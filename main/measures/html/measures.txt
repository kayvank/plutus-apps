-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An abstraction for (tuples of) measured quantities
--   
--   An abstraction for (tuples of) measured quantities
@package measures
@version 0.1.0.1


-- | See <a>Measure</a>
module Data.Measure.Class

-- | A unique maximal measurement
--   
--   <ul>
--   <li><tt>(<a>maxBound</a>, <a>min</a>)</tt> is a bounded
--   meet-semilattice</li>
--   </ul>
class Measure a => BoundedMeasure a

-- | A unique maximal measurement
--   
--   See <a>BoundedMeasure</a> for laws.
maxBound :: BoundedMeasure a => a

-- | Core combinators for a possibly-multidimensional measurement
--   
--   <tt>a</tt> is a fixed set of measurements of a <i>single</i> object.
--   It is not the measurements from multiple objects.
--   
--   <ul>
--   <li><tt>(<a>zero</a>, <a>plus</a>)</tt> is a commutative monoid</li>
--   <li><tt>(<a>zero</a>, <a>max</a>)</tt> is a bounded
--   join-semilattice</li>
--   <li><tt>(<a>min</a>, <a>max</a>)</tt> is a lattice</li>
--   <li><i>lattice-ordered monoid</i> <tt><a>min</a> (<a>plus</a> a b)
--   (<a>plus</a> a c) = a + <a>min</a> b c</tt></li>
--   </ul>
--   
--   Note that the bounded join-semilattice precludes negative (components
--   of) measurements.
class Eq a => Measure a

-- | The measurement of nothing
--   
--   See <a>Measure</a> for laws.
zero :: Measure a => a

-- | Combine two measurements
--   
--   If <tt>a</tt> consists of multiple measurements, this is
--   componentwise.
--   
--   See <a>Measure</a> for laws.
plus :: Measure a => a -> a -> a

-- | The lesser of two measurements
--   
--   If <tt>a</tt> consists of multiple measurements, this is
--   componentwise.
--   
--   See <a>Measure</a> for laws.
min :: Measure a => a -> a -> a

-- | The greater of two measurements
--   
--   If <tt>a</tt> consists of multiple measurements, this is
--   componentwise.
--   
--   See <a>Measure</a> for laws.
max :: Measure a => a -> a -> a

-- | An exception thrown by <a>plus</a> on overflow, since overflow
--   violates <i>lattice-ordered monoid</i>
data DataMeasureClassOverflowException
DataMeasureClassOverflowException :: DataMeasureClassOverflowException
instance GHC.Show.Show Data.Measure.Class.DataMeasureClassOverflowException
instance (Data.Measure.Class.Measure a, Data.Measure.Class.Measure b) => Data.Measure.Class.Measure (a, b)
instance (Data.Measure.Class.Measure a, Data.Measure.Class.Measure b, Data.Measure.Class.Measure c) => Data.Measure.Class.Measure (a, b, c)
instance (Data.Measure.Class.Measure a, Data.Measure.Class.Measure b, Data.Measure.Class.Measure c, Data.Measure.Class.Measure d) => Data.Measure.Class.Measure (a, b, c, d)
instance (Data.Measure.Class.Measure a, Data.Measure.Class.Measure b, Data.Measure.Class.Measure c, Data.Measure.Class.Measure d, Data.Measure.Class.Measure e) => Data.Measure.Class.Measure (a, b, c, d, e)
instance (Data.Measure.Class.Measure a, Data.Measure.Class.Measure b, Data.Measure.Class.Measure c, Data.Measure.Class.Measure d, Data.Measure.Class.Measure e, Data.Measure.Class.Measure f) => Data.Measure.Class.Measure (a, b, c, d, e, f)
instance (Data.Measure.Class.Measure a, Data.Measure.Class.Measure b, Data.Measure.Class.Measure c, Data.Measure.Class.Measure d, Data.Measure.Class.Measure e, Data.Measure.Class.Measure f, Data.Measure.Class.Measure g) => Data.Measure.Class.Measure (a, b, c, d, e, f, g)
instance (GHC.Classes.Eq a, GHC.Generics.Generic a, Data.Measure.Class.GBoundedMeasure (GHC.Generics.Rep a), Data.Measure.Class.GMeasure (GHC.Generics.Rep a)) => Data.Measure.Class.BoundedMeasure (Data.DerivingVia.InstantiatedAt GHC.Generics.Generic a)
instance Data.Measure.Class.BoundedMeasure c => Data.Measure.Class.GBoundedMeasure (GHC.Generics.K1 i c)
instance Data.Measure.Class.GBoundedMeasure f => Data.Measure.Class.GBoundedMeasure (GHC.Generics.M1 i c f)
instance Data.Measure.Class.GBoundedMeasure GHC.Generics.V1
instance Data.Measure.Class.GBoundedMeasure GHC.Generics.U1
instance (Data.Measure.Class.GBoundedMeasure l, Data.Measure.Class.GBoundedMeasure r) => Data.Measure.Class.GBoundedMeasure (l GHC.Generics.:*: r)
instance (TypeError ...) => Data.Measure.Class.GBoundedMeasure (l GHC.Generics.:+: r)
instance (GHC.Classes.Eq a, GHC.Generics.Generic a, Data.Measure.Class.GMeasure (GHC.Generics.Rep a)) => Data.Measure.Class.Measure (Data.DerivingVia.InstantiatedAt GHC.Generics.Generic a)
instance Data.Measure.Class.Measure c => Data.Measure.Class.GMeasure (GHC.Generics.K1 i c)
instance Data.Measure.Class.GMeasure f => Data.Measure.Class.GMeasure (GHC.Generics.M1 i c f)
instance Data.Measure.Class.GMeasure GHC.Generics.V1
instance Data.Measure.Class.GMeasure GHC.Generics.U1
instance (Data.Measure.Class.GMeasure l, Data.Measure.Class.GMeasure r) => Data.Measure.Class.GMeasure (l GHC.Generics.:*: r)
instance (TypeError ...) => Data.Measure.Class.GMeasure (l GHC.Generics.:+: r)
instance GHC.Exception.Type.Exception Data.Measure.Class.DataMeasureClassOverflowException
instance Data.Measure.Class.BoundedMeasure GHC.Word.Word8
instance Data.Measure.Class.BoundedMeasure GHC.Word.Word16
instance Data.Measure.Class.BoundedMeasure GHC.Word.Word32
instance Data.Measure.Class.BoundedMeasure GHC.Word.Word64
instance (GHC.Enum.Bounded a, GHC.Base.Monoid a, GHC.Classes.Ord a) => Data.Measure.Class.BoundedMeasure (Data.DerivingVia.InstantiatedAt GHC.Classes.Ord a)
instance Data.Measure.Class.Measure GHC.Natural.Natural
instance Data.Measure.Class.Measure GHC.Word.Word8
instance Data.Measure.Class.Measure GHC.Word.Word16
instance Data.Measure.Class.Measure GHC.Word.Word32
instance Data.Measure.Class.Measure GHC.Word.Word64
instance Data.Measure.Class.Measure a => GHC.Base.Monoid (Data.DerivingVia.InstantiatedAt Data.Measure.Class.Measure a)
instance Data.Measure.Class.Measure a => GHC.Base.Semigroup (Data.DerivingVia.InstantiatedAt Data.Measure.Class.Measure a)
instance (GHC.Base.Monoid a, GHC.Classes.Ord a) => Data.Measure.Class.Measure (Data.DerivingVia.InstantiatedAt GHC.Classes.Ord a)


-- | Combinators for a possibly-multidimensional measurement
--   
--   The type <tt>(Age, Height)</tt> is archetypal example of
--   <a>Measure</a>. It's typically a fixed-length vector of non-negative "
--   measurements ".
--   
--   The anticipated use-cases involve some notion of a capacity that is
--   limited on a per-dimension basis. Thus the measure of each included
--   candidate quantifies how much of that capacity the candidate would
--   occupy. See eg <a>splitAt</a>.
--   
--   See the <a>Measure</a> class for more.
module Data.Measure

-- | The partial order induced by <a>min</a>
--   
--   It's only true if every component on the left is <tt>&lt;=</tt> the
--   corresponding component on the right.
(<=) :: Measure a => a -> a -> Bool
infix 4 <=

-- | The partial order induced by <a>max</a>
--   
--   It's only true if every component on the left is <tt>&gt;=</tt> the
--   corresponding component on the right.
(>=) :: Measure a => a -> a -> Bool
infix 4 >=

-- | <tt>snd . <a>splitAt</a> measure limit</tt>, with a bit less
--   allocation
drop :: Measure a => (e -> a) -> a -> [e] -> [e]

-- | Split a list once a prefix fills up the given capacity
--   
--   Note that this just splits the given list; it does not attempt
--   anything clever like bin-packing etc.
splitAt :: Measure a => (e -> a) -> a -> [e] -> ([e], [e])

-- | <tt>fst . <a>splitAt</a> measure limit</tt>, but non-strict
take :: Measure a => (e -> a) -> a -> [e] -> [e]
