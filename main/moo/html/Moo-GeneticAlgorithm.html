<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Moo.GeneticAlgorithm</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">moo-1.2.0.0.0.0.1: Genetic algorithm library</span><ul class="links" id="page-menu"><li><a href="src/Moo.GeneticAlgorithm.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>2010-2011 Erlend Hamberg 2011-2013 Sergey Astanin</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Moo.GeneticAlgorithm</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A library for custom genetic algorithms.</p><pre>-----------
Quick Start
-----------
</pre><p>Import</p><ul><li>either <a href="Moo-GeneticAlgorithm-Binary.html">Moo.GeneticAlgorithm.Binary</a></li><li>or <a href="Moo-GeneticAlgorithm-Continuous.html">Moo.GeneticAlgorithm.Continuous</a></li></ul><p>Genetic algorithms are used to find good solutions to optimization
and search problems. They mimic the process of natural evolution
and selection.</p><p>A genetic algorithm deals with a <em>population</em> of candidate solutions.
Each candidate solution is represented with a <code><a href="Moo-GeneticAlgorithm-Types.html#t:Genome" title="Moo.GeneticAlgorithm.Types">Genome</a></code>. On every
iteration the best genomes are <em>selected</em> (<code><a href="Moo-GeneticAlgorithm-Types.html#t:SelectionOp" title="Moo.GeneticAlgorithm.Types">SelectionOp</a></code>). The next
generation is produced through <em>crossover</em> (recombination of the
parents, <code><a href="Moo-GeneticAlgorithm-Types.html#t:CrossoverOp" title="Moo.GeneticAlgorithm.Types">CrossoverOp</a></code>) and <em>mutation</em> (a random change in the genome,
<code><a href="Moo-GeneticAlgorithm-Types.html#t:MutationOp" title="Moo.GeneticAlgorithm.Types">MutationOp</a></code>) of the selected genomes. This process of selection --
crossover -- mutation is repeated until a good solution appears or all
hope is lost.</p><p>Genetic algorithms are often defined in terms of minimizing a cost
function or maximizing fitness. This library refers to observed
performance of a genome as <code><a href="Moo-GeneticAlgorithm-Types.html#t:Objective" title="Moo.GeneticAlgorithm.Types">Objective</a></code>, which can be minimized as well
as maximized.</p><pre>--------------------------------
How to write a genetic algorithm
--------------------------------
</pre><ol><li>Provide an encoding and decoding functions to convert from model
     variables to genomes and back. See <em>How to choose encoding</em> below.</li><li>Write a custom objective function. Its type should be an instance
     of <code><a href="Moo-GeneticAlgorithm-Types.html#t:ObjectiveFunction" title="Moo.GeneticAlgorithm.Types">ObjectiveFunction</a></code> <code>a</code>. Functions of type <code>Genome a -&gt; Objective</code>
     are commonly used.</li><li>Optionally write custom selection (<code><a href="Moo-GeneticAlgorithm-Types.html#t:SelectionOp" title="Moo.GeneticAlgorithm.Types">SelectionOp</a></code>), crossover
     (<code><a href="Moo-GeneticAlgorithm-Types.html#t:CrossoverOp" title="Moo.GeneticAlgorithm.Types">CrossoverOp</a></code>) and mutation (<code><a href="Moo-GeneticAlgorithm-Types.html#t:MutationOp" title="Moo.GeneticAlgorithm.Types">MutationOp</a></code>) operators or just use
     some standard operators provided by this library. Operators specific
     to binary or continuous algorithms are provided by
     <a href="Moo-GeneticAlgorithm-Binary.html">Moo.GeneticAlgorithm.Binary</a> and <a href="Moo-GeneticAlgorithm-Continuous.html">Moo.GeneticAlgorithm.Continuous</a>
     modules respectively.</li><li>Use <code><a href="Moo-GeneticAlgorithm-Run.html#v:nextGeneration" title="Moo.GeneticAlgorithm.Run">nextGeneration</a></code> or <code><a href="Moo-GeneticAlgorithm-Run.html#v:nextSteadyState" title="Moo.GeneticAlgorithm.Run">nextSteadyState</a></code> to create a single step
     of the algorithm, control the iterative process with <code><a href="Moo-GeneticAlgorithm-Run.html#v:loop" title="Moo.GeneticAlgorithm.Run">loop</a></code>,
     <code><a href="Moo-GeneticAlgorithm-Run.html#v:loopWithLog" title="Moo.GeneticAlgorithm.Run">loopWithLog</a></code>, or <code><a href="Moo-GeneticAlgorithm-Run.html#v:loopIO" title="Moo.GeneticAlgorithm.Run">loopIO</a></code>.</li><li>Write a function to generate an initial population; for random
     uniform initialization use <code><a href="Moo-GeneticAlgorithm-Continuous.html#v:getRandomGenomes" title="Moo.GeneticAlgorithm.Continuous">getRandomGenomes</a></code>
     or <code><a href="Moo-GeneticAlgorithm-Binary.html#v:getRandomBinaryGenomes" title="Moo.GeneticAlgorithm.Binary">getRandomBinaryGenomes</a></code>.</li></ol><p>Library functions which need access to random number generator work in
<code><a href="Moo-GeneticAlgorithm-Random.html#t:Rand" title="Moo.GeneticAlgorithm.Random">Rand</a></code> monad.  You may use a high-level wrapper <code><a href="Moo-GeneticAlgorithm-Run.html#v:runGA" title="Moo.GeneticAlgorithm.Run">runGA</a></code> (or
<code><a href="Moo-GeneticAlgorithm-Run.html#v:runIO" title="Moo.GeneticAlgorithm.Run">runIO</a></code> if you used <code><a href="Moo-GeneticAlgorithm-Run.html#v:loopIO" title="Moo.GeneticAlgorithm.Run">loopIO</a></code>), which takes care of creating a new random
number generator and running the entire algorithm.</p><p>To solve constrained optimization problems, modify initialization and
selection operators (see <a href="Moo-GeneticAlgorithm-Constraints.html">Moo.GeneticAlgorithm.Constraints</a>).</p><p>To solve multi-objective optimization problems, use NSGA-II algorithm
(see <a href="Moo-GeneticAlgorithm-Multiobjective.html">Moo.GeneticAlgorithm.Multiobjective</a>).</p><pre>----------------------
How to choose encoding
----------------------
</pre><ul><li>For problems with discrete search space, binary (or Gray)
   encoding of the bit-string is usually used.
   A bit-string is represented as a list of <code>Bool</code> values (<code>[Bool]</code>).
   To build a binary genetic algorithm, import <a href="Moo-GeneticAlgorithm-Binary.html">Moo.GeneticAlgorithm.Binary</a>.</li><li>For problems with continuous search space, it is possible to use a
   vector of real variables as a genome.
   Such a genome is represented as a list of <code>Double</code> or <code>Float</code> values.
   Special crossover and mutation operators should be used.
   To build a continuous genetic algorithm, import
   <a href="Moo-GeneticAlgorithm-Continuous.html">Moo.GeneticAlgorithm.Continuous</a>.</li></ul><pre>--------
Examples
--------
</pre><p>Minimizing Beale's function:</p><pre>import Moo.GeneticAlgorithm.Continuous


beale :: [Double] -&gt; Double
beale [x, y] = (1.5 - x + x*y)**2 + (2.25 - x + x*y*y)**2 + (2.625 - x + x*y*y*y)**2


popsize = 101
elitesize = 1
tolerance = 1e-6


selection = tournamentSelect Minimizing 2 (popsize - elitesize)
crossover = unimodalCrossoverRP
mutation = gaussianMutate 0.25 0.1
step = nextGeneration Minimizing beale selection elitesize crossover mutation
stop = IfObjective (\values -&gt; (minimum values) &lt; tolerance)
initialize = getRandomGenomes popsize [(-4.5, 4.5), (-4.5, 4.5)]


main = do
  population &lt;- runGA initialize (loop stop step)
  print (head . bestFirst Minimizing $ population)
</pre><p>See <code>examples/</code> folder of the source distribution for more examples.</p></div></div><div id="interface"></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>