-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Types and functions for performing numerical calculations.
--   
--   Types and functions for performing numerical calculations.
@package cardano-numeric
@version 2020.12.8

module Cardano.Numeric.Util

-- | Adjusts the source list so that its length is the same as the target
--   list, either by padding the list, or by coalescing a subset of the
--   elements, while preserving the total sum.
--   
--   If the source list is shorter than the target list, this function
--   repeatedly inserts <a>mempty</a> into the list until the desired
--   length has been reached.
--   
--   If the source list is longer than the target list, this function
--   repeatedly coalesces the smallest pair of elements with
--   <a>&lt;&gt;</a> until the desired length has been reached.
--   
--   The resulting list is guaranteed to be sorted into ascending order,
--   and the sum of the elements is guaranteed to be the same as the sum of
--   elements in the source list.
--   
--   Examples (shown with ordinary list notation):
--   
--   <pre>
--   &gt;&gt;&gt; padCoalesce [Sum 1] (replicate 4 ())
--   [Sum 0, Sum 0, Sum 0, Sum 1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; padCoalesce [Sum (-1)] (replicate 4 ())
--   [Sum (-1), Sum 0, Sum 0, Sum 0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; padCoalesce [Sum 8, Sum 4, Sum 2, Sum 1] (replicate 3 ())
--   [Sum 3, Sum 4, Sum 8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; padCoalesce [Sum 8, Sum 4, Sum 2, Sum 1] (replicate 2 ())
--   [Sum 7, Sum 8]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; padCoalesce [Sum 8, Sum 4, Sum 2, Sum 1] (replicate 1 ())
--   [Sum 15]
--   </pre>
padCoalesce :: forall m a. (Monoid m, Ord m) => NonEmpty m -> NonEmpty a -> NonEmpty m

-- | Computes the equipartition of a natural number into <tt>n</tt> smaller
--   numbers.
--   
--   An <i>equipartition</i> of a natural number <tt>n</tt> is a
--   <i>partition</i> of that number into <tt>n</tt> smaller numbers whose
--   values differ by no more than 1.
--   
--   The resultant list is sorted in ascending order.
equipartitionNatural :: HasCallStack => Natural -> NonEmpty a -> NonEmpty Natural

-- | Partitions a natural number into a number of parts, where the size of
--   each part is proportional to the size of its corresponding element in
--   the given list of weights, and the number of parts is equal to the
--   number of weights.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; partitionNatural 9 (1 :| [1, 1])
--   Just (3 :| [3, 3])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partitionNatural 10 (1 :| [])
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; partitionNatural 30 (1 :| [2, 4, 8])
--   Just (2 :| [4, 8, 16])
--   </pre>
--   
--   Pre-condition: there must be at least one non-zero weight.
--   
--   If the pre-condition is not satisfied, this function returns
--   <a>Nothing</a>.
--   
--   If the pre-condition is satisfied, this function guarantees that:
--   
--   <ol>
--   <li>The length of the resulting list is identical to the length of the
--   specified list:<pre>&gt;&gt;&gt; fmap length (partitionNatural n
--   weights) == Just (length weights) </pre></li>
--   <li>The sum of elements in the resulting list is equal to the original
--   natural number:<pre>&gt;&gt;&gt; fmap sum (partitionNatural n weights)
--   == Just n </pre></li>
--   <li>The size of each element in the resulting list is within unity of
--   the ideal proportion.</li>
--   </ol>
partitionNatural :: Natural -> NonEmpty Natural -> Maybe (NonEmpty Natural)

-- | Partitions a natural number into a number of parts, where the size of
--   each part is proportional to the size of its corresponding element in
--   the given list of weights, and the number of parts is equal to the
--   number of weights.
--   
--   Throws a run-time error if the sum of weights is equal to zero.
unsafePartitionNatural :: HasCallStack => Natural -> NonEmpty Natural -> NonEmpty Natural
inAscendingPartialOrder :: (Foldable f, PartialOrd a) => f a -> Bool

-- | Power function where all arguments are of the same type.
--   
--   Helps to avoid the use of boilerplate type annotations.
power :: Integral a => a -> a -> a
instance GHC.Show.Show Cardano.Numeric.Util.RoundingDirection
instance GHC.Classes.Eq Cardano.Numeric.Util.RoundingDirection
