-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The cardano api
@package cardano-api
@version 1.35.4

module Cardano.Api.ChainSync.Client

-- | A chain sync protocol client, on top of some effect <tt>m</tt>. The
--   first choice of request is within that <tt>m</tt>.
newtype ChainSyncClient header point tip (m :: Type -> Type) a
ChainSyncClient :: m (ClientStIdle header point tip m a) -> ChainSyncClient header point tip (m :: Type -> Type) a
[runChainSyncClient] :: ChainSyncClient header point tip (m :: Type -> Type) a -> m (ClientStIdle header point tip m a)

-- | In the <a>StIdle</a> protocol state, the server does not have agency
--   and can choose to send a request next, or a find intersection message.
data ClientStIdle header point tip (m :: Type -> Type) a

-- | Send the <a>MsgRequestNext</a>, with handlers for the replies.
--   
--   The handlers for this message are more complicated than most RPCs
--   because the server can either send us a reply immediately or it can
--   send us a <a>MsgAwaitReply</a> to indicate that the server itself has
--   to block for a state change before it can send us the reply.
--   
--   In the waiting case, the client gets the chance to take a local
--   action.
[SendMsgRequestNext] :: forall header point tip (m :: Type -> Type) a. ClientStNext header point tip m a -> m (ClientStNext header point tip m a) -> ClientStIdle header point tip m a

-- | Send the <a>MsgFindIntersect</a>, with handlers for the replies.
[SendMsgFindIntersect] :: forall point header tip (m :: Type -> Type) a. [point] -> ClientStIntersect header point tip m a -> ClientStIdle header point tip m a

-- | The client decided to end the protocol.
[SendMsgDone] :: forall a header point tip (m :: Type -> Type). a -> ClientStIdle header point tip m a

-- | In the <a>StNext</a> protocol state, the client does not have agency
--   and is waiting to receive either
--   
--   <ul>
--   <li>a roll forward,</li>
--   <li>roll back message,</li>
--   </ul>
--   
--   It must be prepared to handle any of these.
data ClientStNext header point tip (m :: Type -> Type) a
ClientStNext :: (header -> tip -> ChainSyncClient header point tip m a) -> (point -> tip -> ChainSyncClient header point tip m a) -> ClientStNext header point tip (m :: Type -> Type) a
[recvMsgRollForward] :: ClientStNext header point tip (m :: Type -> Type) a -> header -> tip -> ChainSyncClient header point tip m a
[recvMsgRollBackward] :: ClientStNext header point tip (m :: Type -> Type) a -> point -> tip -> ChainSyncClient header point tip m a

-- | In the <a>StIntersect</a> protocol state, the client does not have
--   agency and is waiting to receive:
--   
--   <ul>
--   <li>an intersection improved,</li>
--   <li>unchanged message,</li>
--   <li>the termination message.</li>
--   </ul>
--   
--   It must be prepared to handle any of these.
data ClientStIntersect header point tip (m :: Type -> Type) a
ClientStIntersect :: (point -> tip -> ChainSyncClient header point tip m a) -> (tip -> ChainSyncClient header point tip m a) -> ClientStIntersect header point tip (m :: Type -> Type) a
[recvMsgIntersectFound] :: ClientStIntersect header point tip (m :: Type -> Type) a -> point -> tip -> ChainSyncClient header point tip m a
[recvMsgIntersectNotFound] :: ClientStIntersect header point tip (m :: Type -> Type) a -> tip -> ChainSyncClient header point tip m a

-- | A chain sync client which never sends any message.
chainSyncClientNull :: forall (m :: Type -> Type) header point tip a. MonadTimer m => ChainSyncClient header point tip m a

-- | Transform a <a>ChainSyncClient</a> by mapping over the tx header and
--   the chain tip values.
--   
--   Note the direction of the individual mapping functions corresponds to
--   whether the types are used as protocol inputs or outputs (or both, as
--   is the case for points).
mapChainSyncClient :: forall header header' point point' tip tip' (m :: Type -> Type) a. Functor m => (point -> point') -> (point' -> point) -> (header' -> header) -> (tip' -> tip) -> ChainSyncClient header point tip m a -> ChainSyncClient header' point' tip' m a

module Cardano.Api.ChainSync.ClientPipelined

-- | Pipelined chain sync client. It can only pipeline
--   <a>MsgRequestNext</a> messages, while the <a>MsgFindIntersect</a> are
--   non pipelined. This has a penalty cost of an RTT, but they are send
--   relatively seldom and their response might impact how many messages
--   one would like to pipeline. It also simplifies the receiver callback.
newtype ChainSyncClientPipelined header point tip (m :: Type -> Type) a
ChainSyncClientPipelined :: m (ClientPipelinedStIdle 'Z header point tip m a) -> ChainSyncClientPipelined header point tip (m :: Type -> Type) a
[runChainSyncClientPipelined] :: ChainSyncClientPipelined header point tip (m :: Type -> Type) a -> m (ClientPipelinedStIdle 'Z header point tip m a)

-- | Pipelined sender which starts in <a>StIdle</a> state. It can either
--   
--   <ul>
--   <li>Send <a>MsgRequestNext</a> (no pipelining), which might be useful
--   when we are at the tip of the chain. It can only be send when there is
--   no pipelined message in flight (all responses were collected);</li>
--   <li>Pipeline <a>MsgRequestNext</a>;</li>
--   <li>Send <a>MsgFindIntersect</a> (no pipelining); It can only be send
--   when there is no pipelined message in flight (all responses were
--   collected);</li>
--   <li>Collect responses of pipelined message;</li>
--   <li>Terminate the protocol with by sending <a>MsgDone</a>.</li>
--   </ul>
data ClientPipelinedStIdle (n :: N) header point tip (m :: Type -> Type) a
[SendMsgRequestNext] :: forall header point tip (m :: Type -> Type) a. ClientStNext 'Z header point tip m a -> m (ClientStNext 'Z header point tip m a) -> ClientPipelinedStIdle 'Z header point tip m a
[SendMsgRequestNextPipelined] :: forall (n :: N) header point tip (m :: Type -> Type) a. ClientPipelinedStIdle ('S n) header point tip m a -> ClientPipelinedStIdle n header point tip m a
[SendMsgFindIntersect] :: forall point header tip (m :: Type -> Type) a. [point] -> ClientPipelinedStIntersect header point tip m a -> ClientPipelinedStIdle 'Z header point tip m a
[CollectResponse] :: forall (m :: Type -> Type) (n1 :: N) header point tip a. Maybe (m (ClientPipelinedStIdle ('S n1) header point tip m a)) -> ClientStNext n1 header point tip m a -> ClientPipelinedStIdle ('S n1) header point tip m a
[SendMsgDone] :: forall a header point tip (m :: Type -> Type). a -> ClientPipelinedStIdle 'Z header point tip m a

-- | Callback for responses received after sending <a>MsgRequestNext</a>.
--   
--   We could receive <a>MsgAwaitReply</a>. In this case we will wait for
--   the next message which must be <a>MsgRollForward</a> or
--   <a>MsgRollBackward</a>; thus we need only the two callbacks.
data ClientStNext (n :: N) header point tip (m :: Type -> Type) a
ClientStNext :: (header -> tip -> m (ClientPipelinedStIdle n header point tip m a)) -> (point -> tip -> m (ClientPipelinedStIdle n header point tip m a)) -> ClientStNext (n :: N) header point tip (m :: Type -> Type) a

-- | Callback for <a>MsgRollForward</a> message.
[recvMsgRollForward] :: ClientStNext (n :: N) header point tip (m :: Type -> Type) a -> header -> tip -> m (ClientPipelinedStIdle n header point tip m a)

-- | Callback for <a>MsgRollBackward</a> message.
[recvMsgRollBackward] :: ClientStNext (n :: N) header point tip (m :: Type -> Type) a -> point -> tip -> m (ClientPipelinedStIdle n header point tip m a)

-- | Callbacks for messages received after sending <a>MsgFindIntersect</a>.
--   
--   We might receive either <a>MsgIntersectFound</a> or
--   <a>MsgIntersectNotFound</a>.
data ClientPipelinedStIntersect header point tip (m :: Type -> Type) a
ClientPipelinedStIntersect :: (point -> tip -> m (ClientPipelinedStIdle 'Z header point tip m a)) -> (tip -> m (ClientPipelinedStIdle 'Z header point tip m a)) -> ClientPipelinedStIntersect header point tip (m :: Type -> Type) a
[recvMsgIntersectFound] :: ClientPipelinedStIntersect header point tip (m :: Type -> Type) a -> point -> tip -> m (ClientPipelinedStIdle 'Z header point tip m a)
[recvMsgIntersectNotFound] :: ClientPipelinedStIntersect header point tip (m :: Type -> Type) a -> tip -> m (ClientPipelinedStIdle 'Z header point tip m a)

-- | Data received through pipelining: either roll forward or roll backward
--   instruction. If the server replied with <a>MsgAwaitReply</a> the
--   pipelined receiver will await for the next message which must come
--   with an instruction how to update our chain.
--   
--   Note: internal API, not exposed by this module.
data ChainSyncInstruction header point tip
RollForward :: !header -> !tip -> ChainSyncInstruction header point tip
RollBackward :: !point -> !tip -> ChainSyncInstruction header point tip

-- | Pipeline decision: we can do either one of these:
--   
--   <ul>
--   <li>non-pipelined request</li>
--   <li>pipeline a request</li>
--   <li>collect or pipeline, but only when there are pipelined
--   requests</li>
--   <li>collect, as above, only when there are pipelined requests</li>
--   </ul>
--   
--   There might be other useful pipelining scenarios: collect a given
--   number of requests (which also can be used to collect all outstanding
--   requests).
data PipelineDecision (n :: N)
[Request] :: PipelineDecision 'Z
[Pipeline] :: forall (n :: N). PipelineDecision n
[CollectOrPipeline] :: forall (n1 :: N). PipelineDecision ('S n1)
[Collect] :: forall (n1 :: N). PipelineDecision ('S n1)

-- | The callback gets the following arguments:
--   
--   <ul>
--   <li>how many requests are not yet collected (in flight or already
--   queued)</li>
--   <li>block number of client's tip</li>
--   <li>block number of server's tip</li>
--   </ul>
--   
--   Client's tip block number and server's tip block number can only be
--   equal (from the client's perspective) when both the client's and the
--   server's tip headers agree. If they would not agree (server forked),
--   then the server sends <tt>MsgRollBackward</tt>, which rolls back one
--   block and causes the client's tip and the server's tip to differ.
--   
--   In this module we implement three pipelining strategies:
--   
--   <ul>
--   <li><a>pipelineDecisionMax</a></li>
--   <li><a>pipelineDecisionMin</a></li>
--   <li><a>pipelineDecisionLowHighMark</a></li>
--   </ul>
data MkPipelineDecision
[MkPipelineDecision] :: (forall (n :: N). () => Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> (PipelineDecision n, MkPipelineDecision)) -> MkPipelineDecision
runPipelineDecision :: forall (n :: N). MkPipelineDecision -> Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> (PipelineDecision n, MkPipelineDecision)
constantPipelineDecision :: (forall (n :: N). () => Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> PipelineDecision n) -> MkPipelineDecision

-- | Present maximal pipelining of at most <tt>omax</tt> requests. Collect
--   responses either when we are at the same block number as the server or
--   when we sent more than <tt>omax</tt> requests.
--   
--   If <tt>omax = 3</tt> this pipelining strategy will generate a
--   sequence: <tt> Pipeline Pipeline Pipeline Collect Pipeline Collect
--   .... Pipeline Collect Collect Collect </tt>
pipelineDecisionMax :: forall (n :: N). Word32 -> Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> PipelineDecision n

-- | Present minimum pipelining of at most <tt>omax</tt> requests, collect
--   responses eagerly.
pipelineDecisionMin :: forall (n :: N). Word32 -> Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> PipelineDecision n

-- | Pipelining strategy which pipelines up to <tt>highMark</tt> requests;
--   if the number of pipelined messages exceeds the high mark, it collects
--   messages until there are at most <tt>lowMark</tt> outstanding
--   requests.
pipelineDecisionLowHighMark :: Word32 -> Word32 -> MkPipelineDecision

-- | A type level inductive natural number.
data N
Z :: N
S :: N -> N

-- | A value level inductive natural number, indexed by the corresponding
--   type level natural number <a>N</a>.
--   
--   This is often needed when writing pipelined peers to be able to count
--   the number of outstanding pipelined yields, and show to the type
--   checker that <a>SenderCollect</a> and <a>SenderDone</a> are being used
--   correctly.
data Nat (n :: N)
pattern Zero :: () => 'Z ~ n => Nat n
pattern Succ :: forall m n. () => m ~ 'S n => Nat n -> Nat m
natToInt :: forall (n :: N). Nat n -> Int

-- | Transform a <a>ChainSyncClientPipelined</a> by mapping over the tx
--   header and the chain tip values.
--   
--   Note the direction of the individual mapping functions corresponds to
--   whether the types are used as protocol inputs or outputs (or both, as
--   is the case for points).
mapChainSyncClientPipelined :: forall header header' point point' tip tip' (m :: Type -> Type) a. Functor m => (point -> point') -> (point' -> point) -> (header' -> header) -> (tip' -> tip) -> ChainSyncClientPipelined header point tip m a -> ChainSyncClientPipelined header' point' tip' m a


-- | BIP32-Ed25519 digital signatures.
module Cardano.Api.Crypto.Ed25519Bip32
data Ed25519Bip32DSIGN
data family SigDSIGN v
data family SignKeyDSIGN v
data family VerKeyDSIGN v

-- | Serialise an <a>XPrv</a> to a <a>ByteString</a> (96 bytes).
--   
--   In <tt>cardano-crypto</tt>, an <a>XPrv</a> was originally serialised
--   using the following 128-byte binary format:
--   
--   TODO: table
--   
--   However, this function serialises an <a>XPrv</a> using a more compact
--   96-byte binary format:
--   
--   TODO: table
xPrvToBytes :: XPrv -> ByteString

-- | Deserialise an <a>XPrv</a> from a <a>ByteString</a> (96 bytes).
--   
--   In <tt>cardano-crypto</tt>, an <a>XPrv</a> was originally deserialised
--   using the following 128-byte binary format:
--   
--   TODO: table
--   
--   However, this function deserialises an <a>XPrv</a> using a more
--   compact 96-byte binary format:
--   
--   TODO: table
xPrvFromBytes :: ByteString -> Maybe XPrv
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Data.ByteArray.Types.ByteArrayAccess (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Data.ByteArray.Types.ByteArrayAccess (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.DSIGN.Class.SigDSIGN Cardano.Api.Crypto.Ed25519Bip32.Ed25519Bip32DSIGN)

module Cardano.Api.EraCast
class EraCast (f :: Type -> Type)
eraCast :: (EraCast f, IsCardanoEra fromEra, IsCardanoEra toEra) => CardanoEra toEra -> f fromEra -> Either EraCastError (f toEra)
data EraCastError
EraCastError :: value -> CardanoEra fromEra -> CardanoEra toEra -> EraCastError
[originalValue] :: EraCastError -> value
[fromEra] :: EraCastError -> CardanoEra fromEra
[toEra] :: EraCastError -> CardanoEra toEra

module Cardano.Api.Protocol.Types
data BlockType blk
[ByronBlockType] :: BlockType ByronBlockHFC
[ShelleyBlockType] :: BlockType (ShelleyBlockHFC (TPraos StandardCrypto) StandardShelley)
[CardanoBlockType] :: BlockType (CardanoBlock StandardCrypto)
class (RunNode blk, IOLike m) => Protocol m blk where {
    data family ProtocolInfoArgs m blk;
}
protocolInfo :: Protocol m blk => ProtocolInfoArgs m blk -> ProtocolInfo m blk

-- | Node client support for each consensus protocol.
--   
--   This is like <a>Protocol</a> but for clients of the node, so with less
--   onerous requirements than to run a node.
class RunNode blk => ProtocolClient blk where {
    data family ProtocolClientInfoArgs blk;
}
protocolClientInfo :: ProtocolClient blk => ProtocolClientInfoArgs blk -> ProtocolClientInfo blk
instance GHC.Classes.Eq (Cardano.Api.Protocol.Types.BlockType blk)
instance GHC.Show.Show (Cardano.Api.Protocol.Types.BlockType blk)
instance Cardano.Api.Protocol.Types.ProtocolClient Ouroboros.Consensus.Cardano.ByronHFC.ByronBlockHFC
instance Ouroboros.Consensus.Cardano.CanHardFork.CardanoHardForkConstraints Cardano.Ledger.Crypto.StandardCrypto => Cardano.Api.Protocol.Types.ProtocolClient (Ouroboros.Consensus.Cardano.Block.CardanoBlock Cardano.Ledger.Crypto.StandardCrypto)
instance Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock (Ouroboros.Consensus.Protocol.TPraos.TPraos Cardano.Ledger.Crypto.StandardCrypto) (Cardano.Ledger.Shelley.ShelleyEra Cardano.Ledger.Crypto.StandardCrypto)) => Cardano.Api.Protocol.Types.ProtocolClient (Ouroboros.Consensus.Shelley.ShelleyHFC.ShelleyBlockHFC (Ouroboros.Consensus.Protocol.TPraos.TPraos Cardano.Ledger.Crypto.StandardCrypto) Ouroboros.Consensus.Shelley.Eras.StandardShelley)
instance Ouroboros.Consensus.Util.IOLike.IOLike m => Cardano.Api.Protocol.Types.Protocol m Ouroboros.Consensus.Cardano.ByronHFC.ByronBlockHFC
instance (Ouroboros.Consensus.Cardano.CanHardFork.CardanoHardForkConstraints Cardano.Ledger.Crypto.StandardCrypto, Ouroboros.Consensus.Util.IOLike.IOLike m) => Cardano.Api.Protocol.Types.Protocol m (Ouroboros.Consensus.Cardano.Block.CardanoBlock Cardano.Ledger.Crypto.StandardCrypto)
instance (Ouroboros.Consensus.Util.IOLike.IOLike m, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock (Ouroboros.Consensus.Protocol.TPraos.TPraos Cardano.Ledger.Crypto.StandardCrypto) (Cardano.Ledger.Shelley.ShelleyEra Cardano.Ledger.Crypto.StandardCrypto))) => Cardano.Api.Protocol.Types.Protocol m (Ouroboros.Consensus.Shelley.ShelleyHFC.ShelleyBlockHFC (Ouroboros.Consensus.Protocol.TPraos.TPraos Cardano.Ledger.Crypto.StandardCrypto) Ouroboros.Consensus.Shelley.Eras.StandardShelley)


-- | TextEnvelope Serialisation
module Cardano.Api.SerialiseTextEnvelope
class SerialiseAsCBOR a => HasTextEnvelope a
textEnvelopeType :: HasTextEnvelope a => AsType a -> TextEnvelopeType
textEnvelopeDefaultDescr :: HasTextEnvelope a => a -> TextEnvelopeDescr

-- | A <a>TextEnvelope</a> is a structured envelope for serialised binary
--   values with an external format with a semi-readable textual format.
--   
--   It contains a "type" field, e.g. "PublicKeyByron" or "TxSignedShelley"
--   to indicate the type of the encoded data. This is used as a sanity
--   check and to help readers.
--   
--   It also contains a "title" field which is free-form, and could be used
--   to indicate the role or purpose to a reader.
data TextEnvelope
TextEnvelope :: !TextEnvelopeType -> !TextEnvelopeDescr -> !ByteString -> TextEnvelope
[teType] :: TextEnvelope -> !TextEnvelopeType
[teDescription] :: TextEnvelope -> !TextEnvelopeDescr
[teRawCBOR] :: TextEnvelope -> !ByteString
newtype TextEnvelopeType
TextEnvelopeType :: String -> TextEnvelopeType
newtype TextEnvelopeDescr
TextEnvelopeDescr :: String -> TextEnvelopeDescr
textEnvelopeRawCBOR :: TextEnvelope -> ByteString

-- | The errors that the pure <a>TextEnvelope</a> parsing/decoding
--   functions can return.
data TextEnvelopeError

-- | expected, actual
TextEnvelopeTypeError :: ![TextEnvelopeType] -> !TextEnvelopeType -> TextEnvelopeError
TextEnvelopeDecodeError :: !DecoderError -> TextEnvelopeError
TextEnvelopeAesonDecodeError :: !String -> TextEnvelopeError
serialiseToTextEnvelope :: forall a. HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> TextEnvelope
deserialiseFromTextEnvelope :: HasTextEnvelope a => AsType a -> TextEnvelope -> Either TextEnvelopeError a
readFileTextEnvelope :: HasTextEnvelope a => AsType a -> FilePath -> IO (Either (FileError TextEnvelopeError) a)
writeFileTextEnvelope :: HasTextEnvelope a => FilePath -> Maybe TextEnvelopeDescr -> a -> IO (Either (FileError ()) ())
writeFileTextEnvelopeWithOwnerPermissions :: HasTextEnvelope a => FilePath -> Maybe TextEnvelopeDescr -> a -> IO (Either (FileError ()) ())
readTextEnvelopeFromFile :: FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
readTextEnvelopeOfTypeFromFile :: TextEnvelopeType -> FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
textEnvelopeToJSON :: HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> ByteString
data FromSomeType (c :: Type -> Constraint) b
[FromSomeType] :: c a => AsType a -> (a -> b) -> FromSomeType c b
deserialiseFromTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> TextEnvelope -> Either TextEnvelopeError b
readFileTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> FilePath -> IO (Either (FileError TextEnvelopeError) b)

-- | A family of singleton types used in this API to indicate which type to
--   use where it would otherwise be ambiguous or merely unclear.
--   
--   Values of this type are passed to deserialisation functions for
--   example.
data family AsType t
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.SerialiseTextEnvelope.TextEnvelopeType
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.SerialiseTextEnvelope.TextEnvelopeType
instance GHC.Base.Semigroup Cardano.Api.SerialiseTextEnvelope.TextEnvelopeType
instance Data.String.IsString Cardano.Api.SerialiseTextEnvelope.TextEnvelopeType
instance GHC.Show.Show Cardano.Api.SerialiseTextEnvelope.TextEnvelopeType
instance GHC.Classes.Eq Cardano.Api.SerialiseTextEnvelope.TextEnvelopeType
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.SerialiseTextEnvelope.TextEnvelopeDescr
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.SerialiseTextEnvelope.TextEnvelopeDescr
instance GHC.Base.Semigroup Cardano.Api.SerialiseTextEnvelope.TextEnvelopeDescr
instance Data.String.IsString Cardano.Api.SerialiseTextEnvelope.TextEnvelopeDescr
instance GHC.Show.Show Cardano.Api.SerialiseTextEnvelope.TextEnvelopeDescr
instance GHC.Classes.Eq Cardano.Api.SerialiseTextEnvelope.TextEnvelopeDescr
instance GHC.Show.Show Cardano.Api.SerialiseTextEnvelope.TextEnvelope
instance GHC.Classes.Eq Cardano.Api.SerialiseTextEnvelope.TextEnvelope
instance GHC.Show.Show Cardano.Api.SerialiseTextEnvelope.TextEnvelopeError
instance GHC.Classes.Eq Cardano.Api.SerialiseTextEnvelope.TextEnvelopeError
instance Cardano.Api.Error.Error Cardano.Api.SerialiseTextEnvelope.TextEnvelopeError
instance Cardano.Api.HasTypeProxy.HasTypeProxy Cardano.Api.SerialiseTextEnvelope.TextEnvelope
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.SerialiseTextEnvelope.TextEnvelope
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.SerialiseTextEnvelope.TextEnvelope

module Cardano.Api.Orphans
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.CertIx
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.TxIx
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Slotting.Time.SystemStart
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Slotting.Time.SystemStart
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Mary.Value.Value era)
instance Data.Aeson.Types.ToJSON.ToJSONKey Cardano.Ledger.Mary.Value.AssetName
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Mary.Value.PolicyID era)
instance Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.Mary.Value.PolicyID era)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Mary.Value.AssetName
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.LedgerState.AccountState
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.TxOut era), Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.PParams era), Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.PParamsDelta era)) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.LedgerState.EpochState era)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.TxOut era), Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.PParamsDelta era)) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.LedgerState.LedgerState era)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.LedgerState.IncrementalStake crypto)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.TxOut era), Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.PParamsDelta era)) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.LedgerState.UTxOState era)
instance (Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.PParamsDelta era), Cardano.Ledger.Shelley.Constraints.UsesPParams era) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.LedgerState.PPUPState era)
instance (Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.PParamsDelta era), Cardano.Ledger.Shelley.Constraints.UsesPParams era) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.PParams.PParamsUpdate era)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Babbage.PParams.PParamsUpdate era)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Babbage.PParams.PParams (Cardano.Ledger.Babbage.BabbageEra Cardano.Ledger.Crypto.StandardCrypto))
instance (Cardano.Ledger.Era.Era era, Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.Value era), Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.Data.Datum era), Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.Script era), Cardano.Ledger.Era.Crypto era GHC.Types.~ Cardano.Ledger.Crypto.StandardCrypto) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Babbage.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Era.Crypto era GHC.Types.~ Cardano.Ledger.Crypto.StandardCrypto) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.Data.Datum era)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.Scripts.Script (Cardano.Ledger.Babbage.BabbageEra Cardano.Ledger.Crypto.StandardCrypto))
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.LedgerState.DPState crypto)
instance (Data.Aeson.Types.ToJSON.ToJSON coin, Data.Aeson.Types.ToJSON.ToJSON ptr, Data.Aeson.Types.ToJSON.ToJSON pool) => Data.Aeson.Types.ToJSON.ToJSON (Data.UMap.Trip coin ptr pool)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.UnifiedMap.UnifiedMap crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.LedgerState.DState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.LedgerState.FutureGenDeleg crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Keys.GenDelegs crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.LedgerState.InstantaneousRewards crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Data.BiMap.Bimap Cardano.Ledger.Credential.Ptr (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking crypto))
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Credential.Ptr
instance Data.Aeson.Types.ToJSON.ToJSONKey Cardano.Ledger.Credential.Ptr
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.LedgerState.PState crypto)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.TxOut era)) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.Value era)) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.TxBody.TxOut era)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.TxIn.TxIn crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.TxIn.TxIn crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.PoolRank.Likelihood
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.EpochBoundary.SnapShots crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.EpochBoundary.SnapShot crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.EpochBoundary.Stake crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate crypto)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Coin.DeltaCoin
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.PoolDistr.PoolDistr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.PoolDistr.IndividualPoolStake crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.Rewards.RewardType
instance Cardano.Ledger.Crypto.Crypto c => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.SafeHash.SafeHash c a)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Data.VMap.VMap Data.VMap.VB Data.VMap.VB (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking crypto) (Cardano.Ledger.Keys.KeyHash 'Cardano.Ledger.Keys.StakePool crypto))
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Data.VMap.VMap Data.VMap.VB Data.VMap.VB (Cardano.Ledger.Keys.KeyHash 'Cardano.Ledger.Keys.StakePool crypto) (Cardano.Ledger.Shelley.TxBody.PoolParams crypto))
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Data.VMap.VMap Data.VMap.VB Data.VMap.VP (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking crypto) (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin))


-- | This module provides a library interface for interacting with Cardano
--   as a user of the system.
--   
--   It is intended to be the complete API covering everything but without
--   exposing constructors that reveal any lower level types.
--   
--   In the interest of simplicity it glosses over some details of the
--   system. Most simple tools should be able to work just using this
--   interface, however you can go deeper and expose the types from the
--   underlying libraries using <a>Cardano.Api.Byron</a> or
--   <a>Cardano.Api.Shelley</a>.
module Cardano.Api

-- | A type used as a tag to distinguish the Byron era.
data ByronEra

-- | A type used as a tag to distinguish the Shelley era.
data ShelleyEra

-- | A type used as a tag to distinguish the Allegra era.
data AllegraEra

-- | A type used as a tag to distinguish the Mary era.
data MaryEra

-- | A type used as a tag to distinguish the Alonzo era.
data AlonzoEra

-- | A type used as a tag to distinguish the Babbage era.
data BabbageEra

-- | This GADT provides a value-level representation of all the Cardano
--   eras. This enables pattern matching on the era to allow them to be
--   treated in a non-uniform way.
--   
--   This can be used in combination with the <a>IsCardanoEra</a> class to
--   get access to this value.
--   
--   In combination this can often enable code that handles all eras, and
--   does so uniformly where possible, and non-uniformly where necessary.
data CardanoEra era
[ByronEra] :: CardanoEra ByronEra
[ShelleyEra] :: CardanoEra ShelleyEra
[AllegraEra] :: CardanoEra AllegraEra
[MaryEra] :: CardanoEra MaryEra
[AlonzoEra] :: CardanoEra AlonzoEra
[BabbageEra] :: CardanoEra BabbageEra

-- | The class of Cardano eras. This allows uniform handling of all Cardano
--   eras, but also non-uniform by making case distinctions on the
--   <a>CardanoEra</a> constructors, or the <a>CardanoEraStyle</a>
--   constructors via <a>cardanoEraStyle</a>.
class HasTypeProxy era => IsCardanoEra era
cardanoEra :: IsCardanoEra era => CardanoEra era
data AnyCardanoEra
[AnyCardanoEra] :: IsCardanoEra era => CardanoEra era -> AnyCardanoEra

-- | Like the <a>AnyCardanoEra</a> constructor but does not demand a
--   <a>IsCardanoEra</a> class constraint.
anyCardanoEra :: CardanoEra era -> AnyCardanoEra

-- | This pairs up some era-dependent type with a <a>CardanoEra</a> value
--   that tells us what era it is, but hides the era type. This is useful
--   when the era is not statically known, for example when deserialising
--   from a file.
data InAnyCardanoEra thing
[InAnyCardanoEra] :: IsCardanoEra era => CardanoEra era -> thing era -> InAnyCardanoEra thing

-- | While the Byron and Shelley eras are quite different, there are
--   several eras that are based on Shelley with only minor differences. It
--   is useful to be able to treat the Shelley-based eras in a
--   mostly-uniform way.
--   
--   Values of this type witness the fact that the era is Shelley-based.
--   This can be used to constrain the era to being a Shelley-based on. It
--   allows non-uniform handling making case distinctions on the
--   constructor.
data ShelleyBasedEra era
[ShelleyBasedEraShelley] :: ShelleyBasedEra ShelleyEra
[ShelleyBasedEraAllegra] :: ShelleyBasedEra AllegraEra
[ShelleyBasedEraMary] :: ShelleyBasedEra MaryEra
[ShelleyBasedEraAlonzo] :: ShelleyBasedEra AlonzoEra
[ShelleyBasedEraBabbage] :: ShelleyBasedEra BabbageEra

-- | The class of eras that are based on Shelley. This allows uniform
--   handling of Shelley-based eras, but also non-uniform by making case
--   distinctions on the <a>ShelleyBasedEra</a> constructors.
class IsCardanoEra era => IsShelleyBasedEra era
shelleyBasedEra :: IsShelleyBasedEra era => ShelleyBasedEra era

-- | This pairs up some era-dependent type with a <a>ShelleyBasedEra</a>
--   value that tells us what era it is, but hides the era type. This is
--   useful when the era is not statically known, for example when
--   deserialising from a file.
data InAnyShelleyBasedEra thing
[InAnyShelleyBasedEra] :: IsShelleyBasedEra era => ShelleyBasedEra era -> thing era -> InAnyShelleyBasedEra thing

-- | This is the same essential information as <a>CardanoEra</a> but
--   instead of a flat set of alternative eras, it is factored into the
--   legcy Byron era and the current Shelley-based eras.
--   
--   This way of factoring the eras is useful because in many cases the
--   major differences are between the Byron and Shelley-based eras, and
--   the Shelley-based eras can often be treated uniformly.
data CardanoEraStyle era
[LegacyByronEra] :: CardanoEraStyle ByronEra
[ShelleyBasedEra] :: IsShelleyBasedEra era => ShelleyBasedEra era -> CardanoEraStyle era

-- | The <a>CardanoEraStyle</a> for a <a>CardanoEra</a>.
cardanoEraStyle :: CardanoEra era -> CardanoEraStyle era

-- | Converts a <a>ShelleyBasedEra</a> to the broader <a>CardanoEra</a>.
shelleyBasedToCardanoEra :: ShelleyBasedEra era -> CardanoEra era

-- | <i>Deprecated: Use <a>ByronEra</a> or <tt>ByronAddr</tt> as
--   appropriate</i>
type Byron = ByronEra

-- | <i>Deprecated: Use <a>ShelleyEra</a> or <tt>ShelleyAddr</tt> as
--   appropriate</i>
type Shelley = ShelleyEra

-- | <i>Deprecated: Use <a>AllegraEra</a> instead</i>
type Allegra = AllegraEra

-- | <i>Deprecated: Use <a>MaryEra</a> instead</i>
type Mary = MaryEra
class HasTypeProxy t where {
    
    -- | A family of singleton types used in this API to indicate which type to
    --   use where it would otherwise be ambiguous or merely unclear.
    --   
    --   Values of this type are passed to deserialisation functions for
    --   example.
    data family AsType t;
}
proxyToAsType :: HasTypeProxy t => Proxy t -> AsType t

-- | An interface for cryptographic keys used for signatures with a
--   <a>SigningKey</a> and a <a>VerificationKey</a> key.
--   
--   This interface does not provide actual signing or verifying functions
--   since this API is concerned with the management of keys: generating
--   and serialising.
class (Eq (VerificationKey keyrole), Show (VerificationKey keyrole), SerialiseAsRawBytes (Hash keyrole), HasTextEnvelope (VerificationKey keyrole), HasTextEnvelope (SigningKey keyrole)) => Key keyrole where {
    
    -- | The type of cryptographic verification key, for each key role.
    data family VerificationKey keyrole :: Type;
    
    -- | The type of cryptographic signing key, for each key role.
    data family SigningKey keyrole :: Type;
}

-- | Get the corresponding verification key from a signing key.
getVerificationKey :: Key keyrole => SigningKey keyrole -> VerificationKey keyrole

-- | Generate a <a>SigningKey</a> deterministically, given a <a>Seed</a>.
--   The required size of the seed is given by
--   <a>deterministicSigningKeySeedSize</a>.
deterministicSigningKey :: Key keyrole => AsType keyrole -> Seed -> SigningKey keyrole
deterministicSigningKeySeedSize :: Key keyrole => AsType keyrole -> Word
verificationKeyHash :: Key keyrole => VerificationKey keyrole -> Hash keyrole

-- | Change the role of a <a>VerificationKey</a>, if the representation
--   permits.
castVerificationKey :: CastVerificationKeyRole keyroleA keyroleB => VerificationKey keyroleA -> VerificationKey keyroleB

-- | Change the role of a <a>SigningKey</a>, if the representation permits.
castSigningKey :: CastSigningKeyRole keyroleA keyroleB => SigningKey keyroleA -> SigningKey keyroleB

-- | Generate a <a>SigningKey</a> using a seed from operating system
--   entropy.
generateSigningKey :: Key keyrole => AsType keyrole -> IO (SigningKey keyrole)
data family Hash keyrole :: Type
castHash :: CastHash roleA roleB => Hash roleA -> Hash roleB

-- | Addresses are used as locations where assets live. The address
--   determines the rights needed to spend assets at the address: in
--   particular holding some signing key or being able to satisfy the
--   conditions of a script.
--   
--   There are currently two types of address:
--   
--   <ul>
--   <li>Byron addresses, which use the type tag <a>ByronAddr</a>; and</li>
--   <li>Shelley addresses, which use the type tag <a>ShelleyAddr</a>.
--   Notably, Shelley addresses support scripts and stake delegation.</li>
--   </ul>
--   
--   The <i>address type</i> is subtly from the <i>ledger era</i> in which
--   each address type is valid: while Byron addresses are the only choice
--   in the Byron era, the Shelley era and all subsequent eras support both
--   Byron and Shelley addresses. The <a>Address</a> type param only says
--   the type of the address (either Byron or Shelley). The
--   <a>AddressInEra</a> type connects the address type with the era in
--   which it is supported.
data Address addrtype

-- | A type used as a tag to distinguish Byron addresses.
data ByronAddr

-- | A type used as a tag to distinguish Shelley addresses.
data ShelleyAddr
data NetworkId
Mainnet :: NetworkId
Testnet :: !NetworkMagic -> NetworkId
makeByronAddress :: NetworkId -> VerificationKey ByronKey -> Address ByronAddr

-- | Byron-era payment keys. Used for Byron addresses and witnessing
--   transactions that spend from these addresses.
--   
--   These use Ed25519 but with a 32byte "chaincode" used in HD derivation.
--   The inclusion of the chaincode is a design mistake but one that cannot
--   be corrected for the Byron era. The Shelley era <a>PaymentKey</a>s do
--   not include a chaincode. It is safe to use a zero or random chaincode
--   for new Byron keys.
--   
--   This is a type level tag, used with other interfaces like <a>Key</a>.
data ByronKey
data ByronKeyLegacy
makeShelleyAddress :: NetworkId -> PaymentCredential -> StakeAddressReference -> Address ShelleyAddr
data PaymentCredential
PaymentCredentialByKey :: Hash PaymentKey -> PaymentCredential
PaymentCredentialByScript :: ScriptHash -> PaymentCredential
newtype StakeAddressPointer
StakeAddressPointer :: Ptr -> StakeAddressPointer
[unStakeAddressPointer] :: StakeAddressPointer -> Ptr
data StakeAddressReference
StakeAddressByValue :: StakeCredential -> StakeAddressReference
StakeAddressByPointer :: StakeAddressPointer -> StakeAddressReference
NoStakeAddress :: StakeAddressReference

-- | Shelley-era payment keys. Used for Shelley payment addresses and
--   witnessing transactions that spend from these addresses.
--   
--   This is a type level tag, used with other interfaces like <a>Key</a>.
data PaymentKey

-- | Shelley-era payment keys using extended ed25519 cryptographic keys.
--   
--   They can be used for Shelley payment addresses and witnessing
--   transactions that spend from these addresses.
--   
--   These extended keys are used by HD wallets. So this type provides
--   interoperability with HD wallets. The ITN CLI also supported this key
--   type.
--   
--   The extended verification keys can be converted (via
--   <a>castVerificationKey</a>) to ordinary keys (i.e.
--   <a>VerificationKey</a> <a>PaymentKey</a>) but this is <i>not</i> the
--   case for the signing keys. The signing keys can be used to witness
--   transactions directly, with verification via their non-extended
--   verification key (<a>VerificationKey</a> <a>PaymentKey</a>).
--   
--   This is a type level tag, used with other interfaces like <a>Key</a>.
data PaymentExtendedKey

-- | Either a Byron address or a Shelley address.
--   
--   Sometimes we need to be able to work with either of the two types of
--   address (Byron or Shelley addresses), but without reference to an era
--   in which the address will be used. This type serves that purpose.
data AddressAny
AddressByron :: !Address ByronAddr -> AddressAny
AddressShelley :: !Address ShelleyAddr -> AddressAny
lexPlausibleAddressString :: Parser Text
parseAddressAny :: Parser AddressAny

-- | An <a>Address</a> that can be used in a particular ledger era.
--   
--   All current ledger eras support Byron addresses. Shelley addresses are
--   supported in the <a>ShelleyEra</a> and later eras.
data AddressInEra era
[AddressInEra] :: AddressTypeInEra addrtype era -> Address addrtype -> AddressInEra era

-- | Is the UTxO at the address only spendable via a key witness.
isKeyAddress :: AddressInEra era -> Bool
data AddressTypeInEra addrtype era
[ByronAddressInAnyEra] :: AddressTypeInEra ByronAddr era
[ShelleyAddressInEra] :: ShelleyBasedEra era -> AddressTypeInEra ShelleyAddr era
byronAddressInEra :: Address ByronAddr -> AddressInEra era
shelleyAddressInEra :: IsShelleyBasedEra era => Address ShelleyAddr -> AddressInEra era
anyAddressInShelleyBasedEra :: IsShelleyBasedEra era => AddressAny -> AddressInEra era
anyAddressInEra :: CardanoEra era -> AddressAny -> Maybe (AddressInEra era)
toAddressAny :: Address addr -> AddressAny
makeByronAddressInEra :: NetworkId -> VerificationKey ByronKey -> AddressInEra era
makeShelleyAddressInEra :: IsShelleyBasedEra era => NetworkId -> PaymentCredential -> StakeAddressReference -> AddressInEra era
data StakeAddress
data StakeCredential
makeStakeAddress :: NetworkId -> StakeCredential -> StakeAddress
data StakeKey

-- | Shelley-era stake keys using extended ed25519 cryptographic keys.
--   
--   They can be used for Shelley stake addresses and witnessing
--   transactions that use stake addresses.
--   
--   These extended keys are used by HD wallets. So this type provides
--   interoperability with HD wallets. The ITN CLI also supported this key
--   type.
--   
--   The extended verification keys can be converted (via
--   <a>castVerificationKey</a>) to ordinary keys (i.e.
--   <a>VerificationKey</a> <a>StakeKey</a>) but this is <i>not</i> the
--   case for the signing keys. The signing keys can be used to witness
--   transactions directly, with verification via their non-extended
--   verification key (<a>VerificationKey</a> <a>StakeKey</a>).
--   
--   This is a type level tag, used with other interfaces like <a>Key</a>.
data StakeExtendedKey
newtype Lovelace
Lovelace :: Integer -> Lovelace
newtype Quantity
Quantity :: Integer -> Quantity
newtype PolicyId
PolicyId :: ScriptHash -> PolicyId
[unPolicyId] :: PolicyId -> ScriptHash
scriptPolicyId :: Script lang -> PolicyId
newtype AssetName
AssetName :: ByteString -> AssetName
data AssetId
AdaAssetId :: AssetId
AssetId :: !PolicyId -> !AssetName -> AssetId
data Value

-- | Parse a <a>Value</a> from its string representation.
parseValue :: Parser Value

-- | Policy ID parser.
policyId :: Parser PolicyId
selectAsset :: Value -> AssetId -> Quantity
valueFromList :: [(AssetId, Quantity)] -> Value
valueToList :: Value -> [(AssetId, Quantity)]
filterValue :: (AssetId -> Bool) -> Value -> Value

-- | This lets you write <tt>a - b</tt> as <tt>a &lt;&gt; negateValue
--   b</tt>.
negateValue :: Value -> Value

-- | An alternative nested representation for <a>Value</a> that groups
--   assets that share a <a>PolicyId</a>.
newtype ValueNestedRep
ValueNestedRep :: [ValueNestedBundle] -> ValueNestedRep

-- | A bundle within a <a>ValueNestedRep</a> for a single <a>PolicyId</a>,
--   or for the special case of ada.
data ValueNestedBundle
ValueNestedBundleAda :: Quantity -> ValueNestedBundle
ValueNestedBundle :: PolicyId -> Map AssetName Quantity -> ValueNestedBundle
valueToNestedRep :: Value -> ValueNestedRep
valueFromNestedRep :: ValueNestedRep -> Value

-- | Render a textual representation of a <a>Value</a>.
renderValue :: Value -> Text

-- | Render a "prettified" textual representation of a <a>Value</a>.
renderValuePretty :: Value -> Text
quantityToLovelace :: Quantity -> Lovelace
lovelaceToQuantity :: Lovelace -> Quantity
selectLovelace :: Value -> Lovelace
lovelaceToValue :: Lovelace -> Value

-- | Check if the <a>Value</a> consists of <i>only</i> <a>Lovelace</a> and
--   no other assets, and if so then return the Lovelace.
--   
--   See also <a>selectLovelace</a> to select the Lovelace quantity from
--   the Value, ignoring other assets.
valueToLovelace :: Value -> Maybe Lovelace

-- | A blockchain block in a particular Cardano era.
data Block era

-- | A block consists of a header and a body containing transactions.
pattern Block :: BlockHeader -> [Tx era] -> Block era
data BlockHeader
BlockHeader :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> BlockHeader
getBlockHeader :: forall era. Block era -> BlockHeader
data ChainPoint
ChainPointAtGenesis :: ChainPoint
ChainPoint :: !SlotNo -> !Hash BlockHeader -> ChainPoint

-- | An epoch, i.e. the number of the epoch.
newtype EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64

-- | This is like a <a>ChainPoint</a> but is conventionally used for the
--   tip of the chain: that is the most recent block at the end of the
--   chain.
--   
--   It also carries the <a>BlockNo</a> of the chain tip.
data ChainTip
ChainTipAtGenesis :: ChainTip
ChainTip :: !SlotNo -> !Hash BlockHeader -> !BlockNo -> ChainTip

-- | The 0-based index of the block in the blockchain. BlockNo is &lt;=
--   SlotNo and is only equal at slot N if there is a block for every slot
--   where N &lt;= SlotNo.
newtype BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64
chainTipToChainPoint :: ChainTip -> ChainPoint
data TxBody era
pattern TxBody :: TxBodyContent ViewTx era -> TxBody era
makeTransactionBody :: forall era. IsCardanoEra era => TxBodyContent BuildTx era -> Either TxBodyError (TxBody era)
data TxBodyContent build era
TxBodyContent :: TxIns build era -> TxInsCollateral era -> TxInsReference build era -> [TxOut CtxTx era] -> TxTotalCollateral era -> TxReturnCollateral CtxTx era -> TxFee era -> (TxValidityLowerBound era, TxValidityUpperBound era) -> TxMetadataInEra era -> TxAuxScripts era -> TxExtraKeyWitnesses era -> BuildTxWith build (Maybe ProtocolParameters) -> TxWithdrawals build era -> TxCertificates build era -> TxUpdateProposal era -> TxMintValue build era -> TxScriptValidity era -> TxBodyContent build era
[txIns] :: TxBodyContent build era -> TxIns build era
[txInsCollateral] :: TxBodyContent build era -> TxInsCollateral era
[txInsReference] :: TxBodyContent build era -> TxInsReference build era
[txOuts] :: TxBodyContent build era -> [TxOut CtxTx era]
[txTotalCollateral] :: TxBodyContent build era -> TxTotalCollateral era
[txReturnCollateral] :: TxBodyContent build era -> TxReturnCollateral CtxTx era
[txFee] :: TxBodyContent build era -> TxFee era
[txValidityRange] :: TxBodyContent build era -> (TxValidityLowerBound era, TxValidityUpperBound era)
[txMetadata] :: TxBodyContent build era -> TxMetadataInEra era
[txAuxScripts] :: TxBodyContent build era -> TxAuxScripts era
[txExtraKeyWits] :: TxBodyContent build era -> TxExtraKeyWitnesses era
[txProtocolParams] :: TxBodyContent build era -> BuildTxWith build (Maybe ProtocolParameters)
[txWithdrawals] :: TxBodyContent build era -> TxWithdrawals build era
[txCertificates] :: TxBodyContent build era -> TxCertificates build era
[txUpdateProposal] :: TxBodyContent build era -> TxUpdateProposal era
[txMintValue] :: TxBodyContent build era -> TxMintValue build era
[txScriptValidity] :: TxBodyContent build era -> TxScriptValidity era
data TxBodyError
TxBodyEmptyTxIns :: TxBodyError
TxBodyEmptyTxInsCollateral :: TxBodyError
TxBodyEmptyTxOuts :: TxBodyError
TxBodyOutputNegative :: Quantity -> TxOutInAnyEra -> TxBodyError
TxBodyOutputOverflow :: Quantity -> TxOutInAnyEra -> TxBodyError
TxBodyMetadataError :: [(Word64, TxMetadataRangeError)] -> TxBodyError
TxBodyMintAdaError :: TxBodyError
TxBodyMissingProtocolParams :: TxBodyError
TxBodyInIxOverflow :: TxIn -> TxBodyError
data TxBodyScriptData era
[TxBodyNoScriptData] :: TxBodyScriptData era
[TxBodyScriptData] :: ScriptDataSupportedInEra era -> TxDats (ShelleyLedgerEra era) -> Redeemers (ShelleyLedgerEra era) -> TxBodyScriptData era
newtype TxId
TxId :: Hash StandardCrypto EraIndependentTxBody -> TxId

-- | Calculate the transaction identifier for a <a>TxBody</a>.
getTxId :: forall era. TxBody era -> TxId
data TxIn
TxIn :: TxId -> TxIx -> TxIn
newtype TxIx
TxIx :: Word -> TxIx
renderTxIn :: TxIn -> Text

-- | The context is a transaction body
data CtxTx

-- | The context is the UTxO
data CtxUTxO
data TxOut ctx era
TxOut :: AddressInEra era -> TxOutValue era -> TxOutDatum ctx era -> ReferenceScript era -> TxOut ctx era
data TxOutValue era
[TxOutAdaOnly] :: OnlyAdaSupportedInEra era -> Lovelace -> TxOutValue era
[TxOutValue] :: MultiAssetSupportedInEra era -> Value -> TxOutValue era
txOutValueToLovelace :: TxOutValue era -> Lovelace
txOutValueToValue :: TxOutValue era -> Value
lovelaceToTxOutValue :: IsCardanoEra era => Lovelace -> TxOutValue era
data TxOutDatum ctx era
[TxOutDatumNone] :: TxOutDatum ctx era

-- | A transaction output that only specifies the hash of the datum, but
--   not the full datum value.
[TxOutDatumHash] :: ScriptDataSupportedInEra era -> Hash ScriptData -> TxOutDatum ctx era

-- | A transaction output that specifies the whole datum instead of the
--   datum hash. Note that the datum map will not be updated with this
--   datum, it only exists at the transaction output.
[TxOutDatumInline] :: ReferenceTxInsScriptsInlineDatumsSupportedInEra era -> ScriptData -> TxOutDatum ctx era
pattern TxOutDatumInTx :: ScriptDataSupportedInEra era -> ScriptData -> TxOutDatum CtxTx era
parseHash :: SerialiseAsRawBytes (Hash a) => AsType (Hash a) -> Parser (Hash a)
data TxInsCollateral era
[TxInsCollateralNone] :: TxInsCollateral era
[TxInsCollateral] :: CollateralSupportedInEra era -> [TxIn] -> TxInsCollateral era
data TxInsReference build era
[TxInsReferenceNone] :: TxInsReference build era
[TxInsReference] :: ReferenceTxInsScriptsInlineDatumsSupportedInEra era -> [TxIn] -> TxInsReference build era
data TxTotalCollateral era
[TxTotalCollateralNone] :: TxTotalCollateral era
[TxTotalCollateral] :: TxTotalAndReturnCollateralSupportedInEra era -> Lovelace -> TxTotalCollateral era
data TxReturnCollateral ctx era
[TxReturnCollateralNone] :: TxReturnCollateral ctx era
[TxReturnCollateral] :: TxTotalAndReturnCollateralSupportedInEra era -> TxOut ctx era -> TxReturnCollateral ctx era
data TxFee era
[TxFeeImplicit] :: TxFeesImplicitInEra era -> TxFee era
[TxFeeExplicit] :: TxFeesExplicitInEra era -> Lovelace -> TxFee era
data TxValidityLowerBound era
[TxValidityNoLowerBound] :: TxValidityLowerBound era
[TxValidityLowerBound] :: ValidityLowerBoundSupportedInEra era -> SlotNo -> TxValidityLowerBound era

-- | This was formerly known as the TTL.
data TxValidityUpperBound era
[TxValidityNoUpperBound] :: ValidityNoUpperBoundSupportedInEra era -> TxValidityUpperBound era
[TxValidityUpperBound] :: ValidityUpperBoundSupportedInEra era -> SlotNo -> TxValidityUpperBound era

-- | The 0-based index for the Ourboros time slot.
newtype SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64

-- | The number of slots per epoch.
newtype EpochSlots
EpochSlots :: Word64 -> EpochSlots
[unEpochSlots] :: EpochSlots -> Word64
data TxMetadataInEra era
[TxMetadataNone] :: TxMetadataInEra era
[TxMetadataInEra] :: TxMetadataSupportedInEra era -> TxMetadata -> TxMetadataInEra era
data TxAuxScripts era
[TxAuxScriptsNone] :: TxAuxScripts era
[TxAuxScripts] :: AuxScriptsSupportedInEra era -> [ScriptInEra era] -> TxAuxScripts era
data TxExtraKeyWitnesses era
[TxExtraKeyWitnessesNone] :: TxExtraKeyWitnesses era
[TxExtraKeyWitnesses] :: TxExtraKeyWitnessesSupportedInEra era -> [Hash PaymentKey] -> TxExtraKeyWitnesses era
data TxWithdrawals build era
[TxWithdrawalsNone] :: TxWithdrawals build era
[TxWithdrawals] :: WithdrawalsSupportedInEra era -> [(StakeAddress, Lovelace, BuildTxWith build (Witness WitCtxStake era))] -> TxWithdrawals build era
data TxCertificates build era
[TxCertificatesNone] :: TxCertificates build era
[TxCertificates] :: CertificatesSupportedInEra era -> [Certificate] -> BuildTxWith build (Map StakeCredential (Witness WitCtxStake era)) -> TxCertificates build era
data TxUpdateProposal era
[TxUpdateProposalNone] :: TxUpdateProposal era
[TxUpdateProposal] :: UpdateProposalSupportedInEra era -> UpdateProposal -> TxUpdateProposal era
data TxMintValue build era
[TxMintNone] :: TxMintValue build era
[TxMintValue] :: MultiAssetSupportedInEra era -> Value -> BuildTxWith build (Map PolicyId (ScriptWitness WitCtxMint era)) -> TxMintValue build era
data BuildTxWith build a
[ViewTx] :: BuildTxWith ViewTx a
[BuildTxWith] :: a -> BuildTxWith BuildTx a
data BuildTx
data ViewTx

-- | A representation of whether the era supports transactions with inputs
--   used only for collateral for script fees.
--   
--   The Alonzo and subsequent eras support collateral inputs.
data CollateralSupportedInEra era
[CollateralInAlonzoEra] :: CollateralSupportedInEra AlonzoEra
[CollateralInBabbageEra] :: CollateralSupportedInEra BabbageEra

-- | A representation of whether the era supports multi-asset transactions.
--   
--   The Mary and subsequent eras support multi-asset transactions.
--   
--   The negation of this is <a>OnlyAdaSupportedInEra</a>.
data MultiAssetSupportedInEra era

-- | Multi-asset transactions are supported in the <a>Mary</a> era.
[MultiAssetInMaryEra] :: MultiAssetSupportedInEra MaryEra

-- | Multi-asset transactions are supported in the <tt>Alonzo</tt> era.
[MultiAssetInAlonzoEra] :: MultiAssetSupportedInEra AlonzoEra

-- | Multi-asset transactions are supported in the <tt>Babbage</tt> era.
[MultiAssetInBabbageEra] :: MultiAssetSupportedInEra BabbageEra

-- | A representation of whether the era supports only ada transactions.
--   
--   Prior to the Mary era only ada transactions are supported.
--   Multi-assets are supported from the Mary era onwards.
--   
--   This is the negation of <a>MultiAssetSupportedInEra</a>. It exists
--   since we need evidence to be positive.
data OnlyAdaSupportedInEra era
[AdaOnlyInByronEra] :: OnlyAdaSupportedInEra ByronEra
[AdaOnlyInShelleyEra] :: OnlyAdaSupportedInEra ShelleyEra
[AdaOnlyInAllegraEra] :: OnlyAdaSupportedInEra AllegraEra

-- | A representation of whether the era requires explicitly specified fees
--   in transactions.
--   
--   The Byron era tx fees are implicit (as the difference bettween the sum
--   of outputs and sum of inputs), but all later eras the fees are
--   specified in the transaction explicitly.
data TxFeesExplicitInEra era
[TxFeesExplicitInShelleyEra] :: TxFeesExplicitInEra ShelleyEra
[TxFeesExplicitInAllegraEra] :: TxFeesExplicitInEra AllegraEra
[TxFeesExplicitInMaryEra] :: TxFeesExplicitInEra MaryEra
[TxFeesExplicitInAlonzoEra] :: TxFeesExplicitInEra AlonzoEra
[TxFeesExplicitInBabbageEra] :: TxFeesExplicitInEra BabbageEra

-- | A representation of whether the era requires implicitly specified fees
--   in transactions.
--   
--   This is the negation of <a>TxFeesExplicitInEra</a>.
data TxFeesImplicitInEra era
[TxFeesImplicitInByronEra] :: TxFeesImplicitInEra ByronEra

-- | A representation of whether the era supports transactions with an
--   upper bound on the range of slots in which they are valid.
--   
--   The Shelley and subsequent eras support an upper bound on the validity
--   range. In the Shelley era specifically it is actually required. It is
--   optional in later eras.
data ValidityUpperBoundSupportedInEra era
[ValidityUpperBoundInShelleyEra] :: ValidityUpperBoundSupportedInEra ShelleyEra
[ValidityUpperBoundInAllegraEra] :: ValidityUpperBoundSupportedInEra AllegraEra
[ValidityUpperBoundInMaryEra] :: ValidityUpperBoundSupportedInEra MaryEra
[ValidityUpperBoundInAlonzoEra] :: ValidityUpperBoundSupportedInEra AlonzoEra
[ValidityUpperBoundInBabbageEra] :: ValidityUpperBoundSupportedInEra BabbageEra

-- | A representation of whether the era supports transactions having
--   <i>no</i> upper bound on the range of slots in which they are valid.
--   
--   Note that the <a>ShelleyEra</a> <i>does not support</i> omitting a
--   validity upper bound. It was introduced as a <i>required</i> field in
--   Shelley and then made optional in Allegra and subsequent eras.
--   
--   The Byron era supports this by virtue of the fact that it does not
--   support validity ranges at all.
data ValidityNoUpperBoundSupportedInEra era
[ValidityNoUpperBoundInByronEra] :: ValidityNoUpperBoundSupportedInEra ByronEra
[ValidityNoUpperBoundInAllegraEra] :: ValidityNoUpperBoundSupportedInEra AllegraEra
[ValidityNoUpperBoundInMaryEra] :: ValidityNoUpperBoundSupportedInEra MaryEra
[ValidityNoUpperBoundInAlonzoEra] :: ValidityNoUpperBoundSupportedInEra AlonzoEra
[ValidityNoUpperBoundInBabbageEra] :: ValidityNoUpperBoundSupportedInEra BabbageEra

-- | A representation of whether the era supports transactions with a lower
--   bound on the range of slots in which they are valid.
--   
--   The Allegra and subsequent eras support an optional lower bound on the
--   validity range. No equivalent of
--   <a>ValidityNoUpperBoundSupportedInEra</a> is needed since all eras
--   support having no lower bound.
data ValidityLowerBoundSupportedInEra era
[ValidityLowerBoundInAllegraEra] :: ValidityLowerBoundSupportedInEra AllegraEra
[ValidityLowerBoundInMaryEra] :: ValidityLowerBoundSupportedInEra MaryEra
[ValidityLowerBoundInAlonzoEra] :: ValidityLowerBoundSupportedInEra AlonzoEra
[ValidityLowerBoundInBabbageEra] :: ValidityLowerBoundSupportedInEra BabbageEra

-- | A representation of whether the era supports transaction metadata.
--   
--   Transaction metadata is supported from the Shelley era onwards.
data TxMetadataSupportedInEra era
[TxMetadataInShelleyEra] :: TxMetadataSupportedInEra ShelleyEra
[TxMetadataInAllegraEra] :: TxMetadataSupportedInEra AllegraEra
[TxMetadataInMaryEra] :: TxMetadataSupportedInEra MaryEra
[TxMetadataInAlonzoEra] :: TxMetadataSupportedInEra AlonzoEra
[TxMetadataInBabbageEra] :: TxMetadataSupportedInEra BabbageEra

-- | A representation of whether the era supports auxiliary scripts in
--   transactions.
--   
--   Auxiliary scripts are supported from the Allegra era onwards.
data AuxScriptsSupportedInEra era
[AuxScriptsInAllegraEra] :: AuxScriptsSupportedInEra AllegraEra
[AuxScriptsInMaryEra] :: AuxScriptsSupportedInEra MaryEra
[AuxScriptsInAlonzoEra] :: AuxScriptsSupportedInEra AlonzoEra
[AuxScriptsInBabbageEra] :: AuxScriptsSupportedInEra BabbageEra

-- | A representation of whether the era supports transactions that specify
--   in the body that they need extra key witnesses, and where this fact is
--   visible to scripts.
--   
--   Extra key witnesses visible to scripts are supported from the Alonzo
--   era onwards.
data TxExtraKeyWitnessesSupportedInEra era
[ExtraKeyWitnessesInAlonzoEra] :: TxExtraKeyWitnessesSupportedInEra AlonzoEra
[ExtraKeyWitnessesInBabbageEra] :: TxExtraKeyWitnessesSupportedInEra BabbageEra

-- | A representation of whether the era supports multi-asset transactions.
--   
--   The Mary and subsequent eras support multi-asset transactions.
--   
--   The negation of this is <a>OnlyAdaSupportedInEra</a>.
data ScriptDataSupportedInEra era

-- | Script data is supported in transactions in the <tt>Alonzo</tt> era.
[ScriptDataInAlonzoEra] :: ScriptDataSupportedInEra AlonzoEra
[ScriptDataInBabbageEra] :: ScriptDataSupportedInEra BabbageEra

-- | A representation of whether the era supports withdrawals from reward
--   accounts.
--   
--   The Shelley and subsequent eras support stake addresses, their
--   associated reward accounts and support for withdrawals from them.
data WithdrawalsSupportedInEra era
[WithdrawalsInShelleyEra] :: WithdrawalsSupportedInEra ShelleyEra
[WithdrawalsInAllegraEra] :: WithdrawalsSupportedInEra AllegraEra
[WithdrawalsInMaryEra] :: WithdrawalsSupportedInEra MaryEra
[WithdrawalsInAlonzoEra] :: WithdrawalsSupportedInEra AlonzoEra
[WithdrawalsInBabbageEra] :: WithdrawalsSupportedInEra BabbageEra

-- | A representation of whether the era supports <a>Certificate</a>s
--   embedded in transactions.
--   
--   The Shelley and subsequent eras support such certificates.
data CertificatesSupportedInEra era
[CertificatesInShelleyEra] :: CertificatesSupportedInEra ShelleyEra
[CertificatesInAllegraEra] :: CertificatesSupportedInEra AllegraEra
[CertificatesInMaryEra] :: CertificatesSupportedInEra MaryEra
[CertificatesInAlonzoEra] :: CertificatesSupportedInEra AlonzoEra
[CertificatesInBabbageEra] :: CertificatesSupportedInEra BabbageEra

-- | A representation of whether the era supports <a>UpdateProposal</a>s
--   embedded in transactions.
--   
--   The Shelley and subsequent eras support such update proposals. They
--   Byron era has a notion of an update proposal, but it is a standalone
--   chain object and not embedded in a transaction.
data UpdateProposalSupportedInEra era
[UpdateProposalInShelleyEra] :: UpdateProposalSupportedInEra ShelleyEra
[UpdateProposalInAllegraEra] :: UpdateProposalSupportedInEra AllegraEra
[UpdateProposalInMaryEra] :: UpdateProposalSupportedInEra MaryEra
[UpdateProposalInAlonzoEra] :: UpdateProposalSupportedInEra AlonzoEra
[UpdateProposalInBabbageEra] :: UpdateProposalSupportedInEra BabbageEra
collateralSupportedInEra :: CardanoEra era -> Maybe (CollateralSupportedInEra era)
multiAssetSupportedInEra :: CardanoEra era -> Either (OnlyAdaSupportedInEra era) (MultiAssetSupportedInEra era)
txFeesExplicitInEra :: CardanoEra era -> Either (TxFeesImplicitInEra era) (TxFeesExplicitInEra era)
validityUpperBoundSupportedInEra :: CardanoEra era -> Maybe (ValidityUpperBoundSupportedInEra era)
validityNoUpperBoundSupportedInEra :: CardanoEra era -> Maybe (ValidityNoUpperBoundSupportedInEra era)
validityLowerBoundSupportedInEra :: CardanoEra era -> Maybe (ValidityLowerBoundSupportedInEra era)
txMetadataSupportedInEra :: CardanoEra era -> Maybe (TxMetadataSupportedInEra era)
auxScriptsSupportedInEra :: CardanoEra era -> Maybe (AuxScriptsSupportedInEra era)
extraKeyWitnessesSupportedInEra :: CardanoEra era -> Maybe (TxExtraKeyWitnessesSupportedInEra era)
withdrawalsSupportedInEra :: CardanoEra era -> Maybe (WithdrawalsSupportedInEra era)
certificatesSupportedInEra :: CardanoEra era -> Maybe (CertificatesSupportedInEra era)
updateProposalSupportedInEra :: CardanoEra era -> Maybe (UpdateProposalSupportedInEra era)
scriptDataSupportedInEra :: CardanoEra era -> Maybe (ScriptDataSupportedInEra era)
totalAndReturnCollateralSupportedInEra :: CardanoEra era -> Maybe (TxTotalAndReturnCollateralSupportedInEra era)

-- | For a concrete fully-constructed transaction, determine the minimum
--   fee that it needs to pay.
--   
--   This function is simple, but if you are doing input selection then you
--   probably want to consider estimateTransactionFee.

-- | <i>Deprecated: Use <a>evaluateTransactionFee</a> instead</i>
transactionFee :: forall era. IsShelleyBasedEra era => Natural -> Natural -> Tx era -> Lovelace
toLedgerEpochInfo :: EraHistory mode -> EpochInfo (Either Text)

-- | This can estimate what the transaction fee will be, based on a
--   starting base transaction, plus the numbers of the additional
--   components of the transaction that may be added.
--   
--   So for example with wallet coin selection, the base transaction should
--   contain all the things not subject to coin selection (such as script
--   inputs, metadata, withdrawals, certs etc)
estimateTransactionFee :: forall era. IsShelleyBasedEra era => NetworkId -> Natural -> Natural -> Tx era -> Int -> Int -> Int -> Int -> Lovelace

-- | Compute the transaction fee for a proposed transaction, with the
--   assumption that there will be the given number of key witnesses (i.e.
--   signatures).
--   
--   TODO: we need separate args for Shelley vs Byron key sigs
evaluateTransactionFee :: forall era. IsShelleyBasedEra era => ProtocolParameters -> TxBody era -> Word -> Word -> Lovelace

-- | Give an approximate count of the number of key witnesses (i.e.
--   signatures) a transaction will need.
--   
--   This is an estimate not a precise count in that it can over-estimate:
--   it makes conservative assumptions such as all inputs are from distinct
--   addresses, but in principle multiple inputs can use the same address
--   and we only need a witness per address.
--   
--   Similarly there can be overlap between the regular and collateral
--   inputs, but we conservatively assume they are distinct.
--   
--   TODO: it is worth us considering a more precise count that relies on
--   the UTxO to resolve which inputs are for distinct addresses, and also
--   to count the number of Shelley vs Byron style witnesses.
estimateTransactionKeyWitnessCount :: TxBodyContent BuildTx era -> Word
calculateMinimumUTxO :: ShelleyBasedEra era -> TxOut CtxTx era -> ProtocolParameters -> Either MinimumUTxOError Value
data MinimumUTxOError

-- | Compute the <a>ExecutionUnits</a> needed for each script in the
--   transaction.
--   
--   This works by running all the scripts and counting how many execution
--   units are actually used.
evaluateTransactionExecutionUnits :: forall era mode. EraInMode era mode -> SystemStart -> EraHistory mode -> ProtocolParameters -> UTxO era -> TxBody era -> Either TransactionValidityError (Map ScriptWitnessIndex (Either ScriptExecutionError ExecutionUnits))

-- | The different possible reasons that executing a script can fail, as
--   reported by <a>evaluateTransactionExecutionUnits</a>.
--   
--   The first three of these are about failures before we even get to
--   execute the script, and two are the result of execution.
data ScriptExecutionError

-- | The script depends on a <a>TxIn</a> that has not been provided in the
--   given <a>UTxO</a> subset. The given <a>UTxO</a> must cover all the
--   inputs the transaction references.
ScriptErrorMissingTxIn :: TxIn -> ScriptExecutionError

-- | The <a>TxIn</a> the script is spending does not have a
--   <a>ScriptDatum</a>. All inputs guarded by Plutus scripts need to have
--   been created with a <a>ScriptDatum</a>.
ScriptErrorTxInWithoutDatum :: TxIn -> ScriptExecutionError

-- | The <a>ScriptDatum</a> provided does not match the one from the
--   <a>UTxO</a>. This means the wrong <a>ScriptDatum</a> value has been
--   provided.
ScriptErrorWrongDatum :: Hash ScriptData -> ScriptExecutionError

-- | The script evaluation failed. This usually means it evaluated to an
--   error value. This is not a case of running out of execution units
--   (which is not possible for <a>evaluateTransactionExecutionUnits</a>
--   since the whole point of it is to discover how many execution units
--   are needed).
ScriptErrorEvaluationFailed :: EvaluationError -> [Text] -> ScriptExecutionError

-- | The execution units overflowed a 64bit word. Congratulations if you
--   encounter this error. With the current style of cost model this would
--   need a script to run for over 7 months, which is somewhat more than
--   the expected maximum of a few milliseconds.
ScriptErrorExecutionUnitsOverflow :: ScriptExecutionError

-- | An attempt was made to spend a key witnessed tx input with a script
--   witness.
ScriptErrorNotPlutusWitnessedTxIn :: ScriptWitnessIndex -> ScriptHash -> ScriptExecutionError

-- | The redeemer pointer points to a script hash that does not exist in
--   the transaction nor in the UTxO as a reference script"
ScriptErrorRedeemerPointsToUnknownScriptHash :: ScriptWitnessIndex -> ScriptExecutionError

-- | A redeemer pointer points to a script that does not exist.
ScriptErrorMissingScript :: RdmrPtr -> ResolvablePointers -> ScriptExecutionError

-- | A cost model was missing for a language which was used.
ScriptErrorMissingCostModel :: Language -> ScriptExecutionError
data TransactionValidityError

-- | The transaction validity interval is too far into the future.
--   
--   Transactions with Plutus scripts need to have a validity interval that
--   is not so far in the future that we cannot reliably determine the UTC
--   time corresponding to the validity interval expressed in slot numbers.
--   
--   This is because the Plutus scripts get given the transaction validity
--   interval in UTC time, so that they are not sensitive to slot lengths.
--   
--   If either end of the validity interval is beyond the so called "time
--   horizon" then the consensus algorithm is not able to reliably
--   determine the relationship between slots and time. This is this
--   situation in which this error is reported. For the Cardano mainnet the
--   time horizon is 36 hours beyond the current time. This effectively
--   means we cannot submit check or submit transactions that use Plutus
--   scripts that have the end of their validity interval more than 36
--   hours into the future.
TransactionValidityIntervalError :: PastHorizonException -> TransactionValidityError
TransactionValidityTranslationError :: TranslationError StandardCrypto -> TransactionValidityError
TransactionValidityCostModelError :: Map AnyPlutusScriptVersion CostModel -> String -> TransactionValidityError

-- | Compute the total balance of the proposed transaction. Ultimately a
--   valid transaction must be fully balanced: that is have a total value
--   of zero.
--   
--   Finding the (non-zero) balance of partially constructed transaction is
--   useful for adjusting a transaction to be fully balanced.
evaluateTransactionBalance :: forall era. IsShelleyBasedEra era => ProtocolParameters -> Set PoolId -> UTxO era -> TxBody era -> TxOutValue era

-- | This is much like <a>makeTransactionBody</a> but with greater
--   automation to calculate suitable values for several things.
--   
--   In particular:
--   
--   <ul>
--   <li>It calculates the correct script <a>ExecutionUnits</a> (ignoring
--   the provided values, which can thus be zero).</li>
--   <li>It calculates the transaction fees, based on the script
--   <a>ExecutionUnits</a>, the current <a>ProtocolParameters</a>, and an
--   estimate of the number of key witnesses (i.e. signatures). There is an
--   override for the number of key witnesses.</li>
--   <li>It accepts a change address, calculates the balance of the
--   transaction and puts the excess change into the change output.</li>
--   <li>It also checks that the balance is positive and the change is
--   above the minimum threshold.</li>
--   </ul>
--   
--   To do this it needs more information than <a>makeTransactionBody</a>,
--   all of which can be queried from a local node.
makeTransactionBodyAutoBalance :: forall era mode. IsShelleyBasedEra era => EraInMode era mode -> SystemStart -> EraHistory mode -> ProtocolParameters -> Set PoolId -> UTxO era -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> Either TxBodyErrorAutoBalance (BalancedTxBody era)
data BalancedTxBody era
BalancedTxBody :: TxBody era -> TxOut CtxTx era -> Lovelace -> BalancedTxBody era

-- | The possible errors that can arise from
--   <a>makeTransactionBodyAutoBalance</a>.
data TxBodyErrorAutoBalance

-- | The same errors that can arise from <a>makeTransactionBody</a>.
TxBodyError :: TxBodyError -> TxBodyErrorAutoBalance

-- | One or more of the scripts fails to execute correctly.
TxBodyScriptExecutionError :: [(ScriptWitnessIndex, ScriptExecutionError)] -> TxBodyErrorAutoBalance

-- | One or more of the scripts were expected to fail validation, but none
--   did.
TxBodyScriptBadScriptValidity :: TxBodyErrorAutoBalance

-- | The balance of the non-ada assets is not zero. The <a>Value</a> here
--   is that residual non-zero balance. The
--   <a>makeTransactionBodyAutoBalance</a> function only automatically
--   balances ada, not other assets.
TxBodyErrorAssetBalanceWrong :: Value -> TxBodyErrorAutoBalance

-- | There is not enough ada to cover both the outputs and the fees. The
--   transaction should be changed to provide more input ada, or otherwise
--   adjusted to need less (e.g. outputs, script etc).
TxBodyErrorAdaBalanceNegative :: Lovelace -> TxBodyErrorAutoBalance

-- | Offending TxOut
TxBodyErrorAdaBalanceTooSmall :: TxOutInAnyEra -> Lovelace -> Lovelace -> TxBodyErrorAutoBalance

-- | <a>makeTransactionBodyAutoBalance</a> does not yet support the Byron
--   era.
TxBodyErrorByronEraNotSupported :: TxBodyErrorAutoBalance

-- | The <a>ProtocolParameters</a> must provide the value for the min utxo
--   parameter, for eras that use this parameter.
TxBodyErrorMissingParamMinUTxO :: TxBodyErrorAutoBalance

-- | The transaction validity interval is too far into the future. See
--   <a>TransactionValidityIntervalError</a> for details.
TxBodyErrorValidityInterval :: TransactionValidityError -> TxBodyErrorAutoBalance

-- | Offending TxOut
TxBodyErrorMinUTxONotMet :: TxOutInAnyEra -> Lovelace -> TxBodyErrorAutoBalance
TxBodyErrorMinUTxOMissingPParams :: MinimumUTxOError -> TxBodyErrorAutoBalance
TxBodyErrorNonAdaAssetsUnbalanced :: Value -> TxBodyErrorAutoBalance
TxBodyErrorScriptWitnessIndexMissingFromExecUnitsMap :: ScriptWitnessIndex -> Map ScriptWitnessIndex ExecutionUnits -> TxBodyErrorAutoBalance

-- | A representation of whether the era supports tx script validity.
--   
--   The Mary and subsequent eras support script validity.
data TxScriptValidity era
[TxScriptValidityNone] :: TxScriptValidity era

-- | Tx script validity is supported in transactions in the <tt>Alonzo</tt>
--   era onwards.
[TxScriptValidity] :: TxScriptValiditySupportedInEra era -> ScriptValidity -> TxScriptValidity era

-- | Indicates whether a script is expected to fail or pass validation.
data ScriptValidity

-- | Script is expected to fail validation. Transactions marked as such can
--   include scripts that fail validation. Such transactions may be
--   submitted to the chain, in which case the collateral will be taken
--   upon on chain script validation failure.
ScriptInvalid :: ScriptValidity

-- | Script is expected to pass validation. Transactions marked as such
--   cannot include scripts that fail validation.
ScriptValid :: ScriptValidity
data TxScriptValiditySupportedInEra era
[TxScriptValiditySupportedInAlonzoEra] :: TxScriptValiditySupportedInEra AlonzoEra
[TxScriptValiditySupportedInBabbageEra] :: TxScriptValiditySupportedInEra BabbageEra
scriptValidityToTxScriptValidity :: ShelleyBasedEra era -> ScriptValidity -> TxScriptValidity era
txScriptValiditySupportedInShelleyBasedEra :: ShelleyBasedEra era -> Maybe (TxScriptValiditySupportedInEra era)
txScriptValiditySupportedInCardanoEra :: CardanoEra era -> Maybe (TxScriptValiditySupportedInEra era)
data Tx era
pattern Tx :: TxBody era -> [KeyWitness era] -> Tx era
getTxBody :: forall era. Tx era -> TxBody era
getTxWitnesses :: forall era. Tx era -> [KeyWitness era]
signByronTransaction :: NetworkId -> TxBody ByronEra -> [SigningKey ByronKey] -> Tx ByronEra
signShelleyTransaction :: IsShelleyBasedEra era => TxBody era -> [ShelleyWitnessSigningKey] -> Tx era
makeSignedTransaction :: forall era. [KeyWitness era] -> TxBody era -> Tx era
data KeyWitness era
makeByronKeyWitness :: forall key. IsByronKey key => NetworkId -> TxBody ByronEra -> SigningKey key -> KeyWitness ByronEra
data ShelleyWitnessSigningKey
WitnessPaymentKey :: SigningKey PaymentKey -> ShelleyWitnessSigningKey
WitnessPaymentExtendedKey :: SigningKey PaymentExtendedKey -> ShelleyWitnessSigningKey
WitnessStakeKey :: SigningKey StakeKey -> ShelleyWitnessSigningKey
WitnessStakeExtendedKey :: SigningKey StakeExtendedKey -> ShelleyWitnessSigningKey
WitnessStakePoolKey :: SigningKey StakePoolKey -> ShelleyWitnessSigningKey
WitnessGenesisKey :: SigningKey GenesisKey -> ShelleyWitnessSigningKey
WitnessGenesisExtendedKey :: SigningKey GenesisExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateKey :: SigningKey GenesisDelegateKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateExtendedKey :: SigningKey GenesisDelegateExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisUTxOKey :: SigningKey GenesisUTxOKey -> ShelleyWitnessSigningKey
makeShelleyKeyWitness :: forall era. IsShelleyBasedEra era => TxBody era -> ShelleyWitnessSigningKey -> KeyWitness era
makeShelleyBootstrapWitness :: forall era. IsShelleyBasedEra era => WitnessNetworkIdOrByronAddress -> TxBody era -> SigningKey ByronKey -> KeyWitness era
newtype TxMetadata
TxMetadata :: Map Word64 TxMetadataValue -> TxMetadata
data TxMetadataValue
TxMetaMap :: [(TxMetadataValue, TxMetadataValue)] -> TxMetadataValue
TxMetaList :: [TxMetadataValue] -> TxMetadataValue
TxMetaNumber :: Integer -> TxMetadataValue
TxMetaBytes :: ByteString -> TxMetadataValue
TxMetaText :: Text -> TxMetadataValue
makeTransactionMetadata :: Map Word64 TxMetadataValue -> TxMetadata

-- | Validate transaction metadata. This is for use with existing
--   constructed metadata values, e.g. constructed manually or decoded from
--   CBOR directly.
validateTxMetadata :: TxMetadata -> Either [(Word64, TxMetadataRangeError)] ()

-- | An error in transaction metadata due to an out-of-range value.
data TxMetadataRangeError

-- | The number is outside the maximum range of <tt>-2^64-1 .. 2^64-1</tt>.
TxMetadataNumberOutOfRange :: !Integer -> TxMetadataRangeError

-- | The length of a text string metadatum value exceeds the maximum of 64
--   bytes as UTF8.
TxMetadataTextTooLong :: !Int -> TxMetadataRangeError

-- | The length of a byte string metadatum value exceeds the maximum of 64
--   bytes.
TxMetadataBytesTooLong :: !Int -> TxMetadataRangeError

-- | Tx metadata is similar to JSON but not exactly the same. It has some
--   deliberate limitations such as no support for floating point numbers
--   or special forms for null or boolean values. It also has limitations
--   on the length of strings. On the other hand, unlike JSON, it
--   distinguishes between byte strings and text strings. It also supports
--   any value as map keys rather than just string.
--   
--   We provide two different mappings between tx metadata and JSON, useful
--   for different purposes:
--   
--   <ol>
--   <li>A mapping that allows almost any JSON value to be converted into
--   tx metadata. This does not require a specific JSON schema for the
--   input. It does not expose the full representation capability of tx
--   metadata.</li>
--   <li>A mapping that exposes the full representation capability of tx
--   metadata, but relies on a specific JSON schema for the input
--   JSON.</li>
--   </ol>
--   
--   In the "no schema" mapping, the idea is that (almost) any JSON can be
--   turned into tx metadata and then converted back, without loss. That
--   is, we can round-trip the JSON.
--   
--   The subset of JSON supported is all JSON except: * No null or bool
--   values * No floating point, only integers in the range of a 64bit
--   signed integer * A limitation on string lengths
--   
--   The approach for this mapping is to use whichever representation as tx
--   metadata is most compact. In particular:
--   
--   <ul>
--   <li>JSON lists and maps represented as CBOR lists and maps</li>
--   <li>JSON strings represented as CBOR strings</li>
--   <li>JSON hex strings with "0x" prefix represented as CBOR byte
--   strings</li>
--   <li>JSON integer numbers represented as CBOR signed or unsigned
--   numbers</li>
--   <li>JSON maps with string keys that parse as numbers or hex byte
--   strings, represented as CBOR map keys that are actually numbers or
--   byte strings.</li>
--   </ul>
--   
--   The string length limit depends on whether the hex string
--   representation is used or not. For text strings the limit is 64 bytes
--   for the UTF8 representation of the text string. For byte strings the
--   limit is 64 bytes for the raw byte form (ie not the input hex, but
--   after hex decoding).
--   
--   In the "detailed schema" mapping, the idea is that we expose the full
--   representation capability of the tx metadata in the form of a JSON
--   schema. This means the full representation is available and can be
--   controlled precisely. It also means any tx metadata can be converted
--   into the JSON and back without loss. That is we can round-trip the tx
--   metadata via the JSON and also round-trip schema-compliant JSON via tx
--   metadata.
data TxMetadataJsonSchema

-- | Use the "no schema" mapping between JSON and tx metadata as described
--   above.
TxMetadataJsonNoSchema :: TxMetadataJsonSchema

-- | Use the "detailed schema" mapping between JSON and tx metadata as
--   described above.
TxMetadataJsonDetailedSchema :: TxMetadataJsonSchema

-- | Convert a value from JSON into tx metadata, using the given choice of
--   mapping between JSON and tx metadata.
--   
--   This may fail with a conversion error if the JSON is outside the
--   supported subset for the chosen mapping. See
--   <a>TxMetadataJsonSchema</a> for the details.
metadataFromJson :: TxMetadataJsonSchema -> Value -> Either TxMetadataJsonError TxMetadata

-- | Convert a tx metadata value into JSON , using the given choice of
--   mapping between JSON and tx metadata.
--   
--   This conversion is total but is not necessarily invertible. See
--   <a>TxMetadataJsonSchema</a> for the details.
metadataToJson :: TxMetadataJsonSchema -> TxMetadata -> Value
metadataValueToJsonNoSchema :: TxMetadataValue -> Value
data TxMetadataJsonError
TxMetadataJsonToplevelNotMap :: TxMetadataJsonError
TxMetadataJsonToplevelBadKey :: !Text -> TxMetadataJsonError
TxMetadataJsonSchemaError :: !Word64 -> !Value -> !TxMetadataJsonSchemaError -> TxMetadataJsonError
TxMetadataRangeError :: !Word64 -> !Value -> !TxMetadataRangeError -> TxMetadataJsonError
data TxMetadataJsonSchemaError
TxMetadataJsonNullNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonBoolNotAllowed :: TxMetadataJsonSchemaError
TxMetadataJsonNumberNotInteger :: !Double -> TxMetadataJsonSchemaError
TxMetadataJsonNotObject :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonBadObject :: ![(Text, Value)] -> TxMetadataJsonSchemaError
TxMetadataJsonBadMapPair :: !Value -> TxMetadataJsonSchemaError
TxMetadataJsonTypeMismatch :: !Text -> !Value -> TxMetadataJsonSchemaError
data Certificate
StakeAddressRegistrationCertificate :: StakeCredential -> Certificate
StakeAddressDeregistrationCertificate :: StakeCredential -> Certificate
StakeAddressDelegationCertificate :: StakeCredential -> PoolId -> Certificate
StakePoolRegistrationCertificate :: StakePoolParameters -> Certificate
StakePoolRetirementCertificate :: PoolId -> EpochNo -> Certificate
GenesisKeyDelegationCertificate :: Hash GenesisKey -> Hash GenesisDelegateKey -> Hash VrfKey -> Certificate
MIRCertificate :: MIRPot -> MIRTarget -> Certificate
makeStakeAddressRegistrationCertificate :: StakeCredential -> Certificate
makeStakeAddressDeregistrationCertificate :: StakeCredential -> Certificate
makeStakeAddressDelegationCertificate :: StakeCredential -> PoolId -> Certificate
makeStakePoolRegistrationCertificate :: StakePoolParameters -> Certificate
makeStakePoolRetirementCertificate :: PoolId -> EpochNo -> Certificate
data StakePoolParameters
data StakePoolRelay
data StakePoolMetadataReference

-- | A representation of the required fields for off-chain stake pool
--   metadata.
data StakePoolMetadata

-- | Decode and validate the provided JSON-encoded bytes as
--   <a>StakePoolMetadata</a>. Return the decoded metadata and the hash of
--   the original bytes.
validateAndHashStakePoolMetadata :: ByteString -> Either StakePoolMetadataValidationError (StakePoolMetadata, Hash StakePoolMetadata)

-- | A stake pool metadata validation error.
data StakePoolMetadataValidationError

-- | The original simple script language which supports
--   
--   <ul>
--   <li>require a signature from a given key (by verification key
--   hash)</li>
--   <li>n-way and combinator</li>
--   <li>n-way or combinator</li>
--   <li>m-of-n combinator</li>
--   </ul>
--   
--   This version of the language was introduced in the <a>ShelleyEra</a>.
data SimpleScriptV1

-- | The second version of the simple script language. It has all the
--   features of <a>SimpleScriptV1</a> plus new atomic predicates:
--   
--   <ul>
--   <li>require the time be before a given slot number</li>
--   <li>require the time be after a given slot number</li>
--   </ul>
--   
--   This version of the language was introduced in the <a>AllegraEra</a>.
data SimpleScriptV2

-- | Place holder type to show what the pattern is to extend to multiple
--   languages, not just multiple versions of a single language.
data PlutusScriptV1
data PlutusScriptV2
data ScriptLanguage lang
[SimpleScriptLanguage] :: SimpleScriptVersion lang -> ScriptLanguage lang
[PlutusScriptLanguage] :: PlutusScriptVersion lang -> ScriptLanguage lang
data SimpleScriptVersion lang
[SimpleScriptV1] :: SimpleScriptVersion SimpleScriptV1
[SimpleScriptV2] :: SimpleScriptVersion SimpleScriptV2
data PlutusScriptVersion lang
[PlutusScriptV1] :: PlutusScriptVersion PlutusScriptV1
[PlutusScriptV2] :: PlutusScriptVersion PlutusScriptV2
data AnyScriptLanguage
[AnyScriptLanguage] :: ScriptLanguage lang -> AnyScriptLanguage
data AnyPlutusScriptVersion
[AnyPlutusScriptVersion] :: PlutusScriptVersion lang -> AnyPlutusScriptVersion
class HasTypeProxy lang => IsScriptLanguage lang
scriptLanguage :: IsScriptLanguage lang => ScriptLanguage lang
class IsScriptLanguage lang => IsSimpleScriptLanguage lang
simpleScriptVersion :: IsSimpleScriptLanguage lang => SimpleScriptVersion lang

-- | A script in a particular language.
--   
--   See also <a>ScriptInAnyLang</a> for a script in any of the known
--   languages.
--   
--   See also <a>ScriptInEra</a> for a script in a language that is
--   available within a particular era.
--   
--   Note that some but not all scripts have an external JSON syntax, hence
--   this type has no JSON serialisation instances. The <a>SimpleScript</a>
--   family of languages do have a JSON syntax and thus have
--   <a>ToJSON</a>/<a>FromJSON</a> instances.
data Script lang
[SimpleScript] :: !SimpleScriptVersion lang -> !SimpleScript lang -> Script lang
[PlutusScript] :: !PlutusScriptVersion lang -> !PlutusScript lang -> Script lang

-- | Sometimes it is necessary to handle all languages without making
--   static type distinctions between languages. For example, when reading
--   external input, or before the era context is known.
--   
--   Use <a>toScriptInEra</a> to convert to a script in the context of an
--   era.
data ScriptInAnyLang
[ScriptInAnyLang] :: ScriptLanguage lang -> Script lang -> ScriptInAnyLang

-- | Convert a script in a specific statically-known language to a
--   <a>ScriptInAnyLang</a>.
--   
--   No inverse to this is provided, just do case analysis on the
--   <a>ScriptLanguage</a> field within the <a>ScriptInAnyLang</a>
--   constructor.
toScriptInAnyLang :: Script lang -> ScriptInAnyLang
data ScriptInEra era
[ScriptInEra] :: ScriptLanguageInEra lang era -> Script lang -> ScriptInEra era

-- | Given a target era and a script in some language, check if the
--   language is supported in that era, and if so return a
--   <a>ScriptInEra</a>.
toScriptInEra :: CardanoEra era -> ScriptInAnyLang -> Maybe (ScriptInEra era)
eraOfScriptInEra :: ScriptInEra era -> ShelleyBasedEra era

-- | A tag type for the context in which a script is used in a transaction.
--   
--   This type tags the context as being to witness a transaction input.
data WitCtxTxIn

-- | A tag type for the context in which a script is used in a transaction.
--   
--   This type tags the context as being to witness minting.
data WitCtxMint

-- | A tag type for the context in which a script is used in a transaction.
--   
--   This type tags the context as being to witness the use of stake
--   addresses in both certificates and withdrawals.
data WitCtxStake

-- | This GADT provides a value-level representation of all the witness
--   contexts. This enables pattern matching on the context to allow them
--   to be treated in a non-uniform way.
data WitCtx witctx
[WitCtxTxIn] :: WitCtx WitCtxTxIn
[WitCtxMint] :: WitCtx WitCtxMint
[WitCtxStake] :: WitCtx WitCtxStake

-- | A <i>use</i> of a script within a transaction body to witness that
--   something is being used in an authorised manner. That can be
--   
--   <ul>
--   <li>spending a transaction input</li>
--   <li>minting tokens</li>
--   <li>using a certificate (stake address certs specifically)</li>
--   <li>withdrawing from a reward account</li>
--   </ul>
--   
--   For simple script languages, the use of the script is the same in all
--   contexts. For Plutus scripts, using a script involves supplying a
--   redeemer. In addition, Plutus scripts used for spending inputs must
--   also supply the datum value used when originally creating the TxOut
--   that is now being spent.
data ScriptWitness witctx era
[SimpleScriptWitness] :: ScriptLanguageInEra lang era -> SimpleScriptVersion lang -> SimpleScriptOrReferenceInput lang -> ScriptWitness witctx era
[PlutusScriptWitness] :: ScriptLanguageInEra lang era -> PlutusScriptVersion lang -> PlutusScriptOrReferenceInput lang -> ScriptDatum witctx -> ScriptRedeemer -> ExecutionUnits -> ScriptWitness witctx era
data Witness witctx era
[KeyWitness] :: KeyWitnessInCtx witctx -> Witness witctx era
[ScriptWitness] :: ScriptWitnessInCtx witctx -> ScriptWitness witctx era -> Witness witctx era
data KeyWitnessInCtx witctx
[KeyWitnessForSpending] :: KeyWitnessInCtx WitCtxTxIn
[KeyWitnessForStakeAddr] :: KeyWitnessInCtx WitCtxStake
data ScriptWitnessInCtx witctx
[ScriptWitnessForSpending] :: ScriptWitnessInCtx WitCtxTxIn
[ScriptWitnessForMinting] :: ScriptWitnessInCtx WitCtxMint
[ScriptWitnessForStakeAddr] :: ScriptWitnessInCtx WitCtxStake
data ScriptDatum witctx
[ScriptDatumForTxIn] :: ScriptData -> ScriptDatum WitCtxTxIn
[InlineScriptDatum] :: ScriptDatum WitCtxTxIn
[NoScriptDatumForMint] :: ScriptDatum WitCtxMint
[NoScriptDatumForStake] :: ScriptDatum WitCtxStake
type ScriptRedeemer = ScriptData
scriptWitnessScript :: ScriptWitness witctx era -> Maybe (ScriptInEra era)

-- | A <a>ScriptWitness</a> in any <a>WitCtx</a>. This lets us handle
--   heterogeneous collections of script witnesses from multiple contexts.
data AnyScriptWitness era
[AnyScriptWitness] :: ScriptWitness witctx era -> AnyScriptWitness era

-- | Identify the location of a <a>ScriptWitness</a> within the context of
--   a <a>TxBody</a>. These are indexes of the objects within the
--   transaction that need or can use script witnesses: inputs, minted
--   assets, withdrawals and certificates. These are simple numeric
--   indices, enumerated from zero. Thus the indices are not stable if the
--   transaction body is modified.
data ScriptWitnessIndex

-- | The n'th transaction input, in the order of the <a>TxId</a>s.
ScriptWitnessIndexTxIn :: !Word -> ScriptWitnessIndex

-- | The n'th minting <a>PolicyId</a>, in the order of the
--   <a>PolicyId</a>s.
ScriptWitnessIndexMint :: !Word -> ScriptWitnessIndex

-- | The n'th certificate, in the list order of the certificates.
ScriptWitnessIndexCertificate :: !Word -> ScriptWitnessIndex

-- | The n'th withdrawal, in the order of the <a>StakeAddress</a>s.
ScriptWitnessIndexWithdrawal :: !Word -> ScriptWitnessIndex
renderScriptWitnessIndex :: ScriptWitnessIndex -> String
collectTxBodyScriptWitnesses :: forall era. TxBodyContent BuildTx era -> [(ScriptWitnessIndex, AnyScriptWitness era)]
mapTxScriptWitnesses :: forall era. (forall witctx. ScriptWitnessIndex -> ScriptWitness witctx era -> Either TxBodyErrorAutoBalance (ScriptWitness witctx era)) -> TxBodyContent BuildTx era -> Either TxBodyErrorAutoBalance (TxBodyContent BuildTx era)
data ScriptLanguageInEra lang era
[SimpleScriptV1InShelley] :: ScriptLanguageInEra SimpleScriptV1 ShelleyEra
[SimpleScriptV1InAllegra] :: ScriptLanguageInEra SimpleScriptV1 AllegraEra
[SimpleScriptV1InMary] :: ScriptLanguageInEra SimpleScriptV1 MaryEra
[SimpleScriptV1InAlonzo] :: ScriptLanguageInEra SimpleScriptV1 AlonzoEra
[SimpleScriptV1InBabbage] :: ScriptLanguageInEra SimpleScriptV1 BabbageEra
[SimpleScriptV2InAllegra] :: ScriptLanguageInEra SimpleScriptV2 AllegraEra
[SimpleScriptV2InMary] :: ScriptLanguageInEra SimpleScriptV2 MaryEra
[SimpleScriptV2InAlonzo] :: ScriptLanguageInEra SimpleScriptV2 AlonzoEra
[SimpleScriptV2InBabbage] :: ScriptLanguageInEra SimpleScriptV2 BabbageEra
[PlutusScriptV1InAlonzo] :: ScriptLanguageInEra PlutusScriptV1 AlonzoEra
[PlutusScriptV1InBabbage] :: ScriptLanguageInEra PlutusScriptV1 BabbageEra
[PlutusScriptV2InBabbage] :: ScriptLanguageInEra PlutusScriptV2 BabbageEra

-- | Check if a given script language is supported in a given era, and if
--   so return the evidence.
scriptLanguageSupportedInEra :: CardanoEra era -> ScriptLanguage lang -> Maybe (ScriptLanguageInEra lang era)
languageOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ScriptLanguage lang
eraOfScriptLanguageInEra :: ScriptLanguageInEra lang era -> ShelleyBasedEra era
data SimpleScript lang
[RequireSignature] :: !Hash PaymentKey -> SimpleScript lang
[RequireTimeBefore] :: !TimeLocksSupported lang -> !SlotNo -> SimpleScript lang
[RequireTimeAfter] :: !TimeLocksSupported lang -> !SlotNo -> SimpleScript lang
[RequireAllOf] :: [SimpleScript lang] -> SimpleScript lang
[RequireAnyOf] :: [SimpleScript lang] -> SimpleScript lang
[RequireMOf] :: Int -> [SimpleScript lang] -> SimpleScript lang

-- | Time lock feature in the <a>SimpleScript</a> language.
--   
--   The constructors of this type serve as evidence that the timelocks
--   feature is supported in particular versions of the language.
data TimeLocksSupported lang
[TimeLocksInSimpleScriptV2] :: TimeLocksSupported SimpleScriptV2
timeLocksSupported :: SimpleScriptVersion lang -> Maybe (TimeLocksSupported lang)

-- | Try converting the <a>SimpleScript</a> into a different version of the
--   language.
--   
--   This will work when the script only uses the features of the target
--   language version. For example converting from <a>SimpleScriptV2</a> to
--   <a>SimpleScriptV1</a> will work if the script happens not to use time
--   locks feature. On the other hand converting <a>SimpleScriptV1</a> to
--   <a>SimpleScriptV2</a> will always work because it is backwards
--   compatible.
adjustSimpleScriptVersion :: SimpleScriptVersion lang' -> SimpleScript lang -> Maybe (SimpleScript lang')

-- | Plutus scripts.
--   
--   Note that Plutus scripts have a binary serialisation but no JSON
--   serialisation.
data PlutusScript lang

-- | An example Plutus script that always succeeds, irrespective of inputs.
--   
--   For example, if one were to use this for a payment address then it
--   would allow anyone to spend from it.
--   
--   The exact script depends on the context in which it is to be used.
examplePlutusScriptAlwaysSucceeds :: WitCtx witctx -> PlutusScript PlutusScriptV1

-- | An example Plutus script that always fails, irrespective of inputs.
--   
--   For example, if one were to use this for a payment address then it
--   would be impossible for anyone to ever spend from it.
--   
--   The exact script depends on the context in which it is to be used.
examplePlutusScriptAlwaysFails :: WitCtx witctx -> PlutusScript PlutusScriptV1
data ScriptData
ScriptDataConstructor :: Integer -> [ScriptData] -> ScriptData

-- | Key value pairs
ScriptDataMap :: [(ScriptData, ScriptData)] -> ScriptData

-- | Elements
ScriptDataList :: [ScriptData] -> ScriptData
ScriptDataNumber :: Integer -> ScriptData
ScriptDataBytes :: ByteString -> ScriptData
hashScriptData :: ScriptData -> Hash ScriptData

-- | An error in script data due to an out-of-range value.
data ScriptDataRangeError

-- | The number is outside the maximum range of <tt>-2^64-1 .. 2^64-1</tt>.
ScriptDataNumberOutOfRange :: !Integer -> ScriptDataRangeError

-- | The number is outside the maximum range of <tt>-2^64-1 .. 2^64-1</tt>.
ScriptDataConstructorOutOfRange :: !Integer -> ScriptDataRangeError

-- | The length of a byte string metadatum value exceeds the maximum of 64
--   bytes.
ScriptDataBytesTooLong :: !Int -> ScriptDataRangeError

-- | Validate script data. This is for use with existing constructed script
--   data values, e.g. constructed manually or decoded from CBOR directly.
validateScriptData :: ScriptData -> Either ScriptDataRangeError ()

-- | Script data is similar to JSON but not exactly the same. It has some
--   deliberate limitations such as no support for floating point numbers
--   or special forms for null or boolean values. It also has limitations
--   on the length of strings. On the other hand, unlike JSON, it
--   distinguishes between byte strings and text strings. It also supports
--   any value as map keys rather than just string. It also supports
--   alternatives / tagged unions, used for representing constructors for
--   Plutus data values.
--   
--   We provide two different mappings between script data and JSON, useful
--   for different purposes:
--   
--   <ol>
--   <li>A mapping that allows almost any JSON value to be converted into
--   script data. This does not require a specific JSON schema for the
--   input. It does not expose the full representation capability of script
--   data.</li>
--   <li>A mapping that exposes the full representation capability of
--   script data, but relies on a specific JSON schema for the input
--   JSON.</li>
--   </ol>
--   
--   In the "no schema" mapping, the idea is that (almost) any JSON can be
--   turned into script data and then converted back, without loss. That
--   is, we can round-trip the JSON.
--   
--   The subset of JSON supported is all JSON except: * No null or bool
--   values * No floating point, only integers in the range of a 64bit
--   signed integer * A limitation on string lengths
--   
--   The approach for this mapping is to use whichever representation as
--   script data is most compact. In particular:
--   
--   <ul>
--   <li>JSON lists and maps represented as CBOR lists and maps</li>
--   <li>JSON strings represented as CBOR strings</li>
--   <li>JSON hex strings with "0x" prefix represented as CBOR byte
--   strings</li>
--   <li>JSON integer numbers represented as CBOR signed or unsigned
--   numbers</li>
--   <li>JSON maps with string keys that parse as numbers or hex byte
--   strings, represented as CBOR map keys that are actually numbers or
--   byte strings.</li>
--   </ul>
--   
--   The string length limit depends on whether the hex string
--   representation is used or not. For text strings the limit is 64 bytes
--   for the UTF8 representation of the text string. For byte strings the
--   limit is 64 bytes for the raw byte form (ie not the input hex, but
--   after hex decoding).
--   
--   In the "detailed schema" mapping, the idea is that we expose the full
--   representation capability of the script data in the form of a JSON
--   schema. This means the full representation is available and can be
--   controlled precisely. It also means any script data can be converted
--   into the JSON and back without loss. That is we can round-trip the
--   script data via the JSON and also round-trip schema-compliant JSON via
--   script data.
data ScriptDataJsonSchema

-- | Use the "no schema" mapping between JSON and script data as described
--   above.
ScriptDataJsonNoSchema :: ScriptDataJsonSchema

-- | Use the "detailed schema" mapping between JSON and script data as
--   described above.
ScriptDataJsonDetailedSchema :: ScriptDataJsonSchema

-- | Convert a value from JSON into script data, using the given choice of
--   mapping between JSON and script data.
--   
--   This may fail with a conversion error if the JSON is outside the
--   supported subset for the chosen mapping. See
--   <a>ScriptDataJsonSchema</a> for the details.
scriptDataFromJson :: ScriptDataJsonSchema -> Value -> Either ScriptDataJsonError ScriptData

-- | Convert a script data value into JSON , using the given choice of
--   mapping between JSON and script data.
--   
--   This conversion is total but is not necessarily invertible. See
--   <a>ScriptDataJsonSchema</a> for the details.
scriptDataToJson :: ScriptDataJsonSchema -> ScriptData -> Value
data ScriptDataJsonError
ScriptDataJsonSchemaError :: !Value -> !ScriptDataJsonSchemaError -> ScriptDataJsonError
ScriptDataRangeError :: !Value -> !ScriptDataRangeError -> ScriptDataJsonError
data ScriptDataJsonSchemaError
ScriptDataJsonNullNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonBoolNotAllowed :: ScriptDataJsonSchemaError
ScriptDataJsonNumberNotInteger :: !Double -> ScriptDataJsonSchemaError
ScriptDataJsonNotObject :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonBadObject :: ![(Text, Value)] -> ScriptDataJsonSchemaError
ScriptDataJsonBadMapPair :: !Value -> ScriptDataJsonSchemaError
ScriptDataJsonTypeMismatch :: !Text -> !Value -> ScriptDataJsonSchemaError

-- | The units for how long a script executes for and how much memory it
--   uses. This is used to declare the resources used by a particular use
--   of a script.
--   
--   This type is also used to describe the limits for the maximum overall
--   execution units per transaction or per block.
data ExecutionUnits
ExecutionUnits :: Natural -> Natural -> ExecutionUnits

-- | This corresponds roughly to the time to execute a script.
[executionSteps] :: ExecutionUnits -> Natural

-- | This corresponds roughly to the peak memory used during script
--   execution.
[executionMemory] :: ExecutionUnits -> Natural

-- | The prices for <a>ExecutionUnits</a> as a fraction of a
--   <a>Lovelace</a>.
--   
--   These are used to determine the fee for the use of a script within a
--   transaction, based on the <a>ExecutionUnits</a> needed by the use of
--   the script.
data ExecutionUnitPrices
ExecutionUnitPrices :: Rational -> Rational -> ExecutionUnitPrices
[priceExecutionSteps] :: ExecutionUnitPrices -> Rational
[priceExecutionMemory] :: ExecutionUnitPrices -> Rational
newtype CostModel
CostModel :: Map Text Integer -> CostModel
validateCostModel :: PlutusScriptVersion lang -> CostModel -> Either InvalidCostModel ()

-- | We have this type separate from the <a>Hash</a> type to avoid the
--   script hash type being parametrised by the era. The representation is
--   era independent, and there are many places where we want to use a
--   script hash where we don't want things to be era-parametrised.
data ScriptHash
hashScript :: Script lang -> ScriptHash
class HasTypeProxy a => SerialiseAsCBOR a
class Typeable a => ToCBOR a
class Typeable a => FromCBOR a
serialiseToCBOR :: SerialiseAsCBOR a => a -> ByteString
deserialiseFromCBOR :: SerialiseAsCBOR a => AsType a -> ByteString -> Either DecoderError a

-- | A type that can be converted to JSON.
--   
--   Instances in general <i>must</i> specify <a>toJSON</a> and
--   <i>should</i> (but don't need to) specify <a>toEncoding</a>.
--   
--   An example type and instance:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>ToJSON</a> Coord where
--     <a>toJSON</a> (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   
--     <a>toEncoding</a> (Coord x y) = <tt>pairs</tt> ("x" <a>.=</a> x <a>&lt;&gt;</a> "y" <a>.=</a> y)
--   </pre>
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are two
--   options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>toJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>ToJSON</a> instance. If you
--   require nothing other than <a>defaultOptions</a>, it is sufficient to
--   write (and this is the only alternative where the default
--   <a>toJSON</a> implementation is sufficient):
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toEncoding</a> = <a>genericToEncoding</a> <a>defaultOptions</a>
--   </pre>
--   
--   If on the other hand you wish to customize the generic decoding, you
--   have to implement both methods:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>ToJSON</a> Coord where
--       <a>toJSON</a>     = <a>genericToJSON</a> customOptions
--       <a>toEncoding</a> = <a>genericToEncoding</a> customOptions
--   </pre>
--   
--   Previous versions of this library only had the <a>toJSON</a> method.
--   Adding <a>toEncoding</a> had two reasons:
--   
--   <ol>
--   <li>toEncoding is more efficient for the common case that the output
--   of <a>toJSON</a> is directly serialized to a <tt>ByteString</tt>.
--   Further, expressing either method in terms of the other would be
--   non-optimal.</li>
--   <li>The choice of defaults allows a smooth transition for existing
--   users: Existing instances that do not define <a>toEncoding</a> still
--   compile and have the correct semantics. This is ensured by making the
--   default implementation of <a>toEncoding</a> use <a>toJSON</a>. This
--   produces correct results, but since it performs an intermediate
--   conversion to a <a>Value</a>, it will be less efficient than directly
--   emitting an <a>Encoding</a>. (this also means that specifying nothing
--   more than <tt>instance ToJSON Coord</tt> would be sufficient as a
--   generically decoding instance, but there probably exists no good
--   reason to not specify <a>toEncoding</a> in new instances.)</li>
--   </ol>
class ToJSON a

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   In many cases, you can get the compiler to generate parsing code for
--   you (see below). To begin, let's cover writing an instance by hand.
--   
--   There are various reasons a conversion could fail. For example, an
--   <a>Object</a> could be missing a required key, an <a>Array</a> could
--   be of the wrong size, or a value could be of an incompatible type.
--   
--   The basic ways to signal a failed conversion are as follows:
--   
--   <ul>
--   <li><a>fail</a> yields a custom error message: it is the recommended
--   way of reporting a failure;</li>
--   <li><a>empty</a> (or <a>mzero</a>) is uninformative: use it when the
--   error is meant to be caught by some <tt>(<a>&lt;|&gt;</a>)</tt>;</li>
--   <li><a>typeMismatch</a> can be used to report a failure when the
--   encountered value is not of the expected JSON type; <a>unexpected</a>
--   is an appropriate alternative when more than one type may be expected,
--   or to keep the expected type implicit.</li>
--   </ul>
--   
--   <a>prependFailure</a> (or <a>modifyFailure</a>) add more information
--   to a parser's error messages.
--   
--   An example type and instance using <a>typeMismatch</a> and
--   <a>prependFailure</a>:
--   
--   <pre>
--   -- Allow ourselves to write <a>Text</a> literals.
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> (<a>Object</a> v) = Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   
--       -- We do not expect a non-<a>Object</a> value here.
--       -- We could use <a>empty</a> to fail, but <a>typeMismatch</a>
--       -- gives a much more informative error message.
--       <a>parseJSON</a> invalid    =
--           <a>prependFailure</a> "parsing Coord failed, "
--               (<a>typeMismatch</a> "Object" invalid)
--   </pre>
--   
--   For this common case of only being concerned with a single type of
--   JSON value, the functions <a>withObject</a>, <a>withScientific</a>,
--   etc. are provided. Their use is to be preferred when possible, since
--   they are more terse. Using <a>withObject</a>, we can rewrite the above
--   instance (assuming the same language extension and data type) as:
--   
--   <pre>
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>withObject</a> "Coord" $ \v -&gt; Coord
--           <a>&lt;$&gt;</a> v <a>.:</a> "x"
--           <a>&lt;*&gt;</a> v <a>.:</a> "y"
--   </pre>
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   two options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides Template Haskell functions which
--   will derive an instance at compile time. The generated instance is
--   optimized for your type so it will probably be more efficient than the
--   following option.</li>
--   <li>The compiler can provide a default generic implementation for
--   <a>parseJSON</a>.</li>
--   </ul>
--   
--   To use the second, simply add a <tt>deriving <a>Generic</a></tt>
--   clause to your datatype and declare a <a>FromJSON</a> instance for
--   your datatype without giving a definition for <a>parseJSON</a>.
--   
--   For example, the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import <a>GHC.Generics</a>
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving <a>Generic</a>
--   
--   instance <a>FromJSON</a> Coord
--   </pre>
--   
--   The default implementation will be equivalent to <tt>parseJSON =
--   <a>genericParseJSON</a> <a>defaultOptions</a></tt>; if you need
--   different options, you can customize the generic decoding by defining:
--   
--   <pre>
--   customOptions = <a>defaultOptions</a>
--                   { <a>fieldLabelModifier</a> = <a>map</a> <a>toUpper</a>
--                   }
--   
--   instance <a>FromJSON</a> Coord where
--       <a>parseJSON</a> = <a>genericParseJSON</a> customOptions
--   </pre>
class FromJSON a
serialiseToJSON :: ToJSON a => a -> ByteString
deserialiseFromJSON :: FromJSON a => AsType a -> ByteString -> Either JsonDecodeError a
newtype JsonDecodeError
JsonDecodeError :: String -> JsonDecodeError
readFileJSON :: FromJSON a => AsType a -> FilePath -> IO (Either (FileError JsonDecodeError) a)
writeFileJSON :: ToJSON a => FilePath -> a -> IO (Either (FileError ()) ())
prettyPrintJSON :: ToJSON a => a -> ByteString
class (HasTypeProxy a, SerialiseAsRawBytes a) => SerialiseAsBech32 a
serialiseToBech32 :: SerialiseAsBech32 a => a -> Text
deserialiseFromBech32 :: SerialiseAsBech32 a => AsType a -> Text -> Either Bech32DecodeError a
deserialiseAnyOfFromBech32 :: forall b. [FromSomeType SerialiseAsBech32 b] -> Text -> Either Bech32DecodeError b

-- | Bech32 decoding error.
data Bech32DecodeError

-- | There was an error decoding the string as Bech32.
Bech32DecodingError :: !DecodingError -> Bech32DecodeError

-- | The human-readable prefix in the Bech32-encoded string is not one of
--   the ones expected.
Bech32UnexpectedPrefix :: !Text -> !Set Text -> Bech32DecodeError

-- | There was an error in extracting a <a>ByteString</a> from the data
--   part of the Bech32-encoded string.
Bech32DataPartToBytesError :: !Text -> Bech32DecodeError

-- | There was an error in deserialising the bytes into a value of the
--   expected type.
Bech32DeserialiseFromBytesError :: !ByteString -> Bech32DecodeError

-- | The human-readable prefix in the Bech32-encoded string does not
--   correspond to the prefix that should be used for the payload value.
Bech32WrongPrefix :: !Text -> !Text -> Bech32DecodeError

-- | Address serialisation uses different serialisation formats for
--   different kinds of addresses, so it needs its own class.
--   
--   In particular, Byron addresses are typically formatted in base 58,
--   while Shelley addresses (payment and stake) are formatted using
--   Bech32.
class HasTypeProxy addr => SerialiseAddress addr
serialiseAddress :: SerialiseAddress addr => addr -> Text
deserialiseAddress :: SerialiseAddress addr => AsType addr -> Text -> Maybe addr
class HasTypeProxy a => SerialiseAsRawBytes a
serialiseToRawBytes :: SerialiseAsRawBytes a => a -> ByteString
deserialiseFromRawBytes :: SerialiseAsRawBytes a => AsType a -> ByteString -> Maybe a
serialiseToRawBytesHex :: SerialiseAsRawBytes a => a -> ByteString
deserialiseFromRawBytesHex :: SerialiseAsRawBytes a => AsType a -> ByteString -> Either RawBytesHexError a
serialiseToRawBytesHexText :: SerialiseAsRawBytes a => a -> Text
class SerialiseAsCBOR a => HasTextEnvelope a
textEnvelopeType :: HasTextEnvelope a => AsType a -> TextEnvelopeType
textEnvelopeDefaultDescr :: HasTextEnvelope a => a -> TextEnvelopeDescr

-- | A <a>TextEnvelope</a> is a structured envelope for serialised binary
--   values with an external format with a semi-readable textual format.
--   
--   It contains a "type" field, e.g. "PublicKeyByron" or "TxSignedShelley"
--   to indicate the type of the encoded data. This is used as a sanity
--   check and to help readers.
--   
--   It also contains a "title" field which is free-form, and could be used
--   to indicate the role or purpose to a reader.
data TextEnvelope
TextEnvelope :: !TextEnvelopeType -> !TextEnvelopeDescr -> !ByteString -> TextEnvelope
[teType] :: TextEnvelope -> !TextEnvelopeType
[teDescription] :: TextEnvelope -> !TextEnvelopeDescr
[teRawCBOR] :: TextEnvelope -> !ByteString
newtype TextEnvelopeType
TextEnvelopeType :: String -> TextEnvelopeType
data TextEnvelopeDescr

-- | The errors that the pure <a>TextEnvelope</a> parsing/decoding
--   functions can return.
data TextEnvelopeError

-- | expected, actual
TextEnvelopeTypeError :: ![TextEnvelopeType] -> !TextEnvelopeType -> TextEnvelopeError
TextEnvelopeDecodeError :: !DecoderError -> TextEnvelopeError
TextEnvelopeAesonDecodeError :: !String -> TextEnvelopeError
textEnvelopeRawCBOR :: TextEnvelope -> ByteString
serialiseToTextEnvelope :: forall a. HasTextEnvelope a => Maybe TextEnvelopeDescr -> a -> TextEnvelope
deserialiseFromTextEnvelope :: HasTextEnvelope a => AsType a -> TextEnvelope -> Either TextEnvelopeError a
readFileTextEnvelope :: HasTextEnvelope a => AsType a -> FilePath -> IO (Either (FileError TextEnvelopeError) a)
writeFileTextEnvelope :: HasTextEnvelope a => FilePath -> Maybe TextEnvelopeDescr -> a -> IO (Either (FileError ()) ())
writeFileTextEnvelopeWithOwnerPermissions :: HasTextEnvelope a => FilePath -> Maybe TextEnvelopeDescr -> a -> IO (Either (FileError ()) ())
readTextEnvelopeFromFile :: FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)
readTextEnvelopeOfTypeFromFile :: TextEnvelopeType -> FilePath -> IO (Either (FileError TextEnvelopeError) TextEnvelope)

-- | This GADT allows us to deserialise a tx or key witness without having
--   to provide the era.
data FromSomeTypeCDDL c b
[FromCDDLTx] :: Text -> (InAnyCardanoEra Tx -> b) -> FromSomeTypeCDDL TextEnvelopeCddl b
[FromCDDLWitness] :: Text -> (InAnyCardanoEra KeyWitness -> b) -> FromSomeTypeCDDL TextEnvelopeCddl b
readFileTextEnvelopeCddlAnyOf :: [FromSomeTypeCDDL TextEnvelopeCddl b] -> FilePath -> IO (Either (FileError TextEnvelopeCddlError) b)
writeTxFileTextEnvelopeCddl :: IsCardanoEra era => FilePath -> Tx era -> IO (Either (FileError ()) ())
writeTxWitnessFileTextEnvelopeCddl :: ShelleyBasedEra era -> FilePath -> KeyWitness era -> IO (Either (FileError ()) ())
serialiseTxLedgerCddl :: forall era. IsCardanoEra era => Tx era -> TextEnvelopeCddl
deserialiseTxLedgerCddl :: IsCardanoEra era => CardanoEra era -> TextEnvelopeCddl -> Either TextEnvelopeCddlError (Tx era)
serialiseWitnessLedgerCddl :: forall era. ShelleyBasedEra era -> KeyWitness era -> TextEnvelopeCddl
deserialiseWitnessLedgerCddl :: ShelleyBasedEra era -> TextEnvelopeCddl -> Either TextEnvelopeCddlError (KeyWitness era)
data TextEnvelopeCddlError
TextEnvelopeCddlErrCBORDecodingError :: DecoderError -> TextEnvelopeCddlError
TextEnvelopeCddlAesonDecodeError :: FilePath -> String -> TextEnvelopeCddlError
TextEnvelopeCddlUnknownKeyWitness :: TextEnvelopeCddlError
TextEnvelopeCddlTypeError :: [Text] -> Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrUnknownType :: Text -> TextEnvelopeCddlError
TextEnvelopeCddlErrByronKeyWitnessUnsupported :: TextEnvelopeCddlError
data FromSomeType (c :: Type -> Constraint) b
[FromSomeType] :: c a => AsType a -> (a -> b) -> FromSomeType c b
deserialiseFromTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> TextEnvelope -> Either TextEnvelopeError b
readFileTextEnvelopeAnyOf :: [FromSomeType HasTextEnvelope b] -> FilePath -> IO (Either (FileError TextEnvelopeError) b)
class Show e => Error e
displayError :: Error e => e -> String

-- | The preferred approach is to use <tt>Except</tt> or <tt>ExceptT</tt>,
--   but you can if necessary use IO exceptions.
throwErrorAsException :: Error e => e -> IO a
data FileError e
FileError :: FilePath -> e -> FileError e
FileErrorTempFile :: FilePath -> FilePath -> Handle -> FileError e
FileIOError :: FilePath -> IOException -> FileError e
data Env
Env :: HardForkLedgerConfig (CardanoEras StandardCrypto) -> ConsensusConfig (HardForkProtocol (CardanoEras StandardCrypto)) -> Env
[envLedgerConfig] :: Env -> HardForkLedgerConfig (CardanoEras StandardCrypto)
[envProtocolConfig] :: Env -> ConsensusConfig (HardForkProtocol (CardanoEras StandardCrypto))
envSecurityParam :: Env -> Word64
newtype LedgerState
LedgerState :: LedgerState (HardForkBlock (CardanoEras StandardCrypto)) -> LedgerState
[clsState] :: LedgerState -> LedgerState (HardForkBlock (CardanoEras StandardCrypto))
pattern LedgerStateAlonzo :: LedgerState (ShelleyBlock protocol (AlonzoEra StandardCrypto)) -> LedgerState
pattern LedgerStateMary :: LedgerState (ShelleyBlock protocol (MaryEra StandardCrypto)) -> LedgerState
pattern LedgerStateAllegra :: LedgerState (ShelleyBlock protocol (AllegraEra StandardCrypto)) -> LedgerState
pattern LedgerStateShelley :: LedgerState (ShelleyBlock protocol (ShelleyEra StandardCrypto)) -> LedgerState
pattern LedgerStateByron :: LedgerState ByronBlock -> LedgerState

-- | Get the environment and initial ledger state.
initialLedgerState :: FilePath -> ExceptT InitialLedgerStateError IO (Env, LedgerState)

-- | Apply a single block to the current ledger state.
applyBlock :: Env -> LedgerState -> ValidationMode -> Block era -> Either LedgerStateError (LedgerState, [LedgerEvent])

-- | How to do validation when applying a block to a ledger state.
data ValidationMode

-- | Do all validation implied by the ledger layer's <a>applyBlock</a>.
FullValidation :: ValidationMode

-- | Only check that the previous hash from the block matches the head hash
--   of the ledger state.
QuickValidation :: ValidationMode
data LedgerEvent

-- | The given pool is being registered for the first time on chain.
PoolRegistration :: Certificate -> LedgerEvent

-- | The given pool already exists and is being re-registered.
PoolReRegistration :: Certificate -> LedgerEvent

-- | Incremental rewards are being computed.
IncrementalRewardsDistribution :: EpochNo -> Map StakeCredential (Set (Reward StandardCrypto)) -> LedgerEvent

-- | Reward distribution has completed.
RewardsDistribution :: EpochNo -> Map StakeCredential (Set (Reward StandardCrypto)) -> LedgerEvent

-- | MIR are being distributed.
MIRDistribution :: MIRDistributionDetails -> LedgerEvent

-- | Pools have been reaped and deposits refunded.
PoolReap :: PoolReapDetails -> LedgerEvent

-- | Details of fund transfers due to MIR certificates.
--   
--   Note that the transfers from reserves to treasury and treasury to
--   reserves are inverse; a transfer of 100 ADA in either direction will
--   result in a net movement of 0, but we include both directions for
--   assistance in debugging.
data MIRDistributionDetails
MIRDistributionDetails :: Map StakeCredential Lovelace -> Map StakeCredential Lovelace -> Lovelace -> Lovelace -> MIRDistributionDetails
[mirddReservePayouts] :: MIRDistributionDetails -> Map StakeCredential Lovelace
[mirddTreasuryPayouts] :: MIRDistributionDetails -> Map StakeCredential Lovelace
[mirddReservesToTreasury] :: MIRDistributionDetails -> Lovelace
[mirddTreasuryToReserves] :: MIRDistributionDetails -> Lovelace
data PoolReapDetails
PoolReapDetails :: EpochNo -> Map StakeCredential (Map (Hash StakePoolKey) Lovelace) -> Map StakeCredential (Map (Hash StakePoolKey) Lovelace) -> PoolReapDetails
[prdEpochNo] :: PoolReapDetails -> EpochNo

-- | Refunded deposits. The pools referenced are now retired, and the
--   <a>StakeCredential</a> accounts are credited with the deposits.
[prdRefunded] :: PoolReapDetails -> Map StakeCredential (Map (Hash StakePoolKey) Lovelace)

-- | Unclaimed deposits. The <a>StakeCredential</a> referenced in this map
--   is not actively registered at the time of the pool reaping, and as
--   such the funds are returned to the treasury.
[prdUnclaimed] :: PoolReapDetails -> Map StakeCredential (Map (Hash StakePoolKey) Lovelace)
toLedgerEvent :: ConvertLedgerEvent blk => WrapLedgerEvent blk -> Maybe LedgerEvent

-- | Monadic fold over all blocks and ledger states. Stopping <tt>k</tt>
--   blocks before the node's tip where <tt>k</tt> is the security
--   parameter.
foldBlocks :: forall a. FilePath -> FilePath -> ValidationMode -> a -> (Env -> LedgerState -> [LedgerEvent] -> BlockInMode CardanoMode -> a -> IO a) -> ExceptT FoldBlocksError IO a

-- | Wrap a <tt>ChainSyncClient</tt> with logic that tracks the ledger
--   state.
chainSyncClientWithLedgerState :: forall m a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClient (BlockInMode CardanoMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClient (BlockInMode CardanoMode) ChainPoint ChainTip m a

-- | See <a>chainSyncClientWithLedgerState</a>.
chainSyncClientPipelinedWithLedgerState :: forall m a. Monad m => Env -> LedgerState -> ValidationMode -> ChainSyncClientPipelined (BlockInMode CardanoMode, Either LedgerStateError (LedgerState, [LedgerEvent])) ChainPoint ChainTip m a -> ChainSyncClientPipelined (BlockInMode CardanoMode) ChainPoint ChainTip m a
data LedgerStateError

-- | When using QuickValidation, the block hash did not match the expected
--   block hash after applying a new block to the current ledger state.
ApplyBlockHashMismatch :: Text -> LedgerStateError

-- | When using FullValidation, an error occurred when applying a new block
--   to the current ledger state.
ApplyBlockError :: HardForkLedgerError (CardanoEras StandardCrypto) -> LedgerStateError

-- | Encountered a rollback larger than the security parameter.
InvalidRollback :: SlotNo -> ChainPoint -> LedgerStateError
data FoldBlocksError
FoldBlocksInitialLedgerStateError :: InitialLedgerStateError -> FoldBlocksError
FoldBlocksApplyBlockError :: LedgerStateError -> FoldBlocksError
data GenesisConfigError
NEError :: !Text -> GenesisConfigError
NEByronConfig :: !FilePath -> !ConfigurationError -> GenesisConfigError
NEShelleyConfig :: !FilePath -> !Text -> GenesisConfigError
NEAlonzoConfig :: !FilePath -> !Text -> GenesisConfigError
NECardanoConfig :: !Text -> GenesisConfigError
data InitialLedgerStateError

-- | Failed to read or parse the network config file.
ILSEConfigFile :: Text -> InitialLedgerStateError

-- | Failed to read or parse a genesis file linked from the network config
--   file.
ILSEGenesisFile :: GenesisConfigError -> InitialLedgerStateError

-- | Failed to derive the Ledger or Consensus config.
ILSELedgerConsensusConfig :: GenesisConfigError -> InitialLedgerStateError
renderLedgerStateError :: LedgerStateError -> Text
renderFoldBlocksError :: FoldBlocksError -> Text
renderGenesisConfigError :: GenesisConfigError -> Text
renderInitialLedgerStateError :: InitialLedgerStateError -> Text

-- | Establish a connection to a local node and execute the given set of
--   protocol handlers.
connectToLocalNode :: LocalNodeConnectInfo mode -> LocalNodeClientProtocolsInMode mode -> IO ()

-- | Establish a connection to a local node and execute the given set of
--   protocol handlers parameterized on the negotiated node-to-client
--   protocol version.
connectToLocalNodeWithVersion :: LocalNodeConnectInfo mode -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode mode) -> IO ()
data LocalNodeConnectInfo mode
LocalNodeConnectInfo :: ConsensusModeParams mode -> NetworkId -> FilePath -> LocalNodeConnectInfo mode
[localConsensusModeParams] :: LocalNodeConnectInfo mode -> ConsensusModeParams mode
[localNodeNetworkId] :: LocalNodeConnectInfo mode -> NetworkId
[localNodeSocketPath] :: LocalNodeConnectInfo mode -> FilePath
data AnyConsensusMode
[AnyConsensusMode] :: ConsensusMode mode -> AnyConsensusMode
renderMode :: AnyConsensusMode -> Text

-- | This GADT provides a value-level representation of all the consensus
--   modes. This enables pattern matching on the era to allow them to be
--   treated in a non-uniform way.
data ConsensusMode mode
[CardanoMode] :: ConsensusMode CardanoMode
consensusModeOnly :: ConsensusModeParams mode -> ConsensusMode mode

-- | The subset of consensus modes that consist of multiple eras. Some
--   features are not supported in single-era modes (for exact
--   compatibility without using the hard fork combination at all).
data ConsensusModeIsMultiEra mode
[CardanoModeIsMultiEra] :: ConsensusModeIsMultiEra CardanoMode
data AnyConsensusModeParams
[AnyConsensusModeParams] :: ConsensusModeParams mode -> AnyConsensusModeParams

-- | The consensus-mode-specific parameters needed to connect to a local
--   node that is using each consensus mode.
--   
--   It is in fact only the Byron era that requires extra parameters, but
--   this is of course inherited by the <a>CardanoMode</a> that uses the
--   Byron era. The reason this parameter is needed stems from unfortunate
--   design decisions from the legacy Byron era. The slots per epoch are
--   needed to be able to <i>decode</i> epoch boundary blocks from the
--   Byron era.
--   
--   It is possible in future that we may be able to eliminate this
--   parameter by discovering it from the node during the initial
--   handshake.
data ConsensusModeParams mode
[ByronModeParams] :: EpochSlots -> ConsensusModeParams ByronMode
[ShelleyModeParams] :: ConsensusModeParams ShelleyMode
[CardanoModeParams] :: EpochSlots -> ConsensusModeParams CardanoMode
type family ConsensusProtocol era
type family ChainDepStateProtocol era

-- | A closed type family that maps between the consensus mode (from this
--   API) and the block type used by the consensus libraries.
type family ConsensusBlockForMode mode
type family ConsensusBlockForEra era

-- | A representation of which <a>CardanoEra</a>s are included in each
--   <a>ConsensusMode</a>.
data EraInMode era mode
[ByronEraInByronMode] :: EraInMode ByronEra ByronMode
[ShelleyEraInShelleyMode] :: EraInMode ShelleyEra ShelleyMode
[ByronEraInCardanoMode] :: EraInMode ByronEra CardanoMode
[ShelleyEraInCardanoMode] :: EraInMode ShelleyEra CardanoMode
[AllegraEraInCardanoMode] :: EraInMode AllegraEra CardanoMode
[MaryEraInCardanoMode] :: EraInMode MaryEra CardanoMode
[AlonzoEraInCardanoMode] :: EraInMode AlonzoEra CardanoMode
[BabbageEraInCardanoMode] :: EraInMode BabbageEra CardanoMode
toEraInMode :: CardanoEra era -> ConsensusMode mode -> Maybe (EraInMode era mode)

-- | The protocols we can use with a local node. Use in conjunction with
--   <a>connectToLocalNode</a>.
--   
--   These protocols use the types from the rest of this API. The
--   conversion to/from the types used by the underlying wire formats is
--   handled by <a>connectToLocalNode</a>.
data LocalNodeClientProtocols block point tip slot tx txid txerr query m
LocalNodeClientProtocols :: LocalChainSyncClient block point tip m -> Maybe (LocalTxSubmissionClient tx txerr m ()) -> Maybe (LocalStateQueryClient block point query m ()) -> Maybe (LocalTxMonitorClient txid tx slot m ()) -> LocalNodeClientProtocols block point tip slot tx txid txerr query m
[localChainSyncClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr query m -> LocalChainSyncClient block point tip m
[localTxSubmissionClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr query m -> Maybe (LocalTxSubmissionClient tx txerr m ())
[localStateQueryClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr query m -> Maybe (LocalStateQueryClient block point query m ())
[localTxMonitoringClient] :: LocalNodeClientProtocols block point tip slot tx txid txerr query m -> Maybe (LocalTxMonitorClient txid tx slot m ())

-- | This type defines the boundary between the mode-parametrised style
--   used in this API and the block-parametrised style used by the
--   underlying network and consensus libraries.
--   
--   This interface itself is in the block-parametrised style, with the
--   block type itself being an hidden/existential type.
--   
--   It bundles together all the necessary class instances, the consensus
--   protocol client identifier, and the set of client side mini-protocol
--   handlers for the node-to-client protocol.
data LocalNodeClientParams
[LocalNodeClientParamsSingleBlock] :: (ProtocolClient block, LedgerSupportsProtocol (ShelleyBlock (TPraos StandardCrypto) (ShelleyEra StandardCrypto))) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams
[LocalNodeClientParamsCardano] :: (ProtocolClient block, CardanoHardForkConstraints (ConsensusCryptoForBlock block)) => ProtocolClientInfoArgs block -> (NodeToClientVersion -> LocalNodeClientProtocolsForBlock block) -> LocalNodeClientParams

-- | Convert from the mode-parametrised style to the block-parametrised
--   style.
mkLocalNodeClientParams :: forall mode block. ConsensusBlockForMode mode ~ block => ConsensusModeParams mode -> (NodeToClientVersion -> LocalNodeClientProtocolsInMode mode) -> LocalNodeClientParams
data LocalChainSyncClient block point tip m
NoLocalChainSyncClient :: LocalChainSyncClient block point tip m
LocalChainSyncClientPipelined :: ChainSyncClientPipelined block point tip m () -> LocalChainSyncClient block point tip m
LocalChainSyncClient :: ChainSyncClient block point tip m () -> LocalChainSyncClient block point tip m

-- | The Cardano consensus mode consists of all the eras currently in use
--   on the Cardano mainnet. This is currently: the <a>ByronEra</a>;
--   <a>ShelleyEra</a>, <a>AllegraEra</a> and <a>MaryEra</a>, in that
--   order.
--   
--   This mode will be extended with new eras as the Cardano mainnet
--   develops.
data CardanoMode

-- | A chain sync protocol client, on top of some effect <tt>m</tt>. The
--   first choice of request is within that <tt>m</tt>.
newtype ChainSyncClient header point tip (m :: Type -> Type) a
ChainSyncClient :: m (ClientStIdle header point tip m a) -> ChainSyncClient header point tip (m :: Type -> Type) a
[runChainSyncClient] :: ChainSyncClient header point tip (m :: Type -> Type) a -> m (ClientStIdle header point tip m a)

-- | Pipelined chain sync client. It can only pipeline
--   <a>MsgRequestNext</a> messages, while the <a>MsgFindIntersect</a> are
--   non pipelined. This has a penalty cost of an RTT, but they are send
--   relatively seldom and their response might impact how many messages
--   one would like to pipeline. It also simplifies the receiver callback.
newtype ChainSyncClientPipelined header point tip (m :: Type -> Type) a
ChainSyncClientPipelined :: m (ClientPipelinedStIdle 'Z header point tip m a) -> ChainSyncClientPipelined header point tip (m :: Type -> Type) a
[runChainSyncClientPipelined] :: ChainSyncClientPipelined header point tip (m :: Type -> Type) a -> m (ClientPipelinedStIdle 'Z header point tip m a)

-- | A <a>Block</a> in one of the eras supported by a given protocol mode.
--   
--   For multi-era modes such as the <a>CardanoMode</a> this type is a sum
--   of the different block types for all the eras. It is used in the
--   ChainSync protocol.
data BlockInMode mode
[BlockInMode] :: IsCardanoEra era => Block era -> EraInMode era mode -> BlockInMode mode
type LocalNodeClientProtocolsInMode mode = LocalNodeClientProtocols (BlockInMode mode) ChainPoint ChainTip SlotNo (TxInMode mode) (TxIdInMode mode) (TxValidationErrorInMode mode) (QueryInMode mode) IO
data LocalTxSubmissionClient tx reject (m :: Type -> Type) a

-- | A <a>Tx</a> in one of the eras supported by a given protocol mode.
--   
--   For multi-era modes such as the <a>CardanoMode</a> this type is a sum
--   of the different transaction types for all the eras. It is used in the
--   LocalTxSubmission protocol.
data TxInMode mode

-- | Everything we consider a normal transaction.
[TxInMode] :: Tx era -> EraInMode era mode -> TxInMode mode

-- | Byron has various things we can post to the chain which are not
--   actually transactions. This covers: update proposals, votes and
--   delegation certs.
[TxInByronSpecial] :: GenTx ByronBlock -> EraInMode ByronEra mode -> TxInMode mode

-- | A <a>TxValidationError</a> in one of the eras supported by a given
--   protocol mode.
--   
--   This is used in the LocalStateQuery protocol.
data TxValidationErrorInMode mode
[TxValidationErrorInMode] :: TxValidationError era -> EraInMode era mode -> TxValidationErrorInMode mode
[TxValidationEraMismatch] :: EraMismatch -> TxValidationErrorInMode mode
runLocalTxSubmissionClient :: LocalTxSubmissionClient tx reject m a -> m (LocalTxClientStIdle tx reject m a)
submitTxToNodeLocal :: forall mode. LocalNodeConnectInfo mode -> TxInMode mode -> IO (SubmitResult (TxValidationErrorInMode mode))
newtype LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
LocalStateQueryClient :: m (ClientStIdle block point query m a) -> LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
[runLocalStateQueryClient] :: LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a -> m (ClientStIdle block point query m a)
data QueryInMode mode result
[QueryCurrentEra] :: ConsensusModeIsMultiEra mode -> QueryInMode mode AnyCardanoEra
[QueryInEra] :: EraInMode era mode -> QueryInEra era result -> QueryInMode mode (Either EraMismatch result)
[QueryEraHistory] :: ConsensusModeIsMultiEra mode -> QueryInMode mode (EraHistory mode)
[QuerySystemStart] :: QueryInMode mode SystemStart
[QueryChainBlockNo] :: QueryInMode mode (WithOrigin BlockNo)
[QueryChainPoint] :: ConsensusMode mode -> QueryInMode mode ChainPoint

-- | System start
--   
--   Slots are counted from the system start.
newtype SystemStart
SystemStart :: UTCTime -> SystemStart
[getSystemStart] :: SystemStart -> UTCTime
data QueryInEra era result
[QueryByronUpdateState] :: QueryInEra ByronEra ByronUpdateState
[QueryInShelleyBasedEra] :: ShelleyBasedEra era -> QueryInShelleyBasedEra era result -> QueryInEra era result
data QueryInShelleyBasedEra era result
[QueryEpoch] :: QueryInShelleyBasedEra era EpochNo
[QueryGenesisParameters] :: QueryInShelleyBasedEra era GenesisParameters
[QueryProtocolParameters] :: QueryInShelleyBasedEra era ProtocolParameters
[QueryProtocolParametersUpdate] :: QueryInShelleyBasedEra era (Map (Hash GenesisKey) ProtocolParametersUpdate)
[QueryStakeDistribution] :: QueryInShelleyBasedEra era (Map (Hash StakePoolKey) Rational)
[QueryUTxO] :: QueryUTxOFilter -> QueryInShelleyBasedEra era (UTxO era)
[QueryStakeAddresses] :: Set StakeCredential -> NetworkId -> QueryInShelleyBasedEra era (Map StakeAddress Lovelace, Map StakeAddress PoolId)
[QueryStakePools] :: QueryInShelleyBasedEra era (Set PoolId)
[QueryStakePoolParameters] :: Set PoolId -> QueryInShelleyBasedEra era (Map PoolId StakePoolParameters)
[QueryDebugLedgerState] :: QueryInShelleyBasedEra era (SerialisedDebugLedgerState era)
[QueryProtocolState] :: QueryInShelleyBasedEra era (ProtocolState era)
[QueryCurrentEpochState] :: QueryInShelleyBasedEra era (SerialisedCurrentEpochState era)

-- | Getting the <i>whole</i> UTxO is obviously not efficient since the
--   result can be huge. Filtering by address is also not efficient because
--   it requires a linear search.
--   
--   The <tt>QueryUTxOFilterByTxIn</tt> is efficient since it fits with the
--   structure of the UTxO (which is indexed by <a>TxIn</a>).
data QueryUTxOFilter

-- | <i>O(n) time and space</i> for utxo size n
QueryUTxOWhole :: QueryUTxOFilter

-- | <i>O(n) time, O(m) space</i> for utxo size n, and address set size m
QueryUTxOByAddress :: Set AddressAny -> QueryUTxOFilter

-- | <i>O(m log n) time, O(m) space</i> for utxo size n, and address set
--   size m
QueryUTxOByTxIn :: Set TxIn -> QueryUTxOFilter
newtype UTxO era
UTxO :: Map TxIn (TxOut CtxUTxO era) -> UTxO era
[unUTxO] :: UTxO era -> Map TxIn (TxOut CtxUTxO era)
queryNodeLocalState :: forall mode result. LocalNodeConnectInfo mode -> Maybe ChainPoint -> QueryInMode mode result -> IO (Either AcquiringFailure result)

-- | Execute a query against the local node. The local node must be in
--   CardanoMode.
executeQueryCardanoMode :: CardanoEra era -> NetworkId -> QueryInMode CardanoMode (Either EraMismatch result) -> IO (Either QueryConvenienceError result)

-- | A tx monitor client, on top of some effect <tt>m</tt>.
newtype LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
LocalTxMonitorClient :: m (ClientStIdle txid tx slot m a) -> LocalTxMonitorClient txid tx slot (m :: Type -> Type) a
[runLocalTxMonitorClient] :: LocalTxMonitorClient txid tx slot (m :: Type -> Type) a -> m (ClientStIdle txid tx slot m a)
data LocalTxMonitoringQuery mode

-- | Query if a particular tx exists in the mempool. Note that, the absence
--   of a transaction does not imply anything about how the transaction was
--   processed: it may have been dropped, or inserted in a block.
LocalTxMonitoringQueryTx :: TxIdInMode mode -> LocalTxMonitoringQuery mode

-- | The mempool is modeled as an ordered list of transactions and thus,
--   can be traversed linearly. <a>LocalTxMonitoringSendNextTx</a> requests
--   the next transaction from the current list. This must be a transaction
--   that was not previously sent to the client for this particular
--   snapshot.
LocalTxMonitoringSendNextTx :: LocalTxMonitoringQuery mode

-- | Ask the server about the current mempool's capacity and sizes. This is
--   fixed in a given snapshot.
LocalTxMonitoringMempoolInformation :: LocalTxMonitoringQuery mode
data LocalTxMonitoringResult mode

-- | Slot number at which the mempool snapshot was taken
LocalTxMonitoringTxExists :: TxId -> SlotNo -> LocalTxMonitoringResult mode

-- | Slot number at which the mempool snapshot was taken
LocalTxMonitoringTxDoesNotExist :: TxId -> SlotNo -> LocalTxMonitoringResult mode

-- | Slot number at which the mempool snapshot was taken
LocalTxMonitoringNextTx :: Maybe (TxInMode mode) -> SlotNo -> LocalTxMonitoringResult mode

-- | Slot number at which the mempool snapshot was taken
LocalTxMonitoringMempoolSizeAndCapacity :: MempoolSizeAndCapacity -> SlotNo -> LocalTxMonitoringResult mode

-- | Describes the MemPool sizes and capacity for a given snapshot.
data MempoolSizeAndCapacity
MempoolSizeAndCapacity :: !Word32 -> !Word32 -> !Word32 -> MempoolSizeAndCapacity

-- | The maximum capacity of the mempool. Note that this may dynamically
--   change when the ledger state is updated.
[capacityInBytes] :: MempoolSizeAndCapacity -> !Word32

-- | The summed byte size of all the transactions in the mempool.
[sizeInBytes] :: MempoolSizeAndCapacity -> !Word32

-- | The number of transactions in the mempool
[numberOfTxs] :: MempoolSizeAndCapacity -> !Word32
queryTxMonitoringLocal :: forall mode. LocalNodeConnectInfo mode -> LocalTxMonitoringQuery mode -> IO (LocalTxMonitoringResult mode)
data EraHistory mode
[EraHistory] :: ConsensusBlockForMode mode ~ HardForkBlock xs => ConsensusMode mode -> Interpreter xs -> EraHistory mode
getProgress :: SlotNo -> EraHistory mode -> Either PastHorizonException (RelativeTime, SlotLength)

-- | Query the node to determine which era it is in.
determineEra :: ConsensusModeParams mode -> LocalNodeConnectInfo mode -> IO (Either AcquiringFailure AnyCardanoEra)
getLocalChainTip :: LocalNodeConnectInfo mode -> IO ChainTip
data OperationalCertificate
data OperationalCertificateIssueCounter
data OperationalCertIssueError
getHotKey :: OperationalCertificate -> VerificationKey KesKey
getKesPeriod :: OperationalCertificate -> Word
getOpCertCount :: OperationalCertificate -> Word64
issueOperationalCertificate :: VerificationKey KesKey -> Either (SigningKey StakePoolKey) (SigningKey GenesisDelegateExtendedKey) -> KESPeriod -> OperationalCertificateIssueCounter -> Either OperationalCertIssueError (OperationalCertificate, OperationalCertificateIssueCounter)
data GenesisKey

-- | Shelley-era genesis keys using extended ed25519 cryptographic keys.
--   
--   These serve the same role as normal genesis keys, but are here to
--   support legacy Byron genesis keys which used extended keys.
--   
--   The extended verification keys can be converted (via
--   <a>castVerificationKey</a>) to ordinary keys (i.e.
--   <a>VerificationKey</a> <a>GenesisKey</a>) but this is <i>not</i> the
--   case for the signing keys. The signing keys can be used to witness
--   transactions directly, with verification via their non-extended
--   verification key (<a>VerificationKey</a> <a>GenesisKey</a>).
--   
--   This is a type level tag, used with other interfaces like <a>Key</a>.
data GenesisExtendedKey
data GenesisDelegateKey

-- | Shelley-era genesis keys using extended ed25519 cryptographic keys.
--   
--   These serve the same role as normal genesis keys, but are here to
--   support legacy Byron genesis keys which used extended keys.
--   
--   The extended verification keys can be converted (via
--   <a>castVerificationKey</a>) to ordinary keys (i.e.
--   <a>VerificationKey</a> <a>GenesisKey</a>) but this is <i>not</i> the
--   case for the signing keys. The signing keys can be used to witness
--   transactions directly, with verification via their non-extended
--   verification key (<a>VerificationKey</a> <a>GenesisKey</a>).
--   
--   This is a type level tag, used with other interfaces like <a>Key</a>.
data GenesisDelegateExtendedKey
data GenesisUTxOKey

-- | Compute the <a>TxIn</a> of the initial UTxO pseudo-transaction
--   corresponding to the given address in the genesis initial funds.
--   
--   The Shelley initial UTxO is constructed from the
--   <tt>sgInitialFunds</tt> which is not a full UTxO but just a map from
--   addresses to coin values.
--   
--   This gets turned into a UTxO by making a pseudo-transaction for each
--   address, with the 0th output being the coin value. So to spend from
--   the initial UTxO we need this same <a>TxIn</a> to use as an input to
--   the spending transaction.
genesisUTxOPseudoTxIn :: NetworkId -> Hash GenesisUTxOKey -> TxIn
data GenesisParameters
GenesisParameters :: UTCTime -> NetworkId -> Rational -> Int -> EpochSize -> NominalDiffTime -> Int -> Int -> Int -> Lovelace -> ProtocolParameters -> GenesisParameters

-- | The reference time the system started. The time of slot zero. The time
--   epoch against which all Ouroboros time slots are measured.
[protocolParamSystemStart] :: GenesisParameters -> UTCTime

-- | The network identifier for this blockchain instance. This
--   distinguishes the mainnet from testnets, and different testnets from
--   each other.
[protocolParamNetworkId] :: GenesisParameters -> NetworkId

-- | The Ouroboros Praos active slot coefficient, aka <tt>f</tt>.
[protocolParamActiveSlotsCoefficient] :: GenesisParameters -> Rational

-- | The Ouroboros security parameters, aka <tt>k</tt>. This is the maximum
--   number of blocks the node would ever be prepared to roll back by.
--   
--   Clients of the node following the chain should be prepared to handle
--   the node switching forks up to this long.
[protocolParamSecurity] :: GenesisParameters -> Int

-- | The number of Ouroboros time slots in an Ouroboros epoch.
[protocolParamEpochLength] :: GenesisParameters -> EpochSize

-- | The time duration of a slot.
[protocolParamSlotLength] :: GenesisParameters -> NominalDiffTime

-- | For Ouroboros Praos, the length of a KES period as a number of time
--   slots. The KES keys get evolved once per KES period.
[protocolParamSlotsPerKESPeriod] :: GenesisParameters -> Int

-- | The maximum number of times a KES key can be evolved before it is no
--   longer considered valid. This can be less than the maximum number of
--   times given the KES key size. For example the mainnet KES key size
--   would allow 64 evolutions, but the max KES evolutions param is 62.
[protocolParamMaxKESEvolutions] :: GenesisParameters -> Int

-- | In the Shelley era, prior to decentralised governance, this is the
--   number of genesis key delegates that need to agree for an update
--   proposal to be enacted.
[protocolParamUpdateQuorum] :: GenesisParameters -> Int

-- | The maximum supply for Lovelace. This determines the initial value of
--   the reserves.
[protocolParamMaxLovelaceSupply] :: GenesisParameters -> Lovelace

-- | The initial values of the updateable <a>ProtocolParameters</a>.
[protocolInitialUpdateableProtocolParameters] :: GenesisParameters -> ProtocolParameters
makeMIRCertificate :: MIRPot -> MIRTarget -> Certificate
makeGenesisKeyDelegationCertificate :: Hash GenesisKey -> Hash GenesisDelegateKey -> Hash VrfKey -> Certificate

-- | The <a>MIRTarget</a> determines the target of a <a>MIRCertificate</a>.
--   A <a>MIRCertificate</a> moves lovelace from either the reserves or the
--   treasury to either a collection of stake credentials or to the other
--   pot.
data MIRTarget

-- | Use <a>StakeAddressesMIR</a> to make the target of a
--   <a>MIRCertificate</a> a mapping of stake credentials to lovelace.
StakeAddressesMIR :: [(StakeCredential, Lovelace)] -> MIRTarget

-- | Use <a>SendToReservesMIR</a> to make the target of a
--   <a>MIRCertificate</a> the reserves pot.
SendToReservesMIR :: Lovelace -> MIRTarget

-- | Use <a>SendToTreasuryMIR</a> to make the target of a
--   <a>MIRCertificate</a> the treasury pot.
SendToTreasuryMIR :: Lovelace -> MIRTarget
data UpdateProposal
UpdateProposal :: !Map (Hash GenesisKey) ProtocolParametersUpdate -> !EpochNo -> UpdateProposal

-- | The representation of a change in the <a>ProtocolParameters</a>.
data ProtocolParametersUpdate
ProtocolParametersUpdate :: Maybe (Natural, Natural) -> Maybe Rational -> Maybe (Maybe PraosNonce) -> Maybe Natural -> Maybe Natural -> Maybe Natural -> Maybe Natural -> Maybe Natural -> Maybe Lovelace -> Maybe Lovelace -> Maybe Lovelace -> Maybe Lovelace -> Maybe EpochNo -> Maybe Natural -> Maybe Rational -> Maybe Rational -> Maybe Rational -> Maybe Lovelace -> Map AnyPlutusScriptVersion CostModel -> Maybe ExecutionUnitPrices -> Maybe ExecutionUnits -> Maybe ExecutionUnits -> Maybe Natural -> Maybe Natural -> Maybe Natural -> Maybe Lovelace -> ProtocolParametersUpdate

-- | Protocol version, major and minor. Updating the major version is used
--   to trigger hard forks.
[protocolUpdateProtocolVersion] :: ProtocolParametersUpdate -> Maybe (Natural, Natural)

-- | The decentralization parameter. This is fraction of slots that belong
--   to the BFT overlay schedule, rather than the Praos schedule. So 1
--   means fully centralised, while 0 means fully decentralised.
--   
--   This is the "d" parameter from the design document.
[protocolUpdateDecentralization] :: ProtocolParametersUpdate -> Maybe Rational

-- | Extra entropy for the Praos per-epoch nonce.
--   
--   This can be used to add extra entropy during the decentralisation
--   process. If the extra entropy can be demonstrated to be generated
--   randomly then this method can be used to show that the initial
--   federated operators did not subtly bias the initial schedule so that
--   they retain undue influence after decentralisation.
[protocolUpdateExtraPraosEntropy] :: ProtocolParametersUpdate -> Maybe (Maybe PraosNonce)

-- | The maximum permitted size of a block header.
--   
--   This must be at least as big as the largest legitimate block headers
--   but should not be too much larger, to help prevent DoS attacks.
--   
--   Caution: setting this to be smaller than legitimate block headers is a
--   sure way to brick the system!
[protocolUpdateMaxBlockHeaderSize] :: ProtocolParametersUpdate -> Maybe Natural

-- | The maximum permitted size of the block body (that is, the block
--   payload, without the block header).
--   
--   This should be picked with the Praos network delta security parameter
--   in mind. Making this too large can severely weaken the Praos consensus
--   properties.
--   
--   Caution: setting this to be smaller than a transaction that can change
--   the protocol parameters is a sure way to brick the system!
[protocolUpdateMaxBlockBodySize] :: ProtocolParametersUpdate -> Maybe Natural

-- | The maximum permitted size of a transaction.
--   
--   Typically this should not be too high a fraction of the block size,
--   otherwise wastage from block fragmentation becomes a problem, and the
--   current implementation does not use any sophisticated box packing
--   algorithm.
[protocolUpdateMaxTxSize] :: ProtocolParametersUpdate -> Maybe Natural

-- | The constant factor for the minimum fee calculation.
[protocolUpdateTxFeeFixed] :: ProtocolParametersUpdate -> Maybe Natural

-- | The linear factor for the minimum fee calculation.
[protocolUpdateTxFeePerByte] :: ProtocolParametersUpdate -> Maybe Natural

-- | The minimum permitted value for new UTxO entries, ie for transaction
--   outputs.
[protocolUpdateMinUTxOValue] :: ProtocolParametersUpdate -> Maybe Lovelace

-- | The deposit required to register a stake address.
[protocolUpdateStakeAddressDeposit] :: ProtocolParametersUpdate -> Maybe Lovelace

-- | The deposit required to register a stake pool.
[protocolUpdateStakePoolDeposit] :: ProtocolParametersUpdate -> Maybe Lovelace

-- | The minimum value that stake pools are permitted to declare for their
--   cost parameter.
[protocolUpdateMinPoolCost] :: ProtocolParametersUpdate -> Maybe Lovelace

-- | The maximum number of epochs into the future that stake pools are
--   permitted to schedule a retirement.
[protocolUpdatePoolRetireMaxEpoch] :: ProtocolParametersUpdate -> Maybe EpochNo

-- | The equilibrium target number of stake pools.
--   
--   This is the "k" incentives parameter from the design document.
[protocolUpdateStakePoolTargetNum] :: ProtocolParametersUpdate -> Maybe Natural

-- | The influence of the pledge in stake pool rewards.
--   
--   This is the "a_0" incentives parameter from the design document.
[protocolUpdatePoolPledgeInfluence] :: ProtocolParametersUpdate -> Maybe Rational

-- | The monetary expansion rate. This determines the fraction of the
--   reserves that are added to the fee pot each epoch.
--   
--   This is the "rho" incentives parameter from the design document.
[protocolUpdateMonetaryExpansion] :: ProtocolParametersUpdate -> Maybe Rational

-- | The fraction of the fee pot each epoch that goes to the treasury.
--   
--   This is the "tau" incentives parameter from the design document.
[protocolUpdateTreasuryCut] :: ProtocolParametersUpdate -> Maybe Rational

-- | Cost in ada per word of UTxO storage.
--   
--   <i>Introduced in Alonzo, obsoleted in Babbage by
--   <a>protocolUpdateUTxOCostPerByte</a></i>
[protocolUpdateUTxOCostPerWord] :: ProtocolParametersUpdate -> Maybe Lovelace

-- | Cost models for script languages that use them.
--   
--   <i>Introduced in Alonzo</i>
[protocolUpdateCostModels] :: ProtocolParametersUpdate -> Map AnyPlutusScriptVersion CostModel

-- | Price of execution units for script languages that use them.
--   
--   <i>Introduced in Alonzo</i>
[protocolUpdatePrices] :: ProtocolParametersUpdate -> Maybe ExecutionUnitPrices

-- | Max total script execution resources units allowed per tx
--   
--   <i>Introduced in Alonzo</i>
[protocolUpdateMaxTxExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits

-- | Max total script execution resources units allowed per block
--   
--   <i>Introduced in Alonzo</i>
[protocolUpdateMaxBlockExUnits] :: ProtocolParametersUpdate -> Maybe ExecutionUnits

-- | Max size of a <a>Value</a> in a tx output.
--   
--   <i>Introduced in Alonzo</i>
[protocolUpdateMaxValueSize] :: ProtocolParametersUpdate -> Maybe Natural

-- | The percentage of the script contribution to the txfee that must be
--   provided as collateral inputs when including Plutus scripts.
--   
--   <i>Introduced in Alonzo</i>
[protocolUpdateCollateralPercent] :: ProtocolParametersUpdate -> Maybe Natural

-- | The maximum number of collateral inputs allowed in a transaction.
--   
--   <i>Introduced in Alonzo</i>
[protocolUpdateMaxCollateralInputs] :: ProtocolParametersUpdate -> Maybe Natural

-- | Cost in ada per byte of UTxO storage.
--   
--   <i>Introduced in Babbage. Supercedes
--   <a>protocolUpdateUTxOCostPerWord</a></i>
[protocolUpdateUTxOCostPerByte] :: ProtocolParametersUpdate -> Maybe Lovelace
makeShelleyUpdateProposal :: ProtocolParametersUpdate -> [Hash GenesisKey] -> EpochNo -> UpdateProposal
data PraosNonce
makePraosNonce :: ByteString -> PraosNonce

-- | NetworkMagic is used to differentiate between different networks
--   during the initial handshake.
newtype NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic
[unNetworkMagic] :: NetworkMagic -> Word32
toLedgerPParams :: ShelleyBasedEra era -> ProtocolParameters -> PParams (ShelleyLedgerEra era)
fromLedgerPParams :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> ProtocolParameters
toCtxUTxOTxOut :: TxOut CtxTx era -> TxOut CtxUTxO era
fromNetworkMagic :: NetworkMagic -> NetworkId
toNetworkMagic :: NetworkId -> NetworkMagic
fromLedgerTxOuts :: forall era. ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> TxBodyScriptData era -> [TxOut CtxTx era]
toLedgerUTxO :: ShelleyLedgerEra era ~ ledgerera => Crypto ledgerera ~ StandardCrypto => ShelleyBasedEra era -> UTxO era -> UTxO ledgerera
runParsecParser :: Parser a -> Text -> Parser a
newtype SlotsInEpoch
SlotsInEpoch :: Word64 -> SlotsInEpoch
newtype SlotsToEpochEnd
SlotsToEpochEnd :: Word64 -> SlotsToEpochEnd
slotToEpoch :: SlotNo -> EraHistory mode -> Either PastHorizonException (EpochNo, SlotsInEpoch, SlotsToEpochEnd)
newtype EnvSocketError
CliEnvVarLookup :: Text -> EnvSocketError
newtype SocketPath
SocketPath :: FilePath -> SocketPath
[unSocketPath] :: SocketPath -> FilePath

-- | Read the node socket path from the environment. Fails if the
--   environment variable is not set.
readEnvSocketPath :: IO (Either EnvSocketError SocketPath)
renderEnvSocketError :: EnvSocketError -> Text

-- | Enumeration of node to client protocol versions.
data NodeToClientVersion

-- | enabled <tt>CardanoNodeToClientVersion7</tt>, i.e., Alonzo
NodeToClientV_9 :: NodeToClientVersion

-- | added <tt>GetChainBlockNo</tt> and <tt>GetChainPoint</tt> queries
NodeToClientV_10 :: NodeToClientVersion

-- | added <tt>GetRewardInfoPools</tt> Block query
NodeToClientV_11 :: NodeToClientVersion

-- | added <tt>LocalTxMonitor</tt> mini-protocol
NodeToClientV_12 :: NodeToClientVersion

-- | enabled <tt>CardanoNodeToClientVersion9</tt>, i.e., Babbage
NodeToClientV_13 :: NodeToClientVersion

-- | Monadic type for constructing local state query expressions.
--   
--   Use <a>queryExpr</a> in a do block to construct queries of this type
--   and convert the expression to a <a>LocalStateQueryClient</a> with
--   <a>setupLocalStateQueryExpr</a>.
--   
--   Some consideration was made to use Applicative instead of Monad as the
--   abstraction in order to support pipelining, but we actually have a
--   fair amount of code where the next query depends on the result of the
--   former and therefore actually need Monad.
--   
--   In order to make pipelining still possible we can explore the use of
--   Selective Functors which would allow us to straddle both worlds.
data LocalStateQueryExpr block point query r m a

-- | Execute a local state query expression.
executeLocalStateQueryExpr :: LocalNodeConnectInfo mode -> Maybe ChainPoint -> (NodeToClientVersion -> LocalStateQueryExpr (BlockInMode mode) ChainPoint (QueryInMode mode) () IO a) -> IO (Either AcquiringFailure a)

-- | Use <a>queryExpr</a> in a do block to construct monadic local state
--   queries.
queryExpr :: QueryInMode mode a -> LocalStateQueryExpr block point (QueryInMode mode) r IO a

-- | A monad expression that determines what era the node is in.
determineEraExpr :: ConsensusModeParams mode -> LocalStateQueryExpr block point (QueryInMode mode) r IO AnyCardanoEra
chainPointToSlotNo :: ChainPoint -> Maybe SlotNo
chainPointToHeaderHash :: ChainPoint -> Maybe (Hash BlockHeader)
makeChainTip :: WithOrigin BlockNo -> ChainPoint -> ChainTip
parseFilePath :: String -> String -> Parser FilePath
writeSecrets :: FilePath -> [Char] -> [Char] -> (a -> ByteString) -> [a] -> IO ()
class EraCast (f :: Type -> Type)
eraCast :: (EraCast f, IsCardanoEra fromEra, IsCardanoEra toEra) => CardanoEra toEra -> f fromEra -> Either EraCastError (f toEra)
data EraCastError
EraCastError :: value -> CardanoEra fromEra -> CardanoEra toEra -> EraCastError
[originalValue] :: EraCastError -> value
[fromEra] :: EraCastError -> CardanoEra fromEra
[toEra] :: EraCastError -> CardanoEra toEra

-- | Construct a balanced transaction. See
--   Cardano.Api.Convenience.Query.queryStateForBalancedTx for a convenient
--   way of querying the node to get the required arguements for
--   constructBalancedTx.
constructBalancedTx :: IsShelleyBasedEra era => EraInMode era CardanoMode -> TxBodyContent BuildTx era -> AddressInEra era -> Maybe Word -> UTxO era -> ProtocolParameters -> EraHistory CardanoMode -> SystemStart -> Set PoolId -> [ShelleyWitnessSigningKey] -> Either TxBodyErrorAutoBalance (Tx era)
data QueryConvenienceError
AcqFailure :: AcquiringFailure -> QueryConvenienceError
SockErr :: EnvSocketError -> QueryConvenienceError
QueryEraMismatch :: EraMismatch -> QueryConvenienceError
ByronEraNotSupported :: QueryConvenienceError
EraConsensusModeMismatch :: !AnyConsensusMode -> !AnyCardanoEra -> QueryConvenienceError

-- | A convenience function to query the relevant information, from the
--   local node, for
--   Cardano.Api.Convenience.Construction.constructBalancedTx
queryStateForBalancedTx :: CardanoEra era -> NetworkId -> [TxIn] -> IO (Either QueryConvenienceError (UTxO era, ProtocolParameters, EraHistory CardanoMode, SystemStart, Set PoolId))
renderQueryConvenienceError :: QueryConvenienceError -> Text
getIsCardanoEraConstraint :: CardanoEra era -> (IsCardanoEra era => a) -> a
newtype ScriptLockedTxInsError
ScriptLockedTxIns :: [TxIn] -> ScriptLockedTxInsError
data TxInsExistError
TxInsDoNotExist :: [TxIn] -> TxInsExistError
EmptyUTxO :: TxInsExistError
renderNotScriptLockedTxInsError :: ScriptLockedTxInsError -> Text
renderTxInsExistError :: TxInsExistError -> Text
txInsExistInUTxO :: [TxIn] -> UTxO era -> Either TxInsExistError ()
notScriptLockedTxIns :: [TxIn] -> UTxO era -> Either ScriptLockedTxInsError ()
textShow :: Show a => a -> Text


-- | This module provides a library interface that is intended to be the
--   complete API for Shelley covering everything, including exposing
--   constructors for the lower level types.
module Cardano.Api.Shelley

-- | Shelley genesis information
--   
--   Note that this is needed only for a pure Shelley network, hence it
--   being defined here rather than in its own module. In mainnet, Shelley
--   will transition naturally from Byron, and thus will never have its own
--   genesis information.
data ShelleyGenesis era
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTime -> !Word64 -> !Word64 -> !PParams era -> !Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era)) -> !Map (Addr (Crypto era)) Coin -> !ShelleyGenesisStaking (Crypto era) -> ShelleyGenesis era
[sgSystemStart] :: ShelleyGenesis era -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis era -> !Word32
[sgNetworkId] :: ShelleyGenesis era -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis era -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis era -> !Word64
[sgEpochLength] :: ShelleyGenesis era -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis era -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis era -> !Word64
[sgSlotLength] :: ShelleyGenesis era -> !NominalDiffTime
[sgUpdateQuorum] :: ShelleyGenesis era -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis era -> !Word64
[sgProtocolParams] :: ShelleyGenesis era -> !PParams era
[sgGenDelegs] :: ShelleyGenesis era -> !Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era))
[sgInitialFunds] :: ShelleyGenesis era -> !Map (Addr (Crypto era)) Coin
[sgStaking] :: ShelleyGenesis era -> !ShelleyGenesisStaking (Crypto era)

-- | Some reasonable starting defaults for constructing a
--   <a>ShelleyGenesis</a>.
--   
--   You must override at least the following fields for this to be useful:
--   
--   <ul>
--   <li><a>sgSystemStart</a> the time of the first block</li>
--   <li><a>sgNetworkMagic</a> to a suitable testnet or mainnet network
--   magic number.</li>
--   <li><a>sgGenDelegs</a> to have some initial nodes</li>
--   <li><a>sgInitialFunds</a> to have any money in the system</li>
--   <li><a>sgMaxLovelaceSupply</a> must be at least the sum of the
--   <a>sgInitialFunds</a> but more if you want to allow for rewards.</li>
--   </ul>
shelleyGenesisDefaults :: ShelleyGenesis crypto

-- | An interface for cryptographic keys used for signatures with a
--   <a>SigningKey</a> and a <a>VerificationKey</a> key.
--   
--   This interface does not provide actual signing or verifying functions
--   since this API is concerned with the management of keys: generating
--   and serialising.
class (Eq (VerificationKey keyrole), Show (VerificationKey keyrole), SerialiseAsRawBytes (Hash keyrole), HasTextEnvelope (VerificationKey keyrole), HasTextEnvelope (SigningKey keyrole)) => Key keyrole where {
    
    -- | The type of cryptographic verification key, for each key role.
    data family VerificationKey keyrole :: Type;
    
    -- | The type of cryptographic signing key, for each key role.
    data family SigningKey keyrole :: Type;
}

-- | Get the corresponding verification key from a signing key.
getVerificationKey :: Key keyrole => SigningKey keyrole -> VerificationKey keyrole

-- | Generate a <a>SigningKey</a> deterministically, given a <a>Seed</a>.
--   The required size of the seed is given by
--   <a>deterministicSigningKeySeedSize</a>.
deterministicSigningKey :: Key keyrole => AsType keyrole -> Seed -> SigningKey keyrole
deterministicSigningKeySeedSize :: Key keyrole => AsType keyrole -> Word
verificationKeyHash :: Key keyrole => VerificationKey keyrole -> Hash keyrole
data family Hash keyrole :: Type

-- | Addresses are used as locations where assets live. The address
--   determines the rights needed to spend assets at the address: in
--   particular holding some signing key or being able to satisfy the
--   conditions of a script.
--   
--   There are currently two types of address:
--   
--   <ul>
--   <li>Byron addresses, which use the type tag <a>ByronAddr</a>; and</li>
--   <li>Shelley addresses, which use the type tag <a>ShelleyAddr</a>.
--   Notably, Shelley addresses support scripts and stake delegation.</li>
--   </ul>
--   
--   The <i>address type</i> is subtly from the <i>ledger era</i> in which
--   each address type is valid: while Byron addresses are the only choice
--   in the Byron era, the Shelley era and all subsequent eras support both
--   Byron and Shelley addresses. The <a>Address</a> type param only says
--   the type of the address (either Byron or Shelley). The
--   <a>AddressInEra</a> type connects the address type with the era in
--   which it is supported.
data Address addrtype

-- | Shelley addresses allow delegation. Shelley addresses were introduced
--   in Shelley era and are thus supported from the Shelley era onwards
[ShelleyAddress] :: Network -> PaymentCredential StandardCrypto -> StakeReference StandardCrypto -> Address ShelleyAddr
toShelleyAddr :: AddressInEra era -> Addr StandardCrypto
fromShelleyAddr :: ShelleyBasedEra era -> Addr StandardCrypto -> AddressInEra era
fromShelleyAddrIsSbe :: IsShelleyBasedEra era => Addr StandardCrypto -> AddressInEra era
fromShelleyAddrToAny :: Addr StandardCrypto -> AddressAny
toShelleyStakeCredential :: StakeCredential -> StakeCredential StandardCrypto
fromShelleyStakeCredential :: StakeCredential StandardCrypto -> StakeCredential
data NetworkId
Mainnet :: NetworkId
Testnet :: !NetworkMagic -> NetworkId
data PaymentCredential
PaymentCredentialByKey :: Hash PaymentKey -> PaymentCredential
PaymentCredentialByScript :: ScriptHash -> PaymentCredential
data StakeAddress
[StakeAddress] :: Network -> StakeCredential StandardCrypto -> StakeAddress
data StakeAddressReference
StakeAddressByValue :: StakeCredential -> StakeAddressReference
StakeAddressByPointer :: StakeAddressPointer -> StakeAddressReference
NoStakeAddress :: StakeAddressReference
data StakeCredential
StakeCredentialByKey :: Hash StakeKey -> StakeCredential
StakeCredentialByScript :: ScriptHash -> StakeCredential
toShelleyStakeAddr :: StakeAddress -> RewardAcnt StandardCrypto
fromShelleyStakeAddr :: RewardAcnt StandardCrypto -> StakeAddress
fromShelleyStakeReference :: StakeReference StandardCrypto -> StakeAddressReference
fromShelleyPaymentCredential :: PaymentCredential StandardCrypto -> PaymentCredential
data TxBody era
[ShelleyTxBody] :: ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> [Script (ShelleyLedgerEra era)] -> TxBodyScriptData era -> Maybe (AuxiliaryData (ShelleyLedgerEra era)) -> TxScriptValidity era -> TxBody era
newtype TxId
TxId :: Hash StandardCrypto EraIndependentTxBody -> TxId
toShelleyTxId :: TxId -> TxId StandardCrypto
fromShelleyTxId :: TxId StandardCrypto -> TxId
getTxIdShelley :: Crypto (ShelleyLedgerEra era) ~ StandardCrypto => UsesTxBody (ShelleyLedgerEra era) => ShelleyBasedEra era -> TxBody (ShelleyLedgerEra era) -> TxId
data TxIn
TxIn :: TxId -> TxIx -> TxIn

-- | This function may overflow on the transaction index. Call sites must
--   ensure that all uses of this function are appropriately guarded.
toShelleyTxIn :: TxIn -> TxIn StandardCrypto
fromShelleyTxIn :: TxIn StandardCrypto -> TxIn
data TxOut ctx era
TxOut :: AddressInEra era -> TxOutValue era -> TxOutDatum ctx era -> ReferenceScript era -> TxOut ctx era
toShelleyTxOut :: forall era ledgerera. ShelleyLedgerEra era ~ ledgerera => ShelleyBasedEra era -> TxOut CtxUTxO era -> TxOut ledgerera
fromShelleyTxOut :: ShelleyLedgerEra era ~ ledgerera => ShelleyBasedEra era -> TxOut ledgerera -> TxOut ctx era
newtype TxIx
TxIx :: Word -> TxIx
newtype Lovelace
Lovelace :: Integer -> Lovelace
toShelleyLovelace :: Lovelace -> Coin
fromShelleyLovelace :: Coin -> Lovelace
toMaryValue :: Value -> Value StandardCrypto
fromMaryValue :: Value StandardCrypto -> Value

-- | Calculate cost of making a UTxO entry for a given <a>Value</a> and
--   mininimum UTxO value derived from the <tt>ProtocolParameters</tt>
calcMinimumDeposit :: Value -> Lovelace -> Lovelace
data Tx era
[ShelleyTx] :: ShelleyBasedEra era -> Tx (ShelleyLedgerEra era) -> Tx era
data KeyWitness era
[ShelleyBootstrapWitness] :: ShelleyBasedEra era -> BootstrapWitness StandardCrypto -> KeyWitness era
[ShelleyKeyWitness] :: ShelleyBasedEra era -> WitVKey Witness StandardCrypto -> KeyWitness era
data ShelleyWitnessSigningKey
WitnessPaymentKey :: SigningKey PaymentKey -> ShelleyWitnessSigningKey
WitnessPaymentExtendedKey :: SigningKey PaymentExtendedKey -> ShelleyWitnessSigningKey
WitnessStakeKey :: SigningKey StakeKey -> ShelleyWitnessSigningKey
WitnessStakeExtendedKey :: SigningKey StakeExtendedKey -> ShelleyWitnessSigningKey
WitnessStakePoolKey :: SigningKey StakePoolKey -> ShelleyWitnessSigningKey
WitnessGenesisKey :: SigningKey GenesisKey -> ShelleyWitnessSigningKey
WitnessGenesisExtendedKey :: SigningKey GenesisExtendedKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateKey :: SigningKey GenesisDelegateKey -> ShelleyWitnessSigningKey
WitnessGenesisDelegateExtendedKey :: SigningKey GenesisDelegateExtendedKey -> ShelleyWitnessSigningKey

-- | We support making key witnesses with both normal and extended signing
--   keys.
data ShelleySigningKey

-- | A normal ed25519 signing key
ShelleyNormalSigningKey :: SignKeyDSIGN StandardCrypto -> ShelleySigningKey

-- | An extended ed25519 signing key
ShelleyExtendedSigningKey :: XPrv -> ShelleySigningKey
getShelleyKeyWitnessVerificationKey :: ShelleySigningKey -> VKey Witness StandardCrypto
getTxBodyAndWitnesses :: Tx era -> (TxBody era, [KeyWitness era])
makeShelleySignature :: SignableRepresentation tosign => tosign -> ShelleySigningKey -> SignedDSIGN StandardCrypto tosign
toShelleySigningKey :: ShelleyWitnessSigningKey -> ShelleySigningKey
fromConsensusBlock :: ConsensusBlockForMode mode ~ block => LedgerSupportsProtocol (ShelleyBlock (TPraos StandardCrypto) (ShelleyEra StandardCrypto)) => ConsensusMode mode -> block -> BlockInMode mode
toConsensusBlock :: ConsensusBlockForMode mode ~ block => LedgerSupportsProtocol (ShelleyBlock (TPraos StandardCrypto) (ShelleyEra StandardCrypto)) => BlockInMode mode -> block
fromConsensusTip :: ConsensusBlockForMode mode ~ block => ConsensusMode mode -> Tip block -> ChainTip
fromConsensusPointInMode :: ConsensusMode mode -> Point (ConsensusBlockForMode mode) -> ChainPoint
toConsensusPointInMode :: ConsensusMode mode -> ChainPoint -> Point (ConsensusBlockForMode mode)

-- | Convert a <a>Point</a> for multi-era block type
toConsensusPointHF :: HeaderHash block ~ OneEraHash xs => ChainPoint -> Point block
toShelleyMetadata :: Map Word64 TxMetadataValue -> Map Word64 Metadatum
fromShelleyMetadata :: Map Word64 Metadatum -> Map Word64 TxMetadataValue
toShelleyMetadatum :: TxMetadataValue -> Metadatum
fromShelleyMetadatum :: Metadatum -> TxMetadataValue

-- | The values of the set of <i>updatable</i> protocol parameters. At any
--   particular point on the chain there is a current set of parameters in
--   use.
--   
--   These parameters can be updated (at epoch boundaries) via an
--   <a>UpdateProposal</a>, which contains a
--   <a>ProtocolParametersUpdate</a>.
--   
--   The <a>ProtocolParametersUpdate</a> is essentially a diff for the
--   <a>ProtocolParameters</a>.
--   
--   There are also parameters fixed in the Genesis file. See
--   <tt>GenesisParameters</tt>.
data ProtocolParameters
ProtocolParameters :: (Natural, Natural) -> Maybe Rational -> Maybe PraosNonce -> Natural -> Natural -> Natural -> Natural -> Natural -> Maybe Lovelace -> Lovelace -> Lovelace -> Lovelace -> EpochNo -> Natural -> Rational -> Rational -> Rational -> Maybe Lovelace -> Map AnyPlutusScriptVersion CostModel -> Maybe ExecutionUnitPrices -> Maybe ExecutionUnits -> Maybe ExecutionUnits -> Maybe Natural -> Maybe Natural -> Maybe Natural -> Maybe Lovelace -> ProtocolParameters

-- | Protocol version, major and minor. Updating the major version is used
--   to trigger hard forks. (Major , Minor )
[protocolParamProtocolVersion] :: ProtocolParameters -> (Natural, Natural)

-- | The decentralization parameter. This is fraction of slots that belong
--   to the BFT overlay schedule, rather than the Praos schedule. So 1
--   means fully centralised, while 0 means fully decentralised.
--   
--   This is the "d" parameter from the design document.
--   
--   <i>Deprecated in Babbage</i>
[protocolParamDecentralization] :: ProtocolParameters -> Maybe Rational

-- | Extra entropy for the Praos per-epoch nonce.
--   
--   This can be used to add extra entropy during the decentralisation
--   process. If the extra entropy can be demonstrated to be generated
--   randomly then this method can be used to show that the initial
--   federated operators did not subtly bias the initial schedule so that
--   they retain undue influence after decentralisation.
[protocolParamExtraPraosEntropy] :: ProtocolParameters -> Maybe PraosNonce

-- | The maximum permitted size of a block header.
--   
--   This must be at least as big as the largest legitimate block headers
--   but should not be too much larger, to help prevent DoS attacks.
--   
--   Caution: setting this to be smaller than legitimate block headers is a
--   sure way to brick the system!
[protocolParamMaxBlockHeaderSize] :: ProtocolParameters -> Natural

-- | The maximum permitted size of the block body (that is, the block
--   payload, without the block header).
--   
--   This should be picked with the Praos network delta security parameter
--   in mind. Making this too large can severely weaken the Praos consensus
--   properties.
--   
--   Caution: setting this to be smaller than a transaction that can change
--   the protocol parameters is a sure way to brick the system!
[protocolParamMaxBlockBodySize] :: ProtocolParameters -> Natural

-- | The maximum permitted size of a transaction.
--   
--   Typically this should not be too high a fraction of the block size,
--   otherwise wastage from block fragmentation becomes a problem, and the
--   current implementation does not use any sophisticated box packing
--   algorithm.
[protocolParamMaxTxSize] :: ProtocolParameters -> Natural

-- | The constant factor for the minimum fee calculation.
[protocolParamTxFeeFixed] :: ProtocolParameters -> Natural

-- | The linear factor for the minimum fee calculation.
[protocolParamTxFeePerByte] :: ProtocolParameters -> Natural

-- | The minimum permitted value for new UTxO entries, ie for transaction
--   outputs.
[protocolParamMinUTxOValue] :: ProtocolParameters -> Maybe Lovelace

-- | The deposit required to register a stake address.
[protocolParamStakeAddressDeposit] :: ProtocolParameters -> Lovelace

-- | The deposit required to register a stake pool.
[protocolParamStakePoolDeposit] :: ProtocolParameters -> Lovelace

-- | The minimum value that stake pools are permitted to declare for their
--   cost parameter.
[protocolParamMinPoolCost] :: ProtocolParameters -> Lovelace

-- | The maximum number of epochs into the future that stake pools are
--   permitted to schedule a retirement.
[protocolParamPoolRetireMaxEpoch] :: ProtocolParameters -> EpochNo

-- | The equilibrium target number of stake pools.
--   
--   This is the "k" incentives parameter from the design document.
[protocolParamStakePoolTargetNum] :: ProtocolParameters -> Natural

-- | The influence of the pledge in stake pool rewards.
--   
--   This is the "a_0" incentives parameter from the design document.
[protocolParamPoolPledgeInfluence] :: ProtocolParameters -> Rational

-- | The monetary expansion rate. This determines the fraction of the
--   reserves that are added to the fee pot each epoch.
--   
--   This is the "rho" incentives parameter from the design document.
[protocolParamMonetaryExpansion] :: ProtocolParameters -> Rational

-- | The fraction of the fee pot each epoch that goes to the treasury.
--   
--   This is the "tau" incentives parameter from the design document.
[protocolParamTreasuryCut] :: ProtocolParameters -> Rational

-- | Cost in ada per word of UTxO storage.
--   
--   <i>Introduced in Alonzo</i>
[protocolParamUTxOCostPerWord] :: ProtocolParameters -> Maybe Lovelace

-- | Cost models for script languages that use them.
--   
--   <i>Introduced in Alonzo</i>
[protocolParamCostModels] :: ProtocolParameters -> Map AnyPlutusScriptVersion CostModel

-- | Price of execution units for script languages that use them.
--   
--   <i>Introduced in Alonzo</i>
[protocolParamPrices] :: ProtocolParameters -> Maybe ExecutionUnitPrices

-- | Max total script execution resources units allowed per tx
--   
--   <i>Introduced in Alonzo</i>
[protocolParamMaxTxExUnits] :: ProtocolParameters -> Maybe ExecutionUnits

-- | Max total script execution resources units allowed per block
--   
--   <i>Introduced in Alonzo</i>
[protocolParamMaxBlockExUnits] :: ProtocolParameters -> Maybe ExecutionUnits

-- | Max size of a Value in a tx output.
--   
--   <i>Introduced in Alonzo</i>
[protocolParamMaxValueSize] :: ProtocolParameters -> Maybe Natural

-- | The percentage of the script contribution to the txfee that must be
--   provided as collateral inputs when including Plutus scripts.
--   
--   <i>Introduced in Alonzo</i>
[protocolParamCollateralPercent] :: ProtocolParameters -> Maybe Natural

-- | The maximum number of collateral inputs allowed in a transaction.
--   
--   <i>Introduced in Alonzo</i>
[protocolParamMaxCollateralInputs] :: ProtocolParameters -> Maybe Natural

-- | Cost in ada per byte of UTxO storage.
--   
--   <i>Introduced in Babbage</i>
[protocolParamUTxOCostPerByte] :: ProtocolParameters -> Maybe Lovelace
checkProtocolParameters :: forall era. IsCardanoEra era => ShelleyBasedEra era -> ProtocolParameters -> Either ProtocolParametersError ()
data ProtocolParametersError
PParamsErrorMissingMinUTxoValue :: AnyCardanoEra -> ProtocolParametersError
PParamsErrorMissingAlonzoProtocolParameter :: ProtocolParametersError
toShelleyScript :: ScriptInEra era -> Script (ShelleyLedgerEra era)

-- | Conversion for the <a>MultiSig</a> language used by the Shelley era.
toShelleyMultiSig :: SimpleScript SimpleScriptV1 -> MultiSig StandardCrypto

-- | Conversion for the <a>MultiSig</a> language used by the Shelley era.
fromShelleyMultiSig :: MultiSig StandardCrypto -> SimpleScript lang

-- | Conversion for the <a>Timelock</a> language that is shared between the
--   Allegra and Mary eras.
toAllegraTimelock :: forall lang. SimpleScript lang -> Timelock StandardCrypto

-- | Conversion for the <a>Timelock</a> language that is shared between the
--   Allegra and Mary eras.
fromAllegraTimelock :: TimeLocksSupported lang -> Timelock StandardCrypto -> SimpleScript lang
toShelleyScriptHash :: ScriptHash -> ScriptHash StandardCrypto
fromShelleyScriptHash :: ScriptHash StandardCrypto -> ScriptHash

-- | Plutus scripts.
--   
--   Note that Plutus scripts have a binary serialisation but no JSON
--   serialisation.
data PlutusScript lang
[PlutusScriptSerialised] :: ShortByteString -> PlutusScript lang

-- | Scripts can now exist in the UTxO at a transaction output. We can
--   reference these scripts via specification of a reference transaction
--   input in order to witness spending inputs, withdrawals, certificates
--   or to mint tokens. This datatype encapsulates this concept.
data PlutusScriptOrReferenceInput lang
PScript :: PlutusScript lang -> PlutusScriptOrReferenceInput lang
PReferenceScript :: TxIn -> Maybe ScriptHash -> PlutusScriptOrReferenceInput lang
data SimpleScriptOrReferenceInput lang
SScript :: SimpleScript lang -> SimpleScriptOrReferenceInput lang
SReferenceScript :: TxIn -> Maybe ScriptHash -> SimpleScriptOrReferenceInput lang
toPlutusData :: ScriptData -> Data
fromPlutusData :: Data -> ScriptData
toAlonzoData :: ScriptData -> Data ledgerera
fromAlonzoData :: Data ledgerera -> ScriptData
toAlonzoPrices :: ExecutionUnitPrices -> Maybe Prices
fromAlonzoPrices :: Prices -> ExecutionUnitPrices
toAlonzoExUnits :: ExecutionUnits -> ExUnits
fromAlonzoExUnits :: ExUnits -> ExecutionUnits
toAlonzoRdmrPtr :: ScriptWitnessIndex -> RdmrPtr
fromAlonzoRdmrPtr :: RdmrPtr -> ScriptWitnessIndex
scriptDataFromJsonDetailedSchema :: Value -> Either ScriptDataJsonSchemaError ScriptData
scriptDataToJsonDetailedSchema :: ScriptData -> Value
calculateExecutionUnitsLovelace :: ExecutionUnitPrices -> ExecutionUnits -> Maybe Lovelace

-- | A reference scripts is a script that can exist at a transaction
--   output. This greatly reduces the size of transactions that use scripts
--   as the script no longer has to be added to the transaction, they can
--   now be referenced via a transaction output.
data ReferenceScript era
[ReferenceScript] :: ReferenceTxInsScriptsInlineDatumsSupportedInEra era -> ScriptInAnyLang -> ReferenceScript era
[ReferenceScriptNone] :: ReferenceScript era
data ReferenceTxInsScriptsInlineDatumsSupportedInEra era
[ReferenceTxInsScriptsInlineDatumsInBabbageEra] :: ReferenceTxInsScriptsInlineDatumsSupportedInEra BabbageEra
refInsScriptsAndInlineDatsSupportedInEra :: CardanoEra era -> Maybe (ReferenceTxInsScriptsInlineDatumsSupportedInEra era)
refScriptToShelleyScript :: CardanoEra era -> ReferenceScript era -> StrictMaybe (Script (ShelleyLedgerEra era))
data Certificate
StakeAddressRegistrationCertificate :: StakeCredential -> Certificate
StakeAddressDeregistrationCertificate :: StakeCredential -> Certificate
StakeAddressDelegationCertificate :: StakeCredential -> PoolId -> Certificate
StakePoolRegistrationCertificate :: StakePoolParameters -> Certificate
StakePoolRetirementCertificate :: PoolId -> EpochNo -> Certificate
GenesisKeyDelegationCertificate :: Hash GenesisKey -> Hash GenesisDelegateKey -> Hash VrfKey -> Certificate
MIRCertificate :: MIRPot -> MIRTarget -> Certificate
toShelleyCertificate :: Certificate -> DCert StandardCrypto
fromShelleyCertificate :: DCert StandardCrypto -> Certificate
data OperationalCertificate
OperationalCertificate :: !OCert StandardCrypto -> !VerificationKey StakePoolKey -> OperationalCertificate
data OperationalCertificateIssueCounter
OperationalCertificateIssueCounter :: !Word64 -> !VerificationKey StakePoolKey -> OperationalCertificateIssueCounter
[opCertIssueCount] :: OperationalCertificateIssueCounter -> !Word64
[opCertIssueColdKey] :: OperationalCertificateIssueCounter -> !VerificationKey StakePoolKey
data OperationalCertIssueError

-- | The stake pool verification key expected for the
--   <a>OperationalCertificateIssueCounter</a> does not match the signing
--   key supplied for signing.
--   
--   Order: pool vkey expected, pool skey supplied
OperationalCertKeyMismatch :: VerificationKey StakePoolKey -> VerificationKey StakePoolKey -> OperationalCertIssueError

-- | A representation of the required fields for off-chain stake pool
--   metadata.
data StakePoolMetadata
StakePoolMetadata :: !Text -> !Text -> !Text -> !Text -> StakePoolMetadata

-- | A name of up to 50 characters.
stakePoolName :: StakePoolMetadata -> Text

-- | A description of up to 255 characters.
stakePoolDescription :: StakePoolMetadata -> Text

-- | A ticker of 3-5 characters, for a compact display of stake pools in a
--   wallet.
stakePoolTicker :: StakePoolMetadata -> Text

-- | A URL to a homepage with additional information about the pool. n.b.
--   the spec does not specify a character limit for this field.
stakePoolHomepage :: StakePoolMetadata -> Text
data StakePoolMetadataReference
StakePoolMetadataReference :: Text -> Hash StakePoolMetadata -> StakePoolMetadataReference
stakePoolMetadataURL :: StakePoolMetadataReference -> Text
stakePoolMetadataHash :: StakePoolMetadataReference -> Hash StakePoolMetadata
data StakePoolParameters
StakePoolParameters :: PoolId -> Hash VrfKey -> Lovelace -> Rational -> StakeAddress -> Lovelace -> [Hash StakeKey] -> [StakePoolRelay] -> Maybe StakePoolMetadataReference -> StakePoolParameters
stakePoolId :: StakePoolParameters -> PoolId
stakePoolVRF :: StakePoolParameters -> Hash VrfKey
stakePoolCost :: StakePoolParameters -> Lovelace
stakePoolMargin :: StakePoolParameters -> Rational
stakePoolRewardAccount :: StakePoolParameters -> StakeAddress
stakePoolPledge :: StakePoolParameters -> Lovelace
stakePoolOwners :: StakePoolParameters -> [Hash StakeKey]
stakePoolRelays :: StakePoolParameters -> [StakePoolRelay]
stakePoolMetadata :: StakePoolParameters -> Maybe StakePoolMetadataReference
data StakePoolRelay

-- | One or both of IPv4 &amp; IPv6
StakePoolRelayIp :: Maybe IPv4 -> Maybe IPv6 -> Maybe PortNumber -> StakePoolRelay

-- | An DNS name pointing to a <tt>A</tt> or <tt>AAAA</tt> record.
StakePoolRelayDnsARecord :: ByteString -> Maybe PortNumber -> StakePoolRelay

-- | A DNS name pointing to a <tt>SRV</tt> record.
StakePoolRelayDnsSrvRecord :: ByteString -> StakePoolRelay

-- | An epoch, i.e. the number of the epoch.
newtype EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64
data StakePoolKey
type PoolId = Hash StakePoolKey
data KesKey
newtype KESPeriod
KESPeriod :: Word -> KESPeriod
[unKESPeriod] :: KESPeriod -> Word
data VrfKey
data LocalNodeConnectInfo mode
LocalNodeConnectInfo :: ConsensusModeParams mode -> NetworkId -> FilePath -> LocalNodeConnectInfo mode

-- | The Shelley-only consensus mode consists of only the Shelley era.
--   
--   This was used for the early Shelley testnets prior to the use of the
--   multi-era <a>CardanoMode</a>. It is useful for setting up Shelley test
--   networks (e.g. for benchmarking) without having to go through the
--   complication of the hard fork from Byron to Shelley eras. It also
--   shows how a single-era consensus mode works. It may be replaced by
--   other single-era modes in future.
data ShelleyMode

-- | This GADT provides a value-level representation of all the consensus
--   modes. This enables pattern matching on the era to allow them to be
--   treated in a non-uniform way.
data ConsensusMode mode
[ByronMode] :: ConsensusMode ByronMode
[ShelleyMode] :: ConsensusMode ShelleyMode

-- | The protocols we can use with a local node. Use in conjunction with
--   <a>connectToLocalNode</a>.
--   
--   These protocols use the types from the rest of this API. The
--   conversion to/from the types used by the underlying wire formats is
--   handled by <a>connectToLocalNode</a>.
data LocalNodeClientProtocols block point tip slot tx txid txerr query m
LocalNodeClientProtocols :: LocalChainSyncClient block point tip m -> Maybe (LocalTxSubmissionClient tx txerr m ()) -> Maybe (LocalStateQueryClient block point query m ()) -> Maybe (LocalTxMonitorClient txid tx slot m ()) -> LocalNodeClientProtocols block point tip slot tx txid txerr query m

-- | A type family that connects our era type tags to equivalent type tags
--   used in the Shelley ledger library.
--   
--   This type mapping connect types from this API with types in the
--   Shelley ledger library which allows writing conversion functions in a
--   more generic way.
type family ShelleyLedgerEra era
data DebugLedgerState era
[DebugLedgerState] :: ShelleyLedgerEra era ~ ledgerera => NewEpochState ledgerera -> DebugLedgerState era
decodeDebugLedgerState :: forall era. () => FromCBOR (DebugLedgerState era) => SerialisedDebugLedgerState era -> Either ByteString (DebugLedgerState era)
newtype ProtocolState era
ProtocolState :: Serialised (ChainDepState (ConsensusProtocol era)) -> ProtocolState era
decodeProtocolState :: FromCBOR (ChainDepState (ConsensusProtocol era)) => ProtocolState era -> Either (ByteString, DecoderError) (ChainDepState (ConsensusProtocol era))
newtype SerialisedDebugLedgerState era
SerialisedDebugLedgerState :: Serialised (NewEpochState (ShelleyLedgerEra era)) -> SerialisedDebugLedgerState era
newtype SerialisedCurrentEpochState era
SerialisedCurrentEpochState :: Serialised (EpochState (ShelleyLedgerEra era)) -> SerialisedCurrentEpochState era
decodeCurrentEpochState :: forall era. Era (ShelleyLedgerEra era) => Share (TxOut (ShelleyLedgerEra era)) ~ Interns (Credential 'Staking (Crypto (ShelleyLedgerEra era))) => FromSharedCBOR (TxOut (ShelleyLedgerEra era)) => Share (TxOut (ShelleyLedgerEra era)) ~ Interns (Credential 'Staking (Crypto (ShelleyLedgerEra era))) => FromCBOR (PParams (ShelleyLedgerEra era)) => FromCBOR (Value (ShelleyLedgerEra era)) => FromCBOR (State (EraRule "PPUP" (ShelleyLedgerEra era))) => SerialisedCurrentEpochState era -> Either DecoderError (CurrentEpochState era)
newtype UTxO era
UTxO :: Map TxIn (TxOut CtxUTxO era) -> UTxO era
[unUTxO] :: UTxO era -> Map TxIn (TxOut CtxUTxO era)

-- | Establish a connection to a node and execute a single query using the
--   local state query protocol.
data AcquiringFailure
AFPointTooOld :: AcquiringFailure
AFPointNotOnChain :: AcquiringFailure

-- | System start
--   
--   Slots are counted from the system start.
newtype SystemStart
SystemStart :: UTCTime -> SystemStart
[getSystemStart] :: SystemStart -> UTCTime
data LeadershipError
LeaderErrDecodeLedgerStateFailure :: LeadershipError
LeaderErrDecodeProtocolStateFailure :: (ByteString, DecoderError) -> LeadershipError
LeaderErrDecodeProtocolEpochStateFailure :: DecoderError -> LeadershipError
LeaderErrGenesisSlot :: LeadershipError
LeaderErrStakePoolHasNoStake :: PoolId -> LeadershipError
LeaderErrStakeDistribUnstable :: SlotNo -> SlotNo -> SlotNo -> SlotNo -> LeadershipError
LeaderErrSlotRangeCalculationFailure :: Text -> LeadershipError
LeaderErrCandidateNonceStillEvolving :: LeadershipError

-- | Return the slots at which a particular stake pool operator is expected
--   to mint a block.
currentEpochEligibleLeadershipSlots :: forall era ledgerera. () => ShelleyLedgerEra era ~ ledgerera => Era ledgerera => PraosProtocolSupportsNode (ConsensusProtocol era) => HasField "_d" (PParams ledgerera) UnitInterval => Share (TxOut (ShelleyLedgerEra era)) ~ Interns (Credential 'Staking (Crypto (ShelleyLedgerEra era))) => FromCBOR (ChainDepState (ConsensusProtocol era)) => ShelleyBasedEra era -> ShelleyGenesis StandardShelley -> EpochInfo (Either Text) -> ProtocolParameters -> ProtocolState era -> PoolId -> SigningKey VrfKey -> SerialisedCurrentEpochState era -> EpochNo -> Either LeadershipError (Set SlotNo)
nextEpochEligibleLeadershipSlots :: forall era. HasField "_d" (PParams (ShelleyLedgerEra era)) UnitInterval => Era (ShelleyLedgerEra era) => Share (TxOut (ShelleyLedgerEra era)) ~ Interns (Credential 'Staking (Crypto (ShelleyLedgerEra era))) => FromCBOR (ChainDepState (ConsensusProtocol era)) => PraosProtocolSupportsNode (ConsensusProtocol era) => ShelleyBasedEra era -> ShelleyGenesis StandardShelley -> SerialisedCurrentEpochState era -> ProtocolState era -> PoolId -> SigningKey VrfKey -> ProtocolParameters -> EpochInfo (Either Text) -> (ChainTip, EpochNo) -> Either LeadershipError (Set SlotNo)

-- | Converts a Shelley payment address to a Plutus public key hash.
shelleyPayAddrToPlutusPubKHash :: Address ShelleyAddr -> Maybe PubKeyHash
toConsensusGenTx :: ConsensusBlockForMode mode ~ block => TxInMode mode -> GenTx block
fromAlonzoCostModels :: CostModels -> Map AnyPlutusScriptVersion CostModel
toShelleyNetwork :: NetworkId -> Network
fromShelleyPParams :: PParams ledgerera -> ProtocolParameters


-- | This module provides a library interface that is intended to be the
--   complete API for Byron covering everything, including exposing
--   constructors for the lower level types.
module Cardano.Api.Byron
data SomeByronSigningKey
AByronSigningKeyLegacy :: SigningKey ByronKeyLegacy -> SomeByronSigningKey
AByronSigningKey :: SigningKey ByronKey -> SomeByronSigningKey
data family Hash keyrole :: Type

-- | Addresses are used as locations where assets live. The address
--   determines the rights needed to spend assets at the address: in
--   particular holding some signing key or being able to satisfy the
--   conditions of a script.
--   
--   There are currently two types of address:
--   
--   <ul>
--   <li>Byron addresses, which use the type tag <a>ByronAddr</a>; and</li>
--   <li>Shelley addresses, which use the type tag <a>ShelleyAddr</a>.
--   Notably, Shelley addresses support scripts and stake delegation.</li>
--   </ul>
--   
--   The <i>address type</i> is subtly from the <i>ledger era</i> in which
--   each address type is valid: while Byron addresses are the only choice
--   in the Byron era, the Shelley era and all subsequent eras support both
--   Byron and Shelley addresses. The <a>Address</a> type param only says
--   the type of the address (either Byron or Shelley). The
--   <a>AddressInEra</a> type connects the address type with the era in
--   which it is supported.
data Address addrtype

-- | Byron addresses were the only supported address type in the original
--   Byron era.
[ByronAddress] :: Address -> Address ByronAddr
data NetworkId
Mainnet :: NetworkId
Testnet :: !NetworkMagic -> NetworkId
data TxBody era
[ByronTxBody] :: Annotated Tx ByteString -> TxBody ByronEra
newtype TxId
TxId :: Hash StandardCrypto EraIndependentTxBody -> TxId
data TxIn
TxIn :: TxId -> TxIx -> TxIn
data TxOut ctx era
TxOut :: AddressInEra era -> TxOutValue era -> TxOutDatum ctx era -> ReferenceScript era -> TxOut ctx era
newtype TxIx
TxIx :: Word -> TxIx
newtype Lovelace
Lovelace :: Integer -> Lovelace
data Tx era
[ByronTx] :: ATxAux ByteString -> Tx ByronEra
data KeyWitness era
[ByronKeyWitness] :: TxInWitness -> KeyWitness ByronEra

-- | Either a network ID or a Byron address to be used in constructing a
--   Shelley bootstrap witness.
data WitnessNetworkIdOrByronAddress

-- | Network ID.
--   
--   If this value is used in the construction of a Shelley bootstrap
--   witness, the result will not consist of a derivation path. If that is
--   required, specify a <a>WitnessByronAddress</a> value instead.
WitnessNetworkId :: !NetworkId -> WitnessNetworkIdOrByronAddress

-- | Byron address.
--   
--   If this value is used in the construction of a Shelley bootstrap
--   witness, both the network ID and derivation path will be extracted
--   from the address and used in the construction of the witness.
WitnessByronAddress :: !Address ByronAddr -> WitnessNetworkIdOrByronAddress
class Show e => Error e
displayError :: Error e => e -> String
data FileError e
FileError :: FilePath -> e -> FileError e
FileErrorTempFile :: FilePath -> FilePath -> Handle -> FileError e
FileIOError :: FilePath -> IOException -> FileError e
data LocalNodeConnectInfo mode
LocalNodeConnectInfo :: ConsensusModeParams mode -> NetworkId -> FilePath -> LocalNodeConnectInfo mode

-- | The Byron-only consensus mode consists of only the Byron era.
--   
--   This was used on the mainnet before the deployment of the multi-era
--   <a>CardanoMode</a>. It is now of little practical use, though it
--   illustrates how a single-era consensus mode works. It may be sensible
--   to remove this at some stage.
data ByronMode

-- | This GADT provides a value-level representation of all the consensus
--   modes. This enables pattern matching on the era to allow them to be
--   treated in a non-uniform way.
data ConsensusMode mode
[ByronMode] :: ConsensusMode ByronMode

-- | The protocols we can use with a local node. Use in conjunction with
--   <a>connectToLocalNode</a>.
--   
--   These protocols use the types from the rest of this API. The
--   conversion to/from the types used by the underlying wire formats is
--   handled by <a>connectToLocalNode</a>.
data LocalNodeClientProtocols block point tip slot tx txid txerr query m
LocalNodeClientProtocols :: LocalChainSyncClient block point tip m -> Maybe (LocalTxSubmissionClient tx txerr m ()) -> Maybe (LocalStateQueryClient block point query m ()) -> Maybe (LocalTxMonitorClient txid tx slot m ()) -> LocalNodeClientProtocols block point tip slot tx txid txerr query m

-- | A chain sync protocol client, on top of some effect <tt>m</tt>. The
--   first choice of request is within that <tt>m</tt>.
newtype ChainSyncClient header point tip (m :: Type -> Type) a
ChainSyncClient :: m (ClientStIdle header point tip m a) -> ChainSyncClient header point tip (m :: Type -> Type) a
[runChainSyncClient] :: ChainSyncClient header point tip (m :: Type -> Type) a -> m (ClientStIdle header point tip m a)
newtype LocalTxSubmissionClient tx reject (m :: Type -> Type) a
LocalTxSubmissionClient :: m (LocalTxClientStIdle tx reject m a) -> LocalTxSubmissionClient tx reject (m :: Type -> Type) a
newtype LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
LocalStateQueryClient :: m (ClientStIdle block point query m a) -> LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a
[runLocalStateQueryClient] :: LocalStateQueryClient block point (query :: Type -> Type) (m :: Type -> Type) a -> m (ClientStIdle block point query m a)

-- | NetworkMagic is used to differentiate between different networks
--   during the initial handshake.
newtype NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic
[unNetworkMagic] :: NetworkMagic -> Word32

-- | Byron era update proposal
newtype ByronUpdateProposal
ByronUpdateProposal :: AProposal ByteString -> ByronUpdateProposal
[unByronUpdateProposal] :: ByronUpdateProposal -> AProposal ByteString
data ByronProtocolParametersUpdate
ByronProtocolParametersUpdate :: !Maybe Word16 -> !Maybe Natural -> !Maybe Natural -> !Maybe Natural -> !Maybe Natural -> !Maybe Natural -> !Maybe LovelacePortion -> !Maybe LovelacePortion -> !Maybe LovelacePortion -> !Maybe LovelacePortion -> !Maybe SlotNumber -> !Maybe SoftforkRule -> !Maybe TxFeePolicy -> !Maybe EpochNumber -> ByronProtocolParametersUpdate

-- | Redundant. This was meant to be the version of the Plutus smart
--   contract language, however, there are no smart contracts nor scripts
--   in the Byron era.
[bPpuScriptVersion] :: ByronProtocolParametersUpdate -> !Maybe Word16

-- | Slot duration in milliseconds.
[bPpuSlotDuration] :: ByronProtocolParametersUpdate -> !Maybe Natural

-- | Maximum block size in bytes.
[bPpuMaxBlockSize] :: ByronProtocolParametersUpdate -> !Maybe Natural

-- | Maximum block header size in bytes.
[bPpuMaxHeaderSize] :: ByronProtocolParametersUpdate -> !Maybe Natural

-- | Maximum transaction size in bytes.
[bPpuMaxTxSize] :: ByronProtocolParametersUpdate -> !Maybe Natural

-- | Maximum update proposal size in bytes.
[bPpuMaxProposalSize] :: ByronProtocolParametersUpdate -> !Maybe Natural
[bPpuMpcThd] :: ByronProtocolParametersUpdate -> !Maybe LovelacePortion

-- | Heavyweight delegation threshold. The delegate (i.e stakeholder) must
--   possess no less than this threshold of stake in order to participate
--   in heavyweight delegation.
[bPpuHeavyDelThd] :: ByronProtocolParametersUpdate -> !Maybe LovelacePortion
[bPpuUpdateVoteThd] :: ByronProtocolParametersUpdate -> !Maybe LovelacePortion
[bPpuUpdateProposalThd] :: ByronProtocolParametersUpdate -> !Maybe LovelacePortion
[bPpuUpdateProposalTTL] :: ByronProtocolParametersUpdate -> !Maybe SlotNumber

-- | Values defining the softfork resolution rule. When the stake belonging
--   to block issuers, issuing a given block version, is greater than the
--   current softfork resolution threshold, this block version is adopted.
[bPpuSoftforkRule] :: ByronProtocolParametersUpdate -> !Maybe SoftforkRule

-- | Transaction fee policy represents a formula to compute the minimal
--   allowed Fee for a transaction. Transactions with lesser fees won't be
--   accepted.
[bPpuTxFeePolicy] :: ByronProtocolParametersUpdate -> !Maybe TxFeePolicy

-- | This has been re-purposed for unlocking the OuroborosBFT logic in the
--   software. Relevant: <a>CDEC-610</a>
[bPpuUnlockStakeEpoch] :: ByronProtocolParametersUpdate -> !Maybe EpochNumber
makeByronUpdateProposal :: NetworkId -> ProtocolVersion -> SoftwareVersion -> SystemTag -> InstallerHash -> SomeByronSigningKey -> ByronProtocolParametersUpdate -> ByronUpdateProposal
toByronLedgerUpdateProposal :: ByronUpdateProposal -> GenTx ByronBlock
makeProtocolParametersUpdate :: ByronProtocolParametersUpdate -> ProtocolParametersUpdate

-- | Byron era votes
newtype ByronVote
ByronVote :: AVote ByteString -> ByronVote
[unByronVote] :: ByronVote -> AVote ByteString
makeByronVote :: NetworkId -> SomeByronSigningKey -> ByronUpdateProposal -> Bool -> ByronVote
toByronLedgertoByronVote :: ByronVote -> GenTx ByronBlock
fromByronTxIn :: TxIn -> TxIn
toByronLovelace :: Lovelace -> Maybe Lovelace
toByronNetworkMagic :: NetworkId -> NetworkMagic
toByronProtocolMagicId :: NetworkId -> ProtocolMagicId
toByronRequiresNetworkMagic :: NetworkId -> RequiresNetworkMagic
