-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Groups
--   
--   A group is a monoid with invertibility.
@package groups
@version 0.5.3

module Data.Group

-- | A <a>Group</a> is a <a>Monoid</a> plus a function, <a>invert</a>, such
--   that:
--   
--   <pre>
--   a &lt;&gt; invert a == mempty
--   </pre>
--   
--   <pre>
--   invert a &lt;&gt; a == mempty
--   </pre>
class Monoid m => Group m
invert :: Group m => m -> m

-- | Group subtraction: <tt>x ~~ y == x &lt;&gt; invert y</tt>
(~~) :: Group m => m -> m -> m

-- | <pre>
--   <a>pow</a> a n == a &lt;&gt; a &lt;&gt; ... &lt;&gt; a
--   </pre>
--   
--   <pre>
--   (n lots of a)
--   </pre>
--   
--   If n is negative, the result is inverted.
pow :: (Group m, Integral x) => m -> x -> m
infixl 7 ~~

-- | An <a>Abelian</a> group is a <a>Group</a> that follows the rule:
--   
--   <pre>
--   a &lt;&gt; b == b &lt;&gt; a
--   </pre>
class Group g => Abelian g

-- | A <a>Group</a> G is <a>Cyclic</a> if there exists an element x of G
--   such that for all y in G, there exists an n, such that
--   
--   <pre>
--   y = pow x n
--   </pre>
class Group a => Cyclic a

-- | The generator of the <a>Cyclic</a> group.
generator :: Cyclic a => a

-- | Generate all elements of a <a>Cyclic</a> group using its
--   <a>generator</a>.
--   
--   <i>Note:</i> Fuses, does not terminate even for finite groups.
generated :: Cyclic a => [a]

-- | Lazily generate all elements of a <a>Cyclic</a> group using its
--   <a>generator</a>.
--   
--   <i>Note:</i> Fuses, terminates if the underlying group is finite.
generated' :: (Eq a, Cyclic a) => [a]
instance Data.Group.Cyclic ()
instance GHC.Real.Integral a => Data.Group.Cyclic (Data.Semigroup.Internal.Sum a)
instance Data.Group.Cyclic (Data.Proxy.Proxy x)
instance Data.Group.Cyclic a => Data.Group.Cyclic (Data.Functor.Const.Const a x)
instance Data.Group.Cyclic a => Data.Group.Cyclic (Data.Functor.Identity.Identity a)
instance Data.Group.Cyclic a => Data.Group.Cyclic (Data.Ord.Down a)
instance Data.Group.Abelian ()
instance GHC.Num.Num a => Data.Group.Abelian (Data.Semigroup.Internal.Sum a)
instance GHC.Real.Fractional a => Data.Group.Abelian (Data.Semigroup.Internal.Product a)
instance Data.Group.Abelian a => Data.Group.Abelian (Data.Semigroup.Internal.Dual a)
instance Data.Group.Abelian b => Data.Group.Abelian (a -> b)
instance (Data.Group.Abelian a, Data.Group.Abelian b) => Data.Group.Abelian (a, b)
instance (Data.Group.Abelian a, Data.Group.Abelian b, Data.Group.Abelian c) => Data.Group.Abelian (a, b, c)
instance (Data.Group.Abelian a, Data.Group.Abelian b, Data.Group.Abelian c, Data.Group.Abelian d) => Data.Group.Abelian (a, b, c, d)
instance (Data.Group.Abelian a, Data.Group.Abelian b, Data.Group.Abelian c, Data.Group.Abelian d, Data.Group.Abelian e) => Data.Group.Abelian (a, b, c, d, e)
instance Data.Group.Abelian a => Data.Group.Abelian (Data.Ord.Down a)
instance Data.Group.Abelian (Data.Proxy.Proxy x)
instance Data.Group.Abelian a => Data.Group.Abelian (Data.Functor.Const.Const a x)
instance Data.Group.Abelian a => Data.Group.Abelian (Data.Functor.Identity.Identity a)
instance (Data.Group.Abelian (f a), Data.Group.Abelian (g a)) => Data.Group.Abelian ((GHC.Generics.:*:) f g a)
instance Data.Group.Abelian (f (g a)) => Data.Group.Abelian ((GHC.Generics.:.:) f g a)
instance Data.Group.Abelian a => Data.Group.Abelian (Data.Functor.Contravariant.Op a b)
instance Data.Group.Group ()
instance GHC.Num.Num a => Data.Group.Group (Data.Semigroup.Internal.Sum a)
instance GHC.Real.Fractional a => Data.Group.Group (Data.Semigroup.Internal.Product a)
instance Data.Group.Group a => Data.Group.Group (Data.Semigroup.Internal.Dual a)
instance Data.Group.Group b => Data.Group.Group (a -> b)
instance (Data.Group.Group a, Data.Group.Group b) => Data.Group.Group (a, b)
instance (Data.Group.Group a, Data.Group.Group b, Data.Group.Group c) => Data.Group.Group (a, b, c)
instance (Data.Group.Group a, Data.Group.Group b, Data.Group.Group c, Data.Group.Group d) => Data.Group.Group (a, b, c, d)
instance (Data.Group.Group a, Data.Group.Group b, Data.Group.Group c, Data.Group.Group d, Data.Group.Group e) => Data.Group.Group (a, b, c, d, e)
instance Data.Group.Group a => Data.Group.Group (Data.Ord.Down a)
instance Data.Group.Group (Data.Proxy.Proxy x)
instance Data.Group.Group a => Data.Group.Group (Data.Functor.Const.Const a x)
instance Data.Group.Group a => Data.Group.Group (Data.Functor.Identity.Identity a)
instance (Data.Group.Group (f a), Data.Group.Group (g a)) => Data.Group.Group ((GHC.Generics.:*:) f g a)
instance Data.Group.Group (f (g a)) => Data.Group.Group ((GHC.Generics.:.:) f g a)
instance Data.Group.Group a => Data.Group.Group (Data.Functor.Contravariant.Op a b)
