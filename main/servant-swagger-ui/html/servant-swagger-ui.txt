-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Servant swagger ui
--   
--   Provide embedded swagger UI for servant and swagger (i.e.
--   servant-swagger)
--   
--   <a>https://github.com/swagger-api/swagger-ui</a>
@package servant-swagger-ui
@version 0.3.5.4.5.0


-- | Provides <tt>SwaggerUI</tt> and corresponding
--   <a>swaggerSchemaUIServer</a> to embed <a>swagger ui</a> into the
--   application.
--   
--   All of the UI files are embedded into the binary.
--   
--   Note that you need to depend on particular <tt>swagger-ui</tt>
--   compatible provider:
--   
--   <ul>
--   <li><a>https://hackage.haskell.org/package/swagger2</a></li>
--   <li><a>https://hackage.haskell.org/package/openapi3</a></li>
--   </ul>
--   
--   <i>An example:</i>
--   
--   <pre>
--   -- | Actual API.
--   type BasicAPI = Get '[PlainText, JSON] Text
--       :&lt;|&gt; "cat" :&gt; Capture ":name" CatName :&gt; Get '[JSON] Cat
--   
--   -- | API type with bells and whistles, i.e. schema file and swagger-ui.
--   type API = <a>SwaggerSchemaUI</a> "swagger-ui" "swagger.json"
--       :&lt;|&gt; BasicAPI
--   
--   -- | Servant server for an API
--   server :: Server API
--   server = <a>swaggerSchemaUIServer</a> swaggerDoc
--       :&lt;|&gt; (pure "Hello World" :&lt;|&gt; catEndpoint)
--     where
--       catEndpoint name = pure $ Cat name False
--   </pre>
module Servant.Swagger.UI

-- | Swagger schema + ui api.
--   
--   <tt>SwaggerSchemaUI "swagger-ui" "swagger.json"</tt> will result into
--   following hierarchy:
--   
--   <pre>
--   /swagger.json
--   /swagger-ui
--   /swagger-ui/index.html
--   /swagger-ui/...
--   </pre>
--   
--   This type does not actually force served type to be <tt>Swagger</tt>
--   from <tt>swagger2</tt> package, it could be arbitrary <tt>aeson</tt>
--   <a>Value</a>.
type SwaggerSchemaUI (dir :: Symbol) (schema :: Symbol) = SwaggerSchemaUI' dir schema :> Get '[JSON] Value

-- | Use <a>SwaggerSchemaUI'</a> when you need even more control over where
--   <tt>swagger.json</tt> is served (e.g. subdirectory).
type SwaggerSchemaUI' (dir :: Symbol) api = api :<|> dir :> Get '[HTML] SwaggerUiHtml dir api :<|> "index.html" :> Get '[HTML] SwaggerUiHtml dir api :<|> Raw

-- | Serve Swagger UI on <tt>/dir</tt> using <tt>api</tt> as a Swagger spec
--   source.
--   
--   <pre>
--   swaggerSchemaUIServer :: Swagger -&gt; Server (SwaggerSchemaUI schema dir)
--   swaggerSchemaUIServer :: OpenApi -&gt; Server (SwaggerSchemaUI schema dir)
--   </pre>
swaggerSchemaUIServer :: (Server api ~ Handler Value, ToJSON a) => a -> Server (SwaggerSchemaUI' dir api)

-- | Serve Swagger UI on <tt>/dir</tt> using <tt>api</tt> as a Swagger spec
--   source.
--   
--   Generalized to <a>ServerT</a>
--   
--   <pre>
--   swaggerSchemaUIServerT :: Swagger -&gt; ServerT (SwaggerSchemaUI schema dir) m
--   swaggerSchemaUIServerT :: OpenApi -&gt; ServerT (SwaggerSchemaUI schema dir) m
--   </pre>
swaggerSchemaUIServerT :: (Monad m, ServerT api m ~ m Value, ToJSON a) => a -> ServerT (SwaggerSchemaUI' dir api) m

-- | Use a custom server to serve the Swagger spec source.
--   
--   This allows even more control over how the spec source is served. It
--   allows, for instance, serving the spec source with authentication,
--   customizing the response based on the client or serving a swagger.yaml
--   instead.
swaggerSchemaUIServer' :: Server api -> Server (SwaggerSchemaUI' dir api)

-- | Use a custom server to serve the Swagger spec source.
--   
--   This allows even more control over how the spec source is served. It
--   allows, for instance, serving the spec source with authentication,
--   customizing the response based on the client or serving a swagger.yaml
--   instead.
--   
--   Generalized to <a>ServerT</a>
swaggerSchemaUIServerT' :: Monad m => ServerT api m -> ServerT (SwaggerSchemaUI' dir api) m
swaggerUiIndexTemplate :: Text
swaggerUiFiles :: [(FilePath, ByteString)]
