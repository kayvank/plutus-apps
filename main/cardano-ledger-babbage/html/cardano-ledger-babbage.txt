-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | TODO
--   
--   TODO
@package cardano-ledger-babbage
@version 0.1.0.0


-- | This module contains just the type of protocol parameters.
module Cardano.Ledger.Babbage.PParams

-- | Protocol parameters. Alonzo parameters without d and extraEntropy
data PParams' f era
PParams :: !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Coin -> !HKD f Coin -> !HKD f EpochNo -> !HKD f Natural -> !HKD f NonNegativeInterval -> !HKD f UnitInterval -> !HKD f UnitInterval -> !HKD f ProtVer -> !HKD f Coin -> !HKD f Coin -> !HKD f CostModels -> !HKD f Prices -> !HKD f ExUnits -> !HKD f ExUnits -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> PParams' f era

-- | The linear factor for the minimum fee calculation
[_minfeeA] :: PParams' f era -> !HKD f Natural

-- | The constant factor for the minimum fee calculation
[_minfeeB] :: PParams' f era -> !HKD f Natural

-- | Maximal block body size
[_maxBBSize] :: PParams' f era -> !HKD f Natural

-- | Maximal transaction size
[_maxTxSize] :: PParams' f era -> !HKD f Natural

-- | Maximal block header size
[_maxBHSize] :: PParams' f era -> !HKD f Natural

-- | The amount of a key registration deposit
[_keyDeposit] :: PParams' f era -> !HKD f Coin

-- | The amount of a pool registration deposit
[_poolDeposit] :: PParams' f era -> !HKD f Coin

-- | Maximum number of epochs in the future a pool retirement is allowed to
--   be scheduled for.
[_eMax] :: PParams' f era -> !HKD f EpochNo

-- | Desired number of pools
[_nOpt] :: PParams' f era -> !HKD f Natural

-- | Pool influence
[_a0] :: PParams' f era -> !HKD f NonNegativeInterval

-- | Monetary expansion
[_rho] :: PParams' f era -> !HKD f UnitInterval

-- | Treasury expansion
[_tau] :: PParams' f era -> !HKD f UnitInterval

-- | Protocol version
[_protocolVersion] :: PParams' f era -> !HKD f ProtVer

-- | Minimum Stake Pool Cost
[_minPoolCost] :: PParams' f era -> !HKD f Coin

-- | Cost in lovelace per byte of UTxO storage (instead of
--   _coinsPerUTxOByte)
[_coinsPerUTxOByte] :: PParams' f era -> !HKD f Coin

-- | Cost models for non-native script languages
[_costmdls] :: PParams' f era -> !HKD f CostModels

-- | Prices of execution units (for non-native script languages)
[_prices] :: PParams' f era -> !HKD f Prices

-- | Max total script execution resources units allowed per tx
[_maxTxExUnits] :: PParams' f era -> !HKD f ExUnits

-- | Max total script execution resources units allowed per block
[_maxBlockExUnits] :: PParams' f era -> !HKD f ExUnits

-- | Max size of a Value in an output
[_maxValSize] :: PParams' f era -> !HKD f Natural

-- | Percentage of the txfee which must be provided as collateral when
--   including non-native scripts.
[_collateralPercentage] :: PParams' f era -> !HKD f Natural

-- | Maximum number of collateral inputs allowed in a transaction
[_maxCollateralInputs] :: PParams' f era -> !HKD f Natural
type PParams = PParams' Identity

-- | Returns a basic "empty" <a>PParams</a> structure with all zero values.
emptyPParams :: PParams era
type PParamsUpdate era = PParams' StrictMaybe era
emptyPParamsUpdate :: PParamsUpdate era

-- | Update operation for protocol parameters structure @PParams
updatePParams :: PParams era -> PParamsUpdate era -> PParams era
getLanguageView :: HasField "_costmdls" (PParams era) CostModels => PParams era -> Language -> LangDepView
data LangDepView
LangDepView :: ByteString -> ByteString -> LangDepView
[tag] :: LangDepView -> ByteString
[params] :: LangDepView -> ByteString
encodeLangViews :: Set LangDepView -> Encoding

-- | Turn an PParams' into a Shelley.Params'
retractPP :: HKD f Coin -> HKD f UnitInterval -> HKD f Nonce -> PParams' f era -> PParams' f era

-- | Given the missing pieces Turn a Shelley.PParams' into an Params'
extendPP :: PParams' f era1 -> HKD f Coin -> HKD f CostModels -> HKD f Prices -> HKD f ExUnits -> HKD f ExUnits -> HKD f Natural -> HKD f Natural -> HKD f Natural -> PParams' f era2
instance GHC.Generics.Generic (Cardano.Ledger.Babbage.PParams.PParams' f era)
instance GHC.Classes.Eq (Cardano.Ledger.Babbage.PParams.PParams' Data.Functor.Identity.Identity era)
instance GHC.Show.Show (Cardano.Ledger.Babbage.PParams.PParams' Data.Functor.Identity.Identity era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Babbage.PParams.PParams' Data.Functor.Identity.Identity era)
instance GHC.Classes.Eq (Cardano.Ledger.Babbage.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)
instance GHC.Show.Show (Cardano.Ledger.Babbage.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Babbage.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Babbage.PParams.PParams era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Babbage.PParams.PParams era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Babbage.PParams.PParams era)
instance Data.Default.Class.Default (Cardano.Ledger.Babbage.PParams.PParams era)
instance GHC.Records.HasField "_d" (Cardano.Ledger.Babbage.PParams.PParams era) Cardano.Ledger.BaseTypes.UnitInterval
instance NoThunks.Class.NoThunks (Cardano.Ledger.Babbage.PParams.PParamsUpdate era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Babbage.PParams.PParamsUpdate era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Babbage.PParams.PParamsUpdate era)
instance GHC.Classes.Ord (Cardano.Ledger.Babbage.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)

module Cardano.Ledger.Babbage.Genesis
data AlonzoGenesis
AlonzoGenesis :: !Coin -> !CostModels -> !Prices -> !ExUnits -> !ExUnits -> !Natural -> !Natural -> !Natural -> AlonzoGenesis
[coinsPerUTxOWord] :: AlonzoGenesis -> !Coin
[costmdls] :: AlonzoGenesis -> !CostModels
[prices] :: AlonzoGenesis -> !Prices
[maxTxExUnits] :: AlonzoGenesis -> !ExUnits
[maxBlockExUnits] :: AlonzoGenesis -> !ExUnits
[maxValSize] :: AlonzoGenesis -> !Natural
[collateralPercentage] :: AlonzoGenesis -> !Natural
[maxCollateralInputs] :: AlonzoGenesis -> !Natural

-- | Given the missing pieces turn a Shelley.PParams' into an Params'
extendPPWithGenesis :: PParams' Identity era1 -> AlonzoGenesis -> PParams' Identity era2

module Cardano.Ledger.Babbage.TxBody
data TxOut era
TxOutCompactDatum :: {-# UNPACK #-} !CompactAddr (Crypto era) -> !CompactForm (Value era) -> {-# UNPACK #-} !BinaryData era -> TxOut era
TxOutCompactRefScript :: {-# UNPACK #-} !CompactAddr (Crypto era) -> !CompactForm (Value era) -> !Datum era -> !Script era -> TxOut era
pattern TxOut :: forall era. (Era era, Compactible (Value era), Val (Value era), HasCallStack) => Addr (Crypto era) -> Value era -> Datum era -> StrictMaybe (Script era) -> TxOut era
pattern TxOutCompact :: (Era era, HasCallStack) => CompactAddr (Crypto era) -> CompactForm (Value era) -> TxOut era
pattern TxOutCompactDH :: (Era era, HasCallStack) => CompactAddr (Crypto era) -> CompactForm (Value era) -> DataHash (Crypto era) -> TxOut era
data TxBody era
pattern TxBody :: BabbageBody era => Set (TxIn (Crypto era)) -> Set (TxIn (Crypto era)) -> Set (TxIn (Crypto era)) -> StrictSeq (Sized (TxOut era)) -> StrictMaybe (Sized (TxOut era)) -> StrictMaybe Coin -> StrictSeq (DCert (Crypto era)) -> Wdrl (Crypto era) -> Coin -> ValidityInterval -> StrictMaybe (Update era) -> Set (KeyHash 'Witness (Crypto era)) -> Value (Crypto era) -> StrictMaybe (ScriptIntegrityHash (Crypto era)) -> StrictMaybe (AuxiliaryDataHash (Crypto era)) -> StrictMaybe Network -> TxBody era

-- | Datum can be described by a either a data hash or binary data, but not
--   both. It can also be neither one of them.
data Datum era
NoDatum :: Datum era
DatumHash :: !DataHash (Crypto era) -> Datum era
Datum :: !BinaryData era -> Datum era
spendInputs' :: TxBody era -> Set (TxIn (Crypto era))
collateralInputs' :: TxBody era -> Set (TxIn (Crypto era))
referenceInputs' :: TxBody era -> Set (TxIn (Crypto era))
outputs' :: TxBody era -> StrictSeq (TxOut era)
collateralReturn' :: TxBody era -> StrictMaybe (TxOut era)
totalCollateral' :: TxBody era -> StrictMaybe Coin
certs' :: TxBody era -> StrictSeq (DCert (Crypto era))
wdrls' :: TxBody era -> Wdrl (Crypto era)
txfee' :: TxBody era -> Coin
vldt' :: TxBody era -> ValidityInterval
update' :: TxBody era -> StrictMaybe (Update era)
reqSignerHashes' :: TxBody era -> Set (KeyHash 'Witness (Crypto era))
mint' :: TxBody era -> Value (Crypto era)
scriptIntegrityHash' :: TxBody era -> StrictMaybe (ScriptIntegrityHash (Crypto era))
adHash' :: TxBody era -> StrictMaybe (AuxiliaryDataHash (Crypto era))
txnetworkid' :: TxBody era -> StrictMaybe Network
getBabbageTxOutEitherAddr :: HashAlgorithm (ADDRHASH (Crypto era)) => TxOut era -> Either (Addr (Crypto era)) (CompactAddr (Crypto era))
type BabbageBody era = (Era era, ToCBOR (Value era), ToCBOR (Script era), SerialisableData (PParamsDelta era))
data EraIndependentScriptIntegrity
type ScriptIntegrityHash crypto = SafeHash crypto EraIndependentScriptIntegrity
txOutData :: TxOut era -> Maybe (Data era)

-- | Return the data hash of a given transaction output, if one is present.
--   Note that this function does *not* return the hash of any inline
--   datums that are present.
txOutDataHash :: Era era => TxOut era -> Maybe (DataHash (Crypto era))
txOutScript :: TxOut era -> Maybe (Script era)
instance GHC.Generics.Generic (Cardano.Ledger.Babbage.TxBody.TxBodyRaw era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Babbage.TxBody.TxBody era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Babbage.TxBody.TxBody era)
instance (GHC.Classes.Eq (Cardano.Ledger.Core.Value era), GHC.Classes.Eq (Cardano.Ledger.Core.Script era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era)) => GHC.Classes.Eq (Cardano.Ledger.Babbage.TxBody.TxOut era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Babbage.TxBody.TxOut era)
instance (GHC.Classes.Eq (Cardano.Ledger.Core.Value era), GHC.Classes.Eq (Cardano.Ledger.Core.Script era), Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Classes.Eq (Cardano.Ledger.Core.PParamsDelta era)) => GHC.Classes.Eq (Cardano.Ledger.Babbage.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Script era), GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era)) => GHC.Show.Show (Cardano.Ledger.Babbage.TxBody.TxBodyRaw era)
instance Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era) => GHC.Classes.Eq (Cardano.Ledger.Babbage.TxBody.TxBody era)
instance (Data.Typeable.Internal.Typeable era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParamsDelta era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Babbage.TxBody.TxBody era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Script era), GHC.Show.Show (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era)) => GHC.Show.Show (Cardano.Ledger.Babbage.TxBody.TxBody era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Ledger.Core.SerialisableData (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Babbage.TxBody.TxBody era))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Babbage.TxBody.TxBody era) Cardano.Ledger.Hashes.EraIndependentTxBody c
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "inputs" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn c))
instance GHC.Records.HasField "outputs" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Babbage.TxBody.TxOut era))
instance GHC.Records.HasField "sizedOutputs" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Serialization.Sized (Cardano.Ledger.Babbage.TxBody.TxOut era)))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "certs" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Shelley.TxBody.DCert crypto))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "wdrls" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance GHC.Records.HasField "txfee" (Cardano.Ledger.Babbage.TxBody.TxBody era) Cardano.Ledger.Coin.Coin
instance GHC.Records.HasField "update" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Shelley.PParams.Update era))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "reqSignerHashes" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.Keys.KeyHash 'Cardano.Ledger.Keys.Witness c))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "mint" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Cardano.Ledger.Mary.Value.Value c)
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "collateral" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn c))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "referenceInputs" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn c))
instance GHC.Records.HasField "collateralReturn" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Babbage.TxBody.TxOut era))
instance GHC.Records.HasField "sizedCollateralReturn" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Serialization.Sized (Cardano.Ledger.Babbage.TxBody.TxOut era)))
instance GHC.Records.HasField "totalCollateral" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe Cardano.Ledger.Coin.Coin)
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "minted" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.Hashes.ScriptHash c))
instance GHC.Records.HasField "vldt" (Cardano.Ledger.Babbage.TxBody.TxBody era) Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "adHash" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "scriptIntegrityHash" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Babbage.TxBody.ScriptIntegrityHash c))
instance GHC.Records.HasField "txnetworkid" (Cardano.Ledger.Babbage.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe Cardano.Ledger.BaseTypes.Network)
instance (Data.Typeable.Internal.Typeable era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParamsDelta era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Babbage.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParamsDelta era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Babbage.TxBody.TxBodyRaw era))
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParamsDelta era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Babbage.TxBody.TxBodyRaw era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Babbage.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Script era), GHC.Show.Show (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Core.Value era))) => GHC.Show.Show (Cardano.Ledger.Babbage.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Script era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Babbage.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Babbage.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era)) => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Babbage.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.Value era GHC.Types.~ val, Cardano.Ledger.Compactible.Compactible val) => GHC.Records.HasField "value" (Cardano.Ledger.Babbage.TxBody.TxOut era) val
instance (Cardano.Ledger.Era.Era era, c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "datahash" (Cardano.Ledger.Babbage.TxBody.TxOut era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Hashes.DataHash c))
instance (Cardano.Ledger.Era.Era era, s GHC.Types.~ Cardano.Ledger.Core.Script era) => GHC.Records.HasField "referenceScript" (Cardano.Ledger.Babbage.TxBody.TxOut era) (Data.Maybe.Strict.StrictMaybe s)

module Cardano.Ledger.Babbage.Tx
alonzoInputHashes :: (HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), ValidateScript era, TxOut era ~ TxOut era) => Map (ScriptHash (Crypto era)) (Script era) -> ValidatedTx era -> UTxO era -> (Set (DataHash (Crypto era)), Set (TxIn (Crypto era)))

-- | Compute if an Addr has the hash of a TwoPhaseScript, we can tell what
--   kind of Script from the Hash, by looking it up in the Map
isTwoPhaseScriptAddressFromMap :: ValidateScript era => Map (ScriptHash (Crypto era)) (Script era) -> Addr (Crypto era) -> Bool

-- | Encode to CBOR for the purposes of transmission from node to node, or
--   from wallet to node.
--   
--   Note that this serialisation is neither the serialisation used
--   on-chain (where Txs are deconstructed using segwit), nor the
--   serialisation used for computing the transaction size (which omits the
--   <a>IsValid</a> field for compatibility with Mary - see
--   <a>toCBORForSizeComputation</a>).
toCBORForMempoolSubmission :: (Typeable era, ToCBOR (TxBody era), ToCBOR (AuxiliaryData era)) => ValidatedTx era -> Encoding
segwitTx :: Annotator (TxBody era) -> Annotator (TxWitness era) -> IsValid -> Maybe (Annotator (AuxiliaryData era)) -> Annotator (ValidatedTx era)

-- | Find the Data and ExUnits assigned to a script.
indexedRdmrs :: (Era era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wits" tx (TxWitness era), HasField "body" tx (TxBody era)) => tx -> ScriptPurpose (Crypto era) -> Maybe (Data era, ExUnits)
getMapFromValue :: Value crypto -> Map (PolicyID crypto) (Map AssetName Integer)
rdptrInv :: (HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "minted" (TxBody era) (Set (ScriptHash (Crypto era)))) => TxBody era -> RdmrPtr -> StrictMaybe (ScriptPurpose (Crypto era))
rdptr :: (HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "minted" (TxBody era) (Set (ScriptHash (Crypto era)))) => TxBody era -> ScriptPurpose (Crypto era) -> StrictMaybe RdmrPtr
totExUnits :: (HasField "wits" (Tx era) (Witnesses era), HasField "txrdmrs" (Witnesses era) (Redeemers era)) => Tx era -> ExUnits
minfee :: (HasField "_minfeeA" (PParams era) Natural, HasField "_minfeeB" (PParams era) Natural, HasField "_prices" (PParams era) Prices, HasField "wits" (Tx era) (Witnesses era), HasField "txrdmrs" (Witnesses era) (Redeemers era), HasField "txsize" (Tx era) Integer) => PParams era -> Tx era -> Coin

-- | This ensures that the size of transactions from Mary is unchanged. The
--   individual components all store their bytes; the only work we do in
--   this function is concatenating
toCBORForSizeComputation :: (Typeable era, ToCBOR (TxBody era), ToCBOR (AuxiliaryData era)) => ValidatedTx era -> Encoding
isTwoPhaseScriptAddress :: ValidateScript era => ValidatedTx era -> Addr (Crypto era) -> Bool
hashScriptIntegrity :: Era era => Set LangDepView -> Redeemers era -> TxDats era -> StrictMaybe (ScriptIntegrityHash (Crypto era))
getCoin :: Era era => TxOut era -> Coin

-- | Tag indicating whether non-native scripts in this transaction are
--   expected to validate. This is added by the block creator when
--   constructing the block.
newtype IsValid
IsValid :: Bool -> IsValid
data ValidatedTx era
ValidatedTx :: !TxBody era -> !TxWitness era -> !IsValid -> !StrictMaybe (AuxiliaryData era) -> ValidatedTx era
[body] :: ValidatedTx era -> !TxBody era
[wits] :: ValidatedTx era -> !TxWitness era
[isValid] :: ValidatedTx era -> !IsValid
[auxiliaryData] :: ValidatedTx era -> !StrictMaybe (AuxiliaryData era)

-- | A ScriptIntegrityHash is the hash of three things. The first two come
--   from the witnesses and the last comes from the Protocol Parameters.
data ScriptIntegrity era
ScriptIntegrity :: !Redeemers era -> !TxDats era -> !Set LangDepView -> ScriptIntegrity era
data ScriptPurpose crypto
Minting :: !PolicyID crypto -> ScriptPurpose crypto
Spending :: !TxIn crypto -> ScriptPurpose crypto
Rewarding :: !RewardAcnt crypto -> ScriptPurpose crypto
Certifying :: !DCert crypto -> ScriptPurpose crypto
class Indexable elem container
indexOf :: Indexable elem container => elem -> container -> StrictMaybe Word64
fromIndex :: Indexable elem container => Word64 -> container -> StrictMaybe elem
txdats' :: TxWitness era -> TxDats era
txrdmrs :: TxWitness era -> (Era era, Script era ~ Script era) => Redeemers era
txscripts' :: TxWitness era -> Map (ScriptHash (Crypto era)) (Script era)
type ScriptIntegrityHash crypto = SafeHash crypto EraIndependentScriptIntegrity
hashData :: Era era => Data era -> DataHash (Crypto era)
data Data era
getLanguageView :: HasField "_costmdls" (PParams era) CostModels => PParams era -> Language -> LangDepView

-- | A language dependent cost model for the Plutus evaluator. Note that
--   the <a>EvaluationContext</a> is entirely dependent on the cost model
--   parameters (ie the <a>Map</a> <a>Text</a> <a>Integer</a>) and that
--   this type uses the smart constructor <a>mkCostModel</a> to hide the
--   evaluation context.
data CostModel
nonNativeLanguages :: [Language]

-- | Compute the transaction outputs of a transaction.
txouts :: Era era => TxBody era -> UTxO era
data EraIndependentScriptIntegrity
type DataHash crypto = SafeHash crypto EraIndependentData
data TxBody era
pattern TxBody :: BabbageBody era => Set (TxIn (Crypto era)) -> Set (TxIn (Crypto era)) -> Set (TxIn (Crypto era)) -> StrictSeq (Sized (TxOut era)) -> StrictMaybe (Sized (TxOut era)) -> StrictMaybe Coin -> StrictSeq (DCert (Crypto era)) -> Wdrl (Crypto era) -> Coin -> ValidityInterval -> StrictMaybe (Update era) -> Set (KeyHash 'Witness (Crypto era)) -> Value (Crypto era) -> StrictMaybe (ScriptIntegrityHash (Crypto era)) -> StrictMaybe (AuxiliaryDataHash (Crypto era)) -> StrictMaybe Network -> TxBody era


-- | Figure 3: Functions related to scripts Babbage Specification
module Cardano.Ledger.Babbage.Scripts

-- | Extract binary data either directly from the <a>Tx</a> as an "inline
--   datum" or look it up in the witnesses by the hash.
getDatumBabbage :: (Era era, TxOut era ~ TxOut era, Witnesses era ~ TxWitness era) => Tx era -> UTxO era -> ScriptPurpose (Crypto era) -> Maybe (Data era)
babbageTxScripts :: forall era. (ValidateScript era, HasField "referenceScript" (TxOut era) (StrictMaybe (Script era)), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "referenceInputs" (TxBody era) (Set (TxIn (Crypto era)))) => UTxO era -> Tx era -> Map (ScriptHash (Crypto era)) (Script era)

-- | Collect all the reference scripts found in the TxOuts, pointed to by
--   some input.
refScripts :: forall era. (ValidateScript era, HasField "referenceScript" (TxOut era) (StrictMaybe (Script era))) => Set (TxIn (Crypto era)) -> UTxO era -> Map (ScriptHash (Crypto era)) (Script era)
babbageInputDataHashes :: forall era. (HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), ValidateScript era, TxOut era ~ TxOut era) => Map (ScriptHash (Crypto era)) (Script era) -> ValidatedTx era -> UTxO era -> (Set (DataHash (Crypto era)), Set (TxIn (Crypto era)))


-- | Figure 2: Functions related to fees and collateral Babbage
--   Specification
module Cardano.Ledger.Babbage.Collateral
isTwoPhaseScriptAddress :: forall era. (ValidateScript era, ExtendedUTxO era) => Tx era -> UTxO era -> Addr (Crypto era) -> Bool
collBalance :: forall era. (Era era, HasField "collateralReturn" (TxBody era) (StrictMaybe (TxOut era)), HasField "collateral" (TxBody era) (Set (TxIn (Crypto era)))) => TxBody era -> UTxO era -> Value era
collOuts :: (Era era, TxBody era ~ TxBody era, TxOut era ~ TxOut era) => TxBody era -> UTxO era

module Cardano.Ledger.Babbage.Rules.Utxos
type ConcreteBabbage era = (Script era ~ Script era, Value era ~ Value (Crypto era), TxBody era ~ TxBody era, PParams era ~ PParams era, PParamsDelta era ~ PParamsUpdate era, TxOut era ~ TxOut era, Tx era ~ ValidatedTx era, Witnesses era ~ TxWitness era)
data BabbageUTXOS era
utxosTransition :: forall era. (ConcreteBabbage era, ExtendedUTxO era, Environment (EraRule "PPUP" era) ~ PPUPEnv era, State (EraRule "PPUP" era) ~ PPUPState era, Signal (EraRule "PPUP" era) ~ Maybe (Update era), Embed (EraRule "PPUP" era) (BabbageUTXOS era), ValidateScript era, ToCBOR (PredicateFailure (EraRule "PPUP" era)), HasField "collateral" (TxBody era) (Set (TxIn (Crypto era)))) => TransitionRule (BabbageUTXOS era)
scriptsYes :: forall era. (ValidateScript era, ConcreteBabbage era, ExtendedUTxO era, STS (BabbageUTXOS era), Environment (EraRule "PPUP" era) ~ PPUPEnv era, State (EraRule "PPUP" era) ~ PPUPState era, Signal (EraRule "PPUP" era) ~ Maybe (Update era), Embed (EraRule "PPUP" era) (BabbageUTXOS era)) => TransitionRule (BabbageUTXOS era)
scriptsNo :: forall era. (ValidateScript era, ConcreteBabbage era, ExtendedUTxO era, STS (BabbageUTXOS era), HasField "collateral" (TxBody era) (Set (TxIn (Crypto era)))) => TransitionRule (BabbageUTXOS era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Babbage.Rules.Utxos.ConcreteBabbage era, Cardano.Ledger.Alonzo.TxInfo.ExtendedUTxO era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "PPUP" era) (Cardano.Ledger.Babbage.Rules.Utxos.BabbageUTXOS era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PPUPEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.PPUPState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ GHC.Maybe.Maybe (Cardano.Ledger.Shelley.PParams.Update era), Cardano.Ledger.Era.ValidateScript era, Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => Control.State.Transition.Extended.STS (Cardano.Ledger.Babbage.Rules.Utxos.BabbageUTXOS era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Control.State.Transition.Extended.Event (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era) (Cardano.Ledger.Babbage.Rules.Utxos.BabbageUTXOS era)

module Cardano.Ledger.Babbage.Rules.Utxo
data BabbageUTXO era

-- | Predicate failure for the Babbage Era
data BabbageUtxoPred era
FromAlonzoUtxoFail :: !UtxoPredicateFailure era -> BabbageUtxoPred era

-- | The collateral is not equivalent to the total collateral asserted by
--   the transaction
IncorrectTotalCollateralField :: !Coin -> !Coin -> BabbageUtxoPred era

-- | list of supplied transaction outputs that are too small, together with
--   the minimum value for the given output.
BabbageOutputTooSmallUTxO :: ![(TxOut era, Coin)] -> BabbageUtxoPred era

-- | feesOK is a predicate with several parts. Some parts only apply in
--   special circumstances. 1) The fee paid is &gt;= the minimum fee 2) If
--   the total ExUnits are 0 in both Memory and Steps, no further part
--   needs to be checked. 3) The collateral consists only of VKey addresses
--   4) The collateral inputs do not contain any non-ADA part 5) The
--   collateral is sufficient to cover the appropriate percentage of the
--   fee marked in the transaction 6) The collateral is equivalent to total
--   collateral asserted by the transaction 7) There is at least one
--   collateral input
--   
--   feesOK can differ from Era to Era, as new notions of fees arise. This
--   is the Babbage version See: Figure 2: Functions related to fees and
--   collateral, in the Babbage specification In the spec feesOK is a
--   boolean function. Because wee need to handle predicate failures in the
--   implementaion, it is coded as a Test. Which is a validation. This
--   version is generic in that it can be lifted to any PredicateFailure
--   type that embeds BabbageUtxoPred era. This makes it possibly useful in
--   future Eras.
feesOK :: forall era. (Era era, Tx era ~ ValidatedTx era, TxBody era ~ TxBody era, TxOut era ~ TxOut era, HasField "collateral" (TxBody era) (Set (TxIn (Crypto era))), HasField "_minfeeA" (PParams era) Natural, HasField "_minfeeB" (PParams era) Natural, HasField "_collateralPercentage" (PParams era) Natural, HasField "collateralReturn" (TxBody era) (StrictMaybe (TxOut era)), HasField "_prices" (PParams era) Prices, HasField "txrdmrs" (Witnesses era) (Redeemers era), HasField "totalCollateral" (TxBody era) (StrictMaybe Coin)) => PParams era -> Tx era -> UTxO era -> Test (BabbageUtxoPred era)
validateTotalCollateral :: forall era. (Era era, HasField "_collateralPercentage" (PParams era) Natural, HasField "totalCollateral" (TxBody era) (StrictMaybe Coin)) => PParams era -> TxBody era -> Map (TxIn (Crypto era)) (TxOut era) -> Value era -> Test (BabbageUtxoPred era)
validateCollateralEqBalance :: Coin -> StrictMaybe Coin -> Validation (NonEmpty (BabbageUtxoPred era)) ()
babbageMinUTxOValue :: HasField "_coinsPerUTxOByte" (PParams era) Coin => PParams era -> Sized (TxOut era) -> Coin
validateOutputTooSmallUTxO :: (Era era, HasField "_coinsPerUTxOByte" (PParams era) Coin) => PParams era -> [Sized (TxOut era)] -> Test (BabbageUtxoPred era)
validateOutputTooBigUTxO :: (HasField "_maxValSize" (PParams era) Natural, HasField "value" (TxOut era) (Value era), ToCBOR (Value era)) => PParams era -> [TxOut era] -> Test (UtxoPredicateFailure era)
validateOutputBootAddrAttrsTooBig :: Era era => [TxOut era] -> Test (UtxoPredicateFailure era)

-- | The UTxO transition rule for the Babbage eras.
utxoTransition :: forall era. (Era era, ValidateScript era, ConcreteBabbage era, STS (BabbageUTXO era), Embed (EraRule "UTXOS" era) (BabbageUTXO era), Environment (EraRule "UTXOS" era) ~ UtxoEnv era, State (EraRule "UTXOS" era) ~ UTxOState era, Signal (EraRule "UTXOS" era) ~ Tx era, Inject (PredicateFailure (EraRule "PPUP" era)) (PredicateFailure (EraRule "UTXOS" era)), ExtendedUTxO era) => TransitionRule (BabbageUTXO era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Cardano.Ledger.Core.Script era)) => GHC.Show.Show (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Cardano.Ledger.Core.Script era)) => GHC.Classes.Eq (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era) (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era)) (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)) => Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era)) (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)) => Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era)
instance (Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Era.Era era, Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Babbage.Rules.Utxos.ConcreteBabbage era, Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, Cardano.Ledger.Core.Witnesses era GHC.Types.~ Cardano.Ledger.Alonzo.TxWitness.TxWitness era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UTXOS" era) (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUTXO era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UTxOState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Cardano.Ledger.Core.Tx era, Cardano.Ledger.Rules.ValidationMode.Inject (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era)) (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era, Cardano.Ledger.Alonzo.TxInfo.ExtendedUTxO era) => Control.State.Transition.Extended.STS (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUTXO era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Babbage.Rules.Utxos.BabbageUTXOS era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Control.State.Transition.Extended.Event (Cardano.Ledger.Babbage.Rules.Utxos.BabbageUTXOS era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Babbage.Rules.Utxos.BabbageUTXOS era) (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUTXO era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era)

module Cardano.Ledger.Babbage.Rules.Utxow
data BabbageUtxowPred era
FromAlonzoUtxowFail :: !UtxowPredicateFail era -> BabbageUtxowPred era

-- | Embed UTXO rule failures
UtxoFailure :: !PredicateFailure (EraRule "UTXO" era) -> BabbageUtxowPred era

-- | the set of malformed script witnesses
MalformedScriptWitnesses :: !Set (ScriptHash (Crypto era)) -> BabbageUtxowPred era

-- | the set of malformed script witnesses
MalformedReferenceScripts :: !Set (ScriptHash (Crypto era)) -> BabbageUtxowPred era
babbageMissingScripts :: forall era. PParams era -> Set (ScriptHash (Crypto era)) -> Set (ScriptHash (Crypto era)) -> Set (ScriptHash (Crypto era)) -> Test (UtxowPredicateFailure era)
validateFailedBabbageScripts :: forall era. (ValidateScript era, ExtendedUTxO era, Script era ~ Script era) => Tx era -> UTxO era -> Set (ScriptHash (Crypto era)) -> Test (UtxowPredicateFailure era)
validateScriptsWellFormed :: forall era. (ValidateScript era, HasField "collateralReturn" (TxBody era) (StrictMaybe (TxOut era)), HasField "_protocolVersion" (PParams era) ProtVer, Script era ~ Script era, TxOut era ~ TxOut era) => PParams era -> Tx era -> Test (BabbageUtxowPred era)
data BabbageUTXOW era

-- | A very specialized transitionRule function for the Babbage Era.
babbageUtxowTransition :: forall era. (ValidateScript era, ValidateAuxiliaryData era (Crypto era), ExtendedUTxO era, STS (BabbageUTXOW era), ConcreteBabbage era, Signable (DSIGN (Crypto era)) (Hash (HASH (Crypto era)) EraIndependentTxBody), Embed (EraRule "UTXO" era) (BabbageUTXOW era), Environment (EraRule "UTXO" era) ~ UtxoEnv era, State (EraRule "UTXO" era) ~ UTxOState era, Signal (EraRule "UTXO" era) ~ ValidatedTx era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "referenceInputs" (TxBody era) (Set (TxIn (Crypto era)))) => TransitionRule (BabbageUTXOW era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)), GHC.Show.Show (Cardano.Ledger.Core.Script era), GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Cardano.Ledger.Core.TxBody era), GHC.Show.Show (Cardano.Ledger.Core.Value era)) => GHC.Show.Show (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)), GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Cardano.Ledger.Core.Script era)) => GHC.Classes.Eq (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era)
instance (Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.AuxiliaryData.ValidateAuxiliaryData era (Cardano.Ledger.Era.Crypto era), Cardano.Ledger.Alonzo.TxInfo.ExtendedUTxO era, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN (Cardano.Ledger.Era.Crypto era)) (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH (Cardano.Ledger.Era.Crypto era)) Cardano.Ledger.Hashes.EraIndependentTxBody), Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, Cardano.Ledger.Babbage.Rules.Utxos.ConcreteBabbage era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UTXO" era) (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUTXOW era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UTxOState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era))) => Control.State.Transition.Extended.STS (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUTXOW era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUTXO era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Babbage.Rules.Utxo.BabbageUtxoPred era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxo.UtxoEvent era, Control.State.Transition.Extended.BaseM (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUTXOW era) GHC.Types.~ Cardano.Ledger.BaseTypes.ShelleyBase, Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUTXOW era) GHC.Types.~ Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era, Control.State.Transition.Extended.Event (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUTXOW era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Babbage.Rules.Utxo.BabbageUTXO era) (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUTXOW era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era) (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era) (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era) (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era)

module Cardano.Ledger.Babbage.Rules.Ledger
data BabbageLEDGER c
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Babbage.Rules.Utxos.ConcreteBabbage era, GHC.Show.Show (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELEGS" era) (Cardano.Ledger.Babbage.Rules.Ledger.BabbageLEDGER era), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UTXOW" era) (Cardano.Ledger.Babbage.Rules.Ledger.BabbageLEDGER era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UTxOState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delegs.DelegsEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.DPState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Data.Sequence.Internal.Seq (Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era)), GHC.Show.Show (Cardano.Ledger.Alonzo.Tx.ValidatedTx era)) => Control.State.Transition.Extended.STS (Cardano.Ledger.Babbage.Rules.Ledger.BabbageLEDGER era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Delegs.DELEGS era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delegs.DelegsPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delegs.DelegsEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Delegs.DELEGS era) (Cardano.Ledger.Babbage.Rules.Ledger.BabbageLEDGER era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUTXOW era), Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoEvent era, Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Babbage.Rules.Utxow.BabbageUtxowPred era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Babbage.Rules.Utxow.BabbageUTXOW era) (Cardano.Ledger.Babbage.Rules.Ledger.BabbageLEDGER era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Babbage.Rules.Ledger.BabbageLEDGER era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ledger.LedgerPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "LEDGER" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ledger.LedgerEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Babbage.Rules.Ledger.BabbageLEDGER era) (Cardano.Ledger.Shelley.Rules.Ledgers.LEDGERS era)

module Cardano.Ledger.Babbage.TxInfo
transScriptHash :: ScriptHash c -> ScriptHash
transReferenceScript :: forall era. ValidateScript era => StrictMaybe (Script era) -> Maybe ScriptHash

-- | Given a TxOut, translate it for V2 and return (Right transalation). If
--   the transaction contains any Byron addresses or Babbage features,
--   return Left.
txInfoOutV1 :: forall era. (Era era, ExtendedUTxO era, ValidateScript era, Value era ~ Value (Crypto era), HasField "referenceScript" (TxOut era) (StrictMaybe (Script era))) => TxOutSource (Crypto era) -> TxOut era -> Either (TranslationError (Crypto era)) TxOut

-- | Given a TxOut, translate it for V2 and return (Right transalation). It
--   is possible the address part is a Bootstrap Address, in that case
--   return Left.
txInfoOutV2 :: forall era. (Era era, ExtendedUTxO era, ValidateScript era, Value era ~ Value (Crypto era), HasField "referenceScript" (TxOut era) (StrictMaybe (Script era))) => TxOutSource (Crypto era) -> TxOut era -> Either (TranslationError (Crypto era)) TxOut

-- | Given a TxIn, look it up in the UTxO. If it exists, translate it to
--   the V1 context and return (Just translation). If does not exist in the
--   UTxO, return Nothing.
txInfoInV1 :: forall era. (ValidateScript era, ExtendedUTxO era, Value era ~ Value (Crypto era), HasField "referenceScript" (TxOut era) (StrictMaybe (Script era))) => UTxO era -> TxIn (Crypto era) -> Either (TranslationError (Crypto era)) TxInInfo

-- | Given a TxIn, look it up in the UTxO. If it exists, translate it to
--   the V2 context and return (Just translation). If does not exist in the
--   UTxO, return Nothing.
txInfoInV2 :: forall era. (ValidateScript era, ExtendedUTxO era, Value era ~ Value (Crypto era), HasField "referenceScript" (TxOut era) (StrictMaybe (Script era))) => UTxO era -> TxIn (Crypto era) -> Either (TranslationError (Crypto era)) TxInInfo
transRedeemer :: Data era -> Redeemer
transRedeemerPtr :: (Era era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era)))) => TxBody era -> (RdmrPtr, (Data era, ExUnits)) -> Either (TranslationError (Crypto era)) (ScriptPurpose, Redeemer)
babbageTxInfo :: forall era. (Era era, ExtendedUTxO era, ValidateScript era, Value era ~ Value (Crypto era), HasField "wits" (Tx era) (TxWitness era), HasField "referenceScript" (TxOut era) (StrictMaybe (Script era)), HasField "_protocolVersion" (PParams era) ProtVer, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "referenceInputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "reqSignerHashes" (TxBody era) (Set (KeyHash 'Witness (Crypto era))), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "mint" (TxBody era) (Value (Crypto era)), HasField "vldt" (TxBody era) ValidityInterval) => PParams era -> Language -> EpochInfo (Either Text) -> SystemStart -> UTxO era -> Tx era -> Either (TranslationError (Crypto era)) VersionedTxInfo

module Cardano.Ledger.Babbage

-- | The Babbage era
data BabbageEra c
type Self c = BabbageEra c
data TxOut era
data TxBody era

-- | Scripts in the Alonzo Era, Either a Timelock script or a Plutus
--   script.
data Script era
data AuxiliaryData era
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.Mempool.ApplyTx (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.Validation.ApplyBlock (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.ShelleyBasedEra (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.Era (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.ValidateScript (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.API.Genesis.CanStartFromGenesis (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesTxOut (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.API.Wallet.CLI (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesValue (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesPParams (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.AuxiliaryData.ValidateAuxiliaryData (Cardano.Ledger.Babbage.BabbageEra c) c
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.SupportsSegWit (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Alonzo.TxInfo.ExtendedUTxO (Cardano.Ledger.Babbage.BabbageEra c)

module Cardano.Ledger.Babbage.Translation
newtype Tx era
Tx :: Tx era -> Tx era
[unTx] :: Tx era -> Tx era
translateTxOut :: Crypto c => TxOut (AlonzoEra c) -> TxOut (BabbageEra c)

-- | A word is 8 bytes, so to convert from coinsPerUTxOWord to
--   coinsPerUTxOByte, rounding down.
coinsPerUTxOWordToCoinsPerUTxOByte :: Coin -> Coin
translatePParams :: forall f c. HKDFunctor f => PParams' f (AlonzoEra c) -> PParams' f (BabbageEra c)
instance (Cardano.Ledger.Crypto.Crypto c, Cardano.Ledger.Core.Tx (Cardano.Ledger.Babbage.BabbageEra c) GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx (Cardano.Ledger.Babbage.BabbageEra c)) => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) Cardano.Ledger.Babbage.Translation.Tx
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) Cardano.Ledger.Shelley.LedgerState.NewEpochState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) Cardano.Ledger.Shelley.Genesis.ShelleyGenesis
instance (Cardano.Ledger.Crypto.Crypto c, GHC.Base.Functor f) => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) (Cardano.Ledger.Shelley.PParams.PParams' f)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) Cardano.Ledger.Shelley.LedgerState.EpochState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) Cardano.Ledger.Shelley.LedgerState.LedgerState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) Cardano.Ledger.Shelley.LedgerState.UTxOState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) Cardano.Ledger.Shelley.UTxO.UTxO
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) Cardano.Ledger.Shelley.LedgerState.PPUPState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) Cardano.Ledger.Shelley.PParams.ProposedPPUpdates
