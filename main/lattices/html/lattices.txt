-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fine-grained library for constructing and manipulating lattices
--   
--   In mathematics, a lattice is a partially ordered set in which every
--   two elements <tt>x</tt> and <tt>y</tt> have a unique supremum (also
--   called a least upper bound, join, or <tt>x /\ y</tt>) and a unique
--   infimum (also called a greatest lower bound, meet, or <tt>x \/
--   y</tt>).
--   
--   This package provide type-classes for different lattice types, as well
--   as a class for the partial order.
@package lattices
@version 2.1

module Algebra.Heyting.Free.Expr

-- | Heyting algebra expression.
--   
--   <i>Note:</i> this type doesn't have <a>Heyting</a> instance, as its
--   <a>Eq</a> and <a>Ord</a> are structural.
data Expr a
Var :: a -> Expr a
Bottom :: Expr a
Top :: Expr a
(:/\:) :: Expr a -> Expr a -> Expr a
(:\/:) :: Expr a -> Expr a -> Expr a
(:=>:) :: Expr a -> Expr a -> Expr a
infixr 6 :/\:
infixr 5 :\/:
infixr 4 :=>:

-- | Decide whether <tt>x :: <a>Expr</a> a</tt> is provable.
--   
--   <i>Note:</i> this doesn't construct a proof term, but merely returns a
--   <a>Bool</a>.
proofSearch :: forall a. Ord a => Expr a -> Bool
instance Data.Data.Data a => Data.Data.Data (Algebra.Heyting.Free.Expr.Expr a)
instance GHC.Generics.Generic1 Algebra.Heyting.Free.Expr.Expr
instance GHC.Generics.Generic (Algebra.Heyting.Free.Expr.Expr a)
instance Data.Traversable.Traversable Algebra.Heyting.Free.Expr.Expr
instance Data.Foldable.Foldable Algebra.Heyting.Free.Expr.Expr
instance GHC.Base.Functor Algebra.Heyting.Free.Expr.Expr
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Heyting.Free.Expr.Expr a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Heyting.Free.Expr.Expr a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Heyting.Free.Expr.Expr a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Heyting.Free.Expr.Am a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Heyting.Free.Expr.Am a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Heyting.Free.Expr.Am a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Heyting.Free.Expr.AtomImpl a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Heyting.Free.Expr.AtomImpl a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Heyting.Free.Expr.AtomImpl a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Heyting.Free.Expr.ImplImpl a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Heyting.Free.Expr.ImplImpl a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Heyting.Free.Expr.ImplImpl a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Heyting.Free.Expr.Ctx a)
instance GHC.Base.Applicative Algebra.Heyting.Free.Expr.Expr
instance GHC.Base.Monad Algebra.Heyting.Free.Expr.Expr


module Algebra.PartialOrd

-- | A partial ordering on sets
--   (<a>http://en.wikipedia.org/wiki/Partially_ordered_set</a>) is a set
--   equipped with a binary relation, <a>leq</a>, that obeys the following
--   laws
--   
--   <pre>
--   Reflexive:     a <a>`leq`</a> a
--   Antisymmetric: a <a>`leq`</a> b &amp;&amp; b <a>`leq`</a> a ==&gt; a == b
--   Transitive:    a <a>`leq`</a> b &amp;&amp; b <a>`leq`</a> c ==&gt; a <a>`leq`</a> c
--   </pre>
--   
--   Two elements of the set are said to be <a>comparable</a> when they are
--   are ordered with respect to the <a>leq</a> relation. So
--   
--   <pre>
--   <a>comparable</a> a b ==&gt; a <a>`leq`</a> b || b <a>`leq`</a> a
--   </pre>
--   
--   If <a>comparable</a> always returns true then the relation <a>leq</a>
--   defines a total ordering (and an <a>Ord</a> instance may be defined).
--   Any <a>Ord</a> instance is trivially an instance of <a>PartialOrd</a>.
--   <a>Ordered</a> provides a convenient wrapper to satisfy
--   <a>PartialOrd</a> given <a>Ord</a>.
--   
--   As an example consider the partial ordering on sets induced by set
--   inclusion. Then for sets <tt>a</tt> and <tt>b</tt>,
--   
--   <pre>
--   a <a>`leq`</a> b
--   </pre>
--   
--   is true when <tt>a</tt> is a subset of <tt>b</tt>. Two sets are
--   <a>comparable</a> if one is a subset of the other. Concretely
--   
--   <pre>
--   a = {1, 2, 3}
--   b = {1, 3, 4}
--   c = {1, 2}
--   
--   a <a>`leq`</a> a = <a>True</a>
--   a <a>`leq`</a> b = <a>False</a>
--   a <a>`leq`</a> c = <a>False</a>
--   b <a>`leq`</a> a = <a>False</a>
--   b <a>`leq`</a> b = <a>True</a>
--   b <a>`leq`</a> c = <a>False</a>
--   c <a>`leq`</a> a = <a>True</a>
--   c <a>`leq`</a> b = <a>False</a>
--   c <a>`leq`</a> c = <a>True</a>
--   
--   <a>comparable</a> a b = <a>False</a>
--   <a>comparable</a> a c = <a>True</a>
--   <a>comparable</a> b c = <a>False</a>
--   </pre>
class Eq a => PartialOrd a

-- | The relation that induces the partial ordering
leq :: PartialOrd a => a -> a -> Bool

-- | Whether two elements are ordered with respect to the relation. A
--   default implementation is given by
--   
--   <pre>
--   <a>comparable</a> x y = <a>leq</a> x y <a>||</a> <a>leq</a> y x
--   </pre>
comparable :: PartialOrd a => a -> a -> Bool

-- | The equality relation induced by the partial-order structure. It
--   satisfies the laws of an equivalence relation: <tt> Reflexive: a == a
--   Symmetric: a == b ==&gt; b == a Transitive: a == b &amp;&amp; b == c
--   ==&gt; a == c </tt>
partialOrdEq :: PartialOrd a => a -> a -> Bool

-- | Least point of a partially ordered monotone function. Checks that the
--   function is monotone.
lfpFrom :: PartialOrd a => a -> (a -> a) -> a

-- | Least point of a partially ordered monotone function. Does not checks
--   that the function is monotone.
unsafeLfpFrom :: Eq a => a -> (a -> a) -> a

-- | Greatest fixed point of a partially ordered antinone function. Checks
--   that the function is antinone.
gfpFrom :: PartialOrd a => a -> (a -> a) -> a

-- | Greatest fixed point of a partially ordered antinone function. Does
--   not check that the function is antinone.
unsafeGfpFrom :: Eq a => a -> (a -> a) -> a
instance Algebra.PartialOrd.PartialOrd ()
instance Algebra.PartialOrd.PartialOrd GHC.Types.Bool
instance Algebra.PartialOrd.PartialOrd Data.Semigroup.Internal.Any
instance Algebra.PartialOrd.PartialOrd Data.Semigroup.Internal.All
instance Algebra.PartialOrd.PartialOrd Data.Void.Void
instance GHC.Classes.Eq a => Algebra.PartialOrd.PartialOrd [a]
instance GHC.Classes.Ord a => Algebra.PartialOrd.PartialOrd (Data.Set.Internal.Set a)
instance Algebra.PartialOrd.PartialOrd Data.IntSet.Internal.IntSet
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Algebra.PartialOrd.PartialOrd (Data.HashSet.Internal.HashSet k)
instance (GHC.Classes.Ord k, Algebra.PartialOrd.PartialOrd v) => Algebra.PartialOrd.PartialOrd (Data.Map.Internal.Map k v)
instance Algebra.PartialOrd.PartialOrd v => Algebra.PartialOrd.PartialOrd (Data.IntMap.Internal.IntMap v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, Algebra.PartialOrd.PartialOrd v) => Algebra.PartialOrd.PartialOrd (Data.HashMap.Internal.HashMap k v)
instance (Algebra.PartialOrd.PartialOrd a, Algebra.PartialOrd.PartialOrd b) => Algebra.PartialOrd.PartialOrd (a, b)
instance (Algebra.PartialOrd.PartialOrd a, Algebra.PartialOrd.PartialOrd b) => Algebra.PartialOrd.PartialOrd (Data.Either.Either a b)


-- | In mathematics, a lattice is a partially ordered set in which every
--   two elements have a unique supremum (also called a least upper bound
--   or <tt>join</tt>) and a unique infimum (also called a greatest lower
--   bound or <tt>meet</tt>).
--   
--   In this module lattices are defined using <tt>meet</tt> and
--   <tt>join</tt> operators, as it's constructive one.
module Algebra.Lattice

-- | An algebraic structure with joins and meets.
--   
--   See <a>http://en.wikipedia.org/wiki/Lattice_(order)</a> and
--   <a>http://en.wikipedia.org/wiki/Absorption_law</a>.
--   
--   <a>Lattice</a> is very symmetric, which is seen from the laws:
--   
--   <i>Associativity</i>
--   
--   <pre>
--   x <a>\/</a> (y <a>\/</a> z) ≡ (x <a>\/</a> y) <a>\/</a> z
--   x <a>/\</a> (y <a>/\</a> z) ≡ (x <a>/\</a> y) <a>/\</a> z
--   </pre>
--   
--   <i>Commutativity</i>
--   
--   <pre>
--   x <a>\/</a> y ≡ y <a>\/</a> x
--   x <a>/\</a> y ≡ y <a>/\</a> x
--   </pre>
--   
--   <i>Idempotency</i>
--   
--   <pre>
--   x <a>\/</a> x ≡ x
--   x <a>/\</a> x ≡ x
--   </pre>
--   
--   <i>Absorption</i>
--   
--   <pre>
--   a <a>\/</a> (a <a>/\</a> b) ≡ a
--   a <a>/\</a> (a <a>\/</a> b) ≡ a
--   </pre>
class Lattice a

-- | join
(\/) :: Lattice a => a -> a -> a

-- | meet
(/\) :: Lattice a => a -> a -> a
infixr 6 /\
infixr 5 \/

-- | The partial ordering induced by the join-semilattice structure
joinLeq :: (Eq a, Lattice a) => a -> a -> Bool

-- | The join of at a list of join-semilattice elements (of length at least
--   one)
joins1 :: (Lattice a, Foldable1 f) => f a -> a
meetLeq :: (Eq a, Lattice a) => a -> a -> Bool

-- | The meet of at a list of meet-semilattice elements (of length at least
--   one)
meets1 :: (Lattice a, Foldable1 f) => f a -> a

-- | A join-semilattice with an identity element <a>bottom</a> for
--   <a>\/</a>.
--   
--   <i>Laws</i>
--   
--   <pre>
--   x <a>\/</a> <a>bottom</a> ≡ x
--   </pre>
--   
--   <i>Corollary</i>
--   
--   <pre>
--   x <a>/\</a> <a>bottom</a>
--     ≡⟨ identity ⟩
--   (x <a>/\</a> <a>bottom</a>) <a>\/</a> <a>bottom</a>
--     ≡⟨ absorption ⟩
--   <a>bottom</a>
--   </pre>
class Lattice a => BoundedJoinSemiLattice a
bottom :: BoundedJoinSemiLattice a => a

-- | A meet-semilattice with an identity element <a>top</a> for <a>/\</a>.
--   
--   <i>Laws</i>
--   
--   <pre>
--   x <a>/\</a> <a>top</a> ≡ x
--   </pre>
--   
--   <i>Corollary</i>
--   
--   <pre>
--   x <a>\/</a> <a>top</a>
--     ≡⟨ identity ⟩
--   (x <a>\/</a> <a>top</a>) <a>/\</a> <a>top</a>
--     ≡⟨ absorption ⟩
--   <a>top</a>
--   </pre>
class Lattice a => BoundedMeetSemiLattice a
top :: BoundedMeetSemiLattice a => a

-- | The join of a list of join-semilattice elements
joins :: (BoundedJoinSemiLattice a, Foldable f) => f a -> a

-- | The meet of a list of meet-semilattice elements
meets :: (BoundedMeetSemiLattice a, Foldable f) => f a -> a

-- | <a>True</a> to <a>top</a> and <a>False</a> to <a>bottom</a>
fromBool :: BoundedLattice a => Bool -> a
type BoundedLattice a = (BoundedMeetSemiLattice a, BoundedJoinSemiLattice a)

-- | Monoid wrapper for meet-<a>Lattice</a>
newtype Meet a
Meet :: a -> Meet a
[getMeet] :: Meet a -> a

-- | Monoid wrapper for join-<a>Lattice</a>
newtype Join a
Join :: a -> Join a
[getJoin] :: Join a -> a

-- | Implementation of Kleene fixed-point theorem
--   <a>http://en.wikipedia.org/wiki/Kleene_fixed-point_theorem</a>. Forces
--   the function to be monotone.
lfp :: (Eq a, BoundedJoinSemiLattice a) => (a -> a) -> a

-- | Implementation of Kleene fixed-point theorem
--   <a>http://en.wikipedia.org/wiki/Kleene_fixed-point_theorem</a>. Forces
--   the function to be monotone.
lfpFrom :: (Eq a, BoundedJoinSemiLattice a) => a -> (a -> a) -> a

-- | Implementation of Kleene fixed-point theorem
--   <a>http://en.wikipedia.org/wiki/Kleene_fixed-point_theorem</a>.
--   Assumes that the function is monotone and does not check if that is
--   correct.
unsafeLfp :: (Eq a, BoundedJoinSemiLattice a) => (a -> a) -> a

-- | Implementation of Kleene fixed-point theorem
--   <a>http://en.wikipedia.org/wiki/Kleene_fixed-point_theorem</a>. Forces
--   the function to be antinone.
gfp :: (Eq a, BoundedMeetSemiLattice a) => (a -> a) -> a

-- | Implementation of Kleene fixed-point theorem
--   <a>http://en.wikipedia.org/wiki/Kleene_fixed-point_theorem</a>. Forces
--   the function to be antinone.
gfpFrom :: (Eq a, BoundedMeetSemiLattice a) => a -> (a -> a) -> a

-- | Implementation of Kleene fixed-point theorem
--   <a>http://en.wikipedia.org/wiki/Kleene_fixed-point_theorem</a>.
--   Assumes that the function is antinone and does not check if that is
--   correct.
unsafeGfp :: (Eq a, BoundedMeetSemiLattice a) => (a -> a) -> a
instance GHC.Generics.Generic (Algebra.Lattice.Join a)
instance Data.Data.Data a => Data.Data.Data (Algebra.Lattice.Join a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Algebra.Lattice.Join a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Lattice.Join a)
instance GHC.Read.Read a => GHC.Read.Read (Algebra.Lattice.Join a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Lattice.Join a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Lattice.Join a)
instance GHC.Generics.Generic (Algebra.Lattice.Meet a)
instance Data.Data.Data a => Data.Data.Data (Algebra.Lattice.Meet a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Algebra.Lattice.Meet a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Lattice.Meet a)
instance GHC.Read.Read a => GHC.Read.Read (Algebra.Lattice.Meet a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Lattice.Meet a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Lattice.Meet a)
instance Algebra.Lattice.Lattice a => GHC.Base.Semigroup (Algebra.Lattice.Meet a)
instance Algebra.Lattice.BoundedMeetSemiLattice a => GHC.Base.Monoid (Algebra.Lattice.Meet a)
instance (GHC.Classes.Eq a, Algebra.Lattice.Lattice a) => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Meet a)
instance GHC.Base.Functor Algebra.Lattice.Meet
instance GHC.Base.Applicative Algebra.Lattice.Meet
instance GHC.Base.Monad Algebra.Lattice.Meet
instance Control.Monad.Zip.MonadZip Algebra.Lattice.Meet
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Meet a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Meet a)
instance Algebra.Lattice.Lattice a => GHC.Base.Semigroup (Algebra.Lattice.Join a)
instance Algebra.Lattice.BoundedJoinSemiLattice a => GHC.Base.Monoid (Algebra.Lattice.Join a)
instance (GHC.Classes.Eq a, Algebra.Lattice.Lattice a) => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Join a)
instance GHC.Base.Functor Algebra.Lattice.Join
instance GHC.Base.Applicative Algebra.Lattice.Join
instance GHC.Base.Monad Algebra.Lattice.Join
instance Control.Monad.Zip.MonadZip Algebra.Lattice.Join
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Join a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Join a)
instance (GHC.Classes.Ord a, Data.Universe.Class.Finite a) => Algebra.Lattice.BoundedMeetSemiLattice (Data.Set.Internal.Set a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, Data.Universe.Class.Finite a) => Algebra.Lattice.BoundedMeetSemiLattice (Data.HashSet.Internal.HashSet a)
instance (GHC.Classes.Ord k, Data.Universe.Class.Finite k, Algebra.Lattice.BoundedMeetSemiLattice v) => Algebra.Lattice.BoundedMeetSemiLattice (Data.Map.Internal.Map k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, Data.Universe.Class.Finite k, Algebra.Lattice.BoundedMeetSemiLattice v) => Algebra.Lattice.BoundedMeetSemiLattice (Data.HashMap.Internal.HashMap k v)
instance Algebra.Lattice.BoundedMeetSemiLattice v => Algebra.Lattice.BoundedMeetSemiLattice (k -> v)
instance Algebra.Lattice.BoundedMeetSemiLattice ()
instance (Algebra.Lattice.BoundedMeetSemiLattice a, Algebra.Lattice.BoundedMeetSemiLattice b) => Algebra.Lattice.BoundedMeetSemiLattice (a, b)
instance (Algebra.Lattice.Lattice a, Algebra.Lattice.BoundedMeetSemiLattice b) => Algebra.Lattice.BoundedMeetSemiLattice (Data.Either.Either a b)
instance Algebra.Lattice.BoundedMeetSemiLattice GHC.Types.Bool
instance Algebra.Lattice.BoundedMeetSemiLattice Data.Semigroup.Internal.All
instance Algebra.Lattice.BoundedMeetSemiLattice Data.Semigroup.Internal.Any
instance Algebra.Lattice.BoundedMeetSemiLattice a => Algebra.Lattice.BoundedMeetSemiLattice (Data.Semigroup.Internal.Endo a)
instance Algebra.Lattice.BoundedMeetSemiLattice a => Algebra.Lattice.BoundedMeetSemiLattice (Data.Tagged.Tagged t a)
instance Algebra.Lattice.BoundedMeetSemiLattice (Data.Proxy.Proxy a)
instance Algebra.Lattice.BoundedMeetSemiLattice a => Algebra.Lattice.BoundedMeetSemiLattice (Data.Functor.Identity.Identity a)
instance Algebra.Lattice.BoundedMeetSemiLattice a => Algebra.Lattice.BoundedMeetSemiLattice (Data.Functor.Const.Const a b)
instance Algebra.Lattice.BoundedMeetSemiLattice Test.QuickCheck.Property.Property
instance Algebra.Lattice.BoundedMeetSemiLattice a => Algebra.Lattice.BoundedMeetSemiLattice (Data.Tuple.Solo.Solo a)
instance GHC.Classes.Ord a => Algebra.Lattice.BoundedJoinSemiLattice (Data.Set.Internal.Set a)
instance Algebra.Lattice.BoundedJoinSemiLattice Data.IntSet.Internal.IntSet
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Algebra.Lattice.BoundedJoinSemiLattice (Data.HashSet.Internal.HashSet a)
instance (GHC.Classes.Ord k, Algebra.Lattice.Lattice v) => Algebra.Lattice.BoundedJoinSemiLattice (Data.Map.Internal.Map k v)
instance Algebra.Lattice.Lattice v => Algebra.Lattice.BoundedJoinSemiLattice (Data.IntMap.Internal.IntMap v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, Algebra.Lattice.Lattice v) => Algebra.Lattice.BoundedJoinSemiLattice (Data.HashMap.Internal.HashMap k v)
instance Algebra.Lattice.BoundedJoinSemiLattice v => Algebra.Lattice.BoundedJoinSemiLattice (k -> v)
instance Algebra.Lattice.BoundedJoinSemiLattice ()
instance (Algebra.Lattice.BoundedJoinSemiLattice a, Algebra.Lattice.BoundedJoinSemiLattice b) => Algebra.Lattice.BoundedJoinSemiLattice (a, b)
instance (Algebra.Lattice.BoundedJoinSemiLattice a, Algebra.Lattice.Lattice b) => Algebra.Lattice.BoundedJoinSemiLattice (Data.Either.Either a b)
instance Algebra.Lattice.BoundedJoinSemiLattice GHC.Types.Bool
instance Algebra.Lattice.BoundedJoinSemiLattice Data.Semigroup.Internal.All
instance Algebra.Lattice.BoundedJoinSemiLattice Data.Semigroup.Internal.Any
instance Algebra.Lattice.BoundedJoinSemiLattice a => Algebra.Lattice.BoundedJoinSemiLattice (Data.Semigroup.Internal.Endo a)
instance Algebra.Lattice.BoundedJoinSemiLattice a => Algebra.Lattice.BoundedJoinSemiLattice (Data.Tagged.Tagged t a)
instance Algebra.Lattice.BoundedJoinSemiLattice (Data.Proxy.Proxy a)
instance Algebra.Lattice.BoundedJoinSemiLattice a => Algebra.Lattice.BoundedJoinSemiLattice (Data.Functor.Identity.Identity a)
instance Algebra.Lattice.BoundedJoinSemiLattice a => Algebra.Lattice.BoundedJoinSemiLattice (Data.Functor.Const.Const a b)
instance Algebra.Lattice.BoundedJoinSemiLattice Test.QuickCheck.Property.Property
instance Algebra.Lattice.BoundedJoinSemiLattice a => Algebra.Lattice.BoundedJoinSemiLattice (Data.Tuple.Solo.Solo a)
instance GHC.Classes.Ord a => Algebra.Lattice.Lattice (Data.Set.Internal.Set a)
instance Algebra.Lattice.Lattice Data.IntSet.Internal.IntSet
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Algebra.Lattice.Lattice (Data.HashSet.Internal.HashSet a)
instance (GHC.Classes.Ord k, Algebra.Lattice.Lattice v) => Algebra.Lattice.Lattice (Data.Map.Internal.Map k v)
instance Algebra.Lattice.Lattice v => Algebra.Lattice.Lattice (Data.IntMap.Internal.IntMap v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, Algebra.Lattice.Lattice v) => Algebra.Lattice.Lattice (Data.HashMap.Internal.HashMap k v)
instance Algebra.Lattice.Lattice v => Algebra.Lattice.Lattice (k -> v)
instance Algebra.Lattice.Lattice ()
instance (Algebra.Lattice.Lattice a, Algebra.Lattice.Lattice b) => Algebra.Lattice.Lattice (a, b)
instance (Algebra.Lattice.Lattice a, Algebra.Lattice.Lattice b) => Algebra.Lattice.Lattice (Data.Either.Either a b)
instance Algebra.Lattice.Lattice GHC.Types.Bool
instance Algebra.Lattice.Lattice Data.Semigroup.Internal.All
instance Algebra.Lattice.Lattice Data.Semigroup.Internal.Any
instance Algebra.Lattice.Lattice a => Algebra.Lattice.Lattice (Data.Semigroup.Internal.Endo a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.Lattice (Data.Tagged.Tagged t a)
instance Algebra.Lattice.Lattice (Data.Proxy.Proxy a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.Lattice (Data.Functor.Identity.Identity a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.Lattice (Data.Functor.Const.Const a b)
instance Algebra.Lattice.Lattice Data.Void.Void
instance Algebra.Lattice.Lattice Test.QuickCheck.Property.Property
instance Algebra.Lattice.Lattice a => Algebra.Lattice.Lattice (Data.Tuple.Solo.Solo a)


module Algebra.Lattice.Wide

-- | Graft a distinct top and bottom onto any type. The <a>Top</a> is
--   identity for <a>/\</a> and the absorbing element for <a>\/</a>. The
--   <a>Bottom</a> is the identity for <a>\/</a> and and the absorbing
--   element for <a>/\</a>. Two <a>Middle</a> values join to top, unless
--   they are equal.
--   
data Wide a
Top :: Wide a
Middle :: a -> Wide a
Bottom :: Wide a
instance GHC.Generics.Generic1 Algebra.Lattice.Wide.Wide
instance Data.Traversable.Traversable Algebra.Lattice.Wide.Wide
instance Data.Foldable.Foldable Algebra.Lattice.Wide.Wide
instance GHC.Base.Functor Algebra.Lattice.Wide.Wide
instance GHC.Generics.Generic (Algebra.Lattice.Wide.Wide a)
instance Data.Data.Data a => Data.Data.Data (Algebra.Lattice.Wide.Wide a)
instance GHC.Read.Read a => GHC.Read.Read (Algebra.Lattice.Wide.Wide a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Lattice.Wide.Wide a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Lattice.Wide.Wide a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Lattice.Wide.Wide a)
instance GHC.Base.Applicative Algebra.Lattice.Wide.Wide
instance GHC.Base.Monad Algebra.Lattice.Wide.Wide
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Algebra.Lattice.Wide.Wide a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Algebra.Lattice.Wide.Wide a)
instance GHC.Classes.Eq a => Algebra.Lattice.Lattice (Algebra.Lattice.Wide.Wide a)
instance GHC.Classes.Eq a => Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Lattice.Wide.Wide a)
instance GHC.Classes.Eq a => Algebra.Lattice.BoundedMeetSemiLattice (Algebra.Lattice.Wide.Wide a)
instance GHC.Classes.Eq a => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Wide.Wide a)
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Wide.Wide a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Wide.Wide a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Algebra.Lattice.Wide.Wide a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Algebra.Lattice.Wide.Wide a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Algebra.Lattice.Wide.Wide a)


module Algebra.Lattice.Op

-- | The opposite lattice of a given lattice. That is, switch meets and
--   joins.
newtype Op a
Op :: a -> Op a
[getOp] :: Op a -> a
instance GHC.Generics.Generic1 Algebra.Lattice.Op.Op
instance Data.Traversable.Traversable Algebra.Lattice.Op.Op
instance Data.Foldable.Foldable Algebra.Lattice.Op.Op
instance GHC.Base.Functor Algebra.Lattice.Op.Op
instance GHC.Generics.Generic (Algebra.Lattice.Op.Op a)
instance Data.Data.Data a => Data.Data.Data (Algebra.Lattice.Op.Op a)
instance GHC.Read.Read a => GHC.Read.Read (Algebra.Lattice.Op.Op a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Lattice.Op.Op a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Lattice.Op.Op a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Lattice.Op.Op a)
instance GHC.Base.Applicative Algebra.Lattice.Op.Op
instance GHC.Base.Monad Algebra.Lattice.Op.Op
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Algebra.Lattice.Op.Op a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Algebra.Lattice.Op.Op a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.Lattice (Algebra.Lattice.Op.Op a)
instance Algebra.Lattice.BoundedMeetSemiLattice a => Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Lattice.Op.Op a)
instance Algebra.Lattice.BoundedJoinSemiLattice a => Algebra.Lattice.BoundedMeetSemiLattice (Algebra.Lattice.Op.Op a)
instance Algebra.PartialOrd.PartialOrd a => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Op.Op a)
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Op.Op a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Op.Op a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Algebra.Lattice.Op.Op a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Algebra.Lattice.Op.Op a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Algebra.Lattice.Op.Op a)


module Algebra.Lattice.N5

-- | &lt;math&gt;, is smallest non-modular (and non-distributive) lattice.
--   
data N5
N5o :: N5
N5a :: N5
N5b :: N5
N5c :: N5
N5i :: N5
instance GHC.Generics.Generic Algebra.Lattice.N5.N5
instance Data.Data.Data Algebra.Lattice.N5.N5
instance GHC.Enum.Bounded Algebra.Lattice.N5.N5
instance GHC.Enum.Enum Algebra.Lattice.N5.N5
instance GHC.Show.Show Algebra.Lattice.N5.N5
instance GHC.Read.Read Algebra.Lattice.N5.N5
instance GHC.Classes.Ord Algebra.Lattice.N5.N5
instance GHC.Classes.Eq Algebra.Lattice.N5.N5
instance Algebra.PartialOrd.PartialOrd Algebra.Lattice.N5.N5
instance Algebra.Lattice.Lattice Algebra.Lattice.N5.N5
instance Algebra.Lattice.BoundedJoinSemiLattice Algebra.Lattice.N5.N5
instance Algebra.Lattice.BoundedMeetSemiLattice Algebra.Lattice.N5.N5
instance Test.QuickCheck.Arbitrary.Arbitrary Algebra.Lattice.N5.N5
instance Test.QuickCheck.Arbitrary.CoArbitrary Algebra.Lattice.N5.N5
instance Test.QuickCheck.Function.Function Algebra.Lattice.N5.N5
instance Data.Universe.Class.Universe Algebra.Lattice.N5.N5
instance Data.Universe.Class.Finite Algebra.Lattice.N5.N5
instance Control.DeepSeq.NFData Algebra.Lattice.N5.N5
instance Data.Hashable.Class.Hashable Algebra.Lattice.N5.N5


module Algebra.Lattice.M3

-- | &lt;math&gt;, is smallest non-distributive, yet modular lattice.
--   
data M3
M3o :: M3
M3a :: M3
M3b :: M3
M3c :: M3
M3i :: M3
instance GHC.Generics.Generic Algebra.Lattice.M3.M3
instance Data.Data.Data Algebra.Lattice.M3.M3
instance GHC.Enum.Bounded Algebra.Lattice.M3.M3
instance GHC.Enum.Enum Algebra.Lattice.M3.M3
instance GHC.Show.Show Algebra.Lattice.M3.M3
instance GHC.Read.Read Algebra.Lattice.M3.M3
instance GHC.Classes.Ord Algebra.Lattice.M3.M3
instance GHC.Classes.Eq Algebra.Lattice.M3.M3
instance Algebra.PartialOrd.PartialOrd Algebra.Lattice.M3.M3
instance Algebra.Lattice.Lattice Algebra.Lattice.M3.M3
instance Algebra.Lattice.BoundedJoinSemiLattice Algebra.Lattice.M3.M3
instance Algebra.Lattice.BoundedMeetSemiLattice Algebra.Lattice.M3.M3
instance Test.QuickCheck.Arbitrary.Arbitrary Algebra.Lattice.M3.M3
instance Test.QuickCheck.Arbitrary.CoArbitrary Algebra.Lattice.M3.M3
instance Test.QuickCheck.Function.Function Algebra.Lattice.M3.M3
instance Data.Universe.Class.Universe Algebra.Lattice.M3.M3
instance Data.Universe.Class.Finite Algebra.Lattice.M3.M3
instance Control.DeepSeq.NFData Algebra.Lattice.M3.M3
instance Data.Hashable.Class.Hashable Algebra.Lattice.M3.M3


module Algebra.Lattice.Lifted

-- | Graft a distinct bottom onto an otherwise unbounded lattice. As a
--   bonus, the bottom will be an absorbing element for the meet.
data Lifted a
Bottom :: Lifted a
Lift :: a -> Lifted a

-- | Interpret <tt><a>Lifted</a> a</tt> using the
--   <a>BoundedJoinSemiLattice</a> of <tt>a</tt>.
retractLifted :: BoundedJoinSemiLattice a => Lifted a -> a

-- | Similar to <tt><a>maybe</a></tt>, but for <tt><a>Lifted</a></tt> type.
foldLifted :: b -> (a -> b) -> Lifted a -> b
instance GHC.Generics.Generic1 Algebra.Lattice.Lifted.Lifted
instance Data.Traversable.Traversable Algebra.Lattice.Lifted.Lifted
instance Data.Foldable.Foldable Algebra.Lattice.Lifted.Lifted
instance GHC.Base.Functor Algebra.Lattice.Lifted.Lifted
instance GHC.Generics.Generic (Algebra.Lattice.Lifted.Lifted a)
instance Data.Data.Data a => Data.Data.Data (Algebra.Lattice.Lifted.Lifted a)
instance GHC.Read.Read a => GHC.Read.Read (Algebra.Lattice.Lifted.Lifted a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Lattice.Lifted.Lifted a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Lattice.Lifted.Lifted a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Lattice.Lifted.Lifted a)
instance GHC.Base.Applicative Algebra.Lattice.Lifted.Lifted
instance GHC.Base.Monad Algebra.Lattice.Lifted.Lifted
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Algebra.Lattice.Lifted.Lifted a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Algebra.Lattice.Lifted.Lifted a)
instance Algebra.PartialOrd.PartialOrd a => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Lifted.Lifted a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.Lattice (Algebra.Lattice.Lifted.Lifted a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Lattice.Lifted.Lifted a)
instance Algebra.Lattice.BoundedMeetSemiLattice a => Algebra.Lattice.BoundedMeetSemiLattice (Algebra.Lattice.Lifted.Lifted a)
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Lifted.Lifted a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Lifted.Lifted a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Algebra.Lattice.Lifted.Lifted a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Algebra.Lattice.Lifted.Lifted a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Algebra.Lattice.Lifted.Lifted a)


module Algebra.Lattice.Lexicographic

-- | A pair lattice with a lexicographic ordering. This means in a join the
--   second component of the resulting pair is the second component of the
--   pair with the larger first component. If the first components are
--   equal, then the second components will be joined. The meet is similar
--   only it prefers the smaller first component.
--   
--   An application of this type is versioning. For example, a
--   Last-Writer-Wins register would look like <tt><a>Lexicographic</a>
--   (<a>Ordered</a> Timestamp) v</tt> where the lattice structure handles
--   the, presumably rare, case of matching <tt>Timestamp</tt>s. Typically
--   this is done in an arbitary, but deterministic manner.
data Lexicographic k v
Lexicographic :: !k -> !v -> Lexicographic k v
instance GHC.Generics.Generic1 (Algebra.Lattice.Lexicographic.Lexicographic k)
instance Data.Traversable.Traversable (Algebra.Lattice.Lexicographic.Lexicographic k)
instance Data.Foldable.Foldable (Algebra.Lattice.Lexicographic.Lexicographic k)
instance GHC.Base.Functor (Algebra.Lattice.Lexicographic.Lexicographic k)
instance GHC.Generics.Generic (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Data.Data.Data k, Data.Data.Data v) => Data.Data.Data (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (GHC.Read.Read k, GHC.Read.Read v) => GHC.Read.Read (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance Algebra.Lattice.BoundedJoinSemiLattice k => GHC.Base.Applicative (Algebra.Lattice.Lexicographic.Lexicographic k)
instance Algebra.Lattice.BoundedJoinSemiLattice k => GHC.Base.Monad (Algebra.Lattice.Lexicographic.Lexicographic k)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Data.Hashable.Class.Hashable k, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Algebra.PartialOrd.PartialOrd k, Algebra.Lattice.Lattice k, Algebra.Lattice.BoundedJoinSemiLattice v, Algebra.Lattice.BoundedMeetSemiLattice v) => Algebra.Lattice.Lattice (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Algebra.PartialOrd.PartialOrd k, Algebra.Lattice.BoundedJoinSemiLattice k, Algebra.Lattice.BoundedJoinSemiLattice v, Algebra.Lattice.BoundedMeetSemiLattice v) => Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Algebra.PartialOrd.PartialOrd k, Algebra.Lattice.BoundedMeetSemiLattice k, Algebra.Lattice.BoundedJoinSemiLattice v, Algebra.Lattice.BoundedMeetSemiLattice v) => Algebra.Lattice.BoundedMeetSemiLattice (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Algebra.PartialOrd.PartialOrd k, Algebra.PartialOrd.PartialOrd v) => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Data.Universe.Class.Universe k, Data.Universe.Class.Universe v) => Data.Universe.Class.Universe (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Data.Universe.Class.Finite k, Data.Universe.Class.Finite v) => Data.Universe.Class.Finite (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Test.QuickCheck.Arbitrary.Arbitrary k, Test.QuickCheck.Arbitrary.Arbitrary v) => Test.QuickCheck.Arbitrary.Arbitrary (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Test.QuickCheck.Arbitrary.CoArbitrary k, Test.QuickCheck.Arbitrary.CoArbitrary v) => Test.QuickCheck.Arbitrary.CoArbitrary (Algebra.Lattice.Lexicographic.Lexicographic k v)
instance (Test.QuickCheck.Function.Function k, Test.QuickCheck.Function.Function v) => Test.QuickCheck.Function.Function (Algebra.Lattice.Lexicographic.Lexicographic k v)


module Algebra.Lattice.Levitated

-- | Graft a distinct top and bottom onto an otherwise unbounded lattice.
--   The top is the absorbing element for the join, and the bottom is the
--   absorbing element for the meet.
data Levitated a
Bottom :: Levitated a
Levitate :: a -> Levitated a
Top :: Levitated a

-- | Interpret <tt><a>Levitated</a> a</tt> using the <a>BoundedLattice</a>
--   of <tt>a</tt>.
retractLevitated :: (BoundedMeetSemiLattice a, BoundedJoinSemiLattice a) => Levitated a -> a

-- | Fold <a>Levitated</a>.
foldLevitated :: b -> (a -> b) -> b -> Levitated a -> b
instance GHC.Generics.Generic1 Algebra.Lattice.Levitated.Levitated
instance Data.Traversable.Traversable Algebra.Lattice.Levitated.Levitated
instance Data.Foldable.Foldable Algebra.Lattice.Levitated.Levitated
instance GHC.Base.Functor Algebra.Lattice.Levitated.Levitated
instance GHC.Generics.Generic (Algebra.Lattice.Levitated.Levitated a)
instance Data.Data.Data a => Data.Data.Data (Algebra.Lattice.Levitated.Levitated a)
instance GHC.Read.Read a => GHC.Read.Read (Algebra.Lattice.Levitated.Levitated a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Lattice.Levitated.Levitated a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Lattice.Levitated.Levitated a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Lattice.Levitated.Levitated a)
instance GHC.Base.Applicative Algebra.Lattice.Levitated.Levitated
instance GHC.Base.Monad Algebra.Lattice.Levitated.Levitated
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Algebra.Lattice.Levitated.Levitated a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Algebra.Lattice.Levitated.Levitated a)
instance Algebra.PartialOrd.PartialOrd a => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Levitated.Levitated a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.Lattice (Algebra.Lattice.Levitated.Levitated a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Lattice.Levitated.Levitated a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.BoundedMeetSemiLattice (Algebra.Lattice.Levitated.Levitated a)
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Levitated.Levitated a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Levitated.Levitated a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Algebra.Lattice.Levitated.Levitated a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Algebra.Lattice.Levitated.Levitated a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Algebra.Lattice.Levitated.Levitated a)


module Algebra.Lattice.Free.Final
data FLattice a
liftFLattice :: a -> FLattice a
lowerFLattice :: FLattice a -> forall b. Lattice b => (a -> b) -> b
retractFLattice :: Lattice a => FLattice a -> a
data FBoundedLattice a
liftFBoundedLattice :: a -> FBoundedLattice a
lowerFBoundedLattice :: FBoundedLattice a -> forall b. BoundedLattice b => (a -> b) -> b
retractFBoundedLattice :: BoundedLattice a => FBoundedLattice a -> a
instance GHC.Base.Functor Algebra.Lattice.Free.Final.FBoundedLattice
instance Algebra.Lattice.Lattice (Algebra.Lattice.Free.Final.FBoundedLattice a)
instance Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Lattice.Free.Final.FBoundedLattice a)
instance Algebra.Lattice.BoundedMeetSemiLattice (Algebra.Lattice.Free.Final.FBoundedLattice a)
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Free.Final.FBoundedLattice a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Free.Final.FBoundedLattice a)
instance GHC.Base.Functor Algebra.Lattice.Free.Final.FLattice
instance Algebra.Lattice.Lattice (Algebra.Lattice.Free.Final.FLattice a)
instance Algebra.Lattice.BoundedJoinSemiLattice a => Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Lattice.Free.Final.FLattice a)
instance Algebra.Lattice.BoundedMeetSemiLattice a => Algebra.Lattice.BoundedMeetSemiLattice (Algebra.Lattice.Free.Final.FLattice a)
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Free.Final.FLattice a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Free.Final.FLattice a)

module Algebra.Lattice.Free

-- | Free distributive lattice.
--   
--   <a>Eq</a> and <a>PartialOrd</a> instances aren't structural.
--   
--   <pre>
--   &gt;&gt;&gt; (Var 'x' /\ Var 'y') == (Var 'y' /\ Var 'x' /\ Var 'x')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Var 'x' == Var 'y'
--   False
--   </pre>
--   
--   This is <i>distributive</i> lattice.
--   
--   <pre>
--   &gt;&gt;&gt; import Algebra.Lattice.M3 -- non distributive lattice
--   
--   &gt;&gt;&gt; let x = M3a; y = M3b; z = M3c
--   
--   &gt;&gt;&gt; let lhs = Var x \/ (Var y /\ Var z)
--   
--   &gt;&gt;&gt; let rhs = (Var x \/ Var y) /\ (Var x \/ Var z)
--   </pre>
--   
--   <a>Free</a> is distributive so
--   
--   <pre>
--   &gt;&gt;&gt; lhs == rhs
--   True
--   </pre>
--   
--   but when retracted, values are inequal
--   
--   <pre>
--   &gt;&gt;&gt; retractFree lhs == retractFree rhs
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (retractFree lhs, retractFree rhs)
--   (M3a,M3i)
--   </pre>
data Free a
Var :: a -> Free a
(:/\:) :: Free a -> Free a -> Free a
(:\/:) :: Free a -> Free a -> Free a
infixr 6 :/\:
infixr 5 :\/:
liftFree :: a -> Free a
lowerFree :: Lattice b => (a -> b) -> Free a -> b
substFree :: Free a -> (a -> Free b) -> Free b
retractFree :: Lattice a => Free a -> a
toExpr :: Free a -> Expr a
instance Data.Data.Data a => Data.Data.Data (Algebra.Lattice.Free.Free a)
instance GHC.Generics.Generic1 Algebra.Lattice.Free.Free
instance GHC.Generics.Generic (Algebra.Lattice.Free.Free a)
instance Data.Traversable.Traversable Algebra.Lattice.Free.Free
instance Data.Foldable.Foldable Algebra.Lattice.Free.Free
instance GHC.Base.Functor Algebra.Lattice.Free.Free
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Lattice.Free.Free a)
instance GHC.Base.Applicative Algebra.Lattice.Free.Free
instance GHC.Base.Monad Algebra.Lattice.Free.Free
instance Algebra.Lattice.Lattice (Algebra.Lattice.Free.Free a)
instance GHC.Classes.Ord a => GHC.Classes.Eq (Algebra.Lattice.Free.Free a)
instance GHC.Classes.Ord a => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Free.Free a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Algebra.Lattice.Free.Free a)


module Algebra.Lattice.Dropped

-- | Graft a distinct top onto an otherwise unbounded lattice. As a bonus,
--   the top will be an absorbing element for the join.
data Dropped a
Drop :: a -> Dropped a
Top :: Dropped a

-- | Interpret <tt><a>Dropped</a> a</tt> using the
--   <a>BoundedMeetSemiLattice</a> of <tt>a</tt>.
retractDropped :: BoundedMeetSemiLattice a => Dropped a -> a

-- | Similar to <tt><a>maybe</a></tt>, but for <tt><a>Dropped</a></tt>
--   type.
foldDropped :: b -> (a -> b) -> Dropped a -> b
instance GHC.Generics.Generic1 Algebra.Lattice.Dropped.Dropped
instance Data.Traversable.Traversable Algebra.Lattice.Dropped.Dropped
instance Data.Foldable.Foldable Algebra.Lattice.Dropped.Dropped
instance GHC.Base.Functor Algebra.Lattice.Dropped.Dropped
instance GHC.Generics.Generic (Algebra.Lattice.Dropped.Dropped a)
instance Data.Data.Data a => Data.Data.Data (Algebra.Lattice.Dropped.Dropped a)
instance GHC.Read.Read a => GHC.Read.Read (Algebra.Lattice.Dropped.Dropped a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Lattice.Dropped.Dropped a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Lattice.Dropped.Dropped a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Lattice.Dropped.Dropped a)
instance GHC.Base.Applicative Algebra.Lattice.Dropped.Dropped
instance GHC.Base.Monad Algebra.Lattice.Dropped.Dropped
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Algebra.Lattice.Dropped.Dropped a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Algebra.Lattice.Dropped.Dropped a)
instance Algebra.PartialOrd.PartialOrd a => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Dropped.Dropped a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.Lattice (Algebra.Lattice.Dropped.Dropped a)
instance Algebra.Lattice.BoundedJoinSemiLattice a => Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Lattice.Dropped.Dropped a)
instance Algebra.Lattice.Lattice a => Algebra.Lattice.BoundedMeetSemiLattice (Algebra.Lattice.Dropped.Dropped a)
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Dropped.Dropped a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Dropped.Dropped a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Algebra.Lattice.Dropped.Dropped a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Algebra.Lattice.Dropped.Dropped a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Algebra.Lattice.Dropped.Dropped a)


module Algebra.Lattice.Divisibility

-- | A divisibility lattice. <tt><tt>join</tt> = <a>lcm</a></tt>,
--   <tt><tt>meet</tt> = <a>gcd</a></tt>.
newtype Divisibility a
Divisibility :: a -> Divisibility a
[getDivisibility] :: Divisibility a -> a
instance GHC.Generics.Generic1 Algebra.Lattice.Divisibility.Divisibility
instance Data.Traversable.Traversable Algebra.Lattice.Divisibility.Divisibility
instance Data.Foldable.Foldable Algebra.Lattice.Divisibility.Divisibility
instance GHC.Base.Functor Algebra.Lattice.Divisibility.Divisibility
instance GHC.Generics.Generic (Algebra.Lattice.Divisibility.Divisibility a)
instance Data.Data.Data a => Data.Data.Data (Algebra.Lattice.Divisibility.Divisibility a)
instance GHC.Read.Read a => GHC.Read.Read (Algebra.Lattice.Divisibility.Divisibility a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Lattice.Divisibility.Divisibility a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Lattice.Divisibility.Divisibility a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Lattice.Divisibility.Divisibility a)
instance GHC.Base.Applicative Algebra.Lattice.Divisibility.Divisibility
instance GHC.Base.Monad Algebra.Lattice.Divisibility.Divisibility
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Algebra.Lattice.Divisibility.Divisibility a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Algebra.Lattice.Divisibility.Divisibility a)
instance GHC.Real.Integral a => Algebra.Lattice.Lattice (Algebra.Lattice.Divisibility.Divisibility a)
instance GHC.Real.Integral a => Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Lattice.Divisibility.Divisibility a)
instance (GHC.Classes.Eq a, GHC.Real.Integral a) => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Divisibility.Divisibility a)
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Divisibility.Divisibility a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Divisibility.Divisibility a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Num.Num a, GHC.Classes.Ord a) => Test.QuickCheck.Arbitrary.Arbitrary (Algebra.Lattice.Divisibility.Divisibility a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Algebra.Lattice.Divisibility.Divisibility a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Algebra.Lattice.Divisibility.Divisibility a)


module Algebra.Heyting

-- | A Heyting algebra is a bounded lattice equipped with a binary
--   operation &lt;math&gt; of implication.
--   
--   <i>Laws</i>
--   
--   <pre>
--   x <a>==&gt;</a> x        ≡ <a>top</a>
--   x <a>/\</a> (x <a>==&gt;</a> y) ≡ x <a>/\</a> y
--   y <a>/\</a> (x <a>==&gt;</a> y) ≡ y
--   x <a>==&gt;</a> (y <a>/\</a> z) ≡ (x <a>==&gt;</a> y) <a>/\</a> (x <a>==&gt;</a> z)
--   </pre>
class BoundedLattice a => Heyting a

-- | Implication.
(==>) :: Heyting a => a -> a -> a

-- | Negation.
--   
--   <pre>
--   <a>neg</a> x = x <a>==&gt;</a> <a>bottom</a>
--   </pre>
neg :: Heyting a => a -> a

-- | Equivalence.
--   
--   <pre>
--   x <a>&lt;=&gt;</a> y = (x <a>==&gt;</a> y) <a>/\</a> (y <a>==&gt;</a> x)
--   </pre>
(<=>) :: Heyting a => a -> a -> a
infixr 5 <=>
infixr 5 ==>
instance Algebra.Heyting.Heyting ()
instance Algebra.Heyting.Heyting GHC.Types.Bool
instance Algebra.Heyting.Heyting a => Algebra.Heyting.Heyting (b -> a)
instance Algebra.Heyting.Heyting Data.Semigroup.Internal.All
instance Algebra.Heyting.Heyting Data.Semigroup.Internal.Any
instance Algebra.Heyting.Heyting a => Algebra.Heyting.Heyting (Data.Semigroup.Internal.Endo a)
instance Algebra.Heyting.Heyting (Data.Proxy.Proxy a)
instance Algebra.Heyting.Heyting a => Algebra.Heyting.Heyting (Data.Functor.Identity.Identity a)
instance Algebra.Heyting.Heyting a => Algebra.Heyting.Heyting (Data.Tagged.Tagged b a)
instance Algebra.Heyting.Heyting a => Algebra.Heyting.Heyting (Data.Functor.Const.Const a b)
instance Algebra.Heyting.Heyting a => Algebra.Heyting.Heyting (Data.Tuple.Solo.Solo a)
instance (GHC.Classes.Ord a, Data.Universe.Class.Finite a) => Algebra.Heyting.Heyting (Data.Set.Internal.Set a)
instance (GHC.Classes.Eq a, Data.Hashable.Class.Hashable a, Data.Universe.Class.Finite a) => Algebra.Heyting.Heyting (Data.HashSet.Internal.HashSet a)


module Algebra.Lattice.ZeroHalfOne

-- | The simplest Heyting algebra that is not already a Boolean algebra is
--   the totally ordered set &lt;math&gt;.
data ZeroHalfOne
Zero :: ZeroHalfOne
Half :: ZeroHalfOne
One :: ZeroHalfOne
instance GHC.Generics.Generic Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Data.Data.Data Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance GHC.Enum.Bounded Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance GHC.Enum.Enum Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance GHC.Show.Show Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance GHC.Read.Read Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance GHC.Classes.Ord Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance GHC.Classes.Eq Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Algebra.PartialOrd.PartialOrd Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Algebra.Lattice.Lattice Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Algebra.Lattice.BoundedJoinSemiLattice Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Algebra.Lattice.BoundedMeetSemiLattice Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Algebra.Heyting.Heyting Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Test.QuickCheck.Arbitrary.Arbitrary Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Test.QuickCheck.Arbitrary.CoArbitrary Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Test.QuickCheck.Function.Function Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Data.Universe.Class.Universe Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Data.Universe.Class.Finite Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Control.DeepSeq.NFData Algebra.Lattice.ZeroHalfOne.ZeroHalfOne
instance Data.Hashable.Class.Hashable Algebra.Lattice.ZeroHalfOne.ZeroHalfOne


-- | This module provides Unicode variants of the operators.
--   
--   Unfortunately, ⊤, ⊥, and ¬ don't fit into Haskell lexical structure
--   well.
module Algebra.Lattice.Unicode

-- | Meet, alias for <a>/\</a>.
(∧) :: Lattice a => a -> a -> a
infixr 6 ∧

-- | Join, alias for <a>\/</a>.
(∨) :: Lattice a => a -> a -> a
infixr 5 ∨

-- | Implication, alias for <a>==&gt;</a>.
(⟹) :: Heyting a => a -> a -> a
infixr 4 ⟹

-- | Equivalence, alias for <a>&lt;=&gt;</a>.
(⟺) :: Heyting a => a -> a -> a
infix 4 ⟺


module Algebra.Lattice.Ordered

-- | A total order gives rise to a lattice. Join is <a>max</a>, meet is
--   <a>min</a>.
newtype Ordered a
Ordered :: a -> Ordered a
[getOrdered] :: Ordered a -> a
instance GHC.Generics.Generic1 Algebra.Lattice.Ordered.Ordered
instance Data.Traversable.Traversable Algebra.Lattice.Ordered.Ordered
instance Data.Foldable.Foldable Algebra.Lattice.Ordered.Ordered
instance GHC.Base.Functor Algebra.Lattice.Ordered.Ordered
instance GHC.Generics.Generic (Algebra.Lattice.Ordered.Ordered a)
instance Data.Data.Data a => Data.Data.Data (Algebra.Lattice.Ordered.Ordered a)
instance GHC.Read.Read a => GHC.Read.Read (Algebra.Lattice.Ordered.Ordered a)
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Lattice.Ordered.Ordered a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Algebra.Lattice.Ordered.Ordered a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Algebra.Lattice.Ordered.Ordered a)
instance GHC.Base.Applicative Algebra.Lattice.Ordered.Ordered
instance GHC.Base.Monad Algebra.Lattice.Ordered.Ordered
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Algebra.Lattice.Ordered.Ordered a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Algebra.Lattice.Ordered.Ordered a)
instance GHC.Classes.Ord a => Algebra.Lattice.Lattice (Algebra.Lattice.Ordered.Ordered a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Lattice.Ordered.Ordered a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => Algebra.Lattice.BoundedMeetSemiLattice (Algebra.Lattice.Ordered.Ordered a)
instance (GHC.Classes.Ord a, GHC.Enum.Bounded a) => Algebra.Heyting.Heyting (Algebra.Lattice.Ordered.Ordered a)
instance GHC.Classes.Ord a => Algebra.PartialOrd.PartialOrd (Algebra.Lattice.Ordered.Ordered a)
instance Data.Universe.Class.Universe a => Data.Universe.Class.Universe (Algebra.Lattice.Ordered.Ordered a)
instance Data.Universe.Class.Finite a => Data.Universe.Class.Finite (Algebra.Lattice.Ordered.Ordered a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Algebra.Lattice.Ordered.Ordered a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Algebra.Lattice.Ordered.Ordered a)
instance Test.QuickCheck.Function.Function a => Test.QuickCheck.Function.Function (Algebra.Lattice.Ordered.Ordered a)


module Algebra.Lattice.M2

-- | &lt;math&gt; is isomorphic to &lt;math&gt;, i.e. powerset of
--   <a>Bool</a>.
--   
data M2
M2o :: M2
M2a :: M2
M2b :: M2
M2i :: M2
toSetBool :: M2 -> Set Bool
fromSetBool :: Set Bool -> M2
instance GHC.Generics.Generic Algebra.Lattice.M2.M2
instance Data.Data.Data Algebra.Lattice.M2.M2
instance GHC.Enum.Bounded Algebra.Lattice.M2.M2
instance GHC.Enum.Enum Algebra.Lattice.M2.M2
instance GHC.Show.Show Algebra.Lattice.M2.M2
instance GHC.Read.Read Algebra.Lattice.M2.M2
instance GHC.Classes.Ord Algebra.Lattice.M2.M2
instance GHC.Classes.Eq Algebra.Lattice.M2.M2
instance Algebra.PartialOrd.PartialOrd Algebra.Lattice.M2.M2
instance Algebra.Lattice.Lattice Algebra.Lattice.M2.M2
instance Algebra.Lattice.BoundedJoinSemiLattice Algebra.Lattice.M2.M2
instance Algebra.Lattice.BoundedMeetSemiLattice Algebra.Lattice.M2.M2
instance Algebra.Heyting.Heyting Algebra.Lattice.M2.M2
instance Test.QuickCheck.Arbitrary.Arbitrary Algebra.Lattice.M2.M2
instance Test.QuickCheck.Arbitrary.CoArbitrary Algebra.Lattice.M2.M2
instance Test.QuickCheck.Function.Function Algebra.Lattice.M2.M2
instance Data.Universe.Class.Universe Algebra.Lattice.M2.M2
instance Data.Universe.Class.Finite Algebra.Lattice.M2.M2
instance Control.DeepSeq.NFData Algebra.Lattice.M2.M2
instance Data.Hashable.Class.Hashable Algebra.Lattice.M2.M2

module Algebra.Heyting.Free

-- | Free Heyting algebra.
--   
--   Note: <a>Eq</a> and <a>PartialOrd</a> instances aren't structural.
--   
--   <pre>
--   &gt;&gt;&gt; Top == (Var 'x' ==&gt; Var 'x')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Var 'x' == Var 'y'
--   False
--   </pre>
--   
--   You can test for taulogogies:
--   
--   <pre>
--   &gt;&gt;&gt; leq Top $ (Var 'A' /\ Var 'B' ==&gt; Var 'C') &lt;=&gt;  (Var 'A' ==&gt; Var 'B' ==&gt; Var 'C')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; leq Top $ (Var 'A' /\ neg (Var 'A')) &lt;=&gt; Bottom
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; leq Top $ (Var 'A' \/ neg (Var 'A')) &lt;=&gt; Top
--   False
--   </pre>
data Free a
Var :: a -> Free a
Bottom :: Free a
Top :: Free a
(:/\:) :: Free a -> Free a -> Free a
(:\/:) :: Free a -> Free a -> Free a
(:=>:) :: Free a -> Free a -> Free a
infixr 6 :/\:
infixr 5 :\/:
infixr 4 :=>:
liftFree :: a -> Free a
lowerFree :: Heyting b => (a -> b) -> Free a -> b
retractFree :: Heyting a => Free a -> a
substFree :: Free a -> (a -> Free b) -> Free b
toExpr :: Free a -> Expr a
instance Data.Data.Data a => Data.Data.Data (Algebra.Heyting.Free.Free a)
instance GHC.Generics.Generic1 Algebra.Heyting.Free.Free
instance GHC.Generics.Generic (Algebra.Heyting.Free.Free a)
instance Data.Traversable.Traversable Algebra.Heyting.Free.Free
instance Data.Foldable.Foldable Algebra.Heyting.Free.Free
instance GHC.Base.Functor Algebra.Heyting.Free.Free
instance GHC.Show.Show a => GHC.Show.Show (Algebra.Heyting.Free.Free a)
instance GHC.Base.Applicative Algebra.Heyting.Free.Free
instance GHC.Base.Monad Algebra.Heyting.Free.Free
instance Algebra.Lattice.Lattice (Algebra.Heyting.Free.Free a)
instance Algebra.Lattice.BoundedJoinSemiLattice (Algebra.Heyting.Free.Free a)
instance Algebra.Lattice.BoundedMeetSemiLattice (Algebra.Heyting.Free.Free a)
instance Algebra.Heyting.Heyting (Algebra.Heyting.Free.Free a)
instance GHC.Classes.Ord a => GHC.Classes.Eq (Algebra.Heyting.Free.Free a)
instance GHC.Classes.Ord a => Algebra.PartialOrd.PartialOrd (Algebra.Heyting.Free.Free a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Algebra.Heyting.Free.Free a)


-- | This module re-exports orphan instances from <a>Eq</a> module, and
--   <tt>(PartialOrd v, Finite k) =&gt; PartialOrd (k -&gt; v)</tt>
--   instance.
module Algebra.PartialOrd.Instances
instance (Algebra.PartialOrd.PartialOrd v, Data.Universe.Class.Finite k) => Algebra.PartialOrd.PartialOrd (k -> v)
instance (Algebra.PartialOrd.PartialOrd v, Data.Universe.Class.Finite v) => Algebra.PartialOrd.PartialOrd (Data.Semigroup.Internal.Endo v)
