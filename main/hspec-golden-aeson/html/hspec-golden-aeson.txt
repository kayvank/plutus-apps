-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Use tests to monitor changes in Aeson serialization
--   
--   Use tests to monitor changes in Aeson serialization
@package hspec-golden-aeson
@version 0.9.0.0


module Test.Aeson.Internal.Utils

-- | Option to indicate whether to create a separate comparison file or
--   overwrite the golden file. A separate file allows you to use
--   <tt>diff</tt> to compare. Overwriting allows you to use source control
--   tools for comparison.
data ComparisonFile

-- | Create a new faulty file when tests fail
FaultyFile :: ComparisonFile

-- | Overwrite the golden file when tests fail
OverwriteGoldenFile :: ComparisonFile

-- | Option indicating whether to fail tests when the random seed does not
--   produce the same values as in the golden file. Default is to output a
--   warning.
data RandomMismatchOption

-- | Only output a warning when the random seed does not produce the same
--   values
RandomMismatchWarning :: RandomMismatchOption

-- | Fail the test when the random seed does not produce the same value
RandomMismatchError :: RandomMismatchOption
data Settings
Settings :: GoldenDirectoryOption -> Bool -> Int -> ComparisonFile -> RandomMismatchOption -> Settings

-- | use a custom directory name or use the generic "golden" directory.
[goldenDirectoryOption] :: Settings -> GoldenDirectoryOption

-- | If true, use the module name in the file path, otherwise ignore it.
[useModuleNameAsSubDirectory] :: Settings -> Bool

-- | How many instances of each type you want. If you use ADT versions than
--   it will use the sample size for each constructor.
[sampleSize] :: Settings -> Int

-- | Whether to create a separate comparison file or ovewrite the golden
--   file.
[comparisonFile] :: Settings -> ComparisonFile

-- | Whether to output a warning or fail the test when the random seed
--   produces different values than the values in the golden file.
[randomMismatchOption] :: Settings -> RandomMismatchOption

-- | A custom directory name or a preselected directory name.
data GoldenDirectoryOption
CustomDirectoryName :: String -> GoldenDirectoryOption
GoldenDirectory :: GoldenDirectoryOption

-- | The default settings for general use cases.
defaultSettings :: Settings

-- | put brackets around a String.
addBrackets :: String -> String

-- | <a>hspec</a> style combinator to easily write tests that check the a
--   given operation returns the same value it was given, e.g. roundtrip
--   tests.
shouldBeIdentity :: (Eq a, Show a, Arbitrary a) => Proxy a -> (a -> IO a) -> Property

-- | This function will compare one JSON encoding to a subsequent JSON
--   encoding, thus eliminating the need for an Eq instance
checkAesonEncodingEquality :: forall a. (ToJSON a, FromJSON a) => JsonShow a -> Bool

-- | run decode in IO, if it returns Left then throw an error.
aesonDecodeIO :: FromJSON a => ByteString -> IO a
data AesonDecodeError
AesonDecodeError :: String -> AesonDecodeError

-- | Used to eliminate the need for an Eq instance
newtype JsonShow a
JsonShow :: a -> JsonShow a
newtype TopDir
TopDir :: FilePath -> TopDir
[unTopDir] :: TopDir -> FilePath
newtype ModuleName
ModuleName :: FilePath -> ModuleName
[unModuleName] :: ModuleName -> FilePath
newtype TypeName
TypeName :: FilePath -> TypeName
[unTypeName] :: TypeName -> FilePath
data TypeNameInfo a
TypeNameInfo :: TopDir -> Maybe ModuleName -> TypeName -> TypeNameInfo a
[typeNameTopDir] :: TypeNameInfo a -> TopDir
[typeNameModuleName] :: TypeNameInfo a -> Maybe ModuleName
[typeNameTypeName] :: TypeNameInfo a -> TypeName
mkTypeNameInfo :: forall a. Arbitrary a => Typeable a => Settings -> Proxy a -> IO (TypeNameInfo a)
encodePrettySortedKeys :: ToJSON a => a -> ByteString
instance GHC.Classes.Eq Test.Aeson.Internal.Utils.AesonDecodeError
instance GHC.Show.Show Test.Aeson.Internal.Utils.AesonDecodeError
instance GHC.Show.Show Test.Aeson.Internal.Utils.TopDir
instance GHC.Read.Read Test.Aeson.Internal.Utils.TopDir
instance GHC.Classes.Eq Test.Aeson.Internal.Utils.TopDir
instance GHC.Show.Show Test.Aeson.Internal.Utils.ModuleName
instance GHC.Read.Read Test.Aeson.Internal.Utils.ModuleName
instance GHC.Classes.Eq Test.Aeson.Internal.Utils.ModuleName
instance GHC.Show.Show Test.Aeson.Internal.Utils.TypeName
instance GHC.Read.Read Test.Aeson.Internal.Utils.TypeName
instance GHC.Classes.Eq Test.Aeson.Internal.Utils.TypeName
instance GHC.Show.Show (Test.Aeson.Internal.Utils.TypeNameInfo a)
instance GHC.Read.Read (Test.Aeson.Internal.Utils.TypeNameInfo a)
instance GHC.Classes.Eq (Test.Aeson.Internal.Utils.TypeNameInfo a)
instance Data.Aeson.Types.ToJSON.ToJSON a => GHC.Show.Show (Test.Aeson.Internal.Utils.JsonShow a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Test.Aeson.Internal.Utils.JsonShow a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Test.Aeson.Internal.Utils.JsonShow a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Test.Aeson.Internal.Utils.JsonShow a)
instance GHC.Exception.Type.Exception Test.Aeson.Internal.Utils.AesonDecodeError


-- | Internal module, use at your own risk.
module Test.Aeson.Internal.RoundtripSpecs

-- | A roundtrip test to check whether values of the given type can be
--   successfully converted to JSON and back to a Haskell value.
--   
--   <a>roundtripSpecs</a> will
--   
--   <ul>
--   <li>create random values (using <a>Arbitrary</a>),</li>
--   <li>convert them into JSON (using <a>ToJSON</a>),</li>
--   <li>read them back into Haskell (using <a>FromJSON</a>) and</li>
--   <li>make sure that the result is the same as the value it started with
--   (using <a>Eq</a>).</li>
--   </ul>
roundtripSpecs :: forall a. (Typeable a, Arbitrary a, ToJSON a, FromJSON a) => Proxy a -> Spec

-- | Same as <a>roundtripSpecs</a>, but optionally add notes to the
--   <a>describe</a> function.
genericAesonRoundtripWithNote :: forall a. (Typeable a, Arbitrary a, ToJSON a, FromJSON a) => Proxy a -> Maybe String -> Spec

-- | Same as <a>genericAesonRoundtripWithNote</a>, but no need for
--   Typeable, Eq, or Show
genericAesonRoundtripWithNotePlain :: forall a. (Arbitrary a, ToJSON a, FromJSON a) => Proxy a -> Maybe String -> String -> Spec


-- | Internal module, use at your own risk.
module Test.Aeson.Internal.RandomSamples

-- | RandomSamples, using a seed allows you to replicate an arbitrary. By
--   storing the seed and the samples (previously produced arbitraries), we
--   can try to reproduce the same samples by generating the arbitraries
--   with a seed.
data RandomSamples a
RandomSamples :: Int32 -> [a] -> RandomSamples a
[seed] :: RandomSamples a -> Int32
[samples] :: RandomSamples a -> [a]

-- | Apply the seed.
setSeed :: Int -> Gen a -> Gen a

-- | Reads the seed without looking at the samples.
readSeed :: ByteString -> IO Int32

-- | Read the sample size.
readSampleSize :: ByteString -> IO Int
instance GHC.Generics.Generic (Test.Aeson.Internal.RandomSamples.RandomSamples a)
instance GHC.Show.Show a => GHC.Show.Show (Test.Aeson.Internal.RandomSamples.RandomSamples a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Test.Aeson.Internal.RandomSamples.RandomSamples a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.Aeson.Internal.RandomSamples.RandomSamples a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Test.Aeson.Internal.RandomSamples.RandomSamples a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Test.Aeson.Internal.RandomSamples.RandomSamples a)


-- | Internal module, use at your own risk.
module Test.Aeson.Internal.GoldenSpecs

-- | Tests to ensure that JSON encoding has not unintentionally changed.
--   This could be caused by the following:
--   
--   <ul>
--   <li>A type's instances of <a>ToJSON</a> or <a>FromJSON</a> have
--   changed.</li>
--   <li>Selectors have been edited, added or deleted.</li>
--   <li>You have changed version of Aeson the way Aeson serialization has
--   changed works.</li>
--   </ul>
--   
--   If you run this function and the golden files do not exist, it will
--   create them for each constructor. It they do exist, it will compare
--   with golden file if it exists. Golden file encodes json format of a
--   type. It is recommended that you put the golden files under revision
--   control to help monitor changes.
goldenSpecs :: (Typeable a, Arbitrary a, ToJSON a, FromJSON a) => Settings -> Proxy a -> Spec

-- | same as <a>goldenSpecs</a> but has the option of passing a note to the
--   <a>describe</a> function.
goldenSpecsWithNote :: forall a. (Typeable a, Arbitrary a, ToJSON a, FromJSON a) => Settings -> Proxy a -> Maybe String -> Spec

-- | same as <a>goldenSpecsWithNote</a> but does not require a Typeable, Eq
--   or Show instance.
goldenSpecsWithNotePlain :: forall a. (Arbitrary a, ToJSON a, FromJSON a) => Settings -> TypeNameInfo a -> Maybe String -> Spec

-- | The golden files already exist. Serialize values with the same seed
--   from the golden file and compare the with the JSON in the golden file.
compareWithGolden :: forall a. (Arbitrary a, ToJSON a, FromJSON a) => TypeNameInfo a -> Proxy a -> FilePath -> ComparisonFile -> IO ()

-- | The golden files do not exist. Create it.
createGoldenfile :: forall a. (Arbitrary a, ToJSON a) => Settings -> Proxy a -> FilePath -> IO ()

-- | Create the file path for the golden file. Optionally use the module
--   name to help avoid name collissions. Different modules can have types
--   of the same name.
mkGoldenFile :: TypeNameInfo a -> FilePath

-- | Create the file path to save results from a failed golden test.
--   Optionally use the module name to help avoid name collisions.
--   Different modules can have types of the same name.
mkFaultyFile :: TypeNameInfo a -> FilePath

-- | Create the file path to save results from a failed fallback golden
--   test. Optionally use the module name to help avoid name collisions.
--   Different modules can have types of the same name.
mkFaultyReencodedFile :: TypeNameInfo a -> FilePath

-- | Create a number of arbitrary instances of a type a sample size and a
--   random seed.
mkRandomSamples :: forall a. Arbitrary a => Int -> Proxy a -> Int32 -> IO (RandomSamples a)


-- | Internal module, use at your own risk.
module Test.Aeson.Internal.ADT.RoundtripSpecs

-- | A roundtrip test to check whether values of all of constructors of the
--   given type can be successfully converted to JSON and back to a Haskell
--   value.
--   
--   <a>roundtripADTSpecs</a> will
--   
--   <ul>
--   <li>create random values for each constructor using
--   <a>ToADTArbitrary</a>,</li>
--   <li>convert them into JSON using <a>ToJSON</a>,</li>
--   <li>read them back into Haskell using <a>FromJSON</a> and</li>
--   <li>make sure that the result is the same as the value it started with
--   using <a>Eq</a>.</li>
--   </ul>
roundtripADTSpecs :: forall a. (Arbitrary a, ToADTArbitrary a, Eq a, Show a, ToJSON a, FromJSON a) => Proxy a -> Spec

-- | Same as <a>roundtripADTSpecs</a> but has the option of passing a note
--   to the <a>describe</a> function.
genericAesonRoundtripADTWithNote :: forall a. (ToADTArbitrary a, Eq a, Show a, Arbitrary a, ToJSON a, FromJSON a) => Proxy a -> Maybe String -> Spec


-- | Internal module, use at your own risk.
module Test.Aeson.Internal.ADT.GoldenSpecs

-- | Tests to ensure that JSON encoding has not unintentionally changed.
--   This could be caused by the following:
--   
--   <ul>
--   <li>A type's instances of <a>ToJSON</a> or <a>FromJSON</a> have
--   changed.</li>
--   <li>Selectors have been edited, added or deleted.</li>
--   <li>You have changed version of Aeson the way Aeson serialization has
--   changed works.</li>
--   </ul>
--   
--   If you run this function and the golden files do not exist, it will
--   create them for each constructor. It they do exist, it will compare
--   with golden file if it exists. Golden file encodes json format of a
--   type. It is recommended that you put the golden files under revision
--   control to help monitor changes.
goldenADTSpecs :: forall a. (ToADTArbitrary a, Eq a, Show a, ToJSON a, FromJSON a) => Settings -> Proxy a -> Spec

-- | same as <a>goldenADTSpecs</a> but has the option of passing a note to
--   the <a>describe</a> function.
goldenADTSpecsWithNote :: forall a. (ToADTArbitrary a, Eq a, Show a, ToJSON a, FromJSON a) => Settings -> Proxy a -> Maybe String -> Spec

-- | test a single set of values from a constructor for a given type.
testConstructor :: forall a. (Eq a, Show a, FromJSON a, ToJSON a, ToADTArbitrary a) => Settings -> String -> String -> ConstructorArbitraryPair a -> SpecWith (Arg (IO ()))

-- | The golden files already exist. Serialize values with the same seed
--   from the golden files of each constructor and compare.
compareWithGolden :: forall a. (Show a, Eq a, FromJSON a, ToJSON a, ToADTArbitrary a) => RandomMismatchOption -> String -> Maybe String -> String -> ConstructorArbitraryPair a -> FilePath -> IO ()

-- | The golden files do not exist. Create them for each constructor.
createGoldenFile :: forall a. (ToJSON a, ToADTArbitrary a) => Int -> ConstructorArbitraryPair a -> FilePath -> IO ()

-- | Create the file path for the golden file. Optionally use the module
--   name to help avoid name collissions. Different modules can have types
--   of the same name.
mkGoldenFilePath :: forall a. FilePath -> Maybe FilePath -> FilePath -> ConstructorArbitraryPair a -> FilePath

-- | Create the file path to save results from a failed golden test.
--   Optionally use the module name to help avoid name collisions.
--   Different modules can have types of the same name.
mkFaultyFilePath :: forall a. FilePath -> Maybe FilePath -> FilePath -> ConstructorArbitraryPair a -> FilePath

-- | Create the file path to save results from a failed fallback golden
--   test. Optionally use the module name to help avoid name collisions.
--   Different modules can have types of the same name.
mkFaultyReencodedFilePath :: forall a. FilePath -> Maybe FilePath -> FilePath -> ConstructorArbitraryPair a -> FilePath

-- | Create a number of arbitrary instances of a particular constructor
--   given a sample size and a random seed.
mkRandomADTSamplesForConstructor :: forall a. ToADTArbitrary a => Int -> Proxy a -> String -> Int32 -> IO (RandomSamples a)

-- | Make a Golden File for the Proxy of a type if the file does not exist.
mkGoldenFileForType :: forall a. (ToJSON a, ToADTArbitrary a) => Int -> Proxy a -> FilePath -> IO ()


-- | This package provides tools for testing Aeson serialization.
--   
--   <ul>
--   <li>Test that <a>ToJSON</a> and <a>FromJSON</a> instances are
--   isomorphic.</li>
--   <li>Alert you when unexpected changes in Aeson serialization
--   occur.</li>
--   <li>Record JSON formatting of Haskell types.</li>
--   </ul>
module Test.Aeson.GenericSpecs

-- | Tests to ensure that JSON encoding has not unintentionally changed.
--   This could be caused by the following:
--   
--   <ul>
--   <li>A type's instances of <a>ToJSON</a> or <a>FromJSON</a> have
--   changed.</li>
--   <li>Selectors have been edited, added or deleted.</li>
--   <li>You have changed version of Aeson the way Aeson serialization has
--   changed works.</li>
--   </ul>
--   
--   If you run this function and the golden files do not exist, it will
--   create them for each constructor. It they do exist, it will compare
--   with golden file if it exists. Golden file encodes json format of a
--   type. It is recommended that you put the golden files under revision
--   control to help monitor changes.
goldenSpecs :: (Typeable a, Arbitrary a, ToJSON a, FromJSON a) => Settings -> Proxy a -> Spec

-- | A roundtrip test to check whether values of the given type can be
--   successfully converted to JSON and back to a Haskell value.
--   
--   <a>roundtripSpecs</a> will
--   
--   <ul>
--   <li>create random values (using <a>Arbitrary</a>),</li>
--   <li>convert them into JSON (using <a>ToJSON</a>),</li>
--   <li>read them back into Haskell (using <a>FromJSON</a>) and</li>
--   <li>make sure that the result is the same as the value it started with
--   (using <a>Eq</a>).</li>
--   </ul>
roundtripSpecs :: forall a. (Typeable a, Arbitrary a, ToJSON a, FromJSON a) => Proxy a -> Spec

-- | run roundtrip and golden test for a type. sampleSize is used only when
--   creating the golden file. When it is compared, the sampleSize is
--   derived from the file.
roundtripAndGoldenSpecs :: forall a. (Arbitrary a, ToJSON a, FromJSON a, Typeable a) => Proxy a -> Spec

-- | Tests to ensure that JSON encoding has not unintentionally changed.
--   This could be caused by the following:
--   
--   <ul>
--   <li>A type's instances of <a>ToJSON</a> or <a>FromJSON</a> have
--   changed.</li>
--   <li>Selectors have been edited, added or deleted.</li>
--   <li>You have changed version of Aeson the way Aeson serialization has
--   changed works.</li>
--   </ul>
--   
--   If you run this function and the golden files do not exist, it will
--   create them for each constructor. It they do exist, it will compare
--   with golden file if it exists. Golden file encodes json format of a
--   type. It is recommended that you put the golden files under revision
--   control to help monitor changes.
goldenADTSpecs :: forall a. (ToADTArbitrary a, Eq a, Show a, ToJSON a, FromJSON a) => Settings -> Proxy a -> Spec

-- | A roundtrip test to check whether values of all of constructors of the
--   given type can be successfully converted to JSON and back to a Haskell
--   value.
--   
--   <a>roundtripADTSpecs</a> will
--   
--   <ul>
--   <li>create random values for each constructor using
--   <a>ToADTArbitrary</a>,</li>
--   <li>convert them into JSON using <a>ToJSON</a>,</li>
--   <li>read them back into Haskell using <a>FromJSON</a> and</li>
--   <li>make sure that the result is the same as the value it started with
--   using <a>Eq</a>.</li>
--   </ul>
roundtripADTSpecs :: forall a. (Arbitrary a, ToADTArbitrary a, Eq a, Show a, ToJSON a, FromJSON a) => Proxy a -> Spec

-- | <a>roundtripAndGoldenSpecs</a> with custom settings.
roundtripAndGoldenSpecsWithSettings :: forall a. (Arbitrary a, ToJSON a, FromJSON a, Typeable a) => Settings -> Proxy a -> Spec

-- | run roundtrip and golden tests for all constructors of a type.
--   sampleSize is used only when creating the golden files. When they are
--   compared, the sampleSize is derived from the file.
roundtripAndGoldenADTSpecs :: forall a. (Arbitrary a, ToADTArbitrary a, Eq a, Show a, ToJSON a, FromJSON a) => Proxy a -> Spec

-- | <a>roundtripAndGoldenADTSpecs</a> with custom settings.
roundtripAndGoldenADTSpecsWithSettings :: forall a. (Arbitrary a, ToADTArbitrary a, Eq a, Show a, ToJSON a, FromJSON a) => Settings -> Proxy a -> Spec

-- | Make a Golden File for the Proxy of a type if the file does not exist.
mkGoldenFileForType :: forall a. (ToJSON a, ToADTArbitrary a) => Int -> Proxy a -> FilePath -> IO ()

-- | <a>hspec</a> style combinator to easily write tests that check the a
--   given operation returns the same value it was given, e.g. roundtrip
--   tests.
shouldBeIdentity :: (Eq a, Show a, Arbitrary a) => Proxy a -> (a -> IO a) -> Property

-- | A custom directory name or a preselected directory name.
data GoldenDirectoryOption
CustomDirectoryName :: String -> GoldenDirectoryOption
GoldenDirectory :: GoldenDirectoryOption
data Settings
Settings :: GoldenDirectoryOption -> Bool -> Int -> ComparisonFile -> RandomMismatchOption -> Settings

-- | use a custom directory name or use the generic "golden" directory.
[goldenDirectoryOption] :: Settings -> GoldenDirectoryOption

-- | If true, use the module name in the file path, otherwise ignore it.
[useModuleNameAsSubDirectory] :: Settings -> Bool

-- | How many instances of each type you want. If you use ADT versions than
--   it will use the sample size for each constructor.
[sampleSize] :: Settings -> Int

-- | Whether to create a separate comparison file or ovewrite the golden
--   file.
[comparisonFile] :: Settings -> ComparisonFile

-- | Whether to output a warning or fail the test when the random seed
--   produces different values than the values in the golden file.
[randomMismatchOption] :: Settings -> RandomMismatchOption

-- | The default settings for general use cases.
defaultSettings :: Settings

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)
