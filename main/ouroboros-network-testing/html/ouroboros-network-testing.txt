-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Common modules used for testing in ouroboros-network and ouroboros-consensus
--   
--   Common modules used for testing in ouroboros-network and
--   ouroboros-consensus
@package ouroboros-network-testing
@version 0.1.0.1

module Ouroboros.Network.Testing.Data.Signal

-- | A time-ordered trace of discrete events that occur at specific times.
--   
--   This corresponds for example to a trace of events or observations from
--   a simulation.
data Events a

-- | Construct <a>Events</a> from a time series.
eventsFromList :: [(Time, a)] -> Events a

-- | Construct <a>Events</a> from a time series.
--   
--   The time series is truncated at (but not including) the given time.
--   This is necessary to check properties over finite prefixes of infinite
--   time series.
eventsFromListUpToTime :: Time -> [(Time, a)] -> Events a
eventsToList :: Events a -> [(Time, a)]
selectEvents :: (a -> Maybe b) -> Events a -> Events b
primitiveTransformEvents :: ([E a] -> [E b]) -> Events a -> Events b
data TS
TS :: !Time -> !Int -> TS
data E a
E :: {-# UNPACK #-} !TS -> a -> E a

-- | A signal is a time-varying value. It has a value at all times. It
--   changes value at discrete times, i.e. it is not continuous.
data Signal a

-- | Construct a <a>Signal</a> from an initial value and a time series of
--   events that represent new values of the signal.
--   
--   This only makes sense for events that sample a single time-varying
--   value.
fromChangeEvents :: a -> Events a -> Signal a

-- | Convert a <a>Signal</a> into a time series of events when the signal
--   value changes.
toChangeEvents :: Signal a -> Events a

-- | Construct a <a>Signal</a> that represents a time series of discrete
--   events. The signal is <tt>Just</tt> the event value at the time of the
--   event, and is <tt>Nothing</tt> at all other times.
--   
--   Note that this signal "instantaneously" takes the event value and
--   reverts to <tt>Nothing</tt> before time moves on. Therefore this kind
--   of signal is not "stable" in the sense of <tt>stableSignal</tt>.
fromEvents :: Events a -> Signal (Maybe a)

-- | Check a property over a <a>Signal</a>. The property should be true at
--   all times.
--   
--   On failure it shows the <tt>n</tt> most recent signal values.
signalProperty :: forall a. Int -> (a -> String) -> (a -> Bool) -> Signal a -> Property
truncateAt :: Time -> Signal a -> Signal a

-- | A signal can change value more than once at a single point of time.
--   
--   Sometimes we are interested only in the final "stable" value of the
--   signal before time moves on. This function discards the other values,
--   keeping only the final value at each time.
stable :: Signal a -> Signal a

-- | Sometimes the way a signal is constructed leads to duplicate signal
--   values which can slow down signal processing. This tidies up the
--   signal by eliminating the duplicates. This does not change the meaning
--   (provided the <a>Eq</a> instance is true equality).
nub :: Eq a => Signal a -> Signal a
nubBy :: (a -> a -> Bool) -> Signal a -> Signal a

-- | A linger signal remains <tt>True</tt> for the given time after the
--   underlying signal is <tt>True</tt>.
linger :: DiffTime -> (a -> Bool) -> Signal a -> Signal Bool

-- | Make a timeout signal, based on observing an underlying signal.
--   
--   The timeout signal takes the value <tt>True</tt> when the timeout has
--   occurred, and <tt>False</tt> otherwise.
--   
--   The timeout is controlled by an "arming" function on the underlying
--   signal. The arming function should return <tt>True</tt> when the
--   timeout should be started, and it returns the time to wait before the
--   timeout fires. The arming function should return <tt>False</tt> when
--   the timeout should be cancelled or not started.
--   
--   The output signal becomes <tt>True</tt> when the arming function has
--   been continuously active (i.e. returning <tt>True</tt>) for the given
--   duration.
timeout :: forall a. DiffTime -> (a -> Bool) -> Signal a -> Signal Bool
until :: (a -> Bool) -> (a -> Bool) -> Signal a -> Signal Bool
difference :: (a -> a -> b) -> Signal a -> Signal (Maybe b)
scanl :: (b -> a -> b) -> b -> Signal a -> Signal b

-- | Make a signal that says if a given event longed at least a certain
--   time (timeout), based on observing an underlying signal.
--   
--   The underlying signal is scrutinised with the provided "timeout
--   arming" function that tells us if the signal value is interesting to
--   track. If it is, we arm it with a timeout and see, if until the
--   timeout goes off there's no other event to arm. If any activity occurs
--   again before the previous timeout, then the timeout is reset with the
--   new event and the other one is discarded.
keyedTimeout :: forall a b. Ord b => DiffTime -> (a -> Set b) -> Signal a -> Signal (Set b)

-- | Make a signal that keeps track of recent activity, based on observing
--   an underlying signal.
--   
--   The underlying signal is scrutinised with the provided "activity
--   interest" function that tells us if the signal value is activity of
--   interest to track. If it is, the given key is entered into the result
--   signal set for the given time duration. If the same activity occurs
--   again before the duration expires then the expiry will be extended to
--   the new deadline (it is not cumulative). The key will be removed from
--   the result signal set when it expires.
keyedLinger :: forall a b. Ord b => DiffTime -> (a -> Set b) -> Signal a -> Signal (Set b)
keyedUntil :: forall a b. Ord b => (a -> Set b) -> (a -> Set b) -> (a -> Bool) -> Signal a -> Signal (Set b)
instance GHC.Show.Show Ouroboros.Network.Testing.Data.Signal.TS
instance GHC.Classes.Ord Ouroboros.Network.Testing.Data.Signal.TS
instance GHC.Classes.Eq Ouroboros.Network.Testing.Data.Signal.TS
instance GHC.Base.Functor Ouroboros.Network.Testing.Data.Signal.E
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Testing.Data.Signal.E a)
instance GHC.Base.Functor Ouroboros.Network.Testing.Data.Signal.Events
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Testing.Data.Signal.Events a)
instance GHC.Base.Functor Ouroboros.Network.Testing.Data.Signal.Signal
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Testing.Data.Signal.Signal a)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Ouroboros.Network.Testing.Data.Signal.MergeResult a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Ouroboros.Network.Testing.Data.Signal.MergeResult a b)
instance GHC.Base.Applicative Ouroboros.Network.Testing.Data.Signal.Signal

module Ouroboros.Network.Testing.QuickCheck

-- | <a>IOSim</a> analogue of <a>runSTGen</a>
--   
--   <pre>
--   runSTGen  :: (forall s. Gen (ST    s a)) -&gt; Gen a
--   runSimGen :: (forall s. Gen (IOSim s a)) -&gt; Gen a
--   </pre>
runSimGen :: (forall s. Gen (IOSim s a)) -> Gen a

-- | <a>IOSim</a> analogue of <a>monadicST</a>
--   
--   <pre>
--   monadicST  :: Testable a =&gt; (forall s. PropertyM (ST    s) a) -&gt; Property
--   monadicSim :: Testable a =&gt; (forall s. PropertyM (IOSim s) a) -&gt; Property
--   </pre>
monadicSim :: Testable a => (forall s. PropertyM (IOSim s) a) -> Property

module Ouroboros.Network.Testing.Serialise

-- | Types that are instances of the <tt><a>Serialise</a></tt> class allow
--   values to be quickly encoded or decoded directly to a CBOR
--   representation, for object transmission or storage.
class Serialise a

-- | Definition for encoding a given type into a binary representation,
--   using the <tt><a>Encoding</a></tt> <tt><a>Monoid</a></tt>.
encode :: Serialise a => a -> Encoding

-- | Definition of a given <tt><a>Decoder</a></tt> for a type.
decode :: Serialise a => Decoder s a

-- | Utility to support specialised encoding for some list type - used for
--   <tt><a>Char</a></tt>/<tt><a>String</a></tt> instances in this package.
encodeList :: Serialise a => [a] -> Encoding

-- | Utility to support specialised decoding for some list type - used for
--   <tt><a>Char</a></tt>/<tt><a>String</a></tt> instances in this package.
decodeList :: Serialise a => Decoder s [a]
prop_serialise :: (Serialise a, Eq a, Show a) => a -> Property
prop_serialise_valid :: Serialise a => a -> Property
prop_serialise_roundtrip :: (Serialise a, Eq a, Show a) => a -> Property

module Ouroboros.Network.Testing.Utils
newtype Delay
Delay :: DiffTime -> Delay
[getDelay] :: Delay -> DiffTime
genDelayWithPrecision :: Integer -> Gen DiffTime
newtype SmallDelay
SmallDelay :: DiffTime -> SmallDelay
[getSmallDelay] :: SmallDelay -> DiffTime

-- | Pick a subset of a set, using a 50:50 chance for each set element.
arbitrarySubset :: Ord a => Set a -> Gen (Set a)

-- | Like <a>shrinkList</a> but only shrink the elems, don't drop elements.
--   
--   Useful when you want a custom strategy for dropping elements.
shrinkVector :: (a -> [a]) -> [a] -> [[a]]

-- | Check that each shrink satisfies some invariant or validity condition.
prop_shrink_valid :: (Arbitrary a, Show a) => (a -> Bool) -> Fixed a -> Property

-- | The <a>shrink</a> function needs to give a valid value that is
--   <i>smaller</i> than the original, otherwise the shrinking procedure is
--   not well-founded and can cycle.
--   
--   This property does not check size, as that would need significant
--   extra infrastructure to define an appropriate measure. Instead this
--   property simply checks each shrink is not the same as the original.
--   This catches simple 1-cycles, but not bigger cycles. These are
--   fortunately the most common case, so it is still a useful property in
--   practice.
prop_shrink_nonequal :: (Arbitrary a, Eq a) => Fixed a -> Property
data WithName name event
WithName :: name -> event -> WithName name event
[wnName] :: WithName name event -> name
[wnEvent] :: WithName name event -> event
data WithTime event
WithTime :: Time -> event -> WithTime event
[wtTime] :: WithTime event -> Time
[wtEvent] :: WithTime event -> event
tracerWithName :: name -> Tracer m (WithName name a) -> Tracer m a
tracerWithTime :: MonadMonotonicTime m => Tracer m (WithTime a) -> Tracer m a
tracerWithTimeName :: MonadMonotonicTime m => name -> Tracer m (WithTime (WithName name a)) -> Tracer m a
swapTimeWithName :: WithTime (WithName name b) -> WithName name (WithTime b)
swapNameWithTime :: WithName name (WithTime b) -> WithTime (WithName name b)

-- | Split Trace events into separate traces indexed by a given name.
splitWithNameTrace :: Ord name => Trace r (WithName name b) -> Trace r [WithName name b]
debugTracer :: (Show a, Applicative m) => Tracer m a
sayTracer :: (Show a, MonadSay m) => Tracer m a
nightlyTest :: TestTree -> TestTree

-- | Prevents the tests from running and reports them as succeeding.
--   
--   This may be be desireable as an alternative to commenting out the
--   tests. This way, they are still typechecked (preventing bitrot), and
--   the test report lists them, which serves as a reminder that there are
--   ignored tests.
--   
--   Note that any setup/teardown actions executed by <a>withResource</a>
--   are still executed. You can bypass this manually as in the following
--   example:
--   
--   <pre>
--   askOption $ \(MyFlag b) -&gt; if b
--                              then withResource mytest
--                              else ignoreTest . mytest $ return junkvalue
--   </pre>
ignoreTest :: TestTree -> TestTree

-- | Use in <a>tabulate</a> to help summarise data into buckets.
renderRanges :: Int -> Int -> String
instance GHC.Num.Num Ouroboros.Network.Testing.Utils.Delay
instance GHC.Classes.Ord Ouroboros.Network.Testing.Utils.Delay
instance GHC.Classes.Eq Ouroboros.Network.Testing.Utils.Delay
instance GHC.Show.Show Ouroboros.Network.Testing.Utils.Delay
instance GHC.Num.Num Ouroboros.Network.Testing.Utils.SmallDelay
instance GHC.Classes.Ord Ouroboros.Network.Testing.Utils.SmallDelay
instance GHC.Classes.Eq Ouroboros.Network.Testing.Utils.SmallDelay
instance GHC.Show.Show Ouroboros.Network.Testing.Utils.SmallDelay
instance GHC.Base.Functor (Ouroboros.Network.Testing.Utils.WithName name)
instance (GHC.Show.Show name, GHC.Show.Show event) => GHC.Show.Show (Ouroboros.Network.Testing.Utils.WithName name event)
instance GHC.Base.Functor Ouroboros.Network.Testing.Utils.WithTime
instance GHC.Show.Show event => GHC.Show.Show (Ouroboros.Network.Testing.Utils.WithTime event)
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Utils.SmallDelay
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Utils.Delay

module Ouroboros.Network.Testing.Data.Script
newtype Script a
Script :: NonEmpty a -> Script a

-- | Non-empty (and non-strict) list type.
data NonEmpty a
(:|) :: a -> [a] -> NonEmpty a
infixr 5 :|
scriptHead :: Script a -> a
singletonScript :: a -> Script a
initScript :: MonadSTM m => Script a -> STM m (TVar m (Script a))
stepScript :: MonadSTM m => TVar m (Script a) -> m a
stepScriptSTM :: MonadSTM m => TVar m (Script a) -> STM m a
initScript' :: MonadSTM m => Script a -> m (TVar m (Script a))
stepScript' :: MonadSTM m => TVar m (Script a) -> m a
stepScriptSTM' :: MonadSTM m => TVar m (Script a) -> STM m a
arbitraryScriptOf :: Int -> Gen a -> Gen (Script a)
prop_shrink_Script :: Fixed (Script Int) -> Property
data ScriptDelay
NoDelay :: ScriptDelay
ShortDelay :: ScriptDelay
LongDelay :: ScriptDelay
type TimedScript a = Script (a, ScriptDelay)
playTimedScript :: (MonadAsync m, MonadTimer m) => Tracer m a -> TimedScript a -> m (TVar m a)

-- | A pick script is used to interpret the
--   <tt>policyPickKnownPeersForGossip</tt> and the
--   <tt>policyPickColdPeersToForget</tt>. It selects elements from the
--   given choices by their index (modulo the number of choices). This
--   representation was chosen because it allows easy shrinking.
type PickScript peeraddr = Script (PickMembers peeraddr)
data PickMembers peeraddr
PickFirst :: PickMembers peeraddr
PickAll :: PickMembers peeraddr
PickSome :: Set peeraddr -> PickMembers peeraddr
arbitraryPickScript :: Gen (Set peeraddr) -> Gen (PickScript peeraddr)
interpretPickScript :: (MonadSTM m, Ord peeraddr) => TVar m (PickScript peeraddr) -> Set peeraddr -> Int -> STM m (Set peeraddr)
instance Data.Traversable.Traversable Ouroboros.Network.Testing.Data.Script.Script
instance Data.Foldable.Foldable Ouroboros.Network.Testing.Data.Script.Script
instance GHC.Base.Functor Ouroboros.Network.Testing.Data.Script.Script
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Testing.Data.Script.Script a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Ouroboros.Network.Testing.Data.Script.Script a)
instance GHC.Show.Show Ouroboros.Network.Testing.Data.Script.ScriptDelay
instance GHC.Classes.Eq Ouroboros.Network.Testing.Data.Script.ScriptDelay
instance GHC.Show.Show peeraddr => GHC.Show.Show (Ouroboros.Network.Testing.Data.Script.PickMembers peeraddr)
instance GHC.Classes.Eq peeraddr => GHC.Classes.Eq (Ouroboros.Network.Testing.Data.Script.PickMembers peeraddr)
instance (Test.QuickCheck.Arbitrary.Arbitrary peeraddr, GHC.Classes.Ord peeraddr) => Test.QuickCheck.Arbitrary.Arbitrary (Ouroboros.Network.Testing.Data.Script.PickMembers peeraddr)
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Data.Script.ScriptDelay
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Ouroboros.Network.Testing.Data.Script.Script a)

module Ouroboros.Network.Testing.Data.AbsBearerInfo
newtype AbsBearerInfoScript
AbsBearerInfoScript :: Script AbsBearerInfo -> AbsBearerInfoScript
[unBIScript] :: AbsBearerInfoScript -> Script AbsBearerInfo
canFail :: AbsBearerInfo -> Bool
newtype NonFailingAbsBearerInfoScript
NonFailingAbsBearerInfoScript :: Script AbsBearerInfo -> NonFailingAbsBearerInfoScript
[unNFBIScript] :: NonFailingAbsBearerInfoScript -> Script AbsBearerInfo
data AbsDelay
SmallDelay :: AbsDelay
NormalDelay :: AbsDelay
LargeDelay :: AbsDelay
delay :: AbsDelay -> DiffTime
data AbsSpeed
SlowSpeed :: AbsSpeed
NormalSpeed :: AbsSpeed
FastSpeed :: AbsSpeed
speedToRational :: AbsSpeed -> Rational
delayAtSpeed :: AbsSpeed -> Size -> DiffTime
data AbsSDUSize
SmallSDU :: AbsSDUSize
NormalSDU :: AbsSDUSize
LargeSDU :: AbsSDUSize
toSduSize :: AbsSDUSize -> SDUSize
data AbsAttenuation
NoAttenuation :: AbsSpeed -> AbsAttenuation
SpeedAttenuation :: AbsSpeed -> Time -> DiffTime -> AbsAttenuation
ErrorInterval :: AbsSpeed -> Time -> DiffTime -> AbsAttenuation
attenuation :: AbsAttenuation -> Time -> Size -> (DiffTime, SuccessOrFailure)
absNoAttenuation :: AbsBearerInfo
data AbsBearerInfo
AbsBearerInfo :: !AbsDelay -> !AbsAttenuation -> !AbsAttenuation -> !Maybe Int -> !Maybe Int -> !Maybe (AbsDelay, AbsIOErrType) -> !AbsSDUSize -> AbsBearerInfo
[abiConnectionDelay] :: AbsBearerInfo -> !AbsDelay
[abiInboundAttenuation] :: AbsBearerInfo -> !AbsAttenuation
[abiOutboundAttenuation] :: AbsBearerInfo -> !AbsAttenuation
[abiInboundWriteFailure] :: AbsBearerInfo -> !Maybe Int
[abiOutboundWriteFailure] :: AbsBearerInfo -> !Maybe Int
[abiAcceptFailure] :: AbsBearerInfo -> !Maybe (AbsDelay, AbsIOErrType)
[abiSDUSize] :: AbsBearerInfo -> !AbsSDUSize
toNonFailingAbsBearerInfoScript :: AbsBearerInfoScript -> NonFailingAbsBearerInfoScript
data AbsIOErrType
AbsIOErrConnectionAborted :: AbsIOErrType
AbsIOErrResourceExhausted :: AbsIOErrType
instance GHC.Show.Show Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsDelay
instance GHC.Classes.Ord Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsDelay
instance GHC.Classes.Eq Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsDelay
instance GHC.Show.Show Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsSpeed
instance GHC.Classes.Ord Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsSpeed
instance GHC.Classes.Eq Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsSpeed
instance GHC.Show.Show Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsSDUSize
instance GHC.Classes.Eq Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsSDUSize
instance GHC.Show.Show Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsAttenuation
instance GHC.Classes.Eq Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsAttenuation
instance GHC.Show.Show Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsIOErrType
instance GHC.Classes.Eq Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsIOErrType
instance GHC.Show.Show Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsBearerInfo
instance GHC.Classes.Eq Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsBearerInfo
instance GHC.Classes.Eq Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsBearerInfoScript
instance GHC.Show.Show Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsBearerInfoScript
instance GHC.Classes.Eq Ouroboros.Network.Testing.Data.AbsBearerInfo.NonFailingAbsBearerInfoScript
instance GHC.Show.Show Ouroboros.Network.Testing.Data.AbsBearerInfo.NonFailingAbsBearerInfoScript
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Data.AbsBearerInfo.NonFailingAbsBearerInfoScript
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsBearerInfoScript
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsBearerInfo
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsIOErrType
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsAttenuation
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsSDUSize
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsSpeed
instance Test.QuickCheck.Arbitrary.Arbitrary Ouroboros.Network.Testing.Data.AbsBearerInfo.AbsDelay
