-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Random access lists
--   
--   This package provides ordinary random access list, <a>RAList</a>, and
--   also a length indexed variant, <a>RAVec</a>.
--   
--   The data structure allows fast cons-operation (like ordinary list) but
--   also fast random access (like non-functional arrays).
--   
--   For <tt>lens</tt> or <tt>optics</tt> support see <a>ral-lens</a> and
--   <a>ral-optics</a> packages respectively.
--   
--   <h3>Similar packages</h3>
--   
--   This packages don't provide length-indexed variant, and their
--   <a>RAList</a> has opaque structure.
--   
--   <ul>
--   <li><a>https://hackage.haskell.org/package/ralist</a></li>
--   <li><a>https://hackage.haskell.org/package/random-access-list</a></li>
--   </ul>
@package ral
@version 0.1

module Data.RAList.Tree

-- | A <a>Leaf</a> is isomorphic to <tt>Identity</tt>, but we reimplement
--   it here to have domain specific type. The short constructor name is a
--   bonus.
newtype Leaf a
Lf :: a -> Leaf a

-- | <a>Node</a> is a product of two <tt>f</tt>. This way we can form a
--   perfect binary tree.
data Node f a
Nd :: f a -> f a -> Node f a

-- | Direction in <a>Node</a>.
data Dir a
L :: a -> Dir a
R :: a -> Dir a


-- | Non-empty random access list.
--   
--   This module is designed to imported qualifed.
module Data.RAList.NonEmpty

-- | Non-empty random access list.
newtype NERAList a
NE :: NERAList' Leaf a -> NERAList a

-- | Non-empty random access list, underlying representation.
--   
--   The structure doesn't need to be hidden, as polymorphic recursion of
--   <a>Node</a>s starting from <a>Leaf</a> keeps the <a>NERAList</a>
--   values well-formed.
data NERAList' f a
Last :: f a -> NERAList' f a
Cons0 :: NERAList' (Node f) a -> NERAList' f a
Cons1 :: f a -> NERAList' (Node f) a -> NERAList' f a
explicitShow :: Show a => NERAList a -> String
explicitShowsPrec :: Show a => Int -> NERAList a -> ShowS

-- | Single element <a>NERAList</a>.
singleton :: a -> NERAList a

-- | <a>cons</a> for non-empty rals.
cons :: a -> NERAList a -> NERAList a

-- | List index.
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) ! 0
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) ! 5
--   'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) ! 6
--   *** Exception: array index out of range: NERAList
--   ...
--   </pre>
(!) :: NERAList a -> Int -> a

-- | safe list index.
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) !? 0
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) !? 5
--   Just 'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f']) !? 6
--   Nothing
--   </pre>
(!?) :: NERAList a -> Int -> Maybe a

-- | First value, head of the list.
--   
--   <pre>
--   &gt;&gt;&gt; head $ fromNonEmpty $ 'a' :| ['b'..'f']
--   'a'
--   </pre>
head :: NERAList a -> a

-- | Last value of the list
--   
--   <pre>
--   &gt;&gt;&gt; last $ fromNonEmpty $  'a' :| ['b'..'f']
--   'f'
--   </pre>
last :: NERAList a -> a

-- | <pre>
--   &gt;&gt;&gt; uncons $ fromNonEmpty $ 'a' :| "bcdef"
--   ('a',fromList "bcdef")
--   </pre>
uncons :: NERAList a -> (a, RAList a)

-- | Tail of non-empty list can be empty.
--   
--   <pre>
--   &gt;&gt;&gt; tail $ fromNonEmpty $ 'a' :| "bcdef"
--   fromList "bcdef"
--   </pre>
tail :: NERAList a -> RAList a
length :: NERAList a -> Int
null :: NERAList a -> Bool
toNonEmpty :: NERAList a -> NonEmpty a

-- | <pre>
--   &gt;&gt;&gt; fromNonEmpty ('a' :| ['b'..'f'])
--   fromNonEmpty ('a' :| "bcdef")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow (fromNonEmpty ('a' :| ['b'..'f']))
--   "NE (Cons0 (Cons1 (Nd (Lf 'a') (Lf 'b')) (Last (Nd (Nd (Lf 'c') (Lf 'd')) (Nd (Lf 'e') (Lf 'f'))))))"
--   </pre>
fromNonEmpty :: NonEmpty a -> NERAList a
foldMap1 :: forall a s. Semigroup s => (a -> s) -> NERAList a -> s
foldr1Map :: (a -> b -> b) -> (a -> b) -> NERAList a -> b
ifoldMap :: Monoid m => (Int -> a -> m) -> NERAList a -> m

-- | <pre>
--   &gt;&gt;&gt; import Data.Semigroup (Min (..))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMap1 (\_ x -&gt; Min x) $ fromNonEmpty $ 5 :| [3,1,2,4]
--   Min {getMin = 1}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMap1 (\i x -&gt; Min (i + x)) $ fromNonEmpty $ 5 :| [3,1,2,4]
--   Min {getMin = 3}
--   </pre>
ifoldMap1 :: forall a s. Semigroup s => (Int -> a -> s) -> NERAList a -> s
ifoldr1Map :: forall a b. (Int -> a -> b -> b) -> (Int -> a -> b) -> NERAList a -> b

-- | Adjust a value in the list.
--   
--   <pre>
--   &gt;&gt;&gt; adjust 3 toUpper $ fromNonEmpty $ 'a' :| "bcdef"
--   fromNonEmpty ('a' :| "bcDef")
--   </pre>
--   
--   If index is out of bounds, the list is returned unmodified.
--   
--   <pre>
--   &gt;&gt;&gt; adjust 10 toUpper $ fromNonEmpty $ 'a' :| "bcdef"
--   fromNonEmpty ('a' :| "bcdef")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; adjust (-1) toUpper $ fromNonEmpty $ 'a' :| "bcdef"
--   fromNonEmpty ('a' :| "bcdef")
--   </pre>
adjust :: forall a. Int -> (a -> a) -> NERAList a -> NERAList a

-- | <pre>
--   &gt;&gt;&gt; map toUpper (fromNonEmpty ('a' :| ['b'..'f']))
--   fromNonEmpty ('A' :| "BCDEF")
--   </pre>
map :: (a -> b) -> NERAList a -> NERAList b

-- | <pre>
--   &gt;&gt;&gt; imap (,) (fromNonEmpty ('a' :| ['b'..'f']))
--   fromNonEmpty ((0,'a') :| [(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')])
--   </pre>
imap :: (Int -> a -> b) -> NERAList a -> NERAList b
itraverse :: forall f a b. Applicative f => (Int -> a -> f b) -> NERAList a -> f (NERAList b)
itraverse1 :: forall f a b. Apply f => (Int -> a -> f b) -> NERAList a -> f (NERAList b)


-- | Random access list.
--   
--   This module is designed to imported qualifed.
module Data.RAList

-- | Random access list.
data RAList a
Empty :: RAList a
NonEmpty :: NERAList a -> RAList a
explicitShow :: Show a => RAList a -> String
explicitShowsPrec :: Show a => Int -> RAList a -> ShowS

-- | Empty <a>RAList</a>.
--   
--   <pre>
--   &gt;&gt;&gt; empty :: RAList Int
--   fromList []
--   </pre>
empty :: RAList a

-- | Single element <a>RAList</a>.
singleton :: a -> RAList a

-- | <a>cons</a> for non-empty rals.
cons :: a -> RAList a -> RAList a
(!) :: RAList a -> Int -> a

-- | safe list index.
--   
--   <pre>
--   &gt;&gt;&gt; fromList ['a'..'f'] !? 0
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList ['a'..'f'] !? 5
--   Just 'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList ['a'..'f'] !? 6
--   Nothing
--   </pre>
(!?) :: RAList a -> Int -> Maybe a

-- | <pre>
--   &gt;&gt;&gt; uncons $ fromList []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons $ fromList "abcdef"
--   Just ('a',fromList "bcdef")
--   </pre>
uncons :: RAList a -> Maybe (a, RAList a)
length :: RAList a -> Int
null :: RAList a -> Bool
toList :: RAList a -> [a]

-- | <pre>
--   &gt;&gt;&gt; fromList ['a' .. 'f']
--   fromList "abcdef"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; explicitShow $ fromList ['a' .. 'f']
--   "NonEmpty (NE (Cons0 (Cons1 (Nd (Lf 'a') (Lf 'b')) (Last (Nd (Nd (Lf 'c') (Lf 'd')) (Nd (Lf 'e') (Lf 'f')))))))"
--   </pre>
fromList :: [a] -> RAList a
ifoldMap :: Monoid m => (Int -> a -> m) -> RAList a -> m

-- | Adjust a value in the list.
--   
--   <pre>
--   &gt;&gt;&gt; adjust 3 toUpper $ fromList "bcdef"
--   fromList "bcdEf"
--   </pre>
--   
--   If index is out of bounds, the list is returned unmodified.
--   
--   <pre>
--   &gt;&gt;&gt; adjust 10 toUpper $ fromList "bcdef"
--   fromList "bcdef"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; adjust (-1) toUpper $ fromList "bcdef"
--   fromList "bcdef"
--   </pre>
adjust :: forall a. Int -> (a -> a) -> RAList a -> RAList a

-- | <pre>
--   &gt;&gt;&gt; map toUpper (fromList ['a'..'f'])
--   fromList "ABCDEF"
--   </pre>
map :: (a -> b) -> RAList a -> RAList b

-- | <pre>
--   &gt;&gt;&gt; imap (,) $ fromList ['a' .. 'f']
--   fromList [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')]
--   </pre>
imap :: (Int -> a -> b) -> RAList a -> RAList b
itraverse :: forall f a b. Applicative f => (Int -> a -> f b) -> RAList a -> f (RAList b)


-- | Depth indexed perfect binary tree.
module Data.RAVec.Tree

-- | Perfectly balanced binary tree of depth <tt>n</tt>, with <tt>2 ^
--   n</tt> elements.
data Tree (n :: Nat) a
[Leaf] :: a -> Tree 'Z a
[Node] :: Tree n a -> Tree n a -> Tree ('S n) a

-- | <a>Tree</a> of zero depth, with single element.
--   
--   <pre>
--   &gt;&gt;&gt; singleton True
--   Leaf True
--   </pre>
singleton :: a -> Tree 'Z a

-- | Convert <a>Tree</a> to list.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ Node (Node (Leaf 'a') (Leaf 'b')) (Node (Leaf 'c') (Leaf 'd'))
--   "abcd"
--   </pre>
toList :: Tree n a -> [a]

-- | Indexing.
(!) :: Tree n a -> Wrd n -> a
tabulate :: forall n a. SNatI n => (Wrd n -> a) -> Tree n a
leftmost :: Tree n a -> a
rightmost :: Tree n a -> a
foldMap :: Monoid m => (a -> m) -> Tree n a -> m
foldMap1 :: Semigroup s => (a -> s) -> Tree n a -> s
ifoldMap :: Monoid m => (Wrd n -> a -> m) -> Tree n a -> m
ifoldMap1 :: Semigroup s => (Wrd n -> a -> s) -> Tree n a -> s

-- | <pre>
--   &gt;&gt;&gt; foldr (:) [] $ Node (Leaf True) (Leaf False)
--   [True,False]
--   </pre>
foldr :: (a -> b -> b) -> b -> Tree n a -> b
ifoldr :: (Wrd n -> a -> b -> b) -> b -> Tree n a -> b
foldr1Map :: (a -> b -> b) -> (a -> b) -> Tree n a -> b
ifoldr1Map :: (Wrd n -> a -> b -> b) -> (Wrd n -> a -> b) -> Tree n a -> b

-- | <pre>
--   &gt;&gt;&gt; foldl (flip (:)) [] $ Node (Leaf True) (Leaf False)
--   [False,True]
--   </pre>
foldl :: (b -> a -> b) -> b -> Tree n a -> b
ifoldl :: (Wrd n -> b -> a -> b) -> b -> Tree n a -> b

-- | <pre>
--   &gt;&gt;&gt; length (universe :: Tree N.Nat3 (Wrd N.Nat3))
--   8
--   </pre>
length :: Tree n a -> Int

-- | <pre>
--   &gt;&gt;&gt; map not $ Node (Leaf True) (Leaf False)
--   Node (Leaf False) (Leaf True)
--   </pre>
map :: (a -> b) -> Tree n a -> Tree n b

-- | <pre>
--   &gt;&gt;&gt; imap (,) $ Node (Leaf True) (Leaf False)
--   Node (Leaf (0b0,True)) (Leaf (0b1,False))
--   </pre>
imap :: (Wrd n -> a -> b) -> Tree n a -> Tree n b
traverse :: Applicative f => (a -> f b) -> Tree n a -> f (Tree n b)
itraverse :: Applicative f => (Wrd n -> a -> f b) -> Tree n a -> f (Tree n b)
traverse1 :: Apply f => (a -> f b) -> Tree n a -> f (Tree n b)
itraverse1 :: Apply f => (Wrd n -> a -> f b) -> Tree n a -> f (Tree n b)

-- | Zip two <tt>Vec</tt>s with a function.
zipWith :: (a -> b -> c) -> Tree n a -> Tree n b -> Tree n c

-- | Zip two <a>Tree</a>s. with a function that also takes the elements'
--   indices.
izipWith :: (Wrd n -> a -> b -> c) -> Tree n a -> Tree n b -> Tree n c

-- | Repeat a value.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 'x' :: Tree N.Nat2 Char
--   Node (Node (Leaf 'x') (Leaf 'x')) (Node (Leaf 'x') (Leaf 'x'))
--   </pre>
repeat :: SNatI n => a -> Tree n a

-- | Get all <tt><tt>Vec</tt> n <a>Bool</a></tt> indices in <tt><a>Tree</a>
--   n</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; universe :: Tree N.Nat2 (Wrd N.Nat2)
--   Node (Node (Leaf 0b00) (Leaf 0b01)) (Node (Leaf 0b10) (Leaf 0b11))
--   </pre>
universe :: SNatI n => Tree n (Wrd n)
liftArbitrary :: forall n a. SNatI n => Gen a -> Gen (Tree n a)
liftShrink :: forall n a. (a -> [a]) -> Tree n a -> [Tree n a]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.RAVec.Tree.Tree n a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.RAVec.Tree.Tree n a)
instance GHC.Show.Show a => GHC.Show.Show (Data.RAVec.Tree.Tree n a)
instance GHC.Base.Functor (Data.RAVec.Tree.Tree n)
instance Data.Foldable.Foldable (Data.RAVec.Tree.Tree n)
instance Data.Traversable.Traversable (Data.RAVec.Tree.Tree n)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.RAVec.Tree.Tree n)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.RAVec.Tree.Tree n)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.RAVec.Tree.Tree n a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.RAVec.Tree.Tree n a)
instance Data.Type.Nat.SNatI n => GHC.Base.Applicative (Data.RAVec.Tree.Tree n)
instance Data.Type.Nat.SNatI n => Data.Distributive.Distributive (Data.RAVec.Tree.Tree n)
instance Data.Type.Nat.SNatI n => Data.Functor.Rep.Representable (Data.RAVec.Tree.Tree n)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.RAVec.Tree.Tree n a)
instance Data.Functor.Bind.Class.Apply (Data.RAVec.Tree.Tree n)
instance Data.Type.Nat.SNatI n => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.RAVec.Tree.Tree n)
instance (Data.Type.Nat.SNatI n, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.RAVec.Tree.Tree n a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.RAVec.Tree.Tree n a)
instance (Data.Type.Nat.SNatI n, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.RAVec.Tree.Tree n a)


-- | Non-empty length-indexed random access list.
module Data.RAVec.NonEmpty

-- | Non-empty random access list.
newtype NERAVec (b :: BinP) a
NE :: NERAVec' 'Z b a -> NERAVec (b :: BinP) a

-- | Non-empty random access list, undelying representation.
data NERAVec' (n :: Nat) (b :: BinP) a
[Last] :: Tree n a -> NERAVec' n 'BE a
[Cons0] :: NERAVec' ('S n) b a -> NERAVec' n ('B0 b) a
[Cons1] :: Tree n a -> NERAVec' ('S n) b a -> NERAVec' n ('B1 b) a
singleton :: forall a. a -> NERAVec BinP1 a
singleton' :: a -> NERAVec' 'Z BinP1 a

-- | <a>cons</a> for non-empty rals.
cons :: forall a b. a -> NERAVec b a -> NERAVec (Succ b) a
consTree :: Tree n a -> NERAVec' n b a -> NERAVec' n (Succ b) a

-- | <a>withCons</a> for non-empty rals.
withCons :: SBinPI b => a -> NERAVec b a -> (SBinPI (Succ b) => NERAVec (Succ b) a -> r) -> r
withConsTree :: SBinP b -> Tree n a -> NERAVec' n b a -> (SBinPI (Succ b) => NERAVec' n (Succ b) a -> r) -> r
toList :: NERAVec b a -> [a]
toList' :: NERAVec' n b a -> [a]
toNonEmpty :: NERAVec b a -> NonEmpty a
toNonEmpty' :: NERAVec' n b a -> NonEmpty a
reifyNonEmpty :: NonEmpty a -> (forall b. SBinPI b => NERAVec b a -> r) -> r
reifyNonEmpty' :: forall a r. NonEmpty a -> (forall b. SBinPI b => NERAVec' 'Z b a -> r) -> r
(!) :: NERAVec b a -> PosP b -> a
index' :: NERAVec' n b a -> PosP' n b -> a
tabulate :: SBinPI b => (PosP b -> a) -> NERAVec b a
tabulate' :: forall b n a. (SBinPI b, SNatI n) => (PosP' n b -> a) -> NERAVec' n b a
unsingleton :: NERAVec 'BE a -> a
head :: NERAVec b a -> a
head' :: NERAVec' n b a -> a
last :: NERAVec b a -> a
last' :: NERAVec' n b a -> a
foldMap :: Monoid m => (a -> m) -> NERAVec b a -> m
foldMap' :: Monoid m => (a -> m) -> NERAVec' n b a -> m
foldMap1 :: Semigroup m => (a -> m) -> NERAVec b a -> m
foldMap1' :: Semigroup m => (a -> m) -> NERAVec' n b a -> m
ifoldMap :: Monoid m => (PosP b -> a -> m) -> NERAVec b a -> m
ifoldMap' :: Monoid m => (PosP' n b -> a -> m) -> NERAVec' n b a -> m
ifoldMap1 :: Semigroup m => (PosP b -> a -> m) -> NERAVec b a -> m
ifoldMap1' :: Semigroup m => (PosP' n b -> a -> m) -> NERAVec' n b a -> m
foldr :: (a -> b -> b) -> b -> NERAVec m a -> b
foldr' :: (a -> b -> b) -> b -> NERAVec' n m a -> b
ifoldr :: (PosP m -> a -> b -> b) -> b -> NERAVec m a -> b
ifoldr' :: (PosP' n m -> a -> b -> b) -> b -> NERAVec' n m a -> b
foldr1Map :: (a -> b -> b) -> (a -> b) -> NERAVec m a -> b
foldr1Map' :: (a -> b -> b) -> (a -> b) -> NERAVec' n m a -> b
ifoldr1Map :: (PosP m -> a -> b -> b) -> (PosP m -> a -> b) -> NERAVec m a -> b
ifoldr1Map' :: (PosP' n m -> a -> b -> b) -> (PosP' n m -> a -> b) -> NERAVec' n m a -> b
map :: (a -> b) -> NERAVec m a -> NERAVec m b
map' :: (a -> b) -> NERAVec' n m a -> NERAVec' n m b
imap :: (PosP m -> a -> b) -> NERAVec m a -> NERAVec m b
imap' :: (PosP' n m -> a -> b) -> NERAVec' n m a -> NERAVec' n m b
traverse :: Applicative f => (a -> f b) -> NERAVec m a -> f (NERAVec m b)
traverse' :: Applicative f => (a -> f b) -> NERAVec' n m a -> f (NERAVec' n m b)
itraverse :: Applicative f => (PosP m -> a -> f b) -> NERAVec m a -> f (NERAVec m b)
itraverse' :: Applicative f => (PosP' n m -> a -> f b) -> NERAVec' n m a -> f (NERAVec' n m b)
traverse1 :: Apply f => (a -> f b) -> NERAVec m a -> f (NERAVec m b)
traverse1' :: Apply f => (a -> f b) -> NERAVec' n m a -> f (NERAVec' n m b)
itraverse1 :: Apply f => (PosP m -> a -> f b) -> NERAVec m a -> f (NERAVec m b)
itraverse1' :: Apply f => (PosP' n m -> a -> f b) -> NERAVec' n m a -> f (NERAVec' n m b)
zipWith :: (a -> b -> c) -> NERAVec m a -> NERAVec m b -> NERAVec m c

-- | Zip two <a>NERAVec'</a>s with a function.
zipWith' :: (a -> b -> c) -> NERAVec' n m a -> NERAVec' n m b -> NERAVec' n m c
izipWith :: (PosP m -> a -> b -> c) -> NERAVec m a -> NERAVec m b -> NERAVec m c

-- | Zip two <a>NERAVec'</a>s with a function which also takes <a>PosP'</a>
--   index.
izipWith' :: (PosP' n m -> a -> b -> c) -> NERAVec' n m a -> NERAVec' n m b -> NERAVec' n m c
repeat :: SBinPI b => a -> NERAVec b a
repeat' :: forall b n a. (SNatI n, SBinPI b) => a -> NERAVec' n b a
universe :: forall b. SBinPI b => NERAVec b (PosP b)
universe' :: forall n b. (SNatI n, SBinPI b) => NERAVec' n b (PosP' n b)
liftArbitrary :: SBinPI b => Gen a -> Gen (NERAVec b a)
liftArbitrary' :: forall b n a. (SBinPI b, SNatI n) => Gen a -> Gen (NERAVec' n b a)
liftShrink :: (a -> [a]) -> NERAVec b a -> [NERAVec b a]
liftShrink' :: forall b n a. (a -> [a]) -> NERAVec' n b a -> [NERAVec' n b a]
instance GHC.Show.Show a => GHC.Show.Show (Data.RAVec.NonEmpty.NERAVec b a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.RAVec.NonEmpty.NERAVec b a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.RAVec.NonEmpty.NERAVec b a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.RAVec.NonEmpty.NERAVec' n b a)
instance GHC.Show.Show a => GHC.Show.Show (Data.RAVec.NonEmpty.NERAVec' n b a)
instance GHC.Base.Functor (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Foldable.Foldable (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Traversable.Traversable (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.RAVec.NonEmpty.NERAVec b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.RAVec.NonEmpty.NERAVec b a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.RAVec.NonEmpty.NERAVec b a)
instance Data.Type.BinP.SBinPI b => GHC.Base.Applicative (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Type.BinP.SBinPI b => Data.Distributive.Distributive (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Type.BinP.SBinPI b => Data.Functor.Rep.Representable (Data.RAVec.NonEmpty.NERAVec b)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.RAVec.NonEmpty.NERAVec b a)
instance (GHC.Base.Monoid a, Data.Type.BinP.SBinPI b) => GHC.Base.Monoid (Data.RAVec.NonEmpty.NERAVec b a)
instance Data.Functor.Bind.Class.Apply (Data.RAVec.NonEmpty.NERAVec b)
instance Data.Type.BinP.SBinPI b => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.RAVec.NonEmpty.NERAVec b)
instance (Data.Type.BinP.SBinPI b, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.RAVec.NonEmpty.NERAVec b a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.RAVec.NonEmpty.NERAVec b a)
instance (Data.Type.BinP.SBinPI b, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.RAVec.NonEmpty.NERAVec b a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.RAVec.NonEmpty.NERAVec' n b a)
instance GHC.Base.Functor (Data.RAVec.NonEmpty.NERAVec' n b)
instance Data.Foldable.Foldable (Data.RAVec.NonEmpty.NERAVec' n b)
instance Data.Traversable.Traversable (Data.RAVec.NonEmpty.NERAVec' n b)
instance Data.Semigroup.Foldable.Class.Foldable1 (Data.RAVec.NonEmpty.NERAVec' n b)
instance Data.Semigroup.Traversable.Class.Traversable1 (Data.RAVec.NonEmpty.NERAVec' n b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.RAVec.NonEmpty.NERAVec' n b a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.RAVec.NonEmpty.NERAVec' n b a)
instance (Data.Type.BinP.SBinPI b, Data.Type.Nat.SNatI n) => GHC.Base.Applicative (Data.RAVec.NonEmpty.NERAVec' n b)
instance (Data.Type.BinP.SBinPI b, Data.Type.Nat.SNatI n) => Data.Distributive.Distributive (Data.RAVec.NonEmpty.NERAVec' n b)
instance (Data.Type.BinP.SBinPI b, Data.Type.Nat.SNatI n) => Data.Functor.Rep.Representable (Data.RAVec.NonEmpty.NERAVec' n b)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.RAVec.NonEmpty.NERAVec' n b a)
instance (GHC.Base.Monoid a, Data.Type.BinP.SBinPI b, Data.Type.Nat.SNatI n) => GHC.Base.Monoid (Data.RAVec.NonEmpty.NERAVec' n b a)
instance Data.Functor.Bind.Class.Apply (Data.RAVec.NonEmpty.NERAVec' n b)
instance (Data.Type.BinP.SBinPI b, Data.Type.Nat.SNatI n) => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.RAVec.NonEmpty.NERAVec' n b)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.RAVec.NonEmpty.NERAVec' n b a)
instance (Data.Type.Nat.SNatI n, Data.Type.BinP.SBinPI b, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.RAVec.NonEmpty.NERAVec' n b a)


-- | Length-indexed random access list.
--   
--   See
--   <a>http://www.staff.science.uu.nl/~swier004/publications/2019-jfp-submission.pdf</a>
module Data.RAVec

-- | Length indexed random access lists.
data RAVec (b :: Bin) a
[Empty] :: RAVec 'BZ a
[NonEmpty] :: NERAVec b a -> RAVec ('BP b) a
empty :: RAVec Bin0 a
singleton :: a -> RAVec Bin1 a

-- | Cons an element in front of <a>RAVec</a>.
--   
--   <pre>
--   &gt;&gt;&gt; reifyList "xyz" (print . toList . cons 'a')
--   "axyz"
--   </pre>
cons :: a -> RAVec b a -> RAVec (Succ b) a

-- | Variant of <a>cons</a> which computes the <a>SBinI</a> dictionary at
--   the same time.
withCons :: SBinI b => a -> RAVec b a -> (SBinPI (Succ' b) => RAVec (Succ b) a -> r) -> r

-- | The first element of a non-empty <a>RAVec</a>.
--   
--   <pre>
--   &gt;&gt;&gt; reifyNonEmpty ('x' :| "yz") head
--   'x'
--   </pre>
head :: RAVec ('BP b) a -> a

-- | The last element of a non-empty <a>RAVec</a>.
--   
--   <pre>
--   &gt;&gt;&gt; reifyNonEmpty ('x' :| "yz") last
--   'z'
--   </pre>
last :: RAVec ('BP b) a -> a
toList :: RAVec b a -> [a]
toNonEmpty :: RAVec ('BP b) a -> NonEmpty a

-- | Convert a list <tt>[a]</tt> to <tt><a>RAVec</a> b a</tt>. Returns
--   <a>Nothing</a> if lengths don't match.
--   
--   <pre>
--   &gt;&gt;&gt; fromList "foo" :: Maybe (RAVec B.Bin3 Char)
--   Just (NonEmpty (NE (Cons1 (Leaf 'f') (Last (Node (Leaf 'o') (Leaf 'o'))))))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList "quux" :: Maybe (RAVec B.Bin3 Char)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList "xy" :: Maybe (RAVec B.Bin3 Char)
--   Nothing
--   </pre>
fromList :: forall b a. SBinI b => [a] -> Maybe (RAVec b a)
reifyNonEmpty :: NonEmpty a -> (forall b. SBinPI b => RAVec ('BP b) a -> r) -> r

-- | Indexing.
--   
--   <pre>
--   &gt;&gt;&gt; let ral :: RAVec B.Bin4 Char; Just ral = fromList "abcd"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ral ! minBound
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ral ! maxBound
--   'd'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ral ! pop top
--   'b'
--   </pre>
(!) :: RAVec b a -> Pos b -> a
tabulate :: forall b a. SBinI b => (Pos b -> a) -> RAVec b a
foldMap :: Monoid m => (a -> m) -> RAVec n a -> m
foldMap1 :: Semigroup m => (a -> m) -> RAVec ('BP b) a -> m
ifoldMap :: Monoid m => (Pos b -> a -> m) -> RAVec b a -> m
ifoldMap1 :: Semigroup m => (Pos ('BP b) -> a -> m) -> RAVec ('BP b) a -> m
foldr :: (a -> b -> b) -> b -> RAVec n a -> b
ifoldr :: (Pos n -> a -> b -> b) -> b -> RAVec n a -> b
map :: (a -> b) -> RAVec n a -> RAVec n b
imap :: (Pos n -> a -> b) -> RAVec n a -> RAVec n b
traverse :: Applicative f => (a -> f b) -> RAVec n a -> f (RAVec n b)
itraverse :: Applicative f => (Pos n -> a -> f b) -> RAVec n a -> f (RAVec n b)
traverse1 :: Apply f => (a -> f b) -> RAVec ('BP n) a -> f (RAVec ('BP n) b)
itraverse1 :: Apply f => (Pos ('BP n) -> a -> f b) -> RAVec ('BP n) a -> f (RAVec ('BP n) b)

-- | Zip two <a>RAVec</a>s with a function.
zipWith :: (a -> b -> c) -> RAVec n a -> RAVec n b -> RAVec n c

-- | Zip two <a>RAVec</a>s with a function which also takes <a>Pos</a>
--   index.
izipWith :: (Pos n -> a -> b -> c) -> RAVec n a -> RAVec n b -> RAVec n c

-- | <pre>
--   &gt;&gt;&gt; universe :: RAVec B.Bin2 (Pos B.Bin2)
--   NonEmpty (NE (Cons0 (Last (Node (Leaf 0) (Leaf 1)))))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let u = universe :: RAVec B.Bin3 (Pos B.Bin3)
--   
--   &gt;&gt;&gt; u
--   NonEmpty (NE (Cons1 (Leaf 0) (Last (Node (Leaf 1) (Leaf 2)))))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; P.explicitShow $ u ! Pos (PosP (Here WE))
--   "Pos (PosP (Here WE))"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let u' = universe :: RAVec B.Bin5 (Pos B.Bin5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList u' == sort (toList u')
--   True
--   </pre>
universe :: forall b. SBinI b => RAVec b (Pos b)

-- | Repeat a value.
--   
--   <pre>
--   &gt;&gt;&gt; repeat 'x' :: RAVec B.Bin5 Char
--   NonEmpty (NE (Cons1 (Leaf 'x') (Cons0 (Last (Node (Node (Leaf 'x') (Leaf 'x')) (Node (Leaf 'x') (Leaf 'x')))))))
--   </pre>
repeat :: forall b a. SBinI b => a -> RAVec b a
liftArbitrary :: SBinI b => Gen a -> Gen (RAVec b a)
liftShrink :: (a -> [a]) -> RAVec b a -> [RAVec b a]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.RAVec.RAVec b a)
instance GHC.Show.Show a => GHC.Show.Show (Data.RAVec.RAVec b a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.RAVec.RAVec b a)
instance GHC.Base.Functor (Data.RAVec.RAVec b)
instance Data.Foldable.Foldable (Data.RAVec.RAVec b)
instance Data.Traversable.Traversable (Data.RAVec.RAVec b)
instance ((b :: Data.Bin.Bin) GHC.Types.~ ('Data.Bin.BP n :: Data.Bin.Bin)) => Data.Semigroup.Foldable.Class.Foldable1 (Data.RAVec.RAVec b)
instance ((b :: Data.Bin.Bin) GHC.Types.~ ('Data.Bin.BP n :: Data.Bin.Bin)) => Data.Semigroup.Traversable.Class.Traversable1 (Data.RAVec.RAVec b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.RAVec.RAVec b a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.RAVec.RAVec b a)
instance Data.Type.Bin.SBinI b => GHC.Base.Applicative (Data.RAVec.RAVec b)
instance Data.Type.Bin.SBinI b => Data.Distributive.Distributive (Data.RAVec.RAVec b)
instance Data.Type.Bin.SBinI b => Data.Functor.Rep.Representable (Data.RAVec.RAVec b)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.RAVec.RAVec b a)
instance (GHC.Base.Monoid a, Data.Type.Bin.SBinI b) => GHC.Base.Monoid (Data.RAVec.RAVec b a)
instance Data.Functor.Bind.Class.Apply (Data.RAVec.RAVec b)
instance Data.Type.Bin.SBinI b => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.RAVec.RAVec b)
instance (Data.Type.Bin.SBinI b, Test.QuickCheck.Arbitrary.Arbitrary a) => Test.QuickCheck.Arbitrary.Arbitrary (Data.RAVec.RAVec b a)
instance Test.QuickCheck.Arbitrary.CoArbitrary a => Test.QuickCheck.Arbitrary.CoArbitrary (Data.RAVec.RAVec b a)
instance (Data.Type.Bin.SBinI b, Test.QuickCheck.Function.Function a) => Test.QuickCheck.Function.Function (Data.RAVec.RAVec b a)
