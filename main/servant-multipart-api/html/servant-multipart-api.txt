-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | multipart/form-data (e.g file upload) support for servant
--   
--   This package contains servant API types that support multiform upload,
--   used by servant-multipart and servant-multipart-client for
--   backend/client implementation.
@package servant-multipart-api
@version 0.12.1


-- | <tt>multipart/form-data</tt> Servant API support for servant. see
--   servant-multipart and servant-multipart-client for server- and client-
--   definitions.
--   
--   This is mostly useful for adding file upload support to an API. See
--   haddocks of <a>MultipartForm</a> for an introduction.
module Servant.Multipart.API

-- | Combinator for specifying a <tt>multipart/form-data</tt> request body,
--   typically (but not always) issued from an HTML <tt>&lt;form&gt;</tt>.
--   
--   <tt>multipart/form-data</tt> can't be made into an ordinary content
--   type for now in servant because it doesn't just decode the request
--   body from some format but also performs IO in the case of writing the
--   uploaded files to disk, e.g in <tt>/tmp</tt>, which is not compatible
--   with servant's vision of a content type as things stand now. This also
--   means that <a>MultipartForm</a> can't be used in conjunction with
--   <a>ReqBody</a> in an endpoint.
--   
--   The <tt>tag</tt> type parameter instructs the function to handle data
--   either as data to be saved to temporary storage (<a>Tmp</a>) or saved
--   to memory (<a>Mem</a>).
--   
--   The <tt>a</tt> type parameter represents the Haskell type to which you
--   are going to decode the multipart data to, where the multipart data
--   consists in all the usual form inputs along with the files sent along
--   through <tt>&lt;input type="file"&gt;</tt> fields in the form.
--   
--   One option provided out of the box by this library is to decode to
--   <a>MultipartData</a>.
--   
--   Example:
--   
--   <pre>
--   type API = MultipartForm Tmp (MultipartData Tmp) :&gt; Post '[PlainText] String
--   
--   api :: Proxy API
--   api = Proxy
--   
--   server :: MultipartData Tmp -&gt; Handler String
--   server multipartData = return str
--   
--     where str = "The form was submitted with "
--              ++ show nInputs ++ " textual inputs and "
--              ++ show nFiles  ++ " files."
--           nInputs = length (inputs multipartData)
--           nFiles  = length (files multipartData)
--   
--   </pre>
--   
--   You can alternatively provide a <a>FromMultipart</a> instance for some
--   type of yours, allowing you to regroup data into a structured form and
--   potentially selecting a subset of the entire form data that was
--   submitted.
--   
--   Example, where we only look extract one input, <i>username</i>, and
--   one file, where the corresponding input field's <i>name</i> attribute
--   was set to <i>pic</i>:
--   
--   <pre>
--   data User = User { username :: Text, pic :: FilePath }
--   
--   instance FromMultipart Tmp User where
--     fromMultipart multipartData =
--       User &lt;$&gt; lookupInput "username" multipartData
--            &lt;*&gt; fmap fdPayload (lookupFile "pic" multipartData)
--   
--   type API = MultipartForm Tmp User :&gt; Post '[PlainText] String
--   
--   server :: User -&gt; Handler String
--   server usr = return str
--   
--     where str = username usr ++ "'s profile picture"
--              ++ " got temporarily uploaded to "
--              ++ pic usr ++ " and will be removed from there "
--              ++ " after this handler has run."
--   
--   </pre>
--   
--   Note that the behavior of this combinator is configurable, by using
--   <tt>serveWith</tt> from servant-server instead of <tt>serve</tt>,
--   which takes an additional <tt>Context</tt> argument. It simply is an
--   heterogeneous list where you can for example store a value of type
--   <tt>MultipartOptions</tt> that has the configuration that you want,
--   which would then get picked up by servant-multipart.
--   
--   <b>Important</b>: as mentionned in the example above, the file paths
--   point to temporary files which get removed after your handler has run,
--   if they are still there. It is therefore recommended to move or copy
--   them somewhere in your handler code if you need to keep the content
--   around.
type MultipartForm tag a = MultipartForm' '[] tag a

-- | <a>MultipartForm</a> which can be modified with <a>Lenient</a>.
data MultipartForm' (mods :: [*]) tag a

-- | What servant gets out of a <tt>multipart/form-data</tt> form
--   submission.
--   
--   The type parameter <tt>tag</tt> tells if <a>MultipartData</a> is
--   stored as a temporary file or stored in memory. <tt>tag</tt> is type
--   of either <a>Mem</a> or <a>Tmp</a>.
--   
--   The <a>inputs</a> field contains a list of textual <a>Input</a>s,
--   where each input for which a value is provided gets to be in this
--   list, represented by the input name and the input value. See haddocks
--   for <a>Input</a>.
--   
--   The <a>files</a> field contains a list of files that were sent along
--   with the other inputs in the form. Each file is represented by a value
--   of type <a>FileData</a> which among other things contains the path to
--   the temporary file (to be removed when your handler is done running)
--   with a given uploaded file's content. See haddocks for
--   <a>FileData</a>.
data MultipartData tag
MultipartData :: [Input] -> [FileData tag] -> MultipartData tag
[inputs] :: MultipartData tag -> [Input]
[files] :: MultipartData tag -> [FileData tag]

-- | Allows you to tell servant how to turn a more structured type into a
--   <a>MultipartData</a>, which is what is actually sent by the client.
--   
--   <pre>
--   data User = User { username :: Text, pic :: FilePath }
--   
--   instance toMultipart Tmp User where
--       toMultipart user = MultipartData [Input "username" $ username user]
--                                        [FileData "pic"
--                                                  (pic user)
--                                                  "image/png"
--                                                  (pic user)
--                                        ]
--   
--   </pre>
class ToMultipart tag a

-- | Given a value of type <tt>a</tt>, convert it to a
--   <a>MultipartData</a>.
toMultipart :: ToMultipart tag a => a -> MultipartData tag

-- | <a>MultipartData</a> is the type representing
--   <tt>multipart/form-data</tt> form inputs. Sometimes you may instead
--   want to work with a more structured type of yours that potentially
--   selects only a fraction of the data that was submitted, or just
--   reshapes it to make it easier to work with. The <a>FromMultipart</a>
--   class is exactly what allows you to tell servant how to turn "raw"
--   multipart data into a value of your nicer type.
--   
--   <pre>
--   data User = User { username :: Text, pic :: FilePath }
--   
--   instance FromMultipart Tmp User where
--     fromMultipart form =
--       User &lt;$&gt; lookupInput "username" (inputs form)
--            &lt;*&gt; fmap fdPayload (lookupFile "pic" $ files form)
--   
--   </pre>
class FromMultipart tag a

-- | Given a value of type <a>MultipartData</a>, which consists in a list
--   of textual inputs and another list for files, try to extract a value
--   of type <tt>a</tt>. When extraction fails, servant errors out with
--   status code 400.
fromMultipart :: FromMultipart tag a => MultipartData tag -> Either String a
type family MultipartResult tag :: *

-- | Tag for data stored as a temporary file
data Tmp

-- | Tag for data stored in memory
data Mem

-- | Representation for a textual input (any <tt>&lt;input&gt;</tt> type
--   but <tt>file</tt>).
--   
--   <tt>&lt;input name="foo" value="bar" /&gt;</tt> would appear as
--   <tt><a>Input</a> "foo" "bar"</tt>.
data Input
Input :: Text -> Text -> Input

-- | <tt>name</tt> attribute of the input
[iName] :: Input -> Text

-- | value given for that input
[iValue] :: Input -> Text

-- | Representation for an uploaded file, usually resulting from picking a
--   local file for an HTML input that looks like <tt>&lt;input type="file"
--   name="somefile" /&gt;</tt>.
data FileData tag
FileData :: Text -> Text -> Text -> MultipartResult tag -> FileData tag

-- | <tt>name</tt> attribute of the corresponding HTML
--   <tt>&lt;input&gt;</tt>
[fdInputName] :: FileData tag -> Text

-- | name of the file on the client's disk
[fdFileName] :: FileData tag -> Text

-- | MIME type for the file
[fdFileCType] :: FileData tag -> Text

-- | path to the temporary file that has the content of the user's original
--   file. Only valid during the execution of your handler as it gets
--   removed right after, which means you really want to move or copy it in
--   your handler.
[fdPayload] :: FileData tag -> MultipartResult tag
instance GHC.Show.Show Servant.Multipart.API.Input
instance GHC.Classes.Eq Servant.Multipart.API.Input
instance GHC.Classes.Eq (Servant.Multipart.API.MultipartResult tag) => GHC.Classes.Eq (Servant.Multipart.API.FileData tag)
instance GHC.Show.Show (Servant.Multipart.API.MultipartResult tag) => GHC.Show.Show (Servant.Multipart.API.FileData tag)
instance Servant.Multipart.API.FromMultipart tag (Servant.Multipart.API.MultipartData tag)
instance Servant.Multipart.API.ToMultipart tag (Servant.Multipart.API.MultipartData tag)
instance Servant.Links.HasLink sub => Servant.Links.HasLink (Servant.Multipart.API.MultipartForm tag a Servant.API.Sub.:> sub)
