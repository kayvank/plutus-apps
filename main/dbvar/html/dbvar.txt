-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Mutable variables that are written to disk using delta encodings.
--   
--   Mutable variables that are written to disk using delta encodings.
@package dbvar
@version 2021.8.23

module Data.Delta

-- | Type class for delta encodings.
class Delta delta where {
    
    -- | Base type for which <tt>delta</tt> represents a delta encoding. This
    --   is implemented as a type family, so that we can have multiple delta
    --   encodings for the same base type.
    --   
    --   FIXME: Better name for <a>Base</a>? It's sooo generic. Pier, dock,
    --   ground, anchor, site, …
    type family Base delta :: Type;
}

-- | Apply a delta encoding to the base type.
apply :: Delta delta => delta -> Base delta -> Base delta

-- | Trivial delta encoding for the type <tt>a</tt> that admits no change
--   at all.
data NoChange a
NoChange :: NoChange a

-- | Trivial delta encoding for the type <tt>a</tt> that replaces the value
--   wholesale.
newtype Replace a
Replace :: a -> Replace a

-- | Delta encoding for lists where a list of elements is prepended.
data DeltaList a
Append :: [a] -> DeltaList a

-- | Delta encoding for <a>Set</a> where a single element is deleted or
--   added.
data DeltaSet1 a
Insert :: a -> DeltaSet1 a
Delete :: a -> DeltaSet1 a

-- | Delta encoding for a <a>Set</a> where collections of elements are
--   inserted or deleted.
data DeltaSet a

-- | Delta to get from the second argument to the first argument.
mkDeltaSet :: Ord a => Set a -> Set a -> DeltaSet a

-- | Flatten a <a>DeltaSet</a> to a list of <a>DeltaSet1</a>.
--   
--   In the result list, the set of <tt>a</tt> appearing as
--   <a>Insert</a><tt> a</tt> is <i>disjoint</i> from the set of <tt>a</tt>
--   appearing as <a>Delete</a><tt> a</tt>.
deltaSetToList :: DeltaSet a -> [DeltaSet1 a]

-- | Collect insertions or deletions of elements into a <a>DeltaSet</a>.
--   
--   To save space, combinations of <a>Insert</a> and <a>Delete</a> for the
--   same element are simplified when possible. These simplifications
--   always preserve the property
--   
--   <pre>
--   apply (deltaSetFromList ds) = apply ds
--   </pre>
deltaSetFromList :: Ord a => [DeltaSet1 a] -> DeltaSet a

-- | <a>Embedding</a> with efficient composition <a>o</a>. To construct an
--   embedding, use <a>mkEmbedding</a>.
data Embedding da db

-- | <a>Category</a> sans <a>id</a>
class Semigroupoid (c :: k -> k -> Type)
o :: forall (j :: k) (k1 :: k) (i :: k). Semigroupoid c => c j k1 -> c i j -> c i k1

-- | Specification of an embedding of a type <tt>a</tt> with delta encoding
--   <tt>da</tt> into the type <tt>b</tt> with delta encoding <tt>db</tt>.
--   See <a>the discussion of <tt>Embedding</tt></a> for a more detailed
--   description.
data Embedding' da db
[Embedding'] :: (Delta da, Delta db, a ~ Base da, b ~ Base db) => {load :: b -> Either SomeException a, write :: a -> b, update :: a -> b -> da -> db} -> Embedding' da db

-- | Construct <a>Embedding</a> with efficient composition
mkEmbedding :: Embedding' da db -> Embedding da db

-- | Extract <a>load</a>, <a>write</a>, and <a>update</a> functions from an
--   efficient <a>Embedding</a>.
fromEmbedding :: (Delta da, Delta db) => Embedding da db -> Embedding' da db

-- | A pair of <a>Embedding</a>s gives an embedding of pairs.
pair :: Embedding da1 db1 -> Embedding da2 db2 -> Embedding (da1, da2) (db1, db2)

-- | Lift a sequence of updates through an <a>Embedding</a>.
liftUpdates :: Delta da => Embedding da db -> [da] -> Base da -> (Base db, [db])

-- | Having an <a>apply</a> function is equivalent to the existence of a
--   canonical embedding into the trivial <a>Replace</a> delta encoding.
replaceFromApply :: (Delta da, a ~ Base da) => Embedding' da (Replace a)
inject :: Embedding da db -> Base da -> Machine da db
project :: Embedding da db -> Base db -> Either SomeException (Base da, Machine da db)

-- | Strict pair. If a value of this type is in WHNF, so are the two
--   components. data StrictPair a b = !a :*: !b infixr 1 :*:
--   
--   A state machine that maps deltas to deltas. This machine always
--   carries a state of type <a>Base</a><tt> db</tt> around.
data Machine da db
Machine :: !Base db -> ((Base da, da) -> (db, Machine da db)) -> Machine da db
[state_] :: Machine da db -> !Base db
[step_] :: Machine da db -> (Base da, da) -> (db, Machine da db)

-- | Identity machine starting from a base type.
idle :: Delta da => Base da -> Machine da da

-- | Pair two <a>Machine</a>.
pairMachine :: Machine da1 db1 -> Machine da2 db2 -> Machine (da1, da2) (db1, db2)

-- | Create a <a>Machine</a> from a specific state <tt>s</tt>, and the
--   built-in state <a>Base</a><tt> db</tt>.
fromState :: Delta db => ((Base da, da) -> (Base db, s) -> (db, s)) -> (Base db, s) -> Machine da db
instance GHC.Show.Show (Data.Delta.NoChange a)
instance GHC.Classes.Ord (Data.Delta.NoChange a)
instance GHC.Classes.Eq (Data.Delta.NoChange a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Delta.Replace a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Delta.Replace a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Delta.Replace a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Delta.DeltaList a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Delta.DeltaList a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Delta.DeltaList a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Delta.DeltaSet1 a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Delta.DeltaSet1 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Delta.DeltaSet1 a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Delta.DeltaSet a)
instance Data.Semigroupoid.Semigroupoid Data.Delta.Embedding
instance Data.Semigroupoid.Semigroupoid Data.Delta.Machine
instance GHC.Classes.Ord a => Data.Delta.Delta (Data.Delta.DeltaSet a)
instance GHC.Classes.Ord a => GHC.Base.Semigroup (Data.Delta.DeltaSet a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Delta.DeltaSet a)
instance GHC.Classes.Ord a => Data.Delta.Delta (Data.Delta.DeltaSet1 a)
instance Data.Delta.Delta (Data.Delta.DeltaList a)
instance Data.Delta.Delta (Data.Delta.Replace a)
instance GHC.Base.Semigroup (Data.Delta.Replace a)
instance Data.Delta.Delta (Data.Delta.NoChange a)
instance Data.Delta.Delta delta => Data.Delta.Delta (GHC.Maybe.Maybe delta)
instance Data.Delta.Delta delta => Data.Delta.Delta [delta]
instance Data.Delta.Delta delta => Data.Delta.Delta (GHC.Base.NonEmpty delta)
instance (Data.Delta.Delta d1, Data.Delta.Delta d2) => Data.Delta.Delta (d1, d2)
instance (Data.Delta.Delta d1, Data.Delta.Delta d2, Data.Delta.Delta d3) => Data.Delta.Delta (d1, d2, d3)
instance (Data.Delta.Delta d1, Data.Delta.Delta d2, Data.Delta.Delta d3, Data.Delta.Delta d4) => Data.Delta.Delta (d1, d2, d3, d4)

module Data.DBVar

-- | A <a>DBVar</a><tt> m delta</tt> is a mutable reference to a Haskell
--   value of type <tt>a</tt>. The type <tt>delta</tt> is a delta encoding
--   for this value type <tt>a</tt>, that is we have <tt>a ~
--   </tt><a>Base</a><tt> delta</tt>.
--   
--   The Haskell value is cached in memory, in weak head normal form
--   (WHNF). However, whenever the value is updated, a copy of will be
--   written to persistent storage like a file or database on the hard
--   disk; any particular storage is specified by the <a>Store</a> type.
--   For efficient updates, the delta encoding <tt>delta</tt> is used in
--   the update.
--   
--   Concurrency:
--   
--   <ul>
--   <li>Updates are atomic and will block other updates.</li>
--   <li>Reads will <i>not</i> be blocked during an update (except for a
--   small moment where the new value atomically replaces the old
--   one).</li>
--   </ul>
data DBVar m delta

-- | Read the current value of the <a>DBVar</a>.
readDBVar :: (Delta da, a ~ Base da) => DBVar m da -> m a

-- | Update the value of the <a>DBVar</a> using a delta encoding.
--   
--   The new value will be evaluated to weak head normal form.
updateDBVar :: (Delta da, Monad m) => DBVar m da -> da -> m ()

-- | Modify the value in a <a>DBVar</a>.
--   
--   The new value will be evaluated to weak head normal form.
modifyDBVar :: (Delta da, Monad m, a ~ Base da) => DBVar m da -> (a -> (da, b)) -> m b

-- | Maybe modify the value in a <a>DBVar</a>
--   
--   If updated, the new value will be evaluated to weak head normal form.
modifyDBMaybe :: (Delta da, Monad m, a ~ Base da) => DBVar m da -> (a -> (Maybe da, b)) -> m b

-- | Initialize a new <a>DBVar</a> for a given <a>Store</a>.
initDBVar :: (MonadSTM m, MonadThrow m, MonadEvaluate m, MonadMask m, Delta da, a ~ Base da) => Store m da -> a -> m (DBVar m da)

-- | Create a <a>DBVar</a> by loading its value from an existing
--   <a>Store</a> Throws an exception if the value cannot be loaded.
loadDBVar :: (MonadSTM m, MonadThrow m, MonadEvaluate m, MonadMask m, Delta da) => Store m da -> m (DBVar m da)

-- | A <a>Store</a> is a storage facility for Haskell values of type <tt>a
--   ~</tt><a>Base</a><tt> da</tt>. Typical use cases are a file or a
--   database on the hard disk.
--   
--   A <a>Store</a> has many similarities with an <a>Embedding</a>. The
--   main difference is that storing value in a <a>Store</a> has side
--   effects. A <a>Store</a> is described by three action:
--   
--   <ul>
--   <li><a>writeS</a> writes a value to the store.</li>
--   <li><a>loadS</a> loads a value from the store.</li>
--   <li><a>updateS</a> uses a delta encoding of type <tt>da</tt> to
--   efficiently update the store. In order to avoid performing an
--   expensive <a>loadS</a> operation, the action <a>updateS</a> expects
--   the value described by the store as an argument, but no check is
--   performed whether the provided value matches the contents of the
--   store. Also, not every store inspects this argument.</li>
--   </ul>
--   
--   A <a>Store</a> is characterized by the following properties:
--   
--   <ul>
--   <li>The store <b>need not contain</b> a properly formatted
--   <b>value</b>: Loading a value from the store may fail, and this is why
--   <a>loadS</a> has an <a>Either</a> result. For example, if the
--   <a>Store</a> represents a file on disk, then the file may corrupted or
--   in an incompatible file format when first opened. In such a case of
--   failure, the result <a>Left</a><tt> (e ::
--   </tt><a>SomeException</a><tt>)</tt> is returned, where the exception
--   <tt>e</tt> gives more information about the failure.However, loading a
--   value after writing it should always succeed, we have<pre>writeS s a
--   &gt;&gt; loadS s = pure (Right a)</pre></li>
--   <li>The store is <b>redundant</b>: Two stores with different contents
--   may describe the same value of type <tt>a</tt>. For example, two files
--   with different whitespace may describe the same JSON value. In
--   general, we have<pre>loadS s &gt;&gt;= either (const $ pure ())
--   (writeS s) ≠ pure ()</pre></li>
--   <li>Updating a store <b>commutes with <a>apply</a></b>: We
--   have<pre>updateS s a da &gt;&gt; loadS s = pure $ Right $ apply a
--   da</pre>However, since the store is redundant, we often
--   have<pre>updateS s a da ≠ writeS s (apply a da)</pre></li>
--   <li><b>Exceptions</b>: It is expected that the functions <a>loadS</a>,
--   <a>updateS</a>, <a>writeS</a> do not throw synchronous exceptions. In
--   the worst case, <a>loadS</a> should return <a>Left</a> after reading
--   or writing to the store was unsuccessful.</li>
--   <li><b>Concurrency</b>: It is expected that the functions
--   <a>updateS</a> and <a>writeS</a> are <i>atomic</i>: Either they
--   succeed in updating / writing the new value in its entirety, or the
--   old value is kept. In particular, we expect this even when one of
--   these functions receives an asynchronous exception and needs to abort
--   normal operation.</li>
--   </ul>
data Store m da
Store :: m (Either SomeException (Base da)) -> (Base da -> m ()) -> (Base da -> da -> m ()) -> Store m da
[loadS] :: Store m da -> m (Either SomeException (Base da))
[writeS] :: Store m da -> Base da -> m ()
[updateS] :: Store m da -> Base da -> da -> m ()

-- | An in-memory <a>Store</a> from a mutable variable (<tt>TVar</tt>).
--   Useful for testing.
newStore :: (Delta da, MonadSTM m) => m (Store m da)

-- | $EitherSomeException
--   
--   NOTE: [EitherSomeException]
--   
--   In this version of the library, the error case returned by
--   <a>loadS</a> and <a>load</a> is the general <a>SomeException</a> type,
--   which is a disjoint sum of all possible error types (that is, members
--   of the <a>Exception</a> class).
--   
--   In a future version of this library, this may be replaced by a more
--   specific error type, but at the price of introducing a new type
--   parameter <tt>e</tt> in the <a>Store</a> type.
--   
--   For now, I have opted to explore a region of the design space where
--   the number of type parameters is kept to a minimum. I would argue that
--   making errors visible on the type level is not as useful as one might
--   hope for, because in exchange for making the types noisier, the amount
--   of type-safety we gain is very small. Specifically, if we encounter an
--   element of the <a>SomeException</a> type that we did not expect, it is
--   entirely ok to <tt>throw</tt> it. For example, consider the following
--   code: <tt> let ea :: Either SomeException () ea = [..] in case ea of
--   Right _ -&gt; "everything is ok" Left e -&gt; case fromException e of
--   Just (AssertionFailed _) -&gt; "bad things happened" Nothing -&gt;
--   throw e </tt> In this example, using the more specific type <tt>ea ::
--   Either AssertionFailed ()</tt> would have eliminated the need to
--   handle the <a>Nothing</a> case. But as we are dealing with exceptions,
--   this case does have a default handler, and there is less need to
--   exclude it at compile as opposed to, say, the case of an empty list.
--   
--   Failure that occurs when calling <a>loadS</a> on a <a>newStore</a>
--   that is empty.
data NotInitialized
NotInitialized :: NotInitialized
embedStore :: (MonadSTM m, MonadMask m, Delta da) => Embedding da db -> Store m db -> m (Store m da)

-- | Combine two <tt>Stores</tt> into a store for pairs.
--   
--   WARNING: The <a>updateS</a> and <a>writeS</a> functions of the result
--   are not atomic in the presence of asynchronous exceptions. For
--   example, the update of the first store may succeed while the update of
--   the second store may fail. In other words, this combinator works for
--   some monads, such as <tt>m = </tt><tt>STM</tt>, but fails for others,
--   such as <tt>m = <a>IO</a></tt>.
pairStores :: Monad m => Store m da -> Store m db -> Store m (da, db)

-- | Obtain a <a>Store</a> for one type <tt>a1</tt> from a <a>Store</a> for
--   another type <tt>a2</tt> via an <a>Embedding'</a> of the first type
--   into the second type.
--   
--   Note: This function is exported for testing and documentation only,
--   use the more efficient <a>embedStore</a> instead.
embedStore' :: (Monad m, MonadThrow m) => Embedding' da db -> Store m db -> Store m da
instance GHC.Show.Show Data.DBVar.NotInitialized
instance GHC.Classes.Eq Data.DBVar.NotInitialized
instance GHC.Exception.Type.Exception Data.DBVar.NotInitialized

module Data.DeltaMap

-- | Delta type for <a>Map</a>.
data DeltaMap key da
Insert :: key -> Base da -> DeltaMap key da
Delete :: key -> DeltaMap key da
Adjust :: key -> da -> DeltaMap key da
instance (GHC.Show.Show key, GHC.Show.Show da, GHC.Show.Show (Data.Delta.Base da)) => GHC.Show.Show (Data.DeltaMap.DeltaMap key da)
instance (GHC.Classes.Ord key, Data.Delta.Delta da) => Data.Delta.Delta (Data.DeltaMap.DeltaMap key da)
instance (GHC.Show.Show key, GHC.Show.Show da, GHC.Show.Show (Data.Delta.Base da)) => Formatting.Buildable.Buildable (Data.DeltaMap.DeltaMap key da)

module Data.Table

-- | A <a>Table</a> is a collection of rows.
data Table row
Table :: IntMap row -> Supply -> Table row

-- | Rows indexed by unique ID.
[rows] :: Table row -> IntMap row

-- | Unique ID supply. WARNING: This is an internal part of the structure.
--   Changing it may lead to an inconsistent state.
[uids] :: Table row -> Supply

-- | The empty <a>Table</a>, containing no rows.
empty :: Table row

-- | Construct a <a>Table</a> from a list of rows with unique IDs.
fromRows :: [(Int, row)] -> Table row

-- | Construct a <a>Table</a> from a list of rows
fromList :: [row] -> Table row

-- | Pile of rows contained in the <a>Table</a>.
toPile :: Table row -> Pile row

-- | Pile of rows with unique IDs contained in the <a>Table</a>.
toRows :: Table row -> Pile (Int, row)

-- | List all rows satisfying the predicate.
selectWhere :: (row -> Bool) -> Table row -> Pile row

-- | Insert rows into the table.
insertMany :: [row] -> Table row -> Table row

-- | Delete all rows satisfying the predicate.
deleteWhere :: (row -> Bool) -> Table row -> Table row

-- | Update all rows satisfying the predicate
updateWhere :: (row -> Bool) -> (row -> row) -> Table row -> Table row

-- | Delta encoding for changes to a <a>Table</a>.
data DeltaTable row
InsertMany :: [row] -> DeltaTable row
DeleteWhere :: (row -> Bool) -> DeltaTable row
UpdateWhere :: (row -> Bool) -> (row -> row) -> DeltaTable row

-- | Delta encoding for changes to a database table with unique IDs.
data DeltaDB key row
InsertManyDB :: [(key, row)] -> DeltaDB key row
DeleteManyDB :: [key] -> DeltaDB key row
UpdateManyDB :: [(key, row)] -> DeltaDB key row
tableIntoDatabase :: Embedding [DeltaTable row] [DeltaDB Int row]

-- | A <a>Pile</a> is a set of values. Unlike <a>Set</a>, it is represented
--   as a list, and avoids the <a>Ord</a> constraint.
--   
--   This type is useful for highlighting that a collection of values has
--   no specific order, even though it is not represented as a <a>Set</a>.
newtype Pile a
Pile :: [a] -> Pile a
[getPile] :: Pile a -> [a]
fromSet :: Set a -> Pile a

-- | Map a <a>DeltaList</a> to a <a>Pile</a> of indexed single element
--   concatenations. Higher indices are prepended later.
deltaListToPile :: DeltaList a -> Pile (Int, a)

-- | Restore a <a>DeltaList</a> from a <a>Pile</a>.
--   
--   <pre>
--   deltaListFromPile . deltaListToPile = id
--   </pre>
deltaListFromPile :: Pile (Int, a) -> DeltaList a

-- | Randomly permute the objects in a <a>Pile</a>. Useful for stress
--   testing.
--   
--   Every function <tt>f :: Pile A -&gt; B</tt> should satisfy
--   
--   <pre>
--   forall g.  f . permute g = f
--   </pre>
--   
--   permute :: RandomGen g =&gt; g -&gt; Pile a -&gt; Pile a permute =
--   undefined let (index, g2) = randomR (1,n) g1
--   
--   Map a <a>DeltaSet</a> to a <a>Pile</a> of single element insertions
--   and deltions.
deltaSetToPile :: DeltaSet a -> Pile (DeltaSet1 a)

-- | Restore a <a>DeltaSet</a> from a <a>Pile</a> of single element
--   insertions and deletions.
--   
--   <pre>
--   deltaSetFromPile . deltaSetToPile = id
--   </pre>
deltaSetFromPile :: Ord a => Pile (DeltaSet1 a) -> DeltaSet a

-- | A supply of unique IDs.
data Supply

-- | Fresh supply of unique IDs.
abundance :: Supply

-- | Retrieve a fresh unique ID.
fresh :: Supply -> (Int, Supply)

-- | Remove a list of unique IDs from the <a>Supply</a> if necessary.
consume :: [Int] -> Supply -> Supply
instance (GHC.Show.Show key, GHC.Show.Show row) => GHC.Show.Show (Data.Table.DeltaDB key row)
instance (GHC.Classes.Eq key, GHC.Classes.Eq row) => GHC.Classes.Eq (Data.Table.DeltaDB key row)
instance GHC.Show.Show a => GHC.Show.Show (Data.Table.Pile a)
instance GHC.Show.Show row => GHC.Show.Show (Data.Table.Table row)
instance GHC.Base.Functor Data.Table.Table
instance Data.Delta.Delta (Data.Table.DeltaTable row)
instance (key GHC.Types.~ GHC.Types.Int) => Data.Delta.Delta (Data.Table.DeltaDB key row)
instance GHC.Show.Show Data.Table.Supply
instance GHC.Classes.Ord a => GHC.Classes.Eq (Data.Table.Pile a)
instance GHC.Base.Functor (Data.Table.DeltaDB key)
instance GHC.Show.Show row => GHC.Show.Show (Data.Table.DeltaTable row)

module Data.Chain

-- | A linear chain of nodes. Edges between nodes are labeled by a
--   <a>Monoid</a> <tt>edge</tt>.
--   
--   <pre>
--   n_tip  &lt;--e_tip-- … &lt;--e1-- n1 &lt;--e0-- n0
--   </pre>
data Chain node edge

-- | Test whether a node is contained in the chain.
member :: Ord node => node -> Chain node edge -> Bool

-- | Context (incoming and outgoing edges) for a <tt>node</tt> in a
--   <a>Chain</a>.
type ChainContext node edge = Edge (Maybe (edge, node)) node

-- | Look up the <tt>Context</tt> of a node in a <a>Chain</a>.
lookup :: Ord node => node -> Chain node edge -> Maybe (ChainContext node edge)

-- | Construct a chain from a single <a>Edge</a>.
fromEdge :: Ord node => Edge node edge -> Chain node edge

-- | Construct a chain from a collection of edges. Fails if the edges do
--   not fit together.
--   
--   The ordering of edge labels of a single edge in the chain will be the
--   same as the ordering of the edge labels as they appear in the list.
fromEdges :: Ord node => [Edge node edge] -> Maybe (Chain node [edge])

-- | List all edges in the <a>Chain</a>.
--   
--   The edge that points to the tip is listed <i>first</i>, and the edge
--   that starts at the beginning is listed <i>last</i>.
edges :: Ord node => Chain node edge -> [edge]

-- | List all nodes in the <a>Chain</a>. The tip is listed <i>first</i>.
nodes :: Ord node => Chain node edge -> [node]

-- | Convert a <a>Chain</a> into a list of <a>Edge</a>.
toEdges :: Chain node edge -> [Edge node edge]

-- | Combine all the edges in the <a>Chain</a>. The summary is invariant
--   under <a>collapseNode</a>.
--   
--   <pre>
--   summary = mconcat . edges
--   </pre>
summary :: (Ord node, Monoid edge) => Chain node edge -> edge

-- | Changes to a <a>Chain</a>.
data DeltaChain node edge

-- | See <a>appendTip</a>.
AppendTip :: node -> edge -> DeltaChain node edge

-- | See <a>collapseNode</a>.
CollapseNode :: node -> DeltaChain node edge

-- | See <a>rollbackTo</a>.
RollbackTo :: node -> DeltaChain node edge

-- | Append a new tip to the chain.
appendTip :: Ord node => node -> edge -> Chain node edge -> Chain node edge

-- | Remove the given <tt>node</tt> and combine the incoming and outgoing
--   edges. Do nothing if the node is at the tip, or at the bottom, or not
--   in the chain at all.
collapseNode :: (Ord node, Semigroup edge) => node -> Chain node edge -> Chain node edge

-- | Remove the tip and more nodes from the chain until the given node is
--   the tip.
--   
--   Do nothing if the node is not in the chain.
rollbackTo :: Ord node => node -> Chain node edge -> Chain node edge

-- | Embed a <a>Chain</a> into a table of <a>Edge</a>.
--   
--   The first and second argument specify how the edge labels are to be
--   mapped to and from sets of table rows. Importantly, we may not assume
--   that the table stores the rows in any particular order.
chainIntoTable :: (Ord node, Semigroup edge) => (edge -> Pile e) -> (Pile e -> edge) -> Embedding (DeltaChain node edge) [DeltaTable (Edge node e)]
data ErrMalformedChainTable
ErrMalformedChainTable :: ErrMalformedChainTable

-- | Utility type that represents an <a>Edge</a> in a graph: it connects
--   two <tt>node</tt> via an <tt>edge</tt> label.
data Edge node edge
Edge :: node -> node -> edge -> Edge node edge
[from] :: Edge node edge -> node
[to] :: Edge node edge -> node
[via] :: Edge node edge -> edge

-- | Flatten a list of edges
flattenEdge :: Edge node [edge] -> [Edge node edge]
testChain :: (Table (Edge Int Char), [[DeltaDB Int (Edge Int Char)]])
instance (GHC.Show.Show node, GHC.Show.Show edge) => GHC.Show.Show (Data.Chain.Chain node edge)
instance (GHC.Classes.Eq node, GHC.Classes.Eq edge) => GHC.Classes.Eq (Data.Chain.Chain node edge)
instance GHC.Show.Show Data.Chain.ErrMalformedChainTable
instance GHC.Classes.Eq Data.Chain.ErrMalformedChainTable
instance (GHC.Show.Show node, GHC.Show.Show edge) => GHC.Show.Show (Data.Chain.Edge node edge)
instance (GHC.Classes.Ord node, GHC.Classes.Ord edge) => GHC.Classes.Ord (Data.Chain.Edge node edge)
instance (GHC.Classes.Eq node, GHC.Classes.Eq edge) => GHC.Classes.Eq (Data.Chain.Edge node edge)
instance GHC.Base.Functor (Data.Chain.Edge node)
instance GHC.Exception.Type.Exception Data.Chain.ErrMalformedChainTable
instance (GHC.Classes.Ord node, GHC.Base.Semigroup edge) => Data.Delta.Delta (Data.Chain.DeltaChain node edge)
instance GHC.Base.Functor (Data.Chain.Chain node)

module Database.Schema

-- | Class of columns that can be stored in database tables.
class PersistField a => IsCol a
getSqlType :: IsCol a => Proxy a -> SqlColType

-- | SQL column types, including constraints. Values of type
--   <a>SqlColType</a> represent SQL types such as
--   
--   <pre>
--   INTEGER  PRIMARY KEY NOT NULL
--   TEXT  NOT NULL
--   </pre>
newtype SqlColType
SqlColType :: Text -> SqlColType

-- | Helper for converting <a>SqlType</a> into an SQL column type with
--   constraints.
toColType :: SqlType -> SqlColType

-- | Primary key.
newtype Primary
Primary :: Int -> Primary
[getPrimary] :: Primary -> Int

-- | Named database table.
data Table (name :: Symbol)
Table :: Table (name :: Symbol)

-- | Named database column.
newtype Col (name :: Symbol) a
Col :: a -> Col (name :: Symbol) a

-- | Infix notation for a pair of types.
data a :. b
(:.) :: a -> b -> (:.) a b
infixl 3 :.
infixl 3 :.

-- | Class of row types that can be stored in database tables. Instances of
--   this class are essentially lists of columns. Example:
--   
--   <pre>
--   type PersonRow = Table "person" :. Col "name" Text :. Col "age" Int
--   </pre>
class IsRow row
getTableName :: IsRow row => Proxy row -> Text
getColNames :: IsRow row => Proxy row -> [Text]
getSqlTypes :: IsRow row => Proxy row -> [SqlColType]
toSqlValues :: IsRow row => row -> [PersistValue]
fromSqlValues :: IsRow row => [PersistValue] -> Either Text row

-- | An SQL query that returns a list of values of type <tt>row</tt>.
data Query row

-- | Run an SQL query and return a list of rows as result.
callSql :: (MonadIO m, IsRow row) => Query row -> SqlPersistT m [row]

-- | Execute an SQL query, but do not return any results
runSql :: MonadIO m => Query () -> SqlPersistT m ()

-- | Create a database table that can store the given rows.
createTable :: IsRow row => Proxy row -> Query ()

-- | Select all rows from the table.
selectAll :: forall row. IsRow row => Query row

-- | Insert a single row into the corresponding table.
insertOne :: forall row. IsRow row => row -> Query ()

-- | Replace or insert a single row with a primary key into a database.
--   
--   FIXME: It would be nicer if the "id" column was the first column
--   instead of the last column in the table.
repsertOne :: forall row. IsRow row => (row :. Col "id" Primary) -> Query ()

-- | Update one row with a given "id" column in a database table.
updateOne :: forall row. IsRow row => (row :. Col "id" Primary) -> Query ()

-- | Delete all rows in a database table
deleteAll :: forall row. IsRow row => Proxy row -> Query ()

-- | Delete one row with a given "id" column in a database table.
deleteOne :: forall row. IsRow row => Proxy row -> Col "id" Primary -> Query ()
testPerson :: PersonRow
instance GHC.Show.Show Database.Schema.Primary
instance GHC.Classes.Ord Database.Schema.Primary
instance GHC.Classes.Eq Database.Schema.Primary
instance GHC.Show.Show Database.Schema.SqlColType
instance GHC.Classes.Ord Database.Schema.SqlColType
instance GHC.Classes.Eq Database.Schema.SqlColType
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (a Database.Schema.:. b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a Database.Schema.:. b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (a Database.Schema.:. b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (a Database.Schema.:. b)
instance GHC.Show.Show a => GHC.Show.Show (Database.Schema.Col name a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Database.Schema.Col name a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Schema.Col name a)
instance GHC.Show.Show (Database.Schema.Table name)
instance GHC.Classes.Ord (Database.Schema.Table name)
instance GHC.Classes.Eq (Database.Schema.Table name)
instance GHC.Show.Show (Database.Schema.Query row)
instance GHC.Classes.Eq (Database.Schema.Query row)
instance Database.Schema.IsRow row => Database.Persist.Sql.Class.RawSql (Database.Schema.Wrap row)
instance GHC.TypeLits.KnownSymbol name => Database.Schema.IsRow (Database.Schema.Table name)
instance (Database.Schema.IsRow row, GHC.TypeLits.KnownSymbol name, Database.Schema.IsCol a) => Database.Schema.IsRow (row Database.Schema.:. Database.Schema.Col name a)
instance (Database.Persist.Class.PersistField.PersistField a, Database.Persist.Sql.Class.PersistFieldSql a) => Database.Schema.IsCol a
instance Database.Schema.IsCol Database.Schema.Primary
instance Database.Schema.IsCol GHC.Types.Int
instance Database.Schema.IsCol (GHC.Maybe.Maybe GHC.Types.Int)
instance Database.Persist.Class.PersistField.PersistField Database.Schema.Primary

module Database.Persist.Delta

-- | Construct a <a>Store</a> for <tt>Entity</tt>.
--   
--   FIXME: This function should also do "migrations", i.e. create the
--   database table in the first place.
newEntityStore :: forall row m. (PersistRecordBackend row SqlBackend, ToBackendKey SqlBackend row, Show row, MonadIO m) => m (Store SqlPersistM [DeltaDB Int row])

-- | Construct a <a>Store</a> from an SQL table.
--   
--   The unique IDs will be stored in a column "id" at the end of each row
--   in the database table.
newSqlStore :: (MonadIO m, IsRow row, IsRow (row :. Col "id" Primary), Show row) => m (Store SqlPersistM [DeltaDB Int row])

module Test.DBVar

-- | Randomly generate a sequence of updates
genUpdates :: Delta da => Gen (Base da) -> GenDelta da -> Gen (Updates da)

-- | Test whether <a>updateS</a> and <a>loadS</a> behave as expected.
--   
--   TODO: Shrinking of the update sequence.
prop_StoreUpdates :: (Monad m, Delta da, Eq (Base da), Buildable da, Show (Base da)) => (forall b. m b -> PropertyM IO b) -> Store m da -> Gen (Base da) -> GenDelta da -> PropertyM IO ()

-- | Given a value, generate a random delta starting from this value.
type GenDelta da = Base da -> Gen da

-- | A sequence of updates and values after updating. The update that is
--   applied *last* appears in the list *first*.
newtype Updates da
Updates :: [(Base da, da)] -> Updates da
instance GHC.Show.Show da => GHC.Show.Show (Test.DBVar.Updates da)
