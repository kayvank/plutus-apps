-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Connection layer between beam and postgres
--   
--   Beam driver for <a>PostgreSQL</a>, an advanced open-source RDBMS
@package beam-postgres
@version 0.5.3.0


-- | Data types for Postgres syntax. Access is given mainly for extension
--   modules. The types and definitions here are likely to change.
module Database.Beam.Postgres.Syntax
data PgSyntaxF f
[EmitByteString] :: ByteString -> f -> PgSyntaxF f
[EmitBuilder] :: Builder -> f -> PgSyntaxF f
[EscapeString] :: ByteString -> f -> PgSyntaxF f
[EscapeBytea] :: ByteString -> f -> PgSyntaxF f
[EscapeIdentifier] :: ByteString -> f -> PgSyntaxF f
type PgSyntaxM = F PgSyntaxF

-- | A piece of Postgres SQL syntax, which may contain embedded escaped
--   byte and text sequences. <a>PgSyntax</a> composes monoidally, and may
--   be created with <a>emit</a>, <a>emitBuilder</a>, <a>escapeString</a>,
--   <tt>escapBytea</tt>, and <a>escapeIdentifier</a>.
newtype PgSyntax
PgSyntax :: PgSyntaxM () -> PgSyntax
[buildPgSyntax] :: PgSyntax -> PgSyntaxM ()
emit :: ByteString -> PgSyntax
emitBuilder :: Builder -> PgSyntax
escapeString :: ByteString -> PgSyntax
escapeBytea :: ByteString -> PgSyntax
escapeIdentifier :: ByteString -> PgSyntax
pgParens :: PgSyntax -> PgSyntax
nextSyntaxStep :: PgSyntaxF f -> f

-- | Representation of an arbitrary Postgres command. This is the
--   combination of the command syntax (repesented by <a>PgSyntax</a>), as
--   well as the type of command (represented by <a>PgCommandType</a>). The
--   command type is necessary for us to know how to retrieve results from
--   the database.
data PgCommandSyntax
PgCommandSyntax :: PgCommandType -> PgSyntax -> PgCommandSyntax
[pgCommandType] :: PgCommandSyntax -> PgCommandType
[fromPgCommand] :: PgCommandSyntax -> PgSyntax
data PgCommandType
PgCommandTypeQuery :: PgCommandType
PgCommandTypeDdl :: PgCommandType
PgCommandTypeDataUpdate :: PgCommandType
PgCommandTypeDataUpdateReturning :: PgCommandType

-- | <a>IsSql92SelectSyntax</a> for Postgres
newtype PgSelectSyntax
PgSelectSyntax :: PgSyntax -> PgSelectSyntax
[fromPgSelect] :: PgSelectSyntax -> PgSyntax
newtype PgSelectSetQuantifierSyntax
PgSelectSetQuantifierSyntax :: PgSyntax -> PgSelectSetQuantifierSyntax
[fromPgSelectSetQuantifier] :: PgSelectSetQuantifierSyntax -> PgSyntax

-- | <a>IsSql92InsertSyntax</a> for Postgres
newtype PgInsertSyntax
PgInsertSyntax :: PgSyntax -> PgInsertSyntax
[fromPgInsert] :: PgInsertSyntax -> PgSyntax

-- | <a>IsSql92DeleteSyntax</a> for Postgres
newtype PgDeleteSyntax
PgDeleteSyntax :: PgSyntax -> PgDeleteSyntax
[fromPgDelete] :: PgDeleteSyntax -> PgSyntax

-- | <a>IsSql92UpdateSyntax</a> for Postgres
newtype PgUpdateSyntax
PgUpdateSyntax :: PgSyntax -> PgUpdateSyntax
[fromPgUpdate] :: PgUpdateSyntax -> PgSyntax
newtype PgExpressionSyntax
PgExpressionSyntax :: PgSyntax -> PgExpressionSyntax
[fromPgExpression] :: PgExpressionSyntax -> PgSyntax
newtype PgFromSyntax
PgFromSyntax :: PgSyntax -> PgFromSyntax
[fromPgFrom] :: PgFromSyntax -> PgSyntax
newtype PgTableNameSyntax
PgTableNameSyntax :: PgSyntax -> PgTableNameSyntax
[fromPgTableName] :: PgTableNameSyntax -> PgSyntax
newtype PgComparisonQuantifierSyntax
PgComparisonQuantifierSyntax :: PgSyntax -> PgComparisonQuantifierSyntax
[fromPgComparisonQuantifier] :: PgComparisonQuantifierSyntax -> PgSyntax
newtype PgExtractFieldSyntax
PgExtractFieldSyntax :: PgSyntax -> PgExtractFieldSyntax
[fromPgExtractField] :: PgExtractFieldSyntax -> PgSyntax
newtype PgProjectionSyntax
PgProjectionSyntax :: PgSyntax -> PgProjectionSyntax
[fromPgProjection] :: PgProjectionSyntax -> PgSyntax
newtype PgGroupingSyntax
PgGroupingSyntax :: PgSyntax -> PgGroupingSyntax
[fromPgGrouping] :: PgGroupingSyntax -> PgSyntax
data PgOrderingSyntax
PgOrderingSyntax :: PgSyntax -> Maybe PgNullOrdering -> PgOrderingSyntax
[pgOrderingSyntax] :: PgOrderingSyntax -> PgSyntax
[pgOrderingNullOrdering] :: PgOrderingSyntax -> Maybe PgNullOrdering
newtype PgValueSyntax
PgValueSyntax :: PgSyntax -> PgValueSyntax
[fromPgValue] :: PgValueSyntax -> PgSyntax
newtype PgTableSourceSyntax
PgTableSourceSyntax :: PgSyntax -> PgTableSourceSyntax
[fromPgTableSource] :: PgTableSourceSyntax -> PgSyntax
newtype PgFieldNameSyntax
PgFieldNameSyntax :: PgSyntax -> PgFieldNameSyntax
[fromPgFieldName] :: PgFieldNameSyntax -> PgSyntax
newtype PgAggregationSetQuantifierSyntax
PgAggregationSetQuantifierSyntax :: PgSyntax -> PgAggregationSetQuantifierSyntax
[fromPgAggregationSetQuantifier] :: PgAggregationSetQuantifierSyntax -> PgSyntax
newtype PgInsertValuesSyntax
PgInsertValuesSyntax :: PgSyntax -> PgInsertValuesSyntax
[fromPgInsertValues] :: PgInsertValuesSyntax -> PgSyntax
newtype PgInsertOnConflictSyntax
PgInsertOnConflictSyntax :: PgSyntax -> PgInsertOnConflictSyntax
[fromPgInsertOnConflict] :: PgInsertOnConflictSyntax -> PgSyntax
newtype PgInsertOnConflictTargetSyntax
PgInsertOnConflictTargetSyntax :: PgSyntax -> PgInsertOnConflictTargetSyntax
[fromPgInsertOnConflictTarget] :: PgInsertOnConflictTargetSyntax -> PgSyntax
newtype PgConflictActionSyntax
PgConflictActionSyntax :: PgSyntax -> PgConflictActionSyntax
[fromPgConflictAction] :: PgConflictActionSyntax -> PgSyntax
newtype PgCreateTableSyntax
PgCreateTableSyntax :: PgSyntax -> PgCreateTableSyntax
[fromPgCreateTable] :: PgCreateTableSyntax -> PgSyntax
data PgTableOptionsSyntax
PgTableOptionsSyntax :: PgSyntax -> PgSyntax -> PgTableOptionsSyntax
newtype PgColumnSchemaSyntax
PgColumnSchemaSyntax :: PgSyntax -> PgColumnSchemaSyntax
[fromPgColumnSchema] :: PgColumnSchemaSyntax -> PgSyntax
data PgDataTypeSyntax
PgDataTypeSyntax :: PgDataTypeDescr -> PgSyntax -> BeamSerializedDataType -> PgDataTypeSyntax
[pgDataTypeDescr] :: PgDataTypeSyntax -> PgDataTypeDescr
[fromPgDataType] :: PgDataTypeSyntax -> PgSyntax
[pgDataTypeSerialized] :: PgDataTypeSyntax -> BeamSerializedDataType
data PgColumnConstraintDefinitionSyntax
PgColumnConstraintDefinitionSyntax :: PgSyntax -> BeamSerializedConstraintDefinition -> PgColumnConstraintDefinitionSyntax
[fromPgColumnConstraintDefinition] :: PgColumnConstraintDefinitionSyntax -> PgSyntax
[pgColumnConstraintDefinitionSerialized] :: PgColumnConstraintDefinitionSyntax -> BeamSerializedConstraintDefinition
data PgColumnConstraintSyntax
PgColumnConstraintSyntax :: PgSyntax -> BeamSerializedConstraint -> PgColumnConstraintSyntax
[fromPgColumnConstraint] :: PgColumnConstraintSyntax -> PgSyntax
[pgColumnConstraintSerialized] :: PgColumnConstraintSyntax -> BeamSerializedConstraint
newtype PgTableConstraintSyntax
PgTableConstraintSyntax :: PgSyntax -> PgTableConstraintSyntax
[fromPgTableConstraint] :: PgTableConstraintSyntax -> PgSyntax
data PgMatchTypeSyntax
PgMatchTypeSyntax :: PgSyntax -> BeamSerializedMatchType -> PgMatchTypeSyntax
[fromPgMatchType] :: PgMatchTypeSyntax -> PgSyntax
[pgMatchTypeSerialized] :: PgMatchTypeSyntax -> BeamSerializedMatchType
data PgReferentialActionSyntax
PgReferentialActionSyntax :: PgSyntax -> BeamSerializedReferentialAction -> PgReferentialActionSyntax
[fromPgReferentialAction] :: PgReferentialActionSyntax -> PgSyntax
[pgReferentialActionSerialized] :: PgReferentialActionSyntax -> BeamSerializedReferentialAction
newtype PgAlterTableSyntax
PgAlterTableSyntax :: PgSyntax -> PgAlterTableSyntax
[fromPgAlterTable] :: PgAlterTableSyntax -> PgSyntax
newtype PgAlterTableActionSyntax
PgAlterTableActionSyntax :: PgSyntax -> PgAlterTableActionSyntax
[fromPgAlterTableAction] :: PgAlterTableActionSyntax -> PgSyntax
newtype PgAlterColumnActionSyntax
PgAlterColumnActionSyntax :: PgSyntax -> PgAlterColumnActionSyntax
[fromPgAlterColumnAction] :: PgAlterColumnActionSyntax -> PgSyntax
newtype PgWindowFrameSyntax
PgWindowFrameSyntax :: PgSyntax -> PgWindowFrameSyntax
[fromPgWindowFrame] :: PgWindowFrameSyntax -> PgSyntax
newtype PgWindowFrameBoundsSyntax
PgWindowFrameBoundsSyntax :: PgSyntax -> PgWindowFrameBoundsSyntax
[fromPgWindowFrameBounds] :: PgWindowFrameBoundsSyntax -> PgSyntax
newtype PgWindowFrameBoundSyntax
PgWindowFrameBoundSyntax :: (ByteString -> PgSyntax) -> PgWindowFrameBoundSyntax
[fromPgWindowFrameBound] :: PgWindowFrameBoundSyntax -> ByteString -> PgSyntax
data PgSelectLockingClauseSyntax
PgSelectLockingClauseSyntax :: PgSelectLockingStrength -> [Text] -> Maybe PgSelectLockingOptions -> PgSelectLockingClauseSyntax
[pgSelectLockingClauseStrength] :: PgSelectLockingClauseSyntax -> PgSelectLockingStrength
[pgSelectLockingTables] :: PgSelectLockingClauseSyntax -> [Text]
[pgSelectLockingClauseOptions] :: PgSelectLockingClauseSyntax -> Maybe PgSelectLockingOptions

-- | Specifies the level of lock that will be taken against a row. See
--   <a>the manual section</a> for more information.
data PgSelectLockingStrength

-- | <pre>
--   UPDATE
--   </pre>
PgSelectLockingStrengthUpdate :: PgSelectLockingStrength

-- | <pre>
--   NO KEY UPDATE
--   </pre>
PgSelectLockingStrengthNoKeyUpdate :: PgSelectLockingStrength

-- | <pre>
--   SHARE
--   </pre>
PgSelectLockingStrengthShare :: PgSelectLockingStrength

-- | <pre>
--   KEY SHARE
--   </pre>
PgSelectLockingStrengthKeyShare :: PgSelectLockingStrength

-- | Specifies how we should handle lock conflicts.
--   
--   See <a>the manual section</a> for more information
data PgSelectLockingOptions

-- | <tt>NOWAIT</tt>. Report an error rather than waiting for the lock
PgSelectLockingOptionsNoWait :: PgSelectLockingOptions

-- | <tt>SKIP LOCKED</tt>. Rather than wait for a lock, skip the row
--   instead
PgSelectLockingOptionsSkipLocked :: PgSelectLockingOptions
fromPgSelectLockingClause :: PgSelectLockingClauseSyntax -> PgSyntax
pgSelectStmt :: PgSelectTableSyntax -> [PgOrderingSyntax] -> Maybe Integer -> Maybe Integer -> Maybe PgSelectLockingClauseSyntax -> PgSelectSyntax
defaultPgValueSyntax :: ToField a => a -> PgValueSyntax
data PgDataTypeDescr
PgDataTypeDescrOid :: Oid -> Maybe Int32 -> PgDataTypeDescr
PgDataTypeDescrDomain :: Text -> PgDataTypeDescr
data PgHasEnum
PgHasEnum :: Text -> [Text] -> PgHasEnum
pgCreateExtensionSyntax :: Text -> PgCommandSyntax
pgDropExtensionSyntax :: Text -> PgCommandSyntax
pgCreateEnumSyntax :: Text -> [PgValueSyntax] -> PgCommandSyntax
pgDropTypeSyntax :: Text -> PgCommandSyntax
pgSimpleMatchSyntax :: PgMatchTypeSyntax
pgSelectSetQuantifierDistinctOn :: [PgExpressionSyntax] -> PgSelectSetQuantifierSyntax
pgDataTypeJSON :: Value -> BeamSerializedDataType
pgTsQueryType :: PgDataTypeSyntax
pgTsVectorType :: PgDataTypeSyntax
pgJsonType :: PgDataTypeSyntax
pgJsonbType :: PgDataTypeSyntax
pgUuidType :: PgDataTypeSyntax
pgMoneyType :: PgDataTypeSyntax
pgTsQueryTypeInfo :: TypeInfo

-- | Postgres TypeInfo for tsvector TODO Is the Oid stable from postgres
--   instance to postgres instance?
pgTsVectorTypeInfo :: TypeInfo
pgByteaType :: PgDataTypeSyntax
pgTextType :: PgDataTypeSyntax
pgUnboundedArrayType :: PgDataTypeSyntax -> PgDataTypeSyntax
pgSerialType :: PgDataTypeSyntax
pgSmallSerialType :: PgDataTypeSyntax
pgBigSerialType :: PgDataTypeSyntax
pgPointType :: PgDataTypeSyntax
pgLineType :: PgDataTypeSyntax
pgLineSegmentType :: PgDataTypeSyntax
pgBoxType :: PgDataTypeSyntax
pgQuotedIdentifier :: Text -> PgSyntax
pgSepBy :: PgSyntax -> [PgSyntax] -> PgSyntax
pgDebugRenderSyntax :: PgSyntax -> IO ()
pgRenderSyntaxScript :: PgSyntax -> ByteString
pgBuildAction :: [Action] -> PgSyntax
pgBinOp :: ByteString -> PgExpressionSyntax -> PgExpressionSyntax -> PgExpressionSyntax
pgCompOp :: ByteString -> Maybe PgComparisonQuantifierSyntax -> PgExpressionSyntax -> PgExpressionSyntax -> PgExpressionSyntax
pgUnOp :: ByteString -> PgExpressionSyntax -> PgExpressionSyntax
pgPostFix :: ByteString -> PgExpressionSyntax -> PgExpressionSyntax
pgTestSyntax :: PgSyntax -> [PgSyntaxPrim]
data PostgresInaccessible
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgCommandType
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance GHC.Base.Monoid (Database.Beam.Query.CustomSQL.CustomSqlSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax)
instance GHC.Generics.Generic Database.Beam.Postgres.Syntax.PgNullOrdering
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgNullOrdering
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgNullOrdering
instance GHC.Generics.Generic Database.Beam.Postgres.Syntax.PgSelectLockingStrength
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgSelectLockingStrength
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgSelectLockingStrength
instance GHC.Generics.Generic Database.Beam.Postgres.Syntax.PgSelectLockingOptions
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgSelectLockingOptions
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgSelectLockingOptions
instance GHC.Generics.Generic Database.Beam.Postgres.Syntax.PgDataTypeDescr
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgDataTypeDescr
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgDataTypeDescr
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgColumnSchemaSyntax
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgColumnSchemaSyntax
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgDataTypeSyntax
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgColumnConstraintDefinitionSyntax
instance GHC.Generics.Generic Database.Beam.Postgres.Syntax.PgHasEnum
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgHasEnum
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgHasEnum
instance GHC.Enum.Bounded Database.Beam.Postgres.Syntax.PgEscapeType
instance GHC.Enum.Enum Database.Beam.Postgres.Syntax.PgEscapeType
instance GHC.Classes.Ord Database.Beam.Postgres.Syntax.PgEscapeType
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgEscapeType
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgEscapeType
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgSyntaxPrim
instance GHC.Base.Functor Database.Beam.Postgres.Syntax.PgSyntaxF
instance Data.String.IsString Database.Beam.Postgres.Syntax.PgSyntaxPrim
instance Database.Beam.Migrate.Checks.HasDataTypeCreatedCheck Database.Beam.Postgres.Syntax.PgDataTypeSyntax
instance Data.Hashable.Class.Hashable Database.Beam.Postgres.Syntax.PgHasEnum
instance Database.Beam.Migrate.Types.Predicates.DatabasePredicate Database.Beam.Postgres.Syntax.PgHasEnum
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003WindowFrameBoundsSyntax Database.Beam.Postgres.Syntax.PgWindowFrameBoundsSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003WindowFrameBoundSyntax Database.Beam.Postgres.Syntax.PgWindowFrameBoundSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003WindowFrameSyntax Database.Beam.Postgres.Syntax.PgWindowFrameSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003ExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92AlterTableActionSyntax Database.Beam.Postgres.Syntax.PgAlterTableActionSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92AlterColumnActionSyntax Database.Beam.Postgres.Syntax.PgAlterColumnActionSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92AlterTableSyntax Database.Beam.Postgres.Syntax.PgAlterTableSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92DdlCommandSyntax Database.Beam.Postgres.Syntax.PgCommandSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92DropTableSyntax Database.Beam.Postgres.Syntax.PgDropTableSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ReferentialActionSyntax Database.Beam.Postgres.Syntax.PgReferentialActionSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnConstraintSyntax Database.Beam.Postgres.Syntax.PgColumnConstraintSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92MatchTypeSyntax Database.Beam.Postgres.Syntax.PgMatchTypeSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92CreateTableSyntax Database.Beam.Postgres.Syntax.PgCreateTableSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92TableConstraintSyntax Database.Beam.Postgres.Syntax.PgTableConstraintSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnConstraintDefinitionSyntax Database.Beam.Postgres.Syntax.PgColumnConstraintDefinitionSyntax
instance Database.Beam.Backend.SQL.SQL92.Sql92DisplaySyntax Database.Beam.Postgres.Syntax.PgColumnConstraintDefinitionSyntax
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgColumnConstraintDefinitionSyntax
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnSchemaSyntax Database.Beam.Postgres.Syntax.PgColumnSchemaSyntax
instance Data.Hashable.Class.Hashable Database.Beam.Postgres.Syntax.PgColumnConstraintDefinitionSyntax
instance Database.Beam.Migrate.SQL.SQL92.Sql92SerializableConstraintDefinitionSyntax Database.Beam.Postgres.Syntax.PgColumnConstraintDefinitionSyntax
instance Database.Beam.Backend.SQL.SQL92.Sql92DisplaySyntax Database.Beam.Postgres.Syntax.PgDataTypeSyntax
instance Data.Hashable.Class.Hashable Database.Beam.Postgres.Syntax.PgDataTypeSyntax
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgDataTypeSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92DataTypeSyntax Database.Beam.Postgres.Syntax.PgDataTypeSyntax
instance Database.Beam.Backend.SQL.SQL99.IsSql99DataTypeSyntax Database.Beam.Postgres.Syntax.PgDataTypeSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2008BigIntDataTypeSyntax Database.Beam.Postgres.Syntax.PgDataTypeSyntax
instance Database.Beam.Migrate.SQL.SQL92.Sql92SerializableDataTypeSyntax Database.Beam.Postgres.Syntax.PgDataTypeSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92ExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL92.Sql92DisplaySyntax Database.Beam.Postgres.Syntax.PgColumnSchemaSyntax
instance Data.Hashable.Class.Hashable Database.Beam.Postgres.Syntax.PgColumnSchemaSyntax
instance Data.Hashable.Class.Hashable Database.Beam.Postgres.Syntax.PgDataTypeDescr
instance Database.Beam.Backend.SQL.SQL92.IsSql92SelectSyntax Database.Beam.Postgres.Syntax.PgSelectSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92OrderingSyntax Database.Beam.Postgres.Syntax.PgOrderingSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003OrderingElementaryOLAPOperationsSyntax Database.Beam.Postgres.Syntax.PgOrderingSyntax
instance Database.Beam.Backend.SQL.SQL99.IsSql99CommonTableExpressionSelectSyntax Database.Beam.Postgres.Syntax.PgSelectSyntax
instance Database.Beam.Backend.SQL.SQL99.IsSql99RecursiveCommonTableExpressionSelectSyntax Database.Beam.Postgres.Syntax.PgSelectSyntax
instance Database.Beam.Backend.SQL.SQL99.IsSql99CommonTableExpressionSyntax Database.Beam.Postgres.Syntax.PgCommonTableExpressionSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92InsertSyntax Database.Beam.Postgres.Syntax.PgInsertSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92InsertValuesSyntax Database.Beam.Postgres.Syntax.PgInsertValuesSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92UpdateSyntax Database.Beam.Postgres.Syntax.PgUpdateSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92FieldNameSyntax Database.Beam.Postgres.Syntax.PgFieldNameSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92FromSyntax Database.Beam.Postgres.Syntax.PgFromSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92TableSourceSyntax Database.Beam.Postgres.Syntax.PgTableSourceSyntax
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Types.Bool
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Types.Double
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Types.Float
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Int.Int8
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Int.Int16
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Int.Int32
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Int.Int64
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Integer.Type.Integer
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Word.Word8
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Word.Word16
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Word.Word32
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Word.Word64
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.Text.Internal.Text
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.Text.Internal.Lazy.Text
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.Aeson.Types.Internal.Value
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Database.PostgreSQL.LibPQ.Oid.Oid
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.Time.Clock.Internal.UTCTime.UTCTime
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.Time.Calendar.Days.Day
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax [GHC.Types.Char]
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Database.PostgreSQL.Simple.HStore.Implementation.HStoreMap
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Database.PostgreSQL.Simple.HStore.Implementation.HStoreList
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Database.PostgreSQL.Simple.HStore.Implementation.HStoreBuilder
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Database.PostgreSQL.Simple.Time.Implementation.Date
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Database.PostgreSQL.Simple.Time.Implementation.LocalTimestamp
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Database.PostgreSQL.Simple.Time.Implementation.UTCTimestamp
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.Scientific.Scientific
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax (Data.CaseInsensitive.Internal.CI Data.Text.Internal.Text)
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax (Data.CaseInsensitive.Internal.CI Data.Text.Internal.Lazy.Text)
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Database.Beam.Backend.SQL.Types.SqlNull
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax x => Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax (GHC.Maybe.Maybe x)
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.ByteString.Internal.ByteString
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.ByteString.Lazy.Internal.ByteString
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax Data.UUID.Types.Internal.UUID
instance Database.PostgreSQL.Simple.ToField.ToField a => Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax (Data.Vector.Vector a)
instance (TypeError ...) => Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Types.Int
instance (TypeError ...) => Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Postgres.Syntax.PgValueSyntax GHC.Types.Word
instance Database.Beam.Backend.SQL.SQL92.IsSql92SelectTableSyntax Database.Beam.Postgres.Syntax.PgSelectTableSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92GroupingSyntax Database.Beam.Postgres.Syntax.PgGroupingSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92ProjectionSyntax Database.Beam.Postgres.Syntax.PgProjectionSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92ExtractFieldSyntax Database.Beam.Postgres.Syntax.PgExtractFieldSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92QuantifierSyntax Database.Beam.Postgres.Syntax.PgComparisonQuantifierSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92TableNameSyntax Database.Beam.Postgres.Syntax.PgTableNameSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92DeleteSyntax Database.Beam.Postgres.Syntax.PgDeleteSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92FromOuterJoinSyntax Database.Beam.Postgres.Syntax.PgFromSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92AggregationSetQuantifierSyntax Database.Beam.Postgres.Syntax.PgSelectSetQuantifierSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92AggregationExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92AggregationSetQuantifierSyntax Database.Beam.Postgres.Syntax.PgAggregationSetQuantifierSyntax
instance Database.Beam.Query.CustomSQL.IsCustomSqlSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance GHC.Base.Semigroup (Database.Beam.Query.CustomSQL.CustomSqlSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax)
instance Data.String.IsString (Database.Beam.Query.CustomSQL.CustomSqlSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax)
instance Database.Beam.Backend.SQL.SQL99.IsSql99FunctionExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL99.IsSql99ExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL99.IsSql99ConcatExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003EnhancedNumericFunctionsExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003ExpressionAdvancedOLAPOperationsSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003ExpressionElementaryOLAPOperationsSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003NtileExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003LeadAndLagExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003FirstValueAndLastValueExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003NthValueExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL99.IsSql99AggregationExpressionSyntax Database.Beam.Postgres.Syntax.PgExpressionSyntax
instance Database.Beam.Backend.SQL.SQL92.IsSql92Syntax Database.Beam.Postgres.Syntax.PgCommandSyntax
instance Data.Hashable.Class.Hashable Database.Beam.Postgres.Syntax.PgSyntax
instance Database.Beam.Backend.SQL.SQL92.Sql92DisplaySyntax Database.Beam.Postgres.Syntax.PgSyntax
instance GHC.Base.Semigroup Database.Beam.Postgres.Syntax.PgSyntax
instance GHC.Base.Monoid Database.Beam.Postgres.Syntax.PgSyntax
instance GHC.Classes.Eq Database.Beam.Postgres.Syntax.PgSyntax
instance GHC.Show.Show Database.Beam.Postgres.Syntax.PgSyntax
instance Data.Functor.Classes.Eq1 Database.Beam.Postgres.Syntax.PgSyntaxF
instance GHC.Classes.Eq f => GHC.Classes.Eq (Database.Beam.Postgres.Syntax.PgSyntaxF f)


-- | Module providing (almost) full support for Postgres query and data
--   manipulation statements. These functions shadow the functions in
--   <a>Database.Beam.Query</a> and provide a strict superset of
--   functionality. They map 1-to-1 with the underlying Postgres support.
module Database.Beam.Postgres.Full

-- | Combines the result of a query along with a set of locked tables. Used
--   as a return value for the <a>lockingFor_</a> function.
data PgWithLocking s a

-- | An explicit lock against some tables. You can create a value of this
--   type using the <a>locked_</a> function. You can combine these values
--   monoidally to combine multiple locks for use with the
--   <a>withLocks_</a> function.
data PgLockedTables s

-- | Specifies the level of lock that will be taken against a row. See
--   <a>the manual section</a> for more information.
data PgSelectLockingStrength

-- | <pre>
--   UPDATE
--   </pre>
PgSelectLockingStrengthUpdate :: PgSelectLockingStrength

-- | <pre>
--   NO KEY UPDATE
--   </pre>
PgSelectLockingStrengthNoKeyUpdate :: PgSelectLockingStrength

-- | <pre>
--   SHARE
--   </pre>
PgSelectLockingStrengthShare :: PgSelectLockingStrength

-- | <pre>
--   KEY SHARE
--   </pre>
PgSelectLockingStrengthKeyShare :: PgSelectLockingStrength

-- | Specifies how we should handle lock conflicts.
--   
--   See <a>the manual section</a> for more information
data PgSelectLockingOptions

-- | <tt>NOWAIT</tt>. Report an error rather than waiting for the lock
PgSelectLockingOptionsNoWait :: PgSelectLockingOptions

-- | <tt>SKIP LOCKED</tt>. Rather than wait for a lock, skip the row
--   instead
PgSelectLockingOptionsSkipLocked :: PgSelectLockingOptions

-- | Like <a>lockingFor_</a>, but does not require an explicit set of
--   locked tables. This produces an empty <tt>FOR .. OF</tt> clause.
lockingAllTablesFor_ :: (Database Postgres db, Projectible Postgres a, ThreadRewritable (QNested s) a) => PgSelectLockingStrength -> Maybe PgSelectLockingOptions -> Q Postgres db (QNested s) a -> Q Postgres db s (WithRewrittenThread (QNested s) s a)

-- | Lock some tables during the execution of a query. This is rather
--   complicated, and there are several usage examples in <a>the user
--   guide</a>
--   
--   The Postgres locking clause is rather complex, and beam currently does
--   not check several pre-conditions. It is assumed you kinda know what
--   you're doing.
--   
--   Things which postgres doesn't like, but beam will do
--   
--   <ul>
--   <li>Using aggregates within a query that has a locking clause</li>
--   <li>Using <tt>UNION</tt>, <tt>INTERSECT</tt>, or <tt>EXCEPT</tt></li>
--   </ul>
--   
--   See <a>here</a> for more details.
--   
--   This function accepts a locking strength (<tt>UPDATE</tt>,
--   <tt>SHARE</tt>, <tt>KEY SHARE</tt>, etc), an optional locking option
--   (<tt>NOWAIT</tt> or <tt>SKIP LOCKED</tt>), and a query whose rows to
--   lock. The query should return its result wrapped in
--   <a>PgWithLocking</a>, via the <a>withLocks_</a> or <a>lockAll_</a>
--   function.
--   
--   If you want to use the most common behavior (lock all rows in every
--   table mentioned), the <a>lockingAllTablesFor_</a> function may be what
--   you're after.
lockingFor_ :: forall a db s. (Database Postgres db, Projectible Postgres a, ThreadRewritable (QNested s) a) => PgSelectLockingStrength -> Maybe PgSelectLockingOptions -> Q Postgres db (QNested s) (PgWithLocking (QNested s) a) -> Q Postgres db s (WithRewrittenThread (QNested s) s a)

-- | Join with a table while locking it explicitly. Provides a
--   <a>PgLockedTables</a> value that can be used with <a>withLocks_</a> to
--   explicitly lock a table during a <tt>SELECT</tt> statement
locked_ :: (Beamable tbl, Database Postgres db) => DatabaseEntity Postgres db (TableEntity tbl) -> Q Postgres db s (PgLockedTables s, tbl (QExpr Postgres s))

-- | Use with <a>lockingFor_</a> to lock all tables mentioned in the query
lockAll_ :: a -> PgWithLocking s a

-- | Return and lock the given tables. Typically used as an infix operator.
--   See the <a>the user guide</a> for usage examples
withLocks_ :: a -> PgLockedTables s -> PgWithLocking s a

-- | Postgres <tt>LATERAL JOIN</tt> support
--   
--   Allows the use of variables introduced on the left side of a
--   <tt>JOIN</tt> to be used on the right hand side.
--   
--   Because of the default scoping rules, we can't use the typical monadic
--   bind (<tt>&gt;&gt;=</tt>) operator to create this join.
--   
--   Instead, <a>lateral_</a> takes two arguments. The first is the left
--   hand side of the <tt>JOIN</tt>. The second is a function that takes
--   the result of the first join and uses those variables to create the
--   right hand side.
--   
--   For example, to join table A with a subquery that returns the first
--   three rows in B which matches a column in A, ordered by another column
--   in B:
--   
--   <pre>
--   lateral_ (_tableA database) $ \tblA -&gt;
--     limit_ 3 $
--     ordering_ (\(_, b) -&gt; asc_ (_bField2 b)) $ do
--       b &lt;- _tableB database
--       guard_ (_bField1 b ==. _aField1 a)
--       pure (a, b0
--   </pre>
lateral_ :: forall s a b db. (ThreadRewritable s a, ThreadRewritable (QNested s) b, Projectible Postgres b) => a -> (WithRewrittenThread s (QNested s) a -> Q Postgres db (QNested s) b) -> Q Postgres db s (WithRewrittenThread (QNested s) s b)

-- | A <tt>beam-postgres</tt>-specific version of <a>insert</a>, which
--   provides fuller support for the much richer Postgres <tt>INSERT</tt>
--   syntax. This allows you to specify <tt>ON CONFLICT</tt> actions. For
--   even more complete support, see <a>insertReturning</a>.
insert :: DatabaseEntity Postgres db (TableEntity table) -> SqlInsertValues Postgres (table (QExpr Postgres s)) -> PgInsertOnConflict table -> SqlInsert Postgres table

-- | The full Postgres <tt>INSERT</tt> syntax, supporting conflict actions
--   and the <tt>RETURNING CLAUSE</tt>. See <a>PgInsertOnConflict</a> for
--   how to specify a conflict action or provide <a>onConflictDefault</a>
--   to preserve the behavior without any <tt>ON CONFLICT</tt> clause. The
--   last argument takes a newly inserted row and returns the expression to
--   be returned as part of the <tt>RETURNING</tt> clause. For a
--   backend-agnostic version of this functionality see
--   <a>MonadBeamInsertReturning</a>. Use <tt>runInsertReturning</tt> to
--   get the results.
insertReturning :: Projectible Postgres a => DatabaseEntity Postgres be (TableEntity table) -> SqlInsertValues Postgres (table (QExpr Postgres s)) -> PgInsertOnConflict table -> Maybe (table (QExpr Postgres PostgresInaccessible) -> a) -> PgInsertReturning (QExprToIdentity a)

-- | The Postgres <tt>DEFAULT VALUES</tt> clause for the <tt>INSERT</tt>
--   command.
insertDefaults :: SqlInsertValues Postgres tbl
runPgInsertReturningList :: (MonadBeam be m, BeamSqlBackendSyntax be ~ PgCommandSyntax, FromBackendRow be a) => PgInsertReturning a -> m [a]

-- | The most general kind of <tt>INSERT</tt> that postgres can perform
data PgInsertReturning a
PgInsertReturning :: PgSyntax -> PgInsertReturning a
PgInsertReturningEmpty :: PgInsertReturning a

-- | What to do when an <tt>INSERT</tt> statement inserts a row into the
--   table <tt>tbl</tt> that violates a constraint.
newtype PgInsertOnConflict (tbl :: (* -> *) -> *)
PgInsertOnConflict :: (tbl (QField QInternal) -> PgInsertOnConflictSyntax) -> PgInsertOnConflict (tbl :: (* -> *) -> *)

-- | By default, Postgres will throw an error when a conflict is detected.
--   This preserves that functionality.
onConflictDefault :: PgInsertOnConflict tbl

-- | Tells postgres what to do on an <tt>INSERT</tt> conflict. The first
--   argument is the type of conflict to provide an action for. For
--   example, to only provide an action for certain fields, use
--   <a>conflictingFields</a>. Or to only provide an action over certain
--   fields where a particular condition is met, use
--   <a>conflictingFields</a>. If you have a particular constraint
--   violation in mind, use <a>conflictingConstraint</a>. To perform an
--   action on any conflict, use <a>anyConflict</a>.
--   
--   See the <a>Postgres documentation</a>.
onConflict :: Beamable tbl => SqlConflictTarget Postgres tbl -> SqlConflictAction Postgres tbl -> PgInsertOnConflict tbl

-- | Perform the action only if the given named constraint is violated
conflictingConstraint :: Text -> SqlConflictTarget Postgres tbl
class BeamSqlBackend be => BeamHasInsertOnConflict be where {
    
    -- | Specifies the kind of constraint that must be violated for the action
    --   to occur
    data family SqlConflictTarget be (table :: Type -> Type -> Type);
    
    -- | What to do when an <tt>INSERT</tt> statement inserts a row into the
    --   table <tt>tbl</tt> that violates a constraint.
    data family SqlConflictAction be (table :: Type -> Type -> Type);
}
insertOnConflict :: forall table (db :: (Type -> Type) -> Type) s. (BeamHasInsertOnConflict be, Beamable table) => DatabaseEntity be db (TableEntity table) -> SqlInsertValues be (table (QExpr be s)) -> SqlConflictTarget be table -> SqlConflictAction be table -> SqlInsert be table
anyConflict :: forall (table :: (Type -> Type) -> Type). BeamHasInsertOnConflict be => SqlConflictTarget be table
conflictingFields :: (BeamHasInsertOnConflict be, Projectible be proj) => (table (QExpr be QInternal) -> proj) -> SqlConflictTarget be table
conflictingFieldsWhere :: (BeamHasInsertOnConflict be, Projectible be proj) => (table (QExpr be QInternal) -> proj) -> (forall s. () => table (QExpr be s) -> QExpr be s Bool) -> SqlConflictTarget be table
onConflictDoNothing :: forall (table :: (Type -> Type) -> Type). BeamHasInsertOnConflict be => SqlConflictAction be table
onConflictUpdateSet :: (BeamHasInsertOnConflict be, Beamable table) => (forall s. () => table (QField s) -> table (QExpr be s) -> QAssignment be s) -> SqlConflictAction be table
onConflictUpdateSetWhere :: (BeamHasInsertOnConflict be, Beamable table) => (forall s. () => table (QField s) -> table (QExpr be s) -> QAssignment be s) -> (forall s. () => table (QField s) -> table (QExpr be s) -> QExpr be s Bool) -> SqlConflictAction be table
onConflictUpdateAll :: forall be (table :: (Type -> Type) -> Type). (BeamHasInsertOnConflict be, Beamable table) => SqlConflictAction be table
onConflictUpdateInstead :: (BeamHasInsertOnConflict be, Beamable table, ProjectibleWithPredicate AnyType () (InaccessibleQAssignment be) proj) => (table (Const (InaccessibleQAssignment be) :: Type -> Type) -> proj) -> SqlConflictAction be table

-- | The most general kind of <tt>UPDATE</tt> that postgres can perform
--   
--   You can build this from a <a>SqlUpdate</a> by using <a>returning</a>
--   
--   <pre>
--   update tbl where `returning` projection
--   </pre>
--   
--   Run the result with <a>runPgUpdateReturningList</a>
data PgUpdateReturning a
PgUpdateReturning :: PgSyntax -> PgUpdateReturning a
PgUpdateReturningEmpty :: PgUpdateReturning a
runPgUpdateReturningList :: (MonadBeam be m, BeamSqlBackendSyntax be ~ PgCommandSyntax, FromBackendRow be a) => PgUpdateReturning a -> m [a]

-- | Postgres <tt>UPDATE ... RETURNING</tt> statement support. The last
--   argument takes the newly inserted row and returns the values to be
--   returned. Use <tt>runUpdateReturning</tt> to get the results.
updateReturning :: Projectible Postgres a => DatabaseEntity Postgres be (TableEntity table) -> (forall s. table (QField s) -> QAssignment Postgres s) -> (forall s. table (QExpr Postgres s) -> QExpr Postgres s Bool) -> (table (QExpr Postgres PostgresInaccessible) -> a) -> PgUpdateReturning (QExprToIdentity a)

-- | The most general kind of <tt>DELETE</tt> that postgres can perform
--   
--   You can build this from a <a>SqlDelete</a> by using <a>returning</a>
--   
--   <pre>
--   delete tbl where `returning` projection
--   </pre>
--   
--   Run the result with <a>runPgDeleteReturningList</a>
newtype PgDeleteReturning a
PgDeleteReturning :: PgSyntax -> PgDeleteReturning a
runPgDeleteReturningList :: (MonadBeam be m, BeamSqlBackendSyntax be ~ PgCommandSyntax, FromBackendRow be a) => PgDeleteReturning a -> m [a]

-- | Postgres <tt>DELETE ... RETURNING</tt> statement support. The last
--   argument takes the newly inserted row and returns the values to be
--   returned. Use <tt>runDeleteReturning</tt> to get the results.
deleteReturning :: Projectible Postgres a => DatabaseEntity Postgres be (TableEntity table) -> (forall s. table (QExpr Postgres s) -> QExpr Postgres s Bool) -> (table (QExpr Postgres PostgresInaccessible) -> a) -> PgDeleteReturning (QExprToIdentity a)
class PgReturning cmd where {
    type family PgReturningType cmd :: * -> *;
}
returning :: (PgReturning cmd, Beamable tbl, Projectible Postgres a) => cmd Postgres tbl -> (tbl (QExpr Postgres PostgresInaccessible) -> a) -> PgReturningType cmd (QExprToIdentity a)
instance GHC.Base.Monoid (Database.Beam.Postgres.Full.PgLockedTables s)
instance GHC.Base.Semigroup (Database.Beam.Postgres.Full.PgLockedTables s)
instance Database.Beam.Postgres.Full.PgReturning Database.Beam.Query.SqlInsert
instance Database.Beam.Postgres.Full.PgReturning Database.Beam.Query.SqlUpdate
instance Database.Beam.Postgres.Full.PgReturning Database.Beam.Query.SqlDelete
instance Database.Beam.Query.Internal.ProjectibleWithPredicate c be res a => Database.Beam.Query.Internal.ProjectibleWithPredicate c be res (Database.Beam.Postgres.Full.PgWithLocking s a)
instance Database.Beam.Backend.SQL.BeamExtensions.BeamHasInsertOnConflict Database.Beam.Postgres.Types.Postgres

module Database.Beam.Postgres.CustomTypes
data PgType a
newtype PgTypeCheck
PgTypeCheck :: (Text -> SomeDatabasePredicate) -> PgTypeCheck
data PgDataTypeSchema a
class IsPgCustomDataType a
pgDataTypeName :: IsPgCustomDataType a => Proxy a -> Text
pgDataTypeDescription :: IsPgCustomDataType a => PgDataTypeSchema a
data PgHasEnum
PgHasEnum :: Text -> [Text] -> PgHasEnum
class HasSqlValueSyntax expr ty
class BeamBackend be => FromBackendRow be a
pgCustomEnumSchema :: HasSqlValueSyntax PgValueSyntax a => [a] -> PgDataTypeSchema a
pgBoundedEnumSchema :: (Enum a, Bounded a, HasSqlValueSyntax PgValueSyntax a) => PgDataTypeSchema a
pgCustomEnumActionProvider :: ActionProvider Postgres
pgCreateEnumActionProvider :: ActionProvider Postgres
pgDropEnumActionProvider :: ActionProvider Postgres
pgChecksForTypeSchema :: PgDataTypeSchema a -> [PgTypeCheck]
pgEnumValueSyntax :: (a -> String) -> a -> PgValueSyntax
pgParseEnum :: (Enum a, Bounded a) => (a -> String) -> FromBackendRowM Postgres a
createEnum :: forall a db. (HasSqlValueSyntax PgValueSyntax a, Enum a, Bounded a) => Text -> Migration Postgres (CheckedDatabaseEntity Postgres db (PgType a))
beamTypeForCustomPg :: CheckedDatabaseEntity Postgres db (PgType a) -> DataType Postgres a
instance Database.Beam.Backend.SQL.Row.FromBackendRow Database.Beam.Postgres.Types.Postgres Database.Beam.Postgres.CustomTypes.PgRawString
instance Database.PostgreSQL.Simple.FromField.FromField Database.Beam.Postgres.CustomTypes.PgRawString
instance Database.Beam.Schema.Tables.IsDatabaseEntity Database.Beam.Postgres.Types.Postgres (Database.Beam.Postgres.CustomTypes.PgType a)
instance Database.Beam.Migrate.Types.CheckedEntities.IsCheckedDatabaseEntity Database.Beam.Postgres.Types.Postgres (Database.Beam.Postgres.CustomTypes.PgType a)
instance Database.Beam.Schema.Tables.RenamableWithRule (Database.Beam.Schema.Tables.FieldRenamer (Database.Beam.Schema.Tables.DatabaseEntityDescriptor Database.Beam.Postgres.Types.Postgres (Database.Beam.Postgres.CustomTypes.PgType a)))


-- | Migrations support for beam-postgres. See <a>Database.Beam.Migrate</a>
--   for more information on beam migrations.
module Database.Beam.Postgres.Migrate

-- | Representation of an arbitrary Postgres command. This is the
--   combination of the command syntax (repesented by <a>PgSyntax</a>), as
--   well as the type of command (represented by <a>PgCommandType</a>). The
--   command type is necessary for us to know how to retrieve results from
--   the database.
data PgCommandSyntax

-- | Top-level migration backend for use by <tt>beam-migrate</tt> tools
migrationBackend :: BeamMigrationBackend Postgres Pg

-- | <tt>BeamDeserializers</tt> for postgres-specific types:
--   
--   <ul>
--   <li><a>bytea</a></li>
--   <li><a>smallserial</a></li>
--   <li><a>serial</a></li>
--   <li><a>bigserial</a></li>
--   <li><a>tsvector</a></li>
--   <li><a>tsquery</a></li>
--   <li><a>text</a></li>
--   <li><a>json</a></li>
--   <li><a>jsonb</a></li>
--   <li><a>uuid</a></li>
--   <li><a>money</a></li>
--   </ul>
postgresDataTypeDeserializers :: BeamDeserializers Postgres

-- | Converts postgres <tt>DatabasePredicate</tt>s to
--   <tt>DatabasePredicate</tt>s in the Haskell syntax. Allows automatic
--   generation of Haskell schemas from postgres constraints.
pgPredConverter :: HaskellPredicateConverter
getDbConstraints :: Connection -> IO [SomeDatabasePredicate]
getDbConstraintsForSchemas :: Maybe [String] -> Connection -> IO [SomeDatabasePredicate]

-- | Turn a <a>PgDataTypeSyntax</a> into the corresponding
--   <a>HsDataType</a>. This is a best effort guess, and may fail on more
--   exotic types. Feel free to send PRs to make this function more robust!
pgTypeToHs :: PgDataTypeSyntax -> Maybe HsDataType

-- | Turn a series of <a>MigrationSteps</a> into a line-by-line array of
--   <a>ByteString</a>s suitable for writing to a script.
migrateScript :: MigrationSteps Postgres () a' -> [ByteString]

-- | Write the migration given by the <a>MigrationSteps</a> to a file.
writeMigrationScript :: FilePath -> MigrationSteps Postgres () a -> IO ()
pgDataTypeFromAtt :: ByteString -> Oid -> Maybe Int32 -> Maybe PgDataTypeSyntax

-- | <a>DataType</a> for <tt>tsquery</tt>. See <a>TsQuery</a> for more
--   information
tsquery :: DataType Postgres TsQuery

-- | <a>DataType</a> for <tt>tsvector</tt>. See <a>TsVector</a> for more
--   information
tsvector :: DataType Postgres TsVector

-- | <a>DataType</a> for Postgres <tt>TEXT</tt>.
--   <tt>characterLargeObject</tt> is also mapped to this data type
text :: DataType Postgres Text

-- | <a>DataType</a> for Postgres <tt>BYTEA</tt>.
--   <tt>binaryLargeObject</tt> is also mapped to this data type
bytea :: DataType Postgres ByteString

-- | <a>DataType</a> for a Postgres array without any bounds.
--   
--   Note that array support in <tt>beam-migrate</tt> is still incomplete.
unboundedArray :: forall a. Typeable a => DataType Postgres a -> DataType Postgres (Vector a)

-- | <a>DataType</a> for <tt>UUID</tt> columns. The
--   <tt>pgCryptoGenRandomUUID</tt> function in the <tt>PgCrypto</tt>
--   extension can be used to generate UUIDs at random.
uuid :: DataType Postgres UUID

-- | <a>DataType</a> for <tt>MONEY</tt> columns.
money :: DataType Postgres PgMoney

-- | <a>DataType</a> for <tt>JSON</tt>. See <a>PgJSON</a> for more
--   information
json :: (ToJSON a, FromJSON a) => DataType Postgres (PgJSON a)

-- | <a>DataType</a> for <tt>JSONB</tt>. See <a>PgJSON</a> for more
--   information
jsonb :: (ToJSON a, FromJSON a) => DataType Postgres (PgJSONB a)

-- | Postgres <tt>SERIAL</tt> data types. Automatically generates an
--   appropriate <tt>DEFAULT</tt> clause and sequence
smallserial :: Integral a => DataType Postgres (SqlSerial a)

-- | Postgres <tt>SERIAL</tt> data types. Automatically generates an
--   appropriate <tt>DEFAULT</tt> clause and sequence
serial :: Integral a => DataType Postgres (SqlSerial a)

-- | Postgres <tt>SERIAL</tt> data types. Automatically generates an
--   appropriate <tt>DEFAULT</tt> clause and sequence
bigserial :: Integral a => DataType Postgres (SqlSerial a)
point :: DataType Postgres PgPoint
line :: DataType Postgres PgLine
lineSegment :: DataType Postgres PgLineSegment
box :: DataType Postgres PgBox
instance Database.Beam.Migrate.SQL.Tables.FieldReturnType 'GHC.Types.True 'GHC.Types.False Database.Beam.Postgres.Types.Postgres resTy a => Database.Beam.Migrate.SQL.Tables.FieldReturnType 'GHC.Types.False 'GHC.Types.False Database.Beam.Postgres.Types.Postgres resTy (Database.Beam.Postgres.Migrate.PgHasDefault -> a)
instance Database.Beam.Migrate.SQL.BeamExtensions.BeamSqlBackendHasSerial Database.Beam.Postgres.Types.Postgres


-- | More efficient query execution functions for <tt>beam-postgres</tt>.
--   These functions use the <tt>conduit</tt> package, to execute
--   <tt>beam-postgres</tt> statements in an arbitrary <a>MonadIO</a>.
--   These functions may be more efficient for streaming operations than
--   <a>MonadBeam</a>.
module Database.Beam.Postgres.Conduit

-- | Run a PostgreSQL <tt>SELECT</tt> statement in any
--   <a>MonadResource</a>.
streamingRunSelect :: (MonadResource m, MonadFail m, FromBackendRow Postgres a) => Connection -> SqlSelect Postgres a -> ConduitT () a m ()

-- | Run a PostgreSQL <tt>INSERT</tt> statement in any <a>MonadIO</a>.
--   Returns the number of rows affected.
runInsert :: MonadIO m => Connection -> SqlInsert Postgres tbl -> m Int64

-- | Run a PostgreSQL <tt>INSERT ... RETURNING ...</tt> statement in any
--   <a>MonadResource</a> and get a <a>Source</a> of the newly inserted
--   rows.
streamingRunInsertReturning :: (MonadResource m, MonadFail m, FromBackendRow Postgres a) => Connection -> PgInsertReturning a -> ConduitT () a m ()

-- | Run a PostgreSQL <tt>UPDATE</tt> statement in any <a>MonadIO</a>.
--   Returns the number of rows affected.
runUpdate :: MonadIO m => Connection -> SqlUpdate Postgres tbl -> m Int64

-- | Run a PostgreSQL <tt>UPDATE ... RETURNING ...</tt> statement in any
--   <a>MonadResource</a> and get a <a>Source</a> of the newly updated
--   rows.
streamingRunUpdateReturning :: (MonadResource m, MonadFail m, FromBackendRow Postgres a) => Connection -> PgUpdateReturning a -> ConduitT () a m ()

-- | Run a PostgreSQL <tt>DELETE</tt> statement in any <a>MonadIO</a>.
--   Returns the number of rows affected.
runDelete :: MonadIO m => Connection -> SqlDelete Postgres tbl -> m Int64

-- | Run a PostgreSQl <tt>DELETE ... RETURNING ...</tt> statement in any
--   <a>MonadResource</a> and get a <a>Source</a> of the deleted rows.
streamingRunDeleteReturning :: (MonadResource m, MonadFail m, FromBackendRow Postgres a) => Connection -> PgDeleteReturning a -> ConduitT () a m ()

-- | Run any DML statement. Return the number of rows affected
executeStatement :: MonadIO m => Connection -> PgSyntax -> m Int64

-- | Runs any query that returns a set of values
streamingRunQueryReturning :: (MonadResource m, MonadFail m, FromBackendRow Postgres r) => Connection -> PgSyntax -> ConduitT () r m ()

-- | Run a PostgreSQL <tt>SELECT</tt> statement in any <a>MonadIO</a>.

-- | <i>Deprecated: Use streamingRunSelect</i>
runSelect :: (MonadIO m, MonadFail m, MonadBaseControl IO m, FromBackendRow Postgres a) => Connection -> SqlSelect Postgres a -> (ConduitT () a m () -> m b) -> m b

-- | Run a PostgreSQL <tt>INSERT ... RETURNING ...</tt> statement in any
--   <a>MonadIO</a> and get a <a>Source</a> of the newly inserted rows.

-- | <i>Deprecated: Use streamingRunInsertReturning</i>
runInsertReturning :: (MonadIO m, MonadFail m, MonadBaseControl IO m, FromBackendRow Postgres a) => Connection -> PgInsertReturning a -> (ConduitT () a m () -> m b) -> m b

-- | Run a PostgreSQL <tt>UPDATE ... RETURNING ...</tt> statement in any
--   <a>MonadIO</a> and get a <a>Source</a> of the newly updated rows.

-- | <i>Deprecated: Use streamingRunUpdateReturning</i>
runUpdateReturning :: (MonadIO m, MonadFail m, MonadBaseControl IO m, FromBackendRow Postgres a) => Connection -> PgUpdateReturning a -> (ConduitT () a m () -> m b) -> m b

-- | Run a PostgreSQl <tt>DELETE ... RETURNING ...</tt> statement in any
--   <a>MonadIO</a> and get a <a>Source</a> of the deleted rows.

-- | <i>Deprecated: Use streamingRunDeleteReturning</i>
runDeleteReturning :: (MonadIO m, MonadFail m, MonadBaseControl IO m, FromBackendRow Postgres a) => Connection -> PgDeleteReturning a -> (ConduitT () a m () -> m b) -> m b

-- | Runs any query that returns a set of values

-- | <i>Deprecated: Use streamingRunQueryReturning</i>
runQueryReturning :: (MonadIO m, MonadFail m, MonadBaseControl IO m, Functor m, FromBackendRow Postgres r) => Connection -> PgSyntax -> (ConduitT () r m () -> m b) -> m b


-- | Postgres is a popular, open-source RDBMS. It is fairly standards
--   compliant and supports many advanced features and data types.
--   
--   The <tt>beam-postgres</tt> module is built atop of
--   <tt>postgresql-simple</tt>, which is used for connection management,
--   transaction support, serialization, and deserialization.
--   
--   <tt>beam-postgres</tt> supports most beam features as well as many
--   postgres-specific features. For example, <tt>beam-postgres</tt>
--   provides support for full-text search, <tt>DISTINCT ON</tt>, JSON
--   handling, postgres <tt>ARRAY</tt>s, <tt>RANGE</tt>s, and the
--   <tt>MONEY</tt> type.
--   
--   The documentation for <tt>beam-postgres</tt> functionality below
--   indicates which postgres function each function or type wraps.
--   Postgres maintains its own in-depth documentation. Please refer to
--   that for more detailed information on <a>behavior</a>.
--   
--   For examples on how to use <tt>beam-postgres</tt> usage, see <a>its
--   manual</a>.
module Database.Beam.Postgres

-- | The Postgres backend type, used to parameterize <a>MonadBeam</a>. See
--   the definitions there for more information. The corresponding query
--   monad is <tt>Pg</tt>. See documentation for <a>MonadBeam</a> and the
--   <a>user guide</a> for more information on using this backend.
data Postgres
Postgres :: Postgres

-- | <a>MonadBeam</a> in which we can run Postgres commands. See the
--   documentation for <a>MonadBeam</a> on examples of how to use.
--   
--   <tt>beam-postgres</tt> also provides functions that let you run
--   queries without <a>MonadBeam</a>. These functions may be more
--   efficient and offer a conduit API. See
--   <a>Database.Beam.Postgres.Conduit</a> for more information.
data Pg a
liftIOWithHandle :: (Connection -> IO a) -> Pg a

-- | Representation of an arbitrary Postgres command. This is the
--   combination of the command syntax (repesented by <a>PgSyntax</a>), as
--   well as the type of command (represented by <a>PgCommandType</a>). The
--   command type is necessary for us to know how to retrieve results from
--   the database.
data PgCommandSyntax

-- | A piece of Postgres SQL syntax, which may contain embedded escaped
--   byte and text sequences. <a>PgSyntax</a> composes monoidally, and may
--   be created with <a>emit</a>, <a>emitBuilder</a>, <a>escapeString</a>,
--   <tt>escapBytea</tt>, and <a>escapeIdentifier</a>.
data PgSyntax

-- | <a>IsSql92SelectSyntax</a> for Postgres
data PgSelectSyntax

-- | <a>IsSql92InsertSyntax</a> for Postgres
data PgInsertSyntax

-- | <a>IsSql92UpdateSyntax</a> for Postgres
data PgUpdateSyntax

-- | <a>IsSql92DeleteSyntax</a> for Postgres
data PgDeleteSyntax

-- | <a>BeamURIOpeners</a> for the standard <tt>postgresql:</tt> URI
--   scheme. See the postgres documentation for more details on the
--   formatting. See documentation for <a>BeamURIOpeners</a> for more
--   information on how to use this with beam
postgresUriSyntax :: c Postgres Connection Pg -> BeamURIOpeners c

-- | <a>DataType</a> for <tt>JSON</tt>. See <a>PgJSON</a> for more
--   information
json :: (ToJSON a, FromJSON a) => DataType Postgres (PgJSON a)

-- | <a>DataType</a> for <tt>JSONB</tt>. See <a>PgJSON</a> for more
--   information
jsonb :: (ToJSON a, FromJSON a) => DataType Postgres (PgJSONB a)

-- | <a>DataType</a> for <tt>UUID</tt> columns. The
--   <tt>pgCryptoGenRandomUUID</tt> function in the <tt>PgCrypto</tt>
--   extension can be used to generate UUIDs at random.
uuid :: DataType Postgres UUID

-- | <a>DataType</a> for <tt>MONEY</tt> columns.
money :: DataType Postgres PgMoney

-- | <a>DataType</a> for <tt>tsquery</tt>. See <a>TsQuery</a> for more
--   information
tsquery :: DataType Postgres TsQuery

-- | <a>DataType</a> for <tt>tsvector</tt>. See <a>TsVector</a> for more
--   information
tsvector :: DataType Postgres TsVector

-- | <a>DataType</a> for Postgres <tt>TEXT</tt>.
--   <tt>characterLargeObject</tt> is also mapped to this data type
text :: DataType Postgres Text

-- | <a>DataType</a> for Postgres <tt>BYTEA</tt>.
--   <tt>binaryLargeObject</tt> is also mapped to this data type
bytea :: DataType Postgres ByteString

-- | <a>DataType</a> for a Postgres array without any bounds.
--   
--   Note that array support in <tt>beam-migrate</tt> is still incomplete.
unboundedArray :: forall a. Typeable a => DataType Postgres a -> DataType Postgres (Vector a)

-- | Postgres <tt>SERIAL</tt> data types. Automatically generates an
--   appropriate <tt>DEFAULT</tt> clause and sequence
smallserial :: Integral a => DataType Postgres (SqlSerial a)

-- | Postgres <tt>SERIAL</tt> data types. Automatically generates an
--   appropriate <tt>DEFAULT</tt> clause and sequence
serial :: Integral a => DataType Postgres (SqlSerial a)

-- | Postgres <tt>SERIAL</tt> data types. Automatically generates an
--   appropriate <tt>DEFAULT</tt> clause and sequence
bigserial :: Integral a => DataType Postgres (SqlSerial a)

-- | The identifier of a Postgres text search configuration.
--   
--   Use the <a>IsString</a> instance to construct new values of this type
data TsVectorConfig

-- | The type of a document preprocessed for full-text search. The
--   contained <a>ByteString</a> is the Postgres representation of the
--   <tt>TSVECTOR</tt> type. Use <a>toTsVector</a> to construct these
--   on-the-fly from strings.
--   
--   When this field is embedded in a beam table,
--   <tt>defaultMigratableDbSettings</tt> will give the column the postgres
--   <tt>TSVECTOR</tt> type.
newtype TsVector
TsVector :: ByteString -> TsVector

-- | The Postgres <tt>to_tsvector</tt> function. Given a configuration and
--   string, return the <tt>TSVECTOR</tt> that represents the contents of
--   the string.
toTsVector :: BeamSqlBackendIsString Postgres str => Maybe TsVectorConfig -> QGenExpr context Postgres s str -> QGenExpr context Postgres s TsVector

-- | A full-text search configuration with sensible defaults for english
english :: TsVectorConfig

-- | A query that can be run against a document contained in a
--   <a>TsVector</a>.
--   
--   When this field is embedded in a beam table,
--   <tt>defaultMigratableDbSettings</tt> will give the column the postgres
--   <tt>TSVECTOR</tt> type
newtype TsQuery
TsQuery :: ByteString -> TsQuery

-- | Determine if the given <tt>TSQUERY</tt> matches the document
--   represented by the <tt>TSVECTOR</tt>. Behaves exactly like the
--   similarly-named operator in postgres.
(@@) :: QGenExpr context Postgres s TsVector -> QGenExpr context Postgres s TsQuery -> QGenExpr context Postgres s Bool

-- | The Postgres <tt>to_tsquery</tt> function. Given a configuration and
--   string, return the <tt>TSQUERY</tt> that represents the contents of
--   the string.
toTsQuery :: BeamSqlBackendIsString Postgres str => Maybe TsVectorConfig -> QGenExpr context Postgres s str -> QGenExpr context Postgres s TsQuery

-- | The Postgres <tt>JSON</tt> type, which stores textual values that
--   represent JSON objects. The type parameter indicates the Haskell type
--   which the JSON encodes. This type must be a member of <a>FromJSON</a>
--   and <a>ToJSON</a> in order for deserialization and serialization to
--   work as expected.
--   
--   The <tt>defaultMigratableDbSettings</tt> function automatically
--   assigns the postgres <tt>JSON</tt> type to fields with this type.
newtype PgJSON a
PgJSON :: a -> PgJSON a

-- | The Postgres <tt>JSONB</tt> type, which stores JSON-encoded data in a
--   postgres-specific binary format. Like <a>PgJSON</a>, the type
--   parameter indicates the Haskell type which the JSON encodes.
--   
--   Fields with this type are automatically given the Postgres
--   <tt>JSONB</tt> type
newtype PgJSONB a
PgJSONB :: a -> PgJSONB a

-- | Postgres provides separate <tt>json_</tt> and <tt>jsonb_</tt>
--   functions. However, we know what we're dealing with based on the type
--   of data, so we can be less obtuse.
--   
--   For more information on how these functions behave, see the Postgres
--   manual section on <a>JSON</a>.
class IsPgJSON (json :: * -> *)

-- | The <tt>json_each</tt> or <tt>jsonb_each</tt> function. Values
--   returned as <tt>json</tt> or <tt>jsonb</tt> respectively. Use
--   <a>pgUnnest</a> to join against the result
pgJsonEach :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s (PgSetOf (PgJSONEach (json Value)))

-- | Like <a>pgJsonEach</a>, but returning text values instead
pgJsonEachText :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s (PgSetOf (PgJSONEach Text))

-- | The <tt>json_object_keys</tt> and <tt>jsonb_object_keys</tt> function.
--   Use <a>pgUnnest</a> to join against the result.
pgJsonKeys :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s (PgSetOf PgJSONKey)

-- | The <tt>json_array_elements</tt> and <tt>jsonb_array_elements</tt>
--   function. Use <a>pgUnnest</a> to join against the result
pgJsonArrayElements :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s (PgSetOf (PgJSONElement (json Value)))

-- | Like <a>pgJsonArrayElements</a>, but returning the values as
--   <a>Text</a>
pgJsonArrayElementsText :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s (PgSetOf (PgJSONElement Text))

-- | The <tt>json_typeof</tt> or <tt>jsonb_typeof</tt> function
pgJsonTypeOf :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s Text

-- | The <tt>json_strip_nulls</tt> or <tt>jsonb_strip_nulls</tt> function.
pgJsonStripNulls :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s (json b)

-- | The <tt>json_agg</tt> or <tt>jsonb_agg</tt> aggregate.
pgJsonAgg :: IsPgJSON json => QExpr Postgres s a -> QAgg Postgres s (json a)

-- | The <tt>json_object_agg</tt> or <tt>jsonb_object_agg</tt>. The first
--   argument gives the key source and the second the corresponding values.
pgJsonObjectAgg :: IsPgJSON json => QExpr Postgres s key -> QExpr Postgres s value -> QAgg Postgres s (json a)

-- | Key-value pair, used as output of <a>pgJsonEachText</a> and
--   <a>pgJsonEach</a>
data PgJSONEach valType f
PgJSONEach :: C f Text -> C f valType -> PgJSONEach valType f
[pgJsonEachKey] :: PgJSONEach valType f -> C f Text
[pgJsonEachValue] :: PgJSONEach valType f -> C f valType

-- | Output row of <a>pgJsonKeys</a>
data PgJSONKey f
PgJSONKey :: C f Text -> PgJSONKey f
[pgJsonKey] :: PgJSONKey f -> C f Text

-- | Output row of <a>pgJsonArrayElements</a> and
--   <a>pgJsonArrayElementsText</a>
data PgJSONElement a f
PgJSONElement :: C f a -> PgJSONElement a f
[pgJsonElement] :: PgJSONElement a f -> C f a

-- | Postgres <tt>@&gt;</tt> and <tt>&lt;@</tt> operators for JSON. Return
--   true if the json object pointed to by the arrow is completely
--   contained in the other. See the Postgres documentation for more in
--   formation on what this means.
(@>) :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s (PgJSONB b) -> QGenExpr ctxt Postgres s Bool

-- | Postgres <tt>@&gt;</tt> and <tt>&lt;@</tt> operators for JSON. Return
--   true if the json object pointed to by the arrow is completely
--   contained in the other. See the Postgres documentation for more in
--   formation on what this means.
(<@) :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s (PgJSONB b) -> QGenExpr ctxt Postgres s Bool

-- | Access a JSON array by index. Corresponds to the Postgres
--   <tt>-&gt;</tt> operator. See <a>(-&gt;$)</a> for the corresponding
--   operator for object access.
(->#) :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s Int32 -> QGenExpr ctxt Postgres s (json b)

-- | Acces a JSON object by key. Corresponds to the Postgres <tt>-&gt;</tt>
--   operator. See <a>(-&gt;#)</a> for the corresponding operator for
--   arrays.
(->$) :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s Text -> QGenExpr ctxt Postgres s (json b)

-- | Access a JSON array by index, returning the embedded object as a
--   string. Corresponds to the Postgres <tt>-&gt;&gt;</tt> operator. See
--   <a>(-&gt;&gt;$)</a> for the corresponding operator on objects.
(->>#) :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s Int32 -> QGenExpr ctxt Postgres s Text

-- | Access a JSON object by key, returning the embedded object as a
--   string. Corresponds to the Postgres <tt>-&gt;&gt;</tt> operator. See
--   <a>(-&gt;&gt;#)</a> for the corresponding operator on arrays.
(->>$) :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s Text -> QGenExpr ctxt Postgres s Text

-- | Access a deeply nested JSON object. The first argument is the JSON
--   object to look within, the second is the path of keys from the first
--   argument to the target. Returns the result as a new json value. Note
--   that the postgres function allows etiher string keys or integer
--   indices, but this function only allows string keys. PRs to improve
--   this functionality are welcome.
(#>) :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s (Vector Text) -> QGenExpr ctxt Postgres s (json b)

-- | Like <a>(#&gt;)</a> but returns the result as a string.
(#>>) :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s (Vector Text) -> QGenExpr ctxt Postgres s Text

-- | Postgres <tt>?</tt> operator. Checks if the given string exists as
--   top-level key of the json object.
(?) :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s Text -> QGenExpr ctxt Postgres s Bool

-- | Postgres <tt>?|</tt> and <tt>?&amp;</tt> operators. Check if any or
--   all of the given strings exist as top-level keys of the json object
--   respectively.
(?|) :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s (Vector Text) -> QGenExpr ctxt Postgres s Bool

-- | Postgres <tt>?|</tt> and <tt>?&amp;</tt> operators. Check if any or
--   all of the given strings exist as top-level keys of the json object
--   respectively.
(?&) :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s (Vector Text) -> QGenExpr ctxt Postgres s Bool

-- | Postgres <tt>-</tt> operator on json objects. Returns the supplied
--   json object with the supplied key deleted. See <a>withoutIdx</a> for
--   the corresponding operator on arrays.
withoutKey :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s Text -> QGenExpr ctxt Postgres s (PgJSONB b)

-- | Postgres <tt>-</tt> operator on json arrays. See <a>withoutKey</a> for
--   the corresponding operator on objects.
withoutIdx :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s Int32 -> QGenExpr ctxt Postgres s (PgJSONB b)

-- | Postgres <tt>#-</tt> operator. Removes all the keys specificied from
--   the JSON object and returns the result.
withoutKeys :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s (Vector Text) -> QGenExpr ctxt Postgres s (PgJSONB b)

-- | Postgres <tt>json_array_length</tt> function. The supplied json object
--   should be an array, but this isn't checked at compile-time.
pgJsonArrayLength :: IsPgJSON json => QGenExpr ctxt Postgres s (json a) -> QGenExpr ctxt Postgres s Int32

-- | Postgres <tt>array_to_json</tt> function.
pgArrayToJson :: QGenExpr ctxt Postgres s (Vector e) -> QGenExpr ctxt Postgres s (PgJSON a)

-- | The postgres <tt>jsonb_set</tt> function. <tt>pgJsonUpdate</tt>
--   expects the value specified by the path in the second argument to
--   exist. If it does not, the first argument is not modified.
--   <a>pgJsonbSet</a> will create any intermediate objects necessary. This
--   corresponds to the <tt>create_missing</tt> argument of
--   <tt>jsonb_set</tt> being set to false or true respectively.
pgJsonbUpdate :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s (Vector Text) -> QGenExpr ctxt Postgres s (PgJSONB b) -> QGenExpr ctxt Postgres s (PgJSONB a)

-- | The postgres <tt>jsonb_set</tt> function. <tt>pgJsonUpdate</tt>
--   expects the value specified by the path in the second argument to
--   exist. If it does not, the first argument is not modified.
--   <a>pgJsonbSet</a> will create any intermediate objects necessary. This
--   corresponds to the <tt>create_missing</tt> argument of
--   <tt>jsonb_set</tt> being set to false or true respectively.
pgJsonbSet :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s (Vector Text) -> QGenExpr ctxt Postgres s (PgJSONB b) -> QGenExpr ctxt Postgres s (PgJSONB a)

-- | Postgres <tt>jsonb_pretty</tt> function
pgJsonbPretty :: QGenExpr ctxt Postgres s (PgJSONB a) -> QGenExpr ctxt Postgres s Text

-- | Postgres <tt>MONEY</tt> data type. A simple wrapper over
--   <a>ByteString</a>, because Postgres money format is locale-dependent,
--   and we don't handle currency symbol placement, digit grouping, or
--   decimal separation.
--   
--   The <a>pgMoney</a> function can be used to convert a number to
--   <a>PgMoney</a>.
newtype PgMoney
PgMoney :: ByteString -> PgMoney
[fromPgMoney] :: PgMoney -> ByteString

-- | Attempt to pack a floating point value as a <a>PgMoney</a> value,
--   paying no attention to the locale-dependent currency symbol, digit
--   grouping, or decimal point. This will use the <tt>.</tt> symbol as the
--   decimal separator.
pgMoney :: Real a => a -> PgMoney

-- | Multiply a <tt>MONEY</tt> value by a numeric value. Corresponds to the
--   Postgres <tt>*</tt> operator.
pgScaleMoney_ :: Num a => QGenExpr context Postgres s a -> QGenExpr context Postgres s PgMoney -> QGenExpr context Postgres s PgMoney

-- | Divide a <tt>MONEY</tt> value by a numeric value. Corresponds to
--   Postgres <tt>/</tt> where the numerator has type <tt>MONEY</tt> and
--   the denominator is a number. If you would like to divide two
--   <tt>MONEY</tt> values and have their units cancel out, use
--   <a>pgDivideMoneys_</a>.
pgDivideMoney_ :: Num a => QGenExpr context Postgres s PgMoney -> QGenExpr context Postgres s a -> QGenExpr context Postgres s PgMoney

-- | Dividing two <tt>MONEY</tt> value results in a number. Corresponds to
--   Postgres <tt>/</tt> on two <tt>MONEY</tt> values. If you would like to
--   divide <tt>MONEY</tt> by a scalar, use <a>pgDivideMoney_</a>
pgDivideMoneys_ :: Num a => QGenExpr context Postgres s PgMoney -> QGenExpr context Postgres s PgMoney -> QGenExpr context Postgres s a

-- | Postgres <tt>+</tt> and <tt>-</tt> operators on money.
pgAddMoney_ :: QGenExpr context Postgres s PgMoney -> QGenExpr context Postgres s PgMoney -> QGenExpr context Postgres s PgMoney

-- | Postgres <tt>+</tt> and <tt>-</tt> operators on money.
pgSubtractMoney_ :: QGenExpr context Postgres s PgMoney -> QGenExpr context Postgres s PgMoney -> QGenExpr context Postgres s PgMoney

-- | The Postgres <tt>MONEY</tt> type can be summed or averaged in an
--   aggregation. These functions provide the quantified aggregations. See
--   <a>pgSumMoney_</a> and <a>pgAvgMoney_</a> for the unquantified
--   versions.
pgSumMoneyOver_ :: Maybe PgAggregationSetQuantifierSyntax -> QExpr Postgres s PgMoney -> QExpr Postgres s PgMoney

-- | The Postgres <tt>MONEY</tt> type can be summed or averaged in an
--   aggregation. These functions provide the quantified aggregations. See
--   <a>pgSumMoney_</a> and <a>pgAvgMoney_</a> for the unquantified
--   versions.
pgAvgMoneyOver_ :: Maybe PgAggregationSetQuantifierSyntax -> QExpr Postgres s PgMoney -> QExpr Postgres s PgMoney

-- | The Postgres <tt>MONEY</tt> type can be summed or averaged in an
--   aggregation. To provide an explicit quantification, see
--   <a>pgSumMoneyOver_</a> and <a>pgAvgMoneyOver_</a>.
pgSumMoney_ :: QExpr Postgres s PgMoney -> QExpr Postgres s PgMoney

-- | The Postgres <tt>MONEY</tt> type can be summed or averaged in an
--   aggregation. To provide an explicit quantification, see
--   <a>pgSumMoneyOver_</a> and <a>pgAvgMoneyOver_</a>.
pgAvgMoney_ :: QExpr Postgres s PgMoney -> QExpr Postgres s PgMoney
data PgPoint
PgPoint :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> PgPoint
data PgLine
PgLine :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> PgLine
data PgLineSegment
PgLineSegment :: {-# UNPACK #-} !PgPoint -> {-# UNPACK #-} !PgPoint -> PgLineSegment
data PgBox
PgBox :: {-# UNPACK #-} !PgPoint -> {-# UNPACK #-} !PgPoint -> PgBox
data PgPath
PgPathOpen :: NonEmpty PgPoint -> PgPath
PgPathClosed :: NonEmpty PgPoint -> PgPath
data PgPolygon
PgPolygon :: NonEmpty PgPoint -> PgPolygon
data PgCircle
PgCircle :: {-# UNPACK #-} !PgPoint -> {-# UNPACK #-} !Double -> PgCircle

-- | The type of Postgres regular expressions. Only a
--   <a>HasSqlValueSyntax</a> instance is supplied, because you won't need
--   to be reading these back from the database.
--   
--   If you're generating regexes dynamically, then use <a>pgRegex_</a> to
--   convert a string expression into a regex one.
newtype PgRegex
PgRegex :: Text -> PgRegex

-- | Convert a string valued expression (which could be generated
--   dynamically) into a <a>PgRegex</a>-typed one.
pgRegex_ :: BeamSqlBackendIsString Postgres text => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex

-- | Match regular expression, case-sensitive
(~.) :: BeamSqlBackendIsString Postgres text => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex -> QGenExpr ctxt Postgres s Bool

-- | Match regular expression, case-insensitive
(~*.) :: BeamSqlBackendIsString Postgres text => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex -> QGenExpr ctxt Postgres s Bool

-- | Does not match regular expression, case-sensitive
(!~.) :: BeamSqlBackendIsString Postgres text => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex -> QGenExpr ctxt Postgres s Bool

-- | Does not match regular expression, case-insensitive
(!~*.) :: BeamSqlBackendIsString Postgres text => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex -> QGenExpr ctxt Postgres s Bool

-- | Postgres <tt>regexp_replace</tt>. Replaces all instances of the regex
--   in the first argument with the third argument. The fourth argument is
--   the postgres regex options to provide.
pgRegexpReplace_ :: BeamSqlBackendIsString Postgres text => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex -> QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s Text -> QGenExpr ctxt Postgres s txt

-- | Postgres <tt>regexp_match</tt>. Matches the regular expression against
--   the string given and returns an array where each element corresponds
--   to a match in the string, or <tt>NULL</tt> if nothing was found
pgRegexpMatch_ :: BeamSqlBackendIsString Postgres text => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex -> QGenExpr ctxt Postgres s (Maybe (Vector text))

-- | Postgres <tt>regexp_split_to_table</tt>. Splits the given string by
--   the given regex and return a result set that can be joined against.
pgRegexpSplitToTable :: BeamSqlBackendIsString Postgres text => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex -> Q Postgres db s (QExpr Postgres s Text)

-- | Postgres <tt>regexp_split_to_array</tt>. Splits the given string by
--   the given regex and returns the result as an array.
pgRegexpSplitToArray :: BeamSqlBackendIsString Postgres text => QGenExpr ctxt Postgres s text -> QGenExpr ctxt Postgres s PgRegex -> QGenExpr ctxt Postgres s (Vector text)
data PgSetOf (tbl :: (* -> *) -> *)

-- | Join the results of the given set-valued function to the query
pgUnnest :: forall tbl db s. Beamable tbl => QExpr Postgres s (PgSetOf tbl) -> Q Postgres db s (QExprTable Postgres s tbl)

-- | Introduce each element of the array as a row
pgUnnestArray :: QExpr Postgres s (Vector a) -> Q Postgres db s (QExpr Postgres s a)

-- | Introduce each element of the array as a row, along with the element's
--   index
pgUnnestArrayWithOrdinality :: QExpr Postgres s (Vector a) -> Q Postgres db s (QExpr Postgres s Int64, QExpr Postgres s a)

-- | An expression context that determines which types of expressions can
--   be put inside an array element. Any scalar, aggregate, or window
--   expression can be placed within an array.
data PgArrayValueContext

-- | If you are extending beam-postgres and provide another expression
--   context that can be represented in an array, provide an empty instance
--   of this class.
class PgIsArrayContext ctxt

-- | Build a 1-dimensional postgres array from an arbitrary <a>Foldable</a>
--   containing expressions.
array_ :: forall context f s a. (PgIsArrayContext context, Foldable f) => f (QGenExpr context Postgres s a) -> QGenExpr context Postgres s (Vector a)

-- | Build a 1-dimensional postgres array from a subquery
arrayOf_ :: Q Postgres db s (QExpr Postgres s a) -> QGenExpr context Postgres s (Vector a)

-- | Postgres <tt>||</tt> operator. Concatenates two vectors and returns
--   their result.
(++.) :: QGenExpr ctxt Postgres s (Vector a) -> QGenExpr ctxt Postgres s (Vector a) -> QGenExpr ctxt Postgres s (Vector a)

-- | An aggregate that adds each value to the resulting array. See
--   <tt>pgArrayOver</tt> if you want to specify a quantifier. Corresponds
--   to the Postgres <tt>ARRAY_AGG</tt> function.
pgArrayAgg :: QExpr Postgres s a -> QAgg Postgres s (Vector a)

-- | Postgres <tt>ARRAY_AGG</tt> with an explicit quantifier. Includes each
--   row that meets the quantification criteria in the result.
pgArrayAggOver :: Maybe PgAggregationSetQuantifierSyntax -> QExpr Postgres s a -> QAgg Postgres s (Vector a)

-- | Index into the given array. This translates to the
--   <tt><a>array</a>[<a>index</a>]</tt> syntax in postgres. The beam
--   operator name has been chosen to match the 'Data.Vector.(!)' operator.
(!.) :: Integral ix => QGenExpr context Postgres s (Vector a) -> QGenExpr context Postgres s ix -> QGenExpr context Postgres s a

-- | Postgres <tt>array_dims()</tt> function. Returns a textual
--   representation of the dimensions of the array.
arrayDims_ :: BeamSqlBackendIsString Postgres text => QGenExpr context Postgres s (Vector a) -> QGenExpr context Postgres s text

-- | Return the upper or lower bound of the given array at the given
--   dimension (statically supplied as a type application on a <a>Nat</a>).
--   Note that beam will attempt to statically determine if the dimension
--   is in range. GHC errors will be thrown if this cannot be proved.
--   
--   For example, to get the upper bound of the 2nd-dimension of an array:
--   
--   <pre>
--   arrayUpper_ @2 vectorValuedExpression
--   </pre>
arrayUpper_ :: forall (dim :: Nat) context num v s. (KnownNat dim, WithinBounds dim (Vector v), Integral num) => QGenExpr context Postgres s (Vector v) -> QGenExpr context Postgres s num

-- | Return the upper or lower bound of the given array at the given
--   dimension (statically supplied as a type application on a <a>Nat</a>).
--   Note that beam will attempt to statically determine if the dimension
--   is in range. GHC errors will be thrown if this cannot be proved.
--   
--   For example, to get the upper bound of the 2nd-dimension of an array:
--   
--   <pre>
--   arrayUpper_ @2 vectorValuedExpression
--   </pre>
arrayLower_ :: forall (dim :: Nat) context num v s. (KnownNat dim, WithinBounds dim (Vector v), Integral num) => QGenExpr context Postgres s (Vector v) -> QGenExpr context Postgres s num

-- | These functions can be used to find the lower and upper bounds of an
--   array where the dimension number is not known until run-time. They are
--   marked unsafe because they may cause query processing to fail at
--   runtime, even if they typecheck successfully.
arrayUpperUnsafe_ :: (Integral dim, Integral length) => QGenExpr context Postgres s (Vector v) -> QGenExpr context Postgres s dim -> QGenExpr context Postgres s (Maybe length)

-- | These functions can be used to find the lower and upper bounds of an
--   array where the dimension number is not known until run-time. They are
--   marked unsafe because they may cause query processing to fail at
--   runtime, even if they typecheck successfully.
arrayLowerUnsafe_ :: (Integral dim, Integral length) => QGenExpr context Postgres s (Vector v) -> QGenExpr context Postgres s dim -> QGenExpr context Postgres s (Maybe length)

-- | Get the size of the array at the given (statically known) dimension,
--   provided as a type-level <a>Nat</a>. Like the <a>arrayUpper_</a> and
--   <a>arrayLower_</a> functions,throws a compile-time error if the
--   dimension is out of bounds.
arrayLength_ :: forall (dim :: Nat) ctxt num v s. (KnownNat dim, WithinBounds dim (Vector v), Integral num) => QGenExpr ctxt Postgres s (Vector v) -> QGenExpr ctxt Postgres s num

-- | Get the size of an array at a dimension not known until run-time.
--   Marked unsafe as this may cause runtime errors even if it type checks.
arrayLengthUnsafe_ :: (Integral dim, Integral num) => QGenExpr ctxt Postgres s (Vector v) -> QGenExpr ctxt Postgres s dim -> QGenExpr ctxt Postgres s (Maybe num)

-- | The Postgres <tt>@&gt;</tt> operator. Returns true if every member of
--   the second array is present in the first.
isSupersetOf_ :: QGenExpr ctxt Postgres s (Vector a) -> QGenExpr ctxt Postgres s (Vector a) -> QGenExpr ctxt Postgres s Bool

-- | The Postgres <tt>&lt;@</tt> operator. Returns true if every member of
--   the first array is present in the second.
isSubsetOf_ :: QGenExpr ctxt Postgres s (Vector a) -> QGenExpr ctxt Postgres s (Vector a) -> QGenExpr ctxt Postgres s Bool

-- | A range of a given Haskell type (represented by <tt>a</tt>) stored as
--   a given Postgres Range Type (represented by <tt>n</tt>).
--   
--   A reasonable example might be <tt>Range PgInt8Range Int64</tt>. This
--   represents a range of Haskell <tt>Int64</tt> values stored as a range
--   of <a>bigint</a> in Postgres.
data PgRange (n :: *) a
PgEmptyRange :: PgRange (n :: *) a
PgRange :: PgRangeBound a -> PgRangeBound a -> PgRange (n :: *) a

-- | Represents a single bound on a Range. A bound always has a type, but
--   may not have a value (the absense of a value represents unbounded).
data PgRangeBound a
PgRangeBound :: PgBoundType -> Maybe a -> PgRangeBound a

-- | Represents the types of bounds a range can have. A range can and often
--   does have mis-matched bound types.
data PgBoundType
Inclusive :: PgBoundType
Exclusive :: PgBoundType

-- | A class representing Postgres Range types and how to refer to them
--   when speaking to the database.
--   
--   For custom Range types, create an uninhabited type, and make it an
--   instance of this class.
class PgIsRange n

-- | The range type name in the database.
rangeName :: PgIsRange n => ByteString
data PgInt4Range
data PgInt8Range
data PgNumRange
data PgTsRange
data PgTsTzRange
data PgDateRange
range_ :: forall n a context s. PgIsRange n => PgBoundType -> PgBoundType -> QGenExpr context Postgres s (Maybe a) -> QGenExpr context Postgres s (Maybe a) -> QGenExpr context Postgres s (PgRange n a)
inclusive :: a -> PgRangeBound a
exclusive :: a -> PgRangeBound a
unbounded :: PgRangeBound a
(-@>-) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
(-@>) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s a -> QGenExpr context Postgres s Bool
(-<@-) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
(<@-) :: QGenExpr context Postgres s a -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
(-&&-) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
(-<<-) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
(->>-) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
(-&<-) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
(-&>-) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
(--|--) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
(-+-) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a)
(-*-) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a)

-- | The postgres range operator <tt>-</tt> .
(-.-) :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a)
rLower_ :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (Maybe a)
rUpper_ :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (Maybe a)
isEmpty_ :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
lowerInc_ :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
upperInc_ :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
lowerInf_ :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
upperInf_ :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s Bool
rangeMerge_ :: QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a) -> QGenExpr context Postgres s (PgRange n a)
century_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32
decade_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32
dow_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32
doy_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32
epoch_ :: HasSqlTime tgt => ExtractField Postgres tgt NominalDiffTime
isodow_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32
isoyear_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32
microseconds_ :: HasSqlTime tgt => ExtractField Postgres tgt Int32
milliseconds_ :: HasSqlTime tgt => ExtractField Postgres tgt Int32
millennium_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32
quarter_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32
week_ :: HasSqlDate tgt => ExtractField Postgres tgt Int32

-- | Postgres <tt>bool_or</tt> aggregate. Returns true if any of the rows
--   are true.
pgBoolOr :: QExpr Postgres s a -> QAgg Postgres s (Maybe Bool)

-- | Postgres <tt>bool_and</tt> aggregate. Returns false unless every row
--   is true.
pgBoolAnd :: QExpr Postgres s a -> QAgg Postgres s (Maybe Bool)

-- | Joins the string value in each row of the first argument, using the
--   second argument as a delimiter. See <a>pgStringAggOver</a> if you want
--   to provide explicit quantification.
pgStringAgg :: BeamSqlBackendIsString Postgres str => QExpr Postgres s str -> QExpr Postgres s str -> QAgg Postgres s (Maybe str)

-- | The Postgres <tt>string_agg</tt> function, with an explicit
--   quantifier. Joins the values of the second argument using the
--   delimiter given by the third.
pgStringAggOver :: BeamSqlBackendIsString Postgres str => Maybe PgAggregationSetQuantifierSyntax -> QExpr Postgres s str -> QExpr Postgres s str -> QAgg Postgres s (Maybe str)

-- | Modify a query to only return rows where the supplied key function
--   returns a unique value. This corresponds to the Postgres <tt>DISTINCT
--   ON</tt> support.
pgNubBy_ :: (Projectible Postgres key, Projectible Postgres r) => (r -> key) -> Q Postgres db s r -> Q Postgres db s r

-- | Postgres <tt>NOW()</tt> function. Returns the server's timestamp
now_ :: QExpr Postgres s LocalTime

-- | Postgres <tt>ILIKE</tt> operator. A case-insensitive version of
--   <a>like_</a>.
ilike_ :: BeamSqlBackendIsString Postgres text => QExpr Postgres s text -> QExpr Postgres s text -> QExpr Postgres s Bool

-- | Postgres <tt>ILIKE</tt> operator. A case-insensitive version of
--   <a>like_'</a>.
ilike_' :: (BeamSqlBackendIsString Postgres left, BeamSqlBackendIsString Postgres right) => QExpr Postgres s left -> QExpr Postgres s right -> QExpr Postgres s Bool
runBeamPostgres :: Connection -> Pg a -> IO a
runBeamPostgresDebug :: (String -> IO ()) -> Connection -> Pg a -> IO a

-- | Represents an extension in a database.
--   
--   For example, to include the <a>Database.Beam.Postgres.PgCrypto</a>
--   extension in a database,
--   
--   <pre>
--   import Database.Beam.Postgres.PgCrypto
--   
--   data MyDatabase entity
--       = MyDatabase
--       { _table1 :: entity (TableEntity Table1)
--       , _cryptoExtension :: entity (PgExtensionEntity PgCrypto)
--       }
--   
--   migratableDbSettings :: CheckedDatabaseSettings Postgres MyDatabase
--   migratableDbSettings = defaultMigratableDbSettings
--   
--   dbSettings :: DatabaseSettings Postgres MyDatabase
--   dbSettings = unCheckDatabase migratableDbSettings
--   </pre>
--   
--   Note that our database now only works in the <a>Postgres</a> backend.
--   
--   Extensions are implemented as records of functions and values that
--   expose extension functionality. For example, the <tt>pgcrypto</tt>
--   extension (implemented by <tt>PgCrypto</tt>) provides cryptographic
--   functions. Thus, <tt>PgCrypto</tt> is a record of functions over
--   <a>QGenExpr</a> which wrap the underlying postgres functionality.
--   
--   You get access to these functions by retrieving them from the entity
--   in the database.
--   
--   For example, to use the <tt>pgcrypto</tt> extension in the database
--   above:
--   
--   <pre>
--   let PgCrypto { pgCryptoDigestText = digestText
--                , pgCryptoCrypt = crypt } = getPgExtension (_cryptoExtension dbSettings)
--   in fmap_ (tbl -&gt; (tbl, crypt (_field1 tbl) (_salt tbl))) (all_ (table1 dbSettings))
--   </pre>
--   
--   To implement your own extension, create a record type, and implement
--   the <a>IsPgExtension</a> type class.
data PgExtensionEntity extension

-- | Type class implemented by any Postgresql extension
class IsPgExtension extension

-- | Return the name of this extension. This should be the string that is
--   passed to <tt>CREATE EXTENSION</tt>. For example, <tt>PgCrypto</tt>
--   returns <tt>"pgcrypto"</tt>.
pgExtensionName :: IsPgExtension extension => Proxy extension -> Text

-- | Return a value of this extension type. This should fill in all fields
--   in the record. For example, <tt>PgCrypto</tt> builds a record where
--   each function wraps the underlying Postgres one.
pgExtensionBuild :: IsPgExtension extension => extension

-- | <a>Migration</a> representing the Postgres <tt>CREATE EXTENSION</tt>
--   command. Because the extension name is statically known by the
--   extension type and <a>IsPgExtension</a> type class, this simply
--   produces the checked extension entity.
--   
--   If you need to use the extension in subsequent migration steps, use
--   <a>getPgExtension</a> and <a>unCheck</a> to get access to the
--   underlying <a>DatabaseEntity</a>.
pgCreateExtension :: forall extension db. IsPgExtension extension => Migration Postgres (CheckedDatabaseEntity Postgres db (PgExtensionEntity extension))

-- | <a>Migration</a> representing the Postgres <tt>DROP EXTENSION</tt>.
--   After this executes, you should expect any further uses of the
--   extension to fail. Unfortunately, without linear types, we cannot
--   check this.
pgDropExtension :: forall extension. CheckedDatabaseEntityDescriptor Postgres (PgExtensionEntity extension) -> Migration Postgres ()

-- | Get the extension record from a database entity. See the documentation
--   for <a>PgExtensionEntity</a>.
getPgExtension :: DatabaseEntity Postgres db (PgExtensionEntity extension) -> extension

-- | Deserialize integral fields, possibly downcasting from a larger
--   integral type, but only if we won't lose data
fromPgIntegral :: forall a. (FromField a, Integral a, Typeable a) => FromBackendRowM Postgres a

-- | Deserialize integral fields, possibly downcasting from a larger
--   numeric type via <a>Scientific</a> if we won't lose data, and then
--   falling back to any integral type via <a>Integer</a>
fromPgScientificOrIntegral :: (Bounded a, Integral a) => FromBackendRowM Postgres a

-- | Type class for <tt>Sql*</tt> types that can be turned into Postgres
--   syntax, for use in the following debugging functions
--   
--   These include
--   
--   <ul>
--   <li><a>SqlSelect</a></li>
--   <li><a>SqlInsert</a></li>
--   <li><a>SqlUpdate</a></li>
--   <li><a>SqlDelete</a></li>
--   <li><a>PgInsertReturning</a></li>
--   <li><a>PgUpdateReturning</a></li>
--   <li><a>PgDeleteReturning</a></li>
--   </ul>
class PgDebugStmt statement
pgTraceStmtIO :: PgDebugStmt statement => Connection -> statement -> IO ()
pgTraceStmtIO' :: PgDebugStmt statement => Connection -> statement -> IO ByteString
pgTraceStmt :: PgDebugStmt statement => statement -> Pg ()

-- | Exception thrown if conversion from a SQL value to a Haskell value
--   fails.
data ResultError

-- | The SQL and Haskell types are not compatible.
Incompatible :: String -> Maybe Oid -> String -> String -> String -> ResultError
[errSQLType] :: ResultError -> String
[errSQLTableOid] :: ResultError -> Maybe Oid
[errSQLField] :: ResultError -> String
[errHaskellType] :: ResultError -> String
[errMessage] :: ResultError -> String

-- | A SQL <tt>NULL</tt> was encountered when the Haskell type did not
--   permit it.
UnexpectedNull :: String -> Maybe Oid -> String -> String -> String -> ResultError
[errSQLType] :: ResultError -> String
[errSQLTableOid] :: ResultError -> Maybe Oid
[errSQLField] :: ResultError -> String
[errHaskellType] :: ResultError -> String
[errMessage] :: ResultError -> String

-- | The SQL value could not be parsed, or could not be represented as a
--   valid Haskell value, or an unexpected low-level error occurred (e.g.
--   mismatch between metadata and actual data in a row).
ConversionFailed :: String -> Maybe Oid -> String -> String -> String -> ResultError
[errSQLType] :: ResultError -> String
[errSQLTableOid] :: ResultError -> Maybe Oid
[errSQLField] :: ResultError -> String
[errHaskellType] :: ResultError -> String
[errMessage] :: ResultError -> String
data SqlError
SqlError :: ByteString -> ExecStatus -> ByteString -> ByteString -> ByteString -> SqlError
[sqlState] :: SqlError -> ByteString
[sqlExecStatus] :: SqlError -> ExecStatus
[sqlErrorMsg] :: SqlError -> ByteString
[sqlErrorDetail] :: SqlError -> ByteString
[sqlErrorHint] :: SqlError -> ByteString
data Connection
data ConnectInfo
ConnectInfo :: String -> Word16 -> String -> String -> String -> ConnectInfo
[connectHost] :: ConnectInfo -> String
[connectPort] :: ConnectInfo -> Word16
[connectUser] :: ConnectInfo -> String
[connectPassword] :: ConnectInfo -> String
[connectDatabase] :: ConnectInfo -> String

-- | Default information for setting up a connection.
--   
--   Defaults are as follows:
--   
--   <ul>
--   <li>Server on <tt>localhost</tt></li>
--   <li>Port on <tt>5432</tt></li>
--   <li>User <tt>postgres</tt></li>
--   <li>No password</li>
--   <li>Database <tt>postgres</tt></li>
--   </ul>
--   
--   Use as in the following example:
--   
--   <pre>
--   connect defaultConnectInfo { connectHost = "db.example.com" }
--   </pre>
defaultConnectInfo :: ConnectInfo

-- | Attempt to make a connection based on a libpq connection string. See
--   <a>https://www.postgresql.org/docs/9.5/static/libpq-connect.html#LIBPQ-CONNSTRING</a>
--   for more information. Also note that environment variables also affect
--   parameters not provided, parameters provided as the empty string, and
--   a few other things; see
--   <a>https://www.postgresql.org/docs/9.5/static/libpq-envars.html</a>
--   for details. Here is an example with some of the most commonly used
--   parameters:
--   
--   <pre>
--   host='db.somedomain.com' port=5432 ...
--   </pre>
--   
--   This attempts to connect to <tt>db.somedomain.com:5432</tt>. Omitting
--   the port will normally default to 5432.
--   
--   On systems that provide unix domain sockets, omitting the host
--   parameter will cause libpq to attempt to connect via unix domain
--   sockets. The default filesystem path to the socket is constructed from
--   the port number and the <tt>DEFAULT_PGSOCKET_DIR</tt> constant defined
--   in the <tt>pg_config_manual.h</tt> header file. Connecting via unix
--   sockets tends to use the <tt>peer</tt> authentication method, which is
--   very secure and does not require a password.
--   
--   On Windows and other systems without unix domain sockets, omitting the
--   host will default to <tt>localhost</tt>.
--   
--   <pre>
--   ... dbname='postgres' user='postgres' password='secret \' \\ pw'
--   </pre>
--   
--   This attempts to connect to a database named <tt>postgres</tt> with
--   user <tt>postgres</tt> and password <tt>secret ' \ pw</tt>. Backslash
--   characters will have to be double-quoted in literal Haskell strings,
--   of course. Omitting <tt>dbname</tt> and <tt>user</tt> will both
--   default to the system username that the client process is running as.
--   
--   Omitting <tt>password</tt> will default to an appropriate password
--   found in the <tt>pgpass</tt> file, or no password at all if a matching
--   line is not found. The path of the <tt>pgpass</tt> file may be
--   specified by setting the <tt>PGPASSFILE</tt> environment variable. See
--   <a>https://www.postgresql.org/docs/9.5/static/libpq-pgpass.html</a>
--   for more information regarding this file.
--   
--   As all parameters are optional and the defaults are sensible, the
--   empty connection string can be useful for development and exploratory
--   use, assuming your system is set up appropriately.
--   
--   On Unix, such a setup would typically consist of a local postgresql
--   server listening on port 5432, as well as a system user, database
--   user, and database sharing a common name, with permissions granted to
--   the user on the database.
--   
--   On Windows, in addition you will either need <tt>pg_hba.conf</tt> to
--   specify the use of the <tt>trust</tt> authentication method for the
--   connection, which may not be appropriate for multiuser or production
--   machines, or you will need to use a <tt>pgpass</tt> file with the
--   <tt>password</tt> or <tt>md5</tt> authentication methods.
--   
--   See
--   <a>https://www.postgresql.org/docs/9.5/static/client-authentication.html</a>
--   for more information regarding the authentication process.
--   
--   SSL/TLS will typically "just work" if your postgresql server supports
--   or requires it. However, note that libpq is trivially vulnerable to a
--   MITM attack without setting additional SSL connection parameters. In
--   particular, <tt>sslmode</tt> needs to be set to <tt>require</tt>,
--   <tt>verify-ca</tt>, or <tt>verify-full</tt> in order to perform
--   certificate validation. When <tt>sslmode</tt> is <tt>require</tt>,
--   then you will also need to specify a <tt>sslrootcert</tt> file,
--   otherwise no validation of the server's identity will be performed.
--   Client authentication via certificates is also possible via the
--   <tt>sslcert</tt> and <tt>sslkey</tt> parameters. See
--   <a>https://www.postgresql.org/docs/9.5/static/libpq-ssl.html</a> for
--   detailed information regarding libpq and SSL.
connectPostgreSQL :: ByteString -> IO Connection

-- | Connect with the given username to the given database. Will throw an
--   exception if it cannot connect.
connect :: ConnectInfo -> IO Connection
close :: Connection -> IO ()


-- | The <tt>pgcrypto</tt> extension provides several cryptographic
--   functions to Postgres. This module provides a <tt>beam-postgres</tt>
--   extension to access this functionality. For an example of usage, see
--   the documentation for <a>PgExtensionEntity</a>.
module Database.Beam.Postgres.PgCrypto

-- | Data type representing definitions contained in the <tt>pgcrypto</tt>
--   extension
--   
--   Each field maps closely to the underlying <tt>pgcrypto</tt> function,
--   which are described in further detail in the <a>pgcrypto manual</a>.
data PgCrypto
PgCrypto :: (forall ctxt s. LiftPg ctxt s (Text -> Text -> ByteString)) -> (forall ctxt s. LiftPg ctxt s (ByteString -> Text -> ByteString)) -> (forall ctxt s. LiftPg ctxt s (Text -> Text -> Text -> ByteString)) -> (forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Text -> ByteString)) -> (forall ctxt s. LiftPg ctxt s (Text -> Text -> Text)) -> (forall ctxt s. LiftPg ctxt s (Text -> Maybe Int32 -> Text)) -> (forall ctxt s. LiftPg ctxt s (Text -> Text -> Maybe Text -> ByteString)) -> (forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Maybe Text -> ByteString)) -> (forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Maybe Text -> Text)) -> (forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Maybe Text -> ByteString)) -> (forall ctxt s. LiftPg ctxt s (Text -> ByteString -> Maybe Text -> ByteString)) -> (forall ctxt s. LiftPg ctxt s (ByteString -> ByteString -> Maybe Text -> ByteString)) -> (forall ctxt s. LiftPg ctxt s (ByteString -> ByteString -> Maybe Text -> Maybe Text -> Text)) -> (forall ctxt s. LiftPg ctxt s (ByteString -> ByteString -> Maybe Text -> Maybe Text -> ByteString)) -> (forall ctxt s. LiftPg ctxt s (ByteString -> Text)) -> (forall ctxt s. PgExpr ctxt s ByteString -> Maybe (PgExpr ctxt s (Vector Text), PgExpr ctxt s (Vector Text)) -> PgExpr ctxt s Text) -> (forall ctxt s. LiftPg ctxt s (Text -> ByteString)) -> (forall ctxt s i. Integral i => PgExpr ctxt s i -> PgExpr ctxt s ByteString) -> (forall ctxt s. PgExpr ctxt s UUID) -> PgCrypto
[pgCryptoDigestText] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (Text -> Text -> ByteString)
[pgCryptoDigestBytes] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (ByteString -> Text -> ByteString)
[pgCryptoHmacText] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (Text -> Text -> Text -> ByteString)
[pgCryptoHmacBytes] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Text -> ByteString)
[pgCryptoCrypt] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (Text -> Text -> Text)
[pgCryptoGenSalt] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (Text -> Maybe Int32 -> Text)
[pgCryptoPgpSymEncrypt] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (Text -> Text -> Maybe Text -> ByteString)
[pgCryptoPgpSymEncryptBytea] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Maybe Text -> ByteString)
[pgCryptoPgpSymDecrypt] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Maybe Text -> Text)
[pgCryptoPgpSymDecryptBytea] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (ByteString -> Text -> Maybe Text -> ByteString)
[pgCryptoPgpPubEncrypt] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (Text -> ByteString -> Maybe Text -> ByteString)
[pgCryptoPgpPubEncryptBytea] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (ByteString -> ByteString -> Maybe Text -> ByteString)
[pgCryptoPgpPubDecrypt] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (ByteString -> ByteString -> Maybe Text -> Maybe Text -> Text)
[pgCryptoPgpPubDecryptBytea] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (ByteString -> ByteString -> Maybe Text -> Maybe Text -> ByteString)
[pgCryptoPgpKeyId] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (ByteString -> Text)
[pgCryptoArmor] :: PgCrypto -> forall ctxt s. PgExpr ctxt s ByteString -> Maybe (PgExpr ctxt s (Vector Text), PgExpr ctxt s (Vector Text)) -> PgExpr ctxt s Text
[pgCryptoDearmor] :: PgCrypto -> forall ctxt s. LiftPg ctxt s (Text -> ByteString)
[pgCryptoGenRandomBytes] :: PgCrypto -> forall ctxt s i. Integral i => PgExpr ctxt s i -> PgExpr ctxt s ByteString
[pgCryptoGenRandomUUID] :: PgCrypto -> forall ctxt s. PgExpr ctxt s UUID
instance Database.Beam.Postgres.Extensions.IsPgExtension Database.Beam.Postgres.PgCrypto.PgCrypto


-- | The <tt>uuid-ossp</tt> extension provides functions for constructing
--   UUIDs.
--   
--   For an example of usage, see the documentation for
--   <a>PgExtensionEntity</a>.
module Database.Beam.Postgres.Extensions.UuidOssp

-- | Data type representing definitions contained in the <tt>uuid-ossp</tt>
--   extension
data UuidOssp
UuidOssp :: (forall ctxt s. LiftPg ctxt s UUID) -> (forall ctxt s. LiftPg ctxt s UUID) -> (forall ctxt s. LiftPg ctxt s UUID) -> (forall ctxt s. LiftPg ctxt s UUID) -> (forall ctxt s. LiftPg ctxt s UUID) -> (forall ctxt s. LiftPg ctxt s UUID) -> (forall ctxt s. LiftPg ctxt s UUID) -> (forall ctxt s. LiftPg ctxt s (UUID -> Text -> UUID)) -> (forall ctxt s. LiftPg ctxt s UUID) -> (forall ctxt s. LiftPg ctxt s (UUID -> Text -> UUID)) -> UuidOssp
[pgUuidNil] :: UuidOssp -> forall ctxt s. LiftPg ctxt s UUID
[pgUuidNsDns] :: UuidOssp -> forall ctxt s. LiftPg ctxt s UUID
[pgUuidNsUrl] :: UuidOssp -> forall ctxt s. LiftPg ctxt s UUID
[pgUuidNsOid] :: UuidOssp -> forall ctxt s. LiftPg ctxt s UUID
[pgUuidNsX500] :: UuidOssp -> forall ctxt s. LiftPg ctxt s UUID
[pgUuidGenerateV1] :: UuidOssp -> forall ctxt s. LiftPg ctxt s UUID
[pgUuidGenerateV1Mc] :: UuidOssp -> forall ctxt s. LiftPg ctxt s UUID
[pgUuidGenerateV3] :: UuidOssp -> forall ctxt s. LiftPg ctxt s (UUID -> Text -> UUID)
[pgUuidGenerateV4] :: UuidOssp -> forall ctxt s. LiftPg ctxt s UUID
[pgUuidGenerateV5] :: UuidOssp -> forall ctxt s. LiftPg ctxt s (UUID -> Text -> UUID)
instance Database.Beam.Postgres.Extensions.IsPgExtension Database.Beam.Postgres.Extensions.UuidOssp.UuidOssp
