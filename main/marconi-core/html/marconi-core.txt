-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Indexers that can rewind the state to a previous version.
--   
--   Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/marconi-core#README.md</a>
@package marconi-core
@version 1.2.0.0

module Marconi.Core.Index.VSplit
data SplitIndex m h v e n q r
SplitIndex :: h -> Storage v m e -> [n] -> (SplitIndex m h v e n q r -> m ()) -> (SplitIndex m h v e n q r -> q -> [e] -> m r) -> (SplitIndex m h v e n q r -> e -> m [n]) -> SplitIndex m h v e n q r
[_handle] :: SplitIndex m h v e n q r -> h
[_storage] :: SplitIndex m h v e n q r -> Storage v m e
[_notifications] :: SplitIndex m h v e n q r -> [n]
[_store] :: SplitIndex m h v e n q r -> SplitIndex m h v e n q r -> m ()
[_query] :: SplitIndex m h v e n q r -> SplitIndex m h v e n q r -> q -> [e] -> m r
[_onInsert] :: SplitIndex m h v e n q r -> SplitIndex m h v e n q r -> e -> m [n]
new :: Monad m => MVector (Mutable v) e => (SplitIndex m h v e n q r -> q -> [e] -> m r) -> (SplitIndex m h v e n q r -> m ()) -> (SplitIndex m h v e n q r -> e -> m [n]) -> Int -> h -> Mutable v (PrimState m) e -> m (Maybe (SplitIndex m h v e n q r))
newBoxed :: Monad m => PrimMonad m => (BoxedIndex m h e n q r -> q -> [e] -> m r) -> (BoxedIndex m h e n q r -> m ()) -> (BoxedIndex m h e n q r -> e -> m [n]) -> Int -> Int -> h -> m (Maybe (BoxedIndex m h e n q r))
newUnboxed :: Monad m => PrimMonad m => MVector MVector e => (UnboxedIndex m h e n q r -> q -> [e] -> m r) -> (UnboxedIndex m h e n q r -> m ()) -> (UnboxedIndex m h e n q r -> e -> m [n]) -> Int -> Int -> h -> m (Maybe (UnboxedIndex m h e n q r))
insert :: forall m h v e n q r. Monad m => PrimMonad m => MVector (Mutable v) e => e -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
insertL :: PrimMonad m => MVector (Mutable v) e => [e] -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
size :: SplitIndex m h v e n q r -> Int
rewind :: MVector (Mutable v) e => Int -> SplitIndex m h v e n q r -> Maybe (SplitIndex m h v e n q r)
handle :: forall m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V. Lens' (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V) h_a94Q
storage :: forall m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V. Lens' (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V) (Storage v_a94R m_a94P e_a94S)
notifications :: forall m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V. Lens' (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V) [n_a94T]
store :: forall m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V. Lens' (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V) (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V -> m_a94P ())
query :: forall m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V. Lens' (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V) (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V -> q_a94U -> [e_a94S] -> m_a94P r_a94V)
onInsert :: forall m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V. Lens' (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V) (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V -> e_a94S -> m_a94P [n_a94T])
data Storage v m e
Storage :: Mutable v (PrimState m) e -> Int -> Int -> Int -> Int -> Storage v m e
[_events] :: Storage v m e -> Mutable v (PrimState m) e
[_cursor] :: Storage v m e -> Int
[_eSize] :: Storage v m e -> Int
[_bSize] :: Storage v m e -> Int
[_k] :: Storage v m e -> Int
getBuffer :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
getEvents :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
k :: forall v_a7xa m_a7xb e_a7xc. Lens' (Storage v_a7xa m_a7xb e_a7xc) Int

module Marconi.Core.Index.VSqlite
type SqliteIndex e n q r = SplitIndex IO Connection Vector e n q r
new :: (SqliteIndex e n q r -> q -> [e] -> IO r) -> (SqliteIndex e n q r -> IO ()) -> (SqliteIndex e n q r -> e -> IO [n]) -> Int -> FilePath -> Mutable Vector (PrimState IO) e -> IO (Maybe (SqliteIndex e n q r))
newBoxed :: (BoxedIndex e n q r -> q -> [e] -> IO r) -> (BoxedIndex e n q r -> IO ()) -> (BoxedIndex e n q r -> e -> IO [n]) -> Int -> Int -> FilePath -> IO (Maybe (BoxedIndex e n q r))
insert :: forall m h v e n q r. Monad m => PrimMonad m => MVector (Mutable v) e => e -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
insertL :: PrimMonad m => MVector (Mutable v) e => [e] -> SplitIndex m h v e n q r -> m (SplitIndex m h v e n q r)
size :: SplitIndex m h v e n q r -> Int
rewind :: MVector (Mutable v) e => Int -> SplitIndex m h v e n q r -> Maybe (SplitIndex m h v e n q r)
getEvents :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
getBuffer :: forall v m e. MVector (Mutable v) e => PrimMonad m => Show e => Storage v m e -> m [e]
handle :: forall m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V. Lens' (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V) h_a94Q
storage :: forall m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V. Lens' (SplitIndex m_a94P h_a94Q v_a94R e_a94S n_a94T q_a94U r_a94V) (Storage v_a94R m_a94P e_a94S)

module Marconi.Core.Storable
data Config
memoryBufferSize :: Iso' Config Int
data State h
handle :: forall h_ajTk. Lens' (State h_ajTk) h_ajTk
config :: forall h_ajTk. Lens' (State h_ajTk) Config
emptyState :: PrimMonad (StorableMonad h) => Int -> h -> StorableMonad h (State h)
data Storage h
storage :: forall h_ajTk. Lens' (State h_ajTk) (Storage h_ajTk)
events :: forall h_ajOw h_ajT4. Lens (Storage h_ajOw) (Storage h_ajT4) (MVector (PrimState (StorableMonad h_ajOw)) (SyntheticEvent (StorableEvent h_ajOw) (StorablePoint h_ajOw))) (MVector (PrimState (StorableMonad h_ajT4)) (SyntheticEvent (StorableEvent h_ajT4) (StorablePoint h_ajT4)))
cursor :: forall h_ajOw. Lens' (Storage h_ajOw) Int
getMemoryEvents :: Storage h -> MVector (PrimState (StorableMonad h)) (SyntheticEvent (StorableEvent h) (StorablePoint h))
getEvents :: Buffered h => PrimMonad (StorableMonad h) => State h -> StorableMonad h [StorableEvent h]
filterWithQueryInterval :: forall h. HasPoint (StorableEvent h) (StorablePoint h) => Ord (StorablePoint h) => QueryInterval (StorablePoint h) -> [StorableEvent h] -> [StorableEvent h]
data family StorableEvent h

-- | The resume and query functionality requires a way to specify points on
--   the chain from which we want to resume, or points up to which we want
--   to query.
type family StorablePoint h
data family StorableQuery h
data family StorableResult h
type family StorableMonad h :: * -> *
data QueryInterval p
QEverything :: QueryInterval p
QInterval :: p -> p -> QueryInterval p
data SyntheticEvent e p
Event :: !e -> SyntheticEvent e p
Synthetic :: !p -> SyntheticEvent e p
class Buffered h

-- | This function persists the memory/buffer events to disk when the
--   memory buffer is filled.
persistToStorage :: (Buffered h, Foldable f) => f (StorableEvent h) -> h -> StorableMonad h h
getStoredEvents :: Buffered h => h -> StorableMonad h [StorableEvent h]
class Queryable h
queryStorage :: (Queryable h, Foldable f) => QueryInterval (StorablePoint h) -> f (StorableEvent h) -> h -> StorableQuery h -> StorableMonad h (StorableResult h)
class Resumable h
resumeFromStorage :: Resumable h => h -> StorableMonad h [StorablePoint h]
class Rewindable h
rewindStorage :: Rewindable h => StorablePoint h -> h -> StorableMonad h (Maybe h)
class HasPoint e p
getPoint :: HasPoint e p => e -> p
syntheticPoint :: HasPoint e p => SyntheticEvent e p -> p
foldEvents :: forall f h. Foldable f => f (SyntheticEvent (StorableEvent h) (StorablePoint h)) -> [StorableEvent h]
insert :: Buffered h => PrimMonad (StorableMonad h) => StorableEvent h -> State h -> StorableMonad h (State h)
checkpoint :: Buffered h => PrimMonad (StorableMonad h) => StorablePoint h -> State h -> StorableMonad h (State h)
insertMany :: Foldable f => Buffered h => PrimMonad (StorableMonad h) => f (StorableEvent h) -> State h -> StorableMonad h (State h)
rewind :: forall h. Rewindable h => HasPoint (StorableEvent h) (StorablePoint h) => PrimMonad (StorableMonad h) => Ord (StorablePoint h) => StorablePoint h -> State h -> StorableMonad h (Maybe (State h))
resume :: Resumable h => State h -> StorableMonad h [StorablePoint h]
query :: HasPoint (StorableEvent h) (StorablePoint h) => Ord (StorablePoint h) => Queryable h => PrimMonad (StorableMonad h) => QueryInterval (StorablePoint h) -> State h -> StorableQuery h -> StorableMonad h (StorableResult h)
instance GHC.Generics.Generic (Marconi.Core.Storable.QueryInterval p)
instance GHC.Classes.Eq p => GHC.Classes.Eq (Marconi.Core.Storable.QueryInterval p)
instance GHC.Show.Show p => GHC.Show.Show (Marconi.Core.Storable.QueryInterval p)
instance GHC.Classes.Eq Marconi.Core.Storable.Config
instance GHC.Show.Show Marconi.Core.Storable.Config

module Marconi.Core.TracedStorable
data Config
memoryBufferSize :: Iso' Config Int
data State h
handle :: forall h_andF. Lens' (State h_andF) h_andF
config :: forall h_andF. Lens' (State h_andF) Config
emptyState :: PrimMonad (StorableMonad h) => Int -> h -> StorableMonad h (State h)
data Storage h
storage :: forall h_andF. Lens' (State h_andF) (Storage h_andF)
events :: forall h_anat h_andp. Lens (Storage h_anat) (Storage h_andp) (MVector (PrimState (StorableMonad h_anat)) (SyntheticEvent (StorableEvent h_anat) (StorablePoint h_anat))) (MVector (PrimState (StorableMonad h_andp)) (SyntheticEvent (StorableEvent h_andp) (StorablePoint h_andp)))
cursor :: forall h_anat. Lens' (Storage h_anat) Int
getMemoryEvents :: Storage h -> MVector (PrimState (StorableMonad h)) (SyntheticEvent (StorableEvent h) (StorablePoint h))
getEvents :: Buffered h => PrimMonad (StorableMonad h) => State h -> StorableMonad h [StorableEvent h]
data family StorableEvent h

-- | The resume and query functionality requires a way to specify points on
--   the chain from which we want to resume, or points up to which we want
--   to query.
type family StorablePoint h
data family StorableQuery h
data family StorableResult h
type family StorableMonad h :: * -> *
data family StorableNotifications h
data SyntheticEvent e p
Event :: !e -> SyntheticEvent e p
Synthetic :: !p -> SyntheticEvent e p
data ControlNotification pt n
CNRollForward :: !pt -> ControlNotification pt n
CNRollBack :: !pt -> ControlNotification pt n
CNApplication :: !n -> ControlNotification pt n
class Buffered h

-- | This function persists the memory/buffer events to disk when the
--   memory buffer is filled.
persistToStorage :: (Buffered h, Foldable f) => AppTracer h -> f (StorableEvent h) -> h -> StorableMonad h h
getStoredEvents :: Buffered h => h -> StorableMonad h [StorableEvent h]
class Queryable h
queryStorage :: (Queryable h, Foldable f) => AppTracer h -> StorablePoint h -> f (StorableEvent h) -> h -> StorableQuery h -> StorableMonad h (StorableResult h)
class Resumable h
resumeFromStorage :: Resumable h => AppTracer h -> h -> StorableMonad h [StorablePoint h]
class Rewindable h
rewindStorage :: Rewindable h => AppTracer h -> StorablePoint h -> h -> StorableMonad h (Maybe h)
class HasPoint e p
getPoint :: HasPoint e p => e -> p
syntheticPoint :: HasPoint e p => SyntheticEvent e p -> p
foldEvents :: forall f h. Foldable f => f (SyntheticEvent (StorableEvent h) (StorablePoint h)) -> [StorableEvent h]
insert :: Buffered h => PrimMonad (StorableMonad h) => HasPoint (StorableEvent h) (StorablePoint h) => ControlTracer h -> StorableEvent h -> State h -> StorableMonad h (State h)
checkpoint :: Buffered h => PrimMonad (StorableMonad h) => AppTracer h -> StorablePoint h -> State h -> StorableMonad h (State h)
insertMany :: Foldable f => Buffered h => PrimMonad (StorableMonad h) => HasPoint (StorableEvent h) (StorablePoint h) => ControlTracer h -> f (StorableEvent h) -> State h -> StorableMonad h (State h)
rewind :: forall h. Rewindable h => PrimMonad (StorableMonad h) => Ord (StorablePoint h) => HasPoint (StorableEvent h) (StorablePoint h) => ControlTracer h -> StorablePoint h -> State h -> StorableMonad h (Maybe (State h))
resume :: Resumable h => AppTracer h -> State h -> StorableMonad h [StorablePoint h]
query :: Queryable h => PrimMonad (StorableMonad h) => AppTracer h -> StorablePoint h -> State h -> StorableQuery h -> StorableMonad h (StorableResult h)
instance GHC.Generics.Generic (Marconi.Core.TracedStorable.ControlNotification pt n)
instance GHC.Classes.Eq Marconi.Core.TracedStorable.Config
instance GHC.Show.Show Marconi.Core.TracedStorable.Config
