-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Instances of standard classes that are made possible by enumerations
--   
--   For example this package provides a <tt>Eq (a -&gt; b)</tt> instance:
--   
--   <pre>
--   instance (Finite a, Eq b) =&gt; Eq (a -&gt; b) where
--   f == g = and [f x == g x | x &lt;- universeF]
--   </pre>
@package universe-reverse-instances
@version 1.1.1

module Data.Universe.Instances.Eq

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   The Haskell Report defines no laws for <a>Eq</a>. However, <a>==</a>
--   is customarily expected to implement an equivalence relationship where
--   two values comparing equal are indistinguishable by "public"
--   functions, with a "public" function being one not allowing to see
--   implementation details. For example, for a type representing
--   non-normalised natural numbers modulo 100, a "public" function doesn't
--   make the difference between 1 and 201. It is expected to have the
--   following properties:
--   
--   <ul>
--   <li><i><b>Reflexivity</b></i> <tt>x == x</tt> = <a>True</a></li>
--   <li><i><b>Symmetry</b></i> <tt>x == y</tt> = <tt>y == x</tt></li>
--   <li><i><b>Transitivity</b></i> if <tt>x == y &amp;&amp; y == z</tt> =
--   <a>True</a>, then <tt>x == z</tt> = <a>True</a></li>
--   <li><i><b>Substitutivity</b></i> if <tt>x == y</tt> = <a>True</a> and
--   <tt>f</tt> is a "public" function whose return type is an instance of
--   <a>Eq</a>, then <tt>f x == f y</tt> = <a>True</a></li>
--   <li><i><b>Negation</b></i> <tt>x /= y</tt> = <tt>not (x ==
--   y)</tt></li>
--   </ul>
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool
infix 4 ==
infix 4 /=
instance (Data.Universe.Class.Finite a, GHC.Classes.Eq b) => GHC.Classes.Eq (a -> b)
instance (Data.Universe.Class.Finite a, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.Semigroup.Internal.Endo a)

module Data.Universe.Instances.Ord

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   The Haskell Report defines no laws for <a>Ord</a>. However,
--   <a>&lt;=</a> is customarily expected to implement a non-strict partial
--   order and have the following properties:
--   
--   <ul>
--   <li><i><b>Transitivity</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   z</tt> = <a>True</a>, then <tt>x &lt;= z</tt> = <a>True</a></li>
--   <li><i><b>Reflexivity</b></i> <tt>x &lt;= x</tt> = <a>True</a></li>
--   <li><i><b>Antisymmetry</b></i> if <tt>x &lt;= y &amp;&amp; y &lt;=
--   x</tt> = <a>True</a>, then <tt>x == y</tt> = <a>True</a></li>
--   </ul>
--   
--   Note that the following operator interactions are expected to hold:
--   
--   <ol>
--   <li><tt>x &gt;= y</tt> = <tt>y &lt;= x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>x &lt;= y &amp;&amp; x /= y</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>y &lt; x</tt></li>
--   <li><tt>x &lt; y</tt> = <tt>compare x y == LT</tt></li>
--   <li><tt>x &gt; y</tt> = <tt>compare x y == GT</tt></li>
--   <li><tt>x == y</tt> = <tt>compare x y == EQ</tt></li>
--   <li><tt>min x y == if x &lt;= y then x else y</tt> = <a>True</a></li>
--   <li><tt>max x y == if x &gt;= y then x else y</tt> = <a>True</a></li>
--   </ol>
--   
--   Note that (7.) and (8.) do <i>not</i> require <a>min</a> and
--   <a>max</a> to return either of their arguments. The result is merely
--   required to <i>equal</i> one of the arguments in terms of <a>(==)</a>.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a
infix 4 >=
infix 4 >
infix 4 <=
infix 4 <
instance (Data.Universe.Class.Finite a, GHC.Classes.Ord b) => GHC.Classes.Ord (a -> b)
instance (Data.Universe.Class.Finite a, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.Semigroup.Internal.Endo a)


-- | A <a>Read</a> instance for functions, given the input is <a>Finite</a>
--   and <a>Ord</a> and both the input and output are <a>Read</a>.
module Data.Universe.Instances.Read
instance (Data.Universe.Class.Finite a, GHC.Classes.Ord a, GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (a -> b)
instance (Data.Universe.Class.Finite a, GHC.Classes.Ord a, GHC.Read.Read a) => GHC.Read.Read (Data.Semigroup.Internal.Endo a)


-- | A <a>Show</a> instance for functions, given the input is <a>Finite</a>
--   and both the input and output are <a>Show</a>.
module Data.Universe.Instances.Show
instance (Data.Universe.Class.Finite a, GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (a -> b)
instance (Data.Universe.Class.Finite a, GHC.Show.Show a) => GHC.Show.Show (Data.Semigroup.Internal.Endo a)


-- | A <a>Foldable</a> instance for functions, given the input is
--   <a>Finite</a>, and a <a>Traversable</a> instance for functions, given
--   the input is <a>Ord</a> and <a>Finite</a>.
module Data.Universe.Instances.Traversable
instance Data.Universe.Class.Finite e => Data.Foldable.Foldable ((->) e)
instance (GHC.Classes.Ord e, Data.Universe.Class.Finite e) => Data.Traversable.Traversable ((->) e)
