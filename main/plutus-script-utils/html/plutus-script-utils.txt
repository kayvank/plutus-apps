-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Helper/utility functions for writing Plutus scripts.
--   
--   Helper/utility functions for writing Plutus scripts.
@package plutus-script-utils
@version 1.2.0.0


-- | Functions for working with <a>Ada</a> in Template Haskell.
module Plutus.Script.Utils.Ada

-- | ADA, the special currency on the Cardano blockchain. The unit of Ada
--   is Lovelace, and 1M Lovelace is one Ada. See note [Currencies] in
--   <a>TH</a>.
newtype Ada
Lovelace :: Integer -> Ada
[getLovelace] :: Ada -> Integer

-- | Get the amount of Ada (the unit of the currency Ada) in this
--   <a>Ada</a> value.
getAda :: Ada -> Micro

-- | The <a>CurrencySymbol</a> of the <a>Ada</a> currency.
adaSymbol :: CurrencySymbol

-- | The <a>TokenName</a> of the <a>Ada</a> currency.
adaToken :: TokenName

-- | Get the <a>Ada</a> in the given <a>Value</a>.
fromValue :: Value -> Ada

-- | Create a <a>Value</a> containing only the given <a>Ada</a>.
toValue :: Ada -> Value

-- | Create <a>Ada</a> representing the given quantity of Lovelace (the
--   unit of the currency Ada).
lovelaceOf :: Integer -> Ada

-- | Create <a>Ada</a> representing the given quantity of Ada (1M
--   Lovelace).
adaOf :: Micro -> Ada

-- | A <a>Value</a> with the given amount of Lovelace (the currency unit).
--   
--   <pre>
--   lovelaceValueOf == toValue . lovelaceOf
--   </pre>
lovelaceValueOf :: Integer -> Value

-- | A <a>Value</a> with the given amount of Ada (the currency unit).
--   
--   <pre>
--   adaValueOf == toValue . adaOf
--   </pre>
adaValueOf :: Micro -> Value

-- | Divide one <a>Ada</a> value by another.
divide :: Ada -> Ada -> Ada

-- | Check whether an <a>Ada</a> value is zero.
isZero :: Ada -> Bool
instance PlutusTx.Lift.Class.Typeable PlutusCore.Default.Universe.DefaultUni Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Lift.Class.Lift PlutusCore.Default.Universe.DefaultUni Plutus.Script.Utils.Ada.Ada
instance Prettyprinter.Internal.Pretty Plutus.Script.Utils.Ada.Ada
instance PlutusTx.IsData.Class.UnsafeFromData Plutus.Script.Utils.Ada.Ada
instance PlutusTx.IsData.Class.FromData Plutus.Script.Utils.Ada.Ada
instance PlutusTx.IsData.Class.ToData Plutus.Script.Utils.Ada.Ada
instance Codec.Serialise.Class.Serialise Plutus.Script.Utils.Ada.Ada
instance GHC.Real.Real Plutus.Script.Utils.Ada.Ada
instance GHC.Real.Integral Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Numeric.MultiplicativeMonoid Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Numeric.MultiplicativeSemigroup Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Numeric.AdditiveGroup Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Numeric.AdditiveMonoid Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Numeric.AdditiveSemigroup Plutus.Script.Utils.Ada.Ada
instance GHC.Num.Num Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Ord.Ord Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Eq.Eq Plutus.Script.Utils.Ada.Ada
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Script.Utils.Ada.Ada
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Script.Utils.Ada.Ada
instance GHC.Generics.Generic Plutus.Script.Utils.Ada.Ada
instance GHC.Show.Show Plutus.Script.Utils.Ada.Ada
instance GHC.Classes.Ord Plutus.Script.Utils.Ada.Ada
instance GHC.Classes.Eq Plutus.Script.Utils.Ada.Ada
instance GHC.Enum.Enum Plutus.Script.Utils.Ada.Ada
instance GHC.Base.Semigroup Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Semigroup.Semigroup Plutus.Script.Utils.Ada.Ada
instance GHC.Base.Monoid Plutus.Script.Utils.Ada.Ada
instance PlutusTx.Monoid.Monoid Plutus.Script.Utils.Ada.Ada


-- | This module contains functions related to versioning scripts and
--   BuiltinData, or more specifially, <tt>Datum</tt>s and
--   <tt>Redeemer</tt>s. These functions do not depend on a particular
--   version of Plutus.
module Plutus.Script.Utils.Scripts

-- | Non-Native Script language. This is an Enumerated type. This is
--   expected to be an open type. We will add new Constuctors to this type
--   as additional Non-Native scripting language as are added. We use an
--   enumerated type for two reasons. 1) We can write total functions by
--   case analysis over the constructors 2) We will use DataKinds to make
--   some datatypes indexed by Language For now, the only Non-Native
--   Scriting language is Plutus We might add new languages in the futures.
--   
--   Note that the the serialization of <a>Language</a> depends on the
--   ordering.
data Language
PlutusV1 :: Language
PlutusV2 :: Language

-- | A script of some kind with its Plutus language version
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language

-- | Hash a <a>Versioned</a> <tt>Script</tt>
scriptHash :: Versioned Script -> ScriptHash

-- | Hash a <a>Versioned</a> <a>Validator</a> script.
validatorHash :: Versioned Validator -> ValidatorHash

-- | Hash a <a>Versioned</a> <a>MintingPolicy</a> script.
mintingPolicyHash :: Versioned MintingPolicy -> MintingPolicyHash

-- | Hash a <a>Versioned</a> <a>StakeValidator</a> script.
stakeValidatorHash :: Versioned StakeValidator -> StakeValidatorHash

-- | The <tt>CurrencySymbol</tt> of a <tt>MintingPolicy</tt>.
scriptCurrencySymbol :: Versioned MintingPolicy -> CurrencySymbol

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
data Datum

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
data DatumHash

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
data Redeemer

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
data RedeemerHash

-- | Hash a 'PV1.Datum builtin data.
datumHash :: Datum -> DatumHash

-- | Hash a <a>Redeemer</a> builtin data.
redeemerHash :: Redeemer -> RedeemerHash

-- | Hash a <a>BuiltinData</a>
dataHash :: BuiltinData -> BuiltinByteString
instance Codec.Serialise.Class.Serialise script => Codec.Serialise.Class.Serialise (Plutus.Script.Utils.Scripts.Versioned script)
instance Data.Aeson.Types.FromJSON.FromJSON script => Data.Aeson.Types.FromJSON.FromJSON (Plutus.Script.Utils.Scripts.Versioned script)
instance Data.Aeson.Types.ToJSON.ToJSON script => Data.Aeson.Types.ToJSON.ToJSON (Plutus.Script.Utils.Scripts.Versioned script)
instance GHC.Generics.Generic (Plutus.Script.Utils.Scripts.Versioned script)
instance GHC.Base.Functor Plutus.Script.Utils.Scripts.Versioned
instance GHC.Classes.Ord script => GHC.Classes.Ord (Plutus.Script.Utils.Scripts.Versioned script)
instance GHC.Classes.Eq script => GHC.Classes.Eq (Plutus.Script.Utils.Scripts.Versioned script)
instance GHC.Show.Show script => GHC.Show.Show (Plutus.Script.Utils.Scripts.Versioned script)
instance Codec.Serialise.Class.Serialise Cardano.Ledger.Alonzo.Language.Language
instance Prettyprinter.Internal.Pretty script => Prettyprinter.Internal.Pretty (Plutus.Script.Utils.Scripts.Versioned script)
instance Prettyprinter.Internal.Pretty Cardano.Ledger.Alonzo.Language.Language

module Plutus.Script.Utils.V1.Contexts

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value locked by the given validator in this transaction.
valueLockedBy :: TxInfo -> ValidatorHash -> Value

-- | Get the list of <a>TxOut</a> outputs of the pending transaction at a
--   given script address.
scriptOutputsAt :: ValidatorHash -> TxInfo -> [(DatumHash, Value)]

-- | Convert a <a>CurrencySymbol</a> to a <a>ValidatorHash</a>
fromSymbol :: CurrencySymbol -> ValidatorHash

-- | Get the hash of the validator script that is currently being
--   validated.
ownHash :: ScriptContext -> ValidatorHash

-- | Get the validator and datum hashes of the output that is curently
--   being validated
ownHashes :: ScriptContext -> (ValidatorHash, DatumHash)

-- | Get the public key hash that locks the transaction output, if any.
pubKeyOutput :: TxOut -> Maybe PubKeyHash

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Finds all the outputs that pay to the same script address that we are
--   currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> [(StakingCredential, Integer)] -> POSIXTimeRange -> [PubKeyHash] -> [(DatumHash, Datum)] -> TxId -> TxInfo

-- | Transaction inputs
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> [(StakingCredential, Integer)]

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoData] :: TxInfo -> [(DatumHash, Datum)]

-- | Hash of the pending transaction (excluding witnesses)
[txInfoId] :: TxInfo -> TxId
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | A transaction ID, using a SHA256 hash as the transaction id.
newtype TxId
TxId :: BuiltinByteString -> TxId
[getTxId] :: TxId -> BuiltinByteString

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer

-- | A transaction output, consisting of a target address, a value, and
--   optionally a datum hash.
data TxOut
TxOut :: Address -> Value -> Maybe DatumHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatumHash] :: TxOut -> Maybe DatumHash

-- | Get the values paid to a public key address by a pending transaction.
outputsAt :: Address -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> Address -> Value


-- | This module contains functions related to the computation of script
--   hashes for PlutusV1.
module Plutus.Script.Utils.V1.Scripts

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
data Validator

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
data ValidatorHash

-- | <a>MintingPolicy</a> is a wrapper around <a>Script</a>s which are used
--   as validators for minting constraints.
data MintingPolicy

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
data MintingPolicyHash

-- | <a>StakeValidator</a> is a wrapper around <a>Script</a>s which are
--   used as validators for withdrawals and stake address certificates.
data StakeValidator

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
data StakeValidatorHash

-- | Transform a Cardano Script hash in a Plutus Script hash
fromCardanoHash :: ScriptHash -> ScriptHash

-- | Hash a <a>Validator</a> script.
validatorHash :: Validator -> ValidatorHash

-- | Hash a <a>MintingPolicy</a> script.
mintingPolicyHash :: MintingPolicy -> MintingPolicyHash

-- | Hash a <a>StakeValidator</a> script.
stakeValidatorHash :: StakeValidator -> StakeValidatorHash

-- | Hash a <tt>Script</tt>
scriptHash :: Script -> ScriptHash

-- | The <tt>CurrencySymbol</tt> of a <tt>MintingPolicy</tt>.
scriptCurrencySymbol :: MintingPolicy -> CurrencySymbol

-- | Convert a <tt>Script</tt> to a 'cardano-api' script.
--   
--   For why we depend on `cardano-api`, see note [Hash computation of
--   datums, redeemers and scripts]
toCardanoApiScript :: Script -> Script PlutusScriptV1

module Plutus.Script.Utils.V1.Generators
alwaysSucceedValidator :: Validator
alwaysSucceedValidatorVersioned :: Versioned Validator
alwaysSucceedValidatorHash :: ValidatorHash
alwaysSucceedPolicy :: MintingPolicy
alwaysSucceedPolicyVersioned :: Versioned MintingPolicy
alwaysSucceedPolicyHash :: MintingPolicyHash
someTokenValue :: TokenName -> Integer -> Value

module Plutus.Script.Utils.V1.Address

-- | The address that should be used by a transaction output locked by the
--   given Plutus V1 validator script.
mkValidatorAddress :: Validator -> Address

-- | Cardano address of a <a>Validator</a> script.
mkValidatorCardanoAddress :: NetworkId -> Validator -> AddressInEra BabbageEra

-- | Cardano address of a <a>MintingPolicy</a> script.
mkMintingPolicyCardanoAddress :: NetworkId -> MintingPolicy -> AddressInEra BabbageEra

-- | Cardano address of a <a>MintingPolicy</a> script.
mkStakeValidatorCardanoAddress :: NetworkId -> StakeValidator -> AddressInEra BabbageEra

module Plutus.Script.Utils.V1.Tx

-- | Create a transaction output locked by a validator script and attach
--   the given data script.
scriptTxOut :: Validator -> Value -> Datum -> TxOut

-- | Create a transaction output locked by a validator script hash with the
--   given data script attached.
scriptAddressTxOut :: Address -> Value -> Datum -> TxOut

module Plutus.Script.Utils.V2.Contexts

-- | Check if the pending transaction spends a specific transaction output
--   (identified by the hash of a transaction and an index into that
--   transactions' outputs)
spendsOutput :: TxInfo -> TxId -> Integer -> Bool

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol

-- | Get the total value of outputs produced by this transaction.
valueProduced :: TxInfo -> Value

-- | Get the total value of inputs spent by this transaction.
valueSpent :: TxInfo -> Value

-- | Get the values paid to a public key address by a pending transaction.
pubKeyOutputsAt :: PubKeyHash -> TxInfo -> [Value]

-- | Get the total value locked by the given validator in this transaction.
valueLockedBy :: TxInfo -> ValidatorHash -> Value

-- | Get the list of <a>TxOut</a> outputs of the pending transaction at a
--   given script address.
scriptOutputsAt :: ValidatorHash -> TxInfo -> [(OutputDatum, Value)]

-- | Get the hash of the validator script that is currently being
--   validated.
ownHash :: ScriptContext -> ValidatorHash

-- | Get the validator and datum hashes of the output that is curently
--   being validated
ownHashes :: ScriptContext -> (ValidatorHash, OutputDatum)

-- | Check if a transaction was signed by the given public key.
txSignedBy :: TxInfo -> PubKeyHash -> Bool

-- | Get all the outputs that pay to the same script address we are
--   currently spending from, if any.
getContinuingOutputs :: ScriptContext -> [TxOut]

-- | Find the indices of all the outputs that pay to the same script
--   address we are currently spending from, if any.
findContinuingOutputs :: ScriptContext -> [Integer]

-- | Find the hash of a datum, if it is part of the pending transaction's
--   hashes
findDatumHash :: Datum -> TxInfo -> Maybe DatumHash

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | An input of a pending transaction.
data TxInInfo
TxInInfo :: TxOutRef -> TxOut -> TxInInfo
[txInInfoOutRef] :: TxInInfo -> TxOutRef
[txInInfoResolved] :: TxInInfo -> TxOut

-- | A pending transaction. This is the view as seen by validator scripts,
--   so some details are stripped out.
data TxInfo
TxInfo :: [TxInInfo] -> [TxInInfo] -> [TxOut] -> Value -> Value -> [DCert] -> Map StakingCredential Integer -> POSIXTimeRange -> [PubKeyHash] -> Map ScriptPurpose Redeemer -> Map DatumHash Datum -> TxId -> TxInfo

-- | Transaction inputs
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> [TxInInfo]

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> [DCert]

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> Map StakingCredential Integer

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> POSIXTimeRange

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]
[txInfoRedeemers] :: TxInfo -> Map ScriptPurpose Redeemer
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction (excluding witnesses)
[txInfoId] :: TxInfo -> TxId
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext
[scriptContextTxInfo] :: ScriptContext -> TxInfo
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Convert a <a>CurrencySymbol</a> to a <a>ValidatorHash</a>
fromSymbol :: CurrencySymbol -> ValidatorHash

-- | Get the public key hash that locks the transaction output, if any.
pubKeyOutput :: TxOut -> Maybe PubKeyHash

-- | Purpose of the script that is currently running
data ScriptPurpose
Minting :: CurrencySymbol -> ScriptPurpose
Spending :: TxOutRef -> ScriptPurpose
Rewarding :: StakingCredential -> ScriptPurpose
Certifying :: DCert -> ScriptPurpose

-- | A transaction output, consisting of a target address, a value,
--   optionally a datum/datum hash, and optionally a reference script.
data TxOut
TxOut :: Address -> Value -> OutputDatum -> Maybe ScriptHash -> TxOut
[txOutAddress] :: TxOut -> Address
[txOutValue] :: TxOut -> Value
[txOutDatum] :: TxOut -> OutputDatum
[txOutReferenceScript] :: TxOut -> Maybe ScriptHash

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
data TxOutRef
TxOutRef :: TxId -> Integer -> TxOutRef
[txOutRefId] :: TxOutRef -> TxId

-- | Index into the referenced transaction's outputs
[txOutRefIdx] :: TxOutRef -> Integer
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo
findTxRefInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | Get the values paid to a public key address by a pending transaction.
outputsAt :: Address -> TxInfo -> [Value]

-- | Get the total value paid to a public key address by a pending
--   transaction.
valuePaidTo :: TxInfo -> Address -> Value

module Plutus.Script.Utils.V2.Scripts

-- | <a>Datum</a> is a wrapper around <tt>Data</tt> values which are used
--   as data in transaction outputs.
data Datum

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
data DatumHash

-- | <a>Redeemer</a> is a wrapper around <tt>Data</tt> values that are used
--   as redeemers in transaction inputs.
data Redeemer

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
data RedeemerHash

-- | Hash a 'PV1.Datum builtin data.
datumHash :: Datum -> DatumHash

-- | Hash a <a>Redeemer</a> builtin data.
redeemerHash :: Redeemer -> RedeemerHash

-- | Hash a <a>BuiltinData</a>
dataHash :: BuiltinData -> BuiltinByteString

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
data Validator

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
data ValidatorHash

-- | <a>MintingPolicy</a> is a wrapper around <a>Script</a>s which are used
--   as validators for minting constraints.
data MintingPolicy

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
data MintingPolicyHash

-- | <a>StakeValidator</a> is a wrapper around <a>Script</a>s which are
--   used as validators for withdrawals and stake address certificates.
data StakeValidator

-- | Script runtime representation of a <tt>Digest SHA256</tt>.
data StakeValidatorHash

-- | Hash a <a>Validator</a> script.
validatorHash :: Validator -> ValidatorHash

-- | Hash a <a>MintingPolicy</a> script.
mintingPolicyHash :: MintingPolicy -> MintingPolicyHash

-- | Hash a <a>StakeValidator</a> script.
stakeValidatorHash :: StakeValidator -> StakeValidatorHash

-- | Convert a <a>BuiltinsData</a> value to a 'cardano-api' script data
--   value.
--   
--   For why we depend on `cardano-api`, see note [Hash computation of
--   datums, redeemers and scripts] toCardanoAPIData ::
--   Builtins.BuiltinData -&gt; Script.ScriptData toCardanoAPIData =
--   Script.fromPlutusData . Builtins.builtinDataToData
--   
--   Hash a <tt>Script</tt>
scriptHash :: Script -> ScriptHash

-- | The <tt>CurrencySymbol</tt> of a <tt>MintingPolicy</tt>.
scriptCurrencySymbol :: MintingPolicy -> CurrencySymbol

-- | Convert a <tt>Script</tt> to a 'cardano-api' script.
--   
--   For why we depend on `cardano-api`, see note [Hash computation of
--   datums, redeemers and scripts]
toCardanoApiScript :: Script -> Script PlutusScriptV2

module Plutus.Script.Utils.V2.Generators
alwaysSucceedValidator :: Validator
alwaysSucceedValidatorHash :: ValidatorHash
alwaysSucceedPolicy :: MintingPolicy
someTokenValue :: TokenName -> Integer -> Value

module Plutus.Script.Utils.V2.Address

-- | The address that should be used by a transaction output locked by the
--   given Plutus V2 validator script.
mkValidatorAddress :: Validator -> Address

-- | Cardano address of a <a>Validator</a> script.
mkValidatorCardanoAddress :: NetworkId -> Validator -> AddressInEra BabbageEra

-- | Cardano address of a <a>MintingPolicy</a> script.
mkMintingPolicyCardanoAddress :: NetworkId -> MintingPolicy -> AddressInEra BabbageEra

-- | Cardano address of a <a>MintingPolicy</a> script.
mkStakeValidatorCardanoAddress :: NetworkId -> StakeValidator -> AddressInEra BabbageEra

module Plutus.Script.Utils.Typed
type UntypedValidator = BuiltinData -> BuiltinData -> BuiltinData -> ()
type UntypedMintingPolicy = BuiltinData -> BuiltinData -> ()
type UntypedStakeValidator = BuiltinData -> BuiltinData -> ()

-- | A class that associates a type standing for a connection type with two
--   types, the type of the redeemer and the data script for that
--   connection type.
class ValidatorTypes (a :: Type) where {
    
    -- | The type of the redeemers of this connection type.
    type family RedeemerType a :: Type;
    
    -- | The type of the data of this connection type.
    type family DatumType a :: Type;
    type RedeemerType a = ();
    type DatumType a = ();
}

-- | A typed validator script with its <tt>ValidatorScript</tt> and
--   <tt>Address</tt>.
data TypedValidator (a :: Type)
TypedValidator :: Versioned Validator -> ValidatorHash -> Versioned MintingPolicy -> MintingPolicyHash -> TypedValidator (a :: Type)
[tvValidator] :: TypedValidator (a :: Type) -> Versioned Validator
[tvValidatorHash] :: TypedValidator (a :: Type) -> ValidatorHash
[tvForwardingMPS] :: TypedValidator (a :: Type) -> Versioned MintingPolicy

-- | The hash of the minting policy that checks whether the validator is
--   run in this transaction
[tvForwardingMPSHash] :: TypedValidator (a :: Type) -> MintingPolicyHash

-- | The hash of the validator.
validatorHash :: TypedValidator a -> ValidatorHash

-- | The address of the validator.
validatorCardanoAddress :: NetworkId -> TypedValidator a -> AddressInEra BabbageEra
validatorCardanoAddressAny :: NetworkId -> TypedValidator a -> AddressAny

-- | The address of the validator.
validatorAddress :: TypedValidator a -> Address

-- | The unversioned validator script itself.
validatorScript :: TypedValidator a -> Validator

-- | The validator script itself.
vValidatorScript :: TypedValidator a -> Versioned Validator

-- | The unversioned minting policy that forwards all checks to the
--   instance's validator
forwardingMintingPolicy :: TypedValidator a -> MintingPolicy

-- | The minting policy that forwards all checks to the instance's
--   validator
vForwardingMintingPolicy :: TypedValidator a -> Versioned MintingPolicy

-- | Hash of the minting policy that forwards all checks to the instance's
--   validator
forwardingMintingPolicyHash :: TypedValidator a -> MintingPolicyHash

-- | Generalise the typed validator to one that works with the
--   <tt>Data</tt> type.
generalise :: forall a. TypedValidator a -> TypedValidator Any
data Any

-- | Non-Native Script language. This is an Enumerated type. This is
--   expected to be an open type. We will add new Constuctors to this type
--   as additional Non-Native scripting language as are added. We use an
--   enumerated type for two reasons. 1) We can write total functions by
--   case analysis over the constructors 2) We will use DataKinds to make
--   some datatypes indexed by Language For now, the only Non-Native
--   Scriting language is Plutus We might add new languages in the futures.
--   
--   Note that the the serialization of <a>Language</a> depends on the
--   ordering.
data Language
PlutusV1 :: Language
PlutusV2 :: Language

-- | A script of some kind with its Plutus language version
data Versioned script
Versioned :: script -> Language -> Versioned script
[unversioned] :: Versioned script -> script
[version] :: Versioned script -> Language
class UnsafeFromData sc => IsScriptContext sc

-- | Converts a custom datum and redeemer from a validator function to an
--   untyped validator function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V2.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V2.Scripts (mkUntypedValidator)
--   
--   newtype MyCustomDatum = MyCustomDatum Integer
--   PlutusTx.unstableMakeIsData ''MyCustomDatum
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkValidator :: MyCustomDatum -&gt; MyCustomRedeemer -&gt; Plutus.ScriptContext -&gt; Bool
--   mkValidator _ _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkValidatorScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedValidator mkValidator
--   </pre>
--   
--   Here's an example using a parameterized validator:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V2.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V2.Scripts (mkUntypedValidator)
--   
--   newtype MyCustomDatum = MyCustomDatum Integer
--   PlutusTx.unstableMakeIsData ''MyCustomDatum
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkValidator :: Int -&gt; MyCustomDatum -&gt; MyCustomRedeemer -&gt; Plutus.ScriptContext -&gt; Bool
--   mkValidator _ _ _ _ = True
--   
--   validator :: Int -&gt; Plutus.Validator
--   validator i = Plutus.mkValidatorScript
--       $$(PlutusTx.compile [|| wrap . mkValidator ||]) <a>applyCode</a> PlutusTx.liftCode i
--    where
--       wrap = mkUntypedValidator
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (data, redeemer and then script context). A log trace is
--   generated after each successfully decoded parameter. Thus, if a
--   parameter can't be decoded, the culprit is the first parameter in the
--   list that doesn't appear as successfully decoded in the log trace.
mkUntypedValidator :: (IsScriptContext sc, UnsafeFromData d, UnsafeFromData r) => (d -> r -> sc -> Bool) -> UntypedValidator

-- | Converts a custom redeemer from a stake validator function to an
--   untyped stake validator function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V1.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V1.Scripts (mkUntypedStakeValidator)
--   
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkStakeValidator :: MyCustomRedeemer -&gt; ScriptContext -&gt; Bool
--   mkStakeValidator _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkStakeValidatorScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedStakeValidator mkStakeValidator
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (redeemer and then script context). A log trace is generated
--   after each successfully decoded parameter. Thus, if a parameter can't
--   be decoded, the culprit is the first parameter in the list that
--   doesn't appear as successfully decoded in the log trace.
mkUntypedStakeValidator :: (IsScriptContext sc, UnsafeFromData r) => (r -> sc -> Bool) -> UntypedStakeValidator

-- | Converts a custom redeemer from a minting policy function to an
--   untyped minting policy function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V1.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V1.Scripts (mkUntypedMintingPolicy)
--   
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkMintingPolicy :: MyCustomRedeemer -&gt; ScriptContext -&gt; Bool
--   mkMintingPolicy _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkMintingPolicyScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedMintingPolicy mkMintingPolicy
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (redeemer and then script context). A log trace is generated
--   after each successfully decoded parameter. Thus, if a parameter can't
--   be decoded, the culprit is the first parameter in the list that
--   doesn't appear as successfully decoded in the log trace.
mkUntypedMintingPolicy :: (IsScriptContext sc, UnsafeFromData r) => (r -> sc -> Bool) -> UntypedMintingPolicy
type ScriptContextV1 = ScriptContext
type ScriptContextV2 = ScriptContext
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Script.Utils.Typed.Any
instance GHC.Generics.Generic Plutus.Script.Utils.Typed.Any
instance GHC.Show.Show Plutus.Script.Utils.Typed.Any
instance GHC.Classes.Eq Plutus.Script.Utils.Typed.Any
instance GHC.Generics.Generic (Plutus.Script.Utils.Typed.TypedValidator a)
instance GHC.Classes.Eq (Plutus.Script.Utils.Typed.TypedValidator a)
instance GHC.Show.Show (Plutus.Script.Utils.Typed.TypedValidator a)
instance Plutus.Script.Utils.Typed.IsScriptContext Plutus.V1.Ledger.Contexts.ScriptContext
instance Plutus.Script.Utils.Typed.IsScriptContext Plutus.V2.Ledger.Contexts.ScriptContext
instance Plutus.Script.Utils.Typed.ValidatorTypes Data.Void.Void
instance Plutus.Script.Utils.Typed.ValidatorTypes Plutus.Script.Utils.Typed.Any

module Plutus.Script.Utils.V1.Typed.Scripts.StakeValidators

-- | A stake validator that checks whether the validator script was run in
--   the right transaction.
mkForwardingStakeValidator :: ValidatorHash -> StakeValidator
forwardToValidator :: ValidatorHash -> () -> ScriptContext -> Bool

module Plutus.Script.Utils.V1.Typed.Scripts.MonetaryPolicies

-- | A minting policy that checks whether the validator script was run in
--   the minting transaction.
mkForwardingMintingPolicy :: ValidatorHash -> MintingPolicy
forwardToValidator :: ValidatorHash -> () -> ScriptContext -> Bool

module Plutus.Script.Utils.V1.Typed.Scripts.Validators
type UntypedValidator = BuiltinData -> BuiltinData -> BuiltinData -> ()

-- | Converts a custom datum and redeemer from a validator function to an
--   untyped validator function. See Note [Scripts returning Bool].
--   
--   Here's an example of how this function can be used:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V2.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V2.Scripts (mkUntypedValidator)
--   
--   newtype MyCustomDatum = MyCustomDatum Integer
--   PlutusTx.unstableMakeIsData ''MyCustomDatum
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkValidator :: MyCustomDatum -&gt; MyCustomRedeemer -&gt; Plutus.ScriptContext -&gt; Bool
--   mkValidator _ _ _ = True
--   
--   validator :: Plutus.Validator
--   validator = Plutus.mkValidatorScript
--       $$(PlutusTx.compile [|| wrap ||])
--    where
--       wrap = mkUntypedValidator mkValidator
--   </pre>
--   
--   Here's an example using a parameterized validator:
--   
--   <pre>
--   import PlutusTx qualified
--   import Plutus.V2.Ledger.Scripts qualified as Plutus
--   import Plutus.Script.Utils.V2.Scripts (mkUntypedValidator)
--   
--   newtype MyCustomDatum = MyCustomDatum Integer
--   PlutusTx.unstableMakeIsData ''MyCustomDatum
--   newtype MyCustomRedeemer = MyCustomRedeemer Integer
--   PlutusTx.unstableMakeIsData ''MyCustomRedeemer
--   
--   mkValidator :: Int -&gt; MyCustomDatum -&gt; MyCustomRedeemer -&gt; Plutus.ScriptContext -&gt; Bool
--   mkValidator _ _ _ _ = True
--   
--   validator :: Int -&gt; Plutus.Validator
--   validator i = Plutus.mkValidatorScript
--       $$(PlutusTx.compile [|| wrap . mkValidator ||]) <a>applyCode</a> PlutusTx.liftCode i
--    where
--       wrap = mkUntypedValidator
--   </pre>
--   
--   For debugging purpose, it may be of interest to know that in the
--   default implementation, the parameters are decoded in the order they
--   appear (data, redeemer and then script context). A log trace is
--   generated after each successfully decoded parameter. Thus, if a
--   parameter can't be decoded, the culprit is the first parameter in the
--   list that doesn't appear as successfully decoded in the log trace.
mkUntypedValidator :: (IsScriptContext sc, UnsafeFromData d, UnsafeFromData r) => (d -> r -> sc -> Bool) -> UntypedValidator

-- | A class that associates a type standing for a connection type with two
--   types, the type of the redeemer and the data script for that
--   connection type.
class ValidatorTypes (a :: Type) where {
    
    -- | The type of the redeemers of this connection type.
    type family RedeemerType a :: Type;
    
    -- | The type of the data of this connection type.
    type family DatumType a :: Type;
    type RedeemerType a = ();
    type DatumType a = ();
}

-- | The type of validators for the given connection type.
type ValidatorType (a :: Type) = DatumType a -> RedeemerType a -> ScriptContext -> Bool

-- | A typed validator script with its <tt>ValidatorScript</tt> and
--   <tt>Address</tt>.
data TypedValidator (a :: Type)

-- | Make a <a>TypedValidator</a> from the <a>CompiledCode</a> of a
--   validator script and its wrapper.
mkTypedValidator :: CompiledCode (ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> TypedValidator a

-- | Make a <a>TypedValidator</a> from the <a>CompiledCode</a> of a
--   parameterized validator script and its wrapper.
mkTypedValidatorParam :: forall a param. Lift DefaultUni param => CompiledCode (param -> ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> param -> TypedValidator a

-- | The hash of the validator.
validatorHash :: TypedValidator a -> ValidatorHash

-- | The address of the validator.
validatorAddress :: TypedValidator a -> Address

-- | The unversioned validator script itself.
validatorScript :: TypedValidator a -> Validator

-- | The validator script itself.
vValidatorScript :: TypedValidator a -> Versioned Validator

-- | The unversioned minting policy that forwards all checks to the
--   instance's validator
forwardingMintingPolicy :: TypedValidator a -> MintingPolicy

-- | The minting policy that forwards all checks to the instance's
--   validator
vForwardingMintingPolicy :: TypedValidator a -> Versioned MintingPolicy

-- | Hash of the minting policy that forwards all checks to the instance's
--   validator
forwardingMintingPolicyHash :: TypedValidator a -> MintingPolicyHash

-- | Generalise the typed validator to one that works with the
--   <tt>Data</tt> type.
generalise :: forall a. TypedValidator a -> TypedValidator Any
data WrongOutTypeError
ExpectedScriptGotPubkey :: WrongOutTypeError
ExpectedPubkeyGotScript :: WrongOutTypeError

-- | An error we can get while trying to type an existing transaction part.
data ConnectionError
WrongValidatorAddress :: Address -> Address -> ConnectionError
WrongOutType :: WrongOutTypeError -> ConnectionError
WrongValidatorType :: String -> ConnectionError
WrongRedeemerType :: BuiltinData -> ConnectionError
WrongDatumType :: BuiltinData -> ConnectionError
NoDatum :: TxOutRef -> DatumHash -> ConnectionError
UnknownRef :: TxOutRef -> ConnectionError

-- | Checks that the given validator hash is consistent with the actual
--   validator.
checkValidatorAddress :: forall a m. MonadError ConnectionError m => TypedValidator a -> Address -> m ()

-- | Checks that the given datum has the right type.
checkDatum :: forall a m. (FromData (DatumType a), MonadError ConnectionError m) => TypedValidator a -> Datum -> m (DatumType a)

-- | Checks that the given redeemer script has the right type.
checkRedeemer :: forall inn m. (FromData (RedeemerType inn), MonadError ConnectionError m) => TypedValidator inn -> Redeemer -> m (RedeemerType inn)
instance Data.Aeson.Types.FromJSON.FromJSON Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance Data.Aeson.Types.ToJSON.ToJSON Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance GHC.Generics.Generic Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance GHC.Classes.Ord Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance GHC.Classes.Eq Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance GHC.Show.Show Plutus.Script.Utils.V1.Typed.Scripts.Validators.WrongOutTypeError
instance GHC.Generics.Generic Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance GHC.Classes.Ord Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance GHC.Classes.Eq Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance GHC.Show.Show Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError
instance Prettyprinter.Internal.Pretty Plutus.Script.Utils.V1.Typed.Scripts.Validators.ConnectionError

module Plutus.Script.Utils.V1.Typed.Scripts

-- | A minting policy that checks whether the validator script was run in
--   the minting transaction.
mkForwardingMintingPolicy :: ValidatorHash -> MintingPolicy

-- | A stake validator that checks whether the validator script was run in
--   the right transaction.
mkForwardingStakeValidator :: ValidatorHash -> StakeValidator

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
data Validator

-- | <a>MintingPolicy</a> is a wrapper around <a>Script</a>s which are used
--   as validators for minting constraints.
data MintingPolicy

-- | <a>StakeValidator</a> is a wrapper around <a>Script</a>s which are
--   used as validators for withdrawals and stake address certificates.
data StakeValidator

-- | A <a>TxOut</a> tagged by a phantom type: and the connection type of
--   the output.
data TypedScriptTxOut a

-- | A <a>TxOutRef</a> tagged by a phantom type: and the connection type of
--   the output.
data TypedScriptTxOutRef a

-- | Create a <a>TypedScriptTxOut</a> from a correctly-typed data script,
--   an address, and a value.
makeTypedScriptTxOut :: forall out. (ToData (DatumType out), FromData (DatumType out)) => TypedValidator out -> DatumType out -> Value -> TypedScriptTxOut out

-- | Create a <a>TypedScriptTxOut</a> from an existing <a>TxOut</a> by
--   checking the types of its parts.
typeScriptTxOut :: forall out m. (FromData (DatumType out), ToData (DatumType out), MonadError ConnectionError m) => TypedValidator out -> TxOutRef -> TxOut -> Datum -> m (TypedScriptTxOut out)

-- | Create a <a>TypedScriptTxOut</a> from an existing <a>TxOut</a> by
--   checking the types of its parts.
typeScriptTxOutRef :: forall out m. (FromData (DatumType out), ToData (DatumType out), MonadError ConnectionError m) => TypedValidator out -> TxOutRef -> TxOut -> Datum -> m (TypedScriptTxOutRef out)
instance GHC.Classes.Eq (Plutus.Script.Utils.Typed.DatumType a) => GHC.Classes.Eq (Plutus.Script.Utils.V1.Typed.Scripts.TypedScriptTxOutRef a)
instance GHC.Classes.Eq (Plutus.Script.Utils.Typed.DatumType a) => GHC.Classes.Eq (Plutus.Script.Utils.V1.Typed.Scripts.TypedScriptTxOut a)

module Plutus.Script.Utils.V2.Tx

-- | Create a transaction output locked by a validator script and attach
--   the given data script.
scriptTxOut :: Validator -> Value -> OutputDatum -> HasReferenceScript -> TxOut

module Plutus.Script.Utils.V2.Typed.Scripts.MonetaryPolicies

-- | A minting policy that checks whether the validator script was run in
--   the minting transaction.
mkForwardingMintingPolicy :: ValidatorHash -> MintingPolicy
forwardToValidator :: ValidatorHash -> () -> ScriptContext -> Bool

module Plutus.Script.Utils.V2.Typed.Scripts.StakeValidators

-- | A stake validator that checks whether the validator script was run in
--   the right transaction.
mkForwardingStakeValidator :: ValidatorHash -> StakeValidator
forwardToValidator :: ValidatorHash -> () -> ScriptContext -> Bool

module Plutus.Script.Utils.V2.Typed.Scripts.Validators
type UntypedValidator = BuiltinData -> BuiltinData -> BuiltinData -> ()

-- | A class that associates a type standing for a connection type with two
--   types, the type of the redeemer and the data script for that
--   connection type.
class ValidatorTypes (a :: Type) where {
    
    -- | The type of the redeemers of this connection type.
    type family RedeemerType a :: Type;
    
    -- | The type of the data of this connection type.
    type family DatumType a :: Type;
    type RedeemerType a = ();
    type DatumType a = ();
}

-- | The type of validators for the given connection type.
type ValidatorType (a :: Type) = DatumType a -> RedeemerType a -> ScriptContext -> Bool

-- | A typed validator script with its <tt>ValidatorScript</tt> and
--   <tt>Address</tt>.
data TypedValidator (a :: Type)

-- | Make a <a>TypedValidator</a> from the <a>CompiledCode</a> of a
--   validator script and its wrapper.
mkTypedValidator :: CompiledCode (ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> TypedValidator a

-- | Make a <a>TypedValidator</a> from the <a>CompiledCode</a> of a
--   parameterized validator script and its wrapper.
mkTypedValidatorParam :: forall a param. Lift DefaultUni param => CompiledCode (param -> ValidatorType a) -> CompiledCode (ValidatorType a -> UntypedValidator) -> param -> TypedValidator a

-- | The hash of the validator.
validatorHash :: TypedValidator a -> ValidatorHash

-- | The address of the validator.
validatorAddress :: TypedValidator a -> Address

-- | The unversioned validator script itself.
validatorScript :: TypedValidator a -> Validator

-- | The validator script itself.
vValidatorScript :: TypedValidator a -> Versioned Validator

-- | The unversioned minting policy that forwards all checks to the
--   instance's validator
forwardingMintingPolicy :: TypedValidator a -> MintingPolicy

-- | The minting policy that forwards all checks to the instance's
--   validator
vForwardingMintingPolicy :: TypedValidator a -> Versioned MintingPolicy

-- | Hash of the minting policy that forwards all checks to the instance's
--   validator
forwardingMintingPolicyHash :: TypedValidator a -> MintingPolicyHash

-- | Generalise the typed validator to one that works with the
--   <tt>Data</tt> type.
generalise :: forall a. TypedValidator a -> TypedValidator Any

module Plutus.Script.Utils.V2.Typed.Scripts

-- | A minting policy that checks whether the validator script was run in
--   the minting transaction.
mkForwardingMintingPolicy :: ValidatorHash -> MintingPolicy

-- | A stake validator that checks whether the validator script was run in
--   the right transaction.
mkForwardingStakeValidator :: ValidatorHash -> StakeValidator

-- | <a>Validator</a> is a wrapper around <a>Script</a>s which are used as
--   validators in transaction outputs.
data Validator

-- | <a>MintingPolicy</a> is a wrapper around <a>Script</a>s which are used
--   as validators for minting constraints.
data MintingPolicy

-- | <a>StakeValidator</a> is a wrapper around <a>Script</a>s which are
--   used as validators for withdrawals and stake address certificates.
data StakeValidator

-- | A <a>TxOut</a> tagged by a phantom type: and the connection type of
--   the output.
data TypedScriptTxOut a
TypedScriptTxOut :: TxOut -> DatumType a -> TypedScriptTxOut a
[tyTxOutTxOut] :: TypedScriptTxOut a -> TxOut
[tyTxOutData] :: TypedScriptTxOut a -> DatumType a

-- | A <a>TxOutRef</a> tagged by a phantom type: and the connection type of
--   the output.
data TypedScriptTxOutRef a
TypedScriptTxOutRef :: TxOutRef -> TypedScriptTxOut a -> TypedScriptTxOutRef a
[tyTxOutRefRef] :: TypedScriptTxOutRef a -> TxOutRef
[tyTxOutRefOut] :: TypedScriptTxOutRef a -> TypedScriptTxOut a

-- | Create a <a>TypedScriptTxOut</a> from an existing <a>TxOut</a> by
--   checking the types of its parts.
typeScriptTxOut :: forall out m. (FromData (DatumType out), ToData (DatumType out), MonadError ConnectionError m) => TypedValidator out -> TxOutRef -> TxOut -> Datum -> m (TypedScriptTxOut out)

-- | Create a <a>TypedScriptTxOut</a> from an existing <a>TxOut</a> by
--   checking the types of its parts.
typeScriptTxOutRef :: forall out m. (FromData (DatumType out), ToData (DatumType out), MonadError ConnectionError m) => TypedValidator out -> TxOutRef -> TxOut -> Datum -> m (TypedScriptTxOutRef out)

-- | An error we can get while trying to type an existing transaction part.
data ConnectionError
WrongValidatorAddress :: Address -> Address -> ConnectionError
WrongOutType :: WrongOutTypeError -> ConnectionError
WrongValidatorType :: String -> ConnectionError
WrongRedeemerType :: BuiltinData -> ConnectionError
WrongDatumType :: BuiltinData -> ConnectionError
NoDatum :: TxOutRef -> DatumHash -> ConnectionError
UnknownRef :: TxOutRef -> ConnectionError
instance GHC.Classes.Eq (Plutus.Script.Utils.Typed.DatumType a) => GHC.Classes.Eq (Plutus.Script.Utils.V2.Typed.Scripts.TypedScriptTxOutRef a)
instance GHC.Classes.Eq (Plutus.Script.Utils.Typed.DatumType a) => GHC.Classes.Eq (Plutus.Script.Utils.V2.Typed.Scripts.TypedScriptTxOut a)

module Plutus.Script.Utils.Value

-- | Split a value into its positive and negative parts. The first element
--   of the tuple contains the negative parts of the value, the second
--   element contains the positive parts.
--   
--   <pre>
--   negate (fst (split a)) <tt>plus</tt> (snd (split a)) == a
--   </pre>
split :: Value -> (Value, Value)

-- | Check whether one <a>Value</a> is strictly less than another. This is
--   *not* a pointwise operation. <tt>lt l r</tt> means <tt>leq l r
--   &amp;&amp; not (eq l r)</tt>.
lt :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is strictly greater than another. This
--   is *not* a pointwise operation. <tt>gt l r</tt> means <tt>geq l r
--   &amp;&amp; not (eq l r)</tt>.
gt :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is less than or equal to another. See
--   <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
leq :: Value -> Value -> Bool

-- | Check whether one <a>Value</a> is greater than or equal to another.
--   See <a>Value</a> for an explanation of how operations on <a>Value</a>s
--   work.
geq :: Value -> Value -> Bool

-- | Check whether a <a>Value</a> is zero.
isZero :: Value -> Bool

-- | Convert a value to a simple list, keeping only the non-zero amounts.
flattenValue :: Value -> [(CurrencySymbol, TokenName, Integer)]
unionWith :: (Integer -> Integer -> Integer) -> Value -> Value -> Value

-- | Get the quantity of the given <a>AssetClass</a> class in the
--   <a>Value</a>.
assetClassValueOf :: Value -> AssetClass -> Integer

-- | A <a>Value</a> containing the given amount of the asset class.
assetClassValue :: AssetClass -> Integer -> Value

-- | Make a <a>Value</a> containing only the given quantity of the given
--   currency.
singleton :: CurrencySymbol -> TokenName -> Integer -> Value

-- | The list of <a>CurrencySymbol</a>s of a <a>Value</a>.
symbols :: Value -> [CurrencySymbol]

-- | Get the quantity of the given currency in the <a>Value</a>.
valueOf :: Value -> CurrencySymbol -> TokenName -> Integer
assetClass :: CurrencySymbol -> TokenName -> AssetClass

-- | The <a>TokenName</a> of the <tt>Ada</tt> currency.
adaToken :: TokenName

-- | The <a>CurrencySymbol</a> of the <tt>Ada</tt> currency.
adaSymbol :: CurrencySymbol
toString :: TokenName -> String

-- | Creates <a>TokenName</a> from raw <tt>ByteString</tt>.
tokenName :: ByteString -> TokenName

-- | Creates <a>CurrencySymbol</a> from raw <tt>ByteString</tt>.
currencySymbol :: ByteString -> CurrencySymbol

-- | The minting policy hash of a currency symbol
currencyMPSHash :: CurrencySymbol -> MintingPolicyHash

-- | The currency symbol of a monetay policy hash
mpsSymbol :: MintingPolicyHash -> CurrencySymbol
newtype CurrencySymbol
CurrencySymbol :: BuiltinByteString -> CurrencySymbol
[unCurrencySymbol] :: CurrencySymbol -> BuiltinByteString

-- | ByteString of a name of a token, shown as UTF-8 string when possible
newtype TokenName
TokenName :: BuiltinByteString -> TokenName
[unTokenName] :: TokenName -> BuiltinByteString

-- | An asset class, identified by currency symbol and token name.
newtype AssetClass
AssetClass :: (CurrencySymbol, TokenName) -> AssetClass
[unAssetClass] :: AssetClass -> (CurrencySymbol, TokenName)

-- | A cryptocurrency value. This is a map from <a>CurrencySymbol</a>s to a
--   quantity of that currency.
--   
--   Operations on currencies are usually implemented <i>pointwise</i>.
--   That is, we apply the operation to the quantities for each currency in
--   turn. So when we add two <a>Value</a>s the resulting <a>Value</a> has,
--   for each currency, the sum of the quantities of <i>that particular</i>
--   currency in the argument <a>Value</a>. The effect of this is that the
--   currencies in the <a>Value</a> are "independent", and are operated on
--   separately.
--   
--   Whenever we need to get the quantity of a currency in a <a>Value</a>
--   where there is no explicit quantity of that currency in the
--   <a>Value</a>, then the quantity is taken to be zero.
--   
--   See note [Currencies] for more details.
newtype Value
Value :: Map CurrencySymbol (Map TokenName Integer) -> Value
[getValue] :: Value -> Map CurrencySymbol (Map TokenName Integer)
scale :: Module s v => s -> v -> v

-- | Value without any Ada.
noAdaValue :: Value -> Value

-- | Value without any non-Ada.
adaOnlyValue :: Value -> Value
isAdaOnlyValue :: Value -> Bool

-- | Get the quantities of just the given <a>CurrencySymbol</a> in the
--   <a>Value</a>. This is useful when implementing minting policies as
--   they are responsible for checking all minted/burnt tokens of their own
--   <a>CurrencySymbol</a>.
currencyValueOf :: Value -> CurrencySymbol -> Value
