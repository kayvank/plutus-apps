-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Shared utilities for writing unit and property tests.
--   
--   Shared utilities for writing unit and property tests.
@package cardano-wallet-test-utils
@version 2022.7.1


module Test.Utils.Env

-- | Runs an IO action with exactly the given environment variables. After
--   the action finishes, the original environment variables are restored.
--   
--   NOTE: The process environment is a global variable -- this function is
--   not threadsafe.
withEnv :: MonadUnliftIO m => [(String, String)] -> m a -> m a

-- | Runs an IO action with the given environment variables set, in
--   addition to the current environment variables. After the action
--   finishes, the environment variables are restored back to the original
--   state.
--   
--   NOTE: The process environment is a global variable -- this function is
--   not threadsafe.
withAddedEnv :: MonadUnliftIO m => [(String, String)] -> m a -> m a

-- | Unsets all environment variables for this process.
clearEnv :: MonadIO m => m ()


-- | Provides testing functions to check that type class instances obey
--   laws.
module Test.Utils.Laws

-- | Constructs a test to check that the given type class instance obeys
--   the given set of laws.
--   
--   Example usage:
--   
--   <pre>
--   &gt;&gt;&gt; testLaws @Natural ordLaws
--   
--   &gt;&gt;&gt; testLaws @(Map Int) functorLaws
--   </pre>
testLaws :: forall a. Typeable a => (Proxy a -> Laws) -> Spec

-- | Calls <a>testLaws</a> with multiple sets of laws.
--   
--   Example usage:
--   
--   <pre>
--   &gt;&gt;&gt; testLawsMany @Natural [eqLaws, ordLaws]
--   
--   &gt;&gt;&gt; testLawsMany @(Map Int) [foldableLaws, functorLaws]
--   </pre>
testLawsMany :: forall a. Typeable a => [Proxy a -> Laws] -> Spec


-- | Provides laws for the <a>PartialOrd</a> class.
module Test.Utils.Laws.PartialOrd
partialOrdLaws :: (PartialOrd a, Arbitrary a, Show a) => Proxy a -> Laws


-- | Utility function for finding the package test data directory.
module Test.Utils.Paths

-- | A TH function to get the test data directory.
--   
--   It combines the current source file location and cabal file to locate
--   the package directory in such a way that works in both the stack/cabal
--   package build and ghci.
--   
--   For the Nix build, rather than baking in a path that starts with
--   <tt>/build</tt>, it makes the test data path relative to the current
--   directory.
getTestData :: Q Exp

-- | A variant of <a>getTestData</a> which lets you specify the test data
--   <a>FilePath</a> relative to the package root directory.
getTestDataPath :: FilePath -> Q Exp

-- | Infer from environment variables whether we are running within a Nix
--   build (and not just a nix-shell).
inNixBuild :: IO Bool


-- | Utility function for making test suites pass on difficult platforms.
module Test.Utils.Platform
skipOnWindows :: HasCallStack => String -> Expectation
pendingOnWindows :: HasCallStack => String -> Expectation
pendingOnWine :: HasCallStack => String -> Expectation

-- | Mark test pending if running on macOS
pendingOnMacOS :: HasCallStack => String -> Expectation
whenWindows :: IO () -> IO ()
isWindows :: Bool
isMacOS :: Bool

-- | Use the presence of <tt>winepath.exe</tt> to detect when running tests
--   under Wine.
getIsWine :: IO Bool
nullFileName :: FilePath


-- | File path related test utilities.
module Test.Utils.FilePath

-- | A file or directory name. The <a>Arbitrary</a> instance will generate
--   values which are valid on Windows and POSIX.
--   
--   
--   <a>https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file</a>
newtype PathElement
PathElement :: FilePath -> PathElement
instance GHC.Classes.Eq Test.Utils.FilePath.PathElement
instance GHC.Show.Show Test.Utils.FilePath.PathElement
instance Test.QuickCheck.Arbitrary.Arbitrary Test.Utils.FilePath.PathElement


-- | Small module for writing text-based golden tests.
--   
--   In contrast to `hspec-golden-aeson` this module works with manually
--   provided values instead of QuickCheck, and with text instead of JSON.
--   
--   If the tests are run with the OVERWRITE_GOLDENS environment variable
--   set, they will all fail, and write the current values to disk.
--   
--   If some goldens are os-dependent (like some optparse-applicative help
--   text using getProgName), you can create a windows specific variant by
--   appending ".win" to the golden file name.
--   
--   This seems to work for now with just two windows specific goldens, but
--   if there are more, it might be more convenient if windows goldens
--   always are separate, as OVERWRITE_GOLDENS will never currently write
--   the .win version.
module Test.Hspec.Goldens
data Settings
Settings :: FilePath -> (Text -> Text) -> Settings
[goldenDirectory] :: Settings -> FilePath
[postProcess] :: Settings -> Text -> Text
textGolden :: Settings -> String -> Text -> Expectation
instance GHC.Classes.Eq Test.Hspec.Goldens.GoldenText
instance GHC.Show.Show Test.Hspec.Goldens.GoldenText


-- | A convenience wrapper type for pretty-showing test values.
module Test.Utils.Pretty
newtype Pretty a
Pretty :: a -> Pretty a
[unPretty] :: Pretty a -> a

-- | Like <a>===</a>, but prettier.
(====) :: (Eq a, Show a) => a -> a -> Property
infix 4 ====

-- | Pretty-show a value as a lazy text <a>Builder</a>. This is handy for
--   using with the <a>Fmt</a> module.
pShowBuilder :: Show a => a -> Builder
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.Utils.Pretty.Pretty a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Test.Utils.Pretty.Pretty a)
instance GHC.Show.Show a => GHC.Show.Show (Test.Utils.Pretty.Pretty a)
instance GHC.Show.Show a => Formatting.Buildable.Buildable (Test.Utils.Pretty.Pretty a)
instance GHC.Show.Show a => Data.Text.Class.ToText (Test.Utils.Pretty.Pretty a)


-- | Extra helper functions for QuickCheck
module Test.QuickCheck.Extra

-- | Generates a function.
--   
--   This is based on the implementation of <a>Arbitrary</a> for 'a -&gt;
--   b'.
genFunction :: (a -> Gen b -> Gen b) -> Gen b -> Gen (a -> b)

-- | Generates a <a>Map</a> with the given key and value generation
--   functions.
genMapWith :: Ord k => Gen k -> Gen v -> Gen (Map k v)

-- | Generates a 2-tuple whose range depends linearly on the size
--   parameter.
genSized2 :: Gen a -> Gen b -> Gen (a, b)

-- | Similar to <a>genSized2</a>, but with a custom constructor.
genSized2With :: (a -> b -> c) -> Gen a -> Gen b -> Gen c

-- | Resize a generator to grow with the size parameter, but remains
--   reasonably sized. That is handy when testing on data-structures that
--   can be arbitrarily large and, when large entities don't really bring
--   any value to the test itself.
--   
--   It uses a square root function which makes the size parameter grows
--   quadratically slower than normal. That is,
--   
--   TODO: table
reasonablySized :: Gen a -> Gen a

-- | Lift a shrinking function into a type more convenient for use with
--   Generics.SOP.
--   
--   <b>Examples:</b>
--   
--   <pre>
--   shrinkBool :: Bool -&gt; [Bool]
--   shrinkChar :: Char -&gt; [Char]
--   
--   data BoolChar = BoolChar Bool Char
--   
--   instance Generic BoolChar
--   
--   shrinkBoolChar :: BoolChar -&gt; [BoolChar]
--   shrinkBoolChar =
--       groundRobinShrink (  liftShrinker shrinkBool
--                         :* liftShrinker shrinkChar
--                         :* Nil
--                         )
--   </pre>
liftShrinker :: (a -> [a]) -> (I -.-> []) a

-- | Shrink the given pair in interleaved fashion.
--   
--   Successive shrinks of the left and right hand sides are interleaved in
--   the resulting sequence, to avoid biasing either side.
shrinkInterleaved :: (a, a -> [a]) -> (b, b -> [b]) -> [(a, b)]

-- | Shrinks a <a>Map</a> with the given key and value shrinking functions.
shrinkMapWith :: Ord k => (k -> [k]) -> (v -> [v]) -> Map k v -> [Map k v]

-- | Given a list of shrinkers for each element of a product type (NOTE:
--   this function is not defined for sum types), and a value of that
--   product type, shrink the value using a round-robin algorithm.
--   
--   <b>Examples:</b>
--   
--   <pre>
--   shrinkBoolChar :: BoolChar -&gt; [BoolChar]
--   shrinkBoolChar =
--       groundRobinShrink (  liftShrinker shrinkBool
--                         :* liftShrinker shrinkChar
--                         :* Nil
--                         )
--   </pre>
groundRobinShrink :: (Generic a, Code a ~ '[xs]) => NP (I -.-> []) xs -> a -> [a]

-- | Same as groundRobinShrink, but use the available shrinkers via
--   Arbitrary instance.
--   
--   <b>Examples:</b>
--   
--   <pre>
--   shrinkBoolChar :: BoolChar -&gt; [BoolChar]
--   shrinkBoolChar = groundRobinShrink'
--   </pre>
groundRobinShrink' :: (Generic a, Code a ~ '[xs], All Arbitrary xs) => a -> [a]

-- | This function exists to provide a GHC.Generics version of
--   <tt>groundRobinShrink</tt>, so that users of this code don't have to
--   derive an instance of Generics.SOP.Generic; an instance of
--   GHC.Generics.Generic will do.
genericRoundRobinShrink :: (Generic a, GFrom a, GTo a, GCode a ~ '[xs]) => NP (I -.-> []) xs -> a -> [a]

-- | Same as <tt>genericRoundRobinShrink</tt> but uses available Arbitrary
--   instance for shrinking.
genericRoundRobinShrink' :: (Generic a, GFrom a, GTo a, GCode a ~ '[xs], All Arbitrary xs) => a -> [a]
(<@>) :: (a -> b) -> a -> b
infixl 6 <@>
(<:>) :: (x -> [x]) -> NP (I -.-> []) xs -> NP (I -.-> []) (x : xs)
infixr 7 <:>

-- | Generates a random sequence of progressively shrunken values from a
--   given starting value and shrinking function.
--   
--   Each successive element in the sequence is selected at random from the
--   result of applying the shrinking function to the preceding element.
--   
--   The given starting value is not included in the sequence, by default.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; generate (genShrinkSequence shrink (100 :: Int))
--   [94,83,82,72,70,66,33,32,16,0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate (genShrinkSequence shrink "Cardano")
--   ["Caraano","aaraano","aaraaao","aaro","aarb","aaab","aab","aa",""]
--   </pre>
--   
--   The resulting sequence will be empty if (and only if) applying the
--   shrinking function to the starting value yields the empty list:
--   
--   <pre>
--   &gt;&gt;&gt; generate (genShrinkSequence (const []) "Cardano")
--   []
--   </pre>
--   
--   If the resulting sequence is non-empty, then applying the shrinking
--   function to the terminal element will yield the empty list:
--   
--   <pre>
--   &gt;&gt;&gt; shrink . last &lt;$&gt; generate (genShrinkSequence shrink (100 :: Int))
--   []
--   </pre>
genShrinkSequence :: forall a. (a -> [a]) -> a -> Gen [a]

-- | Computes the shrink space of a given shrinking function for a given
--   starting value.
--   
--   This function returns the set of all values that are transitively
--   reachable through repeated applications of the given shrinking
--   function to the given starting value.
--   
--   By default, the given starting value is not included in the result.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; shrinkSpace shrink "abc"
--   ["","a","aa","aaa","aab","aac","ab","aba","abb","ac","b","ba","bb","bc","c"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; shrinkSpace shrink (8 :: Int)
--   [0,1,2,3,4,5,6,7]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; shrinkSpace shrink (2 :: Int, 2 :: Int)
--   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1)]
--   </pre>
--   
--   Caution:
--   
--   Depending on the particular choice of shrinking function and starting
--   value, the shrink space can grow very quickly. Therefore, this
--   function should be used with caution to avoid non-termination within
--   test cases. If in doubt, use the <tt>within</tt> modifier provided by
--   QuickCheck to ensure that your test case terminates within a fixed
--   time limit.
--   
--   This function can be used to test that a given shrinking function
--   always generates values that satisfy a given condition. For example:
--   
--   <pre>
--   prop_shrinkApple_valid :: Apple -&gt; Property
--   prop_shrinkApple_valid apple =
--       within twoSeconds $
--       all isValidApple (shrinkSpace shrinkApple apple)
--     where
--       twoSeconds = 2_000_000
--   </pre>
shrinkSpace :: forall a. Ord a => (a -> [a]) -> a -> Set a

-- | Repeatedly applies a shrinking function to a value while a condition
--   holds.
--   
--   This function can be used to predict the final value that QuickCheck
--   will produce when searching for a minimal counterexample.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; isCounterexample a = (a &gt; 0) &amp;&amp; (a `mod` 8 == 0)
--   
--   &gt;&gt;&gt; shrinkWhile isCounterexample shrinkIntegral 1024
--   Just 8
--   </pre>
--   
--   Provided that the given starting value satisfies the condition, and
--   provided that at least one shrunken value satisfies the condition,
--   this function will terminate with the smallest shrunken value that
--   cannot be shrunk further with the given shrinking function.
--   
--   This function returns <a>Nothing</a> if the given starting value does
--   not satisfy the condition, or if none of the shrunken values satisfy
--   the condition.
--   
--   The final result is evaluated eagerly. If you suspect that a given
--   shrinking sequence does not terminate, then you may wish to consider
--   evaluating a finite prefix of <a>shrinkWhileSteps</a> instead.
shrinkWhile :: (a -> Bool) -> (a -> [a]) -> a -> Maybe a

-- | Repeatedly applies a shrinking function to a value while a condition
--   holds, returning all the intermediate shrinking steps.
--   
--   This function can be used to predict the sequence of intermediate
--   values that QuickCheck will produce when searching for a minimal
--   counterexample.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; isCounterexample = (&gt;= 100)
--   
--   &gt;&gt;&gt; shrinkWhileSteps isCounterexample shrinkIntegral 1024
--   [512,256,128,112,105,102,101,100]
--   </pre>
--   
--   Provided that the given starting value satisfies the condition, and
--   provided that at least one shrunken value satisfies the condition,
--   this function will produce a non-empty list of all intermediate
--   shrinking steps, ordered from largest to smallest.
--   
--   The list is evaluated lazily from largest to smallest. If you suspect
--   that a given shrinking sequence does not terminate, then you may wish
--   to consider evaluating a finite prefix of the list.
--   
--   This function returns the empty list if the given starting value does
--   not satisfy the condition, or if none of the shrunken values satisfy
--   the condition.
shrinkWhileSteps :: forall a. (a -> Bool) -> (a -> [a]) -> a -> [a]

-- | Partitions a list into a list of sublists.
--   
--   Each sublist in the result has a randomly-chosen length that is
--   bounded by the given minimum and maximum length parameters, with the
--   exception of the last sublist, which may be shorter than the minimum
--   length.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; generate (partitionList (0, 1) [1 .. 4])
--   [[], [1], [2], [], [3], [4]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate (partitionList (1, 4) [1 .. 10])
--   [[1, 2], [3, 4, 5, 6], [7], [8, 9, 10]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; generate (partitionList (4, 8) "Books are the liberated spirits of men.")
--   ["Books ar", "e the l", "iberat", "ed spir", "its of", " men."]
--   </pre>
--   
--   Assuming the following definitions of checked minimum and maximum
--   lengths:
--   
--   <pre>
--   &gt;&gt;&gt; x' = max 0 x
--   
--   &gt;&gt;&gt; y' = max 1 (max y x')
--   </pre>
--   
--   This function satisfies the following properties:
--   
--   <pre>
--   forAll (partitionList (x, y) as) $ (== as) . mconcat
--   </pre>
--   
--   <pre>
--   forAll (partitionList (x, y) as) $ all ((&gt;= x') . length) . dropEnd 1
--   </pre>
--   
--   <pre>
--   forAll (partitionList (x, y) as) $ all ((&lt;= y') . length)
--   </pre>
partitionList :: (Int, Int) -> [a] -> Gen [[a]]

-- | Selects an entry at random from the given map.
--   
--   Returns the selected entry and the remaining map with the entry
--   removed.
--   
--   Returns <a>Nothing</a> if (and only if) the given map is empty.
selectMapEntry :: forall k v. Ord k => Map k v -> Gen (Maybe ((k, v), Map k v))

-- | Selects up to a given number of entries at random from the given map.
--   
--   Returns the selected entries and the remaining map with the entries
--   removed.
selectMapEntries :: forall k v. Ord k => Map k v -> Int -> Gen ([(k, v)], Map k v)
chooseNatural :: (Natural, Natural) -> Gen Natural
shrinkNatural :: Natural -> [Natural]
genNonEmpty :: Gen a -> Gen (NonEmpty a)
shrinkNonEmpty :: (a -> [a]) -> NonEmpty a -> [NonEmpty a]

-- | Adds a named variable to the counterexample output of a property.
--   
--   On failure, uses pretty-printing to show the contents of the variable.
report :: (Show a, Testable prop) => a -> String -> prop -> Property

-- | Adds a named condition to a property.
--   
--   On failure, reports the name of the condition that failed.
verify :: Testable t => Bool -> String -> t -> Property

-- | A combinator that causes the output of <a>show</a> to be
--   pretty-printed.
newtype Pretty a
Pretty :: a -> Pretty a
[unPretty] :: Pretty a -> a
newtype NotNull a
NotNull :: a -> NotNull a
[unNotNull] :: NotNull a -> a
interleaveRoundRobin :: [[a]] -> [a]
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Extra.Pretty a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Extra.NotNull a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.QuickCheck.Extra.NotNull a)
instance (Test.QuickCheck.Arbitrary.Arbitrary a, GHC.Classes.Eq a, GHC.Base.Monoid a) => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Extra.NotNull a)
instance GHC.Show.Show a => GHC.Show.Show (Test.QuickCheck.Extra.Pretty a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Test.QuickCheck.Extra.Pretty a)


-- | A helper function for using the bracket pattern in code.
module Test.Utils.Resource

-- | Decompose a bracket pattern resource acquisition function into two
--   separate functions: "allocate" and "release".
--   
--   It almost goes without saying that you should always call "release"
--   after "allocate", otherwise bad things will happen.
--   
--   It works by actually spawning a new thread responsible for the
--   resource acquisition, passing the resource along to the parent threads
--   via a shared MVar. Then, there's a bit of logic to synchronize both
--   threads and make sure that:
--   
--   a) The 'Resource Owner' thread is terminated when the main thread is
--   done with the resource.
--   
--   b) The 'Main Thread' only exists when the resource owner has released
--   the resource. Exiting the main thread before the 'Resource Owner' has
--   released the resource could left a hanging resource open. This is
--   particularly annoying when the resource is a running process!
--   
--   Main Thread Resource Owner x | Spawn |-----------------------&gt;x | |
--   | |-- Acquire resource | Send Resource | |&lt;-----------------------|
--   | | | | ... ... Await main thread signal | | | | | Send Signal |
--   |-----------------------&gt;| | | | ... Release resource | Send Done |
--   |&lt;-----------------------| | Exit | Exit
unBracket :: forall m a. (HasCallStack, MonadUnliftIO m) => ((a -> m ()) -> m ()) -> m (m a, m ())

module Test.Utils.Roundtrip
jsonRoundtripAndGolden :: forall a. (Arbitrary a, ToJSON a, FromJSON a, Typeable a) => FilePath -> Proxy a -> Spec
httpApiDataRoundtrip :: forall a. (Arbitrary a, FromHttpApiData a, ToHttpApiData a, Typeable a, Eq a, Show a) => Proxy a -> Spec

module Test.Utils.Startup
withLineBuffering :: MonadUnliftIO m => m a -> m a
withNoBuffering :: MonadUnliftIO m => m a -> m a


-- | Helper functions for testing.
module Test.Hspec.Extra

-- | Run a <tt>bracket</tt> resource acquisition function around all the
--   specs. The resource is allocated just before the first test case and
--   released immediately after the last test case.
--   
--   Each test is given the resource as a function parameter.
aroundAll :: forall a. HasCallStack => (ActionWith a -> IO ()) -> SpecWith a -> Spec

-- | A drop-in replacement for <a>it</a> that'll automatically retry a
--   scenario once if it fails, to cope with potentially flaky tests, if
--   the environment variable <tt>TESTS_RETRY_FAILED</tt> is set.
--   
--   It also has a timeout of 10 minutes.
it :: HasCallStack => String -> ActionWith ctx -> SpecWith ctx

-- | Like <tt>it</tt> but with a custom timeout, testing of the function
--   possible.
itWithCustomTimeout :: HasCallStack => Int -> String -> ActionWith ctx -> SpecWith ctx

-- | Like Hspec's parallel, except on Windows.
parallel :: SpecWith a -> SpecWith a

-- | Can be used to add context to a <tt>HUnitFailure</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; counterexample (show response) (0 `shouldBe` 3)
--   
--   &gt;&gt;&gt; (Status {statusCode = 200, statusMessage = "OK"},Right [])
--   
--   &gt;&gt;&gt; expected: 3
--   
--   &gt;&gt;&gt; but got: 0
--   </pre>
counterexample :: (MonadIO m, MonadUnliftIO m, HasCallStack) => String -> m a -> m a
appendFailureReason :: String -> HUnitFailure -> HUnitFailure

-- | An IO action that runs around <tt>hspecWith</tt>.
type HspecWrapper a = IO Summary -> IO a

-- | Main function for running a test suite using <a>getDefaultConfig</a>.
hspecMain :: Spec -> IO ()

-- | Main function for running a test suite. Like <a>hspec</a>, except it
--   allows for a custom action to modify the environment and configuration
--   before passing control over to Hspec.
hspecMain' :: IO (HspecWrapper a, Config) -> Spec -> IO a

-- | Our custom Hspec wrapper. It adds the <tt>--env</tt> option for
--   setting environment variables, and prints the tests which took the
--   longest time after finishing the test suite.
getDefaultConfig :: IO (HspecWrapper (), Config)

-- | Add execution timing information to test output.
configWithExecutionTimes :: Config -> Config

-- | A CLI arguments parser which handles setting environment variables.
setEnvParser :: ParserInfo ([(String, String)], [String])


-- | Provides a simple static files web server to be used as a fixture in
--   tests which need a HTTP server.
module Test.Utils.StaticServer

-- | Run a localhost HTTP file server on any free port, while executing the
--   given action.
withStaticServer :: FilePath -> (String -> IO a) -> IO a


-- | Provides utility functions relating to testing with times and dates.
module Test.Utils.Time

-- | A wrapper for <a>UTCTime</a> whose <a>Arbitrary</a> instance spans a
--   uniform range of dates and a mixture of time precisions.
data UniformTime

-- | Generate <a>UTCTime</a> values over a uniform range of dates and a
--   mixture of time precisions.
--   
--   Dates will be generated in a range that's bounded by
--   <a>defaultLowerBound</a> and <a>defaultUpperBound</a>.
genUniformTime :: Gen UTCTime

-- | Generate <a>UTCTime</a> values over a uniform range of dates and a
--   mixture of time precisions.
--   
--   Dates will be generated in a range that's bounded by the given minimum
--   and maximum Julian day arguments.
genUniformTimeWithinRange :: Day -> Day -> Gen UTCTime
getUniformTime :: UniformTime -> UTCTime
instance GHC.Show.Show Test.Utils.Time.UniformTime
instance GHC.Classes.Ord Test.Utils.Time.UniformTime
instance GHC.Classes.Eq Test.Utils.Time.UniformTime
instance Test.QuickCheck.Arbitrary.Arbitrary Test.Utils.Time.UniformTime


-- | Provides functions for setting up and capturing logging so that
--   expectations about logging can be asserted in test scenarios.
module Test.Utils.Trace

-- | Run an action with a logging <tt>Trace</tt> object, and a function to
--   get all messages that have been traced.
withLogging :: MonadUnliftIO m => ((Tracer m msg, m [msg]) -> m a) -> m a

-- | Same as <a>withLogging</a>, but with a different Tracer monad.
withLogging' :: forall m mtr msg a. (MonadUnliftIO m, MonadIO mtr) => ((Tracer mtr msg, m [msg]) -> m a) -> m a

-- | Run an action with a <tt>Trace</tt>, returning captured log messages
--   along with the result of the action.
captureLogging :: MonadUnliftIO m => (Tracer m msg -> m a) -> m ([msg], a)

-- | Same as <a>captureLogging</a>, but with a different Tracer monad.
captureLogging' :: forall m mtr msg a. (MonadUnliftIO m, MonadIO mtr) => (Tracer mtr msg -> m a) -> m ([msg], a)

-- | Provides a Tracer to the spec, which is silent, unless something goes
--   wrong. In that case, it dumps all the traces it has collected to
--   stdout.
traceSpec :: (HasCallStack, ToText msg) => SpecWith (Tracer IO msg) -> Spec
