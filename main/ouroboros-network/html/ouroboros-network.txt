-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A networking layer for the Ouroboros blockchain protocol
--   
--   A networking layer for the Ouroboros blockchain protocol
@package ouroboros-network
@version 0.1.0.1

module Ouroboros.Network.AnchoredSeq

-- | Generalisation of a <tt>Sequence</tt> with elements of type <tt>b</tt>
--   with a custom measure <tt>v</tt> and an anchor <tt>a</tt>.
--   
--   This type is strict in the elements, but not strict in the spine.
--   
--   For example, an <a>AnchoredSeq</a> can represent a fragment of a chain
--   containing blocks that is anchored at a certain point. It can also
--   represent a history of ledger states with the anchor being the
--   "immutable" ledger state.
--   
--   NOTE: there might be multiple elements with the same measure, e.g.,
--   multiple blocks with the same <tt>WithOrigin SlotNo</tt>. That is why
--   functions operating on an <a>AnchoredSeq</a> often take a predicate in
--   addition to a measure. At most one element should satisfy that
--   predicate, e.g., the block must have a certain hash. The behaviour is
--   undefined when multiple elements satisfy the predicate.
data AnchoredSeq v a b

-- | &lt;math&gt;. Pattern for matching on or creating an empty
--   <a>AnchoredSeq</a>. An empty sequence has/needs an anchor.
pattern Empty :: Anchorable v a b => a -> AnchoredSeq v a b

-- | &lt;math&gt;. Add an element to the right of the anchored sequence.
pattern (:>) :: Anchorable v a b => AnchoredSeq v a b -> b -> AnchoredSeq v a b

-- | &lt;math&gt;. View the first, leftmost block of the anchored sequence.
--   
--   Note that the anchor shifts, i.e., the anchor of the second argument
--   will correspond to the first argument.
--   
--   This is only a view, not a constructor, as adding a block to the left
--   would change the anchor of the sequence, but we have no information
--   about the predecessor of the block we'd be prepending.
pattern (:<) :: Anchorable v a b => b -> AnchoredSeq v a b -> AnchoredSeq v a b
infixl 5 :>
infixl 5 :<

-- | Constaint needed to use an <tt>AnchoredSeq</tt>.
class (Ord v, Bounded v) => Anchorable v a b | a -> v

-- | <tt>b</tt> as anchor
asAnchor :: Anchorable v a b => b -> a

-- | Return the measure of an anchor
--   
--   The advantage of this method over a <tt><a>Measured</a> k a</tt>
--   super-class constraint is that it doesn't inherit the
--   <tt><a>Monoid</a> k</tt> constraint, which is unused and often
--   undesired.
getAnchorMeasure :: Anchorable v a b => Proxy b -> a -> v
anchor :: AnchoredSeq v a b -> a

-- | &lt;math&gt;. When the sequence is empty, return the anchor, otherwise
--   the most recently added element.
head :: Anchorable v a b => AnchoredSeq v a b -> Either a b

-- | &lt;math&gt;. The anchor corresponding to the most recently added
--   element (i.e., the anchor that would be needed for a sequence starting
--   <i>after</i> this). When the anchored sequence is empty, the anchor is
--   returned.
headAnchor :: forall v a b. Anchorable v a b => AnchoredSeq v a b -> a

-- | &lt;math&gt;. When the sequence is empty, return the anchor, otherwise
--   the leftmost element.
last :: Anchorable v a b => AnchoredSeq v a b -> Either a b

-- | &lt;math&gt;. Return the elements in the <a>AnchoredSeq</a> in
--   newest-to-oldest order.
toNewestFirst :: AnchoredSeq v a b -> [b]

-- | &lt;math&gt;. Return the elements in the <a>AnchoredSeq</a> in
--   oldest-to-newest order.
toOldestFirst :: AnchoredSeq v a b -> [b]

-- | &lt;math&gt;. Make an <a>AnchoredSeq</a> from a list of elements in
--   newest-to-oldest order. The last element in the list will be the one
--   after the given anchor.
fromNewestFirst :: Anchorable v a b => a -> [b] -> AnchoredSeq v a b

-- | &lt;math&gt;. Make an <a>AnchoredSeq</a> from a list of elements in
--   oldest-to-newest order. The first element in the list will be the one
--   after the given anchor.
fromOldestFirst :: Anchorable v a b => a -> [b] -> AnchoredSeq v a b

-- | &lt;math&gt;. Split the <a>AnchoredSeq</a> at a given position.
--   
--   POSTCONDITION: <tt>(before, after) = splitAt i s</tt>, then: *
--   <tt>anchor before == anchor s</tt> * <tt>headAnchor before == anchor
--   after</tt> * <tt>headAnchor after == headAnchor s</tt> * <tt>join
--   before after == Just s</tt>
splitAt :: Anchorable v a b => Int -> AnchoredSeq v a b -> (AnchoredSeq v a b, AnchoredSeq v a b)

-- | &lt;math&gt;. Drop the newest <tt>n</tt> elements from the
--   <a>AnchoredSeq</a>. The anchor does not change.
dropNewest :: Anchorable v a b => Int -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Take the oldest <tt>n</tt> elements from the
--   <a>AnchoredSeq</a>. The anchor does not change.
takeOldest :: Anchorable v a b => Int -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Drop the newest elements that satisfy the predicate,
--   keeping the remainder. The anchor does not change.
dropWhileNewest :: Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Take the oldest elements that satisfy the predicate. The
--   anchor does not change.
takeWhileOldest :: Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Return the number of elements. The anchor is not
--   counted.
length :: Anchorable v a b => AnchoredSeq v a b -> Int

-- | &lt;math&gt;. The anchor is not counted.
null :: AnchoredSeq v a b -> Bool

-- | &lt;math&gt;. Does the anchored sequence contain an element with the
--   given measure that satisfies the predicate? The anchor is ignored.
contains :: Anchorable v a b => v -> (b -> Bool) -> AnchoredSeq v a b -> Bool

-- | &lt;math&gt;. Does the anchored sequence contain an element with the
--   given measure that satisfies the predicate? The anchor is <i>not</i>
--   ignored.
withinBounds :: Anchorable v a b => v -> (Either a b -> Bool) -> AnchoredSeq v a b -> Bool

-- | &lt;math&gt;. Maps over the elements and the elements.
map :: Anchorable v2 a b2 => (b1 -> b2) -> AnchoredSeq v1 a b1 -> AnchoredSeq v2 a b2

-- | &lt;math&gt;. Maps over the elements.
bimap :: Anchorable v2 a2 b2 => (a1 -> a2) -> (b1 -> b2) -> AnchoredSeq v1 a1 b1 -> AnchoredSeq v2 a2 b2

-- | &lt;math&gt;. Maps over the elements.
--   
--   NOTE: the functions must preserve the measure.
--   
--   More efficient than <a>map</a>
mapPreservingMeasure :: (b1 -> b2) -> AnchoredSeq v a b1 -> AnchoredSeq v a b2

-- | &lt;math&gt;. Maps over the anchor and the elements.
--   
--   NOTE: the functions must preserve the measure.
--   
--   More efficient than <a>bimap</a>
bimapPreservingMeasure :: (a1 -> a2) -> (b1 -> b2) -> AnchoredSeq v a1 b1 -> AnchoredSeq v a2 b2

-- | &lt;math&gt;. Roll back the anchored sequence such that its new head
--   has the same measure as the given one and satisfies the predicate.
--   When there is no such element or anchor, return <a>Nothing</a>.
rollback :: Anchorable v a b => v -> (Either a b -> Bool) -> AnchoredSeq v a b -> Maybe (AnchoredSeq v a b)

-- | &lt;math&gt;. Check whether the first anchored sequence is a prefix of
--   the second. Comparisons are done based on the <a>Eq</a> instances.
--   
--   The two <a>AnchoredSeq</a>s must have the same anchor, otherwise the
--   first cannot be a prefix of the second.
isPrefixOf :: forall v a b. (Eq a, Eq b) => AnchoredSeq v a b -> AnchoredSeq v a b -> Bool

-- | &lt;math&gt;. Check whether the first anchored sequence is a prefix of
--   the second. Comparisons are done based on the measure.
--   
--   The two <a>AnchoredSeq</a>s must have the same anchor, otherwise the
--   first cannot be a prefix of the second.
isPrefixOfByMeasure :: forall v a b. Anchorable v a b => AnchoredSeq v a b -> AnchoredSeq v a b -> Bool

-- | &lt;math&gt; where <i>s</i> is the number of elements with the same
--   measure. Return all elements in the anchored sequence with a measure
--   (<tt>k</tt>) equal to the given one. The elements will be ordered from
--   oldest to newest. Does not look at the anchor.
lookupByMeasure :: Anchorable v a b => v -> AnchoredSeq v a b -> [b]

-- | &lt;math&gt;. Split the <a>AnchoredSeq</a> after an element or anchor
--   with the given measure that satisfies the predicate. Return
--   <a>Nothing</a> if there is no element or anchor with the given measure
--   that satisfies the predicate.
--   
--   If the given measure corresponds to the anchor and it satisfies the
--   predicate, an empty sequence with the given anchor, and the original
--   sequence are returned.
--   
--   PRECONDITION: there can be multiple elements with the same measure,
--   but there should be at most one element (or anchor) with the given
--   measure satisfying the predicate.
--   
--   POSTCONDITION: when <tt>Just (before, after) = splitAfterMeasure k f
--   s</tt>, then: * <tt>anchor before == anchor s</tt> * <tt>headMeasure
--   before == pt</tt> * <tt>anchorMeasure after == pt</tt> *
--   <tt>headAnchor after == headAnchor s</tt> * <tt>join before after ==
--   Just s</tt>
splitAfterMeasure :: Anchorable v a b => v -> (Either a b -> Bool) -> AnchoredSeq v a b -> Maybe (AnchoredSeq v a b, AnchoredSeq v a b)

-- | &lt;math&gt;. Split the <a>AnchoredSeq</a> before an element with the
--   given measure that satisfies the predicate. Return <a>Nothing</a> if
--   the anchored sequence does not contain an element with the given
--   measure that satisfies the predicate.
--   
--   Unlike <a>splitAfterMeasure</a> we can't split before the anchor.
--   
--   PRECONDITION: there can be multiple elements with the same measure,
--   but there should be at most one element (or anchor) with the given
--   measure satisfying the predicate.
--   
--   POSTCONDITION: joining (<a>join</a>) the two anchored sequences gives
--   back the original anchored sequence.
--   
--   POSTCONDITION: the last element (oldest) in the second sequence has
--   the given measure and satisfies the predicate.
splitBeforeMeasure :: Anchorable v a b => v -> (b -> Bool) -> AnchoredSeq v a b -> Maybe (AnchoredSeq v a b, AnchoredSeq v a b)

-- | &lt;math&gt;. Join two anchored sequences if the given function
--   returns <a>True</a> for the head (newest element or anchor when empty)
--   of the first sequence and the anchor of the second sequence, e.g.,
--   when they match.
--   
--   The returned sequence will have the same anchor as the first sequence.
join :: forall v a b. Anchorable v a b => (Either a b -> a -> Bool) -> AnchoredSeq v a b -> AnchoredSeq v a b -> Maybe (AnchoredSeq v a b)

-- | Take the <tt>n</tt> newest elements from the anchored sequence.
--   
--   WARNING: this may change the anchor
--   
--   When the anchored sequence contains fewer than <tt>n</tt> elements,
--   the anchored sequence will be returned unmodified.
anchorNewest :: forall v a b. Anchorable v a b => Word64 -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Select the elements and optionally the anchor based on
--   the given offsets, starting from the head of the <a>AnchoredSeq</a>.
--   
--   The list of offsets must be increasing monotonically (/strictly
--   increasing is not required).
--   
--   <b>Note</b>: offset <tt>n</tt>, where <tt>n</tt> equals the length of
--   the <a>AnchoredSeq</a>, corresponds to the anchor. When the sequence
--   is empty, offset 0 will thus correspond to the anchor.
selectOffsets :: forall v a b. Anchorable v a b => [Int] -> AnchoredSeq v a b -> [Either a b]

-- | &lt;math&gt; ). Variation on <a>filterWithStop</a> without a stop
--   condition.
filter :: forall v a b. Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]

-- | &lt;math&gt; where <i>r</i> is the number of consecutive ranges of
--   elements to be included in the result.
--   
--   Filter out elements that don't match the predicate.
--   
--   As filtering removes elements the result is a sequence of disconnected
--   sequences. The sequences are in the original order and are of maximum
--   size.
--   
--   As soon as the stop condition is true, the filtering stops and the
--   remaining sequence (starting with the first element for which the stop
--   condition is true) is the final sequence in the returned list.
--   
--   The stop condition wins from the filtering predicate: if the stop
--   condition is true for an element, but the filter predicate not, then
--   the element still ends up in final sequence.
--   
--   For example, given the sequence containing <tt>[0: 1, 2, 3, 4, 5,
--   6]</tt> where the anchor is separated from the elements by <tt>:</tt>:
--   
--   <pre>
--   filter         odd        -&gt; [[0: 1], [2: 3], [4: 5]]
--   filterWithStop odd (&gt;= 4) -&gt; [[0: 1], [2: 3], [3: 4, 5, 6]]
--   </pre>
filterWithStop :: forall v a b. Anchorable v a b => (b -> Bool) -> (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]
prettyPrint :: String -> (a -> String) -> (b -> String) -> AnchoredSeq v a b -> String

-- | &lt;math&gt; ). Naive reference implementation of
--   <a>filterWithStop</a>.
--   
--   While the asymptotic complexity of this function is better than that
--   of <a>filterWithStop</a>, the allocation cost is high. This function
--   deconstructs and reconstructs the anchored sequence (until the stop
--   condition is reached), even when no elements are removed.
filterWithStopSpec :: forall v a b. Anchorable v a b => (b -> Bool) -> (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]
instance GHC.Show.Show v => GHC.Show.Show (Ouroboros.Network.AnchoredSeq.Measure v)
instance NoThunks.Class.NoThunks b => NoThunks.Class.NoThunks (Ouroboros.Network.AnchoredSeq.MeasuredWith v a b)
instance GHC.Generics.Generic (Ouroboros.Network.AnchoredSeq.MeasuredWith v a b)
instance GHC.Classes.Eq b => GHC.Classes.Eq (Ouroboros.Network.AnchoredSeq.MeasuredWith v a b)
instance GHC.Show.Show b => GHC.Show.Show (Ouroboros.Network.AnchoredSeq.MeasuredWith v a b)
instance (NoThunks.Class.NoThunks a, NoThunks.Class.NoThunks b) => NoThunks.Class.NoThunks (Ouroboros.Network.AnchoredSeq.AnchoredSeq v a b)
instance GHC.Generics.Generic (Ouroboros.Network.AnchoredSeq.AnchoredSeq v a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Ouroboros.Network.AnchoredSeq.AnchoredSeq v a b)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Ouroboros.Network.AnchoredSeq.AnchoredSeq v a b)
instance GHC.Show.Show Ouroboros.Network.AnchoredSeq.FilterRange
instance Ouroboros.Network.AnchoredSeq.Anchorable v a b => Data.FingerTree.Measured (Ouroboros.Network.AnchoredSeq.Measure v) (Ouroboros.Network.AnchoredSeq.MeasuredWith v a b)
instance GHC.Classes.Ord v => GHC.Base.Semigroup (Ouroboros.Network.AnchoredSeq.Measure v)
instance (GHC.Classes.Ord v, GHC.Enum.Bounded v) => GHC.Base.Monoid (Ouroboros.Network.AnchoredSeq.Measure v)


-- | 𝚫Q representation and primitives.
--   
--   See also
--   <a>https://www.ofcom.org.uk/__data/assets/pdf_file/0024/71682/traffic-management-detection.pdf</a>
--   appendix A.
module Ouroboros.Network.DeltaQ

-- | A "𝚫Q" is a probability distribution on the duration between two
--   events. It is an "improper" probability distribution in that it may
--   not integrate to 1. The "missing" probability mass represents failure.
--   This allows both timing and failure to be represented in one
--   mathematical object.
--   
--   In the case of networks a 𝚫Q can be used for example distributions
--   such as the time for a leading edge or trailing edge of a packet to
--   traverse a network (or failing to do so), and many others besides.
newtype DeltaQ
DeltaQ :: Distribution DiffTime -> DeltaQ

-- | The point in time in the distribution for which 99% of the probability
--   mass is before that time.
--   
--   This tells us how long we would have to wait to have a 99% chance of
--   the end event having happened. Of course 99% is somewhat arbitrary and
--   other points in the distribution could be of interest.
--   
--   TODO: this needs to be specified better for improper distributions.
deltaqQ99thPercentile :: DeltaQ -> DiffTime
deltaqQ50thPercentile :: DeltaQ -> DiffTime

-- | This is another way of looking at a 𝚫Q distribution. Instead of giving
--   a fraction of the probability mass (like 99%) and asking how long we
--   would have to wait, we can say how long we are prepared to wait and
--   ask what fraction of the probability mass is before that time.
--   
--   So this tells us the chance of the end event happening within the time
--   we are prepared to wait. This is useful for evaluating different
--   options for which has the greatest probability of success within a
--   deadline.
deltaqProbabilityMassBeforeDeadline :: DiffTime -> DeltaQ -> Double

-- | A "GSV" corresponds to a 𝚫Q that is a function of the size of a data
--   unit to be transmitted over a network. That is, it gives the 𝚫Q of the
--   transmission time for different sizes of data in <a>SizeInBytes</a>.
--   
--   The 𝚫Q is broken out into three separate 𝚫Q distributions, 𝚫Q∣G, 𝚫Q∣S
--   and 𝚫Q∣V, with the overall 𝚫Q being the convolution of the three
--   components. The G and S components captures the <i>structural</i>
--   aspects of networks, while the V captures the <i>variable</i> aspects:
--   
--   <ul>
--   <li><i><i>G</i></i> the <i>geographical</i> component of network
--   delay. This is the minimum time to transmit a hypothetical zero-sized
--   data unit. This component of the distribution does not depend on the
--   data unit size. It is a degenerate distribution, taking only one
--   value.</li>
--   <li><i><i>S</i></i> the <i>serialisation</i> component of network
--   delay. This is time to serialise a data unit as it is being
--   transmitted. This is of course a function of the data unit size. For
--   each size it is a degenerate distribution, taking only one value.</li>
--   <li><i><i>V</i></i> the <i>variable</i> aspect of network delay. This
--   captures the variability in network delay due to issues such as
--   congestion. This does not depend on the data unit size, and is
--   <i>not</i> a degenerate disruption.</li>
--   </ul>
--   
--   For ballistic transmission of packets, <i>S</i> is typically directly
--   proportional to the size. Thus the combination of <i>G</i> and
--   <i>S</i> is simply a linear function of the size.
data GSV
GSV :: !DiffTime -> !SizeInBytes -> DiffTime -> !Distribution DiffTime -> GSV
type SizeInBytes = Word32

-- | The case of ballistic packet transmission where the <i>S</i> is
--   directly proportional to the packet size.
ballisticGSV :: DiffTime -> DiffTime -> Distribution DiffTime -> GSV

-- | The 𝚫Q for when the leading edge of a transmission unit arrives at the
--   destination. This is just the convolution of the <i>G</i> and <i>V</i>
--   components.
gsvLeadingEdgeArrive :: GSV -> DeltaQ

-- | The 𝚫Q for when the trailing edge of a transmission unit departs the
--   sending end. This is just the convolution of the <i>S</i> and <i>V</i>
--   components.
--   
--   Since it involves <i>S</i> then it depends on the <a>SizeInBytes</a>
--   of the transmission unit.
gsvTrailingEdgeDepart :: GSV -> SizeInBytes -> DeltaQ

-- | The 𝚫Q for when the trailing edge of a transmission unit arrives at
--   the destination. This is the convolution of the <i>G</i>, <i>S</i> and
--   <i>V</i> components.
--   
--   Since it involves <i>S</i> then it depends on the <a>SizeInBytes</a>
--   of the transmission unit.
gsvTrailingEdgeArrive :: GSV -> SizeInBytes -> DeltaQ

-- | An improper probability distribution over some underlying type (such
--   as time durations).
--   
--   The current representation only covers the case of degenerate
--   distributions, that take a single value with probability 1. This is
--   just a proof of concept to illustrate the API.
data Distribution n

-- | Make a degenerate distribution.
--   
--   <a>https://en.wikipedia.org/wiki/Degenerate_distribution</a>
degenerateDistribution :: n -> Distribution n

-- | The <a>GSV</a> for both directions with a peer, outbound and inbound.
data PeerGSV
PeerGSV :: !Time -> !GSV -> !GSV -> PeerGSV
[sampleTime] :: PeerGSV -> !Time
[outboundGSV] :: PeerGSV -> !GSV
[inboundGSV] :: PeerGSV -> !GSV

-- | This is an example derived operation using the other <a>GSV</a> and
--   <a>DeltaQ</a> primitives.
--   
--   It calculates the 𝚫Q for the time to send a request of a certain size
--   and receive a reply of an expected size. It then takes the 99%
--   percentile as an approximation of the maximum time we might be
--   prepared to wait.
--   
--   <pre>
--   deltaqQ99thPercentile $
--       gsvTrailingEdgeArrive outboundGSV reqSize
--    &lt;&gt; gsvTrailingEdgeArrive inboundGSV respSize
--   </pre>
--   
--   This is not realistic in that it omits processing time, but that could
--   be added as yet another <a>DeltaQ</a> value, if there's any estimate
--   for it:
--   
--   <pre>
--   deltaqQ99thPercentile $
--       gsvTrailingEdgeArrive outboundGSV reqSize
--    &lt;&gt; gsvTrailingEdgeArrive inboundGSV respSize
--    &lt;&gt; processingDeltaQ
--   </pre>
gsvRequestResponseDuration :: PeerGSV -> SizeInBytes -> SizeInBytes -> DiffTime
defaultGSV :: PeerGSV
fromSample :: Time -> Time -> SizeInBytes -> PeerGSV
instance GHC.Show.Show Ouroboros.Network.DeltaQ.PeerGSV
instance GHC.Base.Semigroup Ouroboros.Network.DeltaQ.DeltaQ
instance GHC.Base.Semigroup Ouroboros.Network.DeltaQ.PeerGSV
instance GHC.Base.Semigroup Ouroboros.Network.DeltaQ.GSV
instance GHC.Show.Show Ouroboros.Network.DeltaQ.GSV
instance GHC.Num.Num n => GHC.Base.Semigroup (Ouroboros.Network.DeltaQ.Distribution n)

module Ouroboros.Network.BlockFetch.DeltaQ

-- | A "GSV" corresponds to a 𝚫Q that is a function of the size of a data
--   unit to be transmitted over a network. That is, it gives the 𝚫Q of the
--   transmission time for different sizes of data in <a>SizeInBytes</a>.
--   
--   The 𝚫Q is broken out into three separate 𝚫Q distributions, 𝚫Q∣G, 𝚫Q∣S
--   and 𝚫Q∣V, with the overall 𝚫Q being the convolution of the three
--   components. The G and S components captures the <i>structural</i>
--   aspects of networks, while the V captures the <i>variable</i> aspects:
--   
--   <ul>
--   <li><i><i>G</i></i> the <i>geographical</i> component of network
--   delay. This is the minimum time to transmit a hypothetical zero-sized
--   data unit. This component of the distribution does not depend on the
--   data unit size. It is a degenerate distribution, taking only one
--   value.</li>
--   <li><i><i>S</i></i> the <i>serialisation</i> component of network
--   delay. This is time to serialise a data unit as it is being
--   transmitted. This is of course a function of the data unit size. For
--   each size it is a degenerate distribution, taking only one value.</li>
--   <li><i><i>V</i></i> the <i>variable</i> aspect of network delay. This
--   captures the variability in network delay due to issues such as
--   congestion. This does not depend on the data unit size, and is
--   <i>not</i> a degenerate disruption.</li>
--   </ul>
--   
--   For ballistic transmission of packets, <i>S</i> is typically directly
--   proportional to the size. Thus the combination of <i>G</i> and
--   <i>S</i> is simply a linear function of the size.
data GSV

-- | An improper probability distribution over some underlying type (such
--   as time durations).
--   
--   The current representation only covers the case of degenerate
--   distributions, that take a single value with probability 1. This is
--   just a proof of concept to illustrate the API.
data Distribution n

-- | A "𝚫Q" is a probability distribution on the duration between two
--   events. It is an "improper" probability distribution in that it may
--   not integrate to 1. The "missing" probability mass represents failure.
--   This allows both timing and failure to be represented in one
--   mathematical object.
--   
--   In the case of networks a 𝚫Q can be used for example distributions
--   such as the time for a leading edge or trailing edge of a packet to
--   traverse a network (or failing to do so), and many others besides.
data DeltaQ

-- | The <a>GSV</a> for both directions with a peer, outbound and inbound.
data PeerGSV
PeerGSV :: !Time -> !GSV -> !GSV -> PeerGSV
[sampleTime] :: PeerGSV -> !Time
[outboundGSV] :: PeerGSV -> !GSV
[inboundGSV] :: PeerGSV -> !GSV
type SizeInBytes = Word32
data PeerFetchInFlightLimits
PeerFetchInFlightLimits :: SizeInBytes -> SizeInBytes -> PeerFetchInFlightLimits
[inFlightBytesHighWatermark] :: PeerFetchInFlightLimits -> SizeInBytes
[inFlightBytesLowWatermark] :: PeerFetchInFlightLimits -> SizeInBytes
calculatePeerFetchInFlightLimits :: PeerGSV -> PeerFetchInFlightLimits

-- | Given the <a>PeerGSV</a>, the bytes already in flight and the size of
--   new blocks to download, estimate the probability of the download
--   completing within the deadline.
--   
--   This is an appropriate estimator to use in a situation where meeting a
--   known deadline is the goal.
estimateResponseDeadlineProbability :: PeerGSV -> SizeInBytes -> SizeInBytes -> DiffTime -> Double

-- | Given the <a>PeerGSV</a>, the bytes already in flight and the size of
--   new blocks to download, estimate the expected (mean) time to complete
--   the download.
--   
--   This is an appropriate estimator to use when trying to minimising the
--   expected overall download time case in the long run (rather than
--   optimising for the worst case in the short term).
estimateExpectedResponseDuration :: PeerGSV -> SizeInBytes -> SizeInBytes -> DiffTime

-- | Order two PeerGSVs based on <tt>g</tt>. Incase the g values are within
--   +/- 5% of each other <tt>peer</tt> is used as a tie breaker. The salt
--   is unique per running node, which avoids all nodes prefering the same
--   peer in case of a tie.
comparePeerGSV :: forall peer. (Hashable peer, Ord peer) => Set peer -> Int -> (PeerGSV, peer) -> (PeerGSV, peer) -> Ordering

-- | Order two PeerGSVs based on <tt>g</tt>. Like comparePeerGSV but
--   doesn't take active status into account
comparePeerGSV' :: forall peer. (Hashable peer, Ord peer) => Int -> (PeerGSV, peer) -> (PeerGSV, peer) -> Ordering
instance GHC.Show.Show Ouroboros.Network.BlockFetch.DeltaQ.PeerFetchInFlightLimits

module Ouroboros.Network.Magic

-- | NetworkMagic is used to differentiate between different networks
--   during the initial handshake.
newtype NetworkMagic
NetworkMagic :: Word32 -> NetworkMagic
[unNetworkMagic] :: NetworkMagic -> Word32
instance NoThunks.Class.NoThunks Ouroboros.Network.Magic.NetworkMagic
instance GHC.Generics.Generic Ouroboros.Network.Magic.NetworkMagic
instance GHC.Classes.Eq Ouroboros.Network.Magic.NetworkMagic
instance GHC.Show.Show Ouroboros.Network.Magic.NetworkMagic

module Ouroboros.Network.NodeToClient.Version

-- | Enumeration of node to client protocol versions.
data NodeToClientVersion

-- | enabled <tt>CardanoNodeToClientVersion7</tt>, i.e., Alonzo
NodeToClientV_9 :: NodeToClientVersion

-- | added <tt>GetChainBlockNo</tt> and <tt>GetChainPoint</tt> queries
NodeToClientV_10 :: NodeToClientVersion

-- | added <tt>GetRewardInfoPools</tt> Block query
NodeToClientV_11 :: NodeToClientVersion

-- | added <tt>LocalTxMonitor</tt> mini-protocol
NodeToClientV_12 :: NodeToClientVersion

-- | enabled <tt>CardanoNodeToClientVersion9</tt>, i.e., Babbage
NodeToClientV_13 :: NodeToClientVersion

-- | Version data for NodeToClient protocol v1
newtype NodeToClientVersionData
NodeToClientVersionData :: NetworkMagic -> NodeToClientVersionData
[networkMagic] :: NodeToClientVersionData -> NetworkMagic

-- | We set 16ths bit to distinguish <tt>NodeToNodeVersion</tt> and
--   <a>NodeToClientVersion</a>. This way connecting wrong protocol suite
--   will fail during <tt>Handshake</tt> negotiation
--   
--   This is done in backward compatible way, so <tt>NodeToClientV_1</tt>
--   encoding is not changed.
nodeToClientVersionCodec :: CodecCBORTerm (Text, Maybe Int) NodeToClientVersion
nodeToClientCodecCBORTerm :: NodeToClientVersion -> CodecCBORTerm Text NodeToClientVersionData
instance GHC.Show.Show Ouroboros.Network.NodeToClient.Version.NodeToClientVersion
instance GHC.Enum.Bounded Ouroboros.Network.NodeToClient.Version.NodeToClientVersion
instance GHC.Enum.Enum Ouroboros.Network.NodeToClient.Version.NodeToClientVersion
instance GHC.Classes.Ord Ouroboros.Network.NodeToClient.Version.NodeToClientVersion
instance GHC.Classes.Eq Ouroboros.Network.NodeToClient.Version.NodeToClientVersion
instance GHC.Show.Show Ouroboros.Network.NodeToClient.Version.NodeToClientVersionData
instance GHC.Classes.Eq Ouroboros.Network.NodeToClient.Version.NodeToClientVersionData
instance Ouroboros.Network.Protocol.Handshake.Version.Acceptable Ouroboros.Network.NodeToClient.Version.NodeToClientVersionData

module Ouroboros.Network.NodeToNode.Version

-- | Enumeration of node to node protocol versions.
data NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>new <tt>KeepAlive</tt> codec</li>
--   <li>Enable <tt>CardanoNodeToNodeVersion5</tt>, i.e., Alonzo</li>
--   </ul>
NodeToNodeV_7 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Enable block diffusion pipelining in ChainSync and BlockFetch
--   logic.</li>
--   </ul>
NodeToNodeV_8 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Enable <tt>CardanoNodeToNodeVersion6</tt>, i.e., Babbage</li>
--   </ul>
NodeToNodeV_9 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Enable full duplex connections. NOTE: This is an experimental
--   protocol version, which is not yet released. Until initial P2P version
--   it must be kept as the last version, which allows us to keep it as an
--   experimental version.</li>
--   </ul>
NodeToNodeV_10 :: NodeToNodeVersion

-- | Version data for NodeToNode protocol
data NodeToNodeVersionData
NodeToNodeVersionData :: !NetworkMagic -> !DiffusionMode -> NodeToNodeVersionData
[networkMagic] :: NodeToNodeVersionData -> !NetworkMagic
[diffusionMode] :: NodeToNodeVersionData -> !DiffusionMode

-- | The flag which indicates wheather the node runs only initiator or both
--   initiator or responder node. It does not however specify weather the
--   node is using duplex connections, this is implicit see
--   <tt>NodeToNodeV_4</tt>
data DiffusionMode
InitiatorOnlyDiffusionMode :: DiffusionMode
InitiatorAndResponderDiffusionMode :: DiffusionMode
data ConnectionMode
UnidirectionalMode :: ConnectionMode
DuplexMode :: ConnectionMode
nodeToNodeVersionCodec :: CodecCBORTerm (Text, Maybe Int) NodeToNodeVersion
nodeToNodeCodecCBORTerm :: NodeToNodeVersion -> CodecCBORTerm Text NodeToNodeVersionData

-- | Check whether a version enabling diffusion pipelining has been
--   negotiated.
isPipeliningEnabled :: NodeToNodeVersion -> Bool
instance GHC.Show.Show Ouroboros.Network.NodeToNode.Version.NodeToNodeVersion
instance GHC.Enum.Bounded Ouroboros.Network.NodeToNode.Version.NodeToNodeVersion
instance GHC.Enum.Enum Ouroboros.Network.NodeToNode.Version.NodeToNodeVersion
instance GHC.Classes.Ord Ouroboros.Network.NodeToNode.Version.NodeToNodeVersion
instance GHC.Classes.Eq Ouroboros.Network.NodeToNode.Version.NodeToNodeVersion
instance GHC.Show.Show Ouroboros.Network.NodeToNode.Version.DiffusionMode
instance GHC.Classes.Eq Ouroboros.Network.NodeToNode.Version.DiffusionMode
instance GHC.Classes.Eq Ouroboros.Network.NodeToNode.Version.NodeToNodeVersionData
instance GHC.Show.Show Ouroboros.Network.NodeToNode.Version.NodeToNodeVersionData
instance Ouroboros.Network.Protocol.Handshake.Version.Acceptable Ouroboros.Network.NodeToNode.Version.NodeToNodeVersionData

module Ouroboros.Network.PeerSelection.EstablishedPeers
data EstablishedPeers peeraddr peerconn
empty :: EstablishedPeers peeraddr perconn

-- | <i>O(1)</i>
toMap :: EstablishedPeers peeraddr peerconn -> Map peeraddr peerconn

-- | <i>O(n)</i>
toSet :: EstablishedPeers peeraddr peerconn -> Set peeraddr

-- | Map of established peers that are either active or ready to be
--   promoted to active.
--   
--   <i>O(n log m), for n not-ready peers, and m established peers</i>
readyPeers :: Ord peeraddr => EstablishedPeers peeraddr peerconn -> Set peeraddr

-- | The number of established peers. The size of <a>allPeers</a>
--   
--   <i>O(1)</i>
size :: EstablishedPeers peeraddr peerconn -> Int

-- | The number of ready peers. The size of <a>readyPeers</a>
--   
--   <i>O(1)</i>
sizeReady :: EstablishedPeers peeraddr peerconn -> Int
member :: Ord peeraddr => peeraddr -> EstablishedPeers peeraddr peerconn -> Bool

-- | Insert a peer into <a>EstablishedPeers</a>.
insert :: Ord peeraddr => peeraddr -> peerconn -> EstablishedPeers peeraddr peerconn -> EstablishedPeers peeraddr peerconn
delete :: Ord peeraddr => peeraddr -> EstablishedPeers peeraddr peerconn -> EstablishedPeers peeraddr peerconn

-- | Bulk delete of peers from 'EstablishedPeers.
deletePeers :: Ord peeraddr => Set peeraddr -> EstablishedPeers peeraddr peerconn -> EstablishedPeers peeraddr peerconn
setCurrentTime :: Ord peeraddr => Time -> EstablishedPeers peeraddr peerconn -> EstablishedPeers peeraddr peerconn
minActivateTime :: Ord peeraddr => EstablishedPeers peeraddr peerconn -> Maybe Time
setActivateTime :: Ord peeraddr => Set peeraddr -> Time -> EstablishedPeers peeraddr peerconn -> EstablishedPeers peeraddr peerconn
invariant :: Ord peeraddr => EstablishedPeers peeraddr peerconn -> Bool
instance GHC.Base.Functor (Ouroboros.Network.PeerSelection.EstablishedPeers.EstablishedPeers peeraddr)
instance (GHC.Show.Show peeraddr, GHC.Show.Show peerconn) => GHC.Show.Show (Ouroboros.Network.PeerSelection.EstablishedPeers.EstablishedPeers peeraddr peerconn)

module Ouroboros.Network.PeerSelection.KnownPeers

-- | The set of known peers. To a first approximation it can be thought of
--   as a <a>Set</a> of <tt>peeraddr</tt>.
--   
--   It has two special features:
--   
--   <ul>
--   <li>It tracks which peers we are permitted to gossip with now, or for
--   peers we cannot gossip with now the time at which we would next be
--   allowed to do so.</li>
--   <li>It tracks the subset of peers that we are happy to publish in
--   reply to gossip requests to our node. It supports random sampling from
--   this set.</li>
--   </ul>
data KnownPeers peeraddr
invariant :: Ord peeraddr => KnownPeers peeraddr -> Bool
empty :: KnownPeers peeraddr
size :: KnownPeers peeraddr -> Int
insert :: Ord peeraddr => Set peeraddr -> KnownPeers peeraddr -> KnownPeers peeraddr
delete :: Ord peeraddr => Set peeraddr -> KnownPeers peeraddr -> KnownPeers peeraddr

-- | <i>O(n)</i>
toSet :: KnownPeers peeraddr -> Set peeraddr
member :: Ord peeraddr => peeraddr -> KnownPeers peeraddr -> Bool
setCurrentTime :: Ord peeraddr => Time -> KnownPeers peeraddr -> KnownPeers peeraddr
incrementFailCount :: Ord peeraddr => peeraddr -> KnownPeers peeraddr -> (Int, KnownPeers peeraddr)
resetFailCount :: Ord peeraddr => peeraddr -> KnownPeers peeraddr -> KnownPeers peeraddr
lookupFailCount :: Ord peeraddr => peeraddr -> KnownPeers peeraddr -> Maybe Int
lookupTepidFlag :: Ord peeraddr => peeraddr -> KnownPeers peeraddr -> Maybe Bool
setTepidFlag :: Ord peeraddr => peeraddr -> KnownPeers peeraddr -> KnownPeers peeraddr
clearTepidFlag :: Ord peeraddr => peeraddr -> KnownPeers peeraddr -> KnownPeers peeraddr

-- | The first time that a peer will become available for gossip. If peers
--   are already available for gossip, or there are no known peers at all
--   then the result is <tt>Nothing</tt>.
minGossipTime :: Ord peeraddr => KnownPeers peeraddr -> Maybe Time
setGossipTime :: Ord peeraddr => Set peeraddr -> Time -> KnownPeers peeraddr -> KnownPeers peeraddr

-- | The subset of known peers that we would be allowed to gossip with now.
--   This is because we have not gossiped with them recently.
availableForGossip :: KnownPeers peeraddr -> Set peeraddr
minConnectTime :: Ord peeraddr => KnownPeers peeraddr -> Maybe Time
setConnectTime :: Ord peeraddr => Set peeraddr -> Time -> KnownPeers peeraddr -> KnownPeers peeraddr

-- | The subset of known peers that we would be allowed to try to establish
--   a connection to now. This is because we have not connected with them
--   before or because any failure backoff time has expired.
availableToConnect :: KnownPeers peeraddr -> Set peeraddr
instance GHC.Show.Show Ouroboros.Network.PeerSelection.KnownPeers.KnownPeerInfo
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.KnownPeers.KnownPeerInfo
instance GHC.Show.Show peeraddr => GHC.Show.Show (Ouroboros.Network.PeerSelection.KnownPeers.KnownPeers peeraddr)

module Ouroboros.Network.PeerSelection.PeerMetric.Type

-- | Report arrival time of a header for a given slot.
type HeaderMetricsTracer m = Tracer (STM m) (SlotNo, Time)

-- | Report block arrival of given size for some slot at a given time.
type FetchedMetricsTracer m = Tracer (STM m) (SizeInBytes, SlotNo, Time)
data ReportPeerMetrics m peerAddr
ReportPeerMetrics :: Tracer (STM m) (TraceLabelPeer peerAddr (SlotNo, Time)) -> Tracer (STM m) (TraceLabelPeer peerAddr (SizeInBytes, SlotNo, Time)) -> ReportPeerMetrics m peerAddr
[reportHeader] :: ReportPeerMetrics m peerAddr -> Tracer (STM m) (TraceLabelPeer peerAddr (SlotNo, Time))
[reportFetch] :: ReportPeerMetrics m peerAddr -> Tracer (STM m) (TraceLabelPeer peerAddr (SizeInBytes, SlotNo, Time))

-- | A peer label for use in <tt>Tracer</tt>s. This annotates tracer output
--   as being associated with a given peer identifier.
data TraceLabelPeer peerid a
TraceLabelPeer :: peerid -> a -> TraceLabelPeer peerid a

module Ouroboros.Network.PeerSelection.RelayAccessPoint

-- | A product of a <a>Domain</a> and <a>PortNumber</a>. After resolving
--   the domain we will use the <a>PortNumber</a> to form <a>SockAddr</a>.
data DomainAccessPoint
DomainAccessPoint :: !Domain -> !PortNumber -> DomainAccessPoint
[dapDomain] :: DomainAccessPoint -> !Domain
[dapPortNumber] :: DomainAccessPoint -> !PortNumber

-- | A relay can have either an IP address and a port number or a domain
--   with a port number
data RelayAccessPoint
RelayAccessDomain :: !Domain -> !PortNumber -> RelayAccessPoint
RelayAccessAddress :: !IP -> !PortNumber -> RelayAccessPoint

-- | <a>RelayDomainAccessPoint</a> a bidirectional pattern which links
--   <a>RelayAccessDomain</a> and <a>DomainAccessPoint</a>.
pattern RelayDomainAccessPoint :: DomainAccessPoint -> RelayAccessPoint

-- | A unified IP data for <a>IPv4</a> and <a>IPv6</a>. To create this, use
--   the data constructors. Or use <a>read</a> <tt>"192.0.2.1"</tt> ::
--   <a>IP</a>, for example. Also, <tt>"192.0.2.1"</tt> can be used as
--   literal with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; (read "192.0.2.1" :: IP) == IPv4 (read "192.0.2.1" :: IPv4)
--   True
--   
--   &gt;&gt;&gt; (read "2001:db8:00:00:00:00:00:01" :: IP) == IPv6 (read "2001:db8:00:00:00:00:00:01" :: IPv6)
--   True
--   </pre>
data IP
IPv4 :: IPv4 -> IP
[ipv4] :: IP -> IPv4
IPv6 :: IPv6 -> IP
[ipv6] :: IP -> IPv6

-- | Port number. Use the <tt>Num</tt> instance (i.e. use a literal) to
--   create a <tt>PortNumber</tt> value.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   
--   &gt;&gt;&gt; show (12345 :: PortNumber)
--   "12345"
--   
--   &gt;&gt;&gt; 50000 &lt; (51000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 &lt; (52000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 + (10000 :: PortNumber)
--   60000
--   </pre>
data PortNumber
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.RelayAccessPoint.DomainAccessPoint
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.RelayAccessPoint.DomainAccessPoint
instance GHC.Show.Show Ouroboros.Network.PeerSelection.RelayAccessPoint.DomainAccessPoint
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance GHC.Show.Show Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance Control.DeepSeq.NFData Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance Data.Aeson.Types.FromJSON.FromJSON Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance Data.Aeson.Types.ToJSON.ToJSON Ouroboros.Network.PeerSelection.RelayAccessPoint.RelayAccessPoint
instance Data.Aeson.Types.FromJSON.FromJSON Ouroboros.Network.PeerSelection.RelayAccessPoint.DomainAccessPoint
instance Data.Aeson.Types.ToJSON.ToJSON Ouroboros.Network.PeerSelection.RelayAccessPoint.DomainAccessPoint

module Ouroboros.Network.PeerSelection.RootPeersDNS.DNSActions

-- | Dictionary of DNS actions vocabulary
data DNSActions resolver exception m
DNSActions :: (ResolvConf -> m (Resource m (DNSorIOError exception) resolver)) -> (ResolvConf -> m (Resource m (DNSorIOError exception) resolver)) -> (ResolvConf -> resolver -> Domain -> m ([DNSError], [(IP, TTL)])) -> DNSActions resolver exception m

-- | TODO: it could be useful for <tt>publicRootPeersProvider</tt>.
[dnsResolverResource] :: DNSActions resolver exception m -> ResolvConf -> m (Resource m (DNSorIOError exception) resolver)

-- | <a>Resource</a> which passes the <a>Resolver</a> (or abstract resolver
--   type) through a <a>StrictTVar</a>. Better than <a>resolverResource</a>
--   when using in multiple threads.
--   
--   On <i>Windows</i> we use a different implementation which always
--   returns a newly initialised <a>Resolver</a> at each step. This is
--   because on <i>Windows</i> we don't have a way to check that the
--   network configuration has changed. The <tt>dns</tt> library is using
--   'GetNetworkParams@ win32 api call to get the list of default dns
--   servers.
[dnsAsyncResolverResource] :: DNSActions resolver exception m -> ResolvConf -> m (Resource m (DNSorIOError exception) resolver)

-- | Like <a>lookupA</a> but also return the TTL for the results.
--   
--   DNS library timeouts do not work reliably on Windows (#1873), hence
--   the additional timeout.
[dnsLookupWithTTL] :: DNSActions resolver exception m -> ResolvConf -> resolver -> Domain -> m ([DNSError], [(IP, TTL)])

-- | Bundle of DNS Actions that runs in IO The IPv4 and IPv6 addresses the
--   node will be using should determine the LookupReqs so that we can
--   avoid lookups for address types that wont be used.
ioDNSActions :: LookupReqs -> DNSActions Resolver IOException IO
data LookupReqs
LookupReqAOnly :: LookupReqs
LookupReqAAAAOnly :: LookupReqs
LookupReqAAndAAAA :: LookupReqs

-- | Evolving resource; We use it to reinitialise the dns library if the
--   `<i>etc</i>resolv.conf` file was modified.
newtype Resource m err a
Resource :: m (Either err a, Resource m err a) -> Resource m err a
[withResource] :: Resource m err a -> m (Either err a, Resource m err a)

-- | Like <a>withResource</a> but retries untill success.
withResource' :: MonadDelay m => Tracer m err -> NonEmpty DiffTime -> Resource m err a -> m (a, Resource m err a)
constantResource :: Applicative m => a -> Resource m err a
data DNSorIOError exception
DNSError :: !DNSError -> DNSorIOError exception
IOError :: !exception -> DNSorIOError exception
instance GHC.Show.Show Ouroboros.Network.PeerSelection.RootPeersDNS.DNSActions.LookupReqs
instance GHC.Show.Show exception => GHC.Show.Show (Ouroboros.Network.PeerSelection.RootPeersDNS.DNSActions.DNSorIOError exception)
instance GHC.Exception.Type.Exception exception => GHC.Exception.Type.Exception (Ouroboros.Network.PeerSelection.RootPeersDNS.DNSActions.DNSorIOError exception)

module Ouroboros.Network.PeerSelection.Types

-- | Where did this peer come from? Policy functions can choose to treat
--   peers differently depending on where we found them from.
data PeerSource
PeerSourceLocalRoot :: PeerSource
PeerSourcePublicRoot :: PeerSource
PeerSourceGossip :: PeerSource

-- | Should this peer be advertised to other peers asking for known peers?
--   For certain peers specified by configuration it would be an
--   appropriate policy to keep them private.
data PeerAdvertise
DoNotAdvertisePeer :: PeerAdvertise
DoAdvertisePeer :: PeerAdvertise
data PeerStatus
PeerCold :: PeerStatus
PeerWarm :: PeerStatus
PeerHot :: PeerStatus
instance GHC.Enum.Enum Ouroboros.Network.PeerSelection.Types.PeerSource
instance GHC.Show.Show Ouroboros.Network.PeerSelection.Types.PeerSource
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.Types.PeerSource
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.Types.PeerSource
instance GHC.Generics.Generic Ouroboros.Network.PeerSelection.Types.PeerAdvertise
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.Types.PeerAdvertise
instance GHC.Show.Show Ouroboros.Network.PeerSelection.Types.PeerAdvertise
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.Types.PeerAdvertise
instance GHC.Show.Show Ouroboros.Network.PeerSelection.Types.PeerStatus
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.Types.PeerStatus
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.Types.PeerStatus
instance Data.Aeson.Types.FromJSON.FromJSON Ouroboros.Network.PeerSelection.Types.PeerAdvertise
instance Data.Aeson.Types.ToJSON.ToJSON Ouroboros.Network.PeerSelection.Types.PeerAdvertise

module Ouroboros.Network.PeerSelection.RootPeersDNS

-- | Dictionary of DNS actions vocabulary
data DNSActions resolver exception m
DNSActions :: (ResolvConf -> m (Resource m (DNSorIOError exception) resolver)) -> (ResolvConf -> m (Resource m (DNSorIOError exception) resolver)) -> (ResolvConf -> resolver -> Domain -> m ([DNSError], [(IP, TTL)])) -> DNSActions resolver exception m

-- | TODO: it could be useful for <tt>publicRootPeersProvider</tt>.
[dnsResolverResource] :: DNSActions resolver exception m -> ResolvConf -> m (Resource m (DNSorIOError exception) resolver)

-- | <a>Resource</a> which passes the <a>Resolver</a> (or abstract resolver
--   type) through a <a>StrictTVar</a>. Better than <a>resolverResource</a>
--   when using in multiple threads.
--   
--   On <i>Windows</i> we use a different implementation which always
--   returns a newly initialised <a>Resolver</a> at each step. This is
--   because on <i>Windows</i> we don't have a way to check that the
--   network configuration has changed. The <tt>dns</tt> library is using
--   'GetNetworkParams@ win32 api call to get the list of default dns
--   servers.
[dnsAsyncResolverResource] :: DNSActions resolver exception m -> ResolvConf -> m (Resource m (DNSorIOError exception) resolver)

-- | Like <a>lookupA</a> but also return the TTL for the results.
--   
--   DNS library timeouts do not work reliably on Windows (#1873), hence
--   the additional timeout.
[dnsLookupWithTTL] :: DNSActions resolver exception m -> ResolvConf -> resolver -> Domain -> m ([DNSError], [(IP, TTL)])
constantResource :: Applicative m => a -> Resource m err a

-- | Bundle of DNS Actions that runs in IO The IPv4 and IPv6 addresses the
--   node will be using should determine the LookupReqs so that we can
--   avoid lookups for address types that wont be used.
ioDNSActions :: LookupReqs -> DNSActions Resolver IOException IO
data LookupReqs
LookupReqAOnly :: LookupReqs
LookupReqAAAAOnly :: LookupReqs
LookupReqAAndAAAA :: LookupReqs

-- | Resolve <tt>RelayAddress</tt>-es of local root peers using dns if
--   needed. Local roots are provided wrapped in a <a>StrictTVar</a>, which
--   value might change (re-read form a config file). The resolved dns
--   names are available through the output <a>StrictTVar</a>.
localRootPeersProvider :: forall m peerAddr resolver exception. (MonadAsync m, MonadDelay m, Eq (Async m Void), Ord peerAddr) => Tracer m (TraceLocalRootPeers peerAddr exception) -> (IP -> PortNumber -> peerAddr) -> ResolvConf -> DNSActions resolver exception m -> STM m [(Int, Map RelayAccessPoint PeerAdvertise)] -> StrictTVar m (Seq (Int, Map peerAddr PeerAdvertise)) -> m Void

-- | A product of a <a>Domain</a> and <a>PortNumber</a>. After resolving
--   the domain we will use the <a>PortNumber</a> to form <a>SockAddr</a>.
data DomainAccessPoint
DomainAccessPoint :: !Domain -> !PortNumber -> DomainAccessPoint
[dapDomain] :: DomainAccessPoint -> !Domain
[dapPortNumber] :: DomainAccessPoint -> !PortNumber

-- | A relay can have either an IP address and a port number or a domain
--   with a port number
data RelayAccessPoint
RelayAccessDomain :: !Domain -> !PortNumber -> RelayAccessPoint
RelayAccessAddress :: !IP -> !PortNumber -> RelayAccessPoint

-- | <a>RelayDomainAccessPoint</a> a bidirectional pattern which links
--   <a>RelayAccessDomain</a> and <a>DomainAccessPoint</a>.
pattern RelayDomainAccessPoint :: DomainAccessPoint -> RelayAccessPoint

-- | A unified IP data for <a>IPv4</a> and <a>IPv6</a>. To create this, use
--   the data constructors. Or use <a>read</a> <tt>"192.0.2.1"</tt> ::
--   <a>IP</a>, for example. Also, <tt>"192.0.2.1"</tt> can be used as
--   literal with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; (read "192.0.2.1" :: IP) == IPv4 (read "192.0.2.1" :: IPv4)
--   True
--   
--   &gt;&gt;&gt; (read "2001:db8:00:00:00:00:00:01" :: IP) == IPv6 (read "2001:db8:00:00:00:00:00:01" :: IPv6)
--   True
--   </pre>
data IP
IPv4 :: IPv4 -> IP
[ipv4] :: IP -> IPv4
IPv6 :: IPv6 -> IP
[ipv6] :: IP -> IPv6
data TraceLocalRootPeers peerAddr exception

-- | <a>Int</a> is the configured valency for the local producer groups
TraceLocalRootDomains :: [(Int, Map RelayAccessPoint PeerAdvertise)] -> TraceLocalRootPeers peerAddr exception
TraceLocalRootWaiting :: DomainAccessPoint -> DiffTime -> TraceLocalRootPeers peerAddr exception
TraceLocalRootResult :: DomainAccessPoint -> [(IP, TTL)] -> TraceLocalRootPeers peerAddr exception

-- | This traces the results of the local root peer provider
TraceLocalRootGroups :: Seq (Int, Map peerAddr PeerAdvertise) -> TraceLocalRootPeers peerAddr exception
TraceLocalRootFailure :: DomainAccessPoint -> DNSorIOError exception -> TraceLocalRootPeers peerAddr exception
TraceLocalRootError :: DomainAccessPoint -> SomeException -> TraceLocalRootPeers peerAddr exception

-- | TODO track PeerAdvertise
publicRootPeersProvider :: forall peerAddr resolver exception a m. (MonadThrow m, MonadAsync m, Exception exception, Ord peerAddr) => Tracer m TracePublicRootPeers -> (IP -> PortNumber -> peerAddr) -> ResolvConf -> STM m [RelayAccessPoint] -> DNSActions resolver exception m -> ((Int -> m (Set peerAddr, DiffTime)) -> m a) -> m a
data TracePublicRootPeers
TracePublicRootRelayAccessPoint :: [RelayAccessPoint] -> TracePublicRootPeers
TracePublicRootDomains :: [DomainAccessPoint] -> TracePublicRootPeers
TracePublicRootResult :: Domain -> [(IP, TTL)] -> TracePublicRootPeers
TracePublicRootFailure :: Domain -> DNSError -> TracePublicRootPeers

-- | Provides DNS resolution functionality.
resolveDomainAccessPoint :: forall exception resolver m. (MonadThrow m, MonadAsync m, Exception exception) => Tracer m TracePublicRootPeers -> ResolvConf -> DNSActions resolver exception m -> [DomainAccessPoint] -> m (Map DomainAccessPoint (Set SockAddr))

-- | Type for resolver configuration. Use <a>defaultResolvConf</a> to
--   create a new value.
--   
--   An example to use Google's public DNS cache instead of resolv.conf:
--   
--   <pre>
--   &gt;&gt;&gt; let conf = defaultResolvConf { resolvInfo = RCHostName "8.8.8.8" }
--   </pre>
--   
--   An example to use multiple Google's public DNS cache concurrently:
--   
--   <pre>
--   &gt;&gt;&gt; let conf = defaultResolvConf { resolvInfo = RCHostNames ["8.8.8.8","8.8.4.4"], resolvConcurrent = True }
--   </pre>
--   
--   An example to disable EDNS0:
--   
--   <pre>
--   &gt;&gt;&gt; let conf = defaultResolvConf { resolvEDNS = [] }
--   </pre>
--   
--   An example to enable EDNS0 with a 1,280-bytes buffer:
--   
--   <pre>
--   &gt;&gt;&gt; let conf = defaultResolvConf { resolvEDNS = [fromEDNS0 defaultEDNS0 { udpSize = 1280 }] }
--   </pre>
--   
--   An example to enable cache:
--   
--   <pre>
--   &gt;&gt;&gt; let conf = defaultResolvConf { resolvCache = Just defaultCacheConf }
--   </pre>
data ResolvConf

-- | Type for domain.
type Domain = ByteString

-- | Time to live in second.
type TTL = Word32

-- | Port number. Use the <tt>Num</tt> instance (i.e. use a literal) to
--   create a <tt>PortNumber</tt> value.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   
--   &gt;&gt;&gt; show (12345 :: PortNumber)
--   "12345"
--   
--   &gt;&gt;&gt; 50000 &lt; (51000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 &lt; (52000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 + (10000 :: PortNumber)
--   60000
--   </pre>
data PortNumber
instance (GHC.Show.Show peerAddr, GHC.Show.Show exception) => GHC.Show.Show (Ouroboros.Network.PeerSelection.RootPeersDNS.TraceLocalRootPeers peerAddr exception)
instance GHC.Show.Show Ouroboros.Network.PeerSelection.RootPeersDNS.TracePublicRootPeers

module Ouroboros.Network.PeerSelection.LedgerPeers

-- | A product of a <a>Domain</a> and <a>PortNumber</a>. After resolving
--   the domain we will use the <a>PortNumber</a> to form <a>SockAddr</a>.
data DomainAccessPoint
DomainAccessPoint :: !Domain -> !PortNumber -> DomainAccessPoint
[dapDomain] :: DomainAccessPoint -> !Domain
[dapPortNumber] :: DomainAccessPoint -> !PortNumber

-- | A unified IP data for <a>IPv4</a> and <a>IPv6</a>. To create this, use
--   the data constructors. Or use <a>read</a> <tt>"192.0.2.1"</tt> ::
--   <a>IP</a>, for example. Also, <tt>"192.0.2.1"</tt> can be used as
--   literal with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; (read "192.0.2.1" :: IP) == IPv4 (read "192.0.2.1" :: IPv4)
--   True
--   
--   &gt;&gt;&gt; (read "2001:db8:00:00:00:00:00:01" :: IP) == IPv6 (read "2001:db8:00:00:00:00:00:01" :: IPv6)
--   True
--   </pre>
data IP
IPv4 :: IPv4 -> IP
[ipv4] :: IP -> IPv4
IPv6 :: IPv6 -> IP
[ipv6] :: IP -> IPv6
newtype LedgerPeersConsensusInterface m
LedgerPeersConsensusInterface :: (SlotNo -> STM m (Maybe [(PoolStake, NonEmpty RelayAccessPoint)])) -> LedgerPeersConsensusInterface m
[lpGetPeers] :: LedgerPeersConsensusInterface m -> SlotNo -> STM m (Maybe [(PoolStake, NonEmpty RelayAccessPoint)])

-- | A relay can have either an IP address and a port number or a domain
--   with a port number
data RelayAccessPoint
RelayAccessDomain :: !Domain -> !PortNumber -> RelayAccessPoint
RelayAccessAddress :: !IP -> !PortNumber -> RelayAccessPoint

-- | <a>RelayDomainAccessPoint</a> a bidirectional pattern which links
--   <a>RelayAccessDomain</a> and <a>DomainAccessPoint</a>.
pattern RelayDomainAccessPoint :: DomainAccessPoint -> RelayAccessPoint

-- | The relative stake of a stakepool in relation to the total amount
--   staked. A value in the [0, 1] range.
newtype PoolStake
PoolStake :: Rational -> PoolStake
[unPoolStake] :: PoolStake -> Rational

-- | The accumulated relative stake of a stake pool, like PoolStake but it
--   also includes the relative stake of all preceding pools. A value in
--   the range [0, 1].
newtype AccPoolStake
AccPoolStake :: Rational -> AccPoolStake
[unAccPoolStake] :: AccPoolStake -> Rational

-- | Trace LedgerPeers events.
data TraceLedgerPeers

-- | Trace for a peer picked with accumulated and relative stake of its
--   pool.
PickedPeer :: RelayAccessPoint -> AccPoolStake -> PoolStake -> TraceLedgerPeers

-- | Trace for the number of peers we wanted to pick and the list of peers
--   picked.
PickedPeers :: NumberOfPeers -> [RelayAccessPoint] -> TraceLedgerPeers

-- | Trace for fetching a new list of peers from the ledger. Int is the
--   number of peers returned.
FetchingNewLedgerState :: Int -> TraceLedgerPeers

-- | Trace for when getting peers from the ledger is disabled, that is
--   DontUseLedger.
DisabledLedgerPeers :: TraceLedgerPeers

-- | Trace UseLedgerAfter value
TraceUseLedgerAfter :: UseLedgerAfter -> TraceLedgerPeers
WaitingOnRequest :: TraceLedgerPeers
RequestForPeers :: NumberOfPeers -> TraceLedgerPeers
ReusingLedgerState :: Int -> DiffTime -> TraceLedgerPeers
FallingBackToBootstrapPeers :: TraceLedgerPeers
newtype NumberOfPeers
NumberOfPeers :: Word16 -> NumberOfPeers

-- | Convert a list of pools with stake to a Map keyed on the accumulated
--   stake. Consensus provides a list of pairs of relative stake and
--   corresponding relays for all usable registered pools. By creating a
--   Map keyed on the <a>AccPoolStake</a> that is the sum of the pool's
--   relative stake and the stake of all preceding pools we can support
--   weighted random selection in O(log n) time by taking advantage of
--   Map.lookupGE (returns the smallest key greater or equal to the
--   provided value).
accPoolStake :: [(PoolStake, NonEmpty RelayAccessPoint)] -> Map AccPoolStake (PoolStake, NonEmpty RelayAccessPoint)

-- | For a LederPeers worker thread and submit request and receive
--   responses.
withLedgerPeers :: forall peerAddr m a. (MonadAsync m, MonadTime m, Ord peerAddr) => StdGen -> (IP -> PortNumber -> peerAddr) -> Tracer m TraceLedgerPeers -> STM m UseLedgerAfter -> LedgerPeersConsensusInterface m -> ([DomainAccessPoint] -> m (Map DomainAccessPoint (Set peerAddr))) -> ((NumberOfPeers -> m (Maybe (Set peerAddr, DiffTime))) -> Async m Void -> m a) -> m a

-- | Only use the ledger after the given slot number.
data UseLedgerAfter
DontUseLedger :: UseLedgerAfter
UseLedgerAfter :: SlotNo -> UseLedgerAfter

-- | Port number. Use the <tt>Num</tt> instance (i.e. use a literal) to
--   create a <tt>PortNumber</tt> value.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   
--   &gt;&gt;&gt; show (12345 :: PortNumber)
--   "12345"
--   
--   &gt;&gt;&gt; 50000 &lt; (51000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 &lt; (52000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 + (10000 :: PortNumber)
--   60000
--   </pre>
data PortNumber
instance GHC.Show.Show Ouroboros.Network.PeerSelection.LedgerPeers.UseLedgerAfter
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.LedgerPeers.UseLedgerAfter
instance GHC.Show.Show Ouroboros.Network.PeerSelection.LedgerPeers.NumberOfPeers
instance Control.DeepSeq.NFData Ouroboros.Network.PeerSelection.LedgerPeers.PoolStake
instance GHC.Show.Show Ouroboros.Network.PeerSelection.LedgerPeers.PoolStake
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.LedgerPeers.PoolStake
instance GHC.Num.Num Ouroboros.Network.PeerSelection.LedgerPeers.PoolStake
instance GHC.Real.Fractional Ouroboros.Network.PeerSelection.LedgerPeers.PoolStake
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.LedgerPeers.PoolStake
instance GHC.Classes.Ord Ouroboros.Network.PeerSelection.LedgerPeers.AccPoolStake
instance GHC.Num.Num Ouroboros.Network.PeerSelection.LedgerPeers.AccPoolStake
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.LedgerPeers.AccPoolStake
instance GHC.Show.Show Ouroboros.Network.PeerSelection.LedgerPeers.TraceLedgerPeers

module Ouroboros.Network.PeerSelection.LocalRootPeers
data LocalRootPeers peeraddr
LocalRootPeers :: Map peeraddr PeerAdvertise -> [(Int, Set peeraddr)] -> LocalRootPeers peeraddr
invariant :: Ord peeraddr => LocalRootPeers peeraddr -> Bool
empty :: LocalRootPeers peeraddr
null :: LocalRootPeers peeraddr -> Bool
size :: LocalRootPeers peeraddr -> Int
member :: Ord peeraddr => peeraddr -> LocalRootPeers peeraddr -> Bool
target :: LocalRootPeers peeraddr -> Int

-- | The local root peers info has some invariants that are not directly
--   enforced in the types, and the config comes from an external source.
--   Of course it's good to validate that at source, but here we need to
--   not fail if we're given imperfect data.
--   
--   So what we do is bash it until it is valid. We don't need to be too
--   careful about how we do it, it's ok to be brutal. We should however
--   make sure we trace a warning about dodgy config.
fromGroups :: Ord peeraddr => [(Int, Map peeraddr PeerAdvertise)] -> LocalRootPeers peeraddr

-- | Inverse of <a>fromGroups</a>, for the subset of inputs to
--   <a>fromGroups</a> that satisfy the invariant.
toGroups :: Ord peeraddr => LocalRootPeers peeraddr -> [(Int, Map peeraddr PeerAdvertise)]
toGroupSets :: LocalRootPeers peeraddr -> [(Int, Set peeraddr)]
toMap :: LocalRootPeers peeraddr -> Map peeraddr PeerAdvertise
keysSet :: LocalRootPeers peeraddr -> Set peeraddr

-- | Limit the size of the root peers collection to fit within given
--   bounds.
--   
--   The governor needs to be able to do this to enforce its invariant
--   that:
--   
--   <pre>
--   LocalRootPeers.size localRootPeers &lt;= targetNumberOfKnownPeers
--   </pre>
--   
--   It needs to be able to <i>establish</i> that invariant given arbitrary
--   configuration for local root peers. It makes sense to do it this way
--   rather than just enforce that local root peers config fits the
--   invariant because the invariant depends on both the targets and the
--   local root peers config and these can both vary dynamically and
--   independently.
--   
--   It is unlikely in practice that there are so many local root peers
--   configured that it goes over this targets, so it's ok to resolve it
--   pretty arbitrarily. We just take the local roots in left to right
--   order up to the limit. So we have the property that
--   
--   <pre>
--   LocalRootPeers.size (LocalRootPeers.clampToLimit sz lrps)
--    == min sz (LocalRootPeers.size lrps)
--   </pre>
clampToLimit :: Ord peeraddr => Int -> LocalRootPeers peeraddr -> LocalRootPeers peeraddr
instance GHC.Classes.Eq peeraddr => GHC.Classes.Eq (Ouroboros.Network.PeerSelection.LocalRootPeers.LocalRootPeers peeraddr)
instance (GHC.Show.Show peeraddr, GHC.Classes.Ord peeraddr) => GHC.Show.Show (Ouroboros.Network.PeerSelection.LocalRootPeers.LocalRootPeers peeraddr)

module Ouroboros.Network.PeerSelection.Simple
withPeerSelectionActions :: forall peeraddr peerconn resolver exception m a. (MonadAsync m, MonadDelay m, MonadThrow m, Ord peeraddr, Exception exception, Eq (Async m Void)) => Tracer m (TraceLocalRootPeers peeraddr exception) -> Tracer m TracePublicRootPeers -> (IP -> PortNumber -> peeraddr) -> DNSActions resolver exception m -> STM m PeerSelectionTargets -> STM m [(Int, Map RelayAccessPoint PeerAdvertise)] -> STM m [RelayAccessPoint] -> PeerStateActions peeraddr peerconn m -> (NumberOfPeers -> m (Maybe (Set peeraddr, DiffTime))) -> (Maybe (Async m Void) -> PeerSelectionActions peeraddr peerconn m -> m a) -> m a

-- | Adjustable targets for the peer selection mechanism.
--   
--   These are used by the peer selection governor as targets. They are
--   used by the peer churn governor loop as knobs to adjust, to influence
--   the peer selection governor.
--   
--   The <i>known</i>, <i>established</i> and <i>active</i> peer targets
--   are targets both from below and from above: the governor will attempt
--   to grow or shrink the sets to hit these targets.
--   
--   Unlike the other targets, the <i>root</i> peer target is "one sided",
--   it is only a target from below. The governor does not try to shrink
--   the root set to hit it, it simply stops looking for more.
--   
--   There is also an implicit target that enough local root peers are
--   selected as active. This comes from the configuration for local roots,
--   and is not an independently adjustable target.
data PeerSelectionTargets
PeerSelectionTargets :: !Int -> !Int -> !Int -> !Int -> PeerSelectionTargets
[targetNumberOfRootPeers] :: PeerSelectionTargets -> !Int
[targetNumberOfKnownPeers] :: PeerSelectionTargets -> !Int
[targetNumberOfEstablishedPeers] :: PeerSelectionTargets -> !Int
[targetNumberOfActivePeers] :: PeerSelectionTargets -> !Int

-- | Should this peer be advertised to other peers asking for known peers?
--   For certain peers specified by configuration it would be an
--   appropriate policy to keep them private.
data PeerAdvertise
DoNotAdvertisePeer :: PeerAdvertise
DoAdvertisePeer :: PeerAdvertise

module Ouroboros.Network.Point
data WithOrigin t
Origin :: WithOrigin t
At :: !t -> WithOrigin t
data Block slot hash
Block :: !slot -> !hash -> Block slot hash
[blockPointSlot] :: Block slot hash -> !slot
[blockPointHash] :: Block slot hash -> !hash
origin :: WithOrigin t
at :: t -> WithOrigin t
block :: slot -> hash -> WithOrigin (Block slot hash)
fromWithOrigin :: t -> WithOrigin t -> t
withOrigin :: b -> (t -> b) -> WithOrigin t -> b
withOriginToMaybe :: WithOrigin t -> Maybe t
withOriginFromMaybe :: Maybe t -> WithOrigin t
instance (NoThunks.Class.NoThunks slot, NoThunks.Class.NoThunks hash) => NoThunks.Class.NoThunks (Ouroboros.Network.Point.Block slot hash)
instance GHC.Generics.Generic (Ouroboros.Network.Point.Block slot hash)
instance (GHC.Show.Show slot, GHC.Show.Show hash) => GHC.Show.Show (Ouroboros.Network.Point.Block slot hash)
instance (GHC.Classes.Ord slot, GHC.Classes.Ord hash) => GHC.Classes.Ord (Ouroboros.Network.Point.Block slot hash)
instance (GHC.Classes.Eq slot, GHC.Classes.Eq hash) => GHC.Classes.Eq (Ouroboros.Network.Point.Block slot hash)


-- | Abstract view over blocks
--   
--   The network layer does not make any concrete assumptions about what
--   blocks look like.
module Ouroboros.Network.Block

-- | The 0-based index for the Ourboros time slot.
newtype SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64

-- | The 0-based index of the block in the blockchain. BlockNo is &lt;=
--   SlotNo and is only equal at slot N if there is a block for every slot
--   where N &lt;= SlotNo.
newtype BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64

-- | Header hash
type family HeaderHash b :: Type

-- | Header fields we expect to be present in a block
--   
--   These fields are lazy because they are extracted from a block or block
--   header; this type is not intended for storage.
data HeaderFields b
HeaderFields :: SlotNo -> BlockNo -> HeaderHash b -> HeaderFields b
[headerFieldSlot] :: HeaderFields b -> SlotNo
[headerFieldBlockNo] :: HeaderFields b -> BlockNo

-- | NOTE: this field is last so that the derived <a>Eq</a> and <a>Ord</a>
--   instances first compare the slot and block numbers, which is cheaper
--   than comparing hashes.
[headerFieldHash] :: HeaderFields b -> HeaderHash b
castHeaderFields :: HeaderHash b ~ HeaderHash b' => HeaderFields b -> HeaderFields b'

-- | Abstract over the shape of blocks (or indeed just block headers)
class (StandardHash b, Typeable b) => HasHeader b
getHeaderFields :: HasHeader b => b -> HeaderFields b
blockNo :: HasHeader b => b -> BlockNo
blockSlot :: HasHeader b => b -> SlotNo
blockHash :: HasHeader b => b -> HeaderHash b

-- | Extension of <a>HasHeader</a> with some additional information
--   
--   Used in tests and assertions only.
class HasHeader b => HasFullHeader b
blockPrevHash :: HasFullHeader b => b -> ChainHash b
blockInvariant :: HasFullHeader b => b -> Bool

-- | <a>StandardHash</a> summarises the constraints we want header hashes
--   to have
--   
--   Without this class we would need to write
--   
--   <pre>
--   deriving instance Eq (HeaderHash block) =&gt; Eq (ChainHash block)`
--   </pre>
--   
--   That requires <tt>UndecidableInstances</tt>; not a problem by itself,
--   but it also means that we can then not use <tt>deriving Eq</tt>
--   anywhere else for datatypes that reference <tt>Hash</tt>, which is
--   very frustrating; see
--   
--   
--   <a>https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#inferred-context-for-deriving-clauses</a>
--   
--   Introducing the <a>StandardHash</a> class avoids this problem.
--   
--   Having these constraints directly as part of the <a>HasHeader</a>
--   class is possible but libraries that <i>use</i> the networking layer
--   may wish to be able to talk about <a>StandardHash</a> independently of
--   <a>HasHeader</a> since the latter may impose yet further constraints.
class (Eq (HeaderHash b), Ord (HeaderHash b), Show (HeaderHash b), Typeable (HeaderHash b), NoThunks (HeaderHash b)) => StandardHash b
data ChainHash b
GenesisHash :: ChainHash b
BlockHash :: !HeaderHash b -> ChainHash b
castHash :: Coercible (HeaderHash b) (HeaderHash b') => ChainHash b -> ChainHash b'

-- | A point on the chain is identified by its <tt>Slot</tt> and
--   <a>HeaderHash</a>.
--   
--   The <tt>Slot</tt> tells us where to look and the <a>HeaderHash</a>
--   either simply serves as a check, or in some contexts it disambiguates
--   blocks from different forks that were in the same slot.
--   
--   It's a newtype rather than a type synonym, because using a type
--   synonym would lead to ambiguity, since HeaderHash is a non-injective
--   type family.
newtype Point block
Point :: WithOrigin (Block SlotNo (HeaderHash block)) -> Point block
[getPoint] :: Point block -> WithOrigin (Block SlotNo (HeaderHash block))
pointSlot :: Point block -> WithOrigin SlotNo
pointHash :: Point block -> ChainHash block
castPoint :: Coercible (HeaderHash b) (HeaderHash b') => Point b -> Point b'
blockPoint :: HasHeader block => block -> Point block
pattern GenesisPoint :: Point block
pattern BlockPoint :: SlotNo -> HeaderHash block -> Point block
atSlot :: Point block -> SlotNo
withHash :: Point block -> HeaderHash block

-- | Used in chain-sync protocol to advertise the tip of the server's
--   chain.
data Tip b

-- | The tip is genesis
TipGenesis :: Tip b

-- | The tip is not genesis
Tip :: !SlotNo -> !HeaderHash b -> !BlockNo -> Tip b

-- | The equivalent of <a>castPoint</a> for <a>Tip</a>
castTip :: HeaderHash a ~ HeaderHash b => Tip a -> Tip b
getTipPoint :: Tip b -> Point b
getTipBlockNo :: Tip b -> WithOrigin BlockNo
getTipSlotNo :: Tip b -> WithOrigin SlotNo

-- | Get the block number associated with a <a>Tip</a>, or
--   <tt>genesisBlockNo</tt> otherwise
--   
--   TODO: This is <i>wrong</i>. There <i>is</i> no block number if we are
--   at genesis (<tt>genesisBlockNo</tt> is the block number of the first
--   block on the chain). Usage of this function should be phased out.

-- | <i>Deprecated: Use getTipBlockNo</i>
getLegacyTipBlockNo :: Tip b -> BlockNo
tipFromHeader :: HasHeader a => a -> Tip a

-- | Inverse of <a>toLegacyTip</a>
--   
--   TODO: This should be phased out, since it makes no sense to have a
--   <a>BlockNo</a> for the genesis point.

-- | <i>Deprecated: Use tipFromHeader instead</i>
legacyTip :: Point b -> BlockNo -> Tip b

-- | Translate to the format it was before (to maintain binary
--   compatibility)

-- | <i>Deprecated: Use getTipPoint and getTipBlockNo</i>
toLegacyTip :: Tip b -> (Point b, BlockNo)
encodeTip :: (HeaderHash blk -> Encoding) -> Tip blk -> Encoding
encodedTipSize :: (Proxy (HeaderHash blk) -> Size) -> Proxy (Tip blk) -> Size
decodeTip :: forall blk. (forall s. Decoder s (HeaderHash blk)) -> forall s. Decoder s (Tip blk)

-- | A representation of two actions to update a chain: add a block or roll
--   back to a previous point.
--   
--   The type parameter <tt>a</tt> is there to allow a <a>Functor</a>
--   instance. Typically, it will be instantiated with <tt>block</tt>
--   itself.
data ChainUpdate block a
AddBlock :: a -> ChainUpdate block a
RollBack :: Point block -> ChainUpdate block a

-- | The highest slot number seen.
data MaxSlotNo

-- | No block/header has been seen yet, so we don't have a highest slot
--   number.
NoMaxSlotNo :: MaxSlotNo

-- | The highest slot number seen.
MaxSlotNo :: !SlotNo -> MaxSlotNo
maxSlotNoFromMaybe :: Maybe SlotNo -> MaxSlotNo
maxSlotNoToMaybe :: MaxSlotNo -> Maybe SlotNo
maxSlotNoFromWithOrigin :: WithOrigin SlotNo -> MaxSlotNo
genesisPoint :: Point block
encodePoint :: (HeaderHash block -> Encoding) -> Point block -> Encoding
encodedPointSize :: (Proxy (HeaderHash block) -> Size) -> Proxy (Point block) -> Size
encodeChainHash :: (HeaderHash block -> Encoding) -> ChainHash block -> Encoding
decodePoint :: (forall s. Decoder s (HeaderHash block)) -> forall s. Decoder s (Point block)
decodeChainHash :: (forall s. Decoder s (HeaderHash block)) -> forall s. Decoder s (ChainHash block)

-- | An already serialised value
--   
--   When streaming blocks/header from disk to the network, there is often
--   no need to deserialise them, as we'll just end up serialising them
--   again when putting them on the wire.
newtype Serialised a
Serialised :: ByteString -> Serialised a
[unSerialised] :: Serialised a -> ByteString

-- | Wrap CBOR-in-CBOR
--   
--   This is primarily useful for the <i>decoder</i>; see
--   <a>unwrapCBORinCBOR</a>
wrapCBORinCBOR :: (a -> Encoding) -> a -> Encoding

-- | Unwrap CBOR-in-CBOR
--   
--   The CBOR-in-CBOR encoding gives us the <tt>ByteString</tt> we need in
--   order to to construct annotations.
unwrapCBORinCBOR :: (forall s. Decoder s (ByteString -> a)) -> forall s. Decoder s a

-- | Construct <a>Serialised</a> value from an unserialised value
mkSerialised :: (a -> Encoding) -> a -> Serialised a

-- | Decode a <a>Serialised</a> value
--   
--   Unlike a regular <a>Decoder</a>, which has an implicit input stream,
--   <a>fromSerialised</a> takes the <a>Serialised</a> value as an
--   argument.
fromSerialised :: (forall s. Decoder s (ByteString -> a)) -> Serialised a -> forall s. Decoder s a
instance GHC.Generics.Generic (Ouroboros.Network.Block.HeaderFields b)
instance GHC.Generics.Generic (Ouroboros.Network.Block.ChainHash b)
instance GHC.Generics.Generic (Ouroboros.Network.Block.Point block)
instance GHC.Generics.Generic (Ouroboros.Network.Block.Tip b)
instance Data.Traversable.Traversable (Ouroboros.Network.Block.ChainUpdate block)
instance Data.Foldable.Foldable (Ouroboros.Network.Block.ChainUpdate block)
instance GHC.Base.Functor (Ouroboros.Network.Block.ChainUpdate block)
instance (Ouroboros.Network.Block.StandardHash block, GHC.Show.Show a) => GHC.Show.Show (Ouroboros.Network.Block.ChainUpdate block a)
instance (Ouroboros.Network.Block.StandardHash block, GHC.Classes.Eq a) => GHC.Classes.Eq (Ouroboros.Network.Block.ChainUpdate block a)
instance NoThunks.Class.NoThunks Ouroboros.Network.Block.MaxSlotNo
instance GHC.Generics.Generic Ouroboros.Network.Block.MaxSlotNo
instance GHC.Show.Show Ouroboros.Network.Block.MaxSlotNo
instance GHC.Classes.Eq Ouroboros.Network.Block.MaxSlotNo
instance GHC.Classes.Eq (Ouroboros.Network.Block.Serialised a)
instance Ouroboros.Network.Block.StandardHash b => GHC.Show.Show (Ouroboros.Network.Block.HeaderFields b)
instance Ouroboros.Network.Block.StandardHash b => GHC.Classes.Eq (Ouroboros.Network.Block.HeaderFields b)
instance Ouroboros.Network.Block.StandardHash b => GHC.Classes.Ord (Ouroboros.Network.Block.HeaderFields b)
instance Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.HeaderHash b) => Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.HeaderFields b)
instance Ouroboros.Network.Block.StandardHash block => GHC.Classes.Eq (Ouroboros.Network.Block.ChainHash block)
instance Ouroboros.Network.Block.StandardHash block => GHC.Classes.Ord (Ouroboros.Network.Block.ChainHash block)
instance Ouroboros.Network.Block.StandardHash block => GHC.Show.Show (Ouroboros.Network.Block.ChainHash block)
instance Ouroboros.Network.Block.StandardHash block => GHC.Classes.Eq (Ouroboros.Network.Block.Point block)
instance Ouroboros.Network.Block.StandardHash block => GHC.Classes.Ord (Ouroboros.Network.Block.Point block)
instance Ouroboros.Network.Block.StandardHash block => GHC.Show.Show (Ouroboros.Network.Block.Point block)
instance Ouroboros.Network.Block.StandardHash block => NoThunks.Class.NoThunks (Ouroboros.Network.Block.Point block)
instance Ouroboros.Network.Block.StandardHash b => GHC.Classes.Eq (Ouroboros.Network.Block.Tip b)
instance Ouroboros.Network.Block.StandardHash b => GHC.Show.Show (Ouroboros.Network.Block.Tip b)
instance Ouroboros.Network.Block.StandardHash b => NoThunks.Class.NoThunks (Ouroboros.Network.Block.Tip b)
instance GHC.Show.Show (Ouroboros.Network.Block.Serialised a)
instance Ouroboros.Network.Util.ShowProxy.ShowProxy a => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Block.Serialised a)
instance Ouroboros.Network.Block.StandardHash block => Ouroboros.Network.Block.StandardHash (Ouroboros.Network.Block.Serialised block)
instance Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.Serialised a)
instance GHC.Classes.Ord Ouroboros.Network.Block.MaxSlotNo
instance GHC.Base.Semigroup Ouroboros.Network.Block.MaxSlotNo
instance GHC.Base.Monoid Ouroboros.Network.Block.MaxSlotNo
instance Ouroboros.Network.Util.ShowProxy.ShowProxy b => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Block.Tip b)
instance Ouroboros.Network.Util.ShowProxy.ShowProxy block => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Block.Point block)
instance Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.HeaderHash block) => Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.Point block)
instance (Ouroboros.Network.Block.StandardHash block, Data.Typeable.Internal.Typeable block) => NoThunks.Class.NoThunks (Ouroboros.Network.Block.ChainHash block)
instance Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.HeaderHash b) => Codec.Serialise.Class.Serialise (Ouroboros.Network.Block.ChainHash b)
instance (Ouroboros.Network.Block.StandardHash b, Data.Typeable.Internal.Typeable b) => Ouroboros.Network.Block.HasHeader (Ouroboros.Network.Block.HeaderFields b)
instance Ouroboros.Network.Block.StandardHash b => Ouroboros.Network.Block.StandardHash (Ouroboros.Network.Block.HeaderFields b)

module Ouroboros.Network.AnchoredFragment

-- | An <a>AnchoredFragment</a> is a fragment of a chain that is anchored
--   somewhere in that chain. The <a>Anchor</a> corresponds to the block
--   immediately before the first, leftmost block in the fragment. The
--   block corresponding to the anchor is not present in the fragment. The
--   anchor can be thought of as a left exclusive bound.
--   
--   For example, the following fragment is anchored at <tt>a</tt> and
--   contains <tt>b1</tt>, <tt>b2</tt>, and <tt>b3</tt>, which is the head
--   of the fragment.
--   
--   <pre>
--   a ] b1 &gt;: b2 &gt;: b3
--   </pre>
--   
--   The fact that it is an <i>exclusive</i> bound is particularly
--   convenient when dealing with Genesis. Genesis is the start of the
--   chain, but not an actual block, so we cannot use it an inclusive
--   bound. However, there <i>is</i> an <a>Anchor</a> that refers to
--   Genesis (<a>AnchorGenesis</a>), which can be used as the anchor,
--   acting as an exclusive bound.
--   
--   An <a>AnchoredFragment</a> anchored at Genesis can thus be converted
--   to a <a>Chain</a> (<tt>fromAnchoredFragment</tt>), containing all
--   blocks starting from Genesis.
--   
--   Without an anchor point, an empty fragment wouldn't give us much more
--   information: is it empty because the whole chain is empty? Or, did we
--   just get an empty fragment that was split off from some later part of
--   the chain?
type AnchoredFragment block = AnchoredSeq (WithOrigin SlotNo) (Anchor block) block

-- | Generalisation of a <tt>Sequence</tt> with elements of type <tt>b</tt>
--   with a custom measure <tt>v</tt> and an anchor <tt>a</tt>.
--   
--   This type is strict in the elements, but not strict in the spine.
--   
--   For example, an <a>AnchoredSeq</a> can represent a fragment of a chain
--   containing blocks that is anchored at a certain point. It can also
--   represent a history of ledger states with the anchor being the
--   "immutable" ledger state.
--   
--   NOTE: there might be multiple elements with the same measure, e.g.,
--   multiple blocks with the same <tt>WithOrigin SlotNo</tt>. That is why
--   functions operating on an <a>AnchoredSeq</a> often take a predicate in
--   addition to a measure. At most one element should satisfy that
--   predicate, e.g., the block must have a certain hash. The behaviour is
--   undefined when multiple elements satisfy the predicate.
data AnchoredSeq v a b

-- | &lt;math&gt;. Pattern for matching on or creating an empty
--   <a>AnchoredSeq</a>. An empty sequence has/needs an anchor.
pattern Empty :: Anchorable v a b => a -> AnchoredSeq v a b

-- | &lt;math&gt;. Add an element to the right of the anchored sequence.
pattern (:>) :: Anchorable v a b => AnchoredSeq v a b -> b -> AnchoredSeq v a b

-- | &lt;math&gt;. View the first, leftmost block of the anchored sequence.
--   
--   Note that the anchor shifts, i.e., the anchor of the second argument
--   will correspond to the first argument.
--   
--   This is only a view, not a constructor, as adding a block to the left
--   would change the anchor of the sequence, but we have no information
--   about the predecessor of the block we'd be prepending.
pattern (:<) :: Anchorable v a b => b -> AnchoredSeq v a b -> AnchoredSeq v a b
infixl 5 :>
infixl 5 :<
anchor :: AnchoredSeq v a b -> a

-- | Return the <a>Point</a> corresponding to the anchor.
anchorPoint :: AnchoredFragment block -> Point block

-- | Return the <tt>BlocKno</tt> corresponding to the anchor.
anchorBlockNo :: AnchoredFragment block -> WithOrigin BlockNo

-- | Anchor of an <a>AnchoredFragment</a>
data Anchor block

-- | The fragment is anchored at genesis
AnchorGenesis :: Anchor block

-- | The fragment is anchored after genesis
--   
--   We don't use the <a>Point</a> type directly as that has its <i>own</i>
--   use of <a>WithOrigin</a>, and we want to enforce here that we have a
--   block number if and only if the point is not <a>Origin</a>.
--   
--   Note that we don't use <a>HeaderFields</a> here because that is a view
--   of a header with lazy fields and thus unfit for long-term in-memory
--   storage.
--   
--   Moreover, we don't reuse the <a>Tip</a> type, because that type is
--   sent across the network, while this type is not. This means we can
--   freely change this type to suit our needs without worrying about
--   binary compatibility.
Anchor :: !SlotNo -> !HeaderHash block -> !BlockNo -> Anchor block

-- | Construct anchor from a block
--   
--   In other words, this would be the block immediately <i>before</i> the
--   other blocks in the fragment.
anchorFromBlock :: HasHeader block => block -> Anchor block

-- | Construct an anchor <i>from</i> a point
--   
--   In this case, we must also be given the <a>BlockNo</a>. This only
--   makes sense for points that aren't genesis.
anchorFromPoint :: Point block -> BlockNo -> Anchor block

-- | Compute which <a>Point</a> this anchor corresponds to
anchorToPoint :: Anchor block -> Point block

-- | Extract the <a>SlotNo</a> from the anchor
anchorToSlotNo :: Anchor block -> WithOrigin SlotNo

-- | Extract the <a>BlockNo</a> from the anchor
--   
--   NOTE: When the <a>Anchor</a> is <a>AnchorGenesis</a>, this returns
--   <a>Origin</a>. It does <i>not</i> return <tt>genesisBlockNo</tt>,
--   which is badly named, and is instead the block number of the first
--   block on the chain (i.e., <a>genesisPoint</a> and
--   <tt>genesisBlockNo</tt> don't go hand in hand!)
anchorToBlockNo :: Anchor block -> WithOrigin BlockNo

-- | Extract the hash from the anchor
--   
--   Returns <a>GenesisHash</a> if the anchor is <a>AnchorGenesis</a>.
anchorToHash :: Anchor block -> ChainHash block

-- | Does this anchor represent genesis (i.e., empty chain)?
anchorIsGenesis :: Anchor block -> Bool
anchorToHeaderFields :: Anchor block -> WithOrigin (HeaderFields block)

-- | Translate <a>Anchor</a> to <a>Tip</a>
--   
--   Right now this is in fact an isomorphism, but these two types are
--   logically independent.
anchorToTip :: HeaderHash a ~ HeaderHash b => Anchor a -> Tip b

-- | The equivalent of <a>castPoint</a> for <a>Anchor</a>
castAnchor :: HeaderHash a ~ HeaderHash b => Anchor a -> Anchor b

-- | &lt;math&gt;.
valid :: HasFullHeader block => AnchoredFragment block -> Bool

-- | &lt;math&gt;.
validExtension :: HasFullHeader block => AnchoredFragment block -> block -> Bool

-- | Abstract over the shape of blocks (or indeed just block headers)
class (StandardHash b, Typeable b) => HasHeader b
getHeaderFields :: HasHeader b => b -> HeaderFields b

-- | A point on the chain is identified by its <tt>Slot</tt> and
--   <a>HeaderHash</a>.
--   
--   The <tt>Slot</tt> tells us where to look and the <a>HeaderHash</a>
--   either simply serves as a check, or in some contexts it disambiguates
--   blocks from different forks that were in the same slot.
--   
--   It's a newtype rather than a type synonym, because using a type
--   synonym would lead to ambiguity, since HeaderHash is a non-injective
--   type family.
newtype Point block
Point :: WithOrigin (Block SlotNo (HeaderHash block)) -> Point block
[getPoint] :: Point block -> WithOrigin (Block SlotNo (HeaderHash block))
castPoint :: Coercible (HeaderHash b) (HeaderHash b') => Point b -> Point b'
blockPoint :: HasHeader block => block -> Point block

-- | &lt;math&gt;. When the fragment is empty, the anchor point is
--   returned.
headPoint :: HasHeader block => AnchoredFragment block -> Point block

-- | &lt;math&gt;. The anchor corresponding to the most recently added
--   element (i.e., the anchor that would be needed for a sequence starting
--   <i>after</i> this). When the anchored sequence is empty, the anchor is
--   returned.
headAnchor :: forall v a b. Anchorable v a b => AnchoredSeq v a b -> a

-- | &lt;math&gt;. When the fragment is empty, the slot of the anchor point
--   is returned, which may be origin (no slot).
headSlot :: HasHeader block => AnchoredFragment block -> WithOrigin SlotNo

-- | &lt;math&gt;. When the fragment is empty, the hash of the anchor point
--   is returned.
headHash :: HasHeader block => AnchoredFragment block -> ChainHash block

-- | &lt;math&gt;. When the fragment is empty, the block number of the
--   anchor point is returned.
headBlockNo :: HasHeader block => AnchoredFragment block -> WithOrigin BlockNo

-- | &lt;math&gt;. When the sequence is empty, return the anchor, otherwise
--   the most recently added element.
head :: Anchorable v a b => AnchoredSeq v a b -> Either a b

-- | &lt;math&gt;. When the sequence is empty, return the anchor, otherwise
--   the leftmost element.
last :: Anchorable v a b => AnchoredSeq v a b -> Either a b

-- | &lt;math&gt;. When the fragment is empty, the anchor point is
--   returned.
lastPoint :: HasHeader block => AnchoredFragment block -> Point block

-- | &lt;math&gt;. When the fragment is empty, the slot of the anchor point
--   is returned, which may be the origin and therefore have no slot.
lastSlot :: HasHeader block => AnchoredFragment block -> WithOrigin SlotNo

-- | &lt;math&gt;. Return the elements in the <a>AnchoredSeq</a> in
--   newest-to-oldest order.
toNewestFirst :: AnchoredSeq v a b -> [b]

-- | &lt;math&gt;. Return the elements in the <a>AnchoredSeq</a> in
--   oldest-to-newest order.
toOldestFirst :: AnchoredSeq v a b -> [b]

-- | &lt;math&gt;. Make an <a>AnchoredSeq</a> from a list of elements in
--   newest-to-oldest order. The last element in the list will be the one
--   after the given anchor.
fromNewestFirst :: Anchorable v a b => a -> [b] -> AnchoredSeq v a b

-- | &lt;math&gt;. Make an <a>AnchoredSeq</a> from a list of elements in
--   oldest-to-newest order. The first element in the list will be the one
--   after the given anchor.
fromOldestFirst :: Anchorable v a b => a -> [b] -> AnchoredSeq v a b

-- | &lt;math&gt;. Split the <a>AnchoredSeq</a> at a given position.
--   
--   POSTCONDITION: <tt>(before, after) = splitAt i s</tt>, then: *
--   <tt>anchor before == anchor s</tt> * <tt>headAnchor before == anchor
--   after</tt> * <tt>headAnchor after == headAnchor s</tt> * <tt>join
--   before after == Just s</tt>
splitAt :: Anchorable v a b => Int -> AnchoredSeq v a b -> (AnchoredSeq v a b, AnchoredSeq v a b)

-- | &lt;math&gt;. Drop the newest <tt>n</tt> elements from the
--   <a>AnchoredSeq</a>. The anchor does not change.
dropNewest :: Anchorable v a b => Int -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Take the oldest <tt>n</tt> elements from the
--   <a>AnchoredSeq</a>. The anchor does not change.
takeOldest :: Anchorable v a b => Int -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Drop the newest elements that satisfy the predicate,
--   keeping the remainder. The anchor does not change.
dropWhileNewest :: Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Take the oldest elements that satisfy the predicate. The
--   anchor does not change.
takeWhileOldest :: Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt;. Return the number of elements. The anchor is not
--   counted.
length :: Anchorable v a b => AnchoredSeq v a b -> Int

-- | &lt;math&gt;. The anchor is not counted.
null :: AnchoredSeq v a b -> Bool

-- | A representation of two actions to update a chain: add a block or roll
--   back to a previous point.
--   
--   The type parameter <tt>a</tt> is there to allow a <a>Functor</a>
--   instance. Typically, it will be instantiated with <tt>block</tt>
--   itself.
data ChainUpdate block a
AddBlock :: a -> ChainUpdate block a
RollBack :: Point block -> ChainUpdate block a

-- | &lt;math&gt;. Add a block to the right of the anchored fragment.
--   
--   Synonym for <a>:&gt;</a>.
addBlock :: HasHeader block => block -> AnchoredFragment block -> AnchoredFragment block

-- | &lt;math&gt;. If the <a>Point</a> is within the bounds of the
--   <a>AnchoredFragment</a> (see <a>withinFragmentBounds</a>), roll back
--   the anchored fragment such that its head is the given point. In case
--   the given point was the anchor point, the returned anchored fragment
--   will be empty.
--   
--   In other words, remove blocks from the end of the
--   <a>AnchoredFragment</a> until the given <a>Point</a> is the head. If
--   the given <a>Point</a> is not within the bounds of the
--   <a>AnchoredFragment</a>, return <a>Nothing</a>.
rollback :: HasHeader block => Point block -> AnchoredFragment block -> Maybe (AnchoredFragment block)
applyChainUpdate :: HasHeader block => ChainUpdate block block -> AnchoredFragment block -> Maybe (AnchoredFragment block)
applyChainUpdates :: HasHeader block => [ChainUpdate block block] -> AnchoredFragment block -> Maybe (AnchoredFragment block)

-- | &lt;math&gt;. Does the fragment contain a block with the given point?
--   The anchor point is ignored.
pointOnFragment :: HasHeader block => Point block -> AnchoredFragment block -> Bool

-- | &lt;math&gt;. Is the point within the fragment bounds? Either the
--   point is the anchor point, or it corresponds to a block "on" the
--   fragment.
withinFragmentBounds :: HasHeader block => Point block -> AnchoredFragment block -> Bool

-- | &lt;math&gt;. Find the first <a>Point</a> in the list of points that
--   is within the fragment bounds. Return <a>Nothing</a> if none of them
--   are.
findFirstPoint :: HasHeader block => [Point block] -> AnchoredFragment block -> Maybe (Point block)

-- | &lt;math&gt;. Find the block after the given point. If the given point
--   is the anchor point, then the first block is returned (if there is
--   one).
successorBlock :: HasHeader block => Point block -> AnchoredFragment block -> Maybe block

-- | &lt;math&gt;. Select a bunch of <a>Point</a>s based on offsets from
--   the head of the anchored fragment. This is used in the chain consumer
--   protocol as part of finding the intersection between a local and
--   remote chain.
--   
--   The list of offsets must be increasing monotonically.
--   
--   The typical pattern is to use a selection of offsets covering the last
--   K blocks, biased towards more recent blocks. For example:
--   
--   <pre>
--   selectPoints (0 : [ fib n | n &lt;- [1 .. 17] ])
--   </pre>
--   
--   Only for offsets within the bounds of the anchored fragment will there
--   be points in the returned list.
--   
--   <b>Note</b>: offset <tt>n</tt>, where <tt>n</tt> equals the length of
--   the anchored fragment, corresponds to the anchor point. When the
--   fragment is empty, offset 0 will thus correspond to the anchor point.
selectPoints :: forall block. HasHeader block => [Int] -> AnchoredFragment block -> [Point block]

-- | &lt;math&gt;. Check whether the first anchored sequence is a prefix of
--   the second. Comparisons are done based on the <a>Eq</a> instances.
--   
--   The two <a>AnchoredSeq</a>s must have the same anchor, otherwise the
--   first cannot be a prefix of the second.
isPrefixOf :: forall v a b. (Eq a, Eq b) => AnchoredSeq v a b -> AnchoredSeq v a b -> Bool

-- | &lt;math&gt;. Split the <a>AnchoredFragment</a> after the given
--   <a>Point</a>. Return <a>Nothing</a> if given <a>Point</a> is not
--   within the fragment bounds (<a>withinFragmentBounds</a>).
--   
--   The given <a>Point</a> may be the anchor point of the fragment, in
--   which case the empty fragment with the given anchor point and the
--   original fragment are returned.
--   
--   POSTCONDITION: when <tt>Just (before, after) = splitAfterPoint f
--   pt</tt>, then: * <tt>anchorPoint before == anchorPoint f</tt> *
--   <tt>headPoint before == pt</tt> * <tt>anchorPoint after == pt</tt> *
--   <tt>headPoint after == headPoint f</tt> * <tt>join before after ==
--   Just f</tt>
splitAfterPoint :: forall block1 block2. (HasHeader block1, HeaderHash block1 ~ HeaderHash block2) => AnchoredFragment block1 -> Point block2 -> Maybe (AnchoredFragment block1, AnchoredFragment block1)

-- | &lt;math&gt;. Split the <a>AnchoredFragment</a> before the given
--   <a>Point</a>. Return <a>Nothing</a> if given <a>Point</a> is not on
--   the fragment (<a>pointOnFragment</a>).
--   
--   This means that <a>Nothing</a> is returned if the given <a>Point</a>
--   is the anchor point of the fragment.
--   
--   POSTCONDITION: joining (<a>join</a>) the two fragments gives back the
--   original fragment.
--   
--   POSTCONDITION: the last block (oldest) on the second fragment
--   corresponds to the given point.
splitBeforePoint :: forall block1 block2. (HasHeader block1, HeaderHash block1 ~ HeaderHash block2) => AnchoredFragment block1 -> Point block2 -> Maybe (AnchoredFragment block1, AnchoredFragment block1)

-- | Select a slice of an anchored fragment between two points, inclusive.
--   
--   Both points must exist on the chain, in order, or the result is
--   <tt>Nothing</tt>.
sliceRange :: HasHeader block => AnchoredFragment block -> Point block -> Point block -> Maybe (AnchoredFragment block)

-- | &lt;math&gt;. Join two anchored fragments if the anchor of the second
--   fragment is the head (newest block) of the first fragment.
--   
--   If the first fragment is empty, it can be joined if its anchor is the
--   same as the second fragment's anchor.
--   
--   The returned fragment will have the same anchor as the first fragment.
join :: HasHeader block => AnchoredFragment block -> AnchoredFragment block -> Maybe (AnchoredFragment block)

-- | &lt;math&gt;. Look for the most recent intersection of two
--   <a>AnchoredFragment</a>s <tt>c1</tt> and <tt>c2</tt>.
--   
--   The fragments need not have the same anchor point.
--   
--   If they intersect, i.e., share a common <a>Point</a> (possibly the
--   anchor point), then return a tuple of:
--   
--   <ul>
--   <li><tt>p1</tt>: the prefix of the first fragment</li>
--   <li><tt>p2</tt>: the prefix of the second fragment</li>
--   <li><tt>s1</tt>: the suffix of the first fragment</li>
--   <li><tt>s2</tt>: the suffix of the second fragment</li>
--   </ul>
--   
--   <tt>p1</tt> and <tt>p2</tt> will have the same <i>head</i> (possibly
--   an anchor point), namely the intersection point <tt>i</tt>. The
--   original chain <tt>c1</tt> can be obtained by putting <tt>s1</tt>
--   after <tt>p1</tt>, similarly for <tt>c2</tt>: by putting <tt>s2</tt>
--   after <tt>p2</tt>:
--   
--   <pre>
--   Just c1 = <a>join</a> p1 s1
--   Just c2 = <a>join</a> p2 s2
--   </pre>
--   
--   Take for example the following two fragments that share blocks 4 and
--   5. The two fragments are fragments of the same chain, but don't
--   contain all blocks of the original chain. The anchor points of the
--   fragments are indicated with an asterisk (*). The <tt>-A</tt> and
--   <tt>-B</tt> suffixes denote that blocks are part of a fork of the
--   chain.
--   
--   <pre>
--       ┆ 1*┆
--       ├───┤
--       │ 2 │     ┆ 2*┆
--       ├───┤     ├───┤
--       │ 4 │     │ 4 │
--       ├───┤     ├───┤
--       │ 5 │     │ 5 │
--   ────┼───┼─────┼───┼───
--       │ 6A│     │ 6B│
--       └───┘     ├───┤
--                 │ 8B│
--                 └───┘
--         c1        c2
--   </pre>
--   
--   The intersection of <tt>c1</tt> and <tt>c2</tt> is block 5 (the last
--   <a>Point</a> the two fragments have in common) and we return the
--   following fragments:
--   
--   <pre>
--       ┆ 1*┆
--       ├───┤
--       │ 2 │     ┆ 2*┆
--       ├───┤     ├───┤
--       │ 4 │     │ 4 │
--       ├───┤     ├───┤
--       │ 5 │     │ 5 │      ┆ 5*┆     ┆ 5*┆
--   ────┴───┴─────┴───┴──────┼───┼─────┼───┼──
--                            │ 6A│     │ 6B│
--                            └───┘     ├───┤
--                                      │ 8B│
--                                      └───┘
--   Just (p1,       p2,        s1,       s2)
--   </pre>
--   
--   The intersection point will be the anchor point of fragments
--   <tt>s1</tt> and <tt>s2</tt>. Fragment <tt>p1</tt> will have the same
--   anchor as <tt>c1</tt> and <tt>p2</tt> will have the same anchor as
--   <tt>c2</tt>.
--   
--   Note that an empty fragment can still intersect another fragment, as
--   its anchor point can still intersect the other fragment. In that case
--   the respective prefix and suffix are both equal to original empty
--   fragment. Additionally, two empty fragments intersect if their anchor
--   points are equal, in which case all prefixes and suffixes are equal to
--   the empty fragment with the anchor point in question.
intersect :: forall block1 block2. (HasHeader block1, HasHeader block2, HeaderHash block1 ~ HeaderHash block2) => AnchoredFragment block1 -> AnchoredFragment block2 -> Maybe (AnchoredFragment block1, AnchoredFragment block2, AnchoredFragment block1, AnchoredFragment block2)

-- | &lt;math&gt;. Look for the most recent intersection point of two
--   <a>AnchoredFragment</a>s
--   
--   The fragments need not have the same anchor point.
--   
--   Reusing the example in the docstring of <a>intersect</a>: this
--   function will return the anchor point <tt>5*</tt>.
intersectionPoint :: (HasHeader block1, HasHeader block2, HeaderHash block1 ~ HeaderHash block2) => AnchoredFragment block1 -> AnchoredFragment block2 -> Maybe (Point block1)

-- | &lt;math&gt;. Maps over the chain's blocks. This is not allowed to
--   change the block <a>Point</a>s, or it would create an invalid chain.
--   The <a>anchorPoint</a> is not affected.
mapAnchoredFragment :: (HasHeader block2, HeaderHash block1 ~ HeaderHash block2) => (block1 -> block2) -> AnchoredFragment block1 -> AnchoredFragment block2

-- | Take the <tt>n</tt> newest elements from the anchored sequence.
--   
--   WARNING: this may change the anchor
--   
--   When the anchored sequence contains fewer than <tt>n</tt> elements,
--   the anchored sequence will be returned unmodified.
anchorNewest :: forall v a b. Anchorable v a b => Word64 -> AnchoredSeq v a b -> AnchoredSeq v a b

-- | &lt;math&gt; ). Variation on <a>filterWithStop</a> without a stop
--   condition.
filter :: forall v a b. Anchorable v a b => (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]

-- | &lt;math&gt; where <i>r</i> is the number of consecutive ranges of
--   elements to be included in the result.
--   
--   Filter out elements that don't match the predicate.
--   
--   As filtering removes elements the result is a sequence of disconnected
--   sequences. The sequences are in the original order and are of maximum
--   size.
--   
--   As soon as the stop condition is true, the filtering stops and the
--   remaining sequence (starting with the first element for which the stop
--   condition is true) is the final sequence in the returned list.
--   
--   The stop condition wins from the filtering predicate: if the stop
--   condition is true for an element, but the filter predicate not, then
--   the element still ends up in final sequence.
--   
--   For example, given the sequence containing <tt>[0: 1, 2, 3, 4, 5,
--   6]</tt> where the anchor is separated from the elements by <tt>:</tt>:
--   
--   <pre>
--   filter         odd        -&gt; [[0: 1], [2: 3], [4: 5]]
--   filterWithStop odd (&gt;= 4) -&gt; [[0: 1], [2: 3], [3: 4, 5, 6]]
--   </pre>
filterWithStop :: forall v a b. Anchorable v a b => (b -> Bool) -> (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]
prettyPrint :: String -> (Point block -> String) -> (block -> String) -> AnchoredFragment block -> String

-- | &lt;math&gt;. Specification of <a>pointOnFragment</a>.
--   
--   Use <a>pointOnFragment</a>, as it should be faster.
--   
--   This function is used to verify whether <a>pointOnFragment</a> behaves
--   as expected.
pointOnFragmentSpec :: HasHeader block => Point block -> AnchoredFragment block -> Bool

-- | &lt;math&gt;. Specification of <a>selectPoints</a>.
--   
--   Use <a>selectPoints</a>, as it should be faster.
--   
--   This function is used to verify whether <a>selectPoints</a> behaves as
--   expected.
selectPointsSpec :: HasHeader block => [Int] -> AnchoredFragment block -> [Point block]

-- | &lt;math&gt; ). Naive reference implementation of
--   <a>filterWithStop</a>.
--   
--   While the asymptotic complexity of this function is better than that
--   of <a>filterWithStop</a>, the allocation cost is high. This function
--   deconstructs and reconstructs the anchored sequence (until the stop
--   condition is reached), even when no elements are removed.
filterWithStopSpec :: forall v a b. Anchorable v a b => (b -> Bool) -> (b -> Bool) -> AnchoredSeq v a b -> [AnchoredSeq v a b]
instance GHC.Generics.Generic (Ouroboros.Network.AnchoredFragment.Anchor block)
instance Ouroboros.Network.Block.StandardHash block => GHC.Show.Show (Ouroboros.Network.AnchoredFragment.Anchor block)
instance Ouroboros.Network.Block.StandardHash block => GHC.Classes.Eq (Ouroboros.Network.AnchoredFragment.Anchor block)
instance Ouroboros.Network.Block.StandardHash block => NoThunks.Class.NoThunks (Ouroboros.Network.AnchoredFragment.Anchor block)
instance Ouroboros.Network.Block.HasHeader block => Ouroboros.Network.AnchoredSeq.Anchorable (Cardano.Slotting.Slot.WithOrigin Cardano.Slotting.Slot.SlotNo) (Ouroboros.Network.AnchoredFragment.Anchor block) block


-- | Reference implementation of a representation of a block chain
module Ouroboros.Network.MockChain.Chain
data Chain block
Genesis :: Chain block
(:>) :: Chain block -> block -> Chain block
infixl 5 :>
valid :: HasFullHeader block => Chain block -> Bool
validExtension :: (HasCallStack, HasFullHeader block) => Chain block -> block -> Bool
foldChain :: (a -> b -> a) -> a -> Chain b -> a

-- | Make a list from a <a>Chain</a>, in newest-to-oldest order.
chainToList :: Chain block -> [block]

-- | Abstract over the shape of blocks (or indeed just block headers)
class (StandardHash b, Typeable b) => HasHeader b
getHeaderFields :: HasHeader b => b -> HeaderFields b

-- | Header hash
type family HeaderHash b :: Type

-- | A point on the chain is identified by its <tt>Slot</tt> and
--   <a>HeaderHash</a>.
--   
--   The <tt>Slot</tt> tells us where to look and the <a>HeaderHash</a>
--   either simply serves as a check, or in some contexts it disambiguates
--   blocks from different forks that were in the same slot.
--   
--   It's a newtype rather than a type synonym, because using a type
--   synonym would lead to ambiguity, since HeaderHash is a non-injective
--   type family.
newtype Point block
Point :: WithOrigin (Block SlotNo (HeaderHash block)) -> Point block
[getPoint] :: Point block -> WithOrigin (Block SlotNo (HeaderHash block))
blockPoint :: HasHeader block => block -> Point block
genesis :: Chain b
headPoint :: HasHeader block => Chain block -> Point block
headSlot :: HasHeader block => Chain block -> WithOrigin SlotNo
headHash :: HasHeader block => Chain block -> ChainHash block
headTip :: HasHeader block => Chain block -> Tip block
headBlockNo :: HasHeader block => Chain block -> WithOrigin BlockNo
headAnchor :: HasHeader block => Chain block -> Anchor block
head :: Chain b -> Maybe b

-- | Produce the list of blocks, from most recent back to genesis
toNewestFirst :: Chain block -> [block]

-- | Produce the list of blocks, from genesis to the most recent
toOldestFirst :: Chain block -> [block]

-- | Make a chain from a list of blocks. The head of the list is the head
--   of the chain.
fromNewestFirst :: HasHeader block => [block] -> Chain block

-- | Construct chain from list of blocks from oldest to newest
fromOldestFirst :: HasHeader block => [block] -> Chain block
drop :: Int -> Chain block -> Chain block
length :: Chain block -> Int
null :: Chain block -> Bool

-- | A representation of two actions to update a chain: add a block or roll
--   back to a previous point.
--   
--   The type parameter <tt>a</tt> is there to allow a <a>Functor</a>
--   instance. Typically, it will be instantiated with <tt>block</tt>
--   itself.
data ChainUpdate block a
AddBlock :: a -> ChainUpdate block a
RollBack :: Point block -> ChainUpdate block a
addBlock :: HasHeader block => block -> Chain block -> Chain block
rollback :: HasHeader block => Point block -> Chain block -> Maybe (Chain block)
applyChainUpdate :: HasHeader block => ChainUpdate block block -> Chain block -> Maybe (Chain block)
applyChainUpdates :: HasHeader block => [ChainUpdate block block] -> Chain block -> Maybe (Chain block)
pointOnChain :: HasHeader block => Point block -> Chain block -> Bool

-- | Check whether the first point is after the second point on the chain.
--   Usually, this can simply be checked using the <a>SlotNo</a>s, but some
--   blocks may have the same <a>SlotNo</a>.
--   
--   When the first point equals the second point, the answer will be
--   <a>False</a>.
--   
--   PRECONDITION: both points are on the chain.
pointIsAfter :: HasHeader block => Point block -> Point block -> Chain block -> Bool
successorBlock :: HasHeader block => Point block -> Chain block -> Maybe block
selectChain :: HasHeader block => Chain block -> Chain block -> Chain block

-- | Select a bunch of <a>Point</a>s based on offsets from the head of the
--   chain. This is used in the chain consumer protocol as part of finding
--   the intersection between a local and remote chain.
--   
--   The typical pattern is to use a selection of offsets covering the last
--   K blocks, biased towards more recent blocks. For example:
--   
--   <pre>
--   selectPoints (0 : [ fib n | n &lt;- [1 .. 17] ])
--   </pre>
selectPoints :: HasHeader block => [Int] -> Chain block -> [Point block]
findBlock :: (block -> Bool) -> Chain block -> Maybe block
selectBlockRange :: HasHeader block => Chain block -> Point block -> Point block -> Maybe [block]
findFirstPoint :: HasHeader block => [Point block] -> Chain block -> Maybe (Point block)
intersectChains :: HasHeader block => Chain block -> Chain block -> Maybe (Point block)
isPrefixOf :: Eq block => Chain block -> Chain block -> Bool

-- | Convert an <tt>AnchoredFragment</tt> to a <a>Chain</a>.
--   
--   The anchor of the fragment must be <a>genesisPoint</a>, otherwise
--   <a>Nothing</a> is returned.
fromAnchoredFragment :: HasHeader block => AnchoredFragment block -> Maybe (Chain block)

-- | Convert a <a>Chain</a> to an <tt>AnchoredFragment</tt>.
--   
--   The anchor of the fragment will be <a>genesisPoint</a>.
toAnchoredFragment :: HasHeader block => Chain block -> AnchoredFragment block
prettyPrintChain :: String -> (block -> String) -> Chain block -> String
instance GHC.Base.Functor Ouroboros.Network.MockChain.Chain.Chain
instance GHC.Show.Show block => GHC.Show.Show (Ouroboros.Network.MockChain.Chain.Chain block)
instance GHC.Classes.Ord block => GHC.Classes.Ord (Ouroboros.Network.MockChain.Chain.Chain block)
instance GHC.Classes.Eq block => GHC.Classes.Eq (Ouroboros.Network.MockChain.Chain.Chain block)
instance Codec.Serialise.Class.Serialise block => Codec.Serialise.Class.Serialise (Ouroboros.Network.MockChain.Chain.Chain block)

module Ouroboros.Network.MockChain.ProducerState
data ChainProducerState block
ChainProducerState :: Chain block -> FollowerStates block -> FollowerId -> ChainProducerState block
[chainState] :: ChainProducerState block -> Chain block
[chainFollowers] :: ChainProducerState block -> FollowerStates block
[nextFollowerId] :: ChainProducerState block -> FollowerId

-- | Followers are represented here as a relation.
type FollowerStates block = Map FollowerId (FollowerState block)
type FollowerId = Int

-- | Producer keeps track of consumer chain. The only information for a
--   producer to know is * <tt><a>followerPoint</a></tt>: (some)
--   intersection point of consumer's chain and producer's chain; *
--   <tt><a>followerNext</a></tt>: information what to do on next
--   instruction: either roll forward from the intersection point or roll
--   back to it.
--   
--   The second piece of information is needed to distinguish the following
--   two cases:
--   
--   <ul>
--   <li>consumer chain is a subchain of the producer chain</li>
--   <li>it is a fork.</li>
--   </ul>
--   
--   Since consumer is following the producer chain, the producer has this
--   information at its end. If producer updates its chain to use another
--   fork it may happen that the follower pointer is not on the new chain.
--   In this case the producer will set <tt><tt>RollBackTo</tt></tt> and
--   find intersection of the two chains for <tt><a>followerPoint</a></tt>.
--   And upon consumer's request will replay with
--   <tt><tt>MsgRollBackward</tt> <a>followerPoint</a></tt>. After sending
--   this message, the producer assumes that the the consumer is following
--   the protocol (i.e. will rollback its chain) and will reset the
--   <tt><a>followerNext</a></tt> field to
--   <tt><a>FollowerForwardFrom</a></tt>. The second case: when the
--   <tt><a>followerNext</a></tt> is <tt><a>FollowerForwardFrom</a></tt>,
--   then when sending next instruction the producer will either:
--   
--   <ul>
--   <li>take the next block (or header) on its chain imediatelly folowing
--   the <tt><a>followerPoint</a></tt>, updtate
--   <tt><a>followerPoint</a></tt> to the point of the new value and send
--   <tt><tt>MsgRollForward</tt></tt> with the new block (or header).</li>
--   <li>if there is no block, which means that the consumer side and
--   producer side are synchornized, the producer will send
--   <tt><tt>MsgAwaitResponse</tt></tt> and will wait until its chain is
--   updated: either by a fork or by a new block.</li>
--   </ul>
--   
--   In this implementation a map from <tt><a>FollowerId</a></tt> to
--   <tt><a>FollowerState</a></tt> is shared between all producers running
--   on a single node; hence the unique identifier
--   <tt><a>FollowerId</a></tt> for each follower: this is an
--   implementation detail.
data FollowerState block
FollowerState :: Point block -> FollowerNext -> FollowerState block

-- | Where the chain of the consumer and producer intersect. If the
--   consumer is on the chain then this is the consumer's chain head, but
--   if the consumer's chain is off the producer's chain then this is the
--   point the consumer will need to rollback to.
[followerPoint] :: FollowerState block -> Point block

-- | Where the will go next, roll back to the follower point, or roll
--   forward from the follower point.
[followerNext] :: FollowerState block -> FollowerNext
data FollowerNext
FollowerBackTo :: FollowerNext
FollowerForwardFrom :: FollowerNext
invChainProducerState :: HasFullHeader block => ChainProducerState block -> Bool
invFollowerStates :: HasHeader block => Chain block -> FollowerStates block -> Bool

-- | Initialise <tt><a>ChainProducerState</a></tt> with a given
--   <tt><a>Chain</a></tt> and empty list of followers.
initChainProducerState :: Chain block -> ChainProducerState block

-- | Get the recorded state of a chain consumer. The <a>FollowerId</a> is
--   assumed to exist.
lookupFollower :: ChainProducerState block -> FollowerId -> FollowerState block

-- | Return <a>True</a> when a follower with the given <a>FollowerId</a>
--   exists.
followerExists :: FollowerId -> ChainProducerState block -> Bool

-- | Extract <tt><a>Chain</a></tt> from <tt><a>ChainProducerState</a></tt>.
producerChain :: ChainProducerState block -> Chain block
findFirstPoint :: HasHeader block => [Point block] -> ChainProducerState block -> Maybe (Point block)

-- | Add a new follower with the given intersection point and return the
--   new <a>FollowerId</a>.
initFollower :: HasHeader block => Point block -> ChainProducerState block -> (ChainProducerState block, FollowerId)

-- | Delete an existing follower. The <a>FollowerId</a> is assumed to
--   exist.
deleteFollower :: FollowerId -> ChainProducerState block -> ChainProducerState block

-- | Change the intersection point of a follower. This also puts it into
--   the <a>FollowerBackTo</a> state.
updateFollower :: HasHeader block => FollowerId -> Point block -> ChainProducerState block -> ChainProducerState block

-- | Switch chains and update followers; if a follower point falls out of
--   the chain, replace it with the intersection of both chains and put it
--   in the <a>FollowerBackTo</a> state, otherwise preserve follower state.
switchFork :: HasHeader block => Chain block -> ChainProducerState block -> ChainProducerState block

-- | What a follower needs to do next. Should they move on to the next
--   block or do they need to roll back to a previous point on their chain.
--   It also updates the producer's state assuming that the follower
--   follows its instruction.
followerInstruction :: HasHeader block => FollowerId -> ChainProducerState block -> Maybe (ChainUpdate block block, ChainProducerState block)

-- | Add a block to the chain. It does not require any follower's state
--   changes.
addBlock :: HasHeader block => block -> ChainProducerState block -> ChainProducerState block

-- | Rollback producer chain. It requires to update follower states, since
--   some <tt><a>followerPoint</a></tt>s may not be on the new chain; in
--   this case find intersection of the two chains and set
--   <tt><a>followerNext</a></tt> to <tt><a>FollowerBackTo</a></tt>.
rollback :: (HasHeader block, HeaderHash block ~ HeaderHash block') => Point block' -> ChainProducerState block -> Maybe (ChainProducerState block)

-- | Convenient function which combines both <tt><a>addBlock</a></tt> and
--   <tt><a>rollback</a></tt>.
applyChainUpdate :: (HasHeader block, HeaderHash block ~ HeaderHash block') => ChainUpdate block' block -> ChainProducerState block -> Maybe (ChainProducerState block)

-- | Apply a list of <tt><a>ChainUpdate</a></tt>s.
applyChainUpdates :: (HasHeader block, HeaderHash block ~ HeaderHash block') => [ChainUpdate block' block] -> ChainProducerState block -> Maybe (ChainProducerState block)
instance GHC.Show.Show Ouroboros.Network.MockChain.ProducerState.FollowerNext
instance GHC.Classes.Eq Ouroboros.Network.MockChain.ProducerState.FollowerNext
instance Ouroboros.Network.Block.StandardHash block => GHC.Show.Show (Ouroboros.Network.MockChain.ProducerState.FollowerState block)
instance Ouroboros.Network.Block.StandardHash block => GHC.Classes.Eq (Ouroboros.Network.MockChain.ProducerState.FollowerState block)
instance (Ouroboros.Network.Block.StandardHash block, GHC.Show.Show block) => GHC.Show.Show (Ouroboros.Network.MockChain.ProducerState.ChainProducerState block)
instance (Ouroboros.Network.Block.StandardHash block, GHC.Classes.Eq block) => GHC.Classes.Eq (Ouroboros.Network.MockChain.ProducerState.ChainProducerState block)

module Ouroboros.Network.Protocol.BlockFetch.Type

-- | Range of blocks, defined by a lower and upper point, inclusive.
data ChainRange point
ChainRange :: !point -> !point -> ChainRange point
data BlockFetch block point
[BFIdle] :: BlockFetch block point
[BFBusy] :: BlockFetch block point
[BFStreaming] :: BlockFetch block point
[BFDone] :: BlockFetch block point
instance GHC.Classes.Ord point => GHC.Classes.Ord (Ouroboros.Network.Protocol.BlockFetch.Type.ChainRange point)
instance GHC.Classes.Eq point => GHC.Classes.Eq (Ouroboros.Network.Protocol.BlockFetch.Type.ChainRange point)
instance GHC.Show.Show point => GHC.Show.Show (Ouroboros.Network.Protocol.BlockFetch.Type.ChainRange point)
instance forall k1 k2 (block :: k1) (point :: k2). Ouroboros.Network.Util.ShowProxy.ShowProxy block => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point)
instance forall k1 k2 (block :: k1) (point :: k2). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point)
instance forall block point (from :: Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point) (to :: Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point). (GHC.Show.Show block, GHC.Show.Show point) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point) from to)
instance forall k1 k2 (block :: k1) (point :: k2) (st :: Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k1 k2 (block :: k1) (point :: k2) (st :: Ouroboros.Network.Protocol.BlockFetch.Type.BlockFetch block point). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)

module Ouroboros.Network.Protocol.BlockFetch.Server
data BlockFetchServer block point m a
[BlockFetchServer] :: (ChainRange point -> m (BlockFetchBlockSender block point m a)) -> a -> BlockFetchServer block point m a

-- | Send batches of blocks, when a batch is sent loop using
--   <tt><a>BlockFetchServer</a></tt>.
data BlockFetchBlockSender block point m a

-- | Initiate a batch of blocks.
[SendMsgStartBatch] :: m (BlockFetchSendBlocks block point m a) -> BlockFetchBlockSender block point m a
[SendMsgNoBlocks] :: m (BlockFetchServer block point m a) -> BlockFetchBlockSender block point m a

-- | Stream batch of blocks
data BlockFetchSendBlocks block point m a

-- | Send a single block and recurse.
[SendMsgBlock] :: block -> m (BlockFetchSendBlocks block point m a) -> BlockFetchSendBlocks block point m a

-- | End of the stream of block bodies.
[SendMsgBatchDone] :: m (BlockFetchServer block point m a) -> BlockFetchSendBlocks block point m a
blockFetchServerPeer :: forall block point m a. Functor m => BlockFetchServer block point m a -> Peer (BlockFetch block point) AsServer BFIdle m a

module Ouroboros.Network.Protocol.BlockFetch.Codec

-- | Codec for chain sync that encodes/decodes blocks
--   
--   NOTE: See <tt>wrapCBORinCBOR</tt> and <tt>unwrapCBORinCBOR</tt> if you
--   want to use this with a block type that has annotations.
codecBlockFetch :: forall block point m. MonadST m => (block -> Encoding) -> (forall s. Decoder s block) -> (point -> Encoding) -> (forall s. Decoder s point) -> Codec (BlockFetch block point) DeserialiseFailure m ByteString
codecBlockFetchId :: forall block point m. Monad m => Codec (BlockFetch block point) CodecFailure m (AnyMessage (BlockFetch block point))

-- | Byte Limit.
byteLimitsBlockFetch :: forall bytes block point. (bytes -> Word) -> ProtocolSizeLimits (BlockFetch block point) bytes

-- | Time Limits
--   
--   <a>TokIdle</a> No timeout <a>TokBusy</a> <a>longWait</a> timeout
--   <a>TokStreaming</a> <a>longWait</a> timeout
timeLimitsBlockFetch :: forall block point. ProtocolTimeLimits (BlockFetch block point)

module Ouroboros.Network.Protocol.BlockFetch.Client

-- | Block fetch client type for requesting ranges of blocks and handling
--   responses.
newtype BlockFetchClient block point m a
BlockFetchClient :: m (BlockFetchRequest block point m a) -> BlockFetchClient block point m a
[runBlockFetchClient] :: BlockFetchClient block point m a -> m (BlockFetchRequest block point m a)
data BlockFetchRequest block point m a

-- | Request a chain range, supply handler for incoming blocks and a
--   continuation.
[SendMsgRequestRange] :: ChainRange point -> BlockFetchResponse block m a -> BlockFetchClient block point m a -> BlockFetchRequest block point m a

-- | Client terminating the block-fetch protocol.
[SendMsgClientDone] :: a -> BlockFetchRequest block point m a
data BlockFetchResponse block m a
BlockFetchResponse :: m (BlockFetchReceiver block m) -> m () -> BlockFetchResponse block m a
[handleStartBatch] :: BlockFetchResponse block m a -> m (BlockFetchReceiver block m)
[handleNoBlocks] :: BlockFetchResponse block m a -> m ()

-- | Blocks are streamed and block receiver will handle each one when it
--   comes, it also needs to handle errors sent back from the server.
data BlockFetchReceiver block m
BlockFetchReceiver :: (block -> m (BlockFetchReceiver block m)) -> m () -> BlockFetchReceiver block m
[handleBlock] :: BlockFetchReceiver block m -> block -> m (BlockFetchReceiver block m)
[handleBatchDone] :: BlockFetchReceiver block m -> m ()
blockFetchClientPeer :: forall block point m a. Monad m => BlockFetchClient block point m a -> Peer (BlockFetch block point) AsClient BFIdle m a

-- | A BlockFetch client designed for running the protcol in a pipelined
--   way.
data BlockFetchClientPipelined block point m a

-- | A <a>BlockFetchSender</a>, but starting with zero outstanding
--   pipelined responses, and for any internal collect type <tt>c</tt>.
[BlockFetchClientPipelined] :: BlockFetchSender Z c block point m a -> BlockFetchClientPipelined block point m a

-- | A <a>BlockFetchSender</a> with <tt>n</tt> outstanding stream of block
--   bodies.
data BlockFetchSender n c block point m a

-- | Send a <a>MsgRequestRange</a> but do not wait for response. Supply a
--   monadic action which runs on each received block and which updates the
--   internal received value <tt>c</tt>. <tt>c</tt> could be a Monoid,
--   though it's more general this way.
[SendMsgRequestRangePipelined] :: ChainRange point -> c -> (Maybe block -> c -> m c) -> BlockFetchSender (S n) c block point m a -> BlockFetchSender n c block point m a

-- | Collect the result of a previous pipelined receive action
[CollectBlocksPipelined] :: Maybe (BlockFetchSender (S n) c block point m a) -> (c -> BlockFetchSender n c block point m a) -> BlockFetchSender (S n) c block point m a

-- | Termination of the block-fetch protocol.
[SendMsgDonePipelined] :: a -> BlockFetchSender Z c block point m a
blockFetchClientPeerPipelined :: forall block point m a. Monad m => BlockFetchClientPipelined block point m a -> PeerPipelined (BlockFetch block point) AsClient BFIdle m a
blockFetchClientPeerSender :: forall n block point c m a. Monad m => BlockFetchSender n c block point m a -> PeerSender (BlockFetch block point) AsClient BFIdle n c m a

module Ouroboros.Network.BlockFetch.ClientState

-- | The context that is passed into the block fetch protocol client when
--   it is started.
data FetchClientContext header block m
FetchClientContext :: Tracer m (TraceFetchClientState header) -> FetchClientPolicy header block m -> FetchClientStateVars m header -> FetchClientContext header block m
[fetchClientCtxTracer] :: FetchClientContext header block m -> Tracer m (TraceFetchClientState header)
[fetchClientCtxPolicy] :: FetchClientContext header block m -> FetchClientPolicy header block m
[fetchClientCtxStateVars] :: FetchClientContext header block m -> FetchClientStateVars m header

-- | The policy used by the fetch clients. It is set by the central block
--   fetch logic, and passed to them via the <tt>FetchClientRegistry</tt>.
data FetchClientPolicy header block m
FetchClientPolicy :: (header -> SizeInBytes) -> (header -> block -> Bool) -> (Point block -> block -> m ()) -> (FromConsensus block -> STM m UTCTime) -> FetchClientPolicy header block m
[blockFetchSize] :: FetchClientPolicy header block m -> header -> SizeInBytes
[blockMatchesHeader] :: FetchClientPolicy header block m -> header -> block -> Bool
[addFetchedBlock] :: FetchClientPolicy header block m -> Point block -> block -> m ()
[blockForgeUTCTime] :: FetchClientPolicy header block m -> FromConsensus block -> STM m UTCTime

-- | A set of variables shared between the block fetch logic thread and
--   each thread executing the client side of the block fetch protocol.
--   That is, these are the shared variables per peer. The
--   <tt>FetchClientRegistry</tt> contains the mapping of these for all
--   peers.
--   
--   The variables are used for communicating from the protocol thread to
--   the decision making thread the status of things with that peer. And in
--   the other direction one shared variable is for providing new fetch
--   requests.
data FetchClientStateVars m header
FetchClientStateVars :: StrictTVar m (PeerFetchStatus header) -> StrictTVar m (PeerFetchInFlight header) -> TFetchRequestVar m header -> FetchClientStateVars m header

-- | The current status of communication with the peer. It is written by
--   the protocol thread and monitored and read by the decision logic
--   thread. Changes in this state trigger re-evaluation of fetch
--   decisions.
[fetchClientStatusVar] :: FetchClientStateVars m header -> StrictTVar m (PeerFetchStatus header)

-- | The current number of requests in-flight and the amount of data
--   in-flight with the peer. It is written by the protocol thread and read
--   by the decision logic thread. This is used in fetch decisions but
--   changes here do not trigger re-evaluation of fetch decisions.
[fetchClientInFlightVar] :: FetchClientStateVars m header -> StrictTVar m (PeerFetchInFlight header)

-- | The shared variable used to communicate fetch requests to the thread
--   running the block fetch protocol. Fetch requests are posted by the
--   decision logic thread. The protocol thread accepts the requests and
--   acts on them, updating the in-flight stats. While this is a
--   <tt>TMVar</tt>, it is not used as a one-place queue: the requests can
--   be updated before being accepted.
[fetchClientRequestVar] :: FetchClientStateVars m header -> TFetchRequestVar m header
newFetchClientStateVars :: MonadSTM m => STM m (FetchClientStateVars m header)
readFetchClientState :: MonadSTM m => FetchClientStateVars m header -> STM m (PeerFetchStatus header, PeerFetchInFlight header, FetchClientStateVars m header)

-- | The status of the block fetch communication with a peer. This is
--   maintained by fetch protocol threads and used in the block fetch
--   decision making logic. Changes in this status trigger re-evaluation of
--   fetch decisions.
data PeerFetchStatus header

-- | Communication with the peer has failed. This is a temporary status
--   that may occur during the process of shutting down the thread that
--   runs the block fetch protocol. The peer will promptly be removed from
--   the peer registry and so will not be considered at all.
PeerFetchStatusShutdown :: PeerFetchStatus header

-- | The peer is in a potentially-temporary state in which it has not
--   responded to us within a certain expected time limit. This is not a
--   hard protocol timeout where the whole connection will be abandoned, it
--   is simply a reply that has taken longer than expected. This status is
--   used to trigger re-evaluating which peer to ask for blocks from, so
--   that we can swiftly ask other peers for blocks if one unexpectedly
--   responds too slowly
--   
--   Peers in this state may later return to normal states if communication
--   resumes, or they may eventually hit a hard timeout and fail.
PeerFetchStatusAberrant :: PeerFetchStatus header

-- | Communication with the peer is in a normal state, and the peer is
--   considered too busy to accept new requests. Changing from this state
--   to the ready state is used to trigger re-evaluating fetch decisions
--   and may eventually result in new fetch requests. This state is used as
--   part of a policy to batch new requests: instead of switching to the
--   ready state the moment there is tiny bit of capacity available, the
--   state is changed once the capacity reaches a certain threshold.
PeerFetchStatusBusy :: PeerFetchStatus header

-- | Communication with the peer is in a normal state, and the peer is
--   considered ready to accept new requests.
--   
--   The <a>Set</a> is the blocks in flight.
PeerFetchStatusReady :: Set (Point header) -> IsIdle -> PeerFetchStatus header

-- | Whether this mini protocol instance is in the <tt>Idle</tt> State
data IsIdle
IsIdle :: IsIdle
IsNotIdle :: IsIdle

-- | The number of requests in-flight and the amount of data in-flight with
--   a peer. This is maintained by fetch protocol threads and used in the
--   block fetch decision making logic.
data PeerFetchInFlight header
PeerFetchInFlight :: !Word -> !SizeInBytes -> Set (Point header) -> !MaxSlotNo -> PeerFetchInFlight header

-- | The number of block fetch requests that are currently in-flight. This
--   is the number of <i>requests</i> not the number of blocks. Each
--   request is for a range of blocks.
--   
--   We track this because there is a fixed maximum number of outstanding
--   requests that the protocol allows.
[peerFetchReqsInFlight] :: PeerFetchInFlight header -> !Word

-- | The sum of the byte count of blocks expected from all in-flight fetch
--   requests. This is a close approximation of the amount of data we
--   expect to receive, assuming no failures.
--   
--   We track this because we pipeline fetch requests and we want to keep
--   some but not too much data in flight at once.
[peerFetchBytesInFlight] :: PeerFetchInFlight header -> !SizeInBytes

-- | The points for the set of blocks that are currently in-flight. Note
--   that since requests are for ranges of blocks this does not correspond
--   to the number of requests in flight.
--   
--   We track this because as part of the decision for which blocks to
--   fetch from which peers we take into account what blocks are already
--   in-flight with peers.
[peerFetchBlocksInFlight] :: PeerFetchInFlight header -> Set (Point header)

-- | The maximum slot of a block that <i>has ever been</i> in flight for
--   this peer.
--   
--   We track this to more efficiently remove blocks that are already
--   in-flight from the candidate fragments: blocks with a slot number
--   higher than this one do not have to be filtered out.
[peerFetchMaxSlotNo] :: PeerFetchInFlight header -> !MaxSlotNo
initialPeerFetchInFlight :: PeerFetchInFlight header
newtype FetchRequest header
FetchRequest :: [AnchoredFragment header] -> FetchRequest header
[fetchRequestFragments] :: FetchRequest header -> [AnchoredFragment header]

-- | Add a new fetch request for a single peer. This is used by the fetch
--   decision logic thread to add new fetch requests.
--   
--   We have as a pre-condition that all requested blocks are new, i.e.
--   none should appear in the existing <a>peerFetchBlocksInFlight</a>.
--   This is a relatively easy precondition to satisfy since the decision
--   logic can filter its requests based on this in-flight blocks state,
--   and this operation is the only operation that grows the in-flight
--   blocks, and is only used by the fetch decision logic thread.
addNewFetchRequest :: (MonadSTM m, HasHeader header) => Tracer m (TraceFetchClientState header) -> (header -> SizeInBytes) -> FetchRequest header -> PeerGSV -> FetchClientStateVars m header -> m (PeerFetchStatus header)

-- | This is used by the fetch client threads.
acknowledgeFetchRequest :: MonadSTM m => Tracer m (TraceFetchClientState header) -> ControlMessageSTM m -> FetchClientStateVars m header -> m (Maybe (FetchRequest header, PeerGSV, PeerFetchInFlightLimits))
startedFetchBatch :: MonadSTM m => Tracer m (TraceFetchClientState header) -> PeerFetchInFlightLimits -> ChainRange (Point header) -> FetchClientStateVars m header -> m ()
completeBlockDownload :: (MonadSTM m, HasHeader header) => Tracer m (TraceFetchClientState header) -> (header -> SizeInBytes) -> PeerFetchInFlightLimits -> header -> NominalDiffTime -> FetchClientStateVars m header -> m ()
completeFetchBatch :: MonadSTM m => Tracer m (TraceFetchClientState header) -> PeerFetchInFlightLimits -> ChainRange (Point header) -> FetchClientStateVars m header -> m ()
rejectedFetchBatch :: (MonadSTM m, HasHeader header) => Tracer m (TraceFetchClientState header) -> (header -> SizeInBytes) -> PeerFetchInFlightLimits -> ChainRange (Point header) -> [header] -> FetchClientStateVars m header -> m ()

-- | Tracing types for the various events that change the state (i.e.
--   <a>FetchClientStateVars</a>) for a block fetch client.
--   
--   Note that while these are all state changes, the
--   <a>AddedFetchRequest</a> occurs in the decision thread while the other
--   state changes occur in the block fetch client threads.
data TraceFetchClientState header

-- | The block fetch decision thread has added a new fetch instruction
--   consisting of one or more individual request ranges.
AddedFetchRequest :: FetchRequest header -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | Mark the point when the fetch client picks up the request added by the
--   block fetch decision thread. Note that this event can happen fewer
--   times than the <a>AddedFetchRequest</a> due to fetch request merging.
AcknowledgedFetchRequest :: FetchRequest header -> TraceFetchClientState header

-- | Mark the point when fetch request for a fragment is actually sent over
--   the wire.
SendFetchRequest :: AnchoredFragment header -> TraceFetchClientState header

-- | Mark the start of receiving a streaming batch of blocks. This will be
--   followed by one or more <a>CompletedBlockFetch</a> and a final
--   <a>CompletedFetchBatch</a>.
StartedFetchBatch :: ChainRange (Point header) -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | Mark the completion of of receiving a single block within a streaming
--   batch of blocks.
CompletedBlockFetch :: Point header -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> NominalDiffTime -> SizeInBytes -> TraceFetchClientState header

-- | Mark the successful end of receiving a streaming batch of blocks
CompletedFetchBatch :: ChainRange (Point header) -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | If the other peer rejects our request then we have this event instead
--   of <a>StartedFetchBatch</a> and <a>CompletedFetchBatch</a>.
RejectedFetchBatch :: ChainRange (Point header) -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | The client is terminating. Log the number of outstanding requests.
ClientTerminating :: Int -> TraceFetchClientState header

-- | A peer label for use in <tt>Tracer</tt>s. This annotates tracer output
--   as being associated with a given peer identifier.
data TraceLabelPeer peerid a
TraceLabelPeer :: peerid -> a -> TraceLabelPeer peerid a

-- | Range of blocks, defined by a lower and upper point, inclusive.
data ChainRange point
ChainRange :: !point -> !point -> ChainRange point

-- | A new type used to emphasize the precondition of
--   <a>headerForgeUTCTime</a> and <a>blockForgeUTCTime</a> at each call
--   site.
--   
--   At time of writing, the <tt>a</tt> is either a header or a block. The
--   headers are literally from Consensus (ie provided by ChainSync).
--   Blocks, on the other hand, are indirectly from Consensus: they were
--   fetched only because we favored the corresponding header that
--   Consensus provided.
--   
--   NOTE: We define it here so that it can be used consistently throughout
--   the implementation; definiting it only in
--   <a>BlockFetchConsensusInterface</a> would be too late.
newtype FromConsensus a
FromConsensus :: a -> FromConsensus a
[unFromConsensus] :: FromConsensus a -> a

-- | Whether the block fetch peer is sending tentative blocks, which are
--   understood to possibly be invalid
data WhetherReceivingTentativeBlocks
ReceivingTentativeBlocks :: WhetherReceivingTentativeBlocks
NotReceivingTentativeBlocks :: WhetherReceivingTentativeBlocks
instance GHC.Show.Show Ouroboros.Network.BlockFetch.ClientState.IsIdle
instance GHC.Classes.Eq Ouroboros.Network.BlockFetch.ClientState.IsIdle
instance Ouroboros.Network.Block.StandardHash header => GHC.Show.Show (Ouroboros.Network.BlockFetch.ClientState.PeerFetchStatus header)
instance Ouroboros.Network.Block.StandardHash header => GHC.Classes.Eq (Ouroboros.Network.BlockFetch.ClientState.PeerFetchStatus header)
instance Ouroboros.Network.Block.StandardHash header => GHC.Show.Show (Ouroboros.Network.BlockFetch.ClientState.PeerFetchInFlight header)
instance Ouroboros.Network.Block.StandardHash header => GHC.Classes.Eq (Ouroboros.Network.BlockFetch.ClientState.PeerFetchInFlight header)
instance (Ouroboros.Network.Block.StandardHash header, GHC.Show.Show header) => GHC.Show.Show (Ouroboros.Network.BlockFetch.ClientState.FetchRequest header)
instance (Ouroboros.Network.Block.StandardHash header, GHC.Show.Show header) => GHC.Show.Show (Ouroboros.Network.BlockFetch.ClientState.TraceFetchClientState header)
instance GHC.Base.Functor Ouroboros.Network.BlockFetch.ClientState.FromConsensus
instance GHC.Base.Applicative Ouroboros.Network.BlockFetch.ClientState.FromConsensus
instance Ouroboros.Network.Block.HasHeader header => GHC.Base.Semigroup (Ouroboros.Network.BlockFetch.ClientState.FetchRequest header)

module Ouroboros.Network.BlockFetch.Decision
fetchDecisions :: (Ord peer, Hashable peer, HasHeader header, HeaderHash header ~ HeaderHash block) => FetchDecisionPolicy header -> FetchMode -> AnchoredFragment header -> (Point block -> Bool) -> MaxSlotNo -> [(AnchoredFragment header, PeerInfo header peer extra)] -> [(FetchDecision (FetchRequest header), PeerInfo header peer extra)]
data FetchDecisionPolicy header
FetchDecisionPolicy :: Word -> Word -> Word -> DiffTime -> Int -> (HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Bool) -> (HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Ordering) -> (header -> SizeInBytes) -> FetchDecisionPolicy header
[maxInFlightReqsPerPeer] :: FetchDecisionPolicy header -> Word
[maxConcurrencyBulkSync] :: FetchDecisionPolicy header -> Word
[maxConcurrencyDeadline] :: FetchDecisionPolicy header -> Word
[decisionLoopInterval] :: FetchDecisionPolicy header -> DiffTime
[peerSalt] :: FetchDecisionPolicy header -> Int
[plausibleCandidateChain] :: FetchDecisionPolicy header -> HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Bool
[compareCandidateChains] :: FetchDecisionPolicy header -> HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Ordering
[blockFetchSize] :: FetchDecisionPolicy header -> header -> SizeInBytes
data FetchMode

-- | Use this mode when we are catching up on the chain but are stil well
--   behind. In this mode the fetch logic will optimise for throughput
--   rather than latency.
FetchModeBulkSync :: FetchMode

-- | Use this mode for block-producing nodes that have a known deadline to
--   produce a block and need to get the best chain before that. In this
--   mode the fetch logic will optimise for picking the best chain within
--   the given deadline.
FetchModeDeadline :: FetchMode
type PeerInfo header peer extra = (PeerFetchStatus header, PeerFetchInFlight header, PeerGSV, peer, extra)

-- | Throughout the decision making process we accumulate reasons to
--   decline to fetch any blocks. This type is used to wrap intermediate
--   and final results.
type FetchDecision result = Either FetchDecline result

-- | All the various reasons we can decide not to fetch blocks from a peer.
data FetchDecline
FetchDeclineChainNotPlausible :: FetchDecline
FetchDeclineChainNoIntersection :: FetchDecline
FetchDeclineAlreadyFetched :: FetchDecline
FetchDeclineInFlightThisPeer :: FetchDecline
FetchDeclineInFlightOtherPeer :: FetchDecline
FetchDeclinePeerShutdown :: FetchDecline
FetchDeclinePeerSlow :: FetchDecline
FetchDeclineReqsInFlightLimit :: !Word -> FetchDecline
FetchDeclineBytesInFlightLimit :: !SizeInBytes -> !SizeInBytes -> !SizeInBytes -> FetchDecline
FetchDeclinePeerBusy :: !SizeInBytes -> !SizeInBytes -> !SizeInBytes -> FetchDecline
FetchDeclineConcurrencyLimit :: !FetchMode -> !Word -> FetchDecline

-- | Keep only those candidate chains that are preferred over the current
--   chain. Typically, this means that their length is longer than the
--   length of the current chain.
filterPlausibleCandidates :: (AnchoredFragment block -> AnchoredFragment header -> Bool) -> AnchoredFragment block -> [(AnchoredFragment header, peerinfo)] -> [(FetchDecision (AnchoredFragment header), peerinfo)]
selectForkSuffixes :: (HasHeader header, HasHeader block, HeaderHash header ~ HeaderHash block) => AnchoredFragment block -> [(FetchDecision (AnchoredFragment header), peerinfo)] -> [(FetchDecision (ChainSuffix header), peerinfo)]

-- | Find the fragments of the chain suffix that we still need to fetch,
--   these are the fragments covering blocks that have not yet been fetched
--   and are not currently in the process of being fetched from this peer.
--   
--   Typically this is a single fragment forming a suffix of the chain, but
--   in the general case we can get a bunch of discontiguous chain
--   fragments.
filterNotAlreadyFetched :: (HasHeader header, HeaderHash header ~ HeaderHash block) => (Point block -> Bool) -> MaxSlotNo -> [(FetchDecision (ChainSuffix header), peerinfo)] -> [(FetchDecision (CandidateFragments header), peerinfo)]
filterNotAlreadyInFlightWithPeer :: HasHeader header => [(FetchDecision (CandidateFragments header), PeerFetchInFlight header, peerinfo)] -> [(FetchDecision (CandidateFragments header), peerinfo)]
prioritisePeerChains :: forall extra header peer. (HasHeader header, Hashable peer, Ord peer) => FetchMode -> Int -> (AnchoredFragment header -> AnchoredFragment header -> Ordering) -> (header -> SizeInBytes) -> [(FetchDecision (CandidateFragments header), PeerFetchInFlight header, PeerGSV, peer, extra)] -> [(FetchDecision [AnchoredFragment header], extra)]

-- | A penultimate step of filtering, but this time across peers, rather
--   than individually for each peer. If we're following the parallel fetch
--   mode then we filter out blocks that are already in-flight with other
--   peers.
--   
--   Note that this does <i>not</i> cover blocks that are proposed to be
--   fetched in this round of decisions. That step is covered in
--   <a>fetchRequestDecisions</a>.
filterNotAlreadyInFlightWithOtherPeers :: HasHeader header => FetchMode -> [(FetchDecision [AnchoredFragment header], PeerFetchStatus header, PeerFetchInFlight header, peerinfo)] -> [(FetchDecision [AnchoredFragment header], peerinfo)]
fetchRequestDecisions :: forall extra header peer. (Hashable peer, HasHeader header, Ord peer) => FetchDecisionPolicy header -> FetchMode -> [(FetchDecision [AnchoredFragment header], PeerFetchStatus header, PeerFetchInFlight header, PeerGSV, peer, extra)] -> [(FetchDecision (FetchRequest header), extra)]
instance GHC.Show.Show Ouroboros.Network.BlockFetch.Decision.FetchMode
instance GHC.Classes.Eq Ouroboros.Network.BlockFetch.Decision.FetchMode
instance GHC.Show.Show Ouroboros.Network.BlockFetch.Decision.FetchDecline
instance GHC.Classes.Eq Ouroboros.Network.BlockFetch.Decision.FetchDecline
instance GHC.Show.Show Ouroboros.Network.BlockFetch.Decision.ProbabilityBand
instance GHC.Classes.Ord Ouroboros.Network.BlockFetch.Decision.ProbabilityBand
instance GHC.Classes.Eq Ouroboros.Network.BlockFetch.Decision.ProbabilityBand

module Ouroboros.Network.BlockFetch.State
fetchLogicIterations :: (HasHeader header, HasHeader block, HeaderHash header ~ HeaderHash block, MonadDelay m, MonadMonotonicTime m, MonadSTM m, Ord peer, Hashable peer) => Tracer m [TraceLabelPeer peer (FetchDecision [Point header])] -> Tracer m (TraceLabelPeer peer (TraceFetchClientState header)) -> FetchDecisionPolicy header -> FetchTriggerVariables peer header m -> FetchNonTriggerVariables peer header block m -> m Void
data FetchDecisionPolicy header
FetchDecisionPolicy :: Word -> Word -> Word -> DiffTime -> Int -> (HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Bool) -> (HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Ordering) -> (header -> SizeInBytes) -> FetchDecisionPolicy header
[maxInFlightReqsPerPeer] :: FetchDecisionPolicy header -> Word
[maxConcurrencyBulkSync] :: FetchDecisionPolicy header -> Word
[maxConcurrencyDeadline] :: FetchDecisionPolicy header -> Word
[decisionLoopInterval] :: FetchDecisionPolicy header -> DiffTime
[peerSalt] :: FetchDecisionPolicy header -> Int
[plausibleCandidateChain] :: FetchDecisionPolicy header -> HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Bool
[compareCandidateChains] :: FetchDecisionPolicy header -> HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Ordering
[blockFetchSize] :: FetchDecisionPolicy header -> header -> SizeInBytes

-- | STM actions to read various state variables that the fetch logic
--   depends upon. Any change in these variables is a trigger to
--   re-evaluate the decision on what blocks to fetch.
--   
--   Note that this is a "level trigger" not an "edge trigger": we do not
--   have to re-evaluate on every change, it is sufficient to re-evaluate
--   at some stage after one or more changes. This means it is ok to get
--   somewhat behind, and it is not necessary to determine exactly what
--   changed, just that there was some change.
data FetchTriggerVariables peer header m
FetchTriggerVariables :: STM m (AnchoredFragment header) -> STM m (Map peer (AnchoredFragment header)) -> STM m (Map peer (PeerFetchStatus header)) -> FetchTriggerVariables peer header m
[readStateCurrentChain] :: FetchTriggerVariables peer header m -> STM m (AnchoredFragment header)
[readStateCandidateChains] :: FetchTriggerVariables peer header m -> STM m (Map peer (AnchoredFragment header))
[readStatePeerStatus] :: FetchTriggerVariables peer header m -> STM m (Map peer (PeerFetchStatus header))

-- | STM actions to read various state variables that the fetch logic uses.
--   While the decisions do make use of the values of these variables, it
--   is not necessary to re-evaluate when these variables change.
data FetchNonTriggerVariables peer header block m
FetchNonTriggerVariables :: STM m (Point block -> Bool) -> STM m (Map peer (FetchClientStateVars m header)) -> STM m (Map peer PeerGSV) -> STM m FetchMode -> STM m MaxSlotNo -> FetchNonTriggerVariables peer header block m
[readStateFetchedBlocks] :: FetchNonTriggerVariables peer header block m -> STM m (Point block -> Bool)
[readStatePeerStateVars] :: FetchNonTriggerVariables peer header block m -> STM m (Map peer (FetchClientStateVars m header))
[readStatePeerGSVs] :: FetchNonTriggerVariables peer header block m -> STM m (Map peer PeerGSV)
[readStateFetchMode] :: FetchNonTriggerVariables peer header block m -> STM m FetchMode
[readStateFetchedMaxSlotNo] :: FetchNonTriggerVariables peer header block m -> STM m MaxSlotNo

-- | Throughout the decision making process we accumulate reasons to
--   decline to fetch any blocks. This type is used to wrap intermediate
--   and final results.
type FetchDecision result = Either FetchDecline result

-- | All the various reasons we can decide not to fetch blocks from a peer.
data FetchDecline
FetchDeclineChainNotPlausible :: FetchDecline
FetchDeclineChainNoIntersection :: FetchDecline
FetchDeclineAlreadyFetched :: FetchDecline
FetchDeclineInFlightThisPeer :: FetchDecline
FetchDeclineInFlightOtherPeer :: FetchDecline
FetchDeclinePeerShutdown :: FetchDecline
FetchDeclinePeerSlow :: FetchDecline
FetchDeclineReqsInFlightLimit :: !Word -> FetchDecline
FetchDeclineBytesInFlightLimit :: !SizeInBytes -> !SizeInBytes -> !SizeInBytes -> FetchDecline
FetchDeclinePeerBusy :: !SizeInBytes -> !SizeInBytes -> !SizeInBytes -> FetchDecline
FetchDeclineConcurrencyLimit :: !FetchMode -> !Word -> FetchDecline
data FetchMode

-- | Use this mode when we are catching up on the chain but are stil well
--   behind. In this mode the fetch logic will optimise for throughput
--   rather than latency.
FetchModeBulkSync :: FetchMode

-- | Use this mode for block-producing nodes that have a known deadline to
--   produce a block and need to get the best chain before that. In this
--   mode the fetch logic will optimise for picking the best chain within
--   the given deadline.
FetchModeDeadline :: FetchMode

-- | A peer label for use in <tt>Tracer</tt>s. This annotates tracer output
--   as being associated with a given peer identifier.
data TraceLabelPeer peerid a
TraceLabelPeer :: peerid -> a -> TraceLabelPeer peerid a

-- | Tracing types for the various events that change the state (i.e.
--   <a>FetchClientStateVars</a>) for a block fetch client.
--   
--   Note that while these are all state changes, the
--   <a>AddedFetchRequest</a> occurs in the decision thread while the other
--   state changes occur in the block fetch client threads.
data TraceFetchClientState header

-- | The block fetch decision thread has added a new fetch instruction
--   consisting of one or more individual request ranges.
AddedFetchRequest :: FetchRequest header -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | Mark the point when the fetch client picks up the request added by the
--   block fetch decision thread. Note that this event can happen fewer
--   times than the <a>AddedFetchRequest</a> due to fetch request merging.
AcknowledgedFetchRequest :: FetchRequest header -> TraceFetchClientState header

-- | Mark the point when fetch request for a fragment is actually sent over
--   the wire.
SendFetchRequest :: AnchoredFragment header -> TraceFetchClientState header

-- | Mark the start of receiving a streaming batch of blocks. This will be
--   followed by one or more <a>CompletedBlockFetch</a> and a final
--   <a>CompletedFetchBatch</a>.
StartedFetchBatch :: ChainRange (Point header) -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | Mark the completion of of receiving a single block within a streaming
--   batch of blocks.
CompletedBlockFetch :: Point header -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> NominalDiffTime -> SizeInBytes -> TraceFetchClientState header

-- | Mark the successful end of receiving a streaming batch of blocks
CompletedFetchBatch :: ChainRange (Point header) -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | If the other peer rejects our request then we have this event instead
--   of <a>StartedFetchBatch</a> and <a>CompletedFetchBatch</a>.
RejectedFetchBatch :: ChainRange (Point header) -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | The client is terminating. Log the number of outstanding requests.
ClientTerminating :: Int -> TraceFetchClientState header
instance (Ouroboros.Network.Block.StandardHash block, Ouroboros.Network.Block.StandardHash header, GHC.Classes.Eq peer) => GHC.Classes.Eq (Ouroboros.Network.BlockFetch.State.FetchStateFingerprint peer header block)

module Ouroboros.Network.BlockFetch.ClientRegistry

-- | A registry for the threads that are executing the client side of the
--   <tt>BlockFetch</tt> protocol to communicate with our peers.
--   
--   The registry contains the shared variables we use to communicate with
--   these threads, both to track their status and to provide instructions.
--   
--   The threads add/remove themselves to/from this registry when they
--   start up and shut down.
data FetchClientRegistry peer header block m
newFetchClientRegistry :: MonadSTM m => m (FetchClientRegistry peer header block m)

-- | This is needed to start a block fetch client. It provides the required
--   <a>FetchClientContext</a>. It registers and unregisters the fetch
--   client on start and end.
--   
--   It also manages synchronisation with the corresponding chain sync
--   client.
bracketFetchClient :: forall m a peer header block. (MonadThrow m, MonadSTM m, MonadFork m, MonadMask m, Ord peer) => FetchClientRegistry peer header block m -> NodeToNodeVersion -> peer -> (FetchClientContext header block m -> m a) -> m a
bracketKeepAliveClient :: forall m a peer header block. (MonadThrow m, MonadSTM m, MonadFork m, MonadMask m, Ord peer) => FetchClientRegistry peer header block m -> peer -> (StrictTVar m (Map peer PeerGSV) -> m a) -> m a

-- | The block fetch and chain sync clients for each peer need to
--   synchronise their startup and shutdown. This bracket operation
--   provides that synchronisation for the chain sync client.
--   
--   This must be used for the chain sync client <i>outside</i> of its own
--   state registration and deregistration.
bracketSyncWithFetchClient :: forall m a peer header block. (MonadThrow m, MonadSTM m, MonadFork m, Ord peer) => FetchClientRegistry peer header block m -> peer -> m a -> m a
setFetchClientContext :: MonadSTM m => FetchClientRegistry peer header block m -> Tracer m (TraceLabelPeer peer (TraceFetchClientState header)) -> (WhetherReceivingTentativeBlocks -> STM m (FetchClientPolicy header block m)) -> m ()

-- | The policy used by the fetch clients. It is set by the central block
--   fetch logic, and passed to them via the <tt>FetchClientRegistry</tt>.
data FetchClientPolicy header block m
FetchClientPolicy :: (header -> SizeInBytes) -> (header -> block -> Bool) -> (Point block -> block -> m ()) -> (FromConsensus block -> STM m UTCTime) -> FetchClientPolicy header block m
[blockFetchSize] :: FetchClientPolicy header block m -> header -> SizeInBytes
[blockMatchesHeader] :: FetchClientPolicy header block m -> header -> block -> Bool
[addFetchedBlock] :: FetchClientPolicy header block m -> Point block -> block -> m ()
[blockForgeUTCTime] :: FetchClientPolicy header block m -> FromConsensus block -> STM m UTCTime

-- | A read-only <a>STM</a> action to get the current
--   <a>PeerFetchStatus</a> for all fetch clients in the
--   <a>FetchClientRegistry</a>.
readFetchClientsStatus :: MonadSTM m => FetchClientRegistry peer header block m -> STM m (Map peer (PeerFetchStatus header))

-- | A read-only <a>STM</a> action to get the <a>FetchClientStateVars</a>
--   for all fetch clients in the <a>FetchClientRegistry</a>.
readFetchClientsStateVars :: MonadSTM m => FetchClientRegistry peer header block m -> STM m (Map peer (FetchClientStateVars m header))

-- | A read-only <a>STM</a> action to get the <a>PeerGSV</a>s for all fetch
--   clients in the <a>FetchClientRegistry</a>.
readPeerGSVs :: MonadSTM m => FetchClientRegistry peer header block m -> STM m (Map peer PeerGSV)


-- | Let's start with the big picture...
--   
--   <pre>
--   Key:  ┏━━━━━━━━━━━━┓  ╔═════════════╗  ┏━━━━━━━━━━━━━━┓   ╔════════════╗
--         ┃ STM-based  ┃  ║active thread║  ┃state instance┃┓  ║ one thread ║╗
--         ┃shared state┃  ║             ║  ┃   per peer   ┃┃  ║  per peer  ║║
--         ┗━━━━━━━━━━━━┛  ╚═════════════╝  ┗━━━━━━━━━━━━━━┛┃  ╚════════════╝║
--                                           ┗━━━━━━━━━━━━━━┛   ╚════════════╝
--   </pre>
--   
--   <pre>
--     ╔═════════════╗     ┏━━━━━━━━━━━━━┓
--     ║ Chain sync  ║╗    ┃   Ledger    ┃
--     ║  protocol   ║║◀───┨   state     ┃◀───────────╮
--     ║(client side)║║    ┃             ┃            │
--     ╚══════╤══════╝║    ┗━━━━━━━━━━━━━┛            │
--      ╚═════╪═══════╝                               │
--            ▼                                       │
--     ┏━━━━━━━━━━━━━┓     ┏━━━━━━━━━━━━━┓     ╔══════╧══════╗
--     ┃  Candidate  ┃     ┃   Set of    ┃     ║  Chain and  ║
--     ┃  chains     ┃     ┃  downloaded ┠────▶║   ledger    ║
--     ┃  (headers)  ┃     ┃   blocks    ┃     ║  validation ║
--     ┗━━━━━┯━━━━━━━┛     ┗━━━━━┯━━━━━━━┛     ╚══════╤══════╝
--           │                   │ ▲                  │
--           │ ╭─────────────────╯ │                  │
--   ░░░░░░░░▼░▼░░░░░░░░           │                  ▼
--   ░░╔═════════════╗░░           │           ┏━━━━━━━━━━━━━┓     ╔═════════════╗
--   ░░║    Block    ║░░           │           ┃   Current   ┃     ║ Block fetch ║╗
--   ░░╢    fetch    ║◀────────────┼───────────┨    chain    ┠────▶║ protocol    ║║
--   ░░║    logic    ║░░           │           ┃  (blocks)   ┃     ║(server side)║║
--   ░░╚═════════════╝░░           │           ┠─────────────┨     ╚═════════════╝║
--   ░░░░░░░░░▲░░░░░░░░░           │           ┃  Tentative  ┃      ╚═════════════╝
--   ░░░░░░░░░▼░░░░░░░░░░░░░░░░░░░░│░░░░░░░░   ┃    chain    ┠──╮
--   ░░┏━━━━━━━━━━━━━┓░░░░░╔═══════╧═════╗░░   ┃  (headers)  ┃  │  ╔═════════════╗
--   ░░┃ Block fetch ┃┓░░░░║ block fetch ║╗░   ┗━━━━━━━━━━━━━┛  │  ║ Chain sync  ║╗
--   ░░┃  state and  ┃┃◀──▶║  protocol   ║║░                    ╰─▶║ protocol    ║║
--   ░░┃  requests   ┃┃░░░░║(client side)║║░                       ║(server side)║║
--   ░░┗━━━━━━━━━━━━━┛┃░░░░╚═════════════╝║░                       ╚═════════════╝║
--   ░░░┗━━━━━━━━━━━━━┛░░░░░╚═════════════╝░                        ╚═════════════╝
--   ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li>Thread communication is via STM based state.</li>
--   <li>Outbound: threads update STM state.</li>
--   <li>Inbound: threads wait on STM state changing (using retry).</li>
--   <li>These are no queues: there is only the current state, not all
--   change events.</li>
--   </ul>
--   
--   We consider the block fetch logic and the policy for the block fetch
--   protocol client together as one unit of functionality. This is the
--   shaded area in the diagram.
--   
--   Looking at the diagram we see that these two threads interact with
--   each other and other threads via the following shared state
--   
--   TODO: table
--   
--   The block fetch requests state is private between the block fetch
--   logic and the block fetch protocol client, so it is implemented here.
--   
--   The other state is managed by the consensus layer and is considered
--   external here. So here we define interfaces for interacting with the
--   external state. These have to be provided when instantiating the block
--   fetch logic.
module Ouroboros.Network.BlockFetch

-- | Execute the block fetch logic. It monitors the current chain and
--   candidate chains. It decided which block bodies to fetch and manages
--   the process of fetching them, including making alternative decisions
--   based on timeouts and failures.
--   
--   This runs forever and should be shut down using mechanisms such as
--   async.
blockFetchLogic :: forall peer header block m. (HasHeader header, HasHeader block, HeaderHash header ~ HeaderHash block, MonadDelay m, MonadMonotonicTime m, MonadSTM m, Ord peer, Hashable peer) => Tracer m [TraceLabelPeer peer (FetchDecision [Point header])] -> Tracer m (TraceLabelPeer peer (TraceFetchClientState header)) -> BlockFetchConsensusInterface peer header block m -> FetchClientRegistry peer header block m -> BlockFetchConfiguration -> m Void

-- | Configuration for FetchDecisionPolicy. Should be determined by
--   external local node config.
data BlockFetchConfiguration
BlockFetchConfiguration :: !Word -> !Word -> !Word -> !DiffTime -> !Int -> BlockFetchConfiguration

-- | Maximum concurrent downloads during bulk syncing.
[bfcMaxConcurrencyBulkSync] :: BlockFetchConfiguration -> !Word

-- | Maximum concurrent downloads during deadline syncing.
[bfcMaxConcurrencyDeadline] :: BlockFetchConfiguration -> !Word

-- | Maximum requests in flight per each peer.
[bfcMaxRequestsInflight] :: BlockFetchConfiguration -> !Word

-- | Desired intervall between calls to fetchLogicIteration
[bfcDecisionLoopInterval] :: BlockFetchConfiguration -> !DiffTime

-- | Salt used when comparing peers
[bfcSalt] :: BlockFetchConfiguration -> !Int

-- | The consensus layer functionality that the block fetch logic requires.
--   
--   These are provided as input to the block fetch by the consensus layer.
data BlockFetchConsensusInterface peer header block m
BlockFetchConsensusInterface :: STM m (Map peer (AnchoredFragment header)) -> STM m (AnchoredFragment header) -> STM m FetchMode -> STM m (Point block -> Bool) -> (WhetherReceivingTentativeBlocks -> STM m (Point block -> block -> m ())) -> STM m MaxSlotNo -> (HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Bool) -> (HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Ordering) -> (header -> SizeInBytes) -> (header -> block -> Bool) -> (FromConsensus header -> STM m UTCTime) -> (FromConsensus block -> STM m UTCTime) -> BlockFetchConsensusInterface peer header block m

-- | Read the K-suffixes of the candidate chains.
--   
--   Assumptions: * They must be already validated. * They may contain
--   <i>fewer</i> than <tt>K</tt> blocks. * Their anchor does not have to
--   intersect with the current chain.
[readCandidateChains] :: BlockFetchConsensusInterface peer header block m -> STM m (Map peer (AnchoredFragment header))

-- | Read the K-suffix of the current chain.
--   
--   This must contain info on the last <tt>K</tt> blocks (unless we're
--   near the chain genesis of course).
[readCurrentChain] :: BlockFetchConsensusInterface peer header block m -> STM m (AnchoredFragment header)

-- | Read the current fetch mode that the block fetch logic should use.
--   
--   The fetch mode is a dynamic part of the block fetch policy. In
--   <a>FetchModeBulkSync</a> it follows a policy that optimises for
--   expected bandwidth over latency to fetch any particular block, whereas
--   in <a>FetchModeDeadline</a> it follows a policy optimises for the
--   latency to fetch blocks, at the expense of wasting bandwidth.
--   
--   This mode should be set so that when the node's current chain is near
--   to "now" it uses the deadline mode, and when it is far away it uses
--   the bulk sync mode.
[readFetchMode] :: BlockFetchConsensusInterface peer header block m -> STM m FetchMode

-- | Recent, only within last K
[readFetchedBlocks] :: BlockFetchConsensusInterface peer header block m -> STM m (Point block -> Bool)

-- | This method allocates an <tt>addFetchedBlock</tt> function per client.
--   That function and <a>readFetchedBlocks</a> are required to be linked.
--   Upon successful completion of <tt>addFetchedBlock</tt> it must be the
--   case that <a>readFetchedBlocks</a> reports the block.
[mkAddFetchedBlock] :: BlockFetchConsensusInterface peer header block m -> WhetherReceivingTentativeBlocks -> STM m (Point block -> block -> m ())

-- | The highest stored/downloaded slot number.
--   
--   This is used to optimise the filtering of fragments in the block fetch
--   logic: when removing already downloaded blocks from a fragment, the
--   filtering (with a linear cost) is stopped as soon as a block has a
--   slot number higher than this slot number, as it cannot have been
--   downloaded anyway.
[readFetchedMaxSlotNo] :: BlockFetchConsensusInterface peer header block m -> STM m MaxSlotNo

-- | Given the current chain, is the given chain plausible as a candidate
--   chain. Classically for Ouroboros this would simply check if the
--   candidate is strictly longer, but for Ouroboros with operational key
--   certificates there are also cases where we would consider a chain of
--   equal length to the current chain.
[plausibleCandidateChain] :: BlockFetchConsensusInterface peer header block m -> HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Bool

-- | Compare two candidate chains and return a preference ordering. This is
--   used as part of selecting which chains to prioritise for downloading
--   block bodies.
[compareCandidateChains] :: BlockFetchConsensusInterface peer header block m -> HasCallStack => AnchoredFragment header -> AnchoredFragment header -> Ordering

-- | Much of the logic for deciding which blocks to download from which
--   peer depends on making estimates based on recent performance metrics.
--   These estimates of course depend on the amount of data we will be
--   downloading.
[blockFetchSize] :: BlockFetchConsensusInterface peer header block m -> header -> SizeInBytes

-- | Given a block header, validate the supposed corresponding block body.
[blockMatchesHeader] :: BlockFetchConsensusInterface peer header block m -> header -> block -> Bool

-- | Calculate when a header's block was forged.
--   
--   PRECONDITION: This function will succeed and give a _correct_ result
--   when applied to headers obtained via this interface (ie via Consensus,
--   ie via <a>readCurrentChain</a> or <a>readCandidateChains</a>).
--   
--   WARNING: This function may fail or, worse, __give an incorrect result
--   (!!)__ if applied to headers obtained from sources outside of this
--   interface. The <a>FromConsensus</a> newtype wrapper is intended to
--   make it difficult to make that mistake, so please pay that syntactic
--   price and consider its meaning at each call to this function.
--   Relatedly, preserve that argument wrapper as much as possible when
--   deriving ancillary functions/interfaces from this function.
[headerForgeUTCTime] :: BlockFetchConsensusInterface peer header block m -> FromConsensus header -> STM m UTCTime

-- | Calculate when a block was forged.
--   
--   PRECONDITION: Same as <a>headerForgeUTCTime</a>.
--   
--   WARNING: Same as <a>headerForgeUTCTime</a>.
[blockForgeUTCTime] :: BlockFetchConsensusInterface peer header block m -> FromConsensus block -> STM m UTCTime

-- | Throughout the decision making process we accumulate reasons to
--   decline to fetch any blocks. This type is used to wrap intermediate
--   and final results.
type FetchDecision result = Either FetchDecline result

-- | Tracing types for the various events that change the state (i.e.
--   <a>FetchClientStateVars</a>) for a block fetch client.
--   
--   Note that while these are all state changes, the
--   <a>AddedFetchRequest</a> occurs in the decision thread while the other
--   state changes occur in the block fetch client threads.
data TraceFetchClientState header

-- | The block fetch decision thread has added a new fetch instruction
--   consisting of one or more individual request ranges.
AddedFetchRequest :: FetchRequest header -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | Mark the point when the fetch client picks up the request added by the
--   block fetch decision thread. Note that this event can happen fewer
--   times than the <a>AddedFetchRequest</a> due to fetch request merging.
AcknowledgedFetchRequest :: FetchRequest header -> TraceFetchClientState header

-- | Mark the point when fetch request for a fragment is actually sent over
--   the wire.
SendFetchRequest :: AnchoredFragment header -> TraceFetchClientState header

-- | Mark the start of receiving a streaming batch of blocks. This will be
--   followed by one or more <a>CompletedBlockFetch</a> and a final
--   <a>CompletedFetchBatch</a>.
StartedFetchBatch :: ChainRange (Point header) -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | Mark the completion of of receiving a single block within a streaming
--   batch of blocks.
CompletedBlockFetch :: Point header -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> NominalDiffTime -> SizeInBytes -> TraceFetchClientState header

-- | Mark the successful end of receiving a streaming batch of blocks
CompletedFetchBatch :: ChainRange (Point header) -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | If the other peer rejects our request then we have this event instead
--   of <a>StartedFetchBatch</a> and <a>CompletedFetchBatch</a>.
RejectedFetchBatch :: ChainRange (Point header) -> PeerFetchInFlight header -> PeerFetchInFlightLimits -> PeerFetchStatus header -> TraceFetchClientState header

-- | The client is terminating. Log the number of outstanding requests.
ClientTerminating :: Int -> TraceFetchClientState header

-- | A peer label for use in <tt>Tracer</tt>s. This annotates tracer output
--   as being associated with a given peer identifier.
data TraceLabelPeer peerid a
TraceLabelPeer :: peerid -> a -> TraceLabelPeer peerid a

-- | A registry for the threads that are executing the client side of the
--   <tt>BlockFetch</tt> protocol to communicate with our peers.
--   
--   The registry contains the shared variables we use to communicate with
--   these threads, both to track their status and to provide instructions.
--   
--   The threads add/remove themselves to/from this registry when they
--   start up and shut down.
data FetchClientRegistry peer header block m
newFetchClientRegistry :: MonadSTM m => m (FetchClientRegistry peer header block m)

-- | This is needed to start a block fetch client. It provides the required
--   <a>FetchClientContext</a>. It registers and unregisters the fetch
--   client on start and end.
--   
--   It also manages synchronisation with the corresponding chain sync
--   client.
bracketFetchClient :: forall m a peer header block. (MonadThrow m, MonadSTM m, MonadFork m, MonadMask m, Ord peer) => FetchClientRegistry peer header block m -> NodeToNodeVersion -> peer -> (FetchClientContext header block m -> m a) -> m a

-- | The block fetch and chain sync clients for each peer need to
--   synchronise their startup and shutdown. This bracket operation
--   provides that synchronisation for the chain sync client.
--   
--   This must be used for the chain sync client <i>outside</i> of its own
--   state registration and deregistration.
bracketSyncWithFetchClient :: forall m a peer header block. (MonadThrow m, MonadSTM m, MonadFork m, Ord peer) => FetchClientRegistry peer header block m -> peer -> m a -> m a
bracketKeepAliveClient :: forall m a peer header block. (MonadThrow m, MonadSTM m, MonadFork m, MonadMask m, Ord peer) => FetchClientRegistry peer header block m -> peer -> (StrictTVar m (Map peer PeerGSV) -> m a) -> m a
data FetchMode

-- | Use this mode when we are catching up on the chain but are stil well
--   behind. In this mode the fetch logic will optimise for throughput
--   rather than latency.
FetchModeBulkSync :: FetchMode

-- | Use this mode for block-producing nodes that have a known deadline to
--   produce a block and need to get the best chain before that. In this
--   mode the fetch logic will optimise for picking the best chain within
--   the given deadline.
FetchModeDeadline :: FetchMode

-- | A new type used to emphasize the precondition of
--   <a>headerForgeUTCTime</a> and <a>blockForgeUTCTime</a> at each call
--   site.
--   
--   At time of writing, the <tt>a</tt> is either a header or a block. The
--   headers are literally from Consensus (ie provided by ChainSync).
--   Blocks, on the other hand, are indirectly from Consensus: they were
--   fetched only because we favored the corresponding header that
--   Consensus provided.
--   
--   NOTE: We define it here so that it can be used consistently throughout
--   the implementation; definiting it only in
--   <a>BlockFetchConsensusInterface</a> would be too late.
newtype FromConsensus a
FromConsensus :: a -> FromConsensus a
[unFromConsensus] :: FromConsensus a -> a
type SizeInBytes = Word32

-- | Whether the block fetch peer is sending tentative blocks, which are
--   understood to possibly be invalid
data WhetherReceivingTentativeBlocks
ReceivingTentativeBlocks :: WhetherReceivingTentativeBlocks
NotReceivingTentativeBlocks :: WhetherReceivingTentativeBlocks

module Ouroboros.Network.BlockFetch.Client

-- | The implementation of the client side of block fetch protocol designed
--   to work in conjunction with our fetch logic.
blockFetchClient :: forall header block m. (MonadSTM m, MonadThrow m, MonadTime m, HasHeader header, HasHeader block, HeaderHash header ~ HeaderHash block) => NodeToNodeVersion -> ControlMessageSTM m -> FetchedMetricsTracer m -> FetchClientContext header block m -> PeerPipelined (BlockFetch block (Point block)) AsClient BFIdle m ()

-- | TODO: use a fetch client wrapper type rather than the raw
--   PeerPipelined, and eliminate this alias. It is only here to avoid
--   large types leaking into the consensus layer.
type BlockFetchClient header block m a = FetchClientContext header block m -> PeerPipelined (BlockFetch block (Point block)) AsClient BFIdle m a

-- | The context that is passed into the block fetch protocol client when
--   it is started.
data FetchClientContext header block m

-- | Tracing types for the various events that change the state (i.e.
--   <a>FetchClientStateVars</a>) for a block fetch client.
--   
--   Note that while these are all state changes, the
--   <a>AddedFetchRequest</a> occurs in the decision thread while the other
--   state changes occur in the block fetch client threads.
data TraceFetchClientState header
newtype FetchRequest header
FetchRequest :: [AnchoredFragment header] -> FetchRequest header
[fetchRequestFragments] :: FetchRequest header -> [AnchoredFragment header]

-- | A set of variables shared between the block fetch logic thread and
--   each thread executing the client side of the block fetch protocol.
--   That is, these are the shared variables per peer. The
--   <tt>FetchClientRegistry</tt> contains the mapping of these for all
--   peers.
--   
--   The variables are used for communicating from the protocol thread to
--   the decision making thread the status of things with that peer. And in
--   the other direction one shared variable is for providing new fetch
--   requests.
data FetchClientStateVars m header
data BlockFetchProtocolFailure
instance GHC.Show.Show Ouroboros.Network.BlockFetch.Client.BlockFetchProtocolFailure
instance GHC.Classes.Eq Ouroboros.Network.BlockFetch.Client.BlockFetchProtocolFailure
instance GHC.Exception.Type.Exception Ouroboros.Network.BlockFetch.Client.BlockFetchProtocolFailure

module Ouroboros.Network.Protocol.ChainSync.PipelineDecision

-- | Pipeline decision: we can do either one of these:
--   
--   <ul>
--   <li>non-pipelined request</li>
--   <li>pipeline a request</li>
--   <li>collect or pipeline, but only when there are pipelined
--   requests</li>
--   <li>collect, as above, only when there are pipelined requests</li>
--   </ul>
--   
--   There might be other useful pipelining scenarios: collect a given
--   number of requests (which also can be used to collect all outstanding
--   requests).
data PipelineDecision n
[Request] :: PipelineDecision Z
[Pipeline] :: PipelineDecision n
[CollectOrPipeline] :: PipelineDecision (S n)
[Collect] :: PipelineDecision (S n)

-- | The callback gets the following arguments:
--   
--   <ul>
--   <li>how many requests are not yet collected (in flight or already
--   queued)</li>
--   <li>block number of client's tip</li>
--   <li>block number of server's tip</li>
--   </ul>
--   
--   Client's tip block number and server's tip block number can only be
--   equal (from the client's perspective) when both the client's and the
--   server's tip headers agree. If they would not agree (server forked),
--   then the server sends <tt>MsgRollBackward</tt>, which rolls back one
--   block and causes the client's tip and the server's tip to differ.
--   
--   In this module we implement three pipelining strategies:
--   
--   <ul>
--   <li><a>pipelineDecisionMax</a></li>
--   <li><a>pipelineDecisionMin</a></li>
--   <li><a>pipelineDecisionLowHighMark</a></li>
--   </ul>
data MkPipelineDecision
[MkPipelineDecision] :: (forall n. Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> (PipelineDecision n, MkPipelineDecision)) -> MkPipelineDecision
runPipelineDecision :: MkPipelineDecision -> Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> (PipelineDecision n, MkPipelineDecision)
constantPipelineDecision :: (forall n. Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> PipelineDecision n) -> MkPipelineDecision

-- | Present maximal pipelining of at most <tt>omax</tt> requests. Collect
--   responses either when we are at the same block number as the server or
--   when we sent more than <tt>omax</tt> requests.
--   
--   If <tt>omax = 3</tt> this pipelining strategy will generate a
--   sequence: <tt> Pipeline Pipeline Pipeline Collect Pipeline Collect
--   .... Pipeline Collect Collect Collect </tt>
pipelineDecisionMax :: Word32 -> Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> PipelineDecision n

-- | Present minimum pipelining of at most <tt>omax</tt> requests, collect
--   responses eagerly.
pipelineDecisionMin :: Word32 -> Nat n -> WithOrigin BlockNo -> WithOrigin BlockNo -> PipelineDecision n

-- | Pipelining strategy which pipelines up to <tt>highMark</tt> requests;
--   if the number of pipelined messages exceeds the high mark, it collects
--   messages until there are at most <tt>lowMark</tt> outstanding
--   requests.
pipelineDecisionLowHighMark :: Word32 -> Word32 -> MkPipelineDecision


-- | The type of the chain synchronisation protocol.
--   
--   Since we are using a typed protocol framework this is in some sense
--   <i>the</i> definition of the protocol: what is allowed and what is not
--   allowed.
module Ouroboros.Network.Protocol.ChainSync.Type

-- | A kind to identify our protocol, and the types of the states in the
--   state transition diagram of the protocol.
data ChainSync header point tip

-- | Both client and server are idle. The client can send a request and the
--   server is waiting for a request.
[StIdle] :: ChainSync header point tip

-- | The client has sent a next update request. The client is now waiting
--   for a response, and the server is busy getting ready to send a
--   response. There are two possibilities here, since the server can send
--   a reply immediately or it can send an initial await message followed
--   later by the normal reply.
[StNext] :: StNextKind -> ChainSync header point tip

-- | The client has sent an intersection request. The client is now waiting
--   for a response, and the server is busy getting ready to send a
--   response.
[StIntersect] :: ChainSync header point tip

-- | Both the client and server are in the terminal state. They're done.
[StDone] :: ChainSync header point tip

-- | Sub-cases of the <a>StNext</a> state. This is needed since the server
--   can either send one reply back, or two.
data StNextKind

-- | The server can reply or send an await msg.
[StCanAwait] :: StNextKind

-- | The server must now reply, having already sent an await message.
[StMustReply] :: StNextKind
data TokNextKind (k :: StNextKind)
[TokCanAwait] :: TokNextKind StCanAwait
[TokMustReply] :: TokNextKind StMustReply
instance forall k1 k2 k3 (header :: k1) (point :: k2) (tip :: k3). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip)
instance forall k1 k2 k3 (header :: k1) (point :: k2) (tip :: k3) (st :: Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)
instance forall k1 k2 k3 (header :: k1) (tip :: k2) (point :: k3). (Ouroboros.Network.Util.ShowProxy.ShowProxy header, Ouroboros.Network.Util.ShowProxy.ShowProxy tip) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip)
instance forall header point tip (from :: Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip) (to :: Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip). (GHC.Show.Show header, GHC.Show.Show point, GHC.Show.Show tip) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip) from to)
instance forall k1 k2 k3 (header :: k1) (point :: k2) (tip :: k3) (st :: Ouroboros.Network.Protocol.ChainSync.Type.ChainSync header point tip). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)


-- | A view of the chain synchronisation protocol from the point of view of
--   the server.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, a conversion into the typed protocol is provided.
module Ouroboros.Network.Protocol.ChainSync.Server

-- | A chain sync protocol server, on top of some effect <tt>m</tt>.
newtype ChainSyncServer header point tip m a
ChainSyncServer :: m (ServerStIdle header point tip m a) -> ChainSyncServer header point tip m a
[runChainSyncServer] :: ChainSyncServer header point tip m a -> m (ServerStIdle header point tip m a)

-- | In the <a>StIdle</a> protocol state, the server does not have agency.
--   Instead it is waiting for:
--   
--   <ul>
--   <li>a next update request</li>
--   <li>a find intersection request</li>
--   <li>a termination messge</li>
--   </ul>
--   
--   It must be prepared to handle either.
data ServerStIdle header point tip m a
ServerStIdle :: m (Either (ServerStNext header point tip m a) (m (ServerStNext header point tip m a))) -> ([point] -> m (ServerStIntersect header point tip m a)) -> m a -> ServerStIdle header point tip m a
[recvMsgRequestNext] :: ServerStIdle header point tip m a -> m (Either (ServerStNext header point tip m a) (m (ServerStNext header point tip m a)))
[recvMsgFindIntersect] :: ServerStIdle header point tip m a -> [point] -> m (ServerStIntersect header point tip m a)
[recvMsgDoneClient] :: ServerStIdle header point tip m a -> m a

-- | In the <a>StNext</a> protocol state, the server has agency and must
--   send either:
--   
--   <ul>
--   <li>a roll forward</li>
--   <li>a roll back message</li>
--   <li>a termination message</li>
--   </ul>
data ServerStNext header point tip m a
[SendMsgRollForward] :: header -> tip -> ChainSyncServer header point tip m a -> ServerStNext header point tip m a
[SendMsgRollBackward] :: point -> tip -> ChainSyncServer header point tip m a -> ServerStNext header point tip m a

-- | In the <a>StIntersect</a> protocol state, the server has agency and
--   must send either:
--   
--   <ul>
--   <li>an intersection improved,</li>
--   <li>unchanged message,</li>
--   <li>termination message</li>
--   </ul>
data ServerStIntersect header point tip m a
[SendMsgIntersectFound] :: point -> tip -> ChainSyncServer header point tip m a -> ServerStIntersect header point tip m a
[SendMsgIntersectNotFound] :: tip -> ChainSyncServer header point tip m a -> ServerStIntersect header point tip m a

-- | Interpret a <a>ChainSyncServer</a> action sequence as a <a>Peer</a> on
--   the server side of the <tt>ChainSyncProtocol</tt>.
chainSyncServerPeer :: forall header point tip m a. Monad m => ChainSyncServer header point tip m a -> Peer (ChainSync header point tip) AsServer StIdle m a

module Ouroboros.Network.Protocol.ChainSync.Codec

-- | Codec for chain sync that encodes/decodes headers
--   
--   NOTE: See <tt>wrapCBORinCBOR</tt> and <tt>unwrapCBORinCBOR</tt> if you
--   want to use this with a header type that has annotations.
codecChainSync :: forall header point tip m. MonadST m => (header -> Encoding) -> (forall s. Decoder s header) -> (point -> Encoding) -> (forall s. Decoder s point) -> (tip -> Encoding) -> (forall s. Decoder s tip) -> Codec (ChainSync header point tip) DeserialiseFailure m ByteString

-- | An identity <a>Codec</a> for the <a>ChainSync</a> protocol. It does
--   not do any serialisation. It keeps the typed messages, wrapped in
--   <a>AnyMessage</a>.
codecChainSyncId :: forall header point tip m. Monad m => Codec (ChainSync header point tip) CodecFailure m (AnyMessage (ChainSync header point tip))

-- | Byte Limits
byteLimitsChainSync :: forall bytes header point tip. (bytes -> Word) -> ProtocolSizeLimits (ChainSync header point tip) bytes

-- | Time Limits
--   
--   <pre>
--   'TokIdle'               'waitForever' (ie never times out)
--   'TokNext TokCanAwait'   the given 'canAwaitTimeout'
--   'TokNext TokMustReply'  the given 'mustReplyTimeout'
--   'TokIntersect'          the given 'intersectTimeout'
--   </pre>
timeLimitsChainSync :: forall header point tip. ChainSyncTimeout -> ProtocolTimeLimits (ChainSync header point tip)

-- | Configurable timeouts
--   
--   These are configurable for at least the following reasons.
--   
--   o So that deployment and testing can use different values.
--   
--   o So that a net running Praos can better cope with streaks of empty
--   slots. (See <tt>input-output-hk/ouroboros-network#2245</tt>.)
data ChainSyncTimeout
ChainSyncTimeout :: Maybe DiffTime -> Maybe DiffTime -> Maybe DiffTime -> ChainSyncTimeout
[canAwaitTimeout] :: ChainSyncTimeout -> Maybe DiffTime
[intersectTimeout] :: ChainSyncTimeout -> Maybe DiffTime
[mustReplyTimeout] :: ChainSyncTimeout -> Maybe DiffTime

module Ouroboros.Network.Protocol.ChainSync.ClientPipelined

-- | Pipelined chain sync client. It can only pipeline
--   <a>MsgRequestNext</a> messages, while the <a>MsgFindIntersect</a> are
--   non pipelined. This has a penalty cost of an RTT, but they are send
--   relatively seldom and their response might impact how many messages
--   one would like to pipeline. It also simplifies the receiver callback.
newtype ChainSyncClientPipelined header point tip m a
ChainSyncClientPipelined :: m (ClientPipelinedStIdle Z header point tip m a) -> ChainSyncClientPipelined header point tip m a
[runChainSyncClientPipelined] :: ChainSyncClientPipelined header point tip m a -> m (ClientPipelinedStIdle Z header point tip m a)

-- | Pipelined sender which starts in <a>StIdle</a> state. It can either
--   
--   <ul>
--   <li>Send <a>MsgRequestNext</a> (no pipelining), which might be useful
--   when we are at the tip of the chain. It can only be send when there is
--   no pipelined message in flight (all responses were collected);</li>
--   <li>Pipeline <a>MsgRequestNext</a>;</li>
--   <li>Send <a>MsgFindIntersect</a> (no pipelining); It can only be send
--   when there is no pipelined message in flight (all responses were
--   collected);</li>
--   <li>Collect responses of pipelined message;</li>
--   <li>Terminate the protocol with by sending <a>MsgDone</a>.</li>
--   </ul>
data ClientPipelinedStIdle n header point tip m a
[SendMsgRequestNext] :: ClientStNext Z header point tip m a -> m (ClientStNext Z header point tip m a) -> ClientPipelinedStIdle Z header point tip m a
[SendMsgRequestNextPipelined] :: ClientPipelinedStIdle (S n) header point tip m a -> ClientPipelinedStIdle n header point tip m a
[SendMsgFindIntersect] :: [point] -> ClientPipelinedStIntersect header point tip m a -> ClientPipelinedStIdle Z header point tip m a
[CollectResponse] :: Maybe (m (ClientPipelinedStIdle (S n) header point tip m a)) -> ClientStNext n header point tip m a -> ClientPipelinedStIdle (S n) header point tip m a
[SendMsgDone] :: a -> ClientPipelinedStIdle Z header point tip m a

-- | Callback for responses received after sending <a>MsgRequestNext</a>.
--   
--   We could receive <a>MsgAwaitReply</a>. In this case we will wait for
--   the next message which must be <a>MsgRollForward</a> or
--   <a>MsgRollBackward</a>; thus we need only the two callbacks.
data ClientStNext n header point tip m a
ClientStNext :: (header -> tip -> m (ClientPipelinedStIdle n header point tip m a)) -> (point -> tip -> m (ClientPipelinedStIdle n header point tip m a)) -> ClientStNext n header point tip m a

-- | Callback for <a>MsgRollForward</a> message.
[recvMsgRollForward] :: ClientStNext n header point tip m a -> header -> tip -> m (ClientPipelinedStIdle n header point tip m a)

-- | Callback for <a>MsgRollBackward</a> message.
[recvMsgRollBackward] :: ClientStNext n header point tip m a -> point -> tip -> m (ClientPipelinedStIdle n header point tip m a)

-- | Callbacks for messages received after sending <a>MsgFindIntersect</a>.
--   
--   We might receive either <a>MsgIntersectFound</a> or
--   <a>MsgIntersectNotFound</a>.
data ClientPipelinedStIntersect header point tip m a
ClientPipelinedStIntersect :: (point -> tip -> m (ClientPipelinedStIdle Z header point tip m a)) -> (tip -> m (ClientPipelinedStIdle Z header point tip m a)) -> ClientPipelinedStIntersect header point tip m a
[recvMsgIntersectFound] :: ClientPipelinedStIntersect header point tip m a -> point -> tip -> m (ClientPipelinedStIdle Z header point tip m a)
[recvMsgIntersectNotFound] :: ClientPipelinedStIntersect header point tip m a -> tip -> m (ClientPipelinedStIdle Z header point tip m a)

-- | Data received through pipelining: either roll forward or roll backward
--   instruction. If the server replied with <a>MsgAwaitReply</a> the
--   pipelined receiver will await for the next message which must come
--   with an instruction how to update our chain.
--   
--   Note: internal API, not exposed by this module.
data ChainSyncInstruction header point tip
RollForward :: !header -> !tip -> ChainSyncInstruction header point tip
RollBackward :: !point -> !tip -> ChainSyncInstruction header point tip
chainSyncClientPeerPipelined :: forall header point tip m a. Monad m => ChainSyncClientPipelined header point tip m a -> PeerPipelined (ChainSync header point tip) AsClient StIdle m a
chainSyncClientPeerSender :: forall n header point tip m a. Monad m => Nat n -> ClientPipelinedStIdle n header point tip m a -> PeerSender (ChainSync header point tip) AsClient StIdle n (ChainSyncInstruction header point tip) m a

-- | Transform a <a>ChainSyncClientPipelined</a> by mapping over the tx
--   header and the chain tip values.
--   
--   Note the direction of the individual mapping functions corresponds to
--   whether the types are used as protocol inputs or outputs (or both, as
--   is the case for points).
mapChainSyncClientPipelined :: forall header header' point point' tip tip' (m :: Type -> Type) a. Functor m => (point -> point') -> (point' -> point) -> (header' -> header) -> (tip' -> tip) -> ChainSyncClientPipelined header point tip m a -> ChainSyncClientPipelined header' point' tip' m a


-- | A view of the chain synchronisation protocol from the point of view of
--   the client.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, a conversion into the typed protocol is provided.
module Ouroboros.Network.Protocol.ChainSync.Client

-- | A chain sync protocol client, on top of some effect <tt>m</tt>. The
--   first choice of request is within that <tt>m</tt>.
newtype ChainSyncClient header point tip m a
ChainSyncClient :: m (ClientStIdle header point tip m a) -> ChainSyncClient header point tip m a
[runChainSyncClient] :: ChainSyncClient header point tip m a -> m (ClientStIdle header point tip m a)

-- | In the <a>StIdle</a> protocol state, the server does not have agency
--   and can choose to send a request next, or a find intersection message.
data ClientStIdle header point tip m a

-- | Send the <a>MsgRequestNext</a>, with handlers for the replies.
--   
--   The handlers for this message are more complicated than most RPCs
--   because the server can either send us a reply immediately or it can
--   send us a <a>MsgAwaitReply</a> to indicate that the server itself has
--   to block for a state change before it can send us the reply.
--   
--   In the waiting case, the client gets the chance to take a local
--   action.
[SendMsgRequestNext] :: ClientStNext header point tip m a -> m (ClientStNext header point tip m a) -> ClientStIdle header point tip m a

-- | Send the <a>MsgFindIntersect</a>, with handlers for the replies.
[SendMsgFindIntersect] :: [point] -> ClientStIntersect header point tip m a -> ClientStIdle header point tip m a

-- | The client decided to end the protocol.
[SendMsgDone] :: a -> ClientStIdle header point tip m a

-- | In the <a>StNext</a> protocol state, the client does not have agency
--   and is waiting to receive either
--   
--   <ul>
--   <li>a roll forward,</li>
--   <li>roll back message,</li>
--   </ul>
--   
--   It must be prepared to handle any of these.
data ClientStNext header point tip m a
ClientStNext :: (header -> tip -> ChainSyncClient header point tip m a) -> (point -> tip -> ChainSyncClient header point tip m a) -> ClientStNext header point tip m a
[recvMsgRollForward] :: ClientStNext header point tip m a -> header -> tip -> ChainSyncClient header point tip m a
[recvMsgRollBackward] :: ClientStNext header point tip m a -> point -> tip -> ChainSyncClient header point tip m a

-- | In the <a>StIntersect</a> protocol state, the client does not have
--   agency and is waiting to receive:
--   
--   <ul>
--   <li>an intersection improved,</li>
--   <li>unchanged message,</li>
--   <li>the termination message.</li>
--   </ul>
--   
--   It must be prepared to handle any of these.
data ClientStIntersect header point tip m a
ClientStIntersect :: (point -> tip -> ChainSyncClient header point tip m a) -> (tip -> ChainSyncClient header point tip m a) -> ClientStIntersect header point tip m a
[recvMsgIntersectFound] :: ClientStIntersect header point tip m a -> point -> tip -> ChainSyncClient header point tip m a
[recvMsgIntersectNotFound] :: ClientStIntersect header point tip m a -> tip -> ChainSyncClient header point tip m a

-- | Interpret a <a>ChainSyncClient</a> action sequence as a <a>Peer</a> on
--   the client side of the <tt>ChainSyncProtocol</tt>.
chainSyncClientPeer :: forall header point tip m a. Monad m => ChainSyncClient header point tip m a -> Peer (ChainSync header point tip) AsClient StIdle m a

-- | A chain sync client which never sends any message.

-- | <i>Deprecated: Use
--   Ouroboros.Network.NodeToClient.chainSyncPeerNull</i>
chainSyncClientNull :: MonadTimer m => ChainSyncClient header point tip m a

-- | Transform a <a>ChainSyncClient</a> by mapping over the tx header and
--   the chain tip values.
--   
--   Note the direction of the individual mapping functions corresponds to
--   whether the types are used as protocol inputs or outputs (or both, as
--   is the case for points).
mapChainSyncClient :: forall header header' point point' tip tip' m a. Functor m => (point -> point') -> (point' -> point) -> (header' -> header) -> (tip' -> tip) -> ChainSyncClient header point tip m a -> ChainSyncClient header' point' tip' m a

module Ouroboros.Network.Protocol.ChainSync.Examples

-- | An instance of the client side of the chain sync protocol that
--   consumes into a <a>Chain</a> stored in a <a>StrictTVar</a>.
--   
--   This is of course only useful in tests and reference implementations
--   since this is not a realistic chain representation.
chainSyncClientExample :: forall header tip m a. (HasHeader header, MonadSTM m) => StrictTVar m (Chain header) -> Client header (Point header) tip m a -> ChainSyncClient header (Point header) tip m a
data Client header point tip m t
Client :: (point -> tip -> m (Either t (Client header point tip m t))) -> (header -> m (Either t (Client header point tip m t))) -> ([point] -> m (Client header point tip m t)) -> Client header point tip m t
[rollbackward] :: Client header point tip m t -> point -> tip -> m (Either t (Client header point tip m t))
[rollforward] :: Client header point tip m t -> header -> m (Either t (Client header point tip m t))
[points] :: Client header point tip m t -> [point] -> m (Client header point tip m t)

-- | A client which doesn't do anything and never ends. Used with
--   <a>chainSyncClientExample</a>, the StrictTVar m (Chain header) will be
--   updated but nothing further will happen.
pureClient :: Applicative m => Client header point tip m void
controlledClient :: MonadSTM m => ControlMessageSTM m -> Client header point tip m ()

-- | Used in chain-sync protocol to advertise the tip of the server's
--   chain.
data Tip b

-- | The tip is genesis
TipGenesis :: Tip b

-- | The tip is not genesis
Tip :: !SlotNo -> !HeaderHash b -> !BlockNo -> Tip b

-- | An instance of the server side of the chain sync protocol that reads
--   from a pure <a>ChainProducerState</a> stored in a <a>StrictTVar</a>.
--   
--   This is of course only useful in tests and reference implementations
--   since this is not a realistic chain representation.
chainSyncServerExample :: forall blk header m a. (HasHeader header, MonadSTM m, HeaderHash header ~ HeaderHash blk) => a -> StrictTVar m (ChainProducerState header) -> ChainSyncServer header (Point blk) (Tip blk) m a


-- | The type of the keep alive protocol.
--   
--   The keep alive protocol is used for
--   
--   <ul>
--   <li>sending keep alive messages</li>
--   <li>making round trip measuremnets</li>
--   </ul>
--   
--   Each side will run its own version of the keep alive protocol. It
--   should be configured so that any intermediate state (such as in
--   customer premise equipment or in a carrier grade NAT) is kept alive.
--   This has to be a per-node configuration element as this is about the
--   properties of that nodes network connectivity.
--   
--   For making round trip measurements its in the interest of the other
--   side to reply promptly.
module Ouroboros.Network.Protocol.KeepAlive.Type

-- | A 16bit value used to match responses to requests.
newtype Cookie
Cookie :: Word16 -> Cookie
[unCookie] :: Cookie -> Word16
data KeepAliveProtocolFailure
KeepAliveCookieMissmatch :: Cookie -> Cookie -> KeepAliveProtocolFailure

-- | A kind to identify our protocol, and the types of the states in the
--   state transition diagram of the protocol.
data KeepAlive

-- | The client can send a request and the server is waiting for a request.
[StClient] :: KeepAlive

-- | The server is responsible for sending response back.
[StServer] :: KeepAlive

-- | Both the client and server are in the terminal state. They're done.
[StDone] :: KeepAlive
instance GHC.Show.Show Ouroboros.Network.Protocol.KeepAlive.Type.Cookie
instance GHC.Classes.Eq Ouroboros.Network.Protocol.KeepAlive.Type.Cookie
instance GHC.Show.Show Ouroboros.Network.Protocol.KeepAlive.Type.KeepAliveProtocolFailure
instance GHC.Classes.Eq Ouroboros.Network.Protocol.KeepAlive.Type.KeepAliveProtocolFailure
instance Ouroboros.Network.Util.ShowProxy.ShowProxy Ouroboros.Network.Protocol.KeepAlive.Type.KeepAlive
instance Network.TypedProtocol.Core.Protocol Ouroboros.Network.Protocol.KeepAlive.Type.KeepAlive
instance GHC.Show.Show (Network.TypedProtocol.Core.Message Ouroboros.Network.Protocol.KeepAlive.Type.KeepAlive from to)
instance GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)
instance GHC.Exception.Type.Exception Ouroboros.Network.Protocol.KeepAlive.Type.KeepAliveProtocolFailure

module Ouroboros.Network.Protocol.KeepAlive.Server
data KeepAliveServer m a
KeepAliveServer :: m (KeepAliveServer m a) -> m a -> KeepAliveServer m a
[recvMsgKeepAlive] :: KeepAliveServer m a -> m (KeepAliveServer m a)
[recvMsgDone] :: KeepAliveServer m a -> m a
keepAliveServerPeer :: Functor m => KeepAliveServer m a -> Peer KeepAlive AsServer StClient m a

module Ouroboros.Network.Protocol.KeepAlive.Codec
codecKeepAlive_v2 :: forall m. MonadST m => Codec KeepAlive DeserialiseFailure m ByteString
codecKeepAliveId :: forall m. Monad m => Codec KeepAlive CodecFailure m (AnyMessage KeepAlive)
byteLimitsKeepAlive :: (bytes -> Word) -> ProtocolSizeLimits KeepAlive bytes
timeLimitsKeepAlive :: ProtocolTimeLimits KeepAlive

module Ouroboros.Network.Protocol.KeepAlive.Client
data KeepAliveClient m a
[SendMsgKeepAlive] :: Cookie -> m (KeepAliveClient m a) -> KeepAliveClient m a
[SendMsgDone] :: m a -> KeepAliveClient m a

-- | Interpret a particular client action sequence into the client side of
--   the <a>KeepAlive</a> protocol.
keepAliveClientPeer :: MonadThrow m => KeepAliveClient m a -> Peer KeepAlive AsClient StClient m a

module Ouroboros.Network.KeepAlive
newtype KeepAliveInterval
KeepAliveInterval :: DiffTime -> KeepAliveInterval
[keepAliveInterval] :: KeepAliveInterval -> DiffTime
keepAliveClient :: forall m peer. (MonadSTM m, MonadMonotonicTime m, MonadTimer m, Ord peer) => Tracer m (TraceKeepAliveClient peer) -> StdGen -> ControlMessageSTM m -> peer -> StrictTVar m (Map peer PeerGSV) -> KeepAliveInterval -> KeepAliveClient m ()
keepAliveServer :: forall m. Applicative m => KeepAliveServer m ()
data TraceKeepAliveClient peer
AddSample :: peer -> DiffTime -> PeerGSV -> TraceKeepAliveClient peer
instance GHC.Show.Show peer => GHC.Show.Show (Ouroboros.Network.KeepAlive.TraceKeepAliveClient peer)


-- | The type of the local ledger state query protocol.
--   
--   This is used by local clients (like wallets and CLI tools) to query
--   the ledger state of a local node.
module Ouroboros.Network.Protocol.LocalStateQuery.Type

-- | The kind of the local state query protocol, and the types of the
--   states in the protocol state machine.
--   
--   It is parametrised over the type of block (for points), the type of
--   queries and query results.
data LocalStateQuery block point (query :: Type -> Type)

-- | The client has agency. It can ask to acquire a state or terminate.
--   
--   There is no timeout in this state.
[StIdle] :: LocalStateQuery block point query

-- | The server has agency. it must acquire the state at the requested
--   point or report a failure.
--   
--   There is a timeout in this state.
[StAcquiring] :: LocalStateQuery block point query

-- | The client has agency. It can request queries against the current
--   state, or it can release the state.
[StAcquired] :: LocalStateQuery block point query

-- | The server has agency. It must respond with the query result.
[StQuerying] :: result -> LocalStateQuery block point query

-- | Nobody has agency. The terminal state.
[StDone] :: LocalStateQuery block point query
data AcquireFailure
AcquireFailurePointTooOld :: AcquireFailure
AcquireFailurePointNotOnChain :: AcquireFailure

-- | To implement <a>Show</a> for:
--   
--   <pre>
--   ('Message' ('LocalStateQuery' block query) st st')
--   </pre>
--   
--   we need a way to print the <tt>query</tt> GADT and its type index,
--   <tt>result</tt>. This class contain the method we need to provide this
--   <a>Show</a> instance.
--   
--   We use a type class for this, as this <a>Show</a> constraint
--   propagates to a lot of places.
class (forall result. Show (query result)) => ShowQuery query
showResult :: forall result. ShowQuery query => query result -> result -> String
instance GHC.Show.Show Ouroboros.Network.Protocol.LocalStateQuery.Type.AcquireFailure
instance GHC.Enum.Enum Ouroboros.Network.Protocol.LocalStateQuery.Type.AcquireFailure
instance GHC.Classes.Eq Ouroboros.Network.Protocol.LocalStateQuery.Type.AcquireFailure
instance forall k (query :: * -> *) point (block :: k) (st :: Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query) (st' :: Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query). (Ouroboros.Network.Protocol.LocalStateQuery.Type.ShowQuery query, GHC.Show.Show point) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query) st st')
instance forall k1 k2 (block :: k1) (point :: k2) (query :: * -> *). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query)
instance forall k1 k2 (block :: k1) (query :: * -> *) (point :: k2). (Ouroboros.Network.Util.ShowProxy.ShowProxy block, Ouroboros.Network.Util.ShowProxy.ShowProxy query) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query)
instance forall k1 k2 (block :: k1) (point :: k2) (query :: * -> *) (st :: Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k1 k2 (query :: * -> *) (block :: k1) (point :: k2) (st :: Ouroboros.Network.Protocol.LocalStateQuery.Type.LocalStateQuery block point query). (forall result. GHC.Show.Show (query result)) => GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)

module Ouroboros.Network.Protocol.LocalStateQuery.Server
newtype LocalStateQueryServer block point (query :: Type -> Type) m a
LocalStateQueryServer :: m (ServerStIdle block point query m a) -> LocalStateQueryServer block point (query :: Type -> Type) m a
[runLocalStateQueryServer] :: LocalStateQueryServer block point (query :: Type -> Type) m a -> m (ServerStIdle block point query m a)

-- | In the <a>StIdle</a> protocol state, the server does not have agency.
--   Instead it is waiting for:
--   
--   <ul>
--   <li>a request to acquire a state</li>
--   <li>a termination messge</li>
--   </ul>
--   
--   It must be prepared to handle either.
data ServerStIdle block point query m a
ServerStIdle :: (Maybe point -> m (ServerStAcquiring block point query m a)) -> m a -> ServerStIdle block point query m a
[recvMsgAcquire] :: ServerStIdle block point query m a -> Maybe point -> m (ServerStAcquiring block point query m a)
[recvMsgDone] :: ServerStIdle block point query m a -> m a

-- | In the <a>StAcquiring</a> protocol state, the server has agency and
--   must send either:
--   
--   <ul>
--   <li>acquired</li>
--   <li>failure to acquire</li>
--   </ul>
data ServerStAcquiring block point query m a
[SendMsgAcquired] :: ServerStAcquired block point query m a -> ServerStAcquiring block point query m a
[SendMsgFailure] :: AcquireFailure -> ServerStIdle block point query m a -> ServerStAcquiring block point query m a

-- | In the <a>StAcquired</a> protocol state, the server does not have
--   agency. Instead it is waiting for:
--   
--   <ul>
--   <li>a query</li>
--   <li>a request to (re)acquire another state</li>
--   <li>a release of the current state</li>
--   </ul>
--   
--   It must be prepared to handle either.
data ServerStAcquired block point query m a
ServerStAcquired :: (forall result. query result -> m (ServerStQuerying block point query m a result)) -> (Maybe point -> m (ServerStAcquiring block point query m a)) -> m (ServerStIdle block point query m a) -> ServerStAcquired block point query m a
[recvMsgQuery] :: ServerStAcquired block point query m a -> forall result. query result -> m (ServerStQuerying block point query m a result)
[recvMsgReAcquire] :: ServerStAcquired block point query m a -> Maybe point -> m (ServerStAcquiring block point query m a)
[recvMsgRelease] :: ServerStAcquired block point query m a -> m (ServerStIdle block point query m a)

-- | In the <a>StQuerying</a> protocol state, the server has agency and
--   must send:
--   
--   <ul>
--   <li>a result</li>
--   </ul>
data ServerStQuerying block point query m a result
[SendMsgResult] :: result -> ServerStAcquired block point query m a -> ServerStQuerying block point query m a result

-- | Interpret a <a>LocalStateQueryServer</a> action sequence as a
--   <a>Peer</a> on the server side of the <a>LocalStateQuery</a> protocol.
localStateQueryServerPeer :: forall block point (query :: Type -> Type) m a. Monad m => LocalStateQueryServer block point query m a -> Peer (LocalStateQuery block point query) AsServer StIdle m a

module Ouroboros.Network.Protocol.LocalStateQuery.Codec
codecLocalStateQuery :: forall block point query m. (MonadST m, ShowQuery query) => (point -> Encoding) -> (forall s. Decoder s point) -> (forall result. query result -> Encoding) -> (forall s. Decoder s (Some query)) -> (forall result. query result -> result -> Encoding) -> (forall result. query result -> forall s. Decoder s result) -> Codec (LocalStateQuery block point query) DeserialiseFailure m ByteString

-- | An identity <a>Codec</a> for the <a>LocalStateQuery</a> protocol. It
--   does not do any serialisation. It keeps the typed messages, wrapped in
--   <a>AnyMessage</a>.
codecLocalStateQueryId :: forall block point (query :: Type -> Type) m. Monad m => (forall result1 result2. query result1 -> query result2 -> Maybe (result1 :~: result2)) -> Codec (LocalStateQuery block point query) CodecFailure m (AnyMessage (LocalStateQuery block point query))
data Some (f :: k -> Type)
[Some] :: f a -> Some f

module Ouroboros.Network.Protocol.LocalStateQuery.Client
newtype LocalStateQueryClient block point (query :: Type -> Type) m a
LocalStateQueryClient :: m (ClientStIdle block point query m a) -> LocalStateQueryClient block point (query :: Type -> Type) m a
[runLocalStateQueryClient] :: LocalStateQueryClient block point (query :: Type -> Type) m a -> m (ClientStIdle block point query m a)

-- | In the <a>StIdle</a> protocol state, the client has agency and must
--   send:
--   
--   <ul>
--   <li>a request to acquire a state</li>
--   <li>a termination messge</li>
--   </ul>
data ClientStIdle block point query (m :: Type -> Type) a
[SendMsgAcquire] :: Maybe point -> ClientStAcquiring block point query m a -> ClientStIdle block point query m a
[SendMsgDone] :: a -> ClientStIdle block point query m a

-- | In the <a>StAcquiring</a> protocol state, the client does not have
--   agency. Instead it is waiting for:
--   
--   <ul>
--   <li>acquired</li>
--   <li>failure to acquire</li>
--   </ul>
--   
--   It must be prepared to handle either.
data ClientStAcquiring block point query m a
ClientStAcquiring :: m (ClientStAcquired block point query m a) -> (AcquireFailure -> m (ClientStIdle block point query m a)) -> ClientStAcquiring block point query m a
[recvMsgAcquired] :: ClientStAcquiring block point query m a -> m (ClientStAcquired block point query m a)
[recvMsgFailure] :: ClientStAcquiring block point query m a -> AcquireFailure -> m (ClientStIdle block point query m a)

-- | In the <a>StAcquired</a> protocol state, the client has agency and
--   must send:
--   
--   <ul>
--   <li>a query</li>
--   <li>a request to (re)acquire another state</li>
--   <li>a release of the current state</li>
--   </ul>
data ClientStAcquired block point query m a
[SendMsgQuery] :: query result -> ClientStQuerying block point query m a result -> ClientStAcquired block point query m a
[SendMsgReAcquire] :: Maybe point -> ClientStAcquiring block point query m a -> ClientStAcquired block point query m a
[SendMsgRelease] :: m (ClientStIdle block point query m a) -> ClientStAcquired block point query m a

-- | In the <a>StQuerying</a> protocol state, the client does not have
--   agency. Instead it is waiting for:
--   
--   <ul>
--   <li>a result</li>
--   </ul>
data ClientStQuerying block point query m a result
ClientStQuerying :: (result -> m (ClientStAcquired block point query m a)) -> ClientStQuerying block point query m a result
[recvMsgResult] :: ClientStQuerying block point query m a result -> result -> m (ClientStAcquired block point query m a)

-- | Interpret a <a>LocalStateQueryClient</a> action sequence as a
--   <a>Peer</a> on the client side of the <a>LocalStateQuery</a> protocol.
localStateQueryClientPeer :: forall block point (query :: Type -> Type) m a. Monad m => LocalStateQueryClient block point query m a -> Peer (LocalStateQuery block point query) AsClient StIdle m a

-- | <i>Deprecated: Use
--   Ouroboros.Network.NodeToClient.localStateQueryPeerNull</i>
localStateQueryClientNull :: MonadTimer m => LocalStateQueryClient block point query m a

-- | Transform a <a>LocalStateQueryClient</a> by mapping over the query and
--   query result values.
--   
--   Note the direction of the individual mapping functions corresponds to
--   whether the types are used as protocol inputs or outputs.
mapLocalStateQueryClient :: forall block block' point point' query query' m a. Functor m => (point -> point') -> (forall result. query result -> Some query') -> (forall result result'. query result -> query' result' -> result' -> result) -> LocalStateQueryClient block point query m a -> LocalStateQueryClient block' point' query' m a
data Some (f :: k -> Type)
[Some] :: f a -> Some f

module Ouroboros.Network.Protocol.LocalStateQuery.Examples

-- | An example <a>LocalStateQueryClient</a>, which, for each point in the
--   given list, acquires the state for that point, and if that succeeds,
--   returns the result for the corresponding query. When the state could
--   not be acquired, the <a>AcquireFailure</a> is returned instead of the
--   query results.
localStateQueryClient :: forall block point query result m. Applicative m => [(Maybe point, query result)] -> LocalStateQueryClient block point query m [(Maybe point, Either AcquireFailure result)]

-- | An example <a>LocalStateQueryServer</a>. The first function is called
--   to acquire a <tt>state</tt>, after which the second will be used to
--   query the state.
localStateQueryServer :: forall block point query m state. Applicative m => (Maybe point -> Either AcquireFailure state) -> (forall result. state -> query result -> result) -> LocalStateQueryServer block point query m ()


-- | The type of the local transaction monitoring protocol.
--   
--   This is used by local clients (like wallets, explorers and CLI tools)
--   to monitor the transactions passing through the mempool of a local
--   node.
--   
--   The protocol is stateful such that the server keeps track of the
--   transactions already sent to the client.
--   
--   <pre>
--                     START
--                       ⇓
--                     ┌───────────────┐
--             ┌──────▶│     Idle      │⇒ DONE
--             │       └───┬───────────┘
--             │           │
--             │   Acquire │
--             │           ▼
--             │       ┌───────────────┐
--     Release │       │   Acquiring   │
--             │       └───┬───────────┘
--             │           │       ▲
--             │  Acquired │       │ AwaitAcquire
--             │           ▼       │
--             │       ┌───────────┴───┐
--             └───────┤   Acquired    │
--                     └───┬───────────┘
--                         │       ▲
--   HasTx|NextTx|GetSizes │       │ Reply (HasTx|NextTx|GetSizes)
--                         ▼       │
--                     ┌───────────┴───┐
--                     │      Busy     │
--                     └───────────────┘
--   </pre>
module Ouroboros.Network.Protocol.LocalTxMonitor.Type

-- | The kind of the local transaction monitoring protocol, and the types
--   of the states in the protocol state machine.
--   
--   It is parametrised over the type of transactions.
data LocalTxMonitor txid tx slot

-- | The client has agency; it can request a transaction or terminate.
--   
--   There is no timeout in this state.
[StIdle] :: LocalTxMonitor txid tx slot

-- | The server has agency; it is capturing the latest mempool snapshot.
[StAcquiring] :: LocalTxMonitor txid tx slot

-- | The client has agency; The server is locked on a particular mempool
--   snapshot. The client can now perform various requests on that
--   snapshot, or acquire a new one, more recent.
[StAcquired] :: LocalTxMonitor txid tx slot

-- | The server has agency; It must respond, there's no timeout.
[StBusy] :: StBusyKind -> LocalTxMonitor txid tx slot

-- | Nobody has agency. The terminal state.
[StDone] :: LocalTxMonitor txid tx slot
data StBusyKind

-- | The server is busy fetching the next transaction from the mempool
[NextTx] :: StBusyKind

-- | The server is busy looking for the presence of a specific transaction
--   in the mempool
[HasTx] :: StBusyKind

-- | The server is busy looking for the current size and max capacity of
--   the mempool
[GetSizes] :: StBusyKind

-- | Describes the MemPool sizes and capacity for a given snapshot.
data MempoolSizeAndCapacity
MempoolSizeAndCapacity :: !Word32 -> !Word32 -> !Word32 -> MempoolSizeAndCapacity

-- | The maximum capacity of the mempool. Note that this may dynamically
--   change when the ledger state is updated.
[capacityInBytes] :: MempoolSizeAndCapacity -> !Word32

-- | The summed byte size of all the transactions in the mempool.
[sizeInBytes] :: MempoolSizeAndCapacity -> !Word32

-- | The number of transactions in the mempool
[numberOfTxs] :: MempoolSizeAndCapacity -> !Word32
data TokBusyKind (k :: StBusyKind)
[TokNextTx] :: TokBusyKind NextTx
[TokHasTx] :: TokBusyKind HasTx
[TokGetSizes] :: TokBusyKind GetSizes
instance GHC.Show.Show Ouroboros.Network.Protocol.LocalTxMonitor.Type.MempoolSizeAndCapacity
instance GHC.Classes.Eq Ouroboros.Network.Protocol.LocalTxMonitor.Type.MempoolSizeAndCapacity
instance GHC.Generics.Generic Ouroboros.Network.Protocol.LocalTxMonitor.Type.MempoolSizeAndCapacity
instance forall txid tx slot (from :: Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot) (to :: Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot). (GHC.Show.Show txid, GHC.Show.Show tx, GHC.Show.Show slot) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot) from to)
instance forall k1 k2 k3 (txid :: k1) (tx :: k2) (slot :: k3). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot)
instance forall k1 k2 k3 (txid :: k1) (tx :: k2) (slot :: k3) (st :: Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)
instance forall k1 k2 k3 (txid :: k1) (tx :: k2) (slot :: k3). (Ouroboros.Network.Util.ShowProxy.ShowProxy txid, Ouroboros.Network.Util.ShowProxy.ShowProxy tx, Ouroboros.Network.Util.ShowProxy.ShowProxy slot) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot)
instance forall k1 k2 k3 (txid :: k1) (tx :: k2) (slot :: k3) (st :: Ouroboros.Network.Protocol.LocalTxMonitor.Type.LocalTxMonitor txid tx slot). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)


-- | A view of the transaction monitor protocol from the point of view of
--   the server.
--   
--   This provides simple access to the local mempool snapshots, to allow
--   building more monitoring logic from the client side after submitting
--   transactions.
--   
--   For execution, <a>localTxMonitorServerPeer</a> is provided for
--   conversion into the typed protocol.
module Ouroboros.Network.Protocol.LocalTxMonitor.Server

-- | A local tx monitor protocol server, on top of some effect <tt>m</tt>.
newtype LocalTxMonitorServer txid tx slot m a
LocalTxMonitorServer :: m (ServerStIdle txid tx slot m a) -> LocalTxMonitorServer txid tx slot m a
[runLocalTxMonitorServer] :: LocalTxMonitorServer txid tx slot m a -> m (ServerStIdle txid tx slot m a)

-- | In the <a>StIdle</a> protocol state, the server does not have agency.
--   Instead, it is waiting for:
--   
--   <ul>
--   <li>an acquire request,</li>
--   <li>a termination message.</li>
--   </ul>
data ServerStIdle txid tx slot m a
ServerStIdle :: m (ServerStAcquiring txid tx slot m a) -> m a -> ServerStIdle txid tx slot m a
[recvMsgAcquire] :: ServerStIdle txid tx slot m a -> m (ServerStAcquiring txid tx slot m a)
[recvMsgDone] :: ServerStIdle txid tx slot m a -> m a

-- | In the <a>StAcquiring</a> protocol state, the server has agency and
--   must acquire, and hold on to, the current / latest snapshot of its
--   mempool.
data ServerStAcquiring txid tx slot m a
[SendMsgAcquired] :: slot -> ServerStAcquired txid tx slot m a -> ServerStAcquiring txid tx slot m a

-- | In the <a>StAcquired</a> protocol state, the server does not have
--   agency and is waiting for a client to either:
--   
--   <ul>
--   <li>request the next transaction from the snapshot;</li>
--   <li>check the presence of a given transaction, by its id;</li>
--   <li>await a change in the snapshot and acquire it;</li>
--   <li>release and go back to the <a>StIdle</a> state;</li>
--   </ul>
data ServerStAcquired txid tx slot m a
ServerStAcquired :: m (ServerStBusy NextTx txid tx slot m a) -> (txid -> m (ServerStBusy HasTx txid tx slot m a)) -> m (ServerStBusy GetSizes txid tx slot m a) -> m (ServerStAcquiring txid tx slot m a) -> m (ServerStIdle txid tx slot m a) -> ServerStAcquired txid tx slot m a
[recvMsgNextTx] :: ServerStAcquired txid tx slot m a -> m (ServerStBusy NextTx txid tx slot m a)
[recvMsgHasTx] :: ServerStAcquired txid tx slot m a -> txid -> m (ServerStBusy HasTx txid tx slot m a)
[recvMsgGetSizes] :: ServerStAcquired txid tx slot m a -> m (ServerStBusy GetSizes txid tx slot m a)
[recvMsgAwaitAcquire] :: ServerStAcquired txid tx slot m a -> m (ServerStAcquiring txid tx slot m a)
[recvMsgRelease] :: ServerStAcquired txid tx slot m a -> m (ServerStIdle txid tx slot m a)
data ServerStBusy (kind :: StBusyKind) txid tx slot m a
[SendMsgReplyNextTx] :: Maybe tx -> ServerStAcquired txid tx slot m a -> ServerStBusy NextTx txid tx slot m a
[SendMsgReplyHasTx] :: Bool -> ServerStAcquired txid tx slot m a -> ServerStBusy HasTx txid tx slot m a
[SendMsgReplyGetSizes] :: MempoolSizeAndCapacity -> ServerStAcquired txid tx slot m a -> ServerStBusy GetSizes txid tx slot m a

-- | Interpret a <a>LocalTxMonitorServer</a> action sequence as a
--   <a>Peer</a> on the client-side of the <a>LocalTxMonitor</a> protocol.
localTxMonitorServerPeer :: forall txid tx slot m a. Monad m => LocalTxMonitorServer txid tx slot m a -> Peer (LocalTxMonitor txid tx slot) AsServer StIdle m a

module Ouroboros.Network.Protocol.LocalTxMonitor.Codec
codecLocalTxMonitor :: forall txid tx slot m ptcl. (MonadST m, ptcl ~ LocalTxMonitor txid tx slot) => (txid -> Encoding) -> (forall s. Decoder s txid) -> (tx -> Encoding) -> (forall s. Decoder s tx) -> (slot -> Encoding) -> (forall s. Decoder s slot) -> Codec (LocalTxMonitor txid tx slot) DeserialiseFailure m ByteString

-- | An identity <a>Codec</a> for the <a>LocalTxMonitor</a> protocol. It
--   does not do any serialisation. It keeps the typed messages, wrapped in
--   <a>AnyMessage</a>.
codecLocalTxMonitorId :: forall txid tx slot m ptcl. (Monad m, ptcl ~ LocalTxMonitor txid tx slot) => Codec ptcl CodecFailure m (AnyMessage ptcl)


-- | A view of the transaction monitor protocol from the point of view of
--   the client.
--   
--   This provides simple access to the local mempool snapshots, to allow
--   building more monitoring logic from the client side after submitting
--   transactions.
--   
--   For execution, <a>localTxMonitorClientPeer</a> is provided for
--   conversion into the typed protocol.
module Ouroboros.Network.Protocol.LocalTxMonitor.Client

-- | A tx monitor client, on top of some effect <tt>m</tt>.
newtype LocalTxMonitorClient txid tx slot m a
LocalTxMonitorClient :: m (ClientStIdle txid tx slot m a) -> LocalTxMonitorClient txid tx slot m a
[runLocalTxMonitorClient] :: LocalTxMonitorClient txid tx slot m a -> m (ClientStIdle txid tx slot m a)

-- | In the <a>StIdle</a> protocol state, the client has agency and can
--   proceed to acquire a mempool snapshot, or end the protocol.
data ClientStIdle txid tx slot m a

-- | Send the <a>MsgAcquire</a>, with handlers for the replies.
--   
--   This request cannot timeout and cannot fail, it'll acquire the latest
--   mempool snapshot available on the server and hang on to it. This
--   allows to run any subsequent queries against the same view of the
--   mempool.
--   
--   The snapshot is acquired for a particular slot number which
--   materializes the 'virtual block' under construction.
[SendMsgAcquire] :: (slot -> m (ClientStAcquired txid tx slot m a)) -> ClientStIdle txid tx slot m a

-- | The client decided to end the protocol
[SendMsgDone] :: a -> ClientStIdle txid tx slot m a

-- | In the <a>StAcquired</a> protocol state, the client has agency and can
--   query the server against the acquired snapshot. Alternatively, it can
--   also (re)acquire a more recent snapshot.
data ClientStAcquired txid tx slot m a

-- | The mempool is modeled as an ordered list of transactions and thus,
--   can be traversed linearly. <a>MsgNextTx</a> requests the next
--   transaction from the current list. This must be a transaction that was
--   not previously sent to the client for this particular snapshot.
[SendMsgNextTx] :: (Maybe tx -> m (ClientStAcquired txid tx slot m a)) -> ClientStAcquired txid tx slot m a

-- | For some cases where clients do not wish to traverse the entire
--   mempool but look for a specific transaction, they can assess the
--   presence of such transaction directly. Note that, the absence of a
--   transaction does not imply anything about how the transaction was
--   processed: it may have been dropped, or inserted in a block.
--   <a>False</a> simply means that it is no longer in the mempool.
[SendMsgHasTx] :: txid -> (Bool -> m (ClientStAcquired txid tx slot m a)) -> ClientStAcquired txid tx slot m a

-- | Ask the server about the current mempool's capacity and sizes. This is
--   fixed in a given snapshot.
[SendMsgGetSizes] :: (MempoolSizeAndCapacity -> m (ClientStAcquired txid tx slot m a)) -> ClientStAcquired txid tx slot m a

-- | Await for a new snapshot and acquire it.
[SendMsgAwaitAcquire] :: (slot -> m (ClientStAcquired txid tx slot m a)) -> ClientStAcquired txid tx slot m a

-- | Release the acquired snapshot, in order to loop back to the idle
--   state.
[SendMsgRelease] :: m (ClientStIdle txid tx slot m a) -> ClientStAcquired txid tx slot m a

-- | Interpret a <a>LocalTxMonitorClient</a> action sequence as a
--   <a>Peer</a> on the client-side of the <a>LocalTxMonitor</a> protocol.
localTxMonitorClientPeer :: forall txid tx slot m a. Monad m => LocalTxMonitorClient txid tx slot m a -> Peer (LocalTxMonitor txid tx slot) AsClient StIdle m a


-- | The type of the local transaction submission protocol.
--   
--   This is used by local clients (like wallets and CLI tools) to submit
--   transactions to a local node.
module Ouroboros.Network.Protocol.LocalTxSubmission.Type

-- | The kind of the local transaction-submission protocol, and the types
--   of the states in the protocol state machine.
--   
--   It is parametrised over the type of transactions and the type of
--   reasons used when rejecting a transaction.
data LocalTxSubmission tx reject

-- | The client has agency; it can submit a transaction or terminate.
--   
--   There is no timeout in this state.
[StIdle] :: LocalTxSubmission tx reject

-- | The server has agency; it must process the submitted transaction and
--   either accept or reject it (with a reason).
--   
--   There is a timeout in this state. If the mempool is full and remains
--   so for a period then the transaction should be rejected with a
--   suitable temporary failure reason.
[StBusy] :: LocalTxSubmission tx reject

-- | Nobody has agency. The terminal state.
[StDone] :: LocalTxSubmission tx reject

-- | Isomorphic with Maybe but with a name that better describes its
--   purpose and usage.
data SubmitResult reason
SubmitSuccess :: SubmitResult reason
SubmitFail :: reason -> SubmitResult reason
instance GHC.Base.Functor Ouroboros.Network.Protocol.LocalTxSubmission.Type.SubmitResult
instance GHC.Classes.Eq reason => GHC.Classes.Eq (Ouroboros.Network.Protocol.LocalTxSubmission.Type.SubmitResult reason)
instance forall tx reject (from :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject) (to :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject). (GHC.Classes.Eq tx, GHC.Classes.Eq reject) => GHC.Classes.Eq (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject) from to)
instance forall tx reject (from :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject) (to :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject). (GHC.Show.Show tx, GHC.Show.Show reject) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject) from to)
instance forall k1 k2 (tx :: k1) (reject :: k2). (Ouroboros.Network.Util.ShowProxy.ShowProxy tx, Ouroboros.Network.Util.ShowProxy.ShowProxy reject) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject)
instance forall k1 k2 (tx :: k1) (reject :: k2). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject)
instance forall k1 k2 (tx :: k1) (reject :: k2) (st :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k1 k2 (tx :: k1) (reject :: k2) (st :: Ouroboros.Network.Protocol.LocalTxSubmission.Type.LocalTxSubmission tx reject). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)


-- | A view of the local transaction submission protocol from the point of
--   view of the server.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, a conversion into the typed protocol is provided.
module Ouroboros.Network.Protocol.LocalTxSubmission.Server

-- | The server side of the local transaction submission protocol.
--   
--   The peer in the client role submits transactions to the peer in the
--   server role.
data LocalTxSubmissionServer tx reject m a
LocalTxSubmissionServer :: (tx -> m (SubmitResult reject, LocalTxSubmissionServer tx reject m a)) -> a -> LocalTxSubmissionServer tx reject m a

-- | The client has submited a single transaction and it expects a reply.
--   
--   The server must reply to inform the client that it has either accepted
--   the transaction or rejected it. In the rejection case a reason for the
--   rejection is included.
[recvMsgSubmitTx] :: LocalTxSubmissionServer tx reject m a -> tx -> m (SubmitResult reject, LocalTxSubmissionServer tx reject m a)

-- | The client can terminate the protocol.
[recvMsgDone] :: LocalTxSubmissionServer tx reject m a -> a

-- | A non-pipelined <a>Peer</a> representing the
--   <a>LocalTxSubmissionServer</a>.
localTxSubmissionServerPeer :: forall tx reject m a. Monad m => m (LocalTxSubmissionServer tx reject m a) -> Peer (LocalTxSubmission tx reject) AsServer StIdle m a

module Ouroboros.Network.Protocol.LocalTxSubmission.Codec
codecLocalTxSubmission :: forall tx reject m. MonadST m => (tx -> Encoding) -> (forall s. Decoder s tx) -> (reject -> Encoding) -> (forall s. Decoder s reject) -> Codec (LocalTxSubmission tx reject) DeserialiseFailure m ByteString
codecLocalTxSubmissionId :: forall tx reject m. Monad m => Codec (LocalTxSubmission tx reject) CodecFailure m (AnyMessage (LocalTxSubmission tx reject))


-- | A view of the transaction submission protocol from the point of view
--   of the client.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, <a>localTxSubmissionClientPeer</a> is provided for
--   conversion into the typed protocol.
module Ouroboros.Network.Protocol.LocalTxSubmission.Client
newtype LocalTxSubmissionClient tx reject m a
LocalTxSubmissionClient :: m (LocalTxClientStIdle tx reject m a) -> LocalTxSubmissionClient tx reject m a
[runLocalTxSubmissionClient] :: LocalTxSubmissionClient tx reject m a -> m (LocalTxClientStIdle tx reject m a)

-- | The client side of the local transaction submission protocol.
--   
--   The peer in the client role submits transactions to the peer in the
--   server role.
data LocalTxClientStIdle tx reject m a

-- | The client submits a single transaction and waits a reply.
--   
--   The server replies to inform the client that it has either accepted
--   the transaction or rejected it. In the rejection case a reason for the
--   rejection is included.
[SendMsgSubmitTx] :: tx -> (SubmitResult reject -> m (LocalTxClientStIdle tx reject m a)) -> LocalTxClientStIdle tx reject m a

-- | The client can terminate the protocol.
[SendMsgDone] :: a -> LocalTxClientStIdle tx reject m a

-- | Isomorphic with Maybe but with a name that better describes its
--   purpose and usage.
data SubmitResult reason
SubmitSuccess :: SubmitResult reason
SubmitFail :: reason -> SubmitResult reason

-- | A non-pipelined <a>Peer</a> representing the
--   <a>LocalTxSubmissionClient</a>.
localTxSubmissionClientPeer :: forall tx reject m a. Monad m => LocalTxSubmissionClient tx reject m a -> Peer (LocalTxSubmission tx reject) AsClient StIdle m a

-- | A local tx submission client which never sends any message.

-- | <i>Deprecated: Use
--   Ouroboros.Network.NodeToClient.localTxSubmissionPeerNull</i>
localTxSubmissionClientNull :: MonadTimer m => LocalTxSubmissionClient tx reject m a

-- | Transform a <a>LocalTxSubmissionClient</a> by mapping over the tx and
--   the rejection errors.
--   
--   Note the direction of the individual mapping functions corresponds to
--   whether the types are used as protocol inputs or outputs.
mapLocalTxSubmissionClient :: forall tx tx' reject reject' m a. Functor m => (tx -> tx') -> (reject' -> reject) -> LocalTxSubmissionClient tx reject m a -> LocalTxSubmissionClient tx' reject' m a


-- | The type of the transaction submission protocol.
--   
--   This is used to relay transactions between nodes.
module Ouroboros.Network.Protocol.TxSubmission2.Type

-- | Transactions are typically not big, but in principle in future we
--   could have ones over 64k large.
type TxSizeInBytes = Word32

-- | The kind of the transaction-submission protocol, and the types of the
--   states in the protocol state machine.
--   
--   We describe this protocol using the label "client" for the peer that
--   is submitting transactions, and "server" for the one receiving them.
--   The protocol is however pull based, so it is typically the server that
--   has agency in this protocol. This is the opposite of the chain sync
--   and block fetch protocols, but that makes sense because the
--   information flow is also reversed: submitting transactions rather than
--   receiving headers and blocks.
--   
--   Because these client/server labels are somewhat confusing in this
--   case, we sometimes clarify by using the terms inbound and outbound.
--   This refers to whether transactions are flowing towards a peer or
--   away, and thus indicates what role the peer is playing.
data TxSubmission2 txid tx

-- | Initial protocol message.
[StInit] :: TxSubmission2 txid tx

-- | The server (inbound side) has agency; it can either terminate, ask for
--   transaction identifiers or ask for transactions.
--   
--   There is no timeout in this state.
[StIdle] :: TxSubmission2 txid tx

-- | The client (outbound side) has agency; it must reply with a list of
--   transaction identifiers that it wishes to submit.
--   
--   There are two sub-states for this, for blocking and non-blocking
--   cases.
[StTxIds] :: StBlockingStyle -> TxSubmission2 txid tx

-- | The client (outbound side) has agency; it must reply with the list of
--   transactions.
[StTxs] :: TxSubmission2 txid tx

-- | Nobody has agency; termination state.
[StDone] :: TxSubmission2 txid tx
data StBlockingStyle

-- | In this sub-state the reply need not be prompt. There is no timeout.
[StBlocking] :: StBlockingStyle

-- | In this state the peer must reply. There is a timeout.
[StNonBlocking] :: StBlockingStyle

-- | The value level equivalent of <a>StBlockingStyle</a>.
--   
--   This is also used in <a>MsgRequestTxIds</a> where it is interpreted
--   (and can be encoded) as a <a>Bool</a> with <a>True</a> for blocking,
--   and <a>False</a> for non-blocking.
data TokBlockingStyle (k :: StBlockingStyle)
[TokBlocking] :: TokBlockingStyle StBlocking
[TokNonBlocking] :: TokBlockingStyle StNonBlocking

-- | We have requests for lists of things. In the blocking case the
--   corresponding reply must be non-empty, whereas in the non-blocking
--   case and empty reply is fine.
data BlockingReplyList (blocking :: StBlockingStyle) a
[BlockingReply] :: NonEmpty a -> BlockingReplyList StBlocking a
[NonBlockingReply] :: [a] -> BlockingReplyList StNonBlocking a
instance GHC.Classes.Eq (Ouroboros.Network.Protocol.TxSubmission2.Type.TokBlockingStyle b)
instance GHC.Show.Show (Ouroboros.Network.Protocol.TxSubmission2.Type.TokBlockingStyle b)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Ouroboros.Network.Protocol.TxSubmission2.Type.BlockingReplyList blocking a)
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Protocol.TxSubmission2.Type.BlockingReplyList blocking a)
instance forall txid tx (from :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx) (to :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx). (GHC.Classes.Eq txid, GHC.Classes.Eq tx) => GHC.Classes.Eq (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx) from to)
instance forall txid tx (from :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx) (to :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx). (GHC.Show.Show txid, GHC.Show.Show tx) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx) from to)
instance forall k1 k2 (txid :: k1) (tx :: k2). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx)
instance forall k1 k2 (txid :: k1) (tx :: k2) (st :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k1 k2 (txid :: k1) (tx :: k2). (Ouroboros.Network.Util.ShowProxy.ShowProxy txid, Ouroboros.Network.Util.ShowProxy.ShowProxy tx) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx)
instance forall k1 k2 (txid :: k1) (tx :: k2). Ouroboros.Network.Util.ShowProxy.ShowProxy 'Ouroboros.Network.Protocol.TxSubmission2.Type.StIdle
instance forall k1 k2 (txid :: k1) (tx :: k2) (st :: Ouroboros.Network.Protocol.TxSubmission2.Type.TxSubmission2 txid tx). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)


-- | A view of the transaction submission protocol from the point of view
--   of the server.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, a conversion into the typed protocol is provided.
module Ouroboros.Network.Protocol.TxSubmission2.Server
data TxSubmissionServerPipelined txid tx m a
[TxSubmissionServerPipelined] :: m (ServerStIdle Z txid tx m a) -> TxSubmissionServerPipelined txid tx m a
data ServerStIdle (n :: N) txid tx m a

[SendMsgRequestTxIdsBlocking] :: Word16 -> Word16 -> m a -> (NonEmpty (txid, TxSizeInBytes) -> m (ServerStIdle Z txid tx m a)) -> ServerStIdle Z txid tx m a

[SendMsgRequestTxIdsPipelined] :: Word16 -> Word16 -> m (ServerStIdle (S n) txid tx m a) -> ServerStIdle n txid tx m a

[SendMsgRequestTxsPipelined] :: [txid] -> m (ServerStIdle (S n) txid tx m a) -> ServerStIdle n txid tx m a

-- | Collect a pipelined result.
[CollectPipelined] :: Maybe (ServerStIdle (S n) txid tx m a) -> (Collect txid tx -> m (ServerStIdle n txid tx m a)) -> ServerStIdle (S n) txid tx m a

-- | This is the type of the pipelined results, collected by
--   <a>CollectPipelined</a>. This protocol can pipeline requests for
--   transaction ids and transactions, so we use a sum of either for
--   collecting the responses.
data Collect txid tx

-- | The result of <a>SendMsgRequestTxIdsPipelined</a>. It also carries the
--   number of txids originally requested.
CollectTxIds :: Word16 -> [(txid, TxSizeInBytes)] -> Collect txid tx

-- | The result of <a>SendMsgRequestTxsPipelined</a>. The actual reply only
--   contains the transactions sent, but this pairs them up with the
--   transactions requested. This is because the peer can determine that
--   some transactions are no longer needed.
CollectTxs :: [txid] -> [tx] -> Collect txid tx

-- | Transactions are typically not big, but in principle in future we
--   could have ones over 64k large.
type TxSizeInBytes = Word32

-- | Transform a <a>TxSubmissionServerPipelined</a> into a
--   <a>PeerPipelined</a>.
txSubmissionServerPeerPipelined :: forall txid tx m a. Functor m => TxSubmissionServerPipelined txid tx m a -> PeerPipelined (TxSubmission2 txid tx) AsServer StInit m a

module Ouroboros.Network.Protocol.TxSubmission2.Codec
codecTxSubmission2 :: forall txid tx m. MonadST m => (txid -> Encoding) -> (forall s. Decoder s txid) -> (tx -> Encoding) -> (forall s. Decoder s tx) -> Codec (TxSubmission2 txid tx) DeserialiseFailure m ByteString
codecTxSubmission2Id :: forall txid tx m. Monad m => Codec (TxSubmission2 txid tx) CodecFailure m (AnyMessage (TxSubmission2 txid tx))
encodeTxSubmission2 :: forall txid tx. (txid -> Encoding) -> (tx -> Encoding) -> forall (pr :: PeerRole) (st :: TxSubmission2 txid tx) (st' :: TxSubmission2 txid tx). PeerHasAgency pr st -> Message (TxSubmission2 txid tx) st st' -> Encoding
decodeTxSubmission2 :: forall txid tx. (forall s. Decoder s txid) -> (forall s. Decoder s tx) -> forall (pr :: PeerRole) (st :: TxSubmission2 txid tx) s. PeerHasAgency pr st -> Int -> Word -> Decoder s (SomeMessage st)

-- | Byte Limits.
byteLimitsTxSubmission2 :: forall bytes txid tx. (bytes -> Word) -> ProtocolSizeLimits (TxSubmission2 txid tx) bytes

-- | Time Limits.
--   
--   `TokTxIds TokBlocking` No timeout `TokTxIds TokNonBlocking`
--   <a>shortWait</a> timeout <a>TokTxs</a> <a>shortWait</a> timeout
--   <a>TokIdle</a> <a>shortWait</a> timeout
timeLimitsTxSubmission2 :: forall txid tx. ProtocolTimeLimits (TxSubmission2 txid tx)


-- | A view of the transaction submission protocol from the point of view
--   of the client.
--   
--   This provides a view that uses less complex types and should be easier
--   to use than the underlying typed protocol itself.
--   
--   For execution, <a>txSubmissionClientPeer</a> is provided for
--   conversion into the typed protocol.
module Ouroboros.Network.Protocol.TxSubmission2.Client

-- | The client side of the transaction submission protocol.
--   
--   The peer in the client role submits transactions to the peer in the
--   server role.
newtype TxSubmissionClient txid tx m a
TxSubmissionClient :: m (ClientStIdle txid tx m a) -> TxSubmissionClient txid tx m a
[runTxSubmissionClient] :: TxSubmissionClient txid tx m a -> m (ClientStIdle txid tx m a)

-- | In the <a>StIdle</a> protocol state, the client does not have agency.
--   Instead it is waiting for:
--   
--   <ul>
--   <li>a request for transaction ids (blocking or non-blocking)</li>
--   <li>a request for a given list of transactions</li>
--   <li>a termination message</li>
--   </ul>
--   
--   It must be prepared to handle any of these.
data ClientStIdle txid tx m a
ClientStIdle :: (forall blocking. TokBlockingStyle blocking -> Word16 -> Word16 -> m (ClientStTxIds blocking txid tx m a)) -> ([txid] -> m (ClientStTxs txid tx m a)) -> ClientStIdle txid tx m a
[recvMsgRequestTxIds] :: ClientStIdle txid tx m a -> forall blocking. TokBlockingStyle blocking -> Word16 -> Word16 -> m (ClientStTxIds blocking txid tx m a)
[recvMsgRequestTxs] :: ClientStIdle txid tx m a -> [txid] -> m (ClientStTxs txid tx m a)
data ClientStTxIds blocking txid tx m a
[SendMsgReplyTxIds] :: BlockingReplyList blocking (txid, TxSizeInBytes) -> ClientStIdle txid tx m a -> ClientStTxIds blocking txid tx m a

-- | In the blocking case, the client can terminate the protocol. This
--   could be used when the client knows there will be no more transactions
--   to submit.
[SendMsgDone] :: a -> ClientStTxIds StBlocking txid tx m a
data ClientStTxs txid tx m a
[SendMsgReplyTxs] :: [tx] -> ClientStIdle txid tx m a -> ClientStTxs txid tx m a

-- | Transactions are typically not big, but in principle in future we
--   could have ones over 64k large.
type TxSizeInBytes = Word32

-- | The value level equivalent of <a>StBlockingStyle</a>.
--   
--   This is also used in <a>MsgRequestTxIds</a> where it is interpreted
--   (and can be encoded) as a <a>Bool</a> with <a>True</a> for blocking,
--   and <a>False</a> for non-blocking.
data TokBlockingStyle (k :: StBlockingStyle)
[TokBlocking] :: TokBlockingStyle StBlocking
[TokNonBlocking] :: TokBlockingStyle StNonBlocking

-- | We have requests for lists of things. In the blocking case the
--   corresponding reply must be non-empty, whereas in the non-blocking
--   case and empty reply is fine.
data BlockingReplyList (blocking :: StBlockingStyle) a
[BlockingReply] :: NonEmpty a -> BlockingReplyList StBlocking a
[NonBlockingReply] :: [a] -> BlockingReplyList StNonBlocking a

-- | A non-pipelined <a>Peer</a> representing the
--   <a>TxSubmissionClient</a>.
txSubmissionClientPeer :: forall txid tx m a. Monad m => TxSubmissionClient txid tx m a -> Peer (TxSubmission2 txid tx) AsClient StInit m a


-- | Concrete block
--   
--   The network library should not export a concrete block type at all,
--   except that it might need one in its tests (but not exported). Right
--   now this module serves to isolate this in a specific module so we can
--   identify easily where it is used; eventually it should be simplified
--   and then moved to the network layer tests; the more sophiscated block
--   abstraction (abstracted over an Ouroboros protocol) will live in the
--   consensus layer.
module Ouroboros.Network.Testing.ConcreteBlock

-- | Our highly-simplified version of a block. It retains the separation
--   between a block header and body, which is a detail needed for the
--   protocols.
data Block
Block :: BlockHeader -> BlockBody -> Block
[blockHeader] :: Block -> BlockHeader
[blockBody] :: Block -> BlockBody

-- | A block header. It retains simplified versions of all the essential
--   elements.
data BlockHeader
BlockHeader :: HeaderHash BlockHeader -> ChainHash BlockHeader -> SlotNo -> BlockNo -> BodyHash -> BlockHeader

-- | The cached <a>HeaderHash</a> of this header.
[headerHash] :: BlockHeader -> HeaderHash BlockHeader

-- | The <a>headerHash</a> of the previous block header
[headerPrevHash] :: BlockHeader -> ChainHash BlockHeader

-- | The Ouroboros time slot index of this block
[headerSlot] :: BlockHeader -> SlotNo

-- | The block index from the Genesis
[headerBlockNo] :: BlockHeader -> BlockNo

-- | The hash of the corresponding block body
[headerBodyHash] :: BlockHeader -> BodyHash
newtype BlockBody
BlockBody :: ByteString -> BlockBody

-- | Compute the <a>HeaderHash</a> of the <a>BlockHeader</a>.
hashHeader :: BlockHeader -> ConcreteHeaderHash

-- | The hash of all the information in a <a>BlockBody</a>.
newtype BodyHash
BodyHash :: Int -> BodyHash

-- | The hash of all the information in a <a>BlockHeader</a>.
newtype ConcreteHeaderHash
HeaderHash :: Int -> ConcreteHeaderHash
hashBody :: Hashable body => body -> BodyHash

-- | Arbitrarily but consistently converts slots UTCTimes.
--   
--   It is only intended for use in tests. Notably it assumes a fixed
--   system start time, slot length, and the absence of a hard fork (ie no
--   HardForkCombinator). This is how it's available as a pure function.
convertSlotToTimeForTestsAssumingNoHardFork :: SlotNo -> UTCTime

-- | This takes the blocks in order from <i>oldest to newest</i>.
mkChain :: [(SlotNo, BlockBody)] -> Chain Block
mkChainSimple :: [BlockBody] -> Chain Block
mkAnchoredFragment :: Anchor Block -> [(SlotNo, BlockBody)] -> AnchoredFragment Block
mkAnchoredFragmentSimple :: [BlockBody] -> AnchoredFragment Block
mkPartialBlock :: SlotNo -> BlockBody -> Block
mkPartialBlockHeader :: SlotNo -> BlockBody -> BlockHeader

-- | Fix up a block so that it fits on top of the given anchor. Only the
--   block number, the previous hash and the block hash are updated; the
--   slot number and the signers are kept intact.
fixupBlock :: HeaderHash block ~ HeaderHash BlockHeader => Anchor block -> Block -> Block

-- | Fixup block header to fit it on top of a chain. Only block number and
--   previous hash are updated; the slot and signer are kept unchanged.
fixupBlockHeader :: HeaderHash block ~ HeaderHash BlockHeader => Anchor block -> BlockHeader -> BlockHeader

-- | Fixup a block so to fit it on top of a given previous block.
fixupBlockAfterBlock :: Block -> Block -> Block

-- | Fix up the block number and hashes of a <a>Chain</a>. This also fixes
--   up the first block to chain-on from genesis, since by construction the
--   <a>Chain</a> type starts from genesis.
fixupChain :: HasFullHeader b => (Anchor b -> b -> b) -> [b] -> Chain b
fixupAnchoredFragmentFrom :: HasFullHeader b => Anchor b -> (Anchor b -> b -> b) -> [b] -> AnchoredFragment b
instance GHC.Generics.Generic Ouroboros.Network.Testing.ConcreteBlock.BlockBody
instance Data.String.IsString Ouroboros.Network.Testing.ConcreteBlock.BlockBody
instance GHC.Classes.Ord Ouroboros.Network.Testing.ConcreteBlock.BlockBody
instance GHC.Classes.Eq Ouroboros.Network.Testing.ConcreteBlock.BlockBody
instance GHC.Show.Show Ouroboros.Network.Testing.ConcreteBlock.BlockBody
instance NoThunks.Class.NoThunks Ouroboros.Network.Testing.ConcreteBlock.ConcreteHeaderHash
instance Data.Hashable.Class.Hashable Ouroboros.Network.Testing.ConcreteBlock.ConcreteHeaderHash
instance GHC.Generics.Generic Ouroboros.Network.Testing.ConcreteBlock.ConcreteHeaderHash
instance GHC.Classes.Ord Ouroboros.Network.Testing.ConcreteBlock.ConcreteHeaderHash
instance GHC.Classes.Eq Ouroboros.Network.Testing.ConcreteBlock.ConcreteHeaderHash
instance GHC.Show.Show Ouroboros.Network.Testing.ConcreteBlock.ConcreteHeaderHash
instance Data.Hashable.Class.Hashable Ouroboros.Network.Testing.ConcreteBlock.BodyHash
instance GHC.Generics.Generic Ouroboros.Network.Testing.ConcreteBlock.BodyHash
instance GHC.Classes.Ord Ouroboros.Network.Testing.ConcreteBlock.BodyHash
instance GHC.Classes.Eq Ouroboros.Network.Testing.ConcreteBlock.BodyHash
instance GHC.Show.Show Ouroboros.Network.Testing.ConcreteBlock.BodyHash
instance GHC.Generics.Generic Ouroboros.Network.Testing.ConcreteBlock.BlockHeader
instance GHC.Classes.Eq Ouroboros.Network.Testing.ConcreteBlock.BlockHeader
instance GHC.Show.Show Ouroboros.Network.Testing.ConcreteBlock.BlockHeader
instance GHC.Generics.Generic Ouroboros.Network.Testing.ConcreteBlock.Block
instance GHC.Classes.Eq Ouroboros.Network.Testing.ConcreteBlock.Block
instance GHC.Show.Show Ouroboros.Network.Testing.ConcreteBlock.Block
instance Data.Hashable.Class.Hashable Cardano.Slotting.Slot.SlotNo
instance Data.Hashable.Class.Hashable Cardano.Slotting.Block.BlockNo
instance Ouroboros.Network.Util.ShowProxy.ShowProxy Ouroboros.Network.Testing.ConcreteBlock.Block
instance Ouroboros.Network.Block.StandardHash Ouroboros.Network.Testing.ConcreteBlock.Block
instance Ouroboros.Network.Block.HasHeader Ouroboros.Network.Testing.ConcreteBlock.Block
instance Ouroboros.Network.Block.HasFullHeader Ouroboros.Network.Testing.ConcreteBlock.Block
instance Codec.Serialise.Class.Serialise Ouroboros.Network.Testing.ConcreteBlock.Block
instance Ouroboros.Network.Util.ShowProxy.ShowProxy Ouroboros.Network.Testing.ConcreteBlock.BlockHeader
instance Ouroboros.Network.Block.StandardHash Ouroboros.Network.Testing.ConcreteBlock.BlockHeader
instance Ouroboros.Network.Block.HasHeader Ouroboros.Network.Testing.ConcreteBlock.BlockHeader
instance Ouroboros.Network.Block.HasFullHeader Ouroboros.Network.Testing.ConcreteBlock.BlockHeader
instance Codec.Serialise.Class.Serialise Ouroboros.Network.Testing.ConcreteBlock.BlockHeader
instance Codec.Serialise.Class.Serialise Ouroboros.Network.Testing.ConcreteBlock.BodyHash
instance Codec.Serialise.Class.Serialise Ouroboros.Network.Testing.ConcreteBlock.ConcreteHeaderHash
instance Data.Hashable.Class.Hashable Ouroboros.Network.Testing.ConcreteBlock.BlockBody
instance Codec.Serialise.Class.Serialise Ouroboros.Network.Testing.ConcreteBlock.BlockBody
instance Data.Hashable.Class.Hashable (Ouroboros.Network.Block.HeaderHash b) => Data.Hashable.Class.Hashable (Ouroboros.Network.Block.ChainHash b)

module Ouroboros.Network.Tracers

-- | IP subscription tracers.
data NetworkSubscriptionTracers withIPList addr vNumber
NetworkSubscriptionTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> Tracer IO (WithAddr addr ErrorPolicyTrace) -> Tracer IO (withIPList (SubscriptionTrace addr)) -> NetworkSubscriptionTracers withIPList addr vNumber

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[nsMuxTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[nsHandshakeTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))

-- | error policy tracer; must not be <a>nullTracer</a>, otherwise all the
--   exceptions which are not matched by any error policy will be caught
--   and not logged or rethrown.
[nsErrorPolicyTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (WithAddr addr ErrorPolicyTrace)

-- | subscription tracers; it is infrequent it should not be
--   <a>nullTracer</a> by default.
[nsSubscriptionTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (withIPList (SubscriptionTrace addr))
type NetworkIPSubscriptionTracers addr vNumber = NetworkSubscriptionTracers WithIPList addr vNumber
nullNetworkSubscriptionTracers :: NetworkSubscriptionTracers withIPList addr vNumber

-- | DNS subscription tracers.
data NetworkDNSSubscriptionTracers vNumber addr
NetworkDNSSubscriptionTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> Tracer IO (WithAddr addr ErrorPolicyTrace) -> Tracer IO (WithDomainName (SubscriptionTrace addr)) -> Tracer IO (WithDomainName DnsTrace) -> NetworkDNSSubscriptionTracers vNumber addr

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[ndstMuxTracer] :: NetworkDNSSubscriptionTracers vNumber addr -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[ndstHandshakeTracer] :: NetworkDNSSubscriptionTracers vNumber addr -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))

-- | error policy tracer; must not be <a>nullTracer</a>, otherwise all the
--   exceptions which are not matched by any error policy will be caught
--   and not logged or rethrown.
[ndstErrorPolicyTracer] :: NetworkDNSSubscriptionTracers vNumber addr -> Tracer IO (WithAddr addr ErrorPolicyTrace)

-- | subscription tracer; it is infrequent it should not be
--   <a>nullTracer</a> by default.
[ndstSubscriptionTracer] :: NetworkDNSSubscriptionTracers vNumber addr -> Tracer IO (WithDomainName (SubscriptionTrace addr))

-- | dns resolver tracer; it is infrequent it should not be
--   <a>nullTracer</a> by default.
[ndstDnsTracer] :: NetworkDNSSubscriptionTracers vNumber addr -> Tracer IO (WithDomainName DnsTrace)
nullNetworkDNSSubscriptionTracers :: NetworkDNSSubscriptionTracers vNumber peerid


-- | This is the starting point for a module that will bring together the
--   overall node to client protocol, as a collection of mini-protocols.
module Ouroboros.Network.NodeToClient

-- | Make an <a>OuroborosApplication</a> for the bundle of mini-protocols
--   that make up the overall node-to-client protocol.
--   
--   This function specifies the wire format protocol numbers as well as
--   the protocols that run for each <a>NodeToClientVersion</a>.
--   
--   They are chosen to not overlap with the node to node protocol numbers.
--   This is not essential for correctness, but is helpful to allow a
--   single shared implementation of tools that can analyse both protocols,
--   e.g. wireshark plugins.
nodeToClientProtocols :: (ConnectionId addr -> STM m ControlMessage -> NodeToClientProtocols appType bytes m a b) -> NodeToClientVersion -> OuroborosApplication appType addr bytes m a b

-- | Recorod of node-to-client mini protocols.
data NodeToClientProtocols appType bytes m a b
NodeToClientProtocols :: RunMiniProtocol appType bytes m a b -> RunMiniProtocol appType bytes m a b -> RunMiniProtocol appType bytes m a b -> RunMiniProtocol appType bytes m a b -> NodeToClientProtocols appType bytes m a b

-- | local chain-sync mini-protocol
[localChainSyncProtocol] :: NodeToClientProtocols appType bytes m a b -> RunMiniProtocol appType bytes m a b

-- | local tx-submission mini-protocol
[localTxSubmissionProtocol] :: NodeToClientProtocols appType bytes m a b -> RunMiniProtocol appType bytes m a b

-- | local state-query mini-protocol
[localStateQueryProtocol] :: NodeToClientProtocols appType bytes m a b -> RunMiniProtocol appType bytes m a b

-- | local tx-monitor mini-protocol
[localTxMonitorProtocol] :: NodeToClientProtocols appType bytes m a b -> RunMiniProtocol appType bytes m a b

-- | Enumeration of node to client protocol versions.
data NodeToClientVersion

-- | enabled <tt>CardanoNodeToClientVersion7</tt>, i.e., Alonzo
NodeToClientV_9 :: NodeToClientVersion

-- | added <tt>GetChainBlockNo</tt> and <tt>GetChainPoint</tt> queries
NodeToClientV_10 :: NodeToClientVersion

-- | added <tt>GetRewardInfoPools</tt> Block query
NodeToClientV_11 :: NodeToClientVersion

-- | added <tt>LocalTxMonitor</tt> mini-protocol
NodeToClientV_12 :: NodeToClientVersion

-- | enabled <tt>CardanoNodeToClientVersion9</tt>, i.e., Babbage
NodeToClientV_13 :: NodeToClientVersion

-- | Version data for NodeToClient protocol v1
newtype NodeToClientVersionData
NodeToClientVersionData :: NetworkMagic -> NodeToClientVersionData
[networkMagic] :: NodeToClientVersionData -> NetworkMagic

-- | Tracer used by <a>connectToNode</a> (and derivatives, like
--   <a>connectTo</a> or 'Ouroboros.Network.NodeToClient.connectTo).
data NetworkConnectTracers addr vNumber
NetworkConnectTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> NetworkConnectTracers addr vNumber

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[nctMuxTracer] :: NetworkConnectTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[nctHandshakeTracer] :: NetworkConnectTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))
nullNetworkConnectTracers :: NetworkConnectTracers addr vNumber

-- | A specialised version of <a>connectToNode</a>. It is a general purpose
--   function which can connect using any version of the protocol. This is
--   mostly useful for future enhancements.
connectTo :: LocalSnocket -> NetworkConnectTracers LocalAddress NodeToClientVersion -> Versions NodeToClientVersion NodeToClientVersionData (OuroborosApplication InitiatorMode LocalAddress ByteString IO a b) -> FilePath -> IO ()

-- | Tracers required by a server which handles inbound connections.
data NetworkServerTracers addr vNumber
NetworkServerTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> Tracer IO (WithAddr addr ErrorPolicyTrace) -> Tracer IO AcceptConnectionsPolicyTrace -> NetworkServerTracers addr vNumber

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[nstMuxTracer] :: NetworkServerTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[nstHandshakeTracer] :: NetworkServerTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))

-- | error policy tracer; must not be <a>nullTracer</a>, otherwise all the
--   exceptions which are not matched by any error policy will be caught
--   and not logged or rethrown.
[nstErrorPolicyTracer] :: NetworkServerTracers addr vNumber -> Tracer IO (WithAddr addr ErrorPolicyTrace)

-- | tracing rate limiting of accepting connections.
[nstAcceptPolicyTracer] :: NetworkServerTracers addr vNumber -> Tracer IO AcceptConnectionsPolicyTrace
nullNetworkServerTracers :: NetworkServerTracers addr vNumber

-- | Mutable state maintained by the network component.
data NetworkMutableState addr
NetworkMutableState :: ConnectionTable IO addr -> StrictTVar IO (PeerStates IO addr) -> NetworkMutableState addr

-- | <a>ConnectionTable</a> which maintains information about current
--   upstream and downstream connections.
[nmsConnectionTable] :: NetworkMutableState addr -> ConnectionTable IO addr

-- | <a>PeerStates</a> which maintains state of each downstream / upstream
--   peer that errored, misbehaved or was not interesting to us.
[nmsPeerStates] :: NetworkMutableState addr -> StrictTVar IO (PeerStates IO addr)
newNetworkMutableState :: IO (NetworkMutableState addr)
newNetworkMutableStateSTM :: STM (NetworkMutableState addr)

-- | Clean <a>PeerStates</a> within <a>NetworkMutableState</a> every 200s
cleanNetworkMutableState :: NetworkMutableState addr -> IO ()

-- | A specialised version of <a>withServerNode</a>.
--   
--   Comments to <a>withServer</a> apply here as well.
withServer :: LocalSnocket -> NetworkServerTracers LocalAddress NodeToClientVersion -> NetworkMutableState LocalAddress -> LocalSocket -> Versions NodeToClientVersion NodeToClientVersionData (OuroborosApplication ResponderMode LocalAddress ByteString IO a b) -> ErrorPolicies -> IO Void
type NetworkClientSubcriptionTracers = NetworkSubscriptionTracers Identity LocalAddress NodeToClientVersion

-- | IP subscription tracers.
data NetworkSubscriptionTracers withIPList addr vNumber
NetworkSubscriptionTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> Tracer IO (WithAddr addr ErrorPolicyTrace) -> Tracer IO (withIPList (SubscriptionTrace addr)) -> NetworkSubscriptionTracers withIPList addr vNumber

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[nsMuxTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[nsHandshakeTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))

-- | error policy tracer; must not be <a>nullTracer</a>, otherwise all the
--   exceptions which are not matched by any error policy will be caught
--   and not logged or rethrown.
[nsErrorPolicyTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (WithAddr addr ErrorPolicyTrace)

-- | subscription tracers; it is infrequent it should not be
--   <a>nullTracer</a> by default.
[nsSubscriptionTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (withIPList (SubscriptionTrace addr))
data ClientSubscriptionParams a
ClientSubscriptionParams :: !LocalAddress -> !Maybe DiffTime -> !ErrorPolicies -> ClientSubscriptionParams a

-- | unix socket or named pipe address
[cspAddress] :: ClientSubscriptionParams a -> !LocalAddress

-- | delay between connection attempts
[cspConnectionAttemptDelay] :: ClientSubscriptionParams a -> !Maybe DiffTime

-- | error policies for subscription worker
[cspErrorPolicies] :: ClientSubscriptionParams a -> !ErrorPolicies

-- | <a>ncSubscriptionWorker</a> which starts given application versions on
--   each established connection.
ncSubscriptionWorker :: forall mode x y. HasInitiator mode ~ True => LocalSnocket -> NetworkClientSubcriptionTracers -> NetworkMutableState LocalAddress -> ClientSubscriptionParams () -> Versions NodeToClientVersion NodeToClientVersionData (OuroborosApplication mode LocalAddress ByteString IO x y) -> IO Void
chainSyncPeerNull :: forall (header :: Type) (point :: Type) (tip :: Type) m a. MonadTimer m => Peer (ChainSync header point tip) AsClient StIdle m a
localStateQueryPeerNull :: forall (block :: Type) (point :: Type) (query :: Type -> Type) m a. MonadTimer m => Peer (LocalStateQuery block point query) AsClient StIdle m a
localTxSubmissionPeerNull :: forall (tx :: Type) (reject :: Type) m a. MonadTimer m => Peer (LocalTxSubmission tx reject) AsClient StIdle m a
localTxMonitorPeerNull :: forall (txid :: Type) (tx :: Type) (slot :: Type) m a. MonadTimer m => Peer (LocalTxMonitor txid tx slot) AsClient StIdle m a

-- | This is public api to interact with the io manager; On Windows
--   <a>IOManager</a> holds <a>associateWithIOCompletionPort</a>; on other
--   platforms <a>IOManager</a> can run over any type, and thus is
--   guaranteed to be no-op.
newtype IOManager
IOManager :: (forall hole. () => hole -> IO ()) -> IOManager
[associateWithIOManager] :: IOManager -> forall hole. () => hole -> IO ()
type AssociateWithIOCP = IOManager

-- | <a>withIOManager</a> allows to do asynchronous io on Windows hiding
--   the differences between posix and Win32.
--   
--   It starts an io manger thread, which should be only one running at a
--   time, so the best place to call it is very close to the <tt>main</tt>
--   function and last for duration of the application.
--   
--   Async <a>IO</a> operations which are using the <tt>iocp</tt> port
--   should not leak out-side of <a>withIOManager</a>. They will be
--   silently cancelled when <a>withIOManager</a> exists. In particular one
--   should not return <a>IOManager</a> from <a>withIOManager</a>.
withIOManager :: WithIOManager

-- | System dependent LocalSnocket
type LocalSnocket = Snocket IO LocalSocket LocalAddress

-- | Create a <a>LocalSnocket</a>.
--   
--   On <i>Windows</i>, there is no way to get path associated to a named
--   pipe. To go around this, the address passed to <a>open</a> via
--   <a>LocalFamily</a> will be referenced by <a>LocalSocket</a>.
localSnocket :: IOManager -> LocalSnocket

-- | System dependent LocalSnocket type
newtype LocalSocket
LocalSocket :: LocalHandle -> LocalSocket
[getLocalHandle] :: LocalSocket -> LocalHandle

-- | Local address, on Unix is associated with <a>AF_UNIX</a> family, on
--   
--   Windows with `named-pipes`.
newtype LocalAddress
LocalAddress :: FilePath -> LocalAddress
[getFilePath] :: LocalAddress -> FilePath

-- | The version map supported by the local agent keyed on the version
--   identifier.
--   
--   Each <a>Version</a> contains a function which takes negotiated version
--   data and returns negotiated application (the <tt>r</tt> type
--   variable).
--   
--   If one needs to combine multiple versions the simplest way is to use
--   one of the combinators: <a>foldMapVersions</a>, <a>combineVersions</a>
--   or the <a>Semigroup</a> instance directly:
--   
--   <pre>
--   fold $ (simpleSingletonVersions ...)
--         :| [ (simpleSingletonVersions ...)
--            , (simpleSingletonVersions ...)
--            , ...
--            ]
--   </pre>
newtype Versions vNum vData r
Versions :: Map vNum (Version vData r) -> Versions vNum vData r
[getVersions] :: Versions vNum vData r -> Map vNum (Version vData r)

-- | <a>Versions</a> containing a single version of
--   <a>nodeToClientProtocols</a>.
versionedNodeToClientProtocols :: NodeToClientVersion -> NodeToClientVersionData -> (ConnectionId LocalAddress -> STM m ControlMessage -> NodeToClientProtocols appType bytes m a b) -> Versions NodeToClientVersion NodeToClientVersionData (OuroborosApplication appType LocalAddress bytes m a b)

-- | Singleton smart constructor for <a>Versions</a>.
simpleSingletonVersions :: vNum -> vData -> r -> Versions vNum vData r

-- | Useful for folding multiple <a>Versions</a>.
--   
--   A <a>foldMap</a> restricted to the <a>Versions</a> <a>Semigroup</a>.
--   
--   PRECONDITION: <tt>f x</tt> is non-empty.
foldMapVersions :: (Ord vNum, Foldable f, HasCallStack) => (x -> Versions vNum extra r) -> f x -> Versions vNum extra r
combineVersions :: (Ord vNum, Foldable f, HasCallStack) => f (Versions vNum extra r) -> Versions vNum extra r
nodeToClientHandshakeCodec :: MonadST m => Codec (Handshake NodeToClientVersion Term) DeserialiseFailure m ByteString

-- | We set 16ths bit to distinguish <tt>NodeToNodeVersion</tt> and
--   <a>NodeToClientVersion</a>. This way connecting wrong protocol suite
--   will fail during <tt>Handshake</tt> negotiation
--   
--   This is done in backward compatible way, so <tt>NodeToClientV_1</tt>
--   encoding is not changed.
nodeToClientVersionCodec :: CodecCBORTerm (Text, Maybe Int) NodeToClientVersion
nodeToClientCodecCBORTerm :: NodeToClientVersion -> CodecCBORTerm Text NodeToClientVersionData

-- | Connection is identified by local and remote address.
--   
--   TODO: the type variable which this data type fills in is called
--   <tt>peerid</tt>. We should renamed to <tt>connectionId</tt>.
data ConnectionId addr
ConnectionId :: !addr -> !addr -> ConnectionId addr
[localAddress] :: ConnectionId addr -> !addr
[remoteAddress] :: ConnectionId addr -> !addr
type LocalConnectionId = ConnectionId LocalAddress

-- | List of error policies for exception handling and a policy for handing
--   application return values.
data ErrorPolicies
ErrorPolicies :: [ErrorPolicy] -> [ErrorPolicy] -> ErrorPolicies

-- | Application Error Policies
[epAppErrorPolicies] :: ErrorPolicies -> [ErrorPolicy]

-- | <tt>connect</tt> Error Policies
[epConErrorPolicies] :: ErrorPolicies -> [ErrorPolicy]

-- | <a>ErrorPolicies</a> for client application. Additional rules can be
--   added by means of a <a>Semigroup</a> instance of <a>ErrorPolicies</a>.
--   
--   This error policies will try to preserve <tt>subscriptionWorker</tt>,
--   e.g. if the connect function throws an <a>IOException</a> we will
--   suspend it for a <tt>shortDelay</tt>, and try to re-connect.
--   
--   This allows to recover from a situation where a node temporarily
--   shutsdown, or running a client application which is subscribed two
--   more than one node (possibly over network).
networkErrorPolicies :: ErrorPolicies
nullErrorPolicies :: ErrorPolicies
data ErrorPolicy
[ErrorPolicy] :: forall e. Exception e => (e -> Maybe (SuspendDecision DiffTime)) -> ErrorPolicy

-- | Trace data for error policies
data ErrorPolicyTrace

-- | suspending peer with a given exception until
ErrorPolicySuspendPeer :: Maybe (ConnectionOrApplicationExceptionTrace SomeException) -> DiffTime -> DiffTime -> ErrorPolicyTrace

-- | suspending consumer until
ErrorPolicySuspendConsumer :: Maybe (ConnectionOrApplicationExceptionTrace SomeException) -> DiffTime -> ErrorPolicyTrace

-- | caught a local exception
ErrorPolicyLocalNodeError :: ConnectionOrApplicationExceptionTrace SomeException -> ErrorPolicyTrace

-- | resume a peer (both consumer and producer)
ErrorPolicyResumePeer :: ErrorPolicyTrace

-- | consumer was suspended until producer will resume
ErrorPolicyKeepSuspended :: ErrorPolicyTrace

-- | resume consumer
ErrorPolicyResumeConsumer :: ErrorPolicyTrace

-- | resume producer
ErrorPolicyResumeProducer :: ErrorPolicyTrace

-- | an application throwed an exception, which was not handled by any
--   <a>ErrorPolicy</a>.
ErrorPolicyUnhandledApplicationException :: SomeException -> ErrorPolicyTrace

-- | <tt>connect</tt> throwed an exception, which was not handled by any
--   <a>ErrorPolicy</a>.
ErrorPolicyUnhandledConnectionException :: SomeException -> ErrorPolicyTrace

-- | <tt>accept</tt> throwed an exception
ErrorPolicyAcceptException :: IOException -> ErrorPolicyTrace
data WithAddr addr a
WithAddr :: addr -> a -> WithAddr addr a
[wiaAddr] :: WithAddr addr a -> addr
[wiaEvent] :: WithAddr addr a -> a

-- | Semigroup of commands which acts on <a>PeerState</a>. The <tt>t</tt>
--   variable might be initiated to <a>DiffTime</a> or <tt>Time m</tt>.
--   
--   This semigroup allows to either suspend both consumer and producer or
--   just the consumer part.
data SuspendDecision t

-- | peer is suspend; The first <tt>t</tt> is the time until which a local
--   producer is suspended, the second one is the time until which a local
--   consumer is suspended.
SuspendPeer :: !t -> !t -> SuspendDecision t

-- | suspend local consumer / initiator side until <tt>t</tt> (this mean we
--   are not allowing to communicate with the producer / responder of a
--   remote peer).
SuspendConsumer :: !t -> SuspendDecision t

-- | throw an error from the main thread.
Throw :: SuspendDecision t

-- | Structured <a>Tracer</a> output for <a>runPeer</a> and derivitives.
data TraceSendRecv ps
[TraceSendMsg] :: forall ps. AnyMessageAndAgency ps -> TraceSendRecv ps
[TraceRecvMsg] :: forall ps. AnyMessageAndAgency ps -> TraceSendRecv ps
data ProtocolLimitFailure

-- | The handshake mini-protocol is used initially to agree the version and
--   associated parameters of the protocol to use for all subsequent
--   communication.
data Handshake (vNumber :: k) (vParams :: k1)
data LocalAddresses addr
LocalAddresses :: Maybe addr -> Maybe addr -> Maybe addr -> LocalAddresses addr

-- | Local IPv4 address to use, Nothing indicates don't use IPv4
[laIpv4] :: LocalAddresses addr -> Maybe addr

-- | Local IPv6 address to use, Nothing indicates don't use IPv6
[laIpv6] :: LocalAddresses addr -> Maybe addr

-- | Local Unix address to use, Nothing indicates don't use Unix sockets
[laUnix] :: LocalAddresses addr -> Maybe addr
data SubscriptionTrace addr
SubscriptionTraceConnectStart :: addr -> SubscriptionTrace addr
SubscriptionTraceConnectEnd :: addr -> ConnectResult -> SubscriptionTrace addr
SubscriptionTraceSocketAllocationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceConnectException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceApplicationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceTryConnectToPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSkippingPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSubscriptionRunning :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaiting :: Int -> SubscriptionTrace addr
SubscriptionTraceSubscriptionFailed :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaitingNewConnection :: DiffTime -> SubscriptionTrace addr
SubscriptionTraceStart :: Int -> SubscriptionTrace addr
SubscriptionTraceRestart :: DiffTime -> Int -> Int -> SubscriptionTrace addr
SubscriptionTraceConnectionExist :: addr -> SubscriptionTrace addr
SubscriptionTraceUnsupportedRemoteAddr :: addr -> SubscriptionTrace addr
SubscriptionTraceMissingLocalAddress :: SubscriptionTrace addr
SubscriptionTraceAllocateSocket :: addr -> SubscriptionTrace addr
SubscriptionTraceCloseSocket :: addr -> SubscriptionTrace addr
type HandshakeTr ntcAddr ntcVersion = WithMuxBearer (ConnectionId ntcAddr) (TraceSendRecv (Handshake ntcVersion Term))

module Ouroboros.Network.TxSubmission.Mempool.Reader

-- | The consensus layer functionality that the inbound and outbound side
--   of the tx submission logic requires.
--   
--   This is provided to the tx submission logic by the consensus layer.
data TxSubmissionMempoolReader txid tx idx m
TxSubmissionMempoolReader :: STM m (MempoolSnapshot txid tx idx) -> idx -> TxSubmissionMempoolReader txid tx idx m

-- | In STM, grab a snapshot of the contents of the mempool. This allows
--   further pure queries on the snapshot.
[mempoolGetSnapshot] :: TxSubmissionMempoolReader txid tx idx m -> STM m (MempoolSnapshot txid tx idx)

-- | <a>mempoolTxIdsAfter</a> with <a>mempoolZeroIdx</a> is expected to
--   give all txs currently in the mempool.
[mempoolZeroIdx] :: TxSubmissionMempoolReader txid tx idx m -> idx

-- | A pure snapshot of the contents of the mempool. It allows fetching
--   information about transactions in the mempool, and fetching individual
--   transactions.
--   
--   This uses a transaction sequence number type for identifying
--   transactions within the mempool sequence. The sequence number is local
--   to this mempool, unlike the transaction hash. This allows us to ask
--   for all transactions after a known sequence number, to get new
--   transactions. It is also used to look up individual transactions.
--   
--   Note that it is expected that <a>mempoolLookupTx</a> will often return
--   <a>Nothing</a> even for tx sequence numbers returned in previous
--   snapshots. This happens when the transaction has been removed from the
--   mempool between snapshots.
data MempoolSnapshot txid tx idx
MempoolSnapshot :: (idx -> [(txid, idx, TxSizeInBytes)]) -> (idx -> Maybe tx) -> (txid -> Bool) -> MempoolSnapshot txid tx idx
[mempoolTxIdsAfter] :: MempoolSnapshot txid tx idx -> idx -> [(txid, idx, TxSizeInBytes)]
[mempoolLookupTx] :: MempoolSnapshot txid tx idx -> idx -> Maybe tx
[mempoolHasTx] :: MempoolSnapshot txid tx idx -> txid -> Bool
mapMempoolSnapshot :: (tx -> tx') -> MempoolSnapshot txid tx idx -> MempoolSnapshot txid tx' idx
mapTxSubmissionMempoolReader :: MonadSTM m => (tx -> tx') -> TxSubmissionMempoolReader txid tx idx m -> TxSubmissionMempoolReader txid tx' idx m

module Ouroboros.Network.TxSubmission.Inbound
txSubmissionInbound :: forall txid tx idx m. (Ord txid, NoThunks txid, NoThunks tx, MonadSTM m, MonadThrow m) => Tracer m (TraceTxSubmissionInbound txid tx) -> Word16 -> TxSubmissionMempoolReader txid tx idx m -> TxSubmissionMempoolWriter txid tx idx m -> NodeToNodeVersion -> TxSubmissionServerPipelined txid tx m ()

-- | The consensus layer functionality that the inbound side of the tx
--   submission logic requires.
--   
--   This is provided to the tx submission logic by the consensus layer.
data TxSubmissionMempoolWriter txid tx idx m
TxSubmissionMempoolWriter :: (tx -> txid) -> ([tx] -> m [txid]) -> TxSubmissionMempoolWriter txid tx idx m

-- | Compute the transaction id from a transaction.
--   
--   This is used in the protocol handler to verify a full transaction
--   matches a previously given transaction id.
[txId] :: TxSubmissionMempoolWriter txid tx idx m -> tx -> txid

-- | Supply a batch of transactions to the mempool. They are either
--   accepted or rejected individually, but in the order supplied.
--   
--   The <tt>txid</tt>s of all transactions that were added successfully
--   are returned.
[mempoolAddTxs] :: TxSubmissionMempoolWriter txid tx idx m -> [tx] -> m [txid]
data TraceTxSubmissionInbound txid tx

-- | Number of transactions just about to be inserted.
TraceTxSubmissionCollected :: Int -> TraceTxSubmissionInbound txid tx

-- | Just processed transaction pass/fail breakdown.
TraceTxSubmissionProcessed :: ProcessedTxCount -> TraceTxSubmissionInbound txid tx

-- | Server received <tt>MsgDone</tt>
TraceTxInboundTerminated :: TraceTxSubmissionInbound txid tx
TraceTxInboundCanRequestMoreTxs :: Int -> TraceTxSubmissionInbound txid tx
TraceTxInboundCannotRequestMoreTxs :: Int -> TraceTxSubmissionInbound txid tx
data TxSubmissionProtocolError
ProtocolErrorTxNotRequested :: TxSubmissionProtocolError
ProtocolErrorTxIdsNotRequested :: TxSubmissionProtocolError
data ProcessedTxCount
ProcessedTxCount :: Int -> Int -> ProcessedTxCount

-- | Just accepted this many transactions.
[ptxcAccepted] :: ProcessedTxCount -> Int

-- | Just rejected this many transactions.
[ptxcRejected] :: ProcessedTxCount -> Int
instance GHC.Show.Show Ouroboros.Network.TxSubmission.Inbound.ProcessedTxCount
instance GHC.Classes.Eq Ouroboros.Network.TxSubmission.Inbound.ProcessedTxCount
instance GHC.Show.Show (Ouroboros.Network.TxSubmission.Inbound.TraceTxSubmissionInbound txid tx)
instance GHC.Classes.Eq (Ouroboros.Network.TxSubmission.Inbound.TraceTxSubmissionInbound txid tx)
instance GHC.Show.Show Ouroboros.Network.TxSubmission.Inbound.TxSubmissionProtocolError
instance GHC.Generics.Generic (Ouroboros.Network.TxSubmission.Inbound.ServerState txid tx)
instance (GHC.Show.Show txid, GHC.Show.Show tx) => GHC.Show.Show (Ouroboros.Network.TxSubmission.Inbound.ServerState txid tx)
instance (NoThunks.Class.NoThunks txid, NoThunks.Class.NoThunks tx) => NoThunks.Class.NoThunks (Ouroboros.Network.TxSubmission.Inbound.ServerState txid tx)
instance GHC.Exception.Type.Exception Ouroboros.Network.TxSubmission.Inbound.TxSubmissionProtocolError

module Ouroboros.Network.TxSubmission.Outbound
txSubmissionOutbound :: forall txid tx idx m. (Ord txid, Ord idx, MonadSTM m, MonadThrow m) => Tracer m (TraceTxSubmissionOutbound txid tx) -> Word16 -> TxSubmissionMempoolReader txid tx idx m -> NodeToNodeVersion -> ControlMessageSTM m -> TxSubmissionClient txid tx m ()
data TraceTxSubmissionOutbound txid tx

-- | The IDs of the transactions requested.
TraceTxSubmissionOutboundRecvMsgRequestTxs :: [txid] -> TraceTxSubmissionOutbound txid tx

-- | The transactions to be sent in the response.
TraceTxSubmissionOutboundSendMsgReplyTxs :: [tx] -> TraceTxSubmissionOutbound txid tx
TraceControlMessage :: ControlMessage -> TraceTxSubmissionOutbound txid tx
data TxSubmissionProtocolError
ProtocolErrorAckedTooManyTxids :: TxSubmissionProtocolError
ProtocolErrorRequestedNothing :: TxSubmissionProtocolError
ProtocolErrorRequestedTooManyTxids :: Word16 -> Word16 -> TxSubmissionProtocolError
ProtocolErrorRequestBlocking :: TxSubmissionProtocolError
ProtocolErrorRequestNonBlocking :: TxSubmissionProtocolError
ProtocolErrorRequestedUnavailableTx :: TxSubmissionProtocolError
instance (GHC.Show.Show txid, GHC.Show.Show tx) => GHC.Show.Show (Ouroboros.Network.TxSubmission.Outbound.TraceTxSubmissionOutbound txid tx)
instance GHC.Show.Show Ouroboros.Network.TxSubmission.Outbound.TxSubmissionProtocolError
instance GHC.Exception.Type.Exception Ouroboros.Network.TxSubmission.Outbound.TxSubmissionProtocolError


-- | This is the starting point for a module that will bring together the
--   overall node to node protocol, as a collection of mini-protocols.
module Ouroboros.Network.NodeToNode

-- | Make an <a>OuroborosApplication</a> for the bundle of mini-protocols
--   that make up the overall node-to-node protocol.
--   
--   This function specifies the wire format protocol numbers.
--   
--   The application specific protocol numbers start from 2. The
--   <tt><a>MiniProtocolNum</a> 0</tt> is reserved for the <a>Handshake</a>
--   protocol, while <tt><a>MiniProtocolNum</a> 1</tt> is reserved for
--   DeltaQ messages. <a>Handshake</a> protocol is not included in
--   <a>NodeToNodeProtocols</a> as it runs before mux is started but it
--   reusing <tt>MuxBearer</tt> to send and receive messages. Only when the
--   handshake protocol succeeds, we will know which protocols to run /
--   multiplex.
--   
--   These are chosen to not overlap with the node to client protocol
--   numbers (and the handshake protocol number). This is not essential for
--   correctness, but is helpful to allow a single shared implementation of
--   tools that can analyse both protocols, e.g. wireshark plugins.
nodeToNodeProtocols :: MiniProtocolParameters -> (ConnectionId addr -> STM m ControlMessage -> NodeToNodeProtocols muxMode bytes m a b) -> NodeToNodeVersion -> OuroborosBundle muxMode addr bytes m a b
data NodeToNodeProtocols appType bytes m a b
NodeToNodeProtocols :: RunMiniProtocol appType bytes m a b -> RunMiniProtocol appType bytes m a b -> RunMiniProtocol appType bytes m a b -> RunMiniProtocol appType bytes m a b -> NodeToNodeProtocols appType bytes m a b

-- | chain-sync mini-protocol
[chainSyncProtocol] :: NodeToNodeProtocols appType bytes m a b -> RunMiniProtocol appType bytes m a b

-- | block-fetch mini-protocol
[blockFetchProtocol] :: NodeToNodeProtocols appType bytes m a b -> RunMiniProtocol appType bytes m a b

-- | tx-submission mini-protocol
[txSubmissionProtocol] :: NodeToNodeProtocols appType bytes m a b -> RunMiniProtocol appType bytes m a b

-- | keep-alive mini-protocol
[keepAliveProtocol] :: NodeToNodeProtocols appType bytes m a b -> RunMiniProtocol appType bytes m a b
data MiniProtocolParameters
MiniProtocolParameters :: !Word32 -> !Word32 -> !Word -> !Word16 -> MiniProtocolParameters

-- | high threshold for pipelining (we will never exceed that many messages
--   pipelined).
[chainSyncPipeliningHighMark] :: MiniProtocolParameters -> !Word32

-- | low threshold: if we hit the <a>chainSyncPipeliningHighMark</a> we
--   will listen for responses until there are at most
--   <a>chainSyncPipeliningLowMark</a> pipelined message
--   
--   Must be smaller than <a>chainSyncPipeliningHighMark</a>.
--   
--   Note: <a>chainSyncPipeliningLowMark</a> and
--   <a>chainSyncPipeliningLowMark</a> are passed to
--   <tt>pipelineDecisionLowHighMark</tt>.
[chainSyncPipeliningLowMark] :: MiniProtocolParameters -> !Word32

-- | maximal number of pipelined messages in 'block-fetch' mini-protocol.
[blockFetchPipeliningMax] :: MiniProtocolParameters -> !Word

-- | maximal number of unacked tx (pipelining is bounded by twice this
--   number)
[txSubmissionMaxUnacked] :: MiniProtocolParameters -> !Word16
chainSyncProtocolLimits :: MiniProtocolParameters -> MiniProtocolLimits
blockFetchProtocolLimits :: MiniProtocolParameters -> MiniProtocolLimits
txSubmissionProtocolLimits :: MiniProtocolParameters -> MiniProtocolLimits
keepAliveProtocolLimits :: MiniProtocolParameters -> MiniProtocolLimits
defaultMiniProtocolParameters :: MiniProtocolParameters

-- | Enumeration of node to node protocol versions.
data NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>new <tt>KeepAlive</tt> codec</li>
--   <li>Enable <tt>CardanoNodeToNodeVersion5</tt>, i.e., Alonzo</li>
--   </ul>
NodeToNodeV_7 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Enable block diffusion pipelining in ChainSync and BlockFetch
--   logic.</li>
--   </ul>
NodeToNodeV_8 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Enable <tt>CardanoNodeToNodeVersion6</tt>, i.e., Babbage</li>
--   </ul>
NodeToNodeV_9 :: NodeToNodeVersion

-- | Changes:
--   
--   <ul>
--   <li>Enable full duplex connections. NOTE: This is an experimental
--   protocol version, which is not yet released. Until initial P2P version
--   it must be kept as the last version, which allows us to keep it as an
--   experimental version.</li>
--   </ul>
NodeToNodeV_10 :: NodeToNodeVersion

-- | Version data for NodeToNode protocol
data NodeToNodeVersionData
NodeToNodeVersionData :: !NetworkMagic -> !DiffusionMode -> NodeToNodeVersionData
[networkMagic] :: NodeToNodeVersionData -> !NetworkMagic
[diffusionMode] :: NodeToNodeVersionData -> !DiffusionMode

-- | Tracer used by <a>connectToNode</a> (and derivatives, like
--   <a>connectTo</a> or 'Ouroboros.Network.NodeToClient.connectTo).
data NetworkConnectTracers addr vNumber
NetworkConnectTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> NetworkConnectTracers addr vNumber

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[nctMuxTracer] :: NetworkConnectTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[nctHandshakeTracer] :: NetworkConnectTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))
nullNetworkConnectTracers :: NetworkConnectTracers addr vNumber

-- | A specialised version of <tt><a>connectToNode</a></tt>.
connectTo :: Snocket IO Socket SockAddr -> NetworkConnectTracers SockAddr NodeToNodeVersion -> Versions NodeToNodeVersion NodeToNodeVersionData (OuroborosApplication InitiatorMode SockAddr ByteString IO a b) -> Maybe SockAddr -> SockAddr -> IO ()

-- | Tracers required by a server which handles inbound connections.
data NetworkServerTracers addr vNumber
NetworkServerTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> Tracer IO (WithAddr addr ErrorPolicyTrace) -> Tracer IO AcceptConnectionsPolicyTrace -> NetworkServerTracers addr vNumber

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[nstMuxTracer] :: NetworkServerTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[nstHandshakeTracer] :: NetworkServerTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))

-- | error policy tracer; must not be <a>nullTracer</a>, otherwise all the
--   exceptions which are not matched by any error policy will be caught
--   and not logged or rethrown.
[nstErrorPolicyTracer] :: NetworkServerTracers addr vNumber -> Tracer IO (WithAddr addr ErrorPolicyTrace)

-- | tracing rate limiting of accepting connections.
[nstAcceptPolicyTracer] :: NetworkServerTracers addr vNumber -> Tracer IO AcceptConnectionsPolicyTrace
nullNetworkServerTracers :: NetworkServerTracers addr vNumber

-- | Mutable state maintained by the network component.
data NetworkMutableState addr
NetworkMutableState :: ConnectionTable IO addr -> StrictTVar IO (PeerStates IO addr) -> NetworkMutableState addr

-- | <a>ConnectionTable</a> which maintains information about current
--   upstream and downstream connections.
[nmsConnectionTable] :: NetworkMutableState addr -> ConnectionTable IO addr

-- | <a>PeerStates</a> which maintains state of each downstream / upstream
--   peer that errored, misbehaved or was not interesting to us.
[nmsPeerStates] :: NetworkMutableState addr -> StrictTVar IO (PeerStates IO addr)

-- | Policy which governs how to limit the number of accepted connections.
data AcceptedConnectionsLimit
AcceptedConnectionsLimit :: !Word32 -> !Word32 -> !DiffTime -> AcceptedConnectionsLimit

-- | Hard limit of accepted connections.
[acceptedConnectionsHardLimit] :: AcceptedConnectionsLimit -> !Word32

-- | Soft limit of accepted connections. If we are above this threshold, we
--   will start rate limiting.
[acceptedConnectionsSoftLimit] :: AcceptedConnectionsLimit -> !Word32

-- | Max delay for limiting accepted connections. We use linear regression
--   starting from 0 at the soft limit up to
--   <tt>acceptedConnectionDelay</tt> at the hard limit.
[acceptedConnectionsDelay] :: AcceptedConnectionsLimit -> !DiffTime
newNetworkMutableState :: IO (NetworkMutableState addr)
newNetworkMutableStateSTM :: STM (NetworkMutableState addr)

-- | Clean <a>PeerStates</a> within <a>NetworkMutableState</a> every 200s
cleanNetworkMutableState :: NetworkMutableState addr -> IO ()

-- | A specialised version of <tt><a>withServerNode</a></tt>. It forks a
--   thread which runs an accept loop (server thread):
--   
--   <ul>
--   <li>when the server thread throws an exception the main thread
--   rethrows it (by <a>wait</a>)</li>
--   <li>when an async exception is thrown to kill the main thread the
--   server thread will be cancelled as well (by <tt>withAsync</tt>)</li>
--   </ul>
withServer :: SocketSnocket -> NetworkServerTracers SockAddr NodeToNodeVersion -> NetworkMutableState SockAddr -> AcceptedConnectionsLimit -> Socket -> Versions NodeToNodeVersion NodeToNodeVersionData (OuroborosApplication ResponderMode SockAddr ByteString IO a b) -> ErrorPolicies -> IO Void

-- | A product of a <a>Domain</a> and <a>PortNumber</a>. After resolving
--   the domain we will use the <a>PortNumber</a> to form <a>SockAddr</a>.
data DomainAccessPoint
DomainAccessPoint :: !Domain -> !PortNumber -> DomainAccessPoint
[dapDomain] :: DomainAccessPoint -> !Domain
[dapPortNumber] :: DomainAccessPoint -> !PortNumber

-- | Should this peer be advertised to other peers asking for known peers?
--   For certain peers specified by configuration it would be an
--   appropriate policy to keep them private.
data PeerAdvertise
DoNotAdvertisePeer :: PeerAdvertise
DoAdvertisePeer :: PeerAdvertise

-- | Adjustable targets for the peer selection mechanism.
--   
--   These are used by the peer selection governor as targets. They are
--   used by the peer churn governor loop as knobs to adjust, to influence
--   the peer selection governor.
--   
--   The <i>known</i>, <i>established</i> and <i>active</i> peer targets
--   are targets both from below and from above: the governor will attempt
--   to grow or shrink the sets to hit these targets.
--   
--   Unlike the other targets, the <i>root</i> peer target is "one sided",
--   it is only a target from below. The governor does not try to shrink
--   the root set to hit it, it simply stops looking for more.
--   
--   There is also an implicit target that enough local root peers are
--   selected as active. This comes from the configuration for local roots,
--   and is not an independently adjustable target.
data PeerSelectionTargets
PeerSelectionTargets :: !Int -> !Int -> !Int -> !Int -> PeerSelectionTargets
[targetNumberOfRootPeers] :: PeerSelectionTargets -> !Int
[targetNumberOfKnownPeers] :: PeerSelectionTargets -> !Int
[targetNumberOfEstablishedPeers] :: PeerSelectionTargets -> !Int
[targetNumberOfActivePeers] :: PeerSelectionTargets -> !Int
data IPSubscriptionTarget
IPSubscriptionTarget :: ![SockAddr] -> !Int -> IPSubscriptionTarget

-- | List of destinations to possibly connect to
[ispIps] :: IPSubscriptionTarget -> ![SockAddr]

-- | Number of parallel connections to keep actice.
[ispValency] :: IPSubscriptionTarget -> !Int
type NetworkIPSubscriptionTracers addr vNumber = NetworkSubscriptionTracers WithIPList addr vNumber

-- | IP subscription tracers.
data NetworkSubscriptionTracers withIPList addr vNumber
NetworkSubscriptionTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> Tracer IO (WithAddr addr ErrorPolicyTrace) -> Tracer IO (withIPList (SubscriptionTrace addr)) -> NetworkSubscriptionTracers withIPList addr vNumber

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[nsMuxTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[nsHandshakeTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))

-- | error policy tracer; must not be <a>nullTracer</a>, otherwise all the
--   exceptions which are not matched by any error policy will be caught
--   and not logged or rethrown.
[nsErrorPolicyTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (WithAddr addr ErrorPolicyTrace)

-- | subscription tracers; it is infrequent it should not be
--   <a>nullTracer</a> by default.
[nsSubscriptionTracer] :: NetworkSubscriptionTracers withIPList addr vNumber -> Tracer IO (withIPList (SubscriptionTrace addr))
nullNetworkSubscriptionTracers :: NetworkSubscriptionTracers withIPList addr vNumber

-- | <a>ipSubscriptionWorker</a> and <tt>dnsSubscriptionWorker</tt>
--   parameters
data SubscriptionParams a target
SubscriptionParams :: LocalAddresses SockAddr -> (SockAddr -> Maybe DiffTime) -> ErrorPolicies -> target -> SubscriptionParams a target
[spLocalAddresses] :: SubscriptionParams a target -> LocalAddresses SockAddr

-- | should return expected delay for the given address
[spConnectionAttemptDelay] :: SubscriptionParams a target -> SockAddr -> Maybe DiffTime
[spErrorPolicies] :: SubscriptionParams a target -> ErrorPolicies
[spSubscriptionTarget] :: SubscriptionParams a target -> target
type IPSubscriptionParams a = SubscriptionParams a IPSubscriptionTarget

-- | <a>ipSubscriptionWorker</a> which starts given application versions on
--   each established connection.
ipSubscriptionWorker :: forall mode x y. HasInitiator mode ~ True => SocketSnocket -> NetworkIPSubscriptionTracers SockAddr NodeToNodeVersion -> NetworkMutableState SockAddr -> IPSubscriptionParams () -> Versions NodeToNodeVersion NodeToNodeVersionData (OuroborosApplication mode SockAddr ByteString IO x y) -> IO Void
data DnsSubscriptionTarget
DnsSubscriptionTarget :: !Domain -> !PortNumber -> !Int -> DnsSubscriptionTarget
[dstDomain] :: DnsSubscriptionTarget -> !Domain
[dstPort] :: DnsSubscriptionTarget -> !PortNumber
[dstValency] :: DnsSubscriptionTarget -> !Int
type DnsSubscriptionParams a = SubscriptionParams a DnsSubscriptionTarget

-- | DNS subscription tracers.
data NetworkDNSSubscriptionTracers vNumber addr
NetworkDNSSubscriptionTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> Tracer IO (WithAddr addr ErrorPolicyTrace) -> Tracer IO (WithDomainName (SubscriptionTrace addr)) -> Tracer IO (WithDomainName DnsTrace) -> NetworkDNSSubscriptionTracers vNumber addr

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[ndstMuxTracer] :: NetworkDNSSubscriptionTracers vNumber addr -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[ndstHandshakeTracer] :: NetworkDNSSubscriptionTracers vNumber addr -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))

-- | error policy tracer; must not be <a>nullTracer</a>, otherwise all the
--   exceptions which are not matched by any error policy will be caught
--   and not logged or rethrown.
[ndstErrorPolicyTracer] :: NetworkDNSSubscriptionTracers vNumber addr -> Tracer IO (WithAddr addr ErrorPolicyTrace)

-- | subscription tracer; it is infrequent it should not be
--   <a>nullTracer</a> by default.
[ndstSubscriptionTracer] :: NetworkDNSSubscriptionTracers vNumber addr -> Tracer IO (WithDomainName (SubscriptionTrace addr))

-- | dns resolver tracer; it is infrequent it should not be
--   <a>nullTracer</a> by default.
[ndstDnsTracer] :: NetworkDNSSubscriptionTracers vNumber addr -> Tracer IO (WithDomainName DnsTrace)
nullNetworkDNSSubscriptionTracers :: NetworkDNSSubscriptionTracers vNumber peerid

-- | <a>dnsSubscriptionWorker</a> which starts given application versions
--   on each established connection.
dnsSubscriptionWorker :: forall mode x y. HasInitiator mode ~ True => SocketSnocket -> NetworkDNSSubscriptionTracers NodeToNodeVersion SockAddr -> NetworkMutableState SockAddr -> DnsSubscriptionParams () -> Versions NodeToNodeVersion NodeToNodeVersionData (OuroborosApplication mode SockAddr ByteString IO x y) -> IO Void

-- | The version map supported by the local agent keyed on the version
--   identifier.
--   
--   Each <a>Version</a> contains a function which takes negotiated version
--   data and returns negotiated application (the <tt>r</tt> type
--   variable).
--   
--   If one needs to combine multiple versions the simplest way is to use
--   one of the combinators: <a>foldMapVersions</a>, <a>combineVersions</a>
--   or the <a>Semigroup</a> instance directly:
--   
--   <pre>
--   fold $ (simpleSingletonVersions ...)
--         :| [ (simpleSingletonVersions ...)
--            , (simpleSingletonVersions ...)
--            , ...
--            ]
--   </pre>
newtype Versions vNum vData r
Versions :: Map vNum (Version vData r) -> Versions vNum vData r
[getVersions] :: Versions vNum vData r -> Map vNum (Version vData r)

-- | The flag which indicates wheather the node runs only initiator or both
--   initiator or responder node. It does not however specify weather the
--   node is using duplex connections, this is implicit see
--   <tt>NodeToNodeV_4</tt>
data DiffusionMode
InitiatorOnlyDiffusionMode :: DiffusionMode
InitiatorAndResponderDiffusionMode :: DiffusionMode

-- | Singleton smart constructor for <a>Versions</a>.
simpleSingletonVersions :: vNum -> vData -> r -> Versions vNum vData r

-- | Useful for folding multiple <a>Versions</a>.
--   
--   A <a>foldMap</a> restricted to the <a>Versions</a> <a>Semigroup</a>.
--   
--   PRECONDITION: <tt>f x</tt> is non-empty.
foldMapVersions :: (Ord vNum, Foldable f, HasCallStack) => (x -> Versions vNum extra r) -> f x -> Versions vNum extra r
combineVersions :: (Ord vNum, Foldable f, HasCallStack) => f (Versions vNum extra r) -> Versions vNum extra r

-- | <a>Handshake</a> codec for the <tt>node-to-node</tt> protocol suite.
nodeToNodeHandshakeCodec :: MonadST m => Codec (Handshake NodeToNodeVersion Term) DeserialiseFailure m ByteString
nodeToNodeVersionCodec :: CodecCBORTerm (Text, Maybe Int) NodeToNodeVersion
nodeToNodeCodecCBORTerm :: NodeToNodeVersion -> CodecCBORTerm Text NodeToNodeVersionData

-- | Connection is identified by local and remote address.
--   
--   TODO: the type variable which this data type fills in is called
--   <tt>peerid</tt>. We should renamed to <tt>connectionId</tt>.
data ConnectionId addr
ConnectionId :: !addr -> !addr -> ConnectionId addr
[localAddress] :: ConnectionId addr -> !addr
[remoteAddress] :: ConnectionId addr -> !addr
type RemoteAddress = SockAddr
type RemoteConnectionId = ConnectionId RemoteAddress
data ProtocolLimitFailure

-- | The handshake mini-protocol is used initially to agree the version and
--   associated parameters of the protocol to use for all subsequent
--   communication.
data Handshake (vNumber :: k) (vParams :: k1)
data LocalAddresses addr
LocalAddresses :: Maybe addr -> Maybe addr -> Maybe addr -> LocalAddresses addr

-- | Local IPv4 address to use, Nothing indicates don't use IPv4
[laIpv4] :: LocalAddresses addr -> Maybe addr

-- | Local IPv6 address to use, Nothing indicates don't use IPv6
[laIpv6] :: LocalAddresses addr -> Maybe addr

-- | Local Unix address to use, Nothing indicates don't use Unix sockets
[laUnix] :: LocalAddresses addr -> Maybe addr

-- | Basic type for a socket.
data Socket

-- | Check whether a version enabling diffusion pipelining has been
--   negotiated.
isPipeliningEnabled :: NodeToNodeVersion -> Bool

-- | List of error policies for exception handling and a policy for handing
--   application return values.
data ErrorPolicies
ErrorPolicies :: [ErrorPolicy] -> [ErrorPolicy] -> ErrorPolicies

-- | Application Error Policies
[epAppErrorPolicies] :: ErrorPolicies -> [ErrorPolicy]

-- | <tt>connect</tt> Error Policies
[epConErrorPolicies] :: ErrorPolicies -> [ErrorPolicy]

-- | A minimal error policy for remote peers, which only handles exceptions
--   raised by `ouroboros-network`.
remoteNetworkErrorPolicy :: ErrorPolicies

-- | Error policy for local clients. This is equivalent to
--   <a>nullErrorPolicies</a>, but explicit in the errors which can be
--   caught.
--   
--   We are very permissive here, and very strict in the
--   <a>networkErrorPolicy</a>. After any failure the client will be killed
--   and not penalised by this policy. This allows to restart the local
--   client without a delay.
localNetworkErrorPolicy :: ErrorPolicies
nullErrorPolicies :: ErrorPolicies
data ErrorPolicy
[ErrorPolicy] :: forall e. Exception e => (e -> Maybe (SuspendDecision DiffTime)) -> ErrorPolicy

-- | Semigroup of commands which acts on <a>PeerState</a>. The <tt>t</tt>
--   variable might be initiated to <a>DiffTime</a> or <tt>Time m</tt>.
--   
--   This semigroup allows to either suspend both consumer and producer or
--   just the consumer part.
data SuspendDecision t

-- | peer is suspend; The first <tt>t</tt> is the time until which a local
--   producer is suspended, the second one is the time until which a local
--   consumer is suspended.
SuspendPeer :: !t -> !t -> SuspendDecision t

-- | suspend local consumer / initiator side until <tt>t</tt> (this mean we
--   are not allowing to communicate with the producer / responder of a
--   remote peer).
SuspendConsumer :: !t -> SuspendDecision t

-- | throw an error from the main thread.
Throw :: SuspendDecision t

-- | Trace for the <tt>AcceptConnectionsLimit</tt> policy.
data AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionRateLimiting :: DiffTime -> Int -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionHardLimit :: Word32 -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionResume :: Int -> AcceptConnectionsPolicyTrace

-- | Structured <a>Tracer</a> output for <a>runPeer</a> and derivitives.
data TraceSendRecv ps
[TraceSendMsg] :: forall ps. AnyMessageAndAgency ps -> TraceSendRecv ps
[TraceRecvMsg] :: forall ps. AnyMessageAndAgency ps -> TraceSendRecv ps
data SubscriptionTrace addr
SubscriptionTraceConnectStart :: addr -> SubscriptionTrace addr
SubscriptionTraceConnectEnd :: addr -> ConnectResult -> SubscriptionTrace addr
SubscriptionTraceSocketAllocationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceConnectException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceApplicationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceTryConnectToPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSkippingPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSubscriptionRunning :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaiting :: Int -> SubscriptionTrace addr
SubscriptionTraceSubscriptionFailed :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaitingNewConnection :: DiffTime -> SubscriptionTrace addr
SubscriptionTraceStart :: Int -> SubscriptionTrace addr
SubscriptionTraceRestart :: DiffTime -> Int -> Int -> SubscriptionTrace addr
SubscriptionTraceConnectionExist :: addr -> SubscriptionTrace addr
SubscriptionTraceUnsupportedRemoteAddr :: addr -> SubscriptionTrace addr
SubscriptionTraceMissingLocalAddress :: SubscriptionTrace addr
SubscriptionTraceAllocateSocket :: addr -> SubscriptionTrace addr
SubscriptionTraceCloseSocket :: addr -> SubscriptionTrace addr
data DnsTrace
DnsTraceLookupException :: SomeException -> DnsTrace
DnsTraceLookupAError :: DNSError -> DnsTrace
DnsTraceLookupAAAAError :: DNSError -> DnsTrace
DnsTraceLookupIPv6First :: DnsTrace
DnsTraceLookupIPv4First :: DnsTrace
DnsTraceLookupAResult :: [SockAddr] -> DnsTrace
DnsTraceLookupAAAAResult :: [SockAddr] -> DnsTrace

-- | Trace data for error policies
data ErrorPolicyTrace

-- | suspending peer with a given exception until
ErrorPolicySuspendPeer :: Maybe (ConnectionOrApplicationExceptionTrace SomeException) -> DiffTime -> DiffTime -> ErrorPolicyTrace

-- | suspending consumer until
ErrorPolicySuspendConsumer :: Maybe (ConnectionOrApplicationExceptionTrace SomeException) -> DiffTime -> ErrorPolicyTrace

-- | caught a local exception
ErrorPolicyLocalNodeError :: ConnectionOrApplicationExceptionTrace SomeException -> ErrorPolicyTrace

-- | resume a peer (both consumer and producer)
ErrorPolicyResumePeer :: ErrorPolicyTrace

-- | consumer was suspended until producer will resume
ErrorPolicyKeepSuspended :: ErrorPolicyTrace

-- | resume consumer
ErrorPolicyResumeConsumer :: ErrorPolicyTrace

-- | resume producer
ErrorPolicyResumeProducer :: ErrorPolicyTrace

-- | an application throwed an exception, which was not handled by any
--   <a>ErrorPolicy</a>.
ErrorPolicyUnhandledApplicationException :: SomeException -> ErrorPolicyTrace

-- | <tt>connect</tt> throwed an exception, which was not handled by any
--   <a>ErrorPolicy</a>.
ErrorPolicyUnhandledConnectionException :: SomeException -> ErrorPolicyTrace

-- | <tt>accept</tt> throwed an exception
ErrorPolicyAcceptException :: IOException -> ErrorPolicyTrace
data WithIPList a
WithIPList :: LocalAddresses SockAddr -> [SockAddr] -> a -> WithIPList a
[wilSrc] :: WithIPList a -> LocalAddresses SockAddr
[wilDsts] :: WithIPList a -> [SockAddr]
[wilEvent] :: WithIPList a -> a
data WithDomainName a
WithDomainName :: Domain -> a -> WithDomainName a
[wdnDomain] :: WithDomainName a -> Domain
[wdnEvent] :: WithDomainName a -> a
data WithAddr addr a
WithAddr :: addr -> a -> WithAddr addr a
[wiaAddr] :: WithAddr addr a -> addr
[wiaEvent] :: WithAddr addr a -> a
type HandshakeTr ntnAddr ntnVersion = WithMuxBearer (ConnectionId ntnAddr) (TraceSendRecv (Handshake ntnVersion Term))
chainSyncMiniProtocolNum :: MiniProtocolNum
blockFetchMiniProtocolNum :: MiniProtocolNum
txSubmissionMiniProtocolNum :: MiniProtocolNum
keepAliveMiniProtocolNum :: MiniProtocolNum

module Ouroboros.Network.PeerSelection.PeerMetric
maxEntriesToTrack :: Int
type SlotMetric p = IntPSQ SlotNo (p, Time)
data PeerMetrics m p
PeerMetrics :: StrictTVar m (SlotMetric p) -> StrictTVar m (SlotMetric (p, SizeInBytes)) -> PeerMetrics m p
[headerMetrics] :: PeerMetrics m p -> StrictTVar m (SlotMetric p)
[fetchedMetrics] :: PeerMetrics m p -> StrictTVar m (SlotMetric (p, SizeInBytes))
reportMetric :: forall m p. MonadSTM m => PeerMetrics m p -> ReportPeerMetrics m (ConnectionId p)
nullMetric :: MonadSTM m => ReportPeerMetrics m p
slotMetricKey :: SlotNo -> Int
headerMetricTracer :: forall m p. MonadSTM m => PeerMetrics m p -> Tracer (STM m) (TraceLabelPeer (ConnectionId p) (SlotNo, Time))
fetchedMetricTracer :: forall m p. MonadSTM m => PeerMetrics m p -> Tracer (STM m) (TraceLabelPeer (ConnectionId p) (SizeInBytes, SlotNo, Time))
getHeaderMetrics :: MonadSTM m => PeerMetrics m p -> STM m (SlotMetric p)
getFetchedMetrics :: MonadSTM m => PeerMetrics m p -> STM m (SlotMetric (p, SizeInBytes))
metricsTracer :: forall m p. MonadSTM m => StrictTVar m (SlotMetric p) -> Tracer (STM m) (TraceLabelPeer p (SlotNo, Time))
newPeerMetric :: MonadSTM m => m (PeerMetrics m p)
upstreamyness :: forall p. Ord p => SlotMetric p -> Map p Int
fetchynessBytes :: forall p. Ord p => SlotMetric (p, SizeInBytes) -> Map p Int
fetchynessBlocks :: forall p. Ord p => SlotMetric (p, SizeInBytes) -> Map p Int

module Ouroboros.Network.Diffusion.Policies

-- | Timeout for <tt>spsDeactivateTimeout</tt>.
--   
--   The maximal timeout on <tt>ChainSync</tt> (in <tt>StMustReply</tt>
--   state) is <tt>269s</tt>.
deactivateTimeout :: DiffTime

-- | Timeout for <tt>spsCloseConnectionTimeout</tt>.
--   
--   This timeout depends on <tt>KeepAlive</tt> and <tt>TipSample</tt>
--   timeouts. <tt>KeepAlive</tt> keeps agancy most of the time, but
--   <tt>TipSample</tt> can give away its agency for longer periods of
--   time. Here we allow it to get 6 blocks (assuming a new block every
--   <tt>20s</tt>).
closeConnectionTimeout :: DiffTime
simplePeerSelectionPolicy :: forall m peerAddr. (MonadSTM m, Ord peerAddr) => StrictTVar m StdGen -> STM m ChurnMode -> PeerMetrics m peerAddr -> PeerSelectionPolicy peerAddr m

-- | Sort by upstreamness and a random score.
--   
--   Note: this <a>PrunePolicy</a> does not depend on
--   <tt>igsConnections</tt>. We put <tt>igsPrng</tt> in
--   <tt>InboundGovernorState</tt> only to show that we can have a
--   <a>PrunePolicy</a> which depends on the <tt>InboundGovernorState</tt>
--   as a more refined policy would do.
--   
--   <i>complexity:</i> &lt;math&gt;
--   
--   TODO: complexity could be improved.
prunePolicy :: (MonadSTM m, Ord peerAddr) => StrictTVar m InboundGovernorObservableState -> PrunePolicy peerAddr (STM m)


-- | This subsystem manages the discovery and selection of <i>upstream</i>
--   peers.
module Ouroboros.Network.PeerSelection.Governor
data PeerSelectionPolicy peeraddr m
PeerSelectionPolicy :: PickPolicy peeraddr m -> PickPolicy peeraddr m -> PickPolicy peeraddr m -> PickPolicy peeraddr m -> PickPolicy peeraddr m -> PickPolicy peeraddr m -> !DiffTime -> !Int -> !DiffTime -> !DiffTime -> !DiffTime -> PeerSelectionPolicy peeraddr m
[policyPickKnownPeersForGossip] :: PeerSelectionPolicy peeraddr m -> PickPolicy peeraddr m
[policyPickColdPeersToPromote] :: PeerSelectionPolicy peeraddr m -> PickPolicy peeraddr m
[policyPickWarmPeersToPromote] :: PeerSelectionPolicy peeraddr m -> PickPolicy peeraddr m
[policyPickHotPeersToDemote] :: PeerSelectionPolicy peeraddr m -> PickPolicy peeraddr m
[policyPickWarmPeersToDemote] :: PeerSelectionPolicy peeraddr m -> PickPolicy peeraddr m
[policyPickColdPeersToForget] :: PeerSelectionPolicy peeraddr m -> PickPolicy peeraddr m
[policyFindPublicRootTimeout] :: PeerSelectionPolicy peeraddr m -> !DiffTime
[policyMaxInProgressGossipReqs] :: PeerSelectionPolicy peeraddr m -> !Int
[policyGossipRetryTime] :: PeerSelectionPolicy peeraddr m -> !DiffTime
[policyGossipBatchWaitTime] :: PeerSelectionPolicy peeraddr m -> !DiffTime
[policyGossipOverallTimeout] :: PeerSelectionPolicy peeraddr m -> !DiffTime

-- | Adjustable targets for the peer selection mechanism.
--   
--   These are used by the peer selection governor as targets. They are
--   used by the peer churn governor loop as knobs to adjust, to influence
--   the peer selection governor.
--   
--   The <i>known</i>, <i>established</i> and <i>active</i> peer targets
--   are targets both from below and from above: the governor will attempt
--   to grow or shrink the sets to hit these targets.
--   
--   Unlike the other targets, the <i>root</i> peer target is "one sided",
--   it is only a target from below. The governor does not try to shrink
--   the root set to hit it, it simply stops looking for more.
--   
--   There is also an implicit target that enough local root peers are
--   selected as active. This comes from the configuration for local roots,
--   and is not an independently adjustable target.
data PeerSelectionTargets
PeerSelectionTargets :: !Int -> !Int -> !Int -> !Int -> PeerSelectionTargets
[targetNumberOfRootPeers] :: PeerSelectionTargets -> !Int
[targetNumberOfKnownPeers] :: PeerSelectionTargets -> !Int
[targetNumberOfEstablishedPeers] :: PeerSelectionTargets -> !Int
[targetNumberOfActivePeers] :: PeerSelectionTargets -> !Int

-- | Actions performed by the peer selection governor.
--   
--   These being pluggable allows:
--   
--   <ul>
--   <li>choice of known peer root sets</li>
--   <li>running both in simulation and for real</li>
--   </ul>
data PeerSelectionActions peeraddr peerconn m
PeerSelectionActions :: STM m PeerSelectionTargets -> STM m [(Int, Map peeraddr PeerAdvertise)] -> (Int -> m (Set peeraddr, DiffTime)) -> (peeraddr -> m [peeraddr]) -> PeerStateActions peeraddr peerconn m -> PeerSelectionActions peeraddr peerconn m
[readPeerSelectionTargets] :: PeerSelectionActions peeraddr peerconn m -> STM m PeerSelectionTargets

-- | Read the current set of locally or privately known root peers.
--   
--   In general this is expected to be updated asynchronously by some other
--   thread. It is intended to cover the use case of peers from local
--   configuration. It could be dynamic due to DNS resolution, or due to
--   dynamic configuration updates.
--   
--   It is structured as a collection of (non-overlapping) groups of peers
--   where we are supposed to select n from each group.
[readLocalRootPeers] :: PeerSelectionActions peeraddr peerconn m -> STM m [(Int, Map peeraddr PeerAdvertise)]

-- | Request a sample of public root peers.
--   
--   It is intended to cover use cases including:
--   
--   <ul>
--   <li>federated relays from a DNS pool</li>
--   <li>stake pool relays published in the blockchain</li>
--   <li>a pre-distributed snapshot of stake pool relays from the
--   blockchain</li>
--   </ul>
[requestPublicRootPeers] :: PeerSelectionActions peeraddr peerconn m -> Int -> m (Set peeraddr, DiffTime)

-- | The action to contact a known peer and request a sample of its known
--   peers.
--   
--   This is synchronous, but it should expect to be interrupted by a
--   timeout asynchronous exception. Failures are throw as exceptions.
[requestPeerGossip] :: PeerSelectionActions peeraddr peerconn m -> peeraddr -> m [peeraddr]

-- | Core actions run by the governor to change <a>PeerStatus</a>.
[peerStateActions] :: PeerSelectionActions peeraddr peerconn m -> PeerStateActions peeraddr peerconn m

-- | Callbacks which are performed to change peer state.
data PeerStateActions peeraddr peerconn m
PeerStateActions :: (peerconn -> STM m PeerStatus) -> (peeraddr -> m peerconn) -> (peerconn -> m ()) -> (peerconn -> m ()) -> (peerconn -> m ()) -> PeerStateActions peeraddr peerconn m

-- | Monitor peer state.
[monitorPeerConnection] :: PeerStateActions peeraddr peerconn m -> peerconn -> STM m PeerStatus

-- | Establish new connection.
[establishPeerConnection] :: PeerStateActions peeraddr peerconn m -> peeraddr -> m peerconn

-- | Activate a connection: warm to hot promotion.
[activatePeerConnection] :: PeerStateActions peeraddr peerconn m -> peerconn -> m ()

-- | Deactive a peer: hot to warm demotion.
[deactivatePeerConnection] :: PeerStateActions peeraddr peerconn m -> peerconn -> m ()

-- | Close a connection: warm to cold transition.
[closePeerConnection] :: PeerStateActions peeraddr peerconn m -> peerconn -> m ()
data TracePeerSelection peeraddr
TraceLocalRootPeersChanged :: LocalRootPeers peeraddr -> LocalRootPeers peeraddr -> TracePeerSelection peeraddr
TraceTargetsChanged :: PeerSelectionTargets -> PeerSelectionTargets -> TracePeerSelection peeraddr
TracePublicRootsRequest :: Int -> Int -> TracePeerSelection peeraddr
TracePublicRootsResults :: Set peeraddr -> Int -> DiffTime -> TracePeerSelection peeraddr
TracePublicRootsFailure :: SomeException -> Int -> DiffTime -> TracePeerSelection peeraddr

-- | target known peers, actual known peers, peers available for gossip,
--   peers selected for gossip
TraceGossipRequests :: Int -> Int -> Set peeraddr -> Set peeraddr -> TracePeerSelection peeraddr
TraceGossipResults :: [(peeraddr, Either SomeException [peeraddr])] -> TracePeerSelection peeraddr

-- | target known peers, actual known peers, selected peer
TraceForgetColdPeers :: Int -> Int -> Set peeraddr -> TracePeerSelection peeraddr

-- | target established, actual established, selected peers
TracePromoteColdPeers :: Int -> Int -> Set peeraddr -> TracePeerSelection peeraddr

-- | target local established, actual local established, selected peers
TracePromoteColdLocalPeers :: Int -> Int -> Set peeraddr -> TracePeerSelection peeraddr

-- | target established, actual established, peer, delay until next
--   promotion, reason
TracePromoteColdFailed :: Int -> Int -> peeraddr -> DiffTime -> SomeException -> TracePeerSelection peeraddr

-- | target established, actual established, peer
TracePromoteColdDone :: Int -> Int -> peeraddr -> TracePeerSelection peeraddr

-- | target active, actual active, selected peers
TracePromoteWarmPeers :: Int -> Int -> Set peeraddr -> TracePeerSelection peeraddr

-- | local per-group (target active, actual active), selected peers
TracePromoteWarmLocalPeers :: [(Int, Int)] -> Set peeraddr -> TracePeerSelection peeraddr

-- | target active, actual active, peer, reason
TracePromoteWarmFailed :: Int -> Int -> peeraddr -> SomeException -> TracePeerSelection peeraddr

-- | target active, actual active, peer
TracePromoteWarmDone :: Int -> Int -> peeraddr -> TracePeerSelection peeraddr

-- | aborted promotion of a warm peer; likely it was asynchronously demoted
--   in the meantime.
--   
--   target active, actual active, peer
TracePromoteWarmAborted :: Int -> Int -> peeraddr -> TracePeerSelection peeraddr

-- | target established, actual established, selected peers
TraceDemoteWarmPeers :: Int -> Int -> Set peeraddr -> TracePeerSelection peeraddr

-- | target established, actual established, peer, reason
TraceDemoteWarmFailed :: Int -> Int -> peeraddr -> SomeException -> TracePeerSelection peeraddr

-- | target established, actual established, peer
TraceDemoteWarmDone :: Int -> Int -> peeraddr -> TracePeerSelection peeraddr

-- | target active, actual active, selected peers
TraceDemoteHotPeers :: Int -> Int -> Set peeraddr -> TracePeerSelection peeraddr

-- | local per-group (target active, actual active), selected peers
TraceDemoteLocalHotPeers :: [(Int, Int)] -> Set peeraddr -> TracePeerSelection peeraddr

-- | target active, actual active, peer, reason
TraceDemoteHotFailed :: Int -> Int -> peeraddr -> SomeException -> TracePeerSelection peeraddr

-- | target active, actual active, peer
TraceDemoteHotDone :: Int -> Int -> peeraddr -> TracePeerSelection peeraddr
TraceDemoteAsynchronous :: Map peeraddr PeerStatus -> TracePeerSelection peeraddr
TraceGovernorWakeup :: TracePeerSelection peeraddr
TraceChurnWait :: DiffTime -> TracePeerSelection peeraddr
TraceChurnMode :: ChurnMode -> TracePeerSelection peeraddr
data DebugPeerSelection peeraddr peerconn
TraceGovernorState :: Time -> Maybe DiffTime -> PeerSelectionState peeraddr peerconn -> DebugPeerSelection peeraddr peerconn

peerSelectionGovernor :: (MonadAsync m, MonadLabelledSTM m, MonadMask m, MonadTime m, MonadTimer m, Ord peeraddr) => Tracer m (TracePeerSelection peeraddr) -> Tracer m (DebugPeerSelection peeraddr peerconn) -> Tracer m PeerSelectionCounters -> StdGen -> PeerSelectionActions peeraddr peerconn m -> PeerSelectionPolicy peeraddr m -> m Void

peerChurnGovernor :: forall m peeraddr. (MonadSTM m, MonadMonotonicTime m, MonadDelay m) => Tracer m (TracePeerSelection peeraddr) -> PeerMetrics m peeraddr -> StrictTVar m ChurnMode -> StdGen -> STM m FetchMode -> PeerSelectionTargets -> StrictTVar m PeerSelectionTargets -> m Void
assertPeerSelectionState :: Ord peeraddr => PeerSelectionState peeraddr peerconn -> a -> a
sanePeerSelectionTargets :: PeerSelectionTargets -> Bool

-- | A view of the status of each established peer, for testing and
--   debugging.
establishedPeersStatus :: Ord peeraddr => PeerSelectionState peeraddr peerconn -> Map peeraddr PeerStatus

-- | The internal state used by the <tt>peerSelectionGovernor</tt>.
--   
--   The local and public root sets are disjoint, and their union is the
--   overall root set.
data PeerSelectionState peeraddr peerconn
PeerSelectionState :: !PeerSelectionTargets -> !LocalRootPeers peeraddr -> !Set peeraddr -> !KnownPeers peeraddr -> !EstablishedPeers peeraddr peerconn -> !Set peeraddr -> !Int -> !Time -> !Bool -> !Int -> !Set peeraddr -> !Set peeraddr -> !Set peeraddr -> !Set peeraddr -> !StdGen -> !Cache PeerSelectionCounters -> PeerSelectionState peeraddr peerconn
[targets] :: PeerSelectionState peeraddr peerconn -> !PeerSelectionTargets

-- | The current set of local root peers. This is structured as a bunch of
--   groups, with a target for each group. This gives us a set of n-of-m
--   choices, e.g. "pick 2 from this group and 1 from this group".
--   
--   The targets must of course be achievable, and to keep things simple,
--   the groups must be disjoint.
[localRootPeers] :: PeerSelectionState peeraddr peerconn -> !LocalRootPeers peeraddr
[publicRootPeers] :: PeerSelectionState peeraddr peerconn -> !Set peeraddr

[knownPeers] :: PeerSelectionState peeraddr peerconn -> !KnownPeers peeraddr

[establishedPeers] :: PeerSelectionState peeraddr peerconn -> !EstablishedPeers peeraddr peerconn

[activePeers] :: PeerSelectionState peeraddr peerconn -> !Set peeraddr

-- | A counter to manage the exponential backoff strategy for when to retry
--   querying for more public root peers. It is negative for retry counts
--   after failure, and positive for retry counts that are successful but
--   make no progress.
[publicRootBackoffs] :: PeerSelectionState peeraddr peerconn -> !Int

-- | The earliest time we would be prepared to request more public root
--   peers. This is used with the <a>publicRootBackoffs</a> to manage the
--   exponential backoff.
[publicRootRetryTime] :: PeerSelectionState peeraddr peerconn -> !Time
[inProgressPublicRootsReq] :: PeerSelectionState peeraddr peerconn -> !Bool
[inProgressGossipReqs] :: PeerSelectionState peeraddr peerconn -> !Int
[inProgressPromoteCold] :: PeerSelectionState peeraddr peerconn -> !Set peeraddr
[inProgressPromoteWarm] :: PeerSelectionState peeraddr peerconn -> !Set peeraddr
[inProgressDemoteWarm] :: PeerSelectionState peeraddr peerconn -> !Set peeraddr
[inProgressDemoteHot] :: PeerSelectionState peeraddr peerconn -> !Set peeraddr

-- | Rng for fuzzy delay
[fuzzRng] :: PeerSelectionState peeraddr peerconn -> !StdGen

-- | <a>PeerSelectionCounters</a> counters cache. Allows to only trace
--   values when necessary.
[countersCache] :: PeerSelectionState peeraddr peerconn -> !Cache PeerSelectionCounters
data PeerSelectionCounters
PeerSelectionCounters :: Int -> Int -> Int -> PeerSelectionCounters
[coldPeers] :: PeerSelectionCounters -> Int
[warmPeers] :: PeerSelectionCounters -> Int
[hotPeers] :: PeerSelectionCounters -> Int
nullPeerSelectionTargets :: PeerSelectionTargets
emptyPeerSelectionState :: StdGen -> PeerSelectionState peeraddr peerconn
data ChurnMode
ChurnModeBulkSync :: ChurnMode
ChurnModeNormal :: ChurnMode

module Ouroboros.Network.PeerSelection.PeerStateActions

-- | Record of arguments of <tt>peerSelectionActions</tt>.
data PeerStateActionsArguments muxMode socket peerAddr versionNumber m a b
PeerStateActionsArguments :: Tracer m (PeerSelectionActionsTrace peerAddr) -> DiffTime -> DiffTime -> MuxConnectionManager muxMode socket peerAddr versionNumber ByteString m a b -> PeerStateActionsArguments muxMode socket peerAddr versionNumber m a b
[spsTracer] :: PeerStateActionsArguments muxMode socket peerAddr versionNumber m a b -> Tracer m (PeerSelectionActionsTrace peerAddr)

-- | Peer deactivation timeout: timeouts stopping hot protocols.
[spsDeactivateTimeout] :: PeerStateActionsArguments muxMode socket peerAddr versionNumber m a b -> DiffTime

-- | Timeout on closing connection: timeouts stopping established and warm
--   peer protocols.
[spsCloseConnectionTimeout] :: PeerStateActionsArguments muxMode socket peerAddr versionNumber m a b -> DiffTime
[spsConnectionManager] :: PeerStateActionsArguments muxMode socket peerAddr versionNumber m a b -> MuxConnectionManager muxMode socket peerAddr versionNumber ByteString m a b

-- | Each established connection has access to <a>PeerConnectionHandle</a>.
--   It allows to promote / demote or close the connection, by having
--   access to <tt>Mux</tt>, three bundles of miniprotocols: for hot, warm
--   and established peers together with their state <a>StrictTVar</a>s.
data PeerConnectionHandle (muxMode :: MuxMode) peerAddr bytes m a b
withPeerStateActions :: forall (muxMode :: MuxMode) socket peerAddr versionNumber m a b x. (MonadAsync m, MonadCatch m, MonadLabelledSTM m, MonadMask m, MonadTimer m, MonadThrow (STM m), HasInitiator muxMode ~ True, Typeable versionNumber, Show versionNumber, Ord peerAddr, Typeable peerAddr, Show peerAddr) => PeerStateActionsArguments muxMode socket peerAddr versionNumber m a b -> (PeerStateActions peerAddr (PeerConnectionHandle muxMode peerAddr ByteString m a b) m -> m x) -> m x

-- | Parent exception of all peer selection action exceptions.
data PeerSelectionActionException
PeerSelectionActionException :: e -> PeerSelectionActionException
data EstablishConnectionException versionNumber

-- | Handshake client failed
ClientException :: !HandshakeException versionNumber -> EstablishConnectionException versionNumber

-- | Handshake server failed
ServerException :: !HandshakeException versionNumber -> EstablishConnectionException versionNumber
data PeerSelectionTimeoutException peerAddr
DeactivationTimeout :: !ConnectionId peerAddr -> PeerSelectionTimeoutException peerAddr
CloseConnectionTimeout :: !ConnectionId peerAddr -> PeerSelectionTimeoutException peerAddr

-- | Traces produced by <tt>peerSelectionActions</tt>.
data PeerSelectionActionsTrace peerAddr
PeerStatusChanged :: PeerStatusChangeType peerAddr -> PeerSelectionActionsTrace peerAddr
PeerStatusChangeFailure :: PeerStatusChangeType peerAddr -> FailureType -> PeerSelectionActionsTrace peerAddr
PeerMonitoringError :: ConnectionId peerAddr -> SomeException -> PeerSelectionActionsTrace peerAddr
PeerMonitoringResult :: ConnectionId peerAddr -> WithSomeProtocolTemperature FirstToFinishResult -> PeerSelectionActionsTrace peerAddr
instance GHC.Show.Show Ouroboros.Network.PeerSelection.PeerStateActions.MiniProtocolException
instance GHC.Show.Show Ouroboros.Network.PeerSelection.PeerStateActions.MiniProtocolExceptions
instance GHC.Show.Show Ouroboros.Network.PeerSelection.PeerStateActions.FirstToFinishResult
instance GHC.Classes.Eq Ouroboros.Network.PeerSelection.PeerStateActions.PeerState
instance GHC.Show.Show versionNumber => GHC.Show.Show (Ouroboros.Network.PeerSelection.PeerStateActions.EstablishConnectionException versionNumber)
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.PeerSelection.PeerStateActions.PeerSelectionTimeoutException peerAddr)
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.PeerSelection.PeerStateActions.ColdActionException peerAddr)
instance GHC.Show.Show Ouroboros.Network.PeerSelection.PeerStateActions.FailureType
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.PeerSelection.PeerStateActions.PeerStatusChangeType peerAddr)
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.PeerSelection.PeerStateActions.PeerSelectionActionsTrace peerAddr)
instance (GHC.Show.Show peerAddr, Data.Typeable.Internal.Typeable peerAddr) => GHC.Exception.Type.Exception (Ouroboros.Network.PeerSelection.PeerStateActions.ColdActionException peerAddr)
instance (GHC.Show.Show peerAddr, Data.Typeable.Internal.Typeable peerAddr) => GHC.Exception.Type.Exception (Ouroboros.Network.PeerSelection.PeerStateActions.PeerSelectionTimeoutException peerAddr)
instance (GHC.Show.Show versionNumber, Data.Typeable.Internal.Typeable versionNumber) => GHC.Exception.Type.Exception (Ouroboros.Network.PeerSelection.PeerStateActions.EstablishConnectionException versionNumber)
instance GHC.Show.Show Ouroboros.Network.PeerSelection.PeerStateActions.PeerSelectionActionException
instance GHC.Exception.Type.Exception Ouroboros.Network.PeerSelection.PeerStateActions.PeerSelectionActionException
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.PeerSelection.PeerStateActions.PeerConnectionHandle muxMode peerAddr bytes m a b)
instance GHC.Base.Semigroup Ouroboros.Network.PeerSelection.PeerStateActions.LastToFinishResult
instance GHC.Base.Monoid Ouroboros.Network.PeerSelection.PeerStateActions.LastToFinishResult
instance GHC.Base.Semigroup Ouroboros.Network.PeerSelection.PeerStateActions.FirstToFinishResult
instance GHC.Exception.Type.Exception Ouroboros.Network.PeerSelection.PeerStateActions.MiniProtocolExceptions


-- | This module is expected to be imported qualified (it will clash with
--   the <a>Ouroboros.Network.Diffusion.NonP2P</a>).
module Ouroboros.Network.Diffusion.P2P

-- | P2P DiffusionTracers Extras
data TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m
TracersExtra :: Tracer m (TraceLocalRootPeers ntnAddr resolverError) -> Tracer m TracePublicRootPeers -> Tracer m (TracePeerSelection ntnAddr) -> Tracer m (DebugPeerSelection ntnAddr (PeerConnectionHandle InitiatorMode ntnAddr ByteString m () Void)) -> Tracer m (DebugPeerSelection ntnAddr (PeerConnectionHandle InitiatorResponderMode ntnAddr ByteString m () ())) -> Tracer m PeerSelectionCounters -> Tracer m (PeerSelectionActionsTrace ntnAddr) -> Tracer m (ConnectionManagerTrace ntnAddr (ConnectionHandlerTrace ntnVersion ntnVersionData)) -> Tracer m (AbstractTransitionTrace ntnAddr) -> Tracer m (ServerTrace ntnAddr) -> Tracer m (InboundGovernorTrace ntnAddr) -> Tracer m (RemoteTransitionTrace ntnAddr) -> Tracer m (ConnectionManagerTrace ntcAddr (ConnectionHandlerTrace ntcVersion ntcVersionData)) -> Tracer m (ServerTrace ntcAddr) -> Tracer m (InboundGovernorTrace ntcAddr) -> TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m
[dtTraceLocalRootPeersTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (TraceLocalRootPeers ntnAddr resolverError)
[dtTracePublicRootPeersTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m TracePublicRootPeers
[dtTracePeerSelectionTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (TracePeerSelection ntnAddr)
[dtDebugPeerSelectionInitiatorTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (DebugPeerSelection ntnAddr (PeerConnectionHandle InitiatorMode ntnAddr ByteString m () Void))
[dtDebugPeerSelectionInitiatorResponderTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (DebugPeerSelection ntnAddr (PeerConnectionHandle InitiatorResponderMode ntnAddr ByteString m () ()))
[dtTracePeerSelectionCounters] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m PeerSelectionCounters
[dtPeerSelectionActionsTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (PeerSelectionActionsTrace ntnAddr)
[dtConnectionManagerTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (ConnectionManagerTrace ntnAddr (ConnectionHandlerTrace ntnVersion ntnVersionData))
[dtConnectionManagerTransitionTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (AbstractTransitionTrace ntnAddr)
[dtServerTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (ServerTrace ntnAddr)
[dtInboundGovernorTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (InboundGovernorTrace ntnAddr)
[dtInboundGovernorTransitionTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (RemoteTransitionTrace ntnAddr)

-- | Connection manager tracer for local clients
[dtLocalConnectionManagerTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (ConnectionManagerTrace ntcAddr (ConnectionHandlerTrace ntcVersion ntcVersionData))

-- | Server tracer for local clients
[dtLocalServerTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (ServerTrace ntcAddr)

-- | Inbound protocol governor tracer for local clients
[dtLocalInboundGovernorTracer] :: TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Tracer m (InboundGovernorTrace ntcAddr)
nullTracers :: Applicative m => TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m

-- | P2P Arguments Extras
data ArgumentsExtra m
ArgumentsExtra :: PeerSelectionTargets -> STM m [(Int, Map RelayAccessPoint PeerAdvertise)] -> STM m [RelayAccessPoint] -> STM m UseLedgerAfter -> DiffTime -> DiffTime -> ArgumentsExtra m

-- | selection targets for the peer governor
[daPeerSelectionTargets] :: ArgumentsExtra m -> PeerSelectionTargets
[daReadLocalRootPeers] :: ArgumentsExtra m -> STM m [(Int, Map RelayAccessPoint PeerAdvertise)]
[daReadPublicRootPeers] :: ArgumentsExtra m -> STM m [RelayAccessPoint]
[daReadUseLedgerAfter] :: ArgumentsExtra m -> STM m UseLedgerAfter

-- | Timeout which starts once all responder protocols are idle. If the
--   responders stay idle for duration of the timeout, the connection will
--   be demoted, if it wasn't used by the p2p-governor it will be closed.
--   
--   Applies to <a>Unidirectional</a> as well as <a>Duplex</a>
--   <i>node-to-node</i> connections.
--   
--   See <tt>serverProtocolIdleTimeout</tt>.
[daProtocolIdleTimeout] :: ArgumentsExtra m -> DiffTime

-- | Time for which <i>node-to-node</i> connections are kept in
--   <a>TerminatingState</a>, it should correspond to the OS configured
--   <tt>TCP</tt> <tt>TIME_WAIT</tt> timeout.
--   
--   This timeout will apply to after a connection has been closed, its
--   purpose is to be resilient for delayed packets in the same way
--   <tt>TCP</tt> is using <tt>TIME_WAIT</tt>.
[daTimeWaitTimeout] :: ArgumentsExtra m -> DiffTime

-- | Policy which governs how to limit the number of accepted connections.
data AcceptedConnectionsLimit
AcceptedConnectionsLimit :: !Word32 -> !Word32 -> !DiffTime -> AcceptedConnectionsLimit

-- | Hard limit of accepted connections.
[acceptedConnectionsHardLimit] :: AcceptedConnectionsLimit -> !Word32

-- | Soft limit of accepted connections. If we are above this threshold, we
--   will start rate limiting.
[acceptedConnectionsSoftLimit] :: AcceptedConnectionsLimit -> !Word32

-- | Max delay for limiting accepted connections. We use linear regression
--   starting from 0 at the soft limit up to
--   <tt>acceptedConnectionDelay</tt> at the hard limit.
[acceptedConnectionsDelay] :: AcceptedConnectionsLimit -> !DiffTime

-- | P2P Applications Extras
--   
--   TODO: we need initiator only mode for Deadalus, there's no reason why
--   it should run a node-to-node server side.
data ApplicationsExtra ntnAddr m
ApplicationsExtra :: RethrowPolicy -> RethrowPolicy -> PeerMetrics m ntnAddr -> STM m FetchMode -> ApplicationsExtra ntnAddr m

-- | <i>node-to-node</i> rethrow policy
[daRethrowPolicy] :: ApplicationsExtra ntnAddr m -> RethrowPolicy

-- | <i>node-to-client</i> rethrow policy
[daLocalRethrowPolicy] :: ApplicationsExtra ntnAddr m -> RethrowPolicy

-- | <a>PeerMetrics</a> used by peer selection policy (see
--   <tt>simplePeerSelectionPolicy</tt>)
[daPeerMetrics] :: ApplicationsExtra ntnAddr m -> PeerMetrics m ntnAddr

-- | Used by churn-governor
[daBlockFetchMode] :: ApplicationsExtra ntnAddr m -> STM m FetchMode

-- | Main entry point for data diffusion service. It allows to:
--   
--   <ul>
--   <li>connect to upstream peers;</li>
--   <li>accept connection from downstream peers, if run in
--   <a>InitiatorAndResponderDiffusionMode</a>.</li>
--   <li>runs a local service which allows to use node-to-client protocol
--   to obtain information from the running system. This is used by
--   'cardano-cli' or a wallet and a like local services.</li>
--   </ul>
run :: Tracers RemoteAddress NodeToNodeVersion LocalAddress NodeToClientVersion IO -> TracersExtra RemoteAddress NodeToNodeVersion NodeToNodeVersionData LocalAddress NodeToClientVersion NodeToClientVersionData IOException IO -> Arguments Socket RemoteAddress LocalSocket LocalAddress -> ArgumentsExtra IO -> Applications RemoteAddress NodeToNodeVersion NodeToNodeVersionData LocalAddress NodeToClientVersion NodeToClientVersionData IO -> ApplicationsExtra RemoteAddress IO -> IO Void
data Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m
Interfaces :: Snocket m ntnFd ntnAddr -> HandshakeArguments (ConnectionId ntnAddr) ntnVersion ntnVersionData m -> (ntnAddr -> Maybe AddressType) -> (ntnVersion -> ntnVersionData -> DataFlow) -> (IP -> PortNumber -> ntnAddr) -> (LookupReqs -> [DomainAccessPoint] -> m (Map DomainAccessPoint (Set ntnAddr))) -> Snocket m ntcFd ntcAddr -> HandshakeArguments (ConnectionId ntcAddr) ntcVersion ntcVersionData m -> (ntcFd -> m FileDescriptor) -> StdGen -> (forall mode x. NodeToNodeConnectionManager mode ntnFd ntnAddr ntnVersion m x -> m ()) -> (LookupReqs -> DNSActions resolver resolverError m) -> Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m

-- | node-to-node snocket
[diNtnSnocket] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> Snocket m ntnFd ntnAddr

-- | node-to-node handshake configuration
[diNtnHandshakeArguments] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> HandshakeArguments (ConnectionId ntnAddr) ntnVersion ntnVersionData m

-- | node-to-node address type
[diNtnAddressType] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> ntnAddr -> Maybe AddressType

-- | node-to-node data flow used by connection manager to classify
--   negotiated connections
[diNtnDataFlow] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> ntnVersion -> ntnVersionData -> DataFlow

-- | node-to-node peer address
[diNtnToPeerAddr] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> IP -> PortNumber -> ntnAddr

-- | node-to-node domain resolver
[diNtnDomainResolver] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> LookupReqs -> [DomainAccessPoint] -> m (Map DomainAccessPoint (Set ntnAddr))

-- | node-to-client snocket
[diNtcSnocket] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> Snocket m ntcFd ntcAddr

-- | node-to-client handshake configuration
[diNtcHandshakeArguments] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> HandshakeArguments (ConnectionId ntcAddr) ntcVersion ntcVersionData m

-- | node-to-client file descriptor
[diNtcGetFileDescriptor] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> ntcFd -> m FileDescriptor

-- | diffusion pseudo random generator. It is split between various
--   components that need randomness, e.g. inbound governor, peer
--   selection, policies, etc.
[diRng] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> StdGen

-- | callback which is used to register <tt>SIGUSR1</tt> signal handler.
[diInstallSigUSR1Handler] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> forall mode x. NodeToNodeConnectionManager mode ntnFd ntnAddr ntnVersion m x -> m ()

-- | diffusion dns actions
[diDnsActions] :: Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> LookupReqs -> DNSActions resolver resolverError m
runM :: forall m ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError. (MonadAsync m, MonadEvaluate m, MonadFix m, MonadFork m, MonadLabelledSTM m, MonadTraceSTM m, MonadMask m, MonadThrow (STM m), MonadTime m, MonadTimer m, Eq (Async m Void), Typeable ntnAddr, Ord ntnAddr, Show ntnAddr, Typeable ntnVersion, Ord ntnVersion, Show ntnVersion, Typeable ntcAddr, Ord ntcAddr, Show ntcAddr, Ord ntcVersion, Exception resolverError) => Interfaces ntnFd ntnAddr ntnVersion ntnVersionData ntcFd ntcAddr ntcVersion ntcVersionData resolver resolverError m -> Tracers ntnAddr ntnVersion ntcAddr ntcVersion m -> TracersExtra ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData resolverError m -> Arguments ntnFd ntnAddr ntcFd ntcAddr -> ArgumentsExtra m -> Applications ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData m -> ApplicationsExtra ntnAddr m -> m Void
type NodeToNodePeerConnectionHandle (mode :: MuxMode) ntnAddr m a = PeerConnectionHandle mode ntnAddr ByteString m () a
type AbstractTransitionTrace peerAddr = TransitionTrace' peerAddr AbstractState
type RemoteTransitionTrace peerAddr = TransitionTrace' peerAddr Maybe RemoteSt


-- | This module is expected to be imported qualified (it will clash with
--   the <a>Ouroboros.Network.Diffusion.P2P</a>).
module Ouroboros.Network.Diffusion.NonP2P

-- | NonP2P DiffusionTracers Extras
data TracersExtra
TracersExtra :: Tracer IO (WithIPList (SubscriptionTrace SockAddr)) -> Tracer IO (WithDomainName (SubscriptionTrace SockAddr)) -> Tracer IO (WithDomainName DnsTrace) -> Tracer IO (WithAddr SockAddr ErrorPolicyTrace) -> Tracer IO (WithAddr LocalAddress ErrorPolicyTrace) -> Tracer IO AcceptConnectionsPolicyTrace -> TracersExtra

-- | IP subscription tracer
[dtIpSubscriptionTracer] :: TracersExtra -> Tracer IO (WithIPList (SubscriptionTrace SockAddr))

-- | DNS subscription tracer
[dtDnsSubscriptionTracer] :: TracersExtra -> Tracer IO (WithDomainName (SubscriptionTrace SockAddr))

-- | DNS resolver tracer
[dtDnsResolverTracer] :: TracersExtra -> Tracer IO (WithDomainName DnsTrace)
[dtErrorPolicyTracer] :: TracersExtra -> Tracer IO (WithAddr SockAddr ErrorPolicyTrace)
[dtLocalErrorPolicyTracer] :: TracersExtra -> Tracer IO (WithAddr LocalAddress ErrorPolicyTrace)

-- | Trace rate limiting of accepted connections
[dtAcceptPolicyTracer] :: TracersExtra -> Tracer IO AcceptConnectionsPolicyTrace
nullTracers :: TracersExtra

-- | NonP2P extra applications
newtype ApplicationsExtra
ApplicationsExtra :: ErrorPolicies -> ApplicationsExtra

-- | Error policies
[daErrorPolicies] :: ApplicationsExtra -> ErrorPolicies

-- | NonP2P extra arguments
data ArgumentsExtra
ArgumentsExtra :: IPSubscriptionTarget -> [DnsSubscriptionTarget] -> ArgumentsExtra

-- | ip subscription addresses
[daIpProducers] :: ArgumentsExtra -> IPSubscriptionTarget

-- | list of domain names to subscribe to
[daDnsProducers] :: ArgumentsExtra -> [DnsSubscriptionTarget]
run :: Tracers RemoteAddress NodeToNodeVersion LocalAddress NodeToClientVersion IO -> TracersExtra -> Arguments Socket RemoteAddress LocalSocket LocalAddress -> ArgumentsExtra -> Applications RemoteAddress NodeToNodeVersion NodeToNodeVersionData LocalAddress NodeToClientVersion NodeToClientVersionData IO -> ApplicationsExtra -> IO ()

module Ouroboros.Network.Diffusion

-- | Promoted data types.
data P2P
P2P :: P2P
NonP2P :: P2P
data InitializationTracer ntnAddr ntcAddr
RunServer :: NonEmpty ntnAddr -> InitializationTracer ntnAddr ntcAddr
RunLocalServer :: ntcAddr -> InitializationTracer ntnAddr ntcAddr
UsingSystemdSocket :: ntcAddr -> InitializationTracer ntnAddr ntcAddr
CreateSystemdSocketForSnocketPath :: ntcAddr -> InitializationTracer ntnAddr ntcAddr
CreatedLocalSocket :: ntcAddr -> InitializationTracer ntnAddr ntcAddr
ConfiguringLocalSocket :: ntcAddr -> FileDescriptor -> InitializationTracer ntnAddr ntcAddr
ListeningLocalSocket :: ntcAddr -> FileDescriptor -> InitializationTracer ntnAddr ntcAddr
LocalSocketUp :: ntcAddr -> FileDescriptor -> InitializationTracer ntnAddr ntcAddr
CreatingServerSocket :: ntnAddr -> InitializationTracer ntnAddr ntcAddr
ConfiguringServerSocket :: ntnAddr -> InitializationTracer ntnAddr ntcAddr
ListeningServerSocket :: ntnAddr -> InitializationTracer ntnAddr ntcAddr
ServerSocketUp :: ntnAddr -> InitializationTracer ntnAddr ntcAddr
UnsupportedLocalSystemdSocket :: ntnAddr -> InitializationTracer ntnAddr ntcAddr
UnsupportedReadySocketCase :: InitializationTracer ntnAddr ntcAddr
DiffusionErrored :: SomeException -> InitializationTracer ntnAddr ntcAddr

-- | Common DiffusionTracers interface between P2P and NonP2P
data Tracers ntnAddr ntnVersion ntcAddr ntcVersion m
Tracers :: Tracer m (WithMuxBearer (ConnectionId ntnAddr) MuxTrace) -> Tracer m (HandshakeTr ntnAddr ntnVersion) -> Tracer m (WithMuxBearer (ConnectionId ntcAddr) MuxTrace) -> Tracer m (HandshakeTr ntcAddr ntcVersion) -> Tracer m (InitializationTracer ntnAddr ntcAddr) -> Tracer m TraceLedgerPeers -> Tracers ntnAddr ntnVersion ntcAddr ntcVersion m

-- | Mux tracer
[dtMuxTracer] :: Tracers ntnAddr ntnVersion ntcAddr ntcVersion m -> Tracer m (WithMuxBearer (ConnectionId ntnAddr) MuxTrace)

-- | Handshake protocol tracer
[dtHandshakeTracer] :: Tracers ntnAddr ntnVersion ntcAddr ntcVersion m -> Tracer m (HandshakeTr ntnAddr ntnVersion)

-- | Mux tracer for local clients
[dtLocalMuxTracer] :: Tracers ntnAddr ntnVersion ntcAddr ntcVersion m -> Tracer m (WithMuxBearer (ConnectionId ntcAddr) MuxTrace)

-- | Handshake protocol tracer for local clients
[dtLocalHandshakeTracer] :: Tracers ntnAddr ntnVersion ntcAddr ntcVersion m -> Tracer m (HandshakeTr ntcAddr ntcVersion)

-- | Diffusion initialisation tracer
[dtDiffusionInitializationTracer] :: Tracers ntnAddr ntnVersion ntcAddr ntcVersion m -> Tracer m (InitializationTracer ntnAddr ntcAddr)

-- | Ledger Peers tracer
[dtLedgerPeersTracer] :: Tracers ntnAddr ntnVersion ntcAddr ntcVersion m -> Tracer m TraceLedgerPeers
nullTracers :: Applicative m => Tracers ntnAddr ntnVersion ntcAddr ntcVersion m

-- | Tracers which depend on p2p mode.
data ExtraTracers (p2p :: P2P)
[P2PTracers] :: TracersExtra RemoteAddress NodeToNodeVersion NodeToNodeVersionData LocalAddress NodeToClientVersion NodeToClientVersionData IOException IO -> ExtraTracers 'P2P
[NonP2PTracers] :: TracersExtra -> ExtraTracers 'NonP2P
data Failure ntnAddr

-- | Common DiffusionArguments interface between P2P and NonP2P
data Arguments ntnFd ntnAddr ntcFd ntcAddr
Arguments :: Maybe (Either ntnFd ntnAddr) -> Maybe (Either ntnFd ntnAddr) -> Maybe (Either ntcFd ntcAddr) -> AcceptedConnectionsLimit -> DiffusionMode -> Arguments ntnFd ntnAddr ntcFd ntcAddr

-- | an <tt>IPv4</tt> socket ready to accept connections or an
--   <tt>IPv4</tt> addresses
[daIPv4Address] :: Arguments ntnFd ntnAddr ntcFd ntcAddr -> Maybe (Either ntnFd ntnAddr)

-- | an <tt>IPV4</tt> socket ready to accept connections or an
--   <tt>IPv6</tt> addresses
[daIPv6Address] :: Arguments ntnFd ntnAddr ntcFd ntcAddr -> Maybe (Either ntnFd ntnAddr)

-- | an <tt>AF_UNIX</tt> socket ready to accept connections or an
--   <tt>AF_UNIX</tt> socket path
[daLocalAddress] :: Arguments ntnFd ntnAddr ntcFd ntcAddr -> Maybe (Either ntcFd ntcAddr)

-- | parameters for limiting number of accepted connections
[daAcceptedConnectionsLimit] :: Arguments ntnFd ntnAddr ntcFd ntcAddr -> AcceptedConnectionsLimit

-- | run in initiator only mode
[daMode] :: Arguments ntnFd ntnAddr ntcFd ntcAddr -> DiffusionMode

-- | Diffusion arguments which depend on p2p mode.
data ExtraArguments (p2p :: P2P) m
[P2PArguments] :: ArgumentsExtra m -> ExtraArguments 'P2P m
[NonP2PArguments] :: ArgumentsExtra -> ExtraArguments 'NonP2P m

-- | Common DiffusionArguments interface between P2P and NonP2P
--   
--   TODO: we need initiator only mode for blockchain explorer or a similar
--   application, there's no reason why one should run a node-to-node
--   server for it.
data Applications ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData m
Applications :: Versions ntnVersion ntnVersionData (OuroborosBundle InitiatorMode ntnAddr ByteString m () Void) -> Versions ntnVersion ntnVersionData (OuroborosBundle InitiatorResponderMode ntnAddr ByteString m () ()) -> Versions ntcVersion ntcVersionData (OuroborosApplication ResponderMode ntcAddr ByteString m Void ()) -> LedgerPeersConsensusInterface m -> Applications ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData m

-- | NodeToNode initiator applications for initiator only mode.
--   
--   TODO: we should accept one or the other, but not both:
--   <a>daApplicationInitiatorMode</a>,
--   <a>daApplicationInitiatorResponderMode</a>.
[daApplicationInitiatorMode] :: Applications ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData m -> Versions ntnVersion ntnVersionData (OuroborosBundle InitiatorMode ntnAddr ByteString m () Void)

-- | NodeToNode initiator &amp; responder applications for bidirectional
--   mode.
[daApplicationInitiatorResponderMode] :: Applications ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData m -> Versions ntnVersion ntnVersionData (OuroborosBundle InitiatorResponderMode ntnAddr ByteString m () ())

-- | NodeToClient responder application (server role)
[daLocalResponderApplication] :: Applications ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData m -> Versions ntcVersion ntcVersionData (OuroborosApplication ResponderMode ntcAddr ByteString m Void ())

-- | Interface used to get peers from the current ledger.
--   
--   TODO: it should be in <tt>InterfaceExtra</tt>
[daLedgerPeersCtx] :: Applications ntnAddr ntnVersion ntnVersionData ntcAddr ntcVersion ntcVersionData m -> LedgerPeersConsensusInterface m

-- | Application data which depend on p2p mode.
data ExtraApplications (p2p :: P2P) ntnAddr m
[P2PApplications] :: ApplicationsExtra ntnAddr m -> ExtraApplications 'P2P ntnAddr m
[NonP2PApplications] :: ApplicationsExtra -> ExtraApplications 'NonP2P ntnAddr m

-- | Run data diffusion in either <a>P2P</a> or <a>NonP2P</a> mode.
run :: forall (p2p :: P2P). Tracers RemoteAddress NodeToNodeVersion LocalAddress NodeToClientVersion IO -> ExtraTracers p2p -> Arguments Socket RemoteAddress LocalSocket LocalAddress -> ExtraArguments p2p IO -> Applications RemoteAddress NodeToNodeVersion NodeToNodeVersionData LocalAddress NodeToClientVersion NodeToClientVersionData IO -> ExtraApplications p2p RemoteAddress IO -> IO ()
type AbstractTransitionTrace peerAddr = TransitionTrace' peerAddr AbstractState
