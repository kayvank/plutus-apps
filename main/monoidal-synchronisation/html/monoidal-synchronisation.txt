-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monoidal synchronisation
--   
--   Monoidal synchronisation.
@package monoidal-synchronisation
@version 0.1.0.2

module Data.Monoid.Synchronisation

-- | First-to-finish synchronisation. Like <a>Alt</a> it is a monoid under
--   <a>&lt;|&gt;</a>. First-to-finish is the additive monoid of
--   <a>near-semiring</a> for which multiplication is given by
--   <a>LastToFinish</a>.
--   
--   <pre>
--   -- | Return first available value.
--   --
--   readFirstMVar :: [TMVar a] -&gt; STM a
--   readFirstMVar = runFirstToFinish
--                 . foldMap (FirstToFinish . readTMVar)
--   </pre>
newtype FirstToFinish m a
FirstToFinish :: m a -> FirstToFinish m a
[runFirstToFinish] :: FirstToFinish m a -> m a

-- | Last-to-finish synchronisation. It is the multiplicative semigroup of
--   the <a>near-semiring</a> for which addition is given by
--   <a>FirstToFinish</a>.
--   
--   This is similar to <a>Ap</a> (see <a>LastToFinishM</a>) in the sense
--   that it will wait for all monadic effects, but unlike <a>Ap</a> it
--   will not combine all results using a monoid instance, but rather it
--   will return the last one. Also unlike <a>Ap</a> it does not have a
--   monoidal unit.
--   
--   <pre>
--   -- | Read all 'TMVar's and return the one that was filled last.
--   --
--   readAllTMVars :: Monoid a =&gt; NonEmpty (TMVar a) -&gt; STM a
--   readAllTMVars = runLastToFinish
--                 . foldMap1 (LastToFinish . readTMVar)
--                   -- from 'semigroupoids' package or use 'foldr1' and 'fmap'
--                   -- from 'base'
--   </pre>
newtype LastToFinish m a
LastToFinish :: m a -> LastToFinish m a
[runLastToFinish] :: LastToFinish m a -> m a
firstToLast :: FirstToFinish m a -> LastToFinish m a
lastToFirst :: LastToFinish m a -> FirstToFinish m a

-- | Last-to-finish synchronisation. Like <a>Ap</a> it is a monoid under
--   <a>&lt;*&gt;</a>. The advantage over <a>LastToFinish</a> is that it
--   has a <a>Monoid</a> instance, but <tt>a</tt> must be a <a>Monoid</a>
--   as well. <a>LastToFinishM</a> and <a>FirstToFinish</a> form a unitial
--   near-ring when <tt>m ~ STM</tt>.
--   
--   <pre>
--   -- | Read all 'TMVar's and combine the result using 'Monoid' instance.
--   --
--   readAllTMVars :: Monoid a =&gt; [TMVar a] -&gt; STM a
--   readAllTMVars = runLastToFinish
--                 . foldMap (LastToFinish . readTMVar)
--   </pre>
newtype LastToFinishM m a
LastToFinishM :: m a -> LastToFinishM m a
[runLastToFinishM] :: LastToFinishM m a -> m a
firstToLastM :: FirstToFinish m a -> LastToFinishM m a
lastToFirstM :: LastToFinishM m a -> FirstToFinish m a
instance Data.Functor.Contravariant.Contravariant m => Data.Functor.Contravariant.Contravariant (Data.Monoid.Synchronisation.FirstToFinish m)
instance Data.Foldable.Foldable m => Data.Foldable.Foldable (Data.Monoid.Synchronisation.FirstToFinish m)
instance GHC.Base.Alternative m => GHC.Base.Monoid (Data.Monoid.Synchronisation.FirstToFinish m a)
instance GHC.Base.Alternative m => GHC.Base.Semigroup (Data.Monoid.Synchronisation.FirstToFinish m a)
instance Data.Traversable.Traversable m => Data.Traversable.Traversable (Data.Monoid.Synchronisation.FirstToFinish m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Data.Monoid.Synchronisation.FirstToFinish m)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Monoid.Synchronisation.FirstToFinish m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Data.Monoid.Synchronisation.FirstToFinish m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Data.Monoid.Synchronisation.FirstToFinish m)
instance GHC.Generics.Generic1 (Data.Monoid.Synchronisation.FirstToFinish m)
instance GHC.Generics.Generic (Data.Monoid.Synchronisation.FirstToFinish m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Monoid.Synchronisation.FirstToFinish m)
instance Data.Foldable.Foldable m => Data.Foldable.Foldable (Data.Monoid.Synchronisation.LastToFinish m)
instance Data.Traversable.Traversable m => Data.Traversable.Traversable (Data.Monoid.Synchronisation.LastToFinish m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Data.Monoid.Synchronisation.LastToFinish m)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Monoid.Synchronisation.LastToFinish m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Data.Monoid.Synchronisation.LastToFinish m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Data.Monoid.Synchronisation.LastToFinish m)
instance GHC.Generics.Generic1 (Data.Monoid.Synchronisation.LastToFinish m)
instance GHC.Generics.Generic (Data.Monoid.Synchronisation.LastToFinish m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Monoid.Synchronisation.LastToFinish m)
instance Data.Foldable.Foldable m => Data.Foldable.Foldable (Data.Monoid.Synchronisation.LastToFinishM m)
instance (GHC.Base.Applicative m, GHC.Base.Monoid a) => GHC.Base.Monoid (Data.Monoid.Synchronisation.LastToFinishM m a)
instance (GHC.Base.Applicative m, GHC.Base.Semigroup a) => GHC.Base.Semigroup (Data.Monoid.Synchronisation.LastToFinishM m a)
instance Data.Traversable.Traversable m => Data.Traversable.Traversable (Data.Monoid.Synchronisation.LastToFinishM m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Data.Monoid.Synchronisation.LastToFinishM m)
instance GHC.Base.Monad m => GHC.Base.Monad (Data.Monoid.Synchronisation.LastToFinishM m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Data.Monoid.Synchronisation.LastToFinishM m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Data.Monoid.Synchronisation.LastToFinishM m)
instance GHC.Generics.Generic1 (Data.Monoid.Synchronisation.LastToFinishM m)
instance GHC.Generics.Generic (Data.Monoid.Synchronisation.LastToFinishM m a)
instance GHC.Base.Functor m => GHC.Base.Functor (Data.Monoid.Synchronisation.LastToFinishM m)
instance GHC.Base.MonadPlus m => GHC.Base.Semigroup (Data.Monoid.Synchronisation.LastToFinish m a)
