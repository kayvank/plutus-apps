-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Set Algebra
--   
--   Set Algebra
@package set-algebra
@version 0.1.0.0

module Control.Iterate.Collect
newtype Cont ans x
Cont :: ((x -> ans) -> ans) -> Cont ans x
[runCont] :: Cont ans x -> (x -> ans) -> ans
newtype Collect tuple
Collect :: (forall ans. ans -> (tuple -> ans -> ans) -> ans) -> Collect tuple
[runCollect] :: Collect tuple -> forall ans. ans -> (tuple -> ans -> ans) -> ans

-- | A (Collect t) is completely agnostic over how <tt>t</tt>s are beging
--   collected. We can make this abstraction concrete by using fixAction.
fixAction :: Collect tuple -> ans -> (tuple -> ans -> ans) -> ans
mapify :: Ord a => Collect (a, b) -> Map a b
listify :: Collect (a, b) -> [(a, b)]
count :: Collect (a, b) -> Int

-- | Here are several ways to add a new t to what is being collected.
--   
--   The <a>one</a> and <a>none</a> interface are used when we want
--   collections with 0 or 1 elements
one :: t -> Collect t
none :: Collect t

-- | The <a>front</a> and <a>rear</a> interface can add to either end of
--   the sequence (both in constant time)
front :: t -> Collect t -> Collect t
rear :: Collect t -> t -> Collect t

-- | Conditional collecting
when :: Bool -> Collect ()
takeC :: Int -> Collect t -> [t]
isempty :: Collect t -> Bool
nonempty :: Collect t -> Bool
hasElem :: Collect t -> Maybe t
newtype ColPlus tuple
ColPlus :: (forall ans. ans -> (tuple -> ans -> ans) -> (ans -> ans -> ans) -> ans) -> ColPlus tuple
[runColPlus] :: ColPlus tuple -> forall ans. ans -> (tuple -> ans -> ans) -> (ans -> ans -> ans) -> ans
runPlus :: Monoid a => ColPlus t -> a -> (t -> a -> a) -> a
instance GHC.Base.Functor Control.Iterate.Collect.ColPlus
instance GHC.Base.Applicative Control.Iterate.Collect.ColPlus
instance GHC.Base.Monad Control.Iterate.Collect.ColPlus
instance GHC.Base.Alternative Control.Iterate.Collect.ColPlus
instance GHC.Base.MonadPlus Control.Iterate.Collect.ColPlus
instance GHC.Base.Functor Control.Iterate.Collect.Collect
instance GHC.Base.Applicative Control.Iterate.Collect.Collect
instance GHC.Base.Monad Control.Iterate.Collect.Collect
instance Data.Foldable.Foldable Control.Iterate.Collect.Collect
instance GHC.Show.Show t => GHC.Show.Show (Control.Iterate.Collect.Collect t)
instance GHC.Base.Functor (Control.Iterate.Collect.Cont ans)
instance GHC.Base.Applicative (Control.Iterate.Collect.Cont ans)
instance GHC.Base.Monad (Control.Iterate.Collect.Cont r)


-- | Defines what types can be used in the SetAlgebra, and what operations
--   those types must support (Iter, Basic, Embed)
module Control.Iterate.BaseTypes
class Iter f
nxt :: Iter f => f a b -> Collect (a, b, f a b)
lub :: (Iter f, Ord k) => k -> f k b -> Collect (k, b, f k b)
hasNxt :: Iter f => f a b -> Maybe (a, b, f a b)
hasLub :: (Iter f, Ord k) => k -> f k b -> Maybe (k, b, f k b)
haskey :: (Iter f, Ord key) => key -> f key b -> Bool
isnull :: Iter f => f k v -> Bool
lookup :: (Iter f, Ord key) => key -> f key rng -> Maybe rng
element :: (Iter f, Ord k) => k -> f k v -> Collect ()

-- | In order to build typed Exp (which are a typed deep embedding) of Set
--   operations, we need to know what kind of basic types of Maps and Sets
--   can be used this way. Every Basic type has a few operations for
--   creating one from a list, for adding and removing key-value pairs,
--   looking up a value given a key. Instances of this algebra are
--   functional in that every key has exactly one value associated with it.
class Basic f

-- | in addpair the new value always prevails, to make a choice use
--   <a>addkv</a> which has a combining function that allows choice.
addpair :: (Basic f, Ord k) => k -> v -> f k v -> f k v

-- | use ( old new -&gt; old) if you want the v in (f k v) to prevail, and
--   use ( old new -&gt; new) if you want the v in (k,v) to prevail
addkv :: (Basic f, Ord k) => (k, v) -> f k v -> (v -> v -> v) -> f k v
removekey :: (Basic f, Ord k) => k -> f k v -> f k v
domain :: (Basic f, Ord k) => f k v -> Set k
range :: (Basic f, Ord v) => f k v -> Set v

-- | BaseRep witnesses Basic types. I.e. those types that are instances of
--   both Basic and Iter. Pattern matching against a constructor of type
--   BaseRep, determines which base type. For example data Tag f k v = Tag
--   (BaseRep f k v) (f k v) case Tag MapR x -&gt; -- here we know x ::
--   Map.Map k v
data BaseRep f k v
[MapR] :: Basic Map => BaseRep Map k v
[SetR] :: Basic Sett => BaseRep Sett k ()
[ListR] :: Basic List => BaseRep List k v
[SingleR] :: Basic Single => BaseRep Single k v
[BiMapR] :: (Basic (BiMap v), Ord v) => BaseRep (BiMap v) k v
[ViewR] :: (Monoid coin, Ord cred, Ord ptr, Ord coin, Ord pool) => Tag coin cred pool ptr k v -> BaseRep (View coin cred pool ptr) k v
data List k v
[UnSafeList] :: Ord k => [(k, v)] -> List k v
unList :: List k v -> [(k, v)]
fromPairs :: Ord k => (v -> v -> v) -> [(k, v)] -> List k v
normalize :: Ord k => (v -> v -> v) -> [(k, v)] -> [(k, v)]
data Single k v
[Single] :: k -> v -> Single k v
[Fail] :: Single k v
[SetSingle] :: k -> Single k ()
data Sett k v
[Sett] :: Set k -> Sett k ()
class Embed concrete base | concrete -> base
toBase :: Embed concrete base => concrete -> base
fromBase :: Embed concrete base => base -> concrete
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Control.Iterate.BaseTypes.List k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Control.Iterate.BaseTypes.Single k v)
instance GHC.Classes.Eq k => GHC.Classes.Eq (Control.Iterate.BaseTypes.Sett k ())
instance GHC.Classes.Ord k => Control.Iterate.BaseTypes.Embed [(k, v)] (Control.Iterate.BaseTypes.List k v)
instance Control.Iterate.BaseTypes.Embed (Data.Set.Internal.Set k) (Control.Iterate.BaseTypes.Sett k ())
instance Control.Iterate.BaseTypes.Embed (Data.Map.Internal.Map k v) (Data.Map.Internal.Map k v)
instance Control.Iterate.BaseTypes.Embed (Data.BiMap.BiMap v k v) (Data.BiMap.BiMap v k v)
instance Control.Iterate.BaseTypes.Embed (Control.Iterate.BaseTypes.Single k v) (Control.Iterate.BaseTypes.Single k v)
instance Control.Iterate.BaseTypes.Embed GHC.Types.Bool GHC.Types.Bool
instance Control.Iterate.BaseTypes.Embed (Data.UMap.View coin cred pool ptr k v) (Data.UMap.View coin cred pool ptr k v)
instance GHC.Show.Show (Control.Iterate.BaseTypes.BaseRep f k v)
instance Control.Iterate.BaseTypes.Basic Control.Iterate.BaseTypes.Sett
instance GHC.Show.Show key => GHC.Show.Show (Control.Iterate.BaseTypes.Sett key ())
instance Control.Iterate.BaseTypes.Iter Control.Iterate.BaseTypes.Sett
instance Control.Iterate.BaseTypes.Basic Control.Iterate.BaseTypes.Single
instance Control.Iterate.BaseTypes.Iter Control.Iterate.BaseTypes.Single
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Control.Iterate.BaseTypes.Single k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Control.Iterate.BaseTypes.List k v)
instance Control.Iterate.BaseTypes.Basic Control.Iterate.BaseTypes.List
instance Control.Iterate.BaseTypes.Iter Control.Iterate.BaseTypes.List
instance GHC.Classes.Ord v => Control.Iterate.BaseTypes.Basic (Data.BiMap.BiMap v)
instance Control.Iterate.BaseTypes.Basic Data.Map.Internal.Map
instance (GHC.Base.Monoid coin, GHC.Classes.Ord coin, GHC.Classes.Ord cred, GHC.Classes.Ord ptr, GHC.Classes.Ord pool) => Control.Iterate.BaseTypes.Basic (Data.UMap.View coin cred pool ptr)
instance GHC.Classes.Ord v => Control.Iterate.BaseTypes.Iter (Data.BiMap.BiMap v)
instance Control.Iterate.BaseTypes.Iter Data.Map.Internal.Map
instance (GHC.Classes.Ord coin, GHC.Classes.Ord cred, GHC.Classes.Ord ptr) => Control.Iterate.BaseTypes.Iter (Data.UMap.View coin cred pool ptr)


-- | This module provides deep embeddings of three things 1) Exp is a deep
--   embedding of expressions over Sets and Maps as a typed data structure.
--   2) Fun is a deep embedding of symbolic functions 3) Query is a deep
--   embedding of queries over Sets and Maps. It can be thought of as a
--   low-level compiled form of Exp
module Control.Iterate.Exp

-- | The self typed GADT: Exp, that encodes the shape of Set expressions. A
--   deep embedding. Exp is a typed Symbolic representation of queries we
--   may ask. It allows us to introspect a query The strategy is to 1)
--   Define Exp so all queries can be represented. 2) Define smart
--   constructors that "parse" the surface syntax, and build a typed Exp 3)
--   Write an evaluate function: eval:: Exp t -&gt; t 4) "eval" can
--   introspect the code and apply efficient domain and type specific
--   translations 5) Use the (Iter f) class to evaluate some Exp that can
--   benefit from its efficient nature.
data Exp t
[Base] :: (Ord k, Basic f, Iter f) => BaseRep f k v -> f k v -> Exp (f k v)
[Dom] :: Ord k => Exp (f k v) -> Exp (Sett k ())
[Rng] :: (Ord k, Ord v) => Exp (f k v) -> Exp (Sett v ())
[DRestrict] :: (Ord k, Iter g) => Exp (g k ()) -> Exp (f k v) -> Exp (f k v)
[DExclude] :: (Ord k, Iter g) => Exp (g k ()) -> Exp (f k v) -> Exp (f k v)
[RRestrict] :: (Ord k, Iter g, Ord v) => Exp (f k v) -> Exp (g v ()) -> Exp (f k v)
[RExclude] :: (Ord k, Iter g, Ord v) => Exp (f k v) -> Exp (g v ()) -> Exp (f k v)
[Elem] :: (Ord k, Iter g, Show k) => k -> Exp (g k ()) -> Exp Bool
[NotElem] :: (Ord k, Iter g, Show k) => k -> Exp (g k ()) -> Exp Bool
[Intersect] :: (Ord k, Iter f, Iter g) => Exp (f k v) -> Exp (g k u) -> Exp (Sett k ())
[Subset] :: (Ord k, Iter f, Iter g) => Exp (f k v) -> Exp (g k u) -> Exp Bool
[SetDiff] :: (Ord k, Iter f, Iter g) => Exp (f k v) -> Exp (g k u) -> Exp (f k v)
[UnionOverrideLeft] :: (Show k, Show v, Ord k) => Exp (f k v) -> Exp (g k v) -> Exp (f k v)
[UnionPlus] :: (Ord k, Monoid n) => Exp (f k n) -> Exp (g k n) -> Exp (f k n)
[UnionOverrideRight] :: Ord k => Exp (f k v) -> Exp (g k v) -> Exp (f k v)
[Singleton] :: Ord k => k -> v -> Exp (Single k v)
[SetSingleton] :: Ord k => k -> Exp (Single k ())
[KeyEqual] :: (Ord k, Iter f, Iter g) => Exp (f k v) -> Exp (g k u) -> Exp Bool

-- | Basic types are those that can be embedded into Exp. The HasExp class,
--   encodes how to lift a Basic type into an Exp. The function
--   <a>toExp</a> will build a typed Exp for that Basic type. This will be
--   really usefull in the smart constructors.
class HasExp s t | s -> t
toExp :: HasExp s t => s -> Exp t
dRestrict :: (Ord k, Iter g) => Exp (g k ()) -> Exp (f k v) -> Exp (f k v)
rRestrict :: (Ord k, Iter g, Ord v) => Exp (f k v) -> Exp (g v ()) -> Exp (f k v)
dExclude :: (Ord k, Iter g) => Exp (g k ()) -> Exp (f k v) -> Exp (f k v)
rExclude :: (Ord k, Iter g, Ord v) => Exp (f k v) -> Exp (g v ()) -> Exp (f k v)
dom :: (Ord k, HasExp s (f k v)) => s -> Exp (Sett k ())
rng :: (Ord k, Ord v) => HasExp s (f k v) => s -> Exp (Sett v ())
(◁) :: (Ord k, HasExp s1 (Sett k ()), HasExp s2 (f k v)) => s1 -> s2 -> Exp (f k v)
(<|) :: (Ord k, HasExp s1 (Sett k ()), HasExp s2 (f k v)) => s1 -> s2 -> Exp (f k v)
drestrict :: (Ord k, HasExp s1 (Sett k ()), HasExp s2 (f k v)) => s1 -> s2 -> Exp (f k v)
(⋪) :: (Ord k, Iter g, HasExp s1 (g k ()), HasExp s2 (f k v)) => s1 -> s2 -> Exp (f k v)
dexclude :: (Ord k, Iter g, HasExp s1 (g k ()), HasExp s2 (f k v)) => s1 -> s2 -> Exp (f k v)
(▷) :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) => s1 -> s2 -> Exp (f k v)
(|>) :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) => s1 -> s2 -> Exp (f k v)
rrestrict :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) => s1 -> s2 -> Exp (f k v)
(⋫) :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) => s1 -> s2 -> Exp (f k v)
rexclude :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) => s1 -> s2 -> Exp (f k v)
(∈) :: (Show k, Ord k, Iter g, HasExp s (g k ())) => k -> s -> Exp Bool
(∉) :: (Show k, Ord k, Iter g, HasExp s (g k ())) => k -> s -> Exp Bool
notelem :: (Show k, Ord k, Iter g, HasExp s (g k ())) => k -> s -> Exp Bool
(∪) :: (Show k, Show v, Ord k, HasExp s1 (f k v), HasExp s2 (g k v)) => s1 -> s2 -> Exp (f k v)
unionleft :: (Show k, Show v, Ord k, HasExp s1 (f k v), HasExp s2 (g k v)) => s1 -> s2 -> Exp (f k v)
(⨃) :: (Ord k, HasExp s1 (f k v), HasExp s2 (g k v)) => s1 -> s2 -> Exp (f k v)
unionright :: (Ord k, HasExp s1 (f k v), HasExp s2 (g k v)) => s1 -> s2 -> Exp (f k v)
(∪+) :: (Ord k, Monoid n, HasExp s1 (f k n), HasExp s2 (g k n)) => s1 -> s2 -> Exp (f k n)
unionplus :: (Ord k, Monoid n, HasExp s1 (f k n), HasExp s2 (g k n)) => s1 -> s2 -> Exp (f k n)
singleton :: Ord k => k -> v -> Exp (Single k v)
setSingleton :: Ord k => k -> Exp (Single k ())
(∩) :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp (Sett k ())
intersect :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp (Sett k ())
(⊆) :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp Bool
subset :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp Bool
(➖) :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp (f k v)
setdiff :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp (f k v)
(≍) :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp Bool
keyeq :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp Bool

-- | An symbolic function Fun has two parts, a Lam that can be analyzed,
--   and real function that can be applied
data Fun t
Fun :: Lam t -> t -> Fun t

-- | Symbolc functions (Fun) are data, that can be pattern matched over.
--   They 1) Represent a wide class of binary functions that are used in
--   translating the SetAlgebra 2) Turned into a String so they can be
--   printed 3) Turned into the function they represent. 4) Composed into
--   bigger functions 5) Symbolically symplified Here we implement Symbolic
--   Binary functions with upto 4 variables, which is enough for this use
--   =================================================================================================
data Pat env t
[P1] :: Pat (d, c, b, a) d
[P2] :: Pat (d, c, b, a) c
[P3] :: Pat (d, c, b, a) b
[P4] :: Pat (d, c, b, a) a
[PPair] :: Pat (d, c, b, a) a -> Pat (d, c, b, a) b -> Pat (d, c, b, a) (a, b)
data Expr env t
[X1] :: Expr (d, c, b, a) d
[X2] :: Expr (d, c, b, a) c
[X3] :: Expr (d, c, b, a) b
[X4] :: Expr (d, c, b, a) a
[HasKey] :: (Iter f, Ord k) => Expr e k -> f k v -> Expr e Bool
[Neg] :: Expr e Bool -> Expr e Bool
[Ap] :: Lam (a -> b -> c) -> Expr e a -> Expr e b -> Expr e c
[EPair] :: Expr e a -> Expr e b -> Expr e (a, b)
[FST] :: Expr e (a, b) -> Expr e a
[SND] :: Expr e (a, b) -> Expr e b
[Lit] :: Show t => t -> Expr env t
data Lam t
[Lam] :: Pat (d, c, b, a) t -> Pat (d, c, b, a) s -> Expr (d, c, b, a) v -> Lam (t -> s -> v)
[Add] :: Num n => Lam (n -> n -> n)
[Cat] :: Monoid m => Lam (m -> m -> m)
[Eql] :: Eq t => Lam (t -> t -> Bool)
[Both] :: Lam (Bool -> Bool -> Bool)
[Lift] :: (a -> b -> c) -> Lam (a -> b -> c)
type StringEnv = (String, String, String, String)
bindE :: Pat (a, b, c, d) t -> Expr (w, x, y, z) t -> StringEnv -> StringEnv
showE :: StringEnv -> Expr (a, b, c, d) t -> String
showL :: StringEnv -> Lam t -> String
showP :: StringEnv -> Pat any t -> String
apply :: Fun t -> t
first :: Fun (v -> s -> v)
second :: Fun (v -> s -> s)
plus :: Monoid t => Fun (t -> t -> t)
eql :: Eq t => Fun (t -> t -> Bool)
constant :: Show c => c -> Fun (a -> b -> c)
rngElem :: (Ord rng, Iter f) => f rng v -> Fun (dom -> rng -> Bool)
domElem :: (Ord dom, Iter f) => f dom v -> Fun (dom -> rng -> Bool)
rngFst :: Fun (x -> (a, b) -> a)
rngSnd :: Fun (x -> (a, b) -> b)
compose1 :: Fun (t1 -> t2 -> t3) -> Fun (t1 -> t4 -> t2) -> Fun (t1 -> t4 -> t3)
compSndL :: Fun (k -> (a, b) -> c) -> Fun (k -> d -> a) -> Fun (k -> (d, b) -> c)
compSndR :: Fun (k -> (a, b) -> c) -> Fun (k -> d -> b) -> Fun (k -> (a, d) -> c)
compCurryR :: Fun (k -> (a, b) -> d) -> Fun (a -> c -> b) -> Fun (k -> (a, c) -> d)
nEgate :: Fun (k -> v -> Bool) -> Fun (k -> v -> Bool)
always :: Fun (a -> b -> Bool)
both :: Fun (a -> b -> Bool) -> Fun (a -> b -> Bool) -> Fun (a -> b -> Bool)
lift :: (a -> b -> c) -> Fun (a -> b -> c)
data Query k v
[BaseD] :: (Iter f, Ord k) => BaseRep f k v -> f k v -> Query k v
[ProjectD] :: Ord k => Query k v -> Fun (k -> v -> u) -> Query k u
[AndD] :: Ord k => Query k v -> Query k w -> Query k (v, w)
[ChainD] :: (Ord k, Ord v) => Query k v -> Query v w -> Fun (k -> (v, w) -> u) -> Query k u
[AndPD] :: Ord k => Query k v -> Query k u -> Fun (k -> (v, u) -> w) -> Query k w
[OrD] :: Ord k => Query k v -> Query k v -> Fun (v -> v -> v) -> Query k v
[GuardD] :: Ord k => Query k v -> Fun (k -> v -> Bool) -> Query k v
[DiffD] :: Ord k => Query k v -> Query k u -> Query k v
smart :: Bool
projD :: Ord k => Query k v -> Fun (k -> v -> u) -> Query k u
andD :: Ord k => Query k v1 -> Query k v2 -> Query k (v1, v2)
andPD :: Ord k => Query k v1 -> Query k u -> Fun (k -> (v1, u) -> v) -> Query k v
chainD :: (Ord k, Ord v) => Query k v -> Query v w -> Fun (k -> (v, w) -> u) -> Query k u
guardD :: Ord k => Query k v -> Fun (k -> v -> Bool) -> Query k v
projectQ :: (Ord k, HasQuery c k v) => c -> Fun (k -> v -> u) -> Query k u
andQ :: (Ord k, HasQuery concrete1 k v, HasQuery concrete2 k w) => concrete1 -> concrete2 -> Query k (v, w)
orQ :: (Ord k, HasQuery concrete1 k v, HasQuery concrete2 k v) => concrete1 -> concrete2 -> Fun (v -> v -> v) -> Query k v
chainQ :: (Ord k, Ord v, HasQuery concrete1 k v, HasQuery concrete2 v w) => concrete1 -> concrete2 -> Fun (k -> (v, w) -> u) -> Query k u
andPQ :: (Ord k, HasQuery concrete1 k v, HasQuery concrete2 k u) => concrete1 -> concrete2 -> Fun (k -> (v, u) -> w) -> Query k w
guardQ :: (Ord k, HasQuery concrete k v) => concrete -> Fun (k -> v -> Bool) -> Query k v
diffQ :: forall k v u concrete1 concrete2. (Ord k, HasQuery (concrete1 k v) k v, HasQuery (concrete2 k u) k u) => concrete1 k v -> concrete2 k u -> Query k v
class HasQuery concrete k v
query :: HasQuery concrete k v => concrete -> Query k v
ppQuery :: Query k v -> Doc
nxtQuery :: Query a b -> Collect (a, b, Query a b)
lubQuery :: Ord a => a -> Query a b -> Collect (a, b, Query a b)
projStep :: Ord k => (t -> Collect (k, v, Query k v)) -> Fun (k -> v -> u) -> t -> Collect (k, u, Query k u)
andStep :: Ord a => (a, b1, Query a b1) -> (a, b2, Query a b2) -> Collect (a, (b1, b2), Query a (b1, b2))
chainStep :: (Ord b, Ord a) => (a, b, Query a b) -> Query b w -> Fun (a -> (b, w) -> u) -> Collect (a, u, Query a u)
andPstep :: Ord a => (a, b1, Query a b1) -> (a, b2, Query a b2) -> Fun (a -> (b1, b2) -> w) -> Collect (a, w, Query a w)
orStep :: (Ord k, Ord a) => (Query k v -> Collect (a, v, Query k v)) -> Query k v -> Query k v -> Fun (v -> v -> v) -> Collect (a, v, Query k v)
guardStep :: Ord a => (Query a b -> Collect (a, b, Query a b)) -> Fun (a -> b -> Bool) -> Query a b -> Collect (a, b, Query a b)
diffStep :: Ord k => (k, v, Query k v) -> Query k u -> Collect (k, v, Query k v)
instance Control.Iterate.Exp.HasQuery (Control.Iterate.Exp.Query k v) k v
instance GHC.Classes.Ord k => Control.Iterate.Exp.HasQuery [(k, v)] k v
instance GHC.Classes.Ord k => Control.Iterate.Exp.HasQuery (Data.Set.Internal.Set k) k ()
instance GHC.Classes.Ord k => Control.Iterate.Exp.HasQuery (Data.Map.Internal.Map k v) k v
instance GHC.Classes.Ord k => Control.Iterate.Exp.HasQuery (Control.Iterate.BaseTypes.Single k v) k v
instance (GHC.Classes.Ord v, GHC.Classes.Ord k) => Control.Iterate.Exp.HasQuery (Data.BiMap.BiMap v k v) k v
instance (Data.UMap.UnifiedView coin cred pool ptr k v, GHC.Base.Monoid coin, GHC.Classes.Ord k, GHC.Classes.Ord coin, GHC.Classes.Ord cred, GHC.Classes.Ord ptr, GHC.Classes.Ord pool) => Control.Iterate.Exp.HasQuery (Data.UMap.View coin cred pool ptr k v) k v
instance GHC.Show.Show (Control.Iterate.Exp.Query k v)
instance Control.Iterate.BaseTypes.Iter Control.Iterate.Exp.Query
instance GHC.Show.Show (Control.Iterate.Exp.Fun t)
instance GHC.Show.Show (Control.Iterate.Exp.Expr (a, b, c, d) t)
instance GHC.Show.Show (Control.Iterate.Exp.Lam t)
instance Control.Iterate.Exp.HasExp (Control.Iterate.Exp.Exp t) t
instance GHC.Classes.Ord k => Control.Iterate.Exp.HasExp (Data.Map.Internal.Map k v) (Data.Map.Internal.Map k v)
instance GHC.Classes.Ord k => Control.Iterate.Exp.HasExp (Data.Set.Internal.Set k) (Control.Iterate.BaseTypes.Sett k ())
instance GHC.Classes.Ord k => Control.Iterate.Exp.HasExp [(k, v)] (Control.Iterate.BaseTypes.List k v)
instance GHC.Classes.Ord k => Control.Iterate.Exp.HasExp (Control.Iterate.BaseTypes.Single k v) (Control.Iterate.BaseTypes.Single k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => Control.Iterate.Exp.HasExp (Data.BiMap.Bimap k v) (Data.BiMap.Bimap k v)
instance (Data.UMap.UnifiedView coin cred pool ptr k v, GHC.Classes.Ord k, GHC.Base.Monoid coin, GHC.Classes.Ord coin, GHC.Classes.Ord cred, GHC.Classes.Ord ptr, GHC.Classes.Ord pool) => Control.Iterate.Exp.HasExp (Data.UMap.View coin cred pool ptr k v) (Data.UMap.View coin cred pool ptr k v)
instance GHC.Show.Show (Control.Iterate.Exp.Exp t)


-- | Supports writing 'Set algebra' expressions, using overloaded set
--   operations, that can be applied to a variety of Basic types (Set,
--   List, Map, BiMap etc). Also supports a mechanism to evaluate them
--   efficiently, choosing datatype specific algorithms. This mechanism
--   uses run-time rewrite rules to get the best algorithm. If there are no
--   rewrite rules for a specific expression, falls back to a less
--   efficient generic algorithm.
module Control.Iterate.SetAlgebra

-- | Compile the (Exp (f k v)) to a Query iterator, and a BaseRep that
--   indicates how to materialize the iterator to the correct type. Recall
--   the iterator can be used to constuct many things using runCollect, but
--   here we want to materialize it to the same type as the (Exp (f k v)),
--   i.e. (f k v).
compile :: Exp (f k v) -> (Query k v, BaseRep f k v)
compileSubterm :: Exp a -> Exp (f k v) -> Query k v
run :: Ord k => (Query k v, BaseRep f k v) -> f k v
testing :: Bool
runBoolExp :: Exp Bool -> Bool
runSetExp :: Ord k => Exp (f k v) -> f k v
runSet :: Ord k => Exp (f k v) -> f k v
runBool :: Exp Bool -> Bool

-- | cost O(min (size m) (size n) * log(max (size m) (size n))), BUT the
--   constants are high, too slow except for small maps.
sameDomain :: (Ord k, Iter f, Iter g) => f k b -> g k c -> Bool
compute :: Exp t -> t
eval :: Embed s t => Exp t -> s
computeSlow :: Exp t -> t
lifo :: Iter f => f k v -> Collect (k, v)
fifo :: Iter f => f k v -> Collect (k, v)
addp :: (Ord k, Basic f) => (v -> v -> v) -> (k, v) -> f k v -> f k v
fromList :: Ord k => BaseRep f k v -> (v -> v -> v) -> [(k, v)] -> f k v

-- | A witness (BaseRep) can be used to materialize a (Collect k v) into
--   the type witnessed by the BaseRep. Recall a (Collect k v) has no
--   intrinsic type (it is just an ABSTRACT sequence of tuples), so the
--   witness describes how to turn them into the chosen datatype. Note that
--   materialize is meant to be applied to a collection built by iterating
--   over a Query. This produces the keys in ascending order, with no
--   duplicate keys. So we do not need to specify how to merge duplicate
--   values.
materialize :: Ord k => BaseRep f k v -> Collect (k, v) -> f k v
(⨝) :: (Ord k, Iter f, Iter g) => f k b -> g k c -> Collect (k, b, c)
domEq :: (Ord k, Iter f, Iter g) => f k b -> g k c -> Collect (k, b, c)
domEqSlow :: (Ord k, Iter f, Iter g) => f k b -> g k c -> Collect (k, b, c)

module Control.SetAlgebra
data List k v
data BiMap v a b
type Bimap k v = BiMap v k v
data Single k v
[Single] :: k -> v -> Single k v
[Fail] :: Single k v
[SetSingle] :: k -> Single k ()

-- | In order to build typed Exp (which are a typed deep embedding) of Set
--   operations, we need to know what kind of basic types of Maps and Sets
--   can be used this way. Every Basic type has a few operations for
--   creating one from a list, for adding and removing key-value pairs,
--   looking up a value given a key. Instances of this algebra are
--   functional in that every key has exactly one value associated with it.
class Basic f

-- | in addpair the new value always prevails, to make a choice use
--   <a>addkv</a> which has a combining function that allows choice.
addpair :: (Basic f, Ord k) => k -> v -> f k v -> f k v

-- | use ( old new -&gt; old) if you want the v in (f k v) to prevail, and
--   use ( old new -&gt; new) if you want the v in (k,v) to prevail
addkv :: (Basic f, Ord k) => (k, v) -> f k v -> (v -> v -> v) -> f k v
removekey :: (Basic f, Ord k) => k -> f k v -> f k v
domain :: (Basic f, Ord k) => f k v -> Set k
range :: (Basic f, Ord v) => f k v -> Set v
class Iter f
nxt :: Iter f => f a b -> Collect (a, b, f a b)
lub :: (Iter f, Ord k) => k -> f k b -> Collect (k, b, f k b)
hasNxt :: Iter f => f a b -> Maybe (a, b, f a b)
hasLub :: (Iter f, Ord k) => k -> f k b -> Maybe (k, b, f k b)
haskey :: (Iter f, Ord key) => key -> f key b -> Bool
isnull :: Iter f => f k v -> Bool
lookup :: (Iter f, Ord key) => key -> f key rng -> Maybe rng
element :: (Iter f, Ord k) => k -> f k v -> Collect ()
class Embed concrete base | concrete -> base
toBase :: Embed concrete base => concrete -> base
fromBase :: Embed concrete base => base -> concrete

-- | Basic types are those that can be embedded into Exp. The HasExp class,
--   encodes how to lift a Basic type into an Exp. The function
--   <a>toExp</a> will build a typed Exp for that Basic type. This will be
--   really usefull in the smart constructors.
class HasExp s t | s -> t
toExp :: HasExp s t => s -> Exp t

-- | BaseRep witnesses Basic types. I.e. those types that are instances of
--   both Basic and Iter. Pattern matching against a constructor of type
--   BaseRep, determines which base type. For example data Tag f k v = Tag
--   (BaseRep f k v) (f k v) case Tag MapR x -&gt; -- here we know x ::
--   Map.Map k v
data BaseRep f k v
[MapR] :: Basic Map => BaseRep Map k v
[SetR] :: Basic Sett => BaseRep Sett k ()
[ListR] :: Basic List => BaseRep List k v
[SingleR] :: Basic Single => BaseRep Single k v
[BiMapR] :: (Basic (BiMap v), Ord v) => BaseRep (BiMap v) k v
[ViewR] :: (Monoid coin, Ord cred, Ord ptr, Ord coin, Ord pool) => Tag coin cred pool ptr k v -> BaseRep (View coin cred pool ptr) k v
dom :: (Ord k, HasExp s (f k v)) => s -> Exp (Sett k ())
rng :: (Ord k, Ord v) => HasExp s (f k v) => s -> Exp (Sett v ())
dexclude :: (Ord k, Iter g, HasExp s1 (g k ()), HasExp s2 (f k v)) => s1 -> s2 -> Exp (f k v)
drestrict :: (Ord k, HasExp s1 (Sett k ()), HasExp s2 (f k v)) => s1 -> s2 -> Exp (f k v)
rexclude :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) => s1 -> s2 -> Exp (f k v)
rrestrict :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) => s1 -> s2 -> Exp (f k v)
unionleft :: (Show k, Show v, Ord k, HasExp s1 (f k v), HasExp s2 (g k v)) => s1 -> s2 -> Exp (f k v)
unionright :: (Ord k, HasExp s1 (f k v), HasExp s2 (g k v)) => s1 -> s2 -> Exp (f k v)
unionplus :: (Ord k, Monoid n, HasExp s1 (f k n), HasExp s2 (g k n)) => s1 -> s2 -> Exp (f k n)
singleton :: Ord k => k -> v -> Exp (Single k v)
setSingleton :: Ord k => k -> Exp (Single k ())
intersect :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp (Sett k ())
subset :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp Bool
keyeq :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp Bool
(◁) :: (Ord k, HasExp s1 (Sett k ()), HasExp s2 (f k v)) => s1 -> s2 -> Exp (f k v)
(⋪) :: (Ord k, Iter g, HasExp s1 (g k ()), HasExp s2 (f k v)) => s1 -> s2 -> Exp (f k v)
(▷) :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) => s1 -> s2 -> Exp (f k v)
(⋫) :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) => s1 -> s2 -> Exp (f k v)
(∈) :: (Show k, Ord k, Iter g, HasExp s (g k ())) => k -> s -> Exp Bool
(∉) :: (Show k, Ord k, Iter g, HasExp s (g k ())) => k -> s -> Exp Bool
(∪) :: (Show k, Show v, Ord k, HasExp s1 (f k v), HasExp s2 (g k v)) => s1 -> s2 -> Exp (f k v)
(⨃) :: (Ord k, HasExp s1 (f k v), HasExp s2 (g k v)) => s1 -> s2 -> Exp (f k v)
(∪+) :: (Ord k, Monoid n, HasExp s1 (f k n), HasExp s2 (g k n)) => s1 -> s2 -> Exp (f k n)
(∩) :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp (Sett k ())
(⊆) :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp Bool
(≍) :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp Bool
(<|) :: (Ord k, HasExp s1 (Sett k ()), HasExp s2 (f k v)) => s1 -> s2 -> Exp (f k v)
(|>) :: (Ord k, Iter g, Ord v, HasExp s1 (f k v), HasExp s2 (g v ())) => s1 -> s2 -> Exp (f k v)
(➖) :: (Ord k, Iter f, Iter g, HasExp s1 (f k v), HasExp s2 (g k u)) => s1 -> s2 -> Exp (f k v)

-- | The self typed GADT: Exp, that encodes the shape of Set expressions. A
--   deep embedding. Exp is a typed Symbolic representation of queries we
--   may ask. It allows us to introspect a query The strategy is to 1)
--   Define Exp so all queries can be represented. 2) Define smart
--   constructors that "parse" the surface syntax, and build a typed Exp 3)
--   Write an evaluate function: eval:: Exp t -&gt; t 4) "eval" can
--   introspect the code and apply efficient domain and type specific
--   translations 5) Use the (Iter f) class to evaluate some Exp that can
--   benefit from its efficient nature.
data Exp t
[Base] :: (Ord k, Basic f, Iter f) => BaseRep f k v -> f k v -> Exp (f k v)
eval :: Embed s t => Exp t -> s

-- | A witness (BaseRep) can be used to materialize a (Collect k v) into
--   the type witnessed by the BaseRep. Recall a (Collect k v) has no
--   intrinsic type (it is just an ABSTRACT sequence of tuples), so the
--   witness describes how to turn them into the chosen datatype. Note that
--   materialize is meant to be applied to a collection built by iterating
--   over a Query. This produces the keys in ascending order, with no
--   duplicate keys. So we do not need to specify how to merge duplicate
--   values.
materialize :: Ord k => BaseRep f k v -> Collect (k, v) -> f k v
biMapToMap :: BiMap v a b -> Map a b
biMapFromMap :: (Ord k, Ord v) => Map k v -> BiMap v k v
biMapFromList :: (Ord k, Ord v) => (v -> v -> v) -> [(k, v)] -> BiMap v k v
biMapEmpty :: BiMap v k v
fromList :: Ord k => BaseRep f k v -> (v -> v -> v) -> [(k, v)] -> f k v
keysEqual :: Ord k => Map k v1 -> Map k v2 -> Bool
forwards :: BiMap v k v -> Map k v
backwards :: BiMap v k v -> Map v (Set k)
