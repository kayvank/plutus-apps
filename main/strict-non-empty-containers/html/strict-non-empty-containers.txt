-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Strict non-empty container types
--   
--   Strict non-empty container types
@package strict-non-empty-containers
@version 2020.12.8


-- | Provides a strict implementation of a non-empty map.
--   
--   This implementation is based on the implementation of <a>Strict</a>
--   provided by the <tt>containers</tt> package, but provides an extra
--   guarantee that the map contains at least one entry at all times.
module Data.Map.Strict.NonEmptyMap.Internal

-- | A non-empty map from keys of type <tt>k</tt> to values of type
--   <tt>v</tt>.
data NonEmptyMap k v

-- | Builds a non-empty map from a list of key-value pairs.
--   
--   If the list contains more than one value for the same key, the last
--   value for the key is retained.
fromList :: Ord k => NonEmpty (k, v) -> NonEmptyMap k v

-- | Builds a non-empty map from the given map.
--   
--   If the given map is empty, this function returns <a>Nothing</a>.
fromMap :: Map k v -> Maybe (NonEmptyMap k v)

-- | Creates a map with a single element.
singleton :: Ord k => k -> v -> NonEmptyMap k v

-- | Converts a non-empty map to a list of key-value pairs.
toList :: NonEmptyMap k v -> NonEmpty (k, v)

-- | Converts a non-empty map to an ordinary map.
toMap :: Ord k => NonEmptyMap k v -> Map k v

-- | Inserts a new key and value in the map.
--   
--   If the key is already present in the map, the associated value is
--   replaced with the supplied value.
insert :: Ord k => k -> v -> NonEmptyMap k v -> NonEmptyMap k v

-- | Deletes a key and its value from the map.
--   
--   When the key is not a member of the map, the original map is returned.
--   
--   This function returns <a>Nothing</a> if the delete operation reduces
--   the number of elements to zero.
delete :: Ord k => k -> NonEmptyMap k a -> Maybe (NonEmptyMap k a)

-- | Looks up the value of a key in the map.
--   
--   This function will return the corresponding value as '(Just value)',
--   or <a>Nothing</a> if the key isn't in the map.
lookup :: Ord k => k -> NonEmptyMap k v -> Maybe v

-- | Finds the union of two maps, with the given combining function.
unionWith :: Ord k => (v -> v -> v) -> NonEmptyMap k v -> NonEmptyMap k v -> NonEmptyMap k v

-- | Returns true if and only if the invariant holds for the given map.
invariantHolds :: Ord k => NonEmptyMap k v -> Bool
instance Data.Traversable.Traversable (Data.Map.Strict.NonEmptyMap.Internal.NonEmptyMap k)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Data.Map.Strict.NonEmptyMap.Internal.NonEmptyMap k v)
instance (GHC.Read.Read k, GHC.Read.Read v, GHC.Classes.Ord k) => GHC.Read.Read (Data.Map.Strict.NonEmptyMap.Internal.NonEmptyMap k v)
instance GHC.Generics.Generic (Data.Map.Strict.NonEmptyMap.Internal.NonEmptyMap k v)
instance GHC.Base.Functor (Data.Map.Strict.NonEmptyMap.Internal.NonEmptyMap k)
instance Data.Foldable.Foldable (Data.Map.Strict.NonEmptyMap.Internal.NonEmptyMap k)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.Map.Strict.NonEmptyMap.Internal.NonEmptyMap k v)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Data.Map.Strict.NonEmptyMap.Internal.NonEmptyMap k v)
instance (Data.Hashable.Class.Hashable k, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Data.Map.Strict.NonEmptyMap.Internal.NonEmptyMap k v)


-- | Provides a strict implementation of a non-empty map.
--   
--   This implementation is based on the implementation of <a>Strict</a>
--   provided by the <tt>containers</tt> package, but provides an extra
--   guarantee that the map contains at least one entry at all times.
module Data.Map.Strict.NonEmptyMap

-- | A non-empty map from keys of type <tt>k</tt> to values of type
--   <tt>v</tt>.
data NonEmptyMap k v

-- | Builds a non-empty map from a list of key-value pairs.
--   
--   If the list contains more than one value for the same key, the last
--   value for the key is retained.
fromList :: Ord k => NonEmpty (k, v) -> NonEmptyMap k v

-- | Builds a non-empty map from the given map.
--   
--   If the given map is empty, this function returns <a>Nothing</a>.
fromMap :: Map k v -> Maybe (NonEmptyMap k v)

-- | Creates a map with a single element.
singleton :: Ord k => k -> v -> NonEmptyMap k v

-- | Converts a non-empty map to a list of key-value pairs.
toList :: NonEmptyMap k v -> NonEmpty (k, v)

-- | Converts a non-empty map to an ordinary map.
toMap :: Ord k => NonEmptyMap k v -> Map k v

-- | Inserts a new key and value in the map.
--   
--   If the key is already present in the map, the associated value is
--   replaced with the supplied value.
insert :: Ord k => k -> v -> NonEmptyMap k v -> NonEmptyMap k v

-- | Deletes a key and its value from the map.
--   
--   When the key is not a member of the map, the original map is returned.
--   
--   This function returns <a>Nothing</a> if the delete operation reduces
--   the number of elements to zero.
delete :: Ord k => k -> NonEmptyMap k a -> Maybe (NonEmptyMap k a)

-- | Looks up the value of a key in the map.
--   
--   This function will return the corresponding value as '(Just value)',
--   or <a>Nothing</a> if the key isn't in the map.
lookup :: Ord k => k -> NonEmptyMap k v -> Maybe v

-- | Finds the union of two maps, with the given combining function.
unionWith :: Ord k => (v -> v -> v) -> NonEmptyMap k v -> NonEmptyMap k v -> NonEmptyMap k v


-- | Provides a strict implementation of a non-empty set.
module Data.Set.Strict.NonEmptySet

-- | A non-empty set of elements of type <tt>a</tt>.
data NonEmptySet a
fromList :: Ord a => NonEmpty a -> NonEmptySet a
fromSet :: Set a -> Maybe (NonEmptySet a)
singleton :: Ord a => a -> NonEmptySet a
toList :: NonEmptySet a -> NonEmpty a
toSet :: Ord a => NonEmptySet a -> Set a
insert :: Ord a => a -> NonEmptySet a -> NonEmptySet a
delete :: Ord a => a -> NonEmptySet a -> Maybe (NonEmptySet a)
member :: Ord a => a -> NonEmptySet a -> Bool
union :: Ord a => NonEmptySet a -> NonEmptySet a -> NonEmptySet a
instance GHC.Show.Show a => GHC.Show.Show (Data.Set.Strict.NonEmptySet.NonEmptySet a)
instance (GHC.Read.Read a, GHC.Classes.Ord a) => GHC.Read.Read (Data.Set.Strict.NonEmptySet.NonEmptySet a)
instance GHC.Generics.Generic (Data.Set.Strict.NonEmptySet.NonEmptySet a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Set.Strict.NonEmptySet.NonEmptySet a)
instance Data.Foldable.Foldable Data.Set.Strict.NonEmptySet.NonEmptySet
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Set.Strict.NonEmptySet.NonEmptySet a)
