-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type classes for concurrency with STM, ST and timing
--   
--   Type classes for concurrency with STM, ST and timing
@package io-classes
@version 0.2.0.0

module Control.Monad.Class.MonadEventlog
class Monad m => MonadEventlog m

-- | Emits a message to the eventlog, if eventlog profiling is available
--   and enabled at runtime.
traceEventIO :: MonadEventlog m => String -> m ()

-- | Emits a marker to the eventlog, if eventlog profiling is available and
--   enabled at runtime.
--   
--   The <a>String</a> is the name of the marker. The name is just used in
--   the profiling tools to help you keep clear which marker is which.
traceMarkerIO :: MonadEventlog m => String -> m ()

-- | <i>Deprecated: Use traceEventIO</i>
traceEventM :: MonadEventlog m => String -> m ()

-- | <i>Deprecated: Use traceEventIO</i>
traceMarkerM :: MonadEventlog m => String -> m ()
instance Control.Monad.Class.MonadEventlog.MonadEventlog GHC.Types.IO
instance Control.Monad.Class.MonadEventlog.MonadEventlog m => Control.Monad.Class.MonadEventlog.MonadEventlog (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Monad.Class.MonadFork
class (Monad m, Eq (ThreadId m), Ord (ThreadId m), Show (ThreadId m)) => MonadThread m where {
    type family ThreadId m :: Type;
}
myThreadId :: MonadThread m => m (ThreadId m)
labelThread :: MonadThread m => ThreadId m -> String -> m ()
class MonadThread m => MonadFork m
forkIO :: MonadFork m => m () -> m (ThreadId m)
forkIOWithUnmask :: MonadFork m => ((forall a. m a -> m a) -> m ()) -> m (ThreadId m)
throwTo :: (MonadFork m, Exception e) => ThreadId m -> e -> m ()
killThread :: MonadFork m => ThreadId m -> m ()
yield :: MonadFork m => m ()

-- | Apply the label to the current thread
labelThisThread :: MonadThread m => String -> m ()

-- | <i>Deprecated: use forkIO</i>
fork :: MonadFork m => m () -> m (ThreadId m)

-- | <i>Deprecated: use forkIO</i>
forkWithUnmask :: MonadFork m => ((forall a. m a -> m a) -> m ()) -> m (ThreadId m)
instance Control.Monad.Class.MonadFork.MonadFork GHC.Types.IO
instance Control.Monad.Class.MonadFork.MonadFork m => Control.Monad.Class.MonadFork.MonadFork (Control.Monad.Trans.Reader.ReaderT e m)
instance Control.Monad.Class.MonadFork.MonadThread GHC.Types.IO
instance Control.Monad.Class.MonadFork.MonadThread m => Control.Monad.Class.MonadFork.MonadThread (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Monad.Class.MonadST

-- | This class is for abstracting over <a>stToIO</a> which allows running
--   <a>ST</a> actions in <a>IO</a>. In this case it is to allow running
--   <a>ST</a> actions within another monad <tt>m</tt>.
--   
--   The type of <a>stToIO</a> is:
--   
--   <pre>
--   stToIO : ST RealWorld a -&gt; IO a
--   </pre>
--   
--   Abstracting over this is tricky because we need to not care about both
--   the <tt>IO</tt>, and also the <tt>RealWorld</tt>.
--   
--   A solution is to write an action that is given the <tt>liftST</tt> as
--   an argument and where that action itself is polymorphic in the
--   <tt>s</tt> parameter. This allows us to instantiate it with
--   <tt>RealWorld</tt> in the <tt>IO</tt> case, and the local <tt>s</tt>
--   in a case where we are embedding into another <tt>ST</tt> action.
class Monad m => MonadST m
withLiftST :: MonadST m => (forall s. (forall a. ST s a -> m a) -> b) -> b
instance Control.Monad.Class.MonadST.MonadST GHC.Types.IO
instance Control.Monad.Class.MonadST.MonadST (GHC.ST.ST s)
instance Control.Monad.Class.MonadST.MonadST m => Control.Monad.Class.MonadST.MonadST (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Monad.Class.MonadSay
class Monad m => MonadSay m
say :: MonadSay m => String -> m ()
instance Control.Monad.Class.MonadSay.MonadSay GHC.Types.IO
instance Control.Monad.Class.MonadSay.MonadSay m => Control.Monad.Class.MonadSay.MonadSay (Control.Monad.Trans.State.Lazy.StateT s m)

module Control.Monad.Class.MonadTest
class Monad m => MonadTest m
exploreRaces :: MonadTest m => m ()
instance Control.Monad.Class.MonadTest.MonadTest GHC.Types.IO
instance Control.Monad.Class.MonadTest.MonadTest m => Control.Monad.Class.MonadTest.MonadTest (Control.Monad.Trans.Reader.ReaderT e m)

module Control.Monad.Class.MonadThrow

-- | Throwing exceptions, and resource handling in the presence of
--   exceptions.
--   
--   Does not include the ability to respond to exceptions.
class Monad m => MonadThrow m
throwIO :: (MonadThrow m, Exception e) => e -> m a
bracket :: MonadThrow m => m a -> (a -> m b) -> (a -> m c) -> m c
bracket_ :: MonadThrow m => m a -> m b -> m c -> m c
finally :: MonadThrow m => m a -> m b -> m a
bracket :: (MonadThrow m, MonadCatch m) => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Catching exceptions.
--   
--   Covers standard utilities to respond to exceptions.
class MonadThrow m => MonadCatch m
catch :: (MonadCatch m, Exception e) => m a -> (e -> m a) -> m a
catchJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> m a -> (b -> m a) -> m a
try :: (MonadCatch m, Exception e) => m a -> m (Either e a)
tryJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> m a -> m (Either b a)
handle :: (MonadCatch m, Exception e) => (e -> m a) -> m a -> m a
handleJust :: (MonadCatch m, Exception e) => (e -> Maybe b) -> (b -> m a) -> m a -> m a
onException :: MonadCatch m => m a -> m b -> m a
bracketOnError :: MonadCatch m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | General form of bracket
--   
--   See
--   <a>http://hackage.haskell.org/package/exceptions-0.10.0/docs/Control-Monad-Catch.html#v:generalBracket</a>
--   for discussion and motivation.
generalBracket :: MonadCatch m => m a -> (a -> ExitCase b -> m c) -> (a -> m b) -> m (b, c)

-- | General form of bracket
--   
--   See
--   <a>http://hackage.haskell.org/package/exceptions-0.10.0/docs/Control-Monad-Catch.html#v:generalBracket</a>
--   for discussion and motivation.
generalBracket :: (MonadCatch m, MonadMask m) => m a -> (a -> ExitCase b -> m c) -> (a -> m b) -> m (b, c)

-- | Support for safely working in the presence of asynchronous exceptions.
--   
--   This is typically not needed directly as the utilities in
--   <a>MonadThrow</a> and <a>MonadCatch</a> cover most use cases.
class MonadCatch m => MonadMask m
mask :: MonadMask m => ((forall a. m a -> m a) -> m b) -> m b
uninterruptibleMask :: MonadMask m => ((forall a. m a -> m a) -> m b) -> m b
mask_ :: MonadMask m => m a -> m a
uninterruptibleMask_ :: MonadMask m => m a -> m a
class MonadMask m => MonadMaskingState m
getMaskingState :: MonadMaskingState m => m MaskingState

-- | Monads which can <a>evaluate</a>.
class MonadThrow m => MonadEvaluate m
evaluate :: MonadEvaluate m => a -> m a

-- | Describes the behaviour of a thread when an asynchronous exception is
--   received.
data MaskingState

-- | asynchronous exceptions are unmasked (the normal state)
Unmasked :: MaskingState

-- | the state during <a>mask</a>: asynchronous exceptions are masked, but
--   blocking operations may still be interrupted
MaskedInterruptible :: MaskingState

-- | the state during <a>uninterruptibleMask</a>: asynchronous exceptions
--   are masked, and blocking operations may not be interrupted
MaskedUninterruptible :: MaskingState

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving Show
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving Show
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | Render this exception value in a human-friendly manner.
--   
--   Default implementation: <tt><a>show</a></tt>.
displayException :: Exception e => e -> String

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException

-- | Used in <a>generalBracket</a>
--   
--   See <tt>exceptions</tt> package for discussion and motivation.
data ExitCase a
ExitCaseSuccess :: a -> ExitCase a
ExitCaseException :: SomeException -> ExitCase a
ExitCaseAbort :: ExitCase a

-- | The default handler type for <a>catches</a>, whcih is a generalisation
--   of <a>Handler</a>.
data Handler m a
Handler :: (e -> m a) -> Handler m a

-- | Like <a>catches</a> but for <a>MonadCatch</a> rather than only
--   <a>IO</a>.
catches :: forall m a. MonadCatch m => m a -> [Handler m a] -> m a

-- | <i>Deprecated: Use throwIO</i>
throwM :: (MonadThrow m, Exception e) => e -> m a
instance GHC.Base.Functor Control.Monad.Class.MonadThrow.ExitCase
instance GHC.Show.Show a => GHC.Show.Show (Control.Monad.Class.MonadThrow.ExitCase a)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Class.MonadThrow.Handler m)
instance Control.Monad.Class.MonadThrow.MonadEvaluate GHC.Types.IO
instance Control.Monad.Class.MonadThrow.MonadEvaluate m => Control.Monad.Class.MonadThrow.MonadEvaluate (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadThrow.MonadMaskingState GHC.Types.IO
instance Control.Monad.Class.MonadThrow.MonadThrow GHC.Types.IO
instance Control.Monad.Class.MonadThrow.MonadCatch GHC.Types.IO
instance Control.Monad.Class.MonadThrow.MonadMask GHC.Types.IO
instance Control.Monad.Class.MonadThrow.MonadThrow GHC.Conc.Sync.STM
instance Control.Monad.Class.MonadThrow.MonadCatch GHC.Conc.Sync.STM
instance Control.Monad.Class.MonadThrow.MonadThrow m => Control.Monad.Class.MonadThrow.MonadThrow (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadThrow.MonadCatch m => Control.Monad.Class.MonadThrow.MonadCatch (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadThrow.MonadMask m => Control.Monad.Class.MonadThrow.MonadMask (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadThrow.MonadCatch m => Control.Monad.Class.MonadThrow.MonadThrow (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Class.MonadThrow.MonadCatch m => Control.Monad.Class.MonadThrow.MonadCatch (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Class.MonadThrow.MonadMask m => Control.Monad.Class.MonadThrow.MonadMask (Control.Monad.Trans.Except.ExceptT e m)

module Control.Monad.Class.MonadSTM
class (Monad m, Alternative (STM m), MonadPlus (STM m)) => MonadSTM m where {
    type family STM m = (stm :: Type -> Type) | stm -> m;
    type family TVar m :: Type -> Type;
    type family TMVar m :: Type -> Type;
    type family TQueue m :: Type -> Type;
    type family TBQueue m :: Type -> Type;
}
atomically :: (MonadSTM m, HasCallStack) => STM m a -> m a
newTVar :: MonadSTM m => a -> STM m (TVar m a)
readTVar :: MonadSTM m => TVar m a -> STM m a
writeTVar :: MonadSTM m => TVar m a -> a -> STM m ()
retry :: MonadSTM m => STM m a
orElse :: MonadSTM m => STM m a -> STM m a -> STM m a
modifyTVar :: MonadSTM m => TVar m a -> (a -> a) -> STM m ()
modifyTVar' :: MonadSTM m => TVar m a -> (a -> a) -> STM m ()

-- | @since io-classes-0.2.0.0
stateTVar :: MonadSTM m => TVar m s -> (s -> (a, s)) -> STM m a
swapTVar :: MonadSTM m => TVar m a -> a -> STM m a
check :: MonadSTM m => Bool -> STM m ()
newTMVar :: MonadSTM m => a -> STM m (TMVar m a)
newEmptyTMVar :: MonadSTM m => STM m (TMVar m a)
takeTMVar :: MonadSTM m => TMVar m a -> STM m a
tryTakeTMVar :: MonadSTM m => TMVar m a -> STM m (Maybe a)
putTMVar :: MonadSTM m => TMVar m a -> a -> STM m ()
tryPutTMVar :: MonadSTM m => TMVar m a -> a -> STM m Bool
readTMVar :: MonadSTM m => TMVar m a -> STM m a
tryReadTMVar :: MonadSTM m => TMVar m a -> STM m (Maybe a)
swapTMVar :: MonadSTM m => TMVar m a -> a -> STM m a
isEmptyTMVar :: MonadSTM m => TMVar m a -> STM m Bool
newTQueue :: MonadSTM m => STM m (TQueue m a)
readTQueue :: MonadSTM m => TQueue m a -> STM m a
tryReadTQueue :: MonadSTM m => TQueue m a -> STM m (Maybe a)
peekTQueue :: MonadSTM m => TQueue m a -> STM m a
tryPeekTQueue :: MonadSTM m => TQueue m a -> STM m (Maybe a)
writeTQueue :: MonadSTM m => TQueue m a -> a -> STM m ()
isEmptyTQueue :: MonadSTM m => TQueue m a -> STM m Bool
newTBQueue :: MonadSTM m => Natural -> STM m (TBQueue m a)
readTBQueue :: MonadSTM m => TBQueue m a -> STM m a
tryReadTBQueue :: MonadSTM m => TBQueue m a -> STM m (Maybe a)
peekTBQueue :: MonadSTM m => TBQueue m a -> STM m a
tryPeekTBQueue :: MonadSTM m => TBQueue m a -> STM m (Maybe a)
flushTBQueue :: MonadSTM m => TBQueue m a -> STM m [a]
writeTBQueue :: MonadSTM m => TBQueue m a -> a -> STM m ()

lengthTBQueue :: MonadSTM m => TBQueue m a -> STM m Natural
isEmptyTBQueue :: MonadSTM m => TBQueue m a -> STM m Bool
isFullTBQueue :: MonadSTM m => TBQueue m a -> STM m Bool
newTVarIO :: MonadSTM m => a -> m (TVar m a)
readTVarIO :: MonadSTM m => TVar m a -> m a
newTMVarIO :: MonadSTM m => a -> m (TMVar m a)
newEmptyTMVarIO :: MonadSTM m => m (TMVar m a)
newTQueueIO :: MonadSTM m => m (TQueue m a)
newTBQueueIO :: MonadSTM m => Natural -> m (TBQueue m a)

-- | Labelled <a>TVar</a>s, <a>TMVar</a>s, <a>TQueue</a>s and
--   <a>TBQueue</a>s.
class MonadSTM m => MonadLabelledSTM m
labelTVar :: MonadLabelledSTM m => TVar m a -> String -> STM m ()
labelTMVar :: MonadLabelledSTM m => TMVar m a -> String -> STM m ()
labelTQueue :: MonadLabelledSTM m => TQueue m a -> String -> STM m ()
labelTBQueue :: MonadLabelledSTM m => TBQueue m a -> String -> STM m ()
labelTVarIO :: MonadLabelledSTM m => TVar m a -> String -> m ()
labelTMVarIO :: MonadLabelledSTM m => TMVar m a -> String -> m ()
labelTQueueIO :: MonadLabelledSTM m => TQueue m a -> String -> m ()
labelTBQueueIO :: MonadLabelledSTM m => TBQueue m a -> String -> m ()
labelTVarIO :: MonadLabelledSTM m => TVar m a -> String -> m ()
labelTMVarIO :: MonadLabelledSTM m => TMVar m a -> String -> m ()
labelTQueueIO :: MonadLabelledSTM m => TQueue m a -> String -> m ()
labelTBQueueIO :: MonadLabelledSTM m => TBQueue m a -> String -> m ()

-- | This type class is indented for 'io-sim', where one might want to
--   access <a>TVar</a> in the underlying <tt>ST</tt> monad.
class (MonadSTM m, Monad (InspectMonad m)) => MonadInspectSTM m where {
    type family InspectMonad m :: Type -> Type;
}
inspectTVar :: MonadInspectSTM m => proxy m -> TVar m a -> InspectMonad m a
inspectTMVar :: MonadInspectSTM m => proxy m -> TMVar m a -> InspectMonad m (Maybe a)

-- | A GADT which instructs how to trace the value. The <a>traceDynamic</a>
--   will use dynamic tracing, e.g. <a>traceM</a>; while <a>traceString</a>
--   will be traced with <tt>EventSay</tt>.
data TraceValue
[TraceValue] :: forall tr. Typeable tr => {traceDynamic :: Maybe tr, traceString :: Maybe String} -> TraceValue

-- | Use only dynamic tracer.
pattern TraceDynamic :: () => forall tr. Typeable tr => tr -> TraceValue

-- | Use only string tracing.
pattern TraceString :: String -> TraceValue

-- | Do not trace the value.
pattern DontTrace :: TraceValue

-- | <a>MonadTraceSTM</a> allows to trace values of stm variables when stm
--   transaction is committed. This allows to verify invariants when a
--   variable is committed.
class MonadInspectSTM m => MonadTraceSTM m
traceTVar :: MonadTraceSTM m => proxy m -> TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> STM m ()
traceTMVar :: MonadTraceSTM m => proxy m -> TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
traceTQueue :: MonadTraceSTM m => proxy m -> TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTBQueue :: MonadTraceSTM m => proxy m -> TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTMVar :: (MonadTraceSTM m, TMVar m a ~ TMVarDefault m a) => proxy m -> TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
traceTVarIO :: MonadTraceSTM m => proxy m -> TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> m ()
traceTMVarIO :: MonadTraceSTM m => proxy m -> TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> m ()
traceTQueueIO :: MonadTraceSTM m => proxy m -> TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTBQueueIO :: MonadTraceSTM m => proxy m -> TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTVarIO :: MonadTraceSTM m => proxy m -> TVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> m ()
traceTMVarIO :: MonadTraceSTM m => proxy m -> TMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> m ()
traceTQueueIO :: MonadTraceSTM m => proxy m -> TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTBQueueIO :: MonadTraceSTM m => proxy m -> TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()

-- | <i>Deprecated: Renamed back to <a>TVar</a></i>
type LazyTVar m = TVar m

-- | <i>Deprecated: Renamed back to <a>TMVar</a></i>
type LazyTMVar m = TMVar m
newtype TMVarDefault m a
TMVar :: TVar m (Maybe a) -> TMVarDefault m a
labelTMVarDefault :: MonadLabelledSTM m => TMVarDefault m a -> String -> STM m ()
traceTMVarDefault :: MonadTraceSTM m => proxy m -> TMVarDefault m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
newTMVarDefault :: MonadSTM m => a -> STM m (TMVarDefault m a)
newTMVarIODefault :: MonadSTM m => a -> m (TMVarDefault m a)
newEmptyTMVarDefault :: MonadSTM m => STM m (TMVarDefault m a)
newEmptyTMVarIODefault :: MonadSTM m => m (TMVarDefault m a)
takeTMVarDefault :: MonadSTM m => TMVarDefault m a -> STM m a
tryTakeTMVarDefault :: MonadSTM m => TMVarDefault m a -> STM m (Maybe a)
putTMVarDefault :: MonadSTM m => TMVarDefault m a -> a -> STM m ()
tryPutTMVarDefault :: MonadSTM m => TMVarDefault m a -> a -> STM m Bool
readTMVarDefault :: MonadSTM m => TMVarDefault m a -> STM m a
tryReadTMVarDefault :: MonadSTM m => TMVarDefault m a -> STM m (Maybe a)
swapTMVarDefault :: MonadSTM m => TMVarDefault m a -> a -> STM m a
isEmptyTMVarDefault :: MonadSTM m => TMVarDefault m a -> STM m Bool
data TQueueDefault m a
TQueue :: !TVar m [a] -> !TVar m [a] -> TQueueDefault m a
labelTQueueDefault :: MonadLabelledSTM m => TQueueDefault m a -> String -> STM m ()
newTQueueDefault :: MonadSTM m => STM m (TQueueDefault m a)
readTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m a
tryReadTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m (Maybe a)
peekTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m a
tryPeekTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m (Maybe a)
writeTQueueDefault :: MonadSTM m => TQueueDefault m a -> a -> STM m ()
isEmptyTQueueDefault :: MonadSTM m => TQueueDefault m a -> STM m Bool
data TBQueueDefault m a
TBQueue :: !TVar m Natural -> !TVar m [a] -> !TVar m Natural -> !TVar m [a] -> !Natural -> TBQueueDefault m a
labelTBQueueDefault :: MonadLabelledSTM m => TBQueueDefault m a -> String -> STM m ()
newTBQueueDefault :: MonadSTM m => Natural -> STM m (TBQueueDefault m a)
readTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m a
tryReadTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m (Maybe a)
peekTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m a
tryPeekTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m (Maybe a)
writeTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> a -> STM m ()
isEmptyTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m Bool
isFullTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m Bool
lengthTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m Natural
flushTBQueueDefault :: MonadSTM m => TBQueueDefault m a -> STM m [a]

-- | <a>throwIO</a> specialised to <tt>stm</tt> monad.
throwSTM :: (MonadSTM m, MonadThrow (STM m), Exception e) => e -> STM m a

-- | <a>catch</a> specialized for an <tt>stm</tt> monad.
catchSTM :: (MonadSTM m, MonadCatch (STM m), Exception e) => STM m a -> (e -> STM m a) -> STM m a

-- | <i>Deprecated: Use newTVarIO</i>
newTVarM :: MonadSTM m => a -> m (TVar m a)

-- | <i>Deprecated: Use newTMVarIO</i>
newTMVarM :: MonadSTM m => a -> m (TMVar m a)

-- | <i>Deprecated: Use newTMVarIODefault</i>
newTMVarMDefault :: MonadSTM m => a -> m (TMVarDefault m a)

-- | <i>Deprecated: Use newEmptyTMVarIO</i>
newEmptyTMVarM :: MonadSTM m => m (TMVar m a)

-- | <i>Deprecated: Use newEmptyTMVarIODefault</i>
newEmptyTMVarMDefault :: MonadSTM m => m (TMVarDefault m a)

-- | A newtype wrapper for an <a>STM</a> monad for monad transformers.
newtype WrappedSTM (t :: Trans) r (m :: Type -> Type) a
WrappedSTM :: STM m a -> WrappedSTM (t :: Trans) r (m :: Type -> Type) a
[runWrappedSTM] :: WrappedSTM (t :: Trans) r (m :: Type -> Type) a -> STM m a
instance GHC.Show.Show Control.Monad.Class.MonadSTM.BlockedIndefinitely
instance Control.Monad.Class.MonadSTM.MonadSTM m => GHC.Base.Functor (Control.Monad.Class.MonadSTM.WrappedSTM t r m)
instance Control.Monad.Class.MonadSTM.MonadSTM m => GHC.Base.Applicative (Control.Monad.Class.MonadSTM.WrappedSTM t r m)
instance Control.Monad.Class.MonadSTM.MonadSTM m => GHC.Base.Monad (Control.Monad.Class.MonadSTM.WrappedSTM t r m)
instance Control.Monad.Class.MonadSTM.MonadSTM m => GHC.Base.Alternative (Control.Monad.Class.MonadSTM.WrappedSTM t r m)
instance Control.Monad.Class.MonadSTM.MonadSTM m => GHC.Base.MonadPlus (Control.Monad.Class.MonadSTM.WrappedSTM t r m)
instance (Control.Monad.Class.MonadSTM.MonadSTM m, Control.Monad.Class.MonadThrow.MonadThrow (Control.Monad.Class.MonadSTM.STM m), Control.Monad.Class.MonadThrow.MonadCatch (Control.Monad.Class.MonadSTM.STM m)) => Control.Monad.Class.MonadThrow.MonadThrow (Control.Monad.Class.MonadSTM.WrappedSTM t r m)
instance (Control.Monad.Class.MonadSTM.MonadSTM m, Control.Monad.Class.MonadThrow.MonadThrow (Control.Monad.Class.MonadSTM.STM m), Control.Monad.Class.MonadThrow.MonadCatch (Control.Monad.Class.MonadSTM.STM m)) => Control.Monad.Class.MonadThrow.MonadCatch (Control.Monad.Class.MonadSTM.WrappedSTM t r m)
instance Control.Monad.Class.MonadSTM.MonadSTM m => Control.Monad.Class.MonadSTM.MonadSTM (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Class.MonadSTM.MonadSTM m => Control.Monad.Class.MonadSTM.MonadSTM (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monoid w, Control.Monad.Class.MonadSTM.MonadSTM m) => Control.Monad.Class.MonadSTM.MonadSTM (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Control.Monad.Class.MonadSTM.MonadSTM m => Control.Monad.Class.MonadSTM.MonadSTM (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Class.MonadSTM.MonadSTM m => Control.Monad.Class.MonadSTM.MonadSTM (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Base.Monoid w, Control.Monad.Class.MonadSTM.MonadSTM m) => Control.Monad.Class.MonadSTM.MonadSTM (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Control.Monad.Class.MonadSTM.MonadTraceSTM GHC.Types.IO
instance GHC.Exception.Type.Exception Control.Monad.Class.MonadSTM.BlockedIndefinitely
instance Control.Monad.Class.MonadSTM.MonadInspectSTM GHC.Types.IO
instance Control.Monad.Class.MonadSTM.MonadLabelledSTM GHC.Types.IO
instance Control.Monad.Class.MonadSTM.MonadSTM GHC.Types.IO

module Control.Monad.Class.MonadTime
class MonadMonotonicTime m => MonadTime m

-- | Wall clock time.
getCurrentTime :: MonadTime m => m UTCTime
class Monad m => MonadMonotonicTime m

-- | Time in a monotonic clock, with high precision. The epoch for this
--   clock is arbitrary and does not correspond to any wall clock or
--   calendar.
getMonotonicTime :: MonadMonotonicTime m => m Time

-- | A point in time in a monotonic clock.
--   
--   The epoch for this clock is arbitrary and does not correspond to any
--   wall clock or calendar, and is <i>not guaranteed</i> to be the same
--   epoch across program runs. It is represented as the <a>DiffTime</a>
--   from this arbitrary epoch.
newtype Time
Time :: DiffTime -> Time

-- | The time duration between two points in time (positive or negative).
diffTime :: Time -> Time -> DiffTime

-- | Add a duration to a point in time, giving another time.
addTime :: DiffTime -> Time -> Time
infixr 9 `addTime`

-- | This is a length of time, as measured by a clock. Conversion functions
--   will treat it as seconds. It has a precision of 10^-12 s.
data DiffTime

-- | This is the simplest representation of UTC. It consists of the day
--   number, and a time offset from midnight. Note that if a day has a leap
--   second added to it, it will have 86401 seconds.
data UTCTime

-- | diffUTCTime a b = a - b
diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime

-- | addUTCTime a b = a + b
addUTCTime :: NominalDiffTime -> UTCTime -> UTCTime

-- | This is a length of time, as measured by UTC. It has a precision of
--   10^-12 s.
--   
--   Conversion functions will treat it as seconds. For example, <tt>(0.010
--   :: NominalDiffTime)</tt> corresponds to 10 milliseconds.
--   
--   It ignores leap-seconds, so it's not necessarily a fixed amount of
--   clock time. For instance, 23:00 UTC + 2 hours of NominalDiffTime =
--   01:00 UTC (+ 1 day), regardless of whether a leap-second intervened.
data NominalDiffTime
instance GHC.Generics.Generic Control.Monad.Class.MonadTime.Time
instance GHC.Show.Show Control.Monad.Class.MonadTime.Time
instance GHC.Classes.Ord Control.Monad.Class.MonadTime.Time
instance GHC.Classes.Eq Control.Monad.Class.MonadTime.Time
instance Control.Monad.Class.MonadTime.MonadTime GHC.Types.IO
instance Control.Monad.Class.MonadTime.MonadTime m => Control.Monad.Class.MonadTime.MonadTime (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Class.MonadTime.MonadMonotonicTime GHC.Types.IO
instance Control.Monad.Class.MonadTime.MonadMonotonicTime m => Control.Monad.Class.MonadTime.MonadMonotonicTime (Control.Monad.Trans.Reader.ReaderT r m)

module Control.Monad.Class.MonadTimer
class Monad m => MonadDelay m
threadDelay :: MonadDelay m => DiffTime -> m ()
threadDelay :: (MonadDelay m, MonadTimer m) => DiffTime -> m ()
class (MonadSTM m, MonadDelay m) => MonadTimer m where {
    data family Timeout m :: Type;
}

-- | Create a new timeout which will fire at the given time duration in the
--   future.
--   
--   The timeout will start in the <a>TimeoutPending</a> state and either
--   fire at or after the given time leaving it in the <a>TimeoutFired</a>
--   state, or it may be cancelled with <a>cancelTimeout</a>, leaving it in
--   the <a>TimeoutCancelled</a> state.
--   
--   Timeouts <i>cannot</i> be reset to the pending state once fired or
--   cancelled (as this would be very racy). You should create a new
--   timeout if you need this functionality.
newTimeout :: MonadTimer m => DiffTime -> m (Timeout m)

-- | Read the current state of a timeout. This does not block, but returns
--   the current state. It is your responsibility to use <a>retry</a> to
--   wait.
--   
--   Alternatively you may wish to use the convenience utility
--   <a>awaitTimeout</a> to wait for just the fired or cancelled outcomes.
--   
--   You should consider the cancelled state if you plan to use
--   <a>cancelTimeout</a>.
readTimeout :: MonadTimer m => Timeout m -> STM m TimeoutState
updateTimeout :: MonadTimer m => Timeout m -> DiffTime -> m ()

-- | Cancel a timeout (unless it has already fired), putting it into the
--   <a>TimeoutCancelled</a> state. Code reading and acting on the timeout
--   state need to handle such cancellation appropriately.
--   
--   It is safe to race this concurrently against the timer firing. It will
--   have no effect if the timer fires first.
cancelTimeout :: MonadTimer m => Timeout m -> m ()

-- | Returns <tt>True</tt> when the timeout is fired, or <tt>False</tt> if
--   it is cancelled.
awaitTimeout :: MonadTimer m => Timeout m -> STM m Bool
registerDelay :: MonadTimer m => DiffTime -> m (TVar m Bool)
registerDelay :: (MonadTimer m, MonadFork m) => DiffTime -> m (TVar m Bool)
timeout :: MonadTimer m => DiffTime -> m a -> m (Maybe a)
data TimeoutState
TimeoutPending :: TimeoutState
TimeoutFired :: TimeoutState
TimeoutCancelled :: TimeoutState

-- | This is a length of time, as measured by a clock. Conversion functions
--   will treat it as seconds. It has a precision of 10^-12 s.
data DiffTime
diffTimeToMicrosecondsAsInt :: DiffTime -> Int
microsecondsAsIntToDiffTime :: Int -> DiffTime
instance Control.Monad.Class.MonadTimer.MonadDelay GHC.Types.IO
instance Control.Monad.Class.MonadTimer.MonadTimer GHC.Types.IO
instance Control.Monad.Class.MonadTimer.MonadDelay m => Control.Monad.Class.MonadTimer.MonadDelay (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Class.MonadTimer.MonadDelay m => Control.Monad.Class.MonadTimer.MonadDelay (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monoid w, Control.Monad.Class.MonadTimer.MonadDelay m) => Control.Monad.Class.MonadTimer.MonadDelay (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Control.Monad.Class.MonadTimer.MonadDelay m => Control.Monad.Class.MonadTimer.MonadDelay (Control.Monad.Trans.State.Lazy.StateT s m)
instance Control.Monad.Class.MonadTimer.MonadDelay m => Control.Monad.Class.MonadTimer.MonadDelay (Control.Monad.Trans.Except.ExceptT e m)
instance (GHC.Base.Monoid w, Control.Monad.Class.MonadTimer.MonadDelay m) => Control.Monad.Class.MonadTimer.MonadDelay (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance Control.Monad.Class.MonadTimer.MonadTimer m => Control.Monad.Class.MonadTimer.MonadTimer (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monoid w, Control.Monad.Class.MonadTimer.MonadTimer m) => Control.Monad.Class.MonadTimer.MonadTimer (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance Control.Monad.Class.MonadTimer.MonadTimer m => Control.Monad.Class.MonadTimer.MonadTimer (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Class.MonadTimer.MonadTimer m) => Control.Monad.Class.MonadTimer.MonadTimer (Control.Monad.Trans.RWS.Lazy.RWST r w s m)

module Control.Monad.Class.MonadAsync
class (MonadSTM m, MonadThread m) => MonadAsync m where {
    
    -- | An asynchronous action
    type family Async m = (async :: Type -> Type) | async -> m;
}
async :: MonadAsync m => m a -> m (Async m a)
asyncThreadId :: MonadAsync m => Async m a -> ThreadId m
withAsync :: MonadAsync m => m a -> (Async m a -> m b) -> m b
waitSTM :: MonadAsync m => Async m a -> STM m a
pollSTM :: MonadAsync m => Async m a -> STM m (Maybe (Either SomeException a))
waitCatchSTM :: MonadAsync m => Async m a -> STM m (Either SomeException a)
waitSTM :: (MonadAsync m, MonadThrow (STM m)) => Async m a -> STM m a
waitAnySTM :: MonadAsync m => [Async m a] -> STM m (Async m a, a)
waitAnyCatchSTM :: MonadAsync m => [Async m a] -> STM m (Async m a, Either SomeException a)
waitEitherSTM :: MonadAsync m => Async m a -> Async m b -> STM m (Either a b)
waitEitherSTM_ :: MonadAsync m => Async m a -> Async m b -> STM m ()
waitEitherCatchSTM :: MonadAsync m => Async m a -> Async m b -> STM m (Either (Either SomeException a) (Either SomeException b))
waitBothSTM :: MonadAsync m => Async m a -> Async m b -> STM m (a, b)
wait :: MonadAsync m => Async m a -> m a
poll :: MonadAsync m => Async m a -> m (Maybe (Either SomeException a))
waitCatch :: MonadAsync m => Async m a -> m (Either SomeException a)
cancel :: MonadAsync m => Async m a -> m ()
cancelWith :: (MonadAsync m, Exception e) => Async m a -> e -> m ()
uninterruptibleCancel :: MonadAsync m => Async m a -> m ()
waitAny :: MonadAsync m => [Async m a] -> m (Async m a, a)
waitAnyCatch :: MonadAsync m => [Async m a] -> m (Async m a, Either SomeException a)
waitAnyCancel :: MonadAsync m => [Async m a] -> m (Async m a, a)
waitAnyCatchCancel :: MonadAsync m => [Async m a] -> m (Async m a, Either SomeException a)
waitEither :: MonadAsync m => Async m a -> Async m b -> m (Either a b)
waitAnySTM :: (MonadAsync m, MonadThrow (STM m)) => [Async m a] -> STM m (Async m a, a)
waitEitherSTM :: (MonadAsync m, MonadThrow (STM m)) => Async m a -> Async m b -> STM m (Either a b)
waitEitherSTM_ :: (MonadAsync m, MonadThrow (STM m)) => Async m a -> Async m b -> STM m ()
waitBothSTM :: (MonadAsync m, MonadThrow (STM m)) => Async m a -> Async m b -> STM m (a, b)

-- | Note, IO-based implementations should override the default
--   implementation. See the <tt>async</tt> package implementation and
--   comments.
--   <a>http://hackage.haskell.org/package/async-2.2.1/docs/src/Control.Concurrent.Async.html#waitEitherCatch</a>
waitEitherCatch :: MonadAsync m => Async m a -> Async m b -> m (Either (Either SomeException a) (Either SomeException b))
waitEitherCancel :: MonadAsync m => Async m a -> Async m b -> m (Either a b)
waitEitherCatchCancel :: MonadAsync m => Async m a -> Async m b -> m (Either (Either SomeException a) (Either SomeException b))
waitEither_ :: MonadAsync m => Async m a -> Async m b -> m ()
waitBoth :: MonadAsync m => Async m a -> Async m b -> m (a, b)
race :: MonadAsync m => m a -> m b -> m (Either a b)
race_ :: MonadAsync m => m a -> m b -> m ()
concurrently :: MonadAsync m => m a -> m b -> m (a, b)
concurrently_ :: MonadAsync m => m a -> m b -> m ()
asyncWithUnmask :: MonadAsync m => ((forall b. m b -> m b) -> m a) -> m (Async m a)
withAsync :: (MonadAsync m, MonadMask m) => m a -> (Async m a -> m b) -> m b
uninterruptibleCancel :: (MonadAsync m, MonadMask m) => Async m a -> m ()
waitAnyCancel :: (MonadAsync m, MonadThrow m) => [Async m a] -> m (Async m a, a)
waitAnyCatchCancel :: (MonadAsync m, MonadThrow m) => [Async m a] -> m (Async m a, Either SomeException a)
waitEitherCancel :: (MonadAsync m, MonadThrow m) => Async m a -> Async m b -> m (Either a b)
waitEitherCatchCancel :: (MonadAsync m, MonadThrow m) => Async m a -> Async m b -> m (Either (Either SomeException a) (Either SomeException b))

-- | The exception thrown by <a>cancel</a> to terminate a thread.
data AsyncCancelled
AsyncCancelled :: AsyncCancelled

-- | Exception from child thread re-raised in parent thread
--   
--   We record the thread ID of the child thread as a <a>String</a>. This
--   avoids an <tt>m</tt> parameter in the type, which is important:
--   <a>ExceptionInLinkedThread</a> must be an instance of
--   <a>Exception</a>, requiring it to be <tt>Typeable</tt>; if <tt>m</tt>
--   appeared in the type, we would require <tt>m</tt> to be
--   <tt>Typeable</tt>, which does not work with with the simulator, as it
--   would require a <tt>Typeable</tt> constraint on the <tt>s</tt>
--   parameter of <tt>IOSim</tt>.
data ExceptionInLinkedThread
ExceptionInLinkedThread :: String -> SomeException -> ExceptionInLinkedThread
link :: (MonadAsync m, MonadFork m, MonadMask m) => Async m a -> m ()

-- | Generalizion of <a>link</a> that links an async to an arbitrary
--   thread.
linkTo :: (MonadAsync m, MonadFork m, MonadMask m) => ThreadId m -> Async m a -> m ()
linkOnly :: forall m a. (MonadAsync m, MonadFork m, MonadMask m) => (SomeException -> Bool) -> Async m a -> m ()
linkToOnly :: forall m a. (MonadAsync m, MonadFork m, MonadMask m) => ThreadId m -> (SomeException -> Bool) -> Async m a -> m ()
mapConcurrently :: (Traversable t, MonadAsync m) => (a -> m b) -> t a -> m (t b)
forConcurrently :: (Traversable t, MonadAsync m) => t a -> (a -> m b) -> m (t b)
mapConcurrently_ :: (Foldable f, MonadAsync m) => (a -> m b) -> f a -> m ()
forConcurrently_ :: (Foldable f, MonadAsync m) => f a -> (a -> m b) -> m ()
replicateConcurrently :: MonadAsync m => Int -> m a -> m [a]
replicateConcurrently_ :: MonadAsync m => Int -> m a -> m ()

-- | Similar to <a>Concurrently</a> but which works for any
--   <a>MonadAsync</a> instance.
newtype Concurrently m a
Concurrently :: m a -> Concurrently m a
[runConcurrently] :: Concurrently m a -> m a
instance (Control.Monad.Class.MonadAsync.MonadAsync m, Control.Monad.Class.MonadThrow.MonadCatch (Control.Monad.Class.MonadSTM.STM m)) => Control.Monad.Class.MonadAsync.MonadAsync (Control.Monad.Trans.Reader.ReaderT r m)
instance GHC.Show.Show Control.Monad.Class.MonadAsync.ExceptionInLinkedThread
instance GHC.Exception.Type.Exception Control.Monad.Class.MonadAsync.ExceptionInLinkedThread
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Class.MonadAsync.Concurrently m)
instance Control.Monad.Class.MonadAsync.MonadAsync m => GHC.Base.Applicative (Control.Monad.Class.MonadAsync.Concurrently m)
instance (Control.Monad.Class.MonadAsync.MonadAsync m, Control.Monad.Class.MonadTimer.MonadTimer m) => GHC.Base.Alternative (Control.Monad.Class.MonadAsync.Concurrently m)
instance (GHC.Base.Semigroup a, Control.Monad.Class.MonadAsync.MonadAsync m) => GHC.Base.Semigroup (Control.Monad.Class.MonadAsync.Concurrently m a)
instance (GHC.Base.Monoid a, Control.Monad.Class.MonadAsync.MonadAsync m) => GHC.Base.Monoid (Control.Monad.Class.MonadAsync.Concurrently m a)
instance Control.Monad.Class.MonadAsync.MonadAsync GHC.Types.IO
