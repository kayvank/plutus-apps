-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Shared functionality between GHC and its boot libraries
--   
--   This library is shared between GHC, ghc-pkg, and other boot libraries.
--   
--   A note about <a>GHC.PackageDb</a>: it only deals with the subset of
--   the package database that the compiler cares about: modules paths etc
--   and not package metadata like description, authors etc. It is thus not
--   a library interface to ghc-pkg and is *not* suitable for modifying GHC
--   package databases.
--   
--   The package database format and this library are constructed in such a
--   way that while ghc-pkg depends on Cabal, the GHC library and program
--   do not have to depend on Cabal.
@package ghc-boot
@version 8.10.7


-- | Note [Base Dir] ~~~~~~~~~~~~~~~~~
--   
--   GHC's base directory or top directory containers miscellaneous
--   settings and the package database. The main compiler of course needs
--   this directory to read those settings and read and write packages.
--   ghc-pkg uses it to find the global package database too.
--   
--   In the interest of making GHC builds more relocatable, many settings
--   also will expand `${top_dir}` inside strings so GHC doesn't need to
--   know it's on installation location at build time. ghc-pkg also can
--   expand those variables and so needs the top dir location to do that
--   too.
module GHC.BaseDir

-- | Expand occurrences of the <tt>$topdir</tt> interpolation in a string.
expandTopDir :: FilePath -> String -> String

-- | <pre>
--   expandPathVar var value str
--   </pre>
--   
--   replaces occurences of variable <tt>$var</tt> with <tt>value</tt> in
--   str.
expandPathVar :: String -> FilePath -> String -> String

-- | Calculate the location of the base dir
getBaseDir :: IO (Maybe String)


-- | See <tt>GHC.LanguageExtensions</tt> for an explanation on why this is
--   needed
module GHC.ForeignSrcLang
instance Data.Binary.Class.Binary GHC.ForeignSrcLang.Type.ForeignSrcLang


-- | See GHC #10762 and #15021.
module GHC.HandleEncoding

-- | Handle GHC-specific character encoding flags, allowing us to control
--   how GHC produces output regardless of OS.
configureHandleEncoding :: IO ()


-- | This module re-exports the <a>Extension</a> type along with an orphan
--   <a>Binary</a> instance for it.
--   
--   Note that the <tt>ghc-boot</tt> package has a large set of
--   dependencies; for this reason the <a>Extension</a> type itself is
--   defined in the <a>GHC.LanguageExtensions.Type</a> module provided by
--   the <tt>ghc-boot-th</tt> package, which has no dependencies outside of
--   <tt>base</tt>. For this reason <tt>template-haskell</tt> depends upon
--   <tt>ghc-boot-th</tt>, not <tt>ghc-boot</tt>.
module GHC.LanguageExtensions
instance Data.Binary.Class.Binary GHC.LanguageExtensions.Type.Extension


-- | This module provides the view of GHC's database of registered packages
--   that is shared between GHC the compiler/library, and the ghc-pkg
--   program. It defines the database format that is shared between GHC and
--   ghc-pkg.
--   
--   The database format, and this library are constructed so that GHC does
--   not have to depend on the Cabal library. The ghc-pkg program acts as
--   the gateway between the external package format (which is defined by
--   Cabal) and the internal package format which is specialised just for
--   GHC.
--   
--   GHC the compiler only needs some of the information which is kept
--   about registerd packages, such as module names, various paths etc. On
--   the other hand ghc-pkg has to keep all the information from Cabal
--   packages and be able to regurgitate it for users and other tools.
--   
--   The first trick is that we duplicate some of the information in the
--   package database. We essentially keep two versions of the datbase in
--   one file, one version used only by ghc-pkg which keeps the full
--   information (using the serialised form of the
--   <a>InstalledPackageInfo</a> type defined by the Cabal library); and a
--   second version written by ghc-pkg and read by GHC which has just the
--   subset of information that GHC needs.
--   
--   The second trick is that this module only defines in detail the format
--   of the second version -- the bit GHC uses -- and the part managed by
--   ghc-pkg is kept in the file but here we treat it as an opaque blob of
--   data. That way this library avoids depending on Cabal.
module GHC.PackageDb

-- | This is a subset of Cabal's <a>InstalledPackageInfo</a>, with just the
--   bits that GHC is interested in. See Cabal's documentation for a more
--   detailed description of all of the fields.
data InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod
InstalledPackageInfo :: instunitid -> compid -> [(modulename, mod)] -> srcpkgid -> srcpkgname -> Version -> Maybe srcpkgname -> String -> [instunitid] -> [(instunitid, String)] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [String] -> [FilePath] -> [String] -> [String] -> [String] -> [FilePath] -> [FilePath] -> [FilePath] -> [(modulename, Maybe mod)] -> [modulename] -> Bool -> Bool -> Bool -> InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod
[unitId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> instunitid
[componentId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> compid
[instantiatedWith] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(modulename, mod)]
[sourcePackageId] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> srcpkgid
[packageName] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> srcpkgname
[packageVersion] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Version
[sourceLibName] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Maybe srcpkgname
[abiHash] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> String
[depends] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [instunitid]

-- | Like <a>depends</a>, but each dependency is annotated with the ABI
--   hash we expect the dependency to respect.
[abiDepends] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(instunitid, String)]
[importDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[hsLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[extraLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[extraGHCiLibraries] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[libraryDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[libraryDynDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[frameworks] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[frameworkDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[ldOptions] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[ccOptions] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[includes] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [String]
[includeDirs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[haddockInterfaces] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[haddockHTMLs] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [FilePath]
[exposedModules] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [(modulename, Maybe mod)]
[hiddenModules] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> [modulename]
[indefinite] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool
[exposed] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool
[trusted] :: InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod -> Bool

-- | <tt>ghc-boot</tt>'s copy of <tt>Module</tt>, i.e. what is serialized
--   to the database. Use <a>DbUnitIdModuleRep</a> to convert it into an
--   actual <tt>Module</tt>. It has phantom type parameters as this is the
--   most convenient way to avoid undecidable instances.
data DbModule instunitid compid unitid modulename mod
DbModule :: unitid -> modulename -> DbModule instunitid compid unitid modulename mod
[dbModuleUnitId] :: DbModule instunitid compid unitid modulename mod -> unitid
[dbModuleName] :: DbModule instunitid compid unitid modulename mod -> modulename
DbModuleVar :: modulename -> DbModule instunitid compid unitid modulename mod
[dbModuleVarName] :: DbModule instunitid compid unitid modulename mod -> modulename

-- | <tt>ghc-boot</tt>'s copy of <tt>UnitId</tt>, i.e. what is serialized
--   to the database. Use <a>DbUnitIdModuleRep</a> to convert it into an
--   actual <tt>UnitId</tt>. It has phantom type parameters as this is the
--   most convenient way to avoid undecidable instances.
data DbUnitId instunitid compid unitid modulename mod
DbUnitId :: compid -> [(modulename, mod)] -> DbUnitId instunitid compid unitid modulename mod
DbInstalledUnitId :: instunitid -> DbUnitId instunitid compid unitid modulename mod
class BinaryStringRep a
fromStringRep :: BinaryStringRep a => ByteString -> a
toStringRep :: BinaryStringRep a => a -> ByteString

-- | A type-class for the types which can be converted into
--   <a>DbModule</a>/<a>DbUnitId</a>. There is only one type class because
--   these types are mutually recursive. NB: The functional dependency
--   helps out type inference in cases where types would be ambiguous.
class DbUnitIdModuleRep instunitid compid unitid modulename mod | mod -> unitid, unitid -> mod, mod -> modulename, unitid -> compid, unitid -> instunitid
fromDbModule :: DbUnitIdModuleRep instunitid compid unitid modulename mod => DbModule instunitid compid unitid modulename mod -> mod
toDbModule :: DbUnitIdModuleRep instunitid compid unitid modulename mod => mod -> DbModule instunitid compid unitid modulename mod
fromDbUnitId :: DbUnitIdModuleRep instunitid compid unitid modulename mod => DbUnitId instunitid compid unitid modulename mod -> unitid
toDbUnitId :: DbUnitIdModuleRep instunitid compid unitid modulename mod => unitid -> DbUnitId instunitid compid unitid modulename mod
emptyInstalledPackageInfo :: RepInstalledPackageInfo a b c d e f g => InstalledPackageInfo a b c d e f g

-- | Represents a lock of a package db.
data PackageDbLock

-- | Acquire an exclusive lock related to package DB under given location.
lockPackageDb :: FilePath -> IO PackageDbLock

-- | Release the lock related to package DB.
unlockPackageDb :: PackageDbLock -> IO ()

-- | Mode to open a package db in.
data DbMode
DbReadOnly :: DbMode
DbReadWrite :: DbMode

-- | <a>DbOpenMode</a> holds a value of type <tt>t</tt> but only in
--   <a>DbReadWrite</a> mode. So it is like <a>Maybe</a> but with a type
--   argument for the mode to enforce that the mode is used consistently.
data DbOpenMode (mode :: DbMode) t
[DbOpenReadOnly] :: DbOpenMode 'DbReadOnly t
[DbOpenReadWrite] :: t -> DbOpenMode 'DbReadWrite t
isDbOpenReadMode :: DbOpenMode mode t -> Bool

-- | Read the part of the package DB that GHC is interested in.
readPackageDbForGhc :: RepInstalledPackageInfo a b c d e f g => FilePath -> IO [InstalledPackageInfo a b c d e f g]

-- | Read the part of the package DB that ghc-pkg is interested in
--   
--   Note that the Binary instance for ghc-pkg's representation of packages
--   is not defined in this package. This is because ghc-pkg uses Cabal
--   types (and Binary instances for these) which this package does not
--   depend on.
--   
--   If we open the package db in read only mode, we get its contents.
--   Otherwise we additionally receive a PackageDbLock that represents a
--   lock on the database, so that we can safely update it later.
readPackageDbForGhcPkg :: Binary pkgs => FilePath -> DbOpenMode mode t -> IO (pkgs, DbOpenMode mode PackageDbLock)

-- | Write the whole of the package DB, both parts.
writePackageDb :: (Binary pkgs, RepInstalledPackageInfo a b c d e f g) => FilePath -> [InstalledPackageInfo a b c d e f g] -> pkgs -> IO ()
instance (GHC.Show.Show instunitid, GHC.Show.Show compid, GHC.Show.Show modulename, GHC.Show.Show mod, GHC.Show.Show srcpkgid, GHC.Show.Show srcpkgname) => GHC.Show.Show (GHC.PackageDb.InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod)
instance (GHC.Classes.Eq instunitid, GHC.Classes.Eq compid, GHC.Classes.Eq modulename, GHC.Classes.Eq mod, GHC.Classes.Eq srcpkgid, GHC.Classes.Eq srcpkgname) => GHC.Classes.Eq (GHC.PackageDb.InstalledPackageInfo compid srcpkgid srcpkgname instunitid unitid modulename mod)
instance (GHC.Show.Show unitid, GHC.Show.Show modulename) => GHC.Show.Show (GHC.PackageDb.DbModule instunitid compid unitid modulename mod)
instance (GHC.Classes.Eq unitid, GHC.Classes.Eq modulename) => GHC.Classes.Eq (GHC.PackageDb.DbModule instunitid compid unitid modulename mod)
instance (GHC.Show.Show compid, GHC.Show.Show modulename, GHC.Show.Show mod, GHC.Show.Show instunitid) => GHC.Show.Show (GHC.PackageDb.DbUnitId instunitid compid unitid modulename mod)
instance (GHC.Classes.Eq compid, GHC.Classes.Eq modulename, GHC.Classes.Eq mod, GHC.Classes.Eq instunitid) => GHC.Classes.Eq (GHC.PackageDb.DbUnitId instunitid compid unitid modulename mod)
instance GHC.Base.Functor (GHC.PackageDb.DbOpenMode mode)
instance Data.Foldable.Foldable (GHC.PackageDb.DbOpenMode mode)
instance Data.Traversable.Traversable (GHC.PackageDb.DbOpenMode mode)
instance GHC.PackageDb.RepInstalledPackageInfo a b c d e f g => Data.Binary.Class.Binary (GHC.PackageDb.InstalledPackageInfo a b c d e f g)
instance (GHC.PackageDb.BinaryStringRep modulename, GHC.PackageDb.BinaryStringRep compid, GHC.PackageDb.BinaryStringRep instunitid, GHC.PackageDb.DbUnitIdModuleRep instunitid compid unitid modulename mod) => Data.Binary.Class.Binary (GHC.PackageDb.DbModule instunitid compid unitid modulename mod)
instance (GHC.PackageDb.BinaryStringRep modulename, GHC.PackageDb.BinaryStringRep compid, GHC.PackageDb.BinaryStringRep instunitid, GHC.PackageDb.DbUnitIdModuleRep instunitid compid unitid modulename mod) => Data.Binary.Class.Binary (GHC.PackageDb.DbUnitId instunitid compid unitid modulename mod)


-- | A description of the platform we're compiling for.
module GHC.Platform

-- | Contains the bare-bones arch and os information. This isn't enough for
--   code gen, but useful for tasks where we can fall back upon the host
--   platform, as this is all we know about the host platform.
data PlatformMini
PlatformMini :: Arch -> OS -> PlatformMini
[platformMini_arch] :: PlatformMini -> Arch
[platformMini_os] :: PlatformMini -> OS
data PlatformWordSize

-- | A 32-bit platform
PW4 :: PlatformWordSize

-- | A 64-bit platform
PW8 :: PlatformWordSize

-- | Contains enough information for the native code generator to emit code
--   for this platform.
data Platform
Platform :: PlatformMini -> PlatformWordSize -> Bool -> Bool -> Bool -> Bool -> Bool -> Platform
[platformMini] :: Platform -> PlatformMini
[platformWordSize] :: Platform -> PlatformWordSize
[platformUnregisterised] :: Platform -> Bool
[platformHasGnuNonexecStack] :: Platform -> Bool
[platformHasIdentDirective] :: Platform -> Bool
[platformHasSubsectionsViaSymbols] :: Platform -> Bool
[platformIsCrossCompiling] :: Platform -> Bool

-- | Legacy accessor
platformArch :: Platform -> Arch

-- | Legacy accessor
platformOS :: Platform -> OS

-- | Architectures that the native code generator knows about. TODO: It
--   might be nice to extend these constructors with information about what
--   instruction set extensions an architecture might support.
data Arch
ArchUnknown :: Arch
ArchX86 :: Arch
ArchX86_64 :: Arch
ArchPPC :: Arch
ArchPPC_64 :: PPC_64ABI -> Arch
[ppc_64ABI] :: Arch -> PPC_64ABI
ArchS390X :: Arch
ArchSPARC :: Arch
ArchSPARC64 :: Arch
ArchARM :: ArmISA -> [ArmISAExt] -> ArmABI -> Arch
[armISA] :: Arch -> ArmISA
[armISAExt] :: Arch -> [ArmISAExt]
[armABI] :: Arch -> ArmABI
ArchAArch64 :: Arch
ArchAlpha :: Arch
ArchMipseb :: Arch
ArchMipsel :: Arch
ArchJavaScript :: Arch

-- | Operating systems that the native code generator knows about. Having
--   OSUnknown should produce a sensible default, but no promises.
data OS
OSUnknown :: OS
OSLinux :: OS
OSDarwin :: OS
OSSolaris2 :: OS
OSMinGW32 :: OS
OSFreeBSD :: OS
OSDragonFly :: OS
OSOpenBSD :: OS
OSNetBSD :: OS
OSKFreeBSD :: OS
OSHaiku :: OS
OSQNXNTO :: OS
OSAIX :: OS
OSHurd :: OS

-- | ARM Instruction Set Architecture, Extensions and ABI
data ArmISA
ARMv5 :: ArmISA
ARMv6 :: ArmISA
ARMv7 :: ArmISA
data ArmISAExt
VFPv2 :: ArmISAExt
VFPv3 :: ArmISAExt
VFPv3D16 :: ArmISAExt
NEON :: ArmISAExt
IWMMX2 :: ArmISAExt
data ArmABI
SOFT :: ArmABI
SOFTFP :: ArmABI
HARD :: ArmABI

-- | PowerPC 64-bit ABI
data PPC_64ABI
ELF_V1 :: PPC_64ABI
ELF_V2 :: PPC_64ABI

-- | This predicate tells us whether the platform is 32-bit.
target32Bit :: Platform -> Bool
isARM :: Arch -> Bool

-- | This predicate tells us whether the OS supports ELF-like shared
--   libraries.
osElfTarget :: OS -> Bool

-- | This predicate tells us whether the OS support Mach-O shared
--   libraries.
osMachOTarget :: OS -> Bool
osSubsectionsViaSymbols :: OS -> Bool
platformUsesFrameworks :: Platform -> Bool
platformWordSizeInBytes :: Platform -> Int
platformWordSizeInBits :: Platform -> Int

-- | Platform-specific settings formerly hard-coded in Config.hs.
--   
--   These should probably be all be triaged whether they can be computed
--   from other settings or belong in another another place (like
--   <a>Platform</a> above).
data PlatformMisc
PlatformMisc :: String -> String -> IntegerLibrary -> Bool -> Bool -> Bool -> String -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> String -> PlatformMisc
[platformMisc_targetPlatformString] :: PlatformMisc -> String
[platformMisc_integerLibrary] :: PlatformMisc -> String
[platformMisc_integerLibraryType] :: PlatformMisc -> IntegerLibrary
[platformMisc_ghcWithInterpreter] :: PlatformMisc -> Bool
[platformMisc_ghcWithNativeCodeGen] :: PlatformMisc -> Bool
[platformMisc_ghcWithSMP] :: PlatformMisc -> Bool
[platformMisc_ghcRTSWays] :: PlatformMisc -> String

-- | Determines whether we will be compiling info tables that reside just
--   before the entry code, or with an indirection to the entry code. See
--   TABLES_NEXT_TO_CODE in includes<i>rts</i>storage/InfoTables.h.
[platformMisc_tablesNextToCode] :: PlatformMisc -> Bool
[platformMisc_leadingUnderscore] :: PlatformMisc -> Bool
[platformMisc_libFFI] :: PlatformMisc -> Bool
[platformMisc_ghcThreaded] :: PlatformMisc -> Bool
[platformMisc_ghcDebugged] :: PlatformMisc -> Bool
[platformMisc_ghcRtsWithLibdw] :: PlatformMisc -> Bool
[platformMisc_llvmTarget] :: PlatformMisc -> String
data IntegerLibrary
IntegerGMP :: IntegerLibrary
IntegerSimple :: IntegerLibrary

-- | See Note [Platform Syntax].
stringEncodeArch :: Arch -> String

-- | See Note [Platform Syntax].
stringEncodeOS :: OS -> String
instance GHC.Classes.Eq GHC.Platform.PlatformWordSize
instance GHC.Classes.Eq GHC.Platform.OS
instance GHC.Show.Show GHC.Platform.OS
instance GHC.Read.Read GHC.Platform.OS
instance GHC.Classes.Eq GHC.Platform.ArmISA
instance GHC.Show.Show GHC.Platform.ArmISA
instance GHC.Read.Read GHC.Platform.ArmISA
instance GHC.Classes.Eq GHC.Platform.ArmISAExt
instance GHC.Show.Show GHC.Platform.ArmISAExt
instance GHC.Read.Read GHC.Platform.ArmISAExt
instance GHC.Classes.Eq GHC.Platform.ArmABI
instance GHC.Show.Show GHC.Platform.ArmABI
instance GHC.Read.Read GHC.Platform.ArmABI
instance GHC.Classes.Eq GHC.Platform.PPC_64ABI
instance GHC.Show.Show GHC.Platform.PPC_64ABI
instance GHC.Read.Read GHC.Platform.PPC_64ABI
instance GHC.Classes.Eq GHC.Platform.Arch
instance GHC.Show.Show GHC.Platform.Arch
instance GHC.Read.Read GHC.Platform.Arch
instance GHC.Classes.Eq GHC.Platform.PlatformMini
instance GHC.Show.Show GHC.Platform.PlatformMini
instance GHC.Read.Read GHC.Platform.PlatformMini
instance GHC.Classes.Eq GHC.Platform.Platform
instance GHC.Show.Show GHC.Platform.Platform
instance GHC.Read.Read GHC.Platform.Platform
instance GHC.Classes.Eq GHC.Platform.IntegerLibrary
instance GHC.Show.Show GHC.Platform.IntegerLibrary
instance GHC.Read.Read GHC.Platform.IntegerLibrary
instance GHC.Show.Show GHC.Platform.PlatformWordSize
instance GHC.Read.Read GHC.Platform.PlatformWordSize

module GHC.Platform.Host
cHostPlatformArch :: Arch
cHostPlatformOS :: OS
cHostPlatformMini :: PlatformMini

module GHC.Serialized

-- | Represents a serialized value of a particular type. Attempts can be
--   made to deserialize it at certain types
data Serialized
Serialized :: TypeRep -> [Word8] -> Serialized

-- | Put a Typeable value that we are able to actually turn into bytes into
--   a <a>Serialized</a> value ready for deserialization later
toSerialized :: forall a. Typeable a => (a -> [Word8]) -> a -> Serialized

-- | If the <a>Serialized</a> value contains something of the given type,
--   then use the specified deserializer to return <tt>Just</tt> that.
--   Otherwise return <tt>Nothing</tt>.
fromSerialized :: forall a. Typeable a => ([Word8] -> a) -> Serialized -> Maybe a

-- | Use a <a>Data</a> instance to implement a serialization scheme dual to
--   that of <a>deserializeWithData</a>
serializeWithData :: Data a => a -> [Word8]

-- | Use a <a>Data</a> instance to implement a deserialization scheme dual
--   to that of <a>serializeWithData</a>
deserializeWithData :: Data a => [Word8] -> a

module GHC.Settings
getTargetPlatform :: FilePath -> RawSettings -> Either String Platform
type RawSettings = Map String String

-- | See Note [Settings file] for "0" suffix
getSetting0 :: FilePath -> RawSettings -> String -> Either String String

-- | See Note [Settings file] for "0" suffix
getFilePathSetting0 :: FilePath -> FilePath -> RawSettings -> String -> Either String String

-- | See Note [Settings file] for "0" suffix
getBooleanSetting0 :: FilePath -> RawSettings -> String -> Either String Bool

-- | See Note [Settings file] for "0" suffix
readSetting0 :: (Show a, Read a) => FilePath -> RawSettings -> String -> Either String a
maybeRead :: Read a => String -> Maybe a
maybeReadFuzzy :: Read a => String -> Maybe a

module GHC.Version
cProjectGitCommitId :: String
cProjectVersion :: String
cProjectVersionInt :: String
cProjectPatchLevel :: String
cProjectPatchLevel1 :: String
cProjectPatchLevel2 :: String

module GHC.UniqueSubdir

-- | A filepath like <tt>x86_64-linux-7.6.3</tt> with the platform string
--   to use when constructing platform-version-dependent files that need to
--   co-exist.
--   
--   'ghc-pkg' falls back on the host platform if the settings file is
--   missing, and so needs this since we don't have information about the
--   host platform in as much detail as <a>Platform</a>, so we use
--   <a>PlatformMini</a> instead.
uniqueSubdir :: PlatformMini -> FilePath
