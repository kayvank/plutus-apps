-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core integration test library.
--   
--   Shared core functionality for our integration test suites.
@package cardano-wallet-core-integration
@version 2022.7.1


-- | Restore benchmark CLI handling and setup functions which are shared
--   between backends.
module Cardano.Wallet.BenchShared
data RestoreBenchArgs
RestoreBenchArgs :: String -> FilePath -> Maybe FilePath -> Maybe CardanoNodeConn -> Bool -> RestoreBenchArgs
[argNetworkName] :: RestoreBenchArgs -> String
[argConfigsDir] :: RestoreBenchArgs -> FilePath
[argNodeDatabaseDir] :: RestoreBenchArgs -> Maybe FilePath
[argUseAlreadyRunningNodeSocketPath] :: RestoreBenchArgs -> Maybe CardanoNodeConn
[argQuiet] :: RestoreBenchArgs -> Bool
getRestoreBenchArgs :: IO RestoreBenchArgs
argsNetworkDir :: RestoreBenchArgs -> FilePath
execBenchWithNode :: (RestoreBenchArgs -> cfg) -> (Trace IO Text -> cfg -> CardanoNodeConn -> IO ()) -> IO ExitCode
initBenchmarkLogging :: Text -> Severity -> IO (Configuration, Trace IO Text)
runBenchmarks :: Buildable a => [IO a] -> IO ()
bench :: NFData a => Text -> IO a -> IO (a, Time)
data Time
instance GHC.Classes.Eq Cardano.Wallet.BenchShared.RestoreBenchArgs
instance GHC.Show.Show Cardano.Wallet.BenchShared.RestoreBenchArgs
instance GHC.Generics.Generic Cardano.Wallet.BenchShared.Time
instance GHC.Show.Show Cardano.Wallet.BenchShared.Time
instance Formatting.Buildable.Buildable Cardano.Wallet.BenchShared.Time
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.BenchShared.Time

module Cardano.Wallet.LatencyBenchShared
withLatencyLogging :: (TVar [LogObject ApiLog] -> tracers) -> (tracers -> LogCaptureFunc ApiLog b -> IO a) -> IO a
measureApiLogs :: LogCaptureFunc ApiLog () -> IO a -> IO [NominalDiffTime]
type LogCaptureFunc msg b = IO b -> IO ([LogObject msg], b)
fmtResult :: String -> [NominalDiffTime] -> IO ()
fmtTitle :: Builder -> IO ()

module Test.Integration.Faucet

-- | An opaque <a>Faucet</a> type from which one can get a wallet with
--   funds
data Faucet
Faucet :: MVar [Mnemonic 15] -> MVar [Mnemonic 15] -> MVar [Mnemonic 12] -> MVar [Mnemonic 24] -> MVar [Mnemonic 24] -> MVar [(Address, Coin) -> IO ByteString] -> Faucet
[shelley] :: Faucet -> MVar [Mnemonic 15]
[icarus] :: Faucet -> MVar [Mnemonic 15]
[random] :: Faucet -> MVar [Mnemonic 12]
[reward] :: Faucet -> MVar [Mnemonic 24]
[ma] :: Faucet -> MVar [Mnemonic 24]
[txBuilder] :: Faucet -> MVar [(Address, Coin) -> IO ByteString]

-- | Get the next faucet wallet. Requires the <tt>initFaucet</tt> to be
--   called in order to get a hand on a <a>Faucet</a>.
class NextWallet (scheme :: Symbol)
nextWallet :: NextWallet scheme => Faucet -> IO (Mnemonic (MnemonicSize scheme))

-- | Get a raw transaction builder. It constructs and sign a transaction
--   via an private key that is owned "externally". Returns a bytes string
--   ready to be sent to a node.
nextTxBuilder :: Faucet -> IO ((Address, Coin) -> IO ByteString)
seqMnemonics :: [Mnemonic 15]
icaMnemonics :: [Mnemonic 15]
rndMnemonics :: [Mnemonic 12]
mirMnemonics :: [Mnemonic 24]
maMnemonics :: [Mnemonic 24]

-- | A special Shelley Wallet with 200 UTxOs where 100 of them are 1 ADA
bigDustWallet :: Mnemonic 15

-- | A special wallet with only dust
onlyDustWallet :: Mnemonic 15
seaHorseTokenName :: Int -> TokenName
seaHorsePolicyId :: TokenPolicyId
shelleyIntegrationTestFunds :: [(Address, Coin)]
byronIntegrationTestFunds :: [(Address, Coin)]

-- | A list of addresses, and assets to be provisioned there.
--   
--   Beside the assets, there is a list of <tt>(signing key, verification
--   key hash)</tt>, so that they can be minted by the faucet.
maryIntegrationTestAssets :: Coin -> [(Address, (TokenBundle, [(String, String)]))]

-- | Create <tt>n</tt> unique SeaHorse tokens for each provided
--   <a>Address</a>.
--   
--   The result can be used for minting using the cli-based faucet.
seaHorseTestAssets :: Int -> Coin -> [Address] -> [(Address, (TokenBundle, [(String, String)]))]
hwWalletFunds :: [(Text, Coin)]

-- | Generate faucets addresses and mnemonics to a file.
--   
--   <pre>
--   &gt;&gt;&gt; genMnemonics 100 &gt;&gt;= genByronFaucets "byron-faucets.yaml"
--   </pre>
genByronFaucets :: FilePath -> [Mnemonic 12] -> IO [[Text]]

-- | Generate faucet addresses and mnemonics to a file.
--   
--   <pre>
--   &gt;&gt;&gt; genMnemonics 100 &gt;&gt;= genShelleyFaucets "shelley-faucets.yaml"
--   </pre>
genShelleyFaucets :: FilePath -> [Mnemonic 15] -> IO [[Text]]

-- | Generate faucet addresses and mnemonics to a file.
--   
--   <pre>
--   &gt;&gt;&gt; genMnemonics 100 &gt;&gt;= genMAFaucets "ma-faucets.yaml"
--   </pre>
genMAFaucets :: FilePath -> [Mnemonic 24] -> IO [[Text]]
genMnemonics :: forall mw ent csz. (ValidMnemonicSentence mw, ValidEntropySize ent, ValidChecksumSize ent csz, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Int -> IO [Mnemonic mw]
genShelleyAddresses :: SomeMnemonic -> [Address]
genRewardAccounts :: Mnemonic 24 -> [XPub]
instance Test.Integration.Faucet.NextWallet "shelley"
instance Test.Integration.Faucet.NextWallet "icarus"
instance Test.Integration.Faucet.NextWallet "random"
instance Test.Integration.Faucet.NextWallet "reward"
instance Test.Integration.Faucet.NextWallet "ma"

module Test.Integration.Framework.Context

-- | Context for integration tests.
data Context
Context :: IO () -> (URI, Manager) -> Port "wallet" -> Faucet -> ((ByteString, Coin) -> IO ()) -> (TxDescription -> (Natural, Natural)) -> NetworkParameters -> IORef [PoolGarbageCollectionEvent] -> ApiEra -> Text -> (Int -> Int -> Coin -> [Address] -> IO ()) -> Context

-- | A cleanup action.
[_cleanup] :: Context -> IO ()

-- | The underlying base URL and manager used by the wallet client.
[_manager] :: Context -> (URI, Manager)

-- | Server TCP port.
[_walletPort] :: Context -> Port "wallet"

-- | Provides access to funded wallets.
[_faucet] :: Context -> Faucet

-- | A function to inject rewards into some stake address.
[_moveRewardsToScript] :: Context -> (ByteString, Coin) -> IO ()

-- | A fee estimator.
[_feeEstimator] :: Context -> TxDescription -> (Natural, Natural)

-- | Blockchain parameters for the underlying chain.
[_networkParameters] :: Context -> NetworkParameters

-- | The complete list of pool garbage collection events. Most recent
--   events are stored at the head of the list.
[_poolGarbageCollectionEvents] :: Context -> IORef [PoolGarbageCollectionEvent]

-- | The main era the tests are expected to run on. Allows tests to make
--   era-specific assertions.
[_mainEra] :: Context -> ApiEra

-- | Base URL of the mock smash server.
[_smashUrl] :: Context -> Text

-- | TODO: Remove once we can unify cardano-wallet-core-integration and
--   cardano-wallet:integration, or when the wallet supports minting.
--   
--   Cannot be used by several tests at a time. (!)
[_mintSeaHorseAssets] :: Context -> Int -> Int -> Coin -> [Address] -> IO ()

-- | Records the parameters and return value of a single call to the
--   <tt>removeRetiredPools</tt> operation of <a>DBLayer</a>.
data PoolGarbageCollectionEvent
PoolGarbageCollectionEvent :: EpochNo -> [PoolRetirementCertificate] -> PoolGarbageCollectionEvent

-- | The epoch number parameter.
[poolGarbageCollectionEpochNo] :: PoolGarbageCollectionEvent -> EpochNo

-- | The pools that were removed from the database.
[poolGarbageCollectionCertificates] :: PoolGarbageCollectionEvent -> [PoolRetirementCertificate]

-- | Describe a transaction in terms of its inputs and outputs.
data TxDescription
DelegDescription :: DelegationAction -> TxDescription
PaymentDescription :: Int -> Int -> Int -> TxDescription
[nInputs] :: TxDescription -> Int
[nOutputs] :: TxDescription -> Int
[nChanges] :: TxDescription -> Int
instance GHC.Show.Show Test.Integration.Framework.Context.PoolGarbageCollectionEvent
instance GHC.Classes.Eq Test.Integration.Framework.Context.PoolGarbageCollectionEvent
instance GHC.Show.Show Test.Integration.Framework.Context.TxDescription
instance GHC.Generics.Generic Test.Integration.Framework.Context.Context

module Test.Integration.Framework.Request

-- | Makes a request to the API and decodes the response.
request :: forall a m s. (FromJSON a, MonadIO m, MonadUnliftIO m, HasType (URI, Manager) s) => s -> (Method, Text) -> Headers -> Payload -> m (Status, Either RequestException a)

-- | Like <a>request</a>, but does not attempt to deserialize the response.
rawRequest :: forall m s. (MonadIO m, MonadUnliftIO m, HasType (URI, Manager) s) => s -> (Method, Text) -> Headers -> Payload -> m (Status, Either RequestException ByteString)

-- | Makes a request to the API, but throws if it fails.
unsafeRequest :: forall a m. (FromJSON a, MonadIO m, MonadUnliftIO m) => Context -> (Method, Text) -> Payload -> m (Status, a)

-- | The headers of the request
data Headers
Headers :: RequestHeaders -> Headers
Default :: Headers
None :: Headers

-- | The payload of the request
data Payload
Json :: Value -> Payload
NonJson :: ByteString -> Payload
Empty :: Payload

-- | The result when <a>request</a> fails.
data RequestException

-- | JSON decoding the given response data failed.
DecodeFailure :: ByteString -> String -> RequestException

-- | The HTTP response status code indicated failure.
ClientError :: Value -> RequestException

-- | The HTTP response status code indicated failure and the response was
--   not valid JSON.
RawClientError :: ByteString -> RequestException

-- | A wild exception upon sending the request
HttpException :: HttpExceptionContent -> RequestException
instance GHC.Show.Show Test.Integration.Framework.Request.RequestException
instance GHC.Show.Show Test.Integration.Framework.Request.Payload
instance GHC.Show.Show Test.Integration.Framework.Request.Headers
instance GHC.Exception.Type.Exception Test.Integration.Framework.Request.RequestException

module Test.Integration.Framework.DSL

-- | Context for integration tests.
data Context
Context :: IO () -> (URI, Manager) -> Port "wallet" -> Faucet -> ((ByteString, Coin) -> IO ()) -> (TxDescription -> (Natural, Natural)) -> NetworkParameters -> IORef [PoolGarbageCollectionEvent] -> ApiEra -> Text -> (Int -> Int -> Coin -> [Address] -> IO ()) -> Context

-- | A cleanup action.
[_cleanup] :: Context -> IO ()

-- | The underlying base URL and manager used by the wallet client.
[_manager] :: Context -> (URI, Manager)

-- | Server TCP port.
[_walletPort] :: Context -> Port "wallet"

-- | Provides access to funded wallets.
[_faucet] :: Context -> Faucet

-- | A function to inject rewards into some stake address.
[_moveRewardsToScript] :: Context -> (ByteString, Coin) -> IO ()

-- | A fee estimator.
[_feeEstimator] :: Context -> TxDescription -> (Natural, Natural)

-- | Blockchain parameters for the underlying chain.
[_networkParameters] :: Context -> NetworkParameters

-- | The complete list of pool garbage collection events. Most recent
--   events are stored at the head of the list.
[_poolGarbageCollectionEvents] :: Context -> IORef [PoolGarbageCollectionEvent]

-- | The main era the tests are expected to run on. Allows tests to make
--   era-specific assertions.
[_mainEra] :: Context -> ApiEra

-- | Base URL of the mock smash server.
[_smashUrl] :: Context -> Text

-- | TODO: Remove once we can unify cardano-wallet-core-integration and
--   cardano-wallet:integration, or when the wallet supports minting.
--   
--   Cannot be used by several tests at a time. (!)
[_mintSeaHorseAssets] :: Context -> Int -> Int -> Coin -> [Address] -> IO ()
data MnemonicLength
M9 :: MnemonicLength
M12 :: MnemonicLength
M15 :: MnemonicLength
M18 :: MnemonicLength
M21 :: MnemonicLength
M24 :: MnemonicLength

-- | Describe a transaction in terms of its inputs and outputs.
data TxDescription
DelegDescription :: DelegationAction -> TxDescription
PaymentDescription :: Int -> Int -> Int -> TxDescription
[nInputs] :: TxDescription -> Int
[nOutputs] :: TxDescription -> Int
[nChanges] :: TxDescription -> Int

-- | Makes a request to the API and decodes the response.
request :: forall a m s. (FromJSON a, MonadIO m, MonadUnliftIO m, HasType (URI, Manager) s) => s -> (Method, Text) -> Headers -> Payload -> m (Status, Either RequestException a)

-- | Like <a>request</a>, but does not attempt to deserialize the response.
rawRequest :: forall m s. (MonadIO m, MonadUnliftIO m, HasType (URI, Manager) s) => s -> (Method, Text) -> Headers -> Payload -> m (Status, Either RequestException ByteString)

-- | Makes a request to the API, but throws if it fails.
unsafeRequest :: forall a m. (FromJSON a, MonadIO m, MonadUnliftIO m) => Context -> (Method, Text) -> Payload -> m (Status, a)
unsafeResponse :: (Status, Either RequestException a) -> a

-- | A file is eventually created on the given location
expectPathEventuallyExist :: HasCallStack => FilePath -> IO ()

-- | Expect a successful response, without any further assumptions.
expectSuccess :: (HasCallStack, MonadIO m) => (s, Either RequestException a) -> m ()

-- | Expect an error response, without any further assumptions.
expectError :: (HasCallStack, MonadIO m, Show a) => (s, Either RequestException a) -> m ()

-- | Expect an error response, without any further assumptions.
expectErrorMessage :: (HasCallStack, MonadIO m, Show a) => String -> (s, Either RequestException a) -> m ()
expectField :: (HasCallStack, MonadIO m, Show a) => Traversal' s a -> (a -> Expectation) -> (Status, Either RequestException s) -> m ()
expectListField :: (HasCallStack, MonadIO m, Show a) => Int -> Traversal' s a -> (a -> Expectation) -> (Status, Either RequestException [s]) -> m ()

-- | Expects data list returned by the API to be of certain length
expectListSize :: (HasCallStack, MonadIO m, Foldable xs) => Int -> (Status, Either RequestException (xs a)) -> m ()

-- | Expects data list returned by the API to be of certain length
expectListSizeSatisfy :: (HasCallStack, MonadIO m, Foldable xs) => (Int -> Bool) -> (Status, Either RequestException (xs a)) -> m ()

-- | Expect a given response code on the response.
expectResponseCode :: (HasCallStack, MonadUnliftIO m, Show a) => Status -> (Status, a) -> m ()

-- | Expects a given string to be a valid JSON output corresponding to some
--   given data-type <tt>a</tt>. Returns this type if successful.
expectValidJSON :: forall m a. (HasCallStack, FromJSON a, MonadIO m) => Proxy a -> String -> m a
expectCliField :: (HasCallStack, MonadIO m, Show a) => Lens' s a -> (a -> Expectation) -> s -> m ()
expectCliListField :: (HasCallStack, MonadIO m, Show a) => Int -> Lens' s a -> (a -> Expectation) -> [s] -> m ()

-- | Expects wallet UTxO statistics from the request to be equal to
--   pre-calculated statistics.
expectWalletUTxO :: (HasCallStack, MonadIO m) => [Natural] -> Either RequestException ApiUtxoStatistics -> m ()
between :: (Ord a, Show a) => (a, a) -> a -> Expectation

-- | Can be used to add context to a <tt>HUnitFailure</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; counterexample (show response) (0 `shouldBe` 3)
--   
--   &gt;&gt;&gt; (Status {statusCode = 200, statusMessage = "OK"},Right [])
--   
--   &gt;&gt;&gt; expected: 3
--   
--   &gt;&gt;&gt; but got: 0
--   </pre>
counterexample :: (MonadIO m, MonadUnliftIO m, HasCallStack) => String -> m a -> m a
(.>=) :: (Ord a, Show a) => a -> a -> Expectation
(.<=) :: (Ord a, Show a) => a -> a -> Expectation
(.>) :: (Ord a, Show a) => a -> a -> Expectation
(.<) :: (Ord a, Show a) => a -> a -> Expectation

-- | Applies the value <tt>a</tt> to all assertions in the given sequence.
--   
--   If any of the assertions fail, <tt>a</tt> is shown as the
--   counter-example text.
verify :: (Show a, MonadUnliftIO m) => a -> [a -> m ()] -> m ()

-- | Applies the value <tt>a</tt> to all assertions in the given sequence.
--   
--   Like <a>verify</a>, but the counterexample shows a description of what
--   conditions were being checked.
verifyMsg :: (Show a, MonadUnliftIO m) => String -> a -> [a -> m ()] -> m ()

-- | The headers of the request
data Headers
Headers :: RequestHeaders -> Headers
Default :: Headers
None :: Headers

-- | The payload of the request
data Payload
Json :: Value -> Payload
NonJson :: ByteString -> Payload
Empty :: Payload

-- | The result when <a>request</a> fails.
data RequestException

-- | JSON decoding the given response data failed.
DecodeFailure :: ByteString -> String -> RequestException

-- | The HTTP response status code indicated failure.
ClientError :: Value -> RequestException

-- | The HTTP response status code indicated failure and the response was
--   not valid JSON.
RawClientError :: ByteString -> RequestException

-- | A wild exception upon sending the request
HttpException :: HttpExceptionContent -> RequestException
walletId :: HasType (ApiT WalletId) s => Lens' s Text

-- | Minimum UTxO parameter for the test cluster.
--   
--   The value returned by this function is only appropriate for a very
--   minimal output, where:
--   
--   <ul>
--   <li>the output has no assets other than ada.</li>
--   <li>the output uses a Shelley-era address of the length typically used
--   in the integration test suite.</li>
--   <li>the output has no datum hash.</li>
--   </ul>
--   
--   This value will almost certainly not be correct for outputs with
--   non-ada assets, for outputs with longer addresses, or outputs with a
--   datum hash.
--   
--   In those cases, a larger value will be required. The precise value can
--   be determined by calling one of the endpoints that returns an
--   <a>ApiFee</a> object, and inspecting the <tt>minimumCoins</tt> field.
minUTxOValue :: ApiEra -> Natural
minUTxOValueForMinLengthAddress :: ApiEra -> Natural

-- | Parameter in test cluster shelley genesis.
--   
--   This space left blank intentionally.
slotLengthValue :: NominalDiffTime

-- | Parameter in test cluster shelley genesis.
securityParameterValue :: Word32

-- | Parameter in test cluster shelley genesis.
epochLengthValue :: Word32

-- | Wallet server's chosen transaction TTL value (in seconds) when none is
--   given.
defaultTxTTL :: NominalDiffTime
maximumCollateralInputCountByEra :: ApiEra -> Word16
minimumCollateralPercentageByEra :: ApiEra -> Natural

-- | Restore HW Wallet from pub key
restoreWalletFromPubKey :: forall w (style :: WalletStyle) m. (Discriminate style, PostWallet style, HasType (ApiT WalletId) w, HasType (ApiT SyncProgress) w, Show w, FromJSON w, MonadIO m, MonadUnliftIO m) => Context -> Text -> Text -> ResourceT m w

-- | Create an empty wallet
emptyRandomWallet :: (MonadIO m, MonadUnliftIO m) => Context -> ResourceT m ApiByronWallet
emptyRandomWalletMws :: (MonadIO m, MonadUnliftIO m) => Context -> ResourceT m (ApiByronWallet, Mnemonic 12)
emptyRandomWalletWithPasswd :: (MonadIO m, MonadUnliftIO m) => Context -> Text -> ResourceT m ApiByronWallet
emptyIcarusWallet :: (MonadIO m, MonadUnliftIO m) => Context -> ResourceT m ApiByronWallet
emptyIcarusWalletMws :: (MonadIO m, MonadUnliftIO m) => Context -> ResourceT m (ApiByronWallet, Mnemonic 15)
emptyByronWalletWith :: forall m. (MonadIO m, MonadUnliftIO m) => Context -> String -> (Text, [Text], Text) -> ResourceT m ApiByronWallet
postWallet :: (MonadIO m, MonadUnliftIO m) => Context -> Payload -> ResourceT m (Status, Either RequestException ApiWallet)
postWallet' :: (MonadIO m, MonadUnliftIO m) => Context -> Headers -> Payload -> ResourceT m (Status, Either RequestException ApiWallet)
postByronWallet :: (MonadIO m, MonadUnliftIO m) => Context -> Payload -> ResourceT m (Status, Either RequestException ApiByronWallet)

-- | Create an empty wallet
emptyWallet :: (MonadIO m, MonadUnliftIO m) => Context -> ResourceT m ApiWallet

-- | Create an empty wallet
emptyWalletWith :: (MonadIO m, MonadUnliftIO m) => Context -> (Text, Text, Int) -> ResourceT m ApiWallet
emptyWalletAndMnemonic :: MonadUnliftIO m => Context -> ResourceT m (ApiWallet, [Text])
emptyWalletAndMnemonicAndSndFactor :: MonadUnliftIO m => Context -> ResourceT m (ApiWallet, [Text], [Text])
emptyWalletAndMnemonicWith :: (MonadIO m, MonadUnliftIO m) => Context -> (Text, Text, Int) -> ResourceT m (ApiWallet, [Text])
emptyByronWalletFromXPrvWith :: forall m. (MonadIO m, MonadUnliftIO m) => Context -> String -> (Text, Text, Text) -> ResourceT m ApiByronWallet
rewardWallet :: (MonadIO m, MonadUnliftIO m) => Context -> ResourceT m (ApiWallet, Mnemonic 24)
postSharedWallet :: (MonadIO m, MonadUnliftIO m) => Context -> Headers -> Payload -> ResourceT m (Status, Either RequestException ApiSharedWallet)
deleteSharedWallet :: forall m. (MonadIO m, MonadUnliftIO m) => Context -> ApiSharedWallet -> m (Status, Either RequestException Value)
getSharedWallet :: forall m. (MonadIO m, MonadUnliftIO m) => Context -> ApiSharedWallet -> m (Status, Either RequestException ApiSharedWallet)
patchSharedWallet :: forall m. (MonadIO m, MonadUnliftIO m) => Context -> ApiSharedWallet -> CredentialType -> Payload -> m (Status, Either RequestException ApiSharedWallet)
getSharedWalletKey :: forall m. (MonadIO m, MonadUnliftIO m) => Context -> ApiSharedWallet -> Role -> DerivationIndex -> Maybe Bool -> m (Status, Either RequestException ApiVerificationKeyShared)
postAccountKeyShared :: forall m. (MonadIO m, MonadUnliftIO m) => Context -> ApiSharedWallet -> DerivationIndex -> Headers -> Payload -> m (Status, Either RequestException ApiAccountKeyShared)
getAccountKeyShared :: forall m. (MonadIO m, MonadUnliftIO m) => Context -> ApiSharedWallet -> Maybe KeyFormat -> m (Status, Either RequestException ApiAccountKeyShared)
getSomeVerificationKey :: forall m. (MonadIO m, MonadUnliftIO m) => Context -> ApiWallet -> m (ApiVerificationKeyShelley, ApiT (Hash "VerificationKey"))

-- | Calls 'GET /wallets' and filters the response. This allows tests to be
--   written for a parallel setting.
listFilteredWallets :: (MonadIO m, MonadUnliftIO m) => Set Text -> Context -> m (Status, Either RequestException [ApiWallet])

-- | Calls 'GET /byron-wallets' and filters the response. This allows tests
--   to be written for a parallel setting.
listFilteredByronWallets :: (MonadIO m, MonadUnliftIO m) => Set Text -> Context -> m (Status, Either RequestException [ApiByronWallet])
listFilteredSharedWallets :: (MonadIO m, MonadUnliftIO m) => Set Text -> Context -> m (Status, Either RequestException [ApiSharedWallet])
getWalletIdFromSharedWallet :: ApiSharedWallet -> ApiT WalletId
(</>) :: ToHttpApiData a => Text -> a -> Text
infixr 5 </>

-- | List index (subscript) operator, starting from 0. It is an instance of
--   the more general <a>genericIndex</a>, which takes an index of any
--   integral type.
(!!) :: [a] -> Int -> a
infixl 9 !!

-- | Computes the effective fee for an <a>ApiCoinSelection</a> value.
--   
--   The <a>ApiCoinSelection</a> type doesn't include a field to indicate
--   the fee.
--   
--   This function computes the effective fee by subtracting the total
--   output value from the total input value.
computeApiCoinSelectionFee :: ApiCoinSelection n -> Coin
isValidDerivationPath :: Index 'Hardened 'PurposeK -> NonEmpty (ApiT DerivationIndex) -> Bool
isValidRandomDerivationPath :: NonEmpty (ApiT DerivationIndex) -> Bool
genMnemonics :: MnemonicLength -> IO [Text]
genMnemonics' :: forall mw ent csz m. (ConsistentEntropy ent mw csz, ValidEntropySize ent, ValidChecksumSize ent csz, ent ~ EntropySize mw, mw ~ MnemonicWords ent, MonadIO m) => m [Text]
getFromResponse :: HasCallStack => Lens' s a -> (Status, Either RequestException s) -> a
getFromResponseList :: Int -> Lens' s a -> (Status, Either RequestException [s]) -> a
json :: QuasiQuoter
joinStakePool :: forall n w m. (HasType (ApiT WalletId) w, DecodeAddress n, DecodeStakeAddress n, MonadIO m, MonadUnliftIO m) => Context -> ApiT PoolId -> (w, Text) -> m (Status, Either RequestException (ApiTransaction n))
joinStakePoolUnsigned :: forall n style w. (HasType (ApiT WalletId) w, DecodeAddress n, EncodeAddress n, DecodeStakeAddress n, Discriminate style) => Context -> w -> ApiT PoolId -> IO (Status, Either RequestException (ApiCoinSelection n))
delegationFee :: forall w m. (HasType (ApiT WalletId) w, MonadIO m, MonadUnliftIO m) => Context -> w -> m (Status, Either RequestException ApiFee)
quitStakePool :: forall n w m. (HasType (ApiT WalletId) w, DecodeAddress n, DecodeStakeAddress n, MonadIO m, MonadUnliftIO m) => Context -> (w, Text) -> m (Status, Either RequestException (ApiTransaction n))
quitStakePoolUnsigned :: forall n style w m. (HasType (ApiT WalletId) w, DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, MonadIO m, Discriminate style) => Context -> w -> m (Status, Either RequestException (ApiCoinSelection n))
selectCoins :: forall n style w m. (HasType (ApiT WalletId) w, DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, Discriminate style, MonadIO m, MonadUnliftIO m) => Context -> w -> NonEmpty (AddressAmount (ApiT Address, Proxy n)) -> m (Status, Either RequestException (ApiCoinSelection n))
selectCoinsWith :: forall n style w m. (HasType (ApiT WalletId) w, DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, Discriminate style, MonadIO m, MonadUnliftIO m) => Context -> w -> NonEmpty (AddressAmount (ApiT Address, Proxy n)) -> (Payload -> Payload) -> m (Status, Either RequestException (ApiCoinSelection n))
listAddresses :: forall n m. (MonadIO m, MonadUnliftIO m, DecodeAddress n) => Context -> ApiWallet -> m [ApiAddress n]
signTx :: MonadUnliftIO m => Context -> ApiWallet -> ApiT SealedTx -> [(Status, Either RequestException ApiSerialisedTransaction) -> m ()] -> m ApiSerialisedTransaction
submitTx :: MonadUnliftIO m => Context -> ApiSerialisedTransaction -> [(Status, Either RequestException ApiTxId) -> m ()] -> m ApiTxId
submitTxWithWid :: MonadUnliftIO m => Context -> ApiWallet -> ApiSerialisedTransaction -> m (Status, Either RequestException ApiTxId)
getWallet :: forall w m. (MonadIO m, MonadUnliftIO m, HasType (ApiT WalletId) w) => Context -> w -> m ApiWallet
listTransactions :: forall n w m. (DecodeAddress n, DecodeStakeAddress n, HasType (ApiT WalletId) w, MonadIO m, MonadUnliftIO m) => Context -> w -> Maybe UTCTime -> Maybe UTCTime -> Maybe SortOrder -> m [ApiTransaction n]
listAllTransactions :: forall n w m. (DecodeAddress n, DecodeStakeAddress n, HasType (ApiT WalletId) w, MonadIO m, MonadUnliftIO m) => Context -> w -> m [ApiTransaction n]

-- | Delete all wallets
deleteAllWallets :: Context -> IO ()
fixtureRawTx :: Context -> (Address, Natural) -> IO ByteString
fixtureRandomWallet :: (MonadIO m, MonadUnliftIO m) => Context -> ResourceT m ApiByronWallet

-- | Restore a faucet Random wallet and wait until funds are available.
fixtureRandomWalletMws :: (MonadIO m, MonadUnliftIO m) => Context -> ResourceT m (ApiByronWallet, Mnemonic 12)
fixtureRandomWalletAddrs :: forall (n :: NetworkDiscriminant) m. (PaymentAddress n ByronKey, MonadIO m, MonadUnliftIO m) => Context -> ResourceT m (ApiByronWallet, [Address])

-- | Restore a wallet with the given UTxO distribution. Note that there's a
--   limitation to what can be done here. We only have 10 UTxO available in
--   each faucet and they "only" have 'faucetUtxoAmt = 100_000 Ada' in
--   each.
--   
--   This function makes no attempt at ensuring the request is valid, so be
--   careful.
--   
--   TODO: Remove duplication between Shelley / Byron fixtures.
fixtureRandomWalletWith :: forall (n :: NetworkDiscriminant) m. (EncodeAddress n, DecodeAddress n, DecodeStakeAddress n, PaymentAddress n ByronKey, MonadIO m, MonadUnliftIO m) => Context -> [Natural] -> ResourceT m ApiByronWallet
fixtureIcarusWallet :: (MonadIO m, MonadUnliftIO m) => Context -> ResourceT m ApiByronWallet

-- | Restore a faucet Icarus wallet and wait until funds are available.
fixtureIcarusWalletMws :: (MonadIO m, MonadUnliftIO m) => Context -> ResourceT m (ApiByronWallet, Mnemonic 15)
fixtureIcarusWalletAddrs :: forall (n :: NetworkDiscriminant) m. (PaymentAddress n IcarusKey, MonadIO m, MonadUnliftIO m) => Context -> ResourceT m (ApiByronWallet, [Address])

-- | Restore a wallet with the given UTxO distribution. Note that there's a
--   limitation to what can be done here. We only have 10 UTxO available in
--   each faucet and they "only" have 'faucetUtxoAmt = 100_000 Ada' in
--   each.
--   
--   This function makes no attempt at ensuring the request is valid, so be
--   careful.
--   
--   TODO: Remove duplication between Shelley / Byron fixtures.
fixtureIcarusWalletWith :: forall (n :: NetworkDiscriminant) m. (EncodeAddress n, DecodeAddress n, DecodeStakeAddress n, PaymentAddress n IcarusKey, MonadIO m, MonadUnliftIO m) => Context -> [Natural] -> ResourceT m ApiByronWallet

-- | Restore a faucet and wait until funds are available.
--   
--   Note: <tt>ResourceT</tt> is used to allow automatic garbage collection
--   of unused wallets through small blocks of <tt>runResourceT</tt> (e.g.
--   once per test). It doesn't return <tt>ReleaseKey</tt> since manual
--   releasing is not needed.
fixtureWallet :: MonadIO m => Context -> ResourceT m ApiWallet

-- | Restore a wallet with the given UTxO distribution. Note that there's a
--   limitation to what can be done here. We only have 10 UTxO available in
--   each faucet and they "only" have 'faucetUtxoAmt = 100_000 Ada' in
--   each.
--   
--   This function makes no attempt at ensuring the request is valid, so be
--   careful.
fixtureWalletWith :: forall n m. (EncodeAddress n, DecodeAddress n, DecodeStakeAddress n, MonadIO m, MonadUnliftIO m) => Context -> [Natural] -> ResourceT m ApiWallet
fixtureWalletWithMnemonics :: forall m scheme. (MonadIO m, NextWallet scheme) => Proxy scheme -> Context -> ResourceT m (ApiWallet, [Text])
fixtureMultiAssetWallet :: MonadIO m => Context -> ResourceT m ApiWallet
fixtureMultiAssetRandomWallet :: forall n m. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, MonadIO m, MonadUnliftIO m) => Context -> ResourceT m ApiByronWallet
fixtureMultiAssetIcarusWallet :: forall n m. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, MonadIO m, MonadUnliftIO m) => Context -> ResourceT m ApiByronWallet

-- | Create a fixture from the same mnemonic every time. Don't wait for it
--   to restore before returning.
constFixtureWalletNoWait :: MonadIO m => Context -> ResourceT m ApiWallet

-- | Total amount on each faucet wallet
faucetAmt :: Natural

-- | Each faucet wallet is composed of 10 times a single faucet UTxO of
--   100_000 Ada.
faucetUtxoAmt :: Natural
proc' :: FilePath -> [String] -> CreateProcess
postTx :: forall n w m. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, HasType (ApiT WalletId) w, MonadIO m, MonadUnliftIO m) => Context -> (w, w -> (Method, Text), Text) -> ApiWallet -> Natural -> m (Status, Either RequestException (ApiTransaction n))
pickAnAsset :: TokenMap -> ((Text, Text), Natural)
mkTxPayloadMA :: forall n m. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, MonadUnliftIO m) => (ApiT Address, Proxy n) -> Natural -> [((Text, Text), Natural)] -> Text -> m Payload

-- | Wait for a booting wallet server to start. Wait up to 30s or fail.
waitForServer :: forall ctx m. (HasType (Port "wallet") ctx, MonadIO m) => ctx -> m ()

-- | <a>map</a> flipped.
for :: [a] -> (a -> b) -> [b]
utcIso8601ToText :: UTCTime -> Text
eventually :: MonadIO m => String -> IO a -> m a
eventuallyUsingDelay :: MonadIO m => Int -> Int -> String -> IO a -> m a

-- | Default passphrase used for fixture wallets
fixturePassphrase :: Text

-- | fixturePassphrase encrypted by Scrypt function
fixturePassphraseEncrypted :: Text
waitForNextEpoch :: (MonadIO m, MonadUnliftIO m) => Context -> m ()
waitForTxImmutability :: MonadIO m => Context -> m ()
waitAllTxsInLedger :: forall n m. (DecodeAddress n, DecodeStakeAddress n, MonadIO m, MonadUnliftIO m) => Context -> ApiWallet -> m ()
toQueryString :: [(Text, Text)] -> Text

-- | Override the method of a particular endpoint, mostly to exercise
--   invalid endpoints from existing ones.
withMethod :: Method -> (Method, Text) -> (Method, Text)

-- | Modifies the value of a path parameter at position <tt>n</tt> (indexed
--   from 0) with the given update function. Throws if the given endpoint
--   has no path parameter in the given position.
--   
--   <pre>
--   &gt;&gt;&gt; Link.getWallet @Shelley myWallet
--   ( "GET", "v2/wallets/2512a00e9653fe49a44a5886202e24d77eeb998f" )
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withPathParam 0 (&lt;&gt; "suffix") $ Link.getWallet @Shelley myWallet
--   ( "GET", "v2/wallets/2512a00e9653fe49a44a5886202e24d77eeb998fsuffix" )
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; withPathParam 1 (const "suffix") $ Link.joinStakePool @Shelley myPool myWallet
--   ( "GET", "v2/stake-pools/2512a00e9653fe49a44a5886202e24d77eeb998f/wallets/patate" )
--   </pre>
withPathParam :: Int -> (Text -> Text) -> (Method, Text) -> (Method, Text)
addField :: ToJSON a => Text -> a -> Payload -> Payload

-- | Generate an infinite list of addresses for icarus wallets
--   
--   To be typically used as:
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (icarusAddresses @n)
--   [addr]
--   </pre>
icarusAddresses :: forall (n :: NetworkDiscriminant). PaymentAddress n IcarusKey => Mnemonic 15 -> [Address]

-- | Generate an infinite list of addresses for random wallets.
--   
--   To be typically used as:
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (randomAddresses @n)
--   [addr]
--   </pre>
randomAddresses :: forall (n :: NetworkDiscriminant). PaymentAddress n ByronKey => Mnemonic 12 -> [Address]

-- | Generate an infinite list of addresses for shelley wallets.
--   
--   To be typically used as:
--   
--   <pre>
--   &gt;&gt;&gt; take 1 (shelleyAddresses @n)
--   [addr]
--   </pre>
shelleyAddresses :: forall (n :: NetworkDiscriminant). PaymentAddress n ShelleyKey => Mnemonic 15 -> [Address]
pubKeyFromMnemonics :: [Text] -> Text
rootPrvKeyFromMnemonics :: [Text] -> Text -> Text
unsafeGetTransactionTime :: MonadUnliftIO m => [ApiTransaction n] -> m UTCTime
getTxId :: ApiTransaction n -> String
oneSecond :: Int

-- | Converts a transaction TTL in seconds into a number of slots, using
--   the slot length.
getTTLSlots :: MonadIO m => Context -> NominalDiffTime -> m SlotNo
updateMetadataSource :: (MonadIO m, MonadUnliftIO m) => Context -> Text -> m ()
bracketSettings :: (MonadIO m, MonadUnliftIO m) => Context -> m () -> m ()
verifyMetadataSource :: (MonadIO m, MonadUnliftIO m) => Context -> PoolMetadataSource -> m ()
triggerMaintenanceAction :: (MonadIO m, MonadUnliftIO m) => Context -> Text -> m ()
verifyMaintenanceAction :: (MonadIO m, MonadUnliftIO m) => Context -> PoolMetadataGCStatus -> m ()
genXPubs :: Int -> IO [(XPub, Text)]
hexText :: ByteString -> Text
fromHexText :: Text -> Either String ByteString
accPubKeyFromMnemonics :: SomeMnemonic -> Maybe SomeMnemonic -> Word32 -> Passphrase "encryption" -> Text

-- | Wallet not delegating and not about to join any stake pool.
notDelegating :: [(Maybe (ApiT PoolId), ApiEpochInfo)] -> ApiWalletDelegation
delegating :: ApiT PoolId -> [(Maybe (ApiT PoolId), ApiEpochInfo)] -> ApiWalletDelegation
getSlotParams :: MonadIO m => Context -> m (EpochNo, SlottingParameters)
arbitraryStake :: Maybe Coin
commandName :: String

-- | Execute a system command. Before running <a>command</a> make sure you
--   <a>need</a> any files that are required by the command.
--   
--   This function takes a list of options (often just <tt>[]</tt>, see
--   <a>CmdOption</a> for the available options), the name of the
--   executable (either a full name, or a program on the <tt>$PATH</tt>)
--   and a list of arguments. The result is often <tt>()</tt>, but can be a
--   tuple containg any of <a>Stdout</a>, <a>Stderr</a> and <a>Exit</a>.
--   Some examples:
--   
--   <pre>
--   <a>command_</a> [] "gcc" ["-c","myfile.c"]                          -- compile a file, throwing an exception on failure
--   <a>Exit</a> c &lt;- <a>command</a> [] "gcc" ["-c",myfile]                     -- run a command, recording the exit code
--   (<a>Exit</a> c, <a>Stderr</a> err) &lt;- <a>command</a> [] "gcc" ["-c","myfile.c"]   -- run a command, recording the exit code and error output
--   <a>Stdout</a> out &lt;- <a>command</a> [] "gcc" ["-MM","myfile.c"]            -- run a command, recording the output
--   <a>command_</a> [<a>Cwd</a> "generated"] "gcc" ["-c",myfile]               -- run a command in a directory
--   </pre>
--   
--   Unless you retrieve the <a>ExitCode</a> using <a>Exit</a>, any
--   <a>ExitFailure</a> will throw an error, including the <a>Stderr</a> in
--   the exception message. If you capture the <a>Stdout</a> or
--   <a>Stderr</a>, that stream will not be echoed to the console, unless
--   you use the option <a>EchoStdout</a> or <a>EchoStderr</a>.
--   
--   If you use <a>command</a> inside a <tt>do</tt> block and do not use
--   the result, you may get a compile-time error about being unable to
--   deduce <a>CmdResult</a>. To avoid this error, use <a>command_</a>.
command :: CmdResult r => [CmdOption] -> String -> [String] -> IO r

-- | Run a command using the 'cardano-wallet' executable.
cardanoWalletCLI :: forall r m. (CmdResult r, MonadIO m) => [String] -> m r
generateMnemonicsViaCLI :: forall r m. (CmdResult r, MonadIO m) => [String] -> m r
createWalletViaCLI :: forall s m. (HasType (Port "wallet") s, MonadIO m) => s -> [String] -> String -> String -> String -> ResourceT m (ExitCode, String, Text)
createWalletFromPublicKeyViaCLI :: forall s m. (HasType (Port "wallet") s, MonadIO m) => s -> [String] -> ResourceT m (Exit, Stdout, Stderr)
deleteWalletViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> String -> m r
getWalletUtxoSnapshotViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> String -> m r
getWalletUtxoStatisticsViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> String -> m r
getWalletViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> String -> m r
createAddressViaCLI :: forall s m. (HasType (Port "wallet") s, MonadIO m) => s -> [String] -> String -> m (ExitCode, Text, Text)
importAddressViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> [String] -> m r
listAddressesViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> [String] -> m r
listStakePoolsViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> m r
listWalletsViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> m r
updateWalletNameViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> [String] -> m r
updateWalletPassphraseViaCLI :: forall s m. (HasType (Port "wallet") s, MonadIO m) => s -> String -> String -> String -> String -> m (ExitCode, Text, Text)
updateWalletPassphraseWithMnemonicViaCLI :: forall s m. (HasType (Port "wallet") s, MonadIO m) => s -> String -> [Text] -> String -> String -> m (ExitCode, Text, Text)
postTransactionViaCLI :: forall s m. (HasType (Port "wallet") s, MonadIO m) => s -> String -> [String] -> m (ExitCode, String, Text)
postTransactionFeeViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> [String] -> m r
listTransactionsViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> TxMetadataSchema -> [String] -> m r
postExternalTransactionViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> [String] -> m r
deleteTransactionViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> String -> String -> m r
getTransactionViaCLI :: forall r s m. (CmdResult r, HasType (Port "wallet") s, MonadIO m) => s -> String -> String -> TxMetadataSchema -> m r
getRetirementEpoch :: ApiStakePool -> Maybe EpochNo

-- | Returns the first address, modified to have the same stake key as the
--   second address.
--   
--   Only intended to be used with well-known inputs in tests, so throws if
--   anything goes unexpectedly.
replaceStakeKey :: forall (n :: NetworkDiscriminant). (DecodeAddress n, EncodeAddress n) => (ApiT Address, Proxy n) -> (ApiT Address, Proxy n) -> (ApiT Address, Proxy n)

-- | Unwrap a <a>ResourceT</a> transformer, and call all registered release
--   actions.
--   
--   Note that there is some reference counting involved due to
--   <a>resourceForkIO</a>. If multiple threads are sharing the same
--   collection of resources, only the last call to <tt>runResourceT</tt>
--   will deallocate the resources.
--   
--   <i>NOTE</i> Since version 1.2.0, this function will throw a
--   <a>ResourceCleanupException</a> if any of the cleanup functions throw
--   an exception.
runResourceT :: MonadUnliftIO m => ResourceT m a -> m a

-- | The Resource transformer. This transformer keeps track of all
--   registered actions, and calls them upon exit (via
--   <tt>runResourceT</tt>). Actions may be registered via
--   <tt>register</tt>, or resources may be allocated atomically via
--   <tt>allocate</tt>. <tt>allocate</tt> corresponds closely to
--   <tt>bracket</tt>.
--   
--   Releasing may be performed before exit via the <tt>release</tt>
--   function. This is a highly recommended optimization, as it will ensure
--   that scarce resources are freed early. Note that calling
--   <tt>release</tt> will deregister the action, so that a release action
--   will only ever be called once.
--   
--   Since 0.3.0
data ResourceT (m :: Type -> Type) a
instance GHC.Show.Show Test.Integration.Framework.DSL.MnemonicLength

module Test.Integration.Framework.TestData
chineseMnemonics9 :: [Text]
chineseMnemonics18 :: [Text]
frenchMnemonics12 :: [Text]
frenchMnemonics21 :: [Text]
invalidMnemonics12 :: [Text]
invalidMnemonics15 :: [Text]
japaneseMnemonics12 :: [Text]
japaneseMnemonics15 :: [Text]
notInDictMnemonics15 :: [Text]
specMnemonicByron :: [Text]
specMnemonicSentence :: [Text]
specMnemonicSecondFactor :: [Text]
arabicWalletName :: Text
falseWalletIds :: [(String, String)]
kanjiWalletName :: Text
polishWalletName :: Text
russianWalletName :: Text
wildcardsWalletName :: Text
invalidByronBase58 :: Text
steveToken :: ApiAssetMetadata
cmdOk :: String
versionLine :: Text
payloadWith :: Text -> [Text] -> Payload
payloadWith' :: Text -> [Text] -> Word32 -> Payload
simplePayload :: [Text] -> Payload
updateNamePayload :: Text -> Payload
updatePassPayload :: Text -> Text -> Payload
updatePassPayloadMnemonic :: [Text] -> Text -> Payload
updatePassPayloadMnemonicAndSndFactor :: [Text] -> [Text] -> Text -> Payload
updateEmptyPassPayload :: Text -> Payload

-- | Transaction metadata for ADP-1005.
--   
--   See <a>https://input-output.atlassian.net/browse/ADP-1005</a>
txMetadata_ADP_1005 :: TxMetadata
errMsg400WalletIdEncoding :: String
errMsg400StartTimeLaterThanEndTime :: String -> String -> String
errMsg403Fee :: String
errMsg403Collateral :: String
errMsg403NotAByronWallet :: String
errMsg403NotAnIcarusWallet :: String
errMsg403NotEnoughMoney :: String
errMsg403EmptyUTxO :: String
errMsg403WrongPass :: String
errMsg403WrongMnemonic :: String
errMsg403AlreadyInLedger :: Text -> String
errMsg404NoSuchPool :: Text -> String
errMsg403PoolAlreadyJoined :: Text -> String
errMsg403NotDelegating :: String
errMsg403NonNullReward :: String
errMsg403NothingToMigrate :: Text -> String
errMsg404NoAsset :: String
errMsg404NoEndpoint :: String
errMsg404CannotFindTx :: Text -> String
errMsg403NoRootKey :: Text -> String
errMsg404NoWallet :: Text -> String
errMsg409WalletExists :: String -> String
errMsg403TxTooBig :: String
errMsg400MalformedTxPayload :: String
errMsg400TxMetadataStringTooLong :: String
errMsg400WronglyEncodedTxPayload :: String
errMsg400ParseError :: String
errMsg403ZeroAmtOutput :: String
errMsg405 :: String
errMsg406 :: String
errMsg415 :: String
errMsg415OctetStream :: String
errMsg500 :: String
errMsg400NumberOfWords :: String
errMsgNotInDictionary :: String
errMsg400MinWithdrawalWrong :: String
errMsg403WithdrawalNotWorth :: String
errMsg403NotAShelleyWallet :: String
errMsg403MinUTxOValue :: String
errMsg403CouldntIdentifyAddrAsMine :: String
errMsg503PastHorizon :: String
errMsg403WrongIndex :: String
errMsg403OutputTokenBundleSizeExceedsLimit :: Address -> Int -> String
errMsg403OutputTokenQuantityExceedsLimit :: Address -> TokenPolicyId -> TokenName -> TokenQuantity -> TokenQuantity -> String
errMsg403WalletAlreadyActive :: String
errMsg403NoDelegationTemplate :: String
errMsg403KeyAlreadyPresent :: Text -> String
errMsg403NoSuchCosigner :: Text -> Int -> String
errMsg403CannotUpdateThisCosigner :: String
errMsg403CreateIllegal :: String
errMsg400ScriptWrongCoeffcient :: String
errMsg400ScriptIllFormed :: String
errMsg400ScriptDuplicateKeys :: String
errMsg400ScriptTimelocksContradictory :: String
errMsg400ScriptNotUniformRoles :: String
errMsg403TemplateInvalidNoCosignerInScript :: String
errMsg403TemplateInvalidUnknownCosigner :: String
errMsg403TemplateInvalidDuplicateXPub :: String
errMsg403TemplateInvalidScript :: String -> String
errMsg403InvalidConstructTx :: String
errMsg403ForeignTransaction :: String
errMsg403MissingWitsInTransaction :: Int -> Int -> String
errMsg403MultidelegationTransaction :: String
errMsg403MultiaccountTransaction :: String
errMsg403CreatedWrongPolicyScriptTemplateTx :: String
errMsg403CreatedWrongPolicyScriptTemplatePolicyId :: String
errMsg403AssetNameTooLong :: String
errMsg403MintOrBurnAssetQuantityOutOfBounds :: String
errMsg403InvalidValidityBounds :: String
errMsg403ValidityIntervalNotInsideScriptTimelock :: String
errMsg403SharedWalletPending :: String

module Test.Integration.Plutus

-- | Create a policy for which the only validation condition is that the
--   transaction is signed by some key.
--   
--   This template has one parameter:
--   
--   <ul>
--   <li>vkHash: flat-encoded blake2b-224 hash of some verification key, in
--   base16.</li>
--   </ul>
mkSignerPolicy :: Value -> (Text, ApiT (Hash "TokenPolicy"))
alwaysTrueValidator :: (Text, ApiT (Hash "TokenPolicy"))
pingPong_1 :: Value
pingPong_2 :: (MonadUnliftIO m, MonadFail m) => Value -> m Value
game_1 :: Value
game_2 :: (MonadUnliftIO m, MonadFail m) => Value -> m Value
game_3 :: (MonadUnliftIO m, MonadFail m) => Value -> m Value

-- | A first transaction template which mints some token aimed for the
--   wallet submitting the transaction (collected as part of balancing).
--   Other than the minted token, the transaction has no inputs and no
--   outputs. So the wallet is expected to balance it out and assign the
--   minted token to a change address.
--   
--   The template has three parameters:
--   
--   <ul>
--   <li>policyId: A base16 policyId</li>
--   <li>policy: A base16 corresponding policy (see
--   <a>mkSignerPolicy</a>)</li>
--   <li>vkHash: The verification key hash (base16) which was used to
--   generate the policy.</li>
--   </ul>
mintBurn_1 :: (MonadUnliftIO m, MonadFail m) => Value -> m Value
mintBurn_2 :: (MonadUnliftIO m, MonadFail m) => Value -> m Value

-- | In this scenario, we attempt to perform a withdrawal of 42 ₳ from
--   stake address locked by the special <a>alwaysTrueValidator</a>, which
--   always validate.
--   
--   This however requires to pass a <tt>Rewarding</tt> type of redeemer,
--   which is quite exotic :)
withdrawScript_1 :: (MonadUnliftIO m, MonadFail m) => m Value

-- | Partial transaction that mints assets using the "currency" contract.
--   
--   The contract is implemented in Plutus here:
--   
--   <ul>
--   
--   <li><a>https://github.com/input-output-hk/plutus-apps/blob/main/plutus-use-cases/src/Plutus/Contracts/Currency.hs</a></li>
--   
--   <li><a>https://github.com/input-output-hk/plutus-apps/blob/main/plutus-use-cases/test/Spec/Currency.hs</a></li>
--   </ul>
--   
--   The contract was serialised using the support code in
--   <tt><i>extra</i>Plutus/CurrencyContract.hs</tt> in this repository.
--   
--   Assets can be minted by spending a specific UTxO that is hard-wired
--   into the smart contract. Hence, minting can happen only once, as UTxOs
--   can be spent only once.
--   
--   The transaction is partial and needs to be sent to the
--   <tt>/transactions-balance</tt> endpoint of the wallet in order to add
--   change outputs and further inputs to cover fees if necessary. This
--   endpoint also needs to make sure that the minted assets are assigned
--   to a change output.
currencyTx :: forall n. EncodeAddress n => ApiWalletInput n -> Value
toHex :: ByteString -> Text

module Test.Integration.Scenario.API.Byron.Addresses
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n ByronKey, PaymentAddress n IcarusKey) => SpecWith Context

module Test.Integration.Scenario.API.Byron.CoinSelections
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n IcarusKey, PaymentAddress n ByronKey) => SpecWith Context

module Test.Integration.Scenario.API.Byron.HWWallets
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n IcarusKey) => SpecWith Context

module Test.Integration.Scenario.API.Byron.Migrations
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n ShelleyKey, PaymentAddress n IcarusKey, PaymentAddress n ByronKey) => SpecWith Context

module Test.Integration.Scenario.API.Byron.Network
spec :: SpecWith Context

module Test.Integration.Scenario.API.Byron.Transactions
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n ByronKey, PaymentAddress n IcarusKey) => SpecWith Context

module Test.Integration.Scenario.API.Byron.TransactionsNew
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n ByronKey, PaymentAddress n IcarusKey) => SpecWith Context

module Test.Integration.Scenario.API.Byron.Wallets
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n IcarusKey, PaymentAddress n ByronKey) => SpecWith Context

module Test.Integration.Scenario.API.Network
spec :: SpecWith Context

module Test.Integration.Scenario.API.Shared.Addresses
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n) => SpecWith Context

module Test.Integration.Scenario.API.Shared.Transactions
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n) => SpecWith Context

module Test.Integration.Scenario.API.Shared.Wallets
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n) => SpecWith Context

module Test.Integration.Scenario.API.Shelley.Addresses
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n) => SpecWith Context

module Test.Integration.Scenario.API.Shelley.CoinSelections
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n ShelleyKey, PaymentAddress n IcarusKey, PaymentAddress n ByronKey) => SpecWith Context

module Test.Integration.Scenario.API.Shelley.HWWallets
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n) => SpecWith Context

module Test.Integration.Scenario.API.Shelley.Migrations
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n ShelleyKey, PaymentAddress n IcarusKey, PaymentAddress n ByronKey) => SpecWith Context

module Test.Integration.Scenario.API.Shelley.Network
spec :: SpecWith Context

module Test.Integration.Scenario.API.Shelley.Settings
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n ShelleyKey, PaymentAddress n IcarusKey, PaymentAddress n ByronKey) => SpecWith Context

module Test.Integration.Scenario.API.Shelley.StakePools
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n ShelleyKey) => SpecWith Context

module Test.Integration.Scenario.API.Shelley.Transactions
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n IcarusKey) => SpecWith Context

module Test.Integration.Scenario.API.Shelley.TransactionsNew
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeStakeAddress n, EncodeAddress n, PaymentAddress n IcarusKey) => SpecWith Context

module Test.Integration.Scenario.API.Shelley.Wallets
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n, PaymentAddress n ShelleyKey, PaymentAddress n IcarusKey, PaymentAddress n ByronKey) => SpecWith Context

module Test.Integration.Scenario.CLI.Byron.Addresses
spec :: forall n. (DecodeAddress n, EncodeAddress n, PaymentAddress n ByronKey, PaymentAddress n IcarusKey) => SpecWith Context

module Test.Integration.Scenario.CLI.Byron.Wallets
spec :: forall n. DecodeAddress n => SpecWith Context

module Test.Integration.Scenario.CLI.Miscellaneous
spec :: SpecWith ()

module Test.Integration.Scenario.CLI.Network
spec :: SpecWith Context

module Test.Integration.Scenario.CLI.Port
spec :: forall s. HasType (Port "wallet") s => SpecWith s

module Test.Integration.Scenario.CLI.Shelley.Addresses
spec :: forall n. (DecodeAddress n, EncodeAddress n) => SpecWith Context

module Test.Integration.Scenario.CLI.Shelley.Transactions
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n) => SpecWith Context

module Test.Integration.Scenario.CLI.Shelley.Wallets
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n) => SpecWith Context
walletNames :: [(String, String)]
walletNamesInvalid :: [(String, String)]

module Test.Integration.Scenario.CLI.Shelley.HWWallets
spec :: forall n. (DecodeAddress n, DecodeStakeAddress n, EncodeAddress n) => SpecWith Context
