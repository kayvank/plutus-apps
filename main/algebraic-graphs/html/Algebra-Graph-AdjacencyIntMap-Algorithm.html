<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Algebra.Graph.AdjacencyIntMap.Algorithm</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">algebraic-graphs-0.6.1: A library for algebraic graph construction and transformation</span><ul class="links" id="page-menu"><li><a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) Andrey Mokhov 2016-2022</td></tr><tr><th>License</th><td>MIT (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>andrey.mokhov@gmail.com</td></tr><tr><th>Stability</th><td>unstable</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Algebra.Graph.AdjacencyIntMap.Algorithm</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Algorithms</a></li><li><a href="#g:2">Correctness properties</a></li><li><a href="#g:3">Type synonyms</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p><strong>Alga</strong> is a library for algebraic construction and manipulation of graphs
 in Haskell. See <a href="https://github.com/snowleopard/alga-paper">this paper</a> for the
 motivation behind the library, the underlying theory, and implementation details.</p><p>This module provides basic graph algorithms, such as <em>depth-first search</em>,
 implemented for the <a href="Algebra-Graph-AdjacencyIntMap.html">Algebra.Graph.AdjacencyIntMap</a> data type.</p><p>Some of the worst-case complexities include the term <em>min(n,W)</em>.
 Following <code><a href="../../containers/html/Data-IntSet.html#t:IntSet" title="Data.IntSet">IntSet</a></code> and <code><a href="../../containers/html/Data-IntMap-Strict-Internal.html#t:IntMap" title="Data.IntMap.Strict.Internal">IntMap</a></code>, the <em>W</em> stands for
 word size (usually 32 or 64 bits).</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:bfsForest">bfsForest</a> :: [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:bfs">bfs</a> :: [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [[<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]]</li><li class="src short"><a href="#v:dfsForest">dfsForest</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:dfsForestFrom">dfsForestFrom</a> :: [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:dfs">dfs</a> :: [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:reachable">reachable</a> :: <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:topSort">topSort</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#t:Cycle" title="Algebra.Graph.AdjacencyIntMap.Algorithm">Cycle</a> <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]</li><li class="src short"><a href="#v:isAcyclic">isAcyclic</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isDfsForestOf">isDfsForestOf</a> :: <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isTopSortOf">isTopSortOf</a> :: [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Cycle">Cycle</a> = <a href="../../ghc/html/libraries/base-4.14.3.0/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Algorithms</h1></a><div class="top"><p class="src"><a id="v:bfsForest" class="def">bfsForest</a> :: [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#bfsForest" class="link">Source</a> <a href="#v:bfsForest" class="selflink">#</a></p><div class="doc"><p>Compute the <em>breadth-first search</em> forest of a graph, such that adjacent
 vertices are explored in increasing order according to their <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance.
 The search is seeded by a list of vertices that will become the roots of the
 resulting forest. Duplicates in the list will have their first occurrence
 expanded and subsequent ones ignored. The seed vertices that do not belong to
 the graph are also ignored.</p><p>Complexity: <em>O((L+m)*log n)</em> time and <em>O(n)</em> space, where <em>L</em> is the number
 of seed vertices.</p><pre><code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (bfsForest [1,2] $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)      == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (bfsForest [2]   $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)      == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 2
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (bfsForest [3]   $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)      == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (bfsForest [2,1] $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)      == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyIntMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ bfsForest vs x) x == True
bfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertexList" title="Algebra.Graph.AdjacencyIntMap">vertexList</a></code> g) g               == <code><a href="../../ghc/html/libraries/base-4.14.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> (v -&gt; Node v []) (<code>nub</code> $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertexList" title="Algebra.Graph.AdjacencyIntMap">vertexList</a></code> g)
bfsForest [] x                           == []
bfsForest [1,4] (3 * (1 + 4) * (1 + 5))  == [ Node { rootLabel = 1
                                                   , subForest = [ Node { rootLabel = 5
                                                                        , subForest = [] }]}
                                            , Node { rootLabel = 4
                                                   , subForest = [] }]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (bfsForest [3] (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1])) == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [3,2,1] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [3,4,5]

</pre></div></div><div class="top"><p class="src"><a id="v:bfs" class="def">bfs</a> :: [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [[<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>]] <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#bfs" class="link">Source</a> <a href="#v:bfs" class="selflink">#</a></p><div class="doc"><p>A version of <code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:bfsForest" title="Algebra.Graph.AdjacencyIntMap.Algorithm">bfsForest</a></code> where the resulting forest is converted to a level
 structure. Adjacent vertices are explored in the increasing order according
 to their <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance. Flattening the result via <code><code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Foldable.html#v:concat" title="Data.Foldable">concat</a></code></code> <code>.</code> <code><code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:bfs" title="Algebra.Graph.AdjacencyIntMap.Algorithm">bfs</a></code></code> <code>vs</code>
 gives an enumeration of vertices reachable from <code>vs</code> in the BFS order.</p><p>Complexity: <em>O((L+m)*min(n,W))</em> time and <em>O(n)</em> space, where <em>L</em> is the
 number of seed vertices.</p><pre>bfs vs <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>                                         == []
bfs [] g                                             == []
bfs [1]   (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1)                                 == [[1]]
bfs [1]   (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)                                 == [[1],[2]]
bfs [2]   (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)                                 == [[2]]
bfs [1,2] (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)                                 == [[1,2]]
bfs [2,1] (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)                                 == [[2,1]]
bfs [3]   (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)                                 == []
bfs [1,2] ( (1*2) + (3*4) + (5*6) )                  == [[1,2]]
bfs [1,3] ( (1*2) + (3*4) + (5*6) )                  == [[1,3],[2,4]]
bfs [3] (3 * (1 + 4) * (1 + 5))                      == [[3],[1,4,5]]
bfs [2] (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1])          == [[2],[1,3],[5,4]]
<code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Foldable.html#v:concat" title="Data.Foldable">concat</a></code> (bfs [3] $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1]) == [3,2,4,1,5]
bfs vs == <code><a href="../../ghc/html/libraries/base-4.14.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Foldable.html#v:concat" title="Data.Foldable">concat</a></code> . <code><a href="../../ghc/html/libraries/base-4.14.3.0/GHC-OldList.html#v:transpose" title="GHC.OldList">transpose</a></code> . <code><a href="../../ghc/html/libraries/base-4.14.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> <code><a href="../../containers/html/Data-Tree.html#v:levels" title="Data.Tree">levels</a></code> . <code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:bfsForest" title="Algebra.Graph.AdjacencyIntMap.Algorithm">bfsForest</a></code> vs
</pre></div></div><div class="top"><p class="src"><a id="v:dfsForest" class="def">dfsForest</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#dfsForest" class="link">Source</a> <a href="#v:dfsForest" class="selflink">#</a></p><div class="doc"><p>Compute the <em>depth-first search</em> forest of a graph, where adjacent vertices
 are explored in the increasing order according to their <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance.</p><p>Complexity: <em>O((n+m)*min(n,W))</em> time and <em>O(n)</em> space.</p><pre>dfsForest <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>                       == []
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForest $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1)         == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForest $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)         == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForest $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 2 1)         == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyIntMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForest x) x == True
<code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:isDfsForestOf" title="Algebra.Graph.AdjacencyIntMap.Algorithm">isDfsForestOf</a></code> (dfsForest x) x         == True
dfsForest . <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> . dfsForest        == dfsForest
dfsForest (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> vs)               == <code><a href="../../ghc/html/libraries/base-4.14.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> (\v -&gt; Node v []) (<code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-List.html#v:nub" title="Data.List">nub</a></code> $ <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-List.html#v:sort" title="Data.List">sort</a></code> vs)
<code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:dfsForestFrom" title="Algebra.Graph.AdjacencyIntMap.Algorithm">dfsForestFrom</a></code> (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertexList" title="Algebra.Graph.AdjacencyIntMap">vertexList</a></code> x) x        == dfsForest x
dfsForest $ 3 * (1 + 4) * (1 + 5)     == [ Node { rootLabel = 1
                                                , subForest = [ Node { rootLabel = 5
                                                                     , subForest = [] }]}
                                         , Node { rootLabel = 3
                                                , subForest = [ Node { rootLabel = 4
                                                                     , subForest = [] }]}]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForest $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1]) == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3,4,5]
</pre></div></div><div class="top"><p class="src"><a id="v:dfsForestFrom" class="def">dfsForestFrom</a> :: [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#dfsForestFrom" class="link">Source</a> <a href="#v:dfsForestFrom" class="selflink">#</a></p><div class="doc"><p>Compute the <em>depth-first search</em> forest of a graph starting from the given
 seed vertices, where adjacent vertices are explored in the increasing order
 according to their <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance. Note that the resulting forest does not
 necessarily span the whole graph, as some vertices may be unreachable. The
 seed vertices which do not belong to the graph are ignored.</p><p>Complexity: <em>O((L+m)*log n)</em> time and <em>O(n)</em> space, where <em>L</em> be the number
 of seed vertices.</p><pre>dfsForestFrom vs <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>                           == []
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForestFrom [1]   $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1)          == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForestFrom [1]   $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)          == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForestFrom [2]   $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)          == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 2
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForestFrom [3]   $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)          == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForestFrom [2,1] $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)          == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyIntMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> $ dfsForestFrom vs x) x     == True
<code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:isDfsForestOf" title="Algebra.Graph.AdjacencyIntMap.Algorithm">isDfsForestOf</a></code> (dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertexList" title="Algebra.Graph.AdjacencyIntMap">vertexList</a></code> x) x) x == True
dfsForestFrom (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertexList" title="Algebra.Graph.AdjacencyIntMap">vertexList</a></code> x) x                   == <code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:dfsForest" title="Algebra.Graph.AdjacencyIntMap.Algorithm">dfsForest</a></code> x
dfsForestFrom vs             (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> vs)       == <code><a href="../../ghc/html/libraries/base-4.14.3.0/GHC-List.html#v:map" title="GHC.List">map</a></code> (\v -&gt; Node v []) (<code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-List.html#v:nub" title="Data.List">nub</a></code> vs)
dfsForestFrom []             x                   == []
dfsForestFrom [1,4] $ 3 * (1 + 4) * (1 + 5)      == [ Node { rootLabel = 1
                                                           , subForest = [ Node { rootLabel = 5
                                                                                , subForest = [] }
                                                    , Node { rootLabel = 4
                                                           , subForest = [] }]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:forest" title="Algebra.Graph.AdjacencyIntMap">forest</a></code> (dfsForestFrom [3] $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1]) == <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [3,2,1,5,4]
</pre></div></div><div class="top"><p class="src"><a id="v:dfs" class="def">dfs</a> :: [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#dfs" class="link">Source</a> <a href="#v:dfs" class="selflink">#</a></p><div class="doc"><p>Return the list vertices visited by the <em>depth-first search</em> in a graph,
 starting from the given seed vertices. Adjacent vertices are explored in the
 increasing order according to their <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code> instance.</p><p>Complexity: <em>O((L+m)*log n)</em> time and <em>O(n)</em> space, where <em>L</em> is the number
 of seed vertices.</p><pre>dfs vs    $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>                    == []
dfs [1]   $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1                 == [1]
dfs [1]   $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2                 == [1,2]
dfs [2]   $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2                 == [2]
dfs [3]   $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2                 == []
dfs [1,2] $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2                 == [1,2]
dfs [2,1] $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2                 == [2,1]
dfs []    $ x                        == []
dfs [1,4] $ 3 * (1 + 4) * (1 + 5)    == [1,5,4]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyIntMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> $ dfs vs x) x == True
dfs [3] $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..5] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [5,4..1] == [3,2,1,5,4]
</pre></div></div><div class="top"><p class="src"><a id="v:reachable" class="def">reachable</a> :: <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#reachable" class="link">Source</a> <a href="#v:reachable" class="selflink">#</a></p><div class="doc"><p>Return the list of vertices that are <em>reachable</em> from a given source vertex
 in a graph. The vertices in the resulting list appear in the <em>depth-first order</em>.</p><p>Complexity: <em>O(m*log n)</em> time and <em>O(n)</em> space.</p><pre>reachable x $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>                       == []
reachable 1 $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1                    == [1]
reachable 1 $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 2                    == []
reachable 1 $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1                    == [1]
reachable 1 $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2                    == [1,2]
reachable 4 $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code>    [1..8]              == [4..8]
reachable 4 $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..8]              == [4..8] ++ [1..3]
reachable 8 $ <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:clique" title="Algebra.Graph.AdjacencyIntMap">clique</a></code>  [8,7..1]            == [8] ++ [1..7]
<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:isSubgraphOf" title="Algebra.Graph.AdjacencyIntMap">isSubgraphOf</a></code> (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> $ reachable x y) y == True
</pre></div></div><div class="top"><p class="src"><a id="v:topSort" class="def">topSort</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Either.html#t:Either" title="Data.Either">Either</a> (<a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#t:Cycle" title="Algebra.Graph.AdjacencyIntMap.Algorithm">Cycle</a> <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>) [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#topSort" class="link">Source</a> <a href="#v:topSort" class="selflink">#</a></p><div class="doc"><p>Compute a topological sort of a graph or discover a cycle.</p><p>Vertices are explored in the decreasing order according to their <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a></code>
 instance. This gives the lexicographically smallest topological ordering in
 the case of success. In the case of failure, the cycle is characterized by
 being the lexicographically smallest up to rotation with respect to
 <code>Ord</code> <code>(Dual</code> <code>Int)</code> in the first connected component of the graph containing
 a cycle, where the connected components are ordered by their largest vertex
 with respect to <code>Ord a</code>.</p><p>Complexity: <em>O((n+m)*min(n,W))</em> time and <em>O(n)</em> space.</p><pre>topSort (1 * 2 + 3 * 1)                    == Right [3,1,2]
topSort (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1..5])                      == Right [1..5]
topSort (3 * (1 * 4 + 2 * 5))              == Right [3,1,2,4,5]
topSort (1 * 2 + 2 * 1)                    == Left (2 <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [1])
topSort (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [5,4..1] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 2 4)         == Left (4 <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [3,2])
topSort (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..3])                   == Left (3 <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [1,2])
topSort (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [1..3] + <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code> [3,2,1]) == Left (3 <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [2])
topSort (1*2 + 2*1 + 3*4 + 4*3 + 5*1)      == Left (1 <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-List-NonEmpty.html#v::-124-" title="Data.List.NonEmpty">:|</a></code> [2])
fmap (<code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Function.html#v:flip" title="Data.Function">flip</a></code> <code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:isTopSortOf" title="Algebra.Graph.AdjacencyIntMap.Algorithm">isTopSortOf</a></code> x) (topSort x)      /= Right False
topSort . <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code>                         == Right . <code>nub</code> . <code>sort</code>
</pre></div></div><div class="top"><p class="src"><a id="v:isAcyclic" class="def">isAcyclic</a> :: <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#isAcyclic" class="link">Source</a> <a href="#v:isAcyclic" class="selflink">#</a></p><div class="doc"><p>Check if a given graph is <em>acyclic</em>.</p><p>Complexity: <em>O((n+m)*min(n,W))</em> time and <em>O(n)</em> space.</p><pre>isAcyclic (1 * 2 + 3 * 1) == True
isAcyclic (1 * 2 + 2 * 1) == False
isAcyclic . <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:circuit" title="Algebra.Graph.AdjacencyIntMap">circuit</a></code>       == <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Foldable.html#v:null" title="Data.Foldable">null</a></code>
isAcyclic                 == <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Either.html#v:isRight" title="Data.Either">isRight</a></code> . <code><a href="Algebra-Graph-AdjacencyIntMap-Algorithm.html#v:topSort" title="Algebra.Graph.AdjacencyIntMap.Algorithm">topSort</a></code>
</pre></div></div><a href="#g:2" id="g:2"><h1>Correctness properties</h1></a><div class="top"><p class="src"><a id="v:isDfsForestOf" class="def">isDfsForestOf</a> :: <a href="../../containers/html/Data-Tree.html#t:Forest" title="Data.Tree">Forest</a> <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#isDfsForestOf" class="link">Source</a> <a href="#v:isDfsForestOf" class="selflink">#</a></p><div class="doc"><p>Check if a given forest is a correct <em>depth-first search</em> forest of a graph.
 The implementation is based on the paper &quot;Depth-First Search and Strong
 Connectivity in Coq&quot; by Fran&#231;ois Pottier.</p><pre>isDfsForestOf []                              <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>            == True
isDfsForestOf []                              (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1)       == False
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1)       == True
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 2)       == False
isDfsForestOf [Node 1 [], Node 1 []]          (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> 1)       == False
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 1)       == True
isDfsForestOf [Node 1 []]                     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)       == False
isDfsForestOf [Node 1 [], Node 2 []]          (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)       == False
isDfsForestOf [Node 2 [], Node 1 []]          (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)       == True
isDfsForestOf [Node 1 [Node 2 []]]            (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> 1 2)       == True
isDfsForestOf [Node 1 [], Node 2 []]          (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]) == True
isDfsForestOf [Node 2 [], Node 1 []]          (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]) == True
isDfsForestOf [Node 1 [Node 2 []]]            (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertices" title="Algebra.Graph.AdjacencyIntMap">vertices</a></code> [1,2]) == False
isDfsForestOf [Node 1 [Node 2 [Node 3 []]]]   (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3])   == True
isDfsForestOf [Node 1 [Node 3 [Node 2 []]]]   (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3])   == False
isDfsForestOf [Node 3 [], Node 1 [Node 2 []]] (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3])   == True
isDfsForestOf [Node 2 [Node 3 []], Node 1 []] (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3])   == True
isDfsForestOf [Node 1 [], Node 2 [Node 3 []]] (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:path" title="Algebra.Graph.AdjacencyIntMap">path</a></code> [1,2,3])   == False
</pre></div></div><div class="top"><p class="src"><a id="v:isTopSortOf" class="def">isTopSortOf</a> :: [<a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a>] -&gt; <a href="Algebra-Graph-AdjacencyIntMap.html#t:AdjacencyIntMap" title="Algebra.Graph.AdjacencyIntMap">AdjacencyIntMap</a> -&gt; <a href="../../ghc/html/libraries/base-4.14.3.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#isTopSortOf" class="link">Source</a> <a href="#v:isTopSortOf" class="selflink">#</a></p><div class="doc"><p>Check if a given list of vertices is a correct <em>topological sort</em> of a graph.</p><pre>isTopSortOf [3,1,2] (1 * 2 + 3 * 1) == True
isTopSortOf [1,2,3] (1 * 2 + 3 * 1) == False
isTopSortOf []      (1 * 2 + 3 * 1) == False
isTopSortOf []      <code><a href="Algebra-Graph-AdjacencyIntMap.html#v:empty" title="Algebra.Graph.AdjacencyIntMap">empty</a></code>           == True
isTopSortOf [x]     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:vertex" title="Algebra.Graph.AdjacencyIntMap">vertex</a></code> x)      == True
isTopSortOf [x]     (<code><a href="Algebra-Graph-AdjacencyIntMap.html#v:edge" title="Algebra.Graph.AdjacencyIntMap">edge</a></code> x x)      == False
</pre></div></div><a href="#g:3" id="g:3"><h1>Type synonyms</h1></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Cycle" class="def">Cycle</a> = <a href="../../ghc/html/libraries/base-4.14.3.0/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> <a href="src/Algebra.Graph.AdjacencyIntMap.Algorithm.html#Cycle" class="link">Source</a> <a href="#t:Cycle" class="selflink">#</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>