-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Shelley ledger with multiasset and time lock support.
--   
--   This package extends the Shelley ledger with support for native tokens
--   and timelocks.
@package cardano-ledger-shelley-ma
@version 0.1.0.0

module Cardano.Ledger.Mary.Value

-- | Policy ID
newtype PolicyID crypto
PolicyID :: ScriptHash crypto -> PolicyID crypto
[policyID] :: PolicyID crypto -> ScriptHash crypto

-- | Asset Name
newtype AssetName
AssetName :: ShortByteString -> AssetName
[assetName] :: AssetName -> ShortByteString

-- | The Value representing MultiAssets
data Value crypto
Value :: !Integer -> !Map (PolicyID crypto) (Map AssetName Integer) -> Value crypto

-- | insert comb policy asset n v, if comb = old new -&gt; old, the integer
--   in the Value is prefered over n if comb = old new -&gt; new, then n is
--   prefered over the integer in the Value if (comb old new) == 0, then
--   that value should not be stored in the Map part of the Value.
insert :: (Integer -> Integer -> Integer) -> PolicyID crypto -> AssetName -> Integer -> Value crypto -> Value crypto
lookup :: PolicyID crypto -> AssetName -> Value crypto -> Integer

-- | Extract the set of policies in the Value.
--   
--   This function is equivalent to computing the support of the value in
--   the spec.
policies :: Value crypto -> Set (PolicyID crypto)

-- | Remove 0 assets from a map
prune :: Map (PolicyID crypto) (Map AssetName Integer) -> Map (PolicyID crypto) (Map AssetName Integer)
representationSize :: forall crypto. Crypto crypto => [(PolicyID crypto, AssetName, Integer)] -> Int

-- | Display a Value as a String, one token per line
showValue :: Value crypto -> String

-- | Rather than using prune to remove 0 assets, when can avoid adding them
--   in the first place by using valueFromList to construct a Value.
valueFromList :: Integer -> [(PolicyID era, AssetName, Integer)] -> Value era

-- | Turn the nested <a>Value</a> map-of-maps representation into a flat
--   sequence of policyID, asset name and quantity, plus separately the ada
--   quantity.
gettriples' :: Value crypto -> (Integer, [(PolicyID crypto, AssetName, Integer)], [PolicyID crypto])
instance Control.DeepSeq.NFData Cardano.Ledger.Mary.Value.AssetName
instance NoThunks.Class.NoThunks Cardano.Ledger.Mary.Value.AssetName
instance GHC.Classes.Ord Cardano.Ledger.Mary.Value.AssetName
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Mary.Value.AssetName
instance GHC.Classes.Eq Cardano.Ledger.Mary.Value.AssetName
instance Control.DeepSeq.NFData (Cardano.Ledger.Mary.Value.PolicyID crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Mary.Value.PolicyID crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Mary.Value.PolicyID crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Mary.Value.PolicyID crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Mary.Value.PolicyID crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Mary.Value.PolicyID crypto)
instance GHC.Show.Show (Cardano.Ledger.Mary.Value.PolicyID crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Mary.Value.Value crypto)
instance GHC.Show.Show (Cardano.Ledger.Mary.Value.Value crypto)
instance GHC.Show.Show (Cardano.Ledger.Mary.Value.CompactValue crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Mary.Value.Value crypto))
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Mary.Value.Value crypto))
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Mary.Value.Value crypto))
instance NoThunks.Class.NoThunks (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Mary.Value.Value crypto))
instance GHC.Show.Show (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Mary.Value.Value crypto))
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Mary.Value.Value crypto))
instance NoThunks.Class.NoThunks (Cardano.Ledger.Mary.Value.CompactValue crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Val.Val (Cardano.Ledger.Mary.Value.Value crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Mary.Value.Value crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Mary.Value.CompactValue crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Mary.Value.CompactValue crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Mary.Value.CompactValue crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Ledger.Mary.Value.CompactValue crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Ledger.Mary.Value.Value crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Mary.Value.Value crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Mary.Value.Value crypto)
instance GHC.Base.Semigroup (Cardano.Ledger.Mary.Value.Value crypto)
instance GHC.Base.Monoid (Cardano.Ledger.Mary.Value.Value crypto)
instance Data.Group.Group (Cardano.Ledger.Mary.Value.Value crypto)
instance Data.Group.Abelian (Cardano.Ledger.Mary.Value.Value crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Mary.Value.Value crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Mary.Value.Value crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Mary.Value.Value crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Val.DecodeMint (Cardano.Ledger.Mary.Value.Value crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Val.EncodeMint (Cardano.Ledger.Mary.Value.Value crypto)
instance GHC.Show.Show Cardano.Ledger.Mary.Value.AssetName
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Mary.Value.AssetName

module Cardano.Ledger.ShelleyMA.AuxiliaryData
newtype AuxiliaryData era
AuxiliaryDataWithBytes :: MemoBytes (AuxiliaryDataRaw era) -> AuxiliaryData era
pattern AuxiliaryData :: (AnnotatedData (Script era), Ord (Script era)) => Map Word64 Metadatum -> StrictSeq (Script era) -> AuxiliaryData era
pattern AuxiliaryData' :: Map Word64 Metadatum -> StrictSeq (Script era) -> AuxiliaryData era
instance GHC.Generics.Generic (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryDataRaw era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryData era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryData era)
instance GHC.Generics.Generic (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryData era)
instance Cardano.Ledger.Core.ChainData (Cardano.Ledger.Core.Script era) => GHC.Classes.Eq (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryDataRaw era)
instance Cardano.Ledger.Core.ChainData (Cardano.Ledger.Core.Script era) => GHC.Show.Show (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryDataRaw era)
instance Cardano.Ledger.Core.ChainData (Cardano.Ledger.Core.Script era) => NoThunks.Class.NoThunks (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryDataRaw era)
instance Cardano.Ledger.Era.Era era => GHC.Classes.Eq (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryData era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.ChainData (Cardano.Ledger.Core.Script era)) => GHC.Show.Show (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryData era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.ChainData (Cardano.Ledger.Core.Script era)) => NoThunks.Class.NoThunks (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryData era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Core.Script era) => Control.DeepSeq.NFData (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryData era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.AnnotatedData (Cardano.Ledger.Core.Script era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryData era))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryData era) Cardano.Ledger.Hashes.EraIndependentAuxiliaryData c
instance Control.DeepSeq.NFData (Cardano.Ledger.Core.Script era) => Control.DeepSeq.NFData (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryDataRaw era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.AnnotatedData (Cardano.Ledger.Core.Script era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryDataRaw era))

module Cardano.Ledger.ShelleyMA.Timelocks
data Timelock crypto
pattern RequireSignature :: Crypto crypto => KeyHash 'Witness crypto -> Timelock crypto
pattern RequireAllOf :: Crypto crypto => StrictSeq (Timelock crypto) -> Timelock crypto
pattern RequireAnyOf :: Crypto crypto => StrictSeq (Timelock crypto) -> Timelock crypto
pattern RequireMOf :: Crypto crypto => Int -> StrictSeq (Timelock crypto) -> Timelock crypto
pattern RequireTimeExpire :: Crypto crypto => SlotNo -> Timelock crypto
pattern RequireTimeStart :: Crypto crypto => SlotNo -> Timelock crypto
pattern TimelockConstr :: () => MemoBytes (TimelockRaw crypto) -> Timelock crypto

-- | Test if a slot is in the Validity interval. Recall that a
--   ValidityInterval is a half Open interval, that is why we use (slot
--   &lt; top)
inInterval :: SlotNo -> ValidityInterval -> Bool
showTimelock :: Crypto crypto => Timelock crypto -> String
evalTimelock :: Crypto crypto => Set (KeyHash 'Witness crypto) -> ValidityInterval -> Timelock crypto -> Bool
validateTimelock :: forall era. (UsesTxBody era, HasField "vldt" (TxBody era) ValidityInterval, HasField "addrWits" (Tx era) (Set (WitVKey 'Witness (Crypto era)))) => Timelock (Crypto era) -> Tx era -> Bool

-- | ValidityInterval is a half open interval. Closed on the bottom, Open
--   on the top. A SNothing on the bottom is negative infinity, and a
--   SNothing on the top is positive infinity
data ValidityInterval
ValidityInterval :: !StrictMaybe SlotNo -> !StrictMaybe SlotNo -> ValidityInterval
[invalidBefore] :: ValidityInterval -> !StrictMaybe SlotNo
[invalidHereafter] :: ValidityInterval -> !StrictMaybe SlotNo
encodeVI :: ValidityInterval -> Encode ('Closed 'Dense) ValidityInterval
decodeVI :: Decode ('Closed 'Dense) ValidityInterval
translate :: Crypto crypto => MultiSig crypto -> Timelock crypto
instance Control.DeepSeq.NFData Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval
instance NoThunks.Class.NoThunks Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval
instance GHC.Show.Show Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval
instance GHC.Generics.Generic Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval
instance GHC.Classes.Eq Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval
instance GHC.Classes.Ord Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval
instance Control.DeepSeq.NFData (Cardano.Ledger.ShelleyMA.Timelocks.TimelockRaw crypto)
instance GHC.Generics.Generic (Cardano.Ledger.ShelleyMA.Timelocks.TimelockRaw crypto)
instance GHC.Classes.Ord (Cardano.Ledger.ShelleyMA.Timelocks.TimelockRaw crypto)
instance GHC.Show.Show (Cardano.Ledger.ShelleyMA.Timelocks.TimelockRaw crypto)
instance GHC.Classes.Eq (Cardano.Ledger.ShelleyMA.Timelocks.TimelockRaw crypto)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.ShelleyMA.Timelocks.Timelock crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.ShelleyMA.Timelocks.Timelock crypto)
instance Data.Typeable.Internal.Typeable crypto => NoThunks.Class.NoThunks (Cardano.Ledger.ShelleyMA.Timelocks.Timelock crypto)
instance Data.Typeable.Internal.Typeable crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.ShelleyMA.Timelocks.Timelock crypto)
instance GHC.Generics.Generic (Cardano.Ledger.ShelleyMA.Timelocks.Timelock crypto)
instance GHC.Show.Show (Cardano.Ledger.ShelleyMA.Timelocks.Timelock crypto)
instance GHC.Classes.Ord (Cardano.Ledger.ShelleyMA.Timelocks.Timelock crypto)
instance GHC.Classes.Eq (Cardano.Ledger.ShelleyMA.Timelocks.Timelock crypto)
instance Data.Typeable.Internal.Typeable crypto => NoThunks.Class.NoThunks (Cardano.Ledger.ShelleyMA.Timelocks.TimelockRaw crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.ShelleyMA.Timelocks.Timelock crypto))
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.ShelleyMA.Timelocks.TimelockRaw crypto))
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval

module Cardano.Ledger.ShelleyMA.TxBody
newtype TxBody e
TxBodyConstr :: MemoBytes (TxBodyRaw e) -> TxBody e
pattern TxBody :: FamsTo era => Set (TxIn (Crypto era)) -> StrictSeq (TxOut era) -> StrictSeq (DCert (Crypto era)) -> Wdrl (Crypto era) -> Coin -> ValidityInterval -> StrictMaybe (Update era) -> StrictMaybe (AuxiliaryDataHash (Crypto era)) -> Value era -> TxBody era

-- | This pattern is for deconstruction only but accompanied with fields
--   and projection functions.
pattern TxBody' :: Set (TxIn (Crypto era)) -> StrictSeq (TxOut era) -> StrictSeq (DCert (Crypto era)) -> Wdrl (Crypto era) -> Coin -> ValidityInterval -> StrictMaybe (Update era) -> StrictMaybe (AuxiliaryDataHash (Crypto era)) -> Value era -> TxBody era
data TxBodyRaw era
TxBodyRaw :: !Set (TxIn (Crypto era)) -> !StrictSeq (TxOut era) -> !StrictSeq (DCert (Crypto era)) -> !Wdrl (Crypto era) -> !Coin -> !ValidityInterval -> !StrictMaybe (Update era) -> !StrictMaybe (AuxiliaryDataHash (Crypto era)) -> !Value era -> TxBodyRaw era
[inputs] :: TxBodyRaw era -> !Set (TxIn (Crypto era))
[outputs] :: TxBodyRaw era -> !StrictSeq (TxOut era)
[certs] :: TxBodyRaw era -> !StrictSeq (DCert (Crypto era))
[wdrls] :: TxBodyRaw era -> !Wdrl (Crypto era)
[txfee] :: TxBodyRaw era -> !Coin
[vldt] :: TxBodyRaw era -> !ValidityInterval
[update] :: TxBodyRaw era -> !StrictMaybe (Update era)
[adHash] :: TxBodyRaw era -> !StrictMaybe (AuxiliaryDataHash (Crypto era))
[mint] :: TxBodyRaw era -> !Value era
type FamsFrom era = (Era era, Typeable era, Typeable (Script era), Typeable (AuxiliaryData era), Show (Value era), DecodeNonNegative (Value era), DecodeMint (Value era), FromCBOR (PParams era), FromCBOR (PParamsDelta era), FromCBOR (Value era), FromCBOR (Annotator (Script era)))
type FamsTo era = (Era era, ToCBOR (Value era), EncodeMint (Value era), ToCBOR (Script era), ToCBOR (PParams era), ToCBOR (PParamsDelta era), Typeable (AuxiliaryData era))
txSparse :: FamsTo era => TxBodyRaw era -> Encode ('Closed 'Sparse) (TxBodyRaw era)
bodyFields :: FamsFrom era => Word -> Field (TxBodyRaw era)
data StrictMaybe a
SNothing :: StrictMaybe a
SJust :: !a -> StrictMaybe a
fromSJust :: StrictMaybe a -> a

-- | ValidityInterval is a half open interval. Closed on the bottom, Open
--   on the top. A SNothing on the bottom is negative infinity, and a
--   SNothing on the top is positive infinity
data ValidityInterval
ValidityInterval :: !StrictMaybe SlotNo -> !StrictMaybe SlotNo -> ValidityInterval
[invalidBefore] :: ValidityInterval -> !StrictMaybe SlotNo
[invalidHereafter] :: ValidityInterval -> !StrictMaybe SlotNo
initial :: Val (Value era) => TxBodyRaw era
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.ShelleyMA.TxBody.TxBody e)
instance (Control.DeepSeq.NFData (Cardano.Ledger.Core.Value era), Cardano.Ledger.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.PParamsDelta era)) => Control.DeepSeq.NFData (Cardano.Ledger.ShelleyMA.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Shelley.Constraints.TransValue GHC.Classes.Eq era, GHC.Classes.Eq (Cardano.Ledger.Core.PParamsDelta era)) => GHC.Classes.Eq (Cardano.Ledger.ShelleyMA.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Shelley.Constraints.TransValue GHC.Show.Show era, GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era)) => GHC.Show.Show (Cardano.Ledger.ShelleyMA.TxBody.TxBodyRaw era)
instance GHC.Generics.Generic (Cardano.Ledger.ShelleyMA.TxBody.TxBodyRaw era)
instance (NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParamsDelta era)) => NoThunks.Class.NoThunks (Cardano.Ledger.ShelleyMA.TxBody.TxBodyRaw era)
instance GHC.Classes.Eq (Cardano.Ledger.ShelleyMA.TxBody.TxBody era)
instance (Cardano.Ledger.Shelley.Constraints.TransValue GHC.Show.Show era, GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era)) => GHC.Show.Show (Cardano.Ledger.ShelleyMA.TxBody.TxBody era)
instance GHC.Generics.Generic (Cardano.Ledger.ShelleyMA.TxBody.TxBody era)
instance (Data.Typeable.Internal.Typeable era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParamsDelta era)) => NoThunks.Class.NoThunks (Cardano.Ledger.ShelleyMA.TxBody.TxBody era)
instance (Control.DeepSeq.NFData (Cardano.Ledger.Core.Value era), Control.DeepSeq.NFData (Cardano.Ledger.Core.PParamsDelta era), Cardano.Ledger.Era.Era era) => Control.DeepSeq.NFData (Cardano.Ledger.ShelleyMA.TxBody.TxBody era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.ShelleyMA.TxBody.TxBody era)
instance Cardano.Ledger.ShelleyMA.TxBody.FamsFrom era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.ShelleyMA.TxBody.TxBody era))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era, Cardano.Ledger.Era.Era era) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.ShelleyMA.TxBody.TxBody era) Cardano.Ledger.Hashes.EraIndependentTxBody c
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "inputs" (Cardano.Ledger.ShelleyMA.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn crypto))
instance GHC.Records.HasField "outputs" (Cardano.Ledger.ShelleyMA.TxBody.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Shelley.TxBody.TxOut era))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "certs" (Cardano.Ledger.ShelleyMA.TxBody.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Shelley.TxBody.DCert crypto))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "wdrls" (Cardano.Ledger.ShelleyMA.TxBody.TxBody era) (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance GHC.Records.HasField "txfee" (Cardano.Ledger.ShelleyMA.TxBody.TxBody era) Cardano.Ledger.Coin.Coin
instance GHC.Records.HasField "vldt" (Cardano.Ledger.ShelleyMA.TxBody.TxBody era) Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval
instance GHC.Records.HasField "update" (Cardano.Ledger.ShelleyMA.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Shelley.PParams.Update era))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "adHash" (Cardano.Ledger.ShelleyMA.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto))
instance (Cardano.Ledger.Core.Value era GHC.Types.~ value) => GHC.Records.HasField "mint" (Cardano.Ledger.ShelleyMA.TxBody.TxBody era) value
instance Cardano.Ledger.ShelleyMA.TxBody.FamsFrom era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.ShelleyMA.TxBody.TxBodyRaw era)
instance Cardano.Ledger.ShelleyMA.TxBody.FamsFrom era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.ShelleyMA.TxBody.TxBodyRaw era))

module Cardano.Ledger.ShelleyMA.Rules.Utxo
scaledMinDeposit :: Val v => v -> Coin -> Coin
data UtxoPredicateFailure era
BadInputsUTxO :: !Set (TxIn (Crypto era)) -> UtxoPredicateFailure era
OutsideValidityIntervalUTxO :: !ValidityInterval -> !SlotNo -> UtxoPredicateFailure era
MaxTxSizeUTxO :: !Integer -> !Integer -> UtxoPredicateFailure era
InputSetEmptyUTxO :: UtxoPredicateFailure era
FeeTooSmallUTxO :: !Coin -> !Coin -> UtxoPredicateFailure era
ValueNotConservedUTxO :: !Value era -> !Value era -> UtxoPredicateFailure era
WrongNetwork :: !Network -> !Set (Addr (Crypto era)) -> UtxoPredicateFailure era
WrongNetworkWithdrawal :: !Network -> !Set (RewardAcnt (Crypto era)) -> UtxoPredicateFailure era
OutputTooSmallUTxO :: ![TxOut era] -> UtxoPredicateFailure era
UpdateFailure :: !PredicateFailure (EraRule "PPUP" era) -> UtxoPredicateFailure era
OutputBootAddrAttrsTooBig :: ![TxOut era] -> UtxoPredicateFailure era
TriesToForgeADA :: UtxoPredicateFailure era
OutputTooBigUTxO :: ![TxOut era] -> UtxoPredicateFailure era
newtype UtxoEvent era
UpdateEvent :: Event (EraRule "PPUP" era) -> UtxoEvent era

-- | Calculate the value consumed by the transation.
--   
--   This differs from the corresponding Shelley function
--   <tt>Shelley.consumed</tt> since it also considers the "mint" field
--   which creates or destroys non-Ada tokens.
--   
--   Note that this is slightly confusing, since it also covers non-Ada
--   assets _created_ by the transaction, depending on the sign of the
--   quantities in the mint field.
consumed :: forall era. (Era era, HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "mint" (TxBody era) (Value era), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "_keyDeposit" (PParams era) Coin) => PParams era -> UTxO era -> TxBody era -> Value era

-- | The UTxO transition rule for the Shelley-MA (Mary and Allegra) eras.
utxoTransition :: forall era. (UsesTxBody era, UsesValue era, STS (UTXO era), Tx era ~ Tx era, Embed (EraRule "PPUP" era) (UTXO era), Environment (EraRule "PPUP" era) ~ PPUPEnv era, State (EraRule "PPUP" era) ~ PPUPState era, Signal (EraRule "PPUP" era) ~ Maybe (Update era), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "mint" (TxBody era) (Value era), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "vldt" (TxBody era) ValidityInterval, HasField "update" (TxBody era) (StrictMaybe (Update era)), HasField "_minfeeA" (PParams era) Natural, HasField "_minfeeB" (PParams era) Natural, HasField "_keyDeposit" (PParams era) Coin, HasField "_poolDeposit" (PParams era) Coin, HasField "_minUTxOValue" (PParams era) Coin, HasField "_maxTxSize" (PParams era) Natural) => TransitionRule (UTXO era)

-- | Ensure the transaction is within the validity window.
--   
--   <pre>
--   ininterval slot (txvld tx)
--   </pre>
validateOutsideValidityIntervalUTxO :: HasField "vldt" (TxBody era) ValidityInterval => SlotNo -> TxBody era -> Test (UtxoPredicateFailure era)

-- | Check that the mint field does not try to mint ADA. This is equivalent
--   to the check:
--   
--   <pre>
--   adaPolicy ∉ supp mint tx
--   </pre>
validateTriesToForgeADA :: (Val (Value era), HasField "mint" (TxBody era) (Value era)) => TxBody era -> Test (UtxoPredicateFailure era)

-- | Ensure that there are no <a>TxOut</a>s that have <tt>Value</tt> of
--   size larger than <tt>MaxValSize</tt>
--   
--   <pre>
--   ∀ txout ∈ txouts txb, serSize (getValue txout) ≤ MaxValSize
--   </pre>
validateOutputTooBigUTxO :: (HasField "value" (TxOut era) (Value era), ToCBOR (Value era)) => UTxO era -> Test (UtxoPredicateFailure era)

-- | Ensure that there are no <a>TxOut</a>s that have value less than the
--   scaled <tt>minUTxOValue</tt>
--   
--   <pre>
--   ∀ txout ∈ txouts txb, getValue txout ≥ inject (scaledMinDeposit v (minUTxOValue pp))
--   </pre>
validateOutputTooSmallUTxO :: (HasField "_minUTxOValue" (PParams era) Coin, HasField "value" (TxOut era) (Value era), Val (Value era)) => PParams era -> UTxO era -> Test (UtxoPredicateFailure era)

-- | Ensure that value consumed and produced matches up exactly. Note that
--   this is different from Shelley, since implementation of
--   <a>consumed</a> has changed.
--   
--   <pre>
--   consumed pp utxo txb = produced pp poolParams txb
--   </pre>
validateValueNotConservedUTxO :: (Era era, HasField "_keyDeposit" (PParams era) Coin, HasField "_poolDeposit" (PParams era) Coin, HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "mint" (TxBody era) (Value era)) => PParams era -> UTxO era -> Map (KeyHash 'StakePool (Crypto era)) a -> TxBody era -> Test (UtxoPredicateFailure era)
data UTXO era
fromShelleyFailure :: UtxoPredicateFailure era -> Maybe (UtxoPredicateFailure era)
instance GHC.Generics.Generic (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era)
instance (GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.UTxOState era), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Show.Show (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era)
instance (GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Cardano.Ledger.Core.Value era), GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.UTxOState era), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Classes.Eq (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.Constraints.UsesAuxiliary era, Cardano.Ledger.Shelley.Constraints.UsesScript era, Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Cardano.Ledger.Shelley.Constraints.UsesPParams era, Cardano.Ledger.Shelley.Constraints.TransValue Cardano.Binary.ToCBOR.ToCBOR era, Cardano.Ledger.Core.PParams era GHC.Types.~ Cardano.Ledger.Shelley.PParams.PParams era, Cardano.Ledger.Core.TxBody era GHC.Types.~ Cardano.Ledger.ShelleyMA.TxBody.TxBody era, Cardano.Ledger.Core.TxOut era GHC.Types.~ Cardano.Ledger.Shelley.TxBody.TxOut era, Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Shelley.Tx.Tx era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "PPUP" era) (Cardano.Ledger.ShelleyMA.Rules.Utxo.UTXO era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PPUPEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.PPUPState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ GHC.Maybe.Maybe (Cardano.Ledger.Shelley.PParams.Update era)) => Control.State.Transition.Extended.STS (Cardano.Ledger.ShelleyMA.Rules.Utxo.UTXO era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Control.State.Transition.Extended.Event (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era) (Cardano.Ledger.ShelleyMA.Rules.Utxo.UTXO era)
instance (NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxOut era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.UTxOState era), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era)
instance (Data.Typeable.Internal.Typeable era, Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.UTxOState era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era)
instance (Cardano.Ledger.Shelley.Constraints.TransValue Cardano.Binary.FromCBOR.FromCBOR era, Cardano.Ledger.Shelley.UTxO.TransUTxO Cardano.Binary.FromCBOR.FromCBOR era, Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.InjectMaybe (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era)

module Cardano.Ledger.ShelleyMA.Rules.Utxow
data UTXOW era
instance (Cardano.Ledger.Core.Witnesses era GHC.Types.~ Cardano.Ledger.Shelley.Tx.WitnessSet era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UTXO" era) (Cardano.Ledger.ShelleyMA.Rules.Utxow.UTXOW era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UTxOState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Core.Tx era, Cardano.Ledger.Shelley.Rules.Utxow.ShelleyStyleWitnessNeeds era) => Control.State.Transition.Extended.STS (Cardano.Ledger.ShelleyMA.Rules.Utxow.UTXOW era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.ShelleyMA.Rules.Utxo.UTXO era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Control.State.Transition.Extended.Event (Cardano.Ledger.ShelleyMA.Rules.Utxo.UTXO era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.ShelleyMA.Rules.Utxo.UTXO era) (Cardano.Ledger.ShelleyMA.Rules.Utxow.UTXOW era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.ShelleyMA.Rules.Utxow.UTXOW era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Control.State.Transition.Extended.Event (Cardano.Ledger.ShelleyMA.Rules.Utxow.UTXOW era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.ShelleyMA.Rules.Utxow.UTXOW era) (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era)

module Cardano.Ledger.ShelleyMA

-- | The Shelley Mary/Allegra eras The uninhabited type that indexes both
--   the Mary and Allegra Eras.
data ShelleyMAEra (ma :: MaryOrAllegra) c
data MaryOrAllegra
Mary :: MaryOrAllegra
Allegra :: MaryOrAllegra

-- | The output of a UTxO.
data TxOut era
data TxBody e
data AuxiliaryData era
type PParams era = PParams' Identity era
data Tx era
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.ShelleyMA.MAClass 'Cardano.Ledger.ShelleyMA.Mary c
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.ShelleyMA.MAClass 'Cardano.Ledger.ShelleyMA.Allegra c
instance Cardano.Ledger.ShelleyMA.MAClass ma c => Cardano.Ledger.Era.Era (Cardano.Ledger.ShelleyMA.ShelleyMAEra ma c)
instance (Cardano.Ledger.Crypto.Crypto c, Cardano.Ledger.ShelleyMA.MAClass ma c) => Cardano.Ledger.Era.SupportsSegWit (Cardano.Ledger.ShelleyMA.ShelleyMAEra ma c)
instance Cardano.Ledger.ShelleyMA.MAClass ma c => GHC.Records.HasField "minted" (Cardano.Ledger.ShelleyMA.TxBody.TxBody (Cardano.Ledger.ShelleyMA.ShelleyMAEra ma c)) (Data.Set.Internal.Set (Cardano.Ledger.Hashes.ScriptHash c))
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesValue (Cardano.Ledger.ShelleyMA.ShelleyMAEra 'Cardano.Ledger.ShelleyMA.Mary c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesValue (Cardano.Ledger.ShelleyMA.ShelleyMAEra 'Cardano.Ledger.ShelleyMA.Allegra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesTxOut (Cardano.Ledger.ShelleyMA.ShelleyMAEra 'Cardano.Ledger.ShelleyMA.Mary c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesTxOut (Cardano.Ledger.ShelleyMA.ShelleyMAEra 'Cardano.Ledger.ShelleyMA.Allegra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesPParams (Cardano.Ledger.ShelleyMA.ShelleyMAEra 'Cardano.Ledger.ShelleyMA.Mary c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesPParams (Cardano.Ledger.ShelleyMA.ShelleyMAEra 'Cardano.Ledger.ShelleyMA.Allegra c)
instance (Cardano.Ledger.Crypto.Crypto c, Cardano.Ledger.Shelley.Constraints.UsesTxBody (Cardano.Ledger.ShelleyMA.ShelleyMAEra ma c), Cardano.Ledger.Core.AnnotatedData (Cardano.Ledger.Core.AuxiliaryData (Cardano.Ledger.ShelleyMA.ShelleyMAEra ma c))) => Cardano.Ledger.Era.ValidateScript (Cardano.Ledger.ShelleyMA.ShelleyMAEra ma c)
instance (Cardano.Ledger.Crypto.Crypto c, Cardano.Ledger.Core.AnnotatedData (Cardano.Ledger.Core.Script (Cardano.Ledger.ShelleyMA.ShelleyMAEra ma c))) => Cardano.Ledger.AuxiliaryData.ValidateAuxiliaryData (Cardano.Ledger.ShelleyMA.ShelleyMAEra ma c) c

module Cardano.Ledger.ShelleyMA.Rules.EraMapping

module Cardano.Ledger.Mary
type MaryEra c = ShelleyMAEra 'Mary c
type Self c = ShelleyMAEra 'Mary c

-- | The output of a UTxO.
data TxOut era
type Value era = Value (Crypto era)
data TxBody e
type Script era = Timelock (Crypto era)
data AuxiliaryData era
type PParams era = PParams' Identity era
type PParamsDelta era = PParamsUpdate era
data Tx era
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.Mempool.ApplyTx (Cardano.Ledger.Mary.MaryEra c)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.Validation.ApplyBlock (Cardano.Ledger.Mary.MaryEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.API.Genesis.CanStartFromGenesis (Cardano.Ledger.Mary.MaryEra c)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.ShelleyBasedEra (Cardano.Ledger.Mary.MaryEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.API.Wallet.CLI (Cardano.Ledger.Mary.MaryEra c)

module Cardano.Ledger.Allegra
type AllegraEra = ShelleyMAEra 'Allegra
type Self c = ShelleyMAEra 'Allegra c

-- | The output of a UTxO.
data TxOut era
data TxBody e
type Value era = Coin
type Script era = Timelock (Crypto era)
data AuxiliaryData era
type PParams era = PParams' Identity era
type PParamsDelta era = PParamsUpdate era
data Tx era
type Witnesses era = WitnessSet (Crypto era)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.Mempool.ApplyTx (Cardano.Ledger.Allegra.AllegraEra c)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.Validation.ApplyBlock (Cardano.Ledger.Allegra.AllegraEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.API.Genesis.CanStartFromGenesis (Cardano.Ledger.Allegra.AllegraEra c)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.ShelleyBasedEra (Cardano.Ledger.Allegra.AllegraEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.API.Wallet.CLI (Cardano.Ledger.Allegra.AllegraEra c)

module Cardano.Ledger.Mary.Translation
translateValue :: Crypto c => Coin -> Value c
translateCompactValue :: Crypto c => CompactForm Coin -> CompactForm (Value c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.LedgerState.NewEpochState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.Tx.Tx
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.Genesis.ShelleyGenesis
instance (Cardano.Ledger.Crypto.Crypto c, GHC.Base.Functor f) => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) (Cardano.Ledger.Shelley.PParams.PParams' f)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.LedgerState.EpochState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.LedgerState.LedgerState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.PParams.ProposedPPUpdates
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.LedgerState.PPUPState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.LedgerState.UTxOState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.TxBody.TxOut
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.UTxO.UTxO
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.Tx.WitnessSet
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.Shelley.PParams.Update
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Cardano.Ledger.ShelleyMA.AuxiliaryData.AuxiliaryData

module Cardano.Ledger.Allegra.Translation

-- | Return the subset of UTxO corresponding to Byron-era AVVM addresses,
--   which are to be removed on the Shelley/Allegra boundary. This set will
--   be passed _back_ to the translation functions as the UTxO, allowing
--   these addresses to be removed. This is needed because we cannot do a
--   full scan on the UTxO at this point, since it has been persisted to
--   disk.
shelleyToAllegraAVVMsToDelete :: NewEpochState (ShelleyEra c) -> UTxO (ShelleyEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.LedgerState.NewEpochState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.Tx.Tx
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.Genesis.ShelleyGenesis
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) (Cardano.Ledger.Shelley.PParams.PParams' f)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.PParams.ProposedPPUpdates
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.LedgerState.PPUPState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.TxBody.TxOut
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.UTxO.UTxO
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.LedgerState.UTxOState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.LedgerState.LedgerState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.LedgerState.EpochState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.Tx.WitnessSet
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Cardano.Ledger.Shelley.PParams.Update
