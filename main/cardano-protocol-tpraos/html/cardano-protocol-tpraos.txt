-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cardano Protocol: Transitional Praos
@package cardano-protocol-tpraos
@version 0.1.0.0

module Cardano.Protocol.TPraos.OCert
data OCert crypto
OCert :: !VerKeyKES crypto -> !Word64 -> !KESPeriod -> !SignedDSIGN crypto (OCertSignable crypto) -> OCert crypto

-- | The operational hot key
[ocertVkHot] :: OCert crypto -> !VerKeyKES crypto

-- | counter
[ocertN] :: OCert crypto -> !Word64

-- | Start of key evolving signature period
[ocertKESPeriod] :: OCert crypto -> !KESPeriod

-- | Signature of block operational certificate content
[ocertSigma] :: OCert crypto -> !SignedDSIGN crypto (OCertSignable crypto)
data OCertEnv crypto
OCertEnv :: Set (KeyHash 'StakePool crypto) -> Set (KeyHash 'GenesisDelegate crypto) -> OCertEnv crypto
[ocertEnvStPools] :: OCertEnv crypto -> Set (KeyHash 'StakePool crypto)
[ocertEnvGenDelegs] :: OCertEnv crypto -> Set (KeyHash 'GenesisDelegate crypto)

-- | Signable part of an operational certificate
data OCertSignable crypto
OCertSignable :: !VerKeyKES crypto -> !Word64 -> !KESPeriod -> OCertSignable crypto

-- | Extract the signable part of an operational certificate (for
--   verification)
ocertToSignable :: OCert crypto -> OCertSignable crypto
currentIssueNo :: OCertEnv crypto -> Map (KeyHash 'BlockIssuer crypto) Word64 -> KeyHash 'BlockIssuer crypto -> Maybe Word64
newtype KESPeriod
KESPeriod :: Word -> KESPeriod
[unKESPeriod] :: KESPeriod -> Word
slotsPerKESPeriod :: Globals -> Word64
kesPeriod :: SlotNo -> ShelleyBase KESPeriod
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.OCert.OCertEnv crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.OCert.OCertEnv crypto)
instance GHC.Show.Show Cardano.Protocol.TPraos.OCert.KESPeriod
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Protocol.TPraos.OCert.KESPeriod
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Protocol.TPraos.OCert.KESPeriod
instance NoThunks.Class.NoThunks Cardano.Protocol.TPraos.OCert.KESPeriod
instance GHC.Classes.Ord Cardano.Protocol.TPraos.OCert.KESPeriod
instance GHC.Generics.Generic Cardano.Protocol.TPraos.OCert.KESPeriod
instance GHC.Classes.Eq Cardano.Protocol.TPraos.OCert.KESPeriod
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Protocol.TPraos.OCert.OCert crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.OCert.OCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Protocol.TPraos.OCert.OCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Cardano.Protocol.TPraos.OCert.OCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.OCert.OCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Serialization.ToCBORGroup (Cardano.Protocol.TPraos.OCert.OCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Serialization.FromCBORGroup (Cardano.Protocol.TPraos.OCert.OCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Crypto.Util.SignableRepresentation (Cardano.Protocol.TPraos.OCert.OCertSignable crypto)

module Cardano.Protocol.TPraos.BHeader

-- | The hash of a Block Header
newtype HashHeader crypto
HashHeader :: Hash crypto EraIndependentBlockHeader -> HashHeader crypto
[unHashHeader] :: HashHeader crypto -> Hash crypto EraIndependentBlockHeader

-- | The previous hash of a block
data PrevHash crypto
GenesisHash :: PrevHash crypto
BlockHash :: !HashHeader crypto -> PrevHash crypto
data BHeader crypto
pattern BHeader :: Crypto crypto => BHBody crypto -> SignedKES crypto (BHBody crypto) -> BHeader crypto
data BHBody crypto
BHBody :: !BlockNo -> !SlotNo -> !PrevHash crypto -> !VKey 'BlockIssuer crypto -> !VerKeyVRF crypto -> !CertifiedVRF crypto Nonce -> !CertifiedVRF crypto Natural -> !Natural -> !Hash crypto EraIndependentBlockBody -> !OCert crypto -> !ProtVer -> BHBody crypto

-- | block number
[bheaderBlockNo] :: BHBody crypto -> !BlockNo

-- | block slot
[bheaderSlotNo] :: BHBody crypto -> !SlotNo

-- | Hash of the previous block header
[bheaderPrev] :: BHBody crypto -> !PrevHash crypto

-- | verification key of block issuer
[bheaderVk] :: BHBody crypto -> !VKey 'BlockIssuer crypto

-- | VRF verification key for block issuer
[bheaderVrfVk] :: BHBody crypto -> !VerKeyVRF crypto

-- | block nonce
[bheaderEta] :: BHBody crypto -> !CertifiedVRF crypto Nonce

-- | leader election value
[bheaderL] :: BHBody crypto -> !CertifiedVRF crypto Natural

-- | Size of the block body
[bsize] :: BHBody crypto -> !Natural

-- | Hash of block body
[bhash] :: BHBody crypto -> !Hash crypto EraIndependentBlockBody

-- | operational certificate
[bheaderOCert] :: BHBody crypto -> !OCert crypto

-- | protocol version
[bprotver] :: BHBody crypto -> !ProtVer
data LastAppliedBlock crypto
LastAppliedBlock :: !BlockNo -> !SlotNo -> !HashHeader crypto -> LastAppliedBlock crypto
[labBlockNo] :: LastAppliedBlock crypto -> !BlockNo
[labSlotNo] :: LastAppliedBlock crypto -> !SlotNo
[labHash] :: LastAppliedBlock crypto -> !HashHeader crypto

-- | Natural value with some additional bound. It must always be the base
--   that 'bvValue &lt;= bvMaxValue'. The creator is responsible for
--   checking this value.
data BoundedNatural

-- | Assert that a natural is bounded by a certain value. Throws an error
--   when this is not the case.
assertBoundedNatural :: Natural -> Natural -> BoundedNatural
lastAppliedHash :: WithOrigin (LastAppliedBlock crypto) -> PrevHash crypto

-- | Retrieve the issuer id (the hash of the cold key) from the body of the
--   block header. This corresponds to either a genesis/core node or a
--   stake pool.
issuerIDfromBHBody :: Crypto crypto => BHBody crypto -> KeyHash 'BlockIssuer crypto

-- | Check that the certified VRF output, when used as a natural, is valid
--   for being slot leader.
checkLeaderValue :: forall v. VRFAlgorithm v => OutputVRF v -> Rational -> ActiveSlotCoeff -> Bool

-- | Check that the certified input natural is valid for being slot leader.
--   This means we check that
--   
--   p &lt; 1 - (1 - f)^σ
--   
--   where p = certNat / certNatMax.
--   
--   The calculation is done using the following optimization:
--   
--   let q = 1 - p and c = ln(1 - f)
--   
--   then p &lt; 1 - (1 - f)^σ <a>=</a> 1 / (1 - p) &lt; exp(-σ * c)
--   <a>=</a> 1 / q &lt; exp(-σ * c)
--   
--   This can be efficiently be computed by <a>taylorExpCmp</a> which
--   returns <a>ABOVE</a> in case the reference value `1 / (1 - p)` is
--   above the exponential function at `-σ * c`, <a>BELOW</a> if it is
--   below or <a>MaxReached</a> if it couldn't conclusively compute this
--   within the given iteration bounds.
--   
--   Note that 1 1 1 certNatMax --- = ----- = ----------------------------
--   = ---------------------- q 1 - p 1 - (certNat / certNatMax)
--   (certNatMax - certNat)
checkLeaderNatValue :: BoundedNatural -> Rational -> ActiveSlotCoeff -> Bool

-- | Hash a given block header
bhHash :: Crypto crypto => BHeader crypto -> HashHeader crypto

-- | HashHeader to Nonce What is going on here? This is here because the
--   surrounding code is parametrized in the hash algorithm used, but the
--   nonce is hard-coded to Blake2b_256. We require the nonce to have the
--   right length (the size of a Blake2b_256 hash), so if the hash size
--   differs, we pad or remove bytes accordingly.
hashHeaderToNonce :: HashHeader crypto -> Nonce
prevHashToNonce :: PrevHash crypto -> Nonce
bHeaderSize :: forall crypto. BHeader crypto -> Int
bhbody :: Crypto crypto => BHeader crypto -> BHBody crypto
hBbsize :: BHBody crypto -> Natural
seedEta :: Nonce
seedL :: Nonce

-- | Construct a seed to use in the VRF computation.
mkSeed :: Nonce -> SlotNo -> Nonce -> Seed

-- | Retrieve the new nonce from the block header body.
bnonce :: BHBody crypto -> Nonce
makeHeaderView :: Crypto crypto => BHeader crypto -> BHeaderView crypto
instance NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.BHeader.HashHeader crypto)
instance Control.DeepSeq.NFData (Cardano.Protocol.TPraos.BHeader.HashHeader crypto)
instance GHC.Classes.Ord (Cardano.Protocol.TPraos.BHeader.HashHeader crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.BHeader.HashHeader crypto)
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.BHeader.HashHeader crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.BHeader.HashHeader crypto)
instance GHC.Classes.Ord (Cardano.Protocol.TPraos.BHeader.PrevHash crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.BHeader.PrevHash crypto)
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.BHeader.PrevHash crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.BHeader.PrevHash crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.BHeader.BHBody crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.BHeader.BHeader crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.BHeader.LastAppliedBlock crypto)
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.BHeader.LastAppliedBlock crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.BHeader.LastAppliedBlock crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Protocol.TPraos.BHeader.HashHeader crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Protocol.TPraos.BHeader.HashHeader crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Cardano.Protocol.TPraos.BHeader.BHBody crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Protocol.TPraos.BHeader.BHBody crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.BHeader.BHeader crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Protocol.TPraos.BHeader.BHeader crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Cardano.Protocol.TPraos.BHeader.BHeader crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.BHeader.LastAppliedBlock crypto)
instance Control.DeepSeq.NFData (Cardano.Protocol.TPraos.BHeader.LastAppliedBlock crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Protocol.TPraos.BHeader.LastAppliedBlock crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Protocol.TPraos.BHeader.LastAppliedBlock crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Protocol.TPraos.BHeader.BHeader crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Protocol.TPraos.BHeader.BHeader crypto))
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Crypto.Util.SignableRepresentation (Cardano.Protocol.TPraos.BHeader.BHBody crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.BHeader.BHBody crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Protocol.TPraos.BHeader.BHBody crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Protocol.TPraos.BHeader.BHBody crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.BHeader.PrevHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Protocol.TPraos.BHeader.PrevHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Protocol.TPraos.BHeader.PrevHash crypto)

module Cardano.Protocol.TPraos.Rules.OCert
data OCERT crypto

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data OCertEnv crypto
OCertEnv :: Set (KeyHash 'StakePool crypto) -> Set (KeyHash 'GenesisDelegate crypto) -> OCertEnv crypto
[ocertEnvStPools] :: OCertEnv crypto -> Set (KeyHash 'StakePool crypto)
[ocertEnvGenDelegs] :: OCertEnv crypto -> Set (KeyHash 'GenesisDelegate crypto)
data OcertPredicateFailure crypto
KESBeforeStartOCERT :: !KESPeriod -> !KESPeriod -> OcertPredicateFailure crypto
KESAfterEndOCERT :: !KESPeriod -> !KESPeriod -> !Word64 -> OcertPredicateFailure crypto
CounterTooSmallOCERT :: !Word64 -> !Word64 -> OcertPredicateFailure crypto
InvalidSignatureOCERT :: !Word64 -> !KESPeriod -> OcertPredicateFailure crypto
InvalidKesSignatureOCERT :: !Word -> !Word -> !Word -> !String -> OcertPredicateFailure crypto
NoCounterForKeyHashOCERT :: !KeyHash 'BlockIssuer crypto -> OcertPredicateFailure crypto
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.Rules.OCert.OcertPredicateFailure crypto)
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.Rules.OCert.OcertPredicateFailure crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.Rules.OCert.OcertPredicateFailure crypto)
instance NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.Rules.OCert.OcertPredicateFailure crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Cardano.Ledger.Keys.DSignable crypto (Cardano.Protocol.TPraos.OCert.OCertSignable crypto), Cardano.Ledger.Keys.KESignable crypto (Cardano.Protocol.TPraos.BHeader.BHBody crypto)) => Control.State.Transition.Extended.STS (Cardano.Protocol.TPraos.Rules.OCert.OCERT crypto)

module Cardano.Protocol.TPraos.Rules.Overlay
data OVERLAY crypto

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data OverlayEnv crypto
OverlayEnv :: UnitInterval -> PoolDistr crypto -> GenDelegs crypto -> Nonce -> OverlayEnv crypto
data OverlayPredicateFailure crypto
VRFKeyUnknown :: !KeyHash 'StakePool crypto -> OverlayPredicateFailure crypto
VRFKeyWrongVRFKey :: !KeyHash 'StakePool crypto -> !Hash crypto (VerKeyVRF crypto) -> !Hash crypto (VerKeyVRF crypto) -> OverlayPredicateFailure crypto
VRFKeyBadNonce :: !Nonce -> !SlotNo -> !Nonce -> !CertifiedVRF (VRF crypto) Nonce -> OverlayPredicateFailure crypto
VRFKeyBadLeaderValue :: !Nonce -> !SlotNo -> !Nonce -> !CertifiedVRF (VRF crypto) Nonce -> OverlayPredicateFailure crypto
VRFLeaderValueTooBig :: !OutputVRF (VRF crypto) -> !Rational -> !ActiveSlotCoeff -> OverlayPredicateFailure crypto
NotActiveSlotOVERLAY :: !SlotNo -> OverlayPredicateFailure crypto
WrongGenesisColdKeyOVERLAY :: !KeyHash 'BlockIssuer crypto -> !KeyHash 'GenesisDelegate crypto -> OverlayPredicateFailure crypto
WrongGenesisVRFKeyOVERLAY :: !KeyHash 'BlockIssuer crypto -> !Hash crypto (VerKeyVRF crypto) -> !Hash crypto (VerKeyVRF crypto) -> OverlayPredicateFailure crypto
UnknownGenesisKeyOVERLAY :: !KeyHash 'Genesis crypto -> OverlayPredicateFailure crypto
OcertFailure :: PredicateFailure (OCERT crypto) -> OverlayPredicateFailure crypto
data OBftSlot crypto
NonActiveSlot :: OBftSlot crypto
ActiveSlot :: !KeyHash 'Genesis crypto -> OBftSlot crypto
classifyOverlaySlot :: SlotNo -> Set (KeyHash 'Genesis crypto) -> UnitInterval -> ActiveSlotCoeff -> SlotNo -> OBftSlot crypto
lookupInOverlaySchedule :: SlotNo -> Set (KeyHash 'Genesis crypto) -> UnitInterval -> ActiveSlotCoeff -> SlotNo -> Maybe (OBftSlot crypto)

-- | Return the list of overlaySlots for a given epoch. Note that this
--   linear in the size of the epoch, and should probably only be used for
--   testing. If something more performant is needed, we could probably use
--   [start + floor(x<i>d) | x &lt;- [0 .. (spe -1)], floor(x</i>d) &lt;
--   spe] but we would need to make sure that this is equivalent.
overlaySlots :: SlotNo -> UnitInterval -> EpochSize -> [SlotNo]
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.Rules.Overlay.OverlayEnv crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.Rules.Overlay.OverlayPredicateFailure crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.Rules.Overlay.OBftSlot crypto)
instance GHC.Classes.Ord (Cardano.Protocol.TPraos.Rules.Overlay.OBftSlot crypto)
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.Rules.Overlay.OBftSlot crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.Rules.Overlay.OBftSlot crypto)
instance Cardano.Crypto.VRF.Class.VRFAlgorithm (Cardano.Ledger.Crypto.VRF crypto) => GHC.Show.Show (Cardano.Protocol.TPraos.Rules.Overlay.OverlayPredicateFailure crypto)
instance Cardano.Crypto.VRF.Class.VRFAlgorithm (Cardano.Ledger.Crypto.VRF crypto) => GHC.Classes.Eq (Cardano.Protocol.TPraos.Rules.Overlay.OverlayPredicateFailure crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Protocol.TPraos.Rules.Overlay.OBftSlot crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Protocol.TPraos.Rules.Overlay.OBftSlot crypto)
instance NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.Rules.Overlay.OBftSlot crypto)
instance Control.DeepSeq.NFData (Cardano.Protocol.TPraos.Rules.Overlay.OBftSlot crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Cardano.Ledger.Keys.DSignable crypto (Cardano.Protocol.TPraos.OCert.OCertSignable crypto), Cardano.Ledger.Keys.KESignable crypto (Cardano.Protocol.TPraos.BHeader.BHBody crypto), Cardano.Crypto.VRF.Class.Signable (Cardano.Ledger.Crypto.VRF crypto) Cardano.Ledger.BaseTypes.Seed) => Control.State.Transition.Extended.STS (Cardano.Protocol.TPraos.Rules.Overlay.OVERLAY crypto)
instance Cardano.Crypto.VRF.Class.VRFAlgorithm (Cardano.Ledger.Crypto.VRF crypto) => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.Rules.Overlay.OverlayPredicateFailure crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Cardano.Ledger.Keys.DSignable crypto (Cardano.Protocol.TPraos.OCert.OCertSignable crypto), Cardano.Ledger.Keys.KESignable crypto (Cardano.Protocol.TPraos.BHeader.BHBody crypto), Cardano.Crypto.VRF.Class.Signable (Cardano.Ledger.Crypto.VRF crypto) Cardano.Ledger.BaseTypes.Seed) => Control.State.Transition.Extended.Embed (Cardano.Protocol.TPraos.Rules.OCert.OCERT crypto) (Cardano.Protocol.TPraos.Rules.Overlay.OVERLAY crypto)
instance NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.Rules.Overlay.OverlayEnv crypto)

module Cardano.Protocol.TPraos.Rules.Tickn
data TICKN
data TicknEnv
TicknEnv :: Nonce -> Nonce -> Nonce -> TicknEnv
[ticknEnvExtraEntropy] :: TicknEnv -> Nonce
[ticknEnvCandidateNonce] :: TicknEnv -> Nonce

-- | Hash of the last header of the previous epoch as a nonce.
[ticknEnvHashHeaderNonce] :: TicknEnv -> Nonce
data TicknState
TicknState :: !Nonce -> !Nonce -> TicknState
[ticknStateEpochNonce] :: TicknState -> !Nonce
[ticknStatePrevHashNonce] :: TicknState -> !Nonce
data TicknPredicateFailure

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
instance GHC.Generics.Generic Cardano.Protocol.TPraos.Rules.Tickn.TicknState
instance GHC.Classes.Eq Cardano.Protocol.TPraos.Rules.Tickn.TicknState
instance GHC.Show.Show Cardano.Protocol.TPraos.Rules.Tickn.TicknState
instance GHC.Classes.Eq Cardano.Protocol.TPraos.Rules.Tickn.TicknPredicateFailure
instance GHC.Show.Show Cardano.Protocol.TPraos.Rules.Tickn.TicknPredicateFailure
instance GHC.Generics.Generic Cardano.Protocol.TPraos.Rules.Tickn.TicknPredicateFailure
instance NoThunks.Class.NoThunks Cardano.Protocol.TPraos.Rules.Tickn.TicknPredicateFailure
instance Control.State.Transition.Extended.STS Cardano.Protocol.TPraos.Rules.Tickn.TICKN
instance NoThunks.Class.NoThunks Cardano.Protocol.TPraos.Rules.Tickn.TicknState
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Protocol.TPraos.Rules.Tickn.TicknState
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Protocol.TPraos.Rules.Tickn.TicknState

module Cardano.Protocol.TPraos.Rules.Updn
data UPDN crypto
newtype UpdnEnv

-- | New nonce
UpdnEnv :: Nonce -> UpdnEnv
data UpdnState
UpdnState :: Nonce -> Nonce -> UpdnState

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data UpdnPredicateFailure crypto
instance GHC.Classes.Eq Cardano.Protocol.TPraos.Rules.Updn.UpdnState
instance GHC.Show.Show Cardano.Protocol.TPraos.Rules.Updn.UpdnState
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.Rules.Updn.UpdnPredicateFailure crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.Rules.Updn.UpdnPredicateFailure crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.Rules.Updn.UpdnPredicateFailure crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Control.State.Transition.Extended.STS (Cardano.Protocol.TPraos.Rules.Updn.UPDN crypto)
instance NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.Rules.Updn.UpdnPredicateFailure crypto)

module Cardano.Protocol.TPraos.Rules.Prtcl
data PRTCL crypto

-- | Type of the state which the system transitions between.
type family State a
data PrtclEnv crypto
PrtclEnv :: UnitInterval -> PoolDistr crypto -> GenDelegs crypto -> Nonce -> PrtclEnv crypto
data PrtclState crypto
PrtclState :: !Map (KeyHash 'BlockIssuer crypto) Word64 -> !Nonce -> !Nonce -> PrtclState crypto
data PrtclPredicateFailure crypto
OverlayFailure :: PredicateFailure (OVERLAY crypto) -> PrtclPredicateFailure crypto
UpdnFailure :: PredicateFailure (UPDN crypto) -> PrtclPredicateFailure crypto

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data PrtlSeqFailure crypto
WrongSlotIntervalPrtclSeq :: SlotNo -> SlotNo -> PrtlSeqFailure crypto
WrongBlockNoPrtclSeq :: WithOrigin (LastAppliedBlock crypto) -> BlockNo -> PrtlSeqFailure crypto
WrongBlockSequencePrtclSeq :: PrevHash crypto -> PrevHash crypto -> PrtlSeqFailure crypto
prtlSeqChecks :: (MonadError (PrtlSeqFailure crypto) m, Crypto crypto) => WithOrigin (LastAppliedBlock crypto) -> BHeader crypto -> m ()
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclState crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclState crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclState crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclEnv crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclPredicateFailure crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.Rules.Prtcl.PrtlSeqFailure crypto)
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.Rules.Prtcl.PrtlSeqFailure crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.Rules.Prtcl.PrtlSeqFailure crypto)
instance Cardano.Crypto.VRF.Class.VRFAlgorithm (Cardano.Ledger.Crypto.VRF crypto) => GHC.Show.Show (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclPredicateFailure crypto)
instance Cardano.Crypto.VRF.Class.VRFAlgorithm (Cardano.Ledger.Crypto.VRF crypto) => GHC.Classes.Eq (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclPredicateFailure crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.Rules.Prtcl.PrtlSeqFailure crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Cardano.Ledger.Keys.DSignable crypto (Cardano.Protocol.TPraos.OCert.OCertSignable crypto), Cardano.Ledger.Keys.KESignable crypto (Cardano.Protocol.TPraos.BHeader.BHBody crypto), Cardano.Ledger.Keys.VRFSignable crypto Cardano.Ledger.BaseTypes.Seed) => Control.State.Transition.Extended.STS (Cardano.Protocol.TPraos.Rules.Prtcl.PRTCL crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Cardano.Ledger.Keys.DSignable crypto (Cardano.Protocol.TPraos.OCert.OCertSignable crypto), Cardano.Ledger.Keys.KESignable crypto (Cardano.Protocol.TPraos.BHeader.BHBody crypto), Cardano.Ledger.Keys.VRFSignable crypto Cardano.Ledger.BaseTypes.Seed) => Control.State.Transition.Extended.Embed (Cardano.Protocol.TPraos.Rules.Overlay.OVERLAY crypto) (Cardano.Protocol.TPraos.Rules.Prtcl.PRTCL crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Cardano.Ledger.Keys.DSignable crypto (Cardano.Protocol.TPraos.OCert.OCertSignable crypto), Cardano.Ledger.Keys.KESignable crypto (Cardano.Protocol.TPraos.BHeader.BHBody crypto), Cardano.Ledger.Keys.VRFSignable crypto Cardano.Ledger.BaseTypes.Seed) => Control.State.Transition.Extended.Embed (Cardano.Protocol.TPraos.Rules.Updn.UPDN crypto) (Cardano.Protocol.TPraos.Rules.Prtcl.PRTCL crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclPredicateFailure crypto)
instance NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclEnv crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclState crypto)


-- | Integration between the Shelley ledger and its corresponding
--   (Transitional Praos) protocol.
--   
--   In particular, this code supports extracting the components of the
--   ledger state needed for protocol execution, both now and in a 2k-slot
--   window.
module Cardano.Protocol.TPraos.API
class (Crypto c, DSignable c (OCertSignable c), KESignable c (BHBody c), VRFSignable c Seed) => PraosCrypto c
class (ChainData (ChainDepState (Crypto era)), SerialisableData (ChainDepState (Crypto era)), Eq (ChainTransitionError (Crypto era)), Show (ChainTransitionError (Crypto era)), Show (LedgerView (Crypto era)), Show (FutureLedgerViewError era), STS (EraRule "TICKF" era), BaseM (EraRule "TICKF" era) ~ ShelleyBase, Environment (EraRule "TICKF" era) ~ (), State (EraRule "TICKF" era) ~ NewEpochState era, Signal (EraRule "TICKF" era) ~ SlotNo, PredicateFailure (EraRule "TICKF" era) ~ TickfPredicateFailure era, HasField "_d" (PParams era) UnitInterval, HasField "_maxBBSize" (PParams era) Natural, HasField "_maxBHSize" (PParams era) Natural, HasField "_protocolVersion" (PParams era) ProtVer) => GetLedgerView era
currentLedgerView :: GetLedgerView era => NewEpochState era -> LedgerView (Crypto era)
currentLedgerView :: (GetLedgerView era, HasField "_extraEntropy" (PParams era) Nonce) => NewEpochState era -> LedgerView (Crypto era)
futureLedgerView :: (GetLedgerView era, MonadError (FutureLedgerViewError era) m) => Globals -> NewEpochState era -> SlotNo -> m (LedgerView (Crypto era))
futureLedgerView :: (GetLedgerView era, MonadError (FutureLedgerViewError era) m, HasField "_extraEntropy" (PParams era) Nonce) => Globals -> NewEpochState era -> SlotNo -> m (LedgerView (Crypto era))

-- | Data required by the Transitional Praos protocol from the Shelley
--   ledger.
data LedgerView crypto
LedgerView :: UnitInterval -> ~Nonce -> PoolDistr crypto -> GenDelegs crypto -> ChainChecksPParams -> LedgerView crypto
[lvD] :: LedgerView crypto -> UnitInterval
[lvExtraEntropy] :: LedgerView crypto -> ~Nonce
[lvPoolDistr] :: LedgerView crypto -> PoolDistr crypto
[lvGenDelegs] :: LedgerView crypto -> GenDelegs crypto
[lvChainChecks] :: LedgerView crypto -> ChainChecksPParams

-- | We construct a <a>LedgerView</a> using the Shelley genesis config in
--   the same way as <tt>translateToShelleyLedgerState</tt>.
mkInitialShelleyLedgerView :: forall c. ShelleyGenesis (ShelleyEra c) -> LedgerView c
newtype FutureLedgerViewError era
FutureLedgerViewError :: [PredicateFailure (EraRule "TICKF" era)] -> FutureLedgerViewError era
data ChainDepState crypto
ChainDepState :: !PrtclState crypto -> !TicknState -> !Nonce -> ChainDepState crypto
[csProtocol] :: ChainDepState crypto -> !PrtclState crypto
[csTickn] :: ChainDepState crypto -> !TicknState

-- | Nonce constructed from the hash of the last applied block header.
[csLabNonce] :: ChainDepState crypto -> !Nonce
newtype ChainTransitionError crypto
ChainTransitionError :: [PredicateFailure (PRTCL crypto)] -> ChainTransitionError crypto

-- | Tick the chain state to a new epoch.
tickChainDepState :: Globals -> LedgerView crypto -> Bool -> ChainDepState crypto -> ChainDepState crypto

-- | Update the chain state based upon a new block header.
--   
--   This also updates the last applied block hash.
updateChainDepState :: forall crypto m. (PraosCrypto crypto, MonadError (ChainTransitionError crypto) m) => Globals -> LedgerView crypto -> BHeader crypto -> ChainDepState crypto -> m (ChainDepState crypto)

-- | Re-update the chain state based upon a new block header.
--   
--   This function does no validation of whether the header is internally
--   valid or consistent with the chain it is being applied to; the caller
--   must ensure that this is valid through having previously applied it.
reupdateChainDepState :: forall crypto. PraosCrypto crypto => Globals -> LedgerView crypto -> BHeader crypto -> ChainDepState crypto -> ChainDepState crypto

-- | Construct an initial chain state given an initial nonce and a set of
--   genesis delegates.
initialChainDepState :: Nonce -> Map (KeyHash 'Genesis crypto) (GenDelegPair crypto) -> ChainDepState crypto

-- | Check that the certified VRF output, when used as a natural, is valid
--   for being slot leader.
checkLeaderValue :: forall v. VRFAlgorithm v => OutputVRF v -> Rational -> ActiveSlotCoeff -> Bool

-- | Get the (private) leader schedule for this epoch.
--   
--   Given a private VRF key, returns the set of slots in which this node
--   is eligible to lead.
getLeaderSchedule :: (Era era, Signable (VRF (Crypto era)) Seed, HasField "_d" (PParams era) UnitInterval) => Globals -> NewEpochState era -> ChainDepState (Crypto era) -> KeyHash 'StakePool (Crypto era) -> SignKeyVRF (Crypto era) -> PParams era -> Set SlotNo
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.API.LedgerView crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.API.LedgerView crypto)
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.API.LedgerView crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.API.ChainDepState crypto)
instance GHC.Show.Show (Cardano.Protocol.TPraos.API.ChainDepState crypto)
instance GHC.Classes.Eq (Cardano.Protocol.TPraos.API.ChainDepState crypto)
instance GHC.Generics.Generic (Cardano.Protocol.TPraos.API.ChainTransitionError crypto)
instance GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICKF" era)) => GHC.Classes.Eq (Cardano.Protocol.TPraos.API.FutureLedgerViewError era)
instance GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICKF" era)) => GHC.Show.Show (Cardano.Protocol.TPraos.API.FutureLedgerViewError era)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Protocol.TPraos.API.ChainTransitionError crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Cardano.Protocol.TPraos.API.ChainTransitionError crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Protocol.TPraos.API.GetLedgerView (Cardano.Ledger.Shelley.ShelleyEra crypto)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Protocol.TPraos.API.GetLedgerView (Cardano.Ledger.Allegra.AllegraEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Protocol.TPraos.API.GetLedgerView (Cardano.Ledger.Mary.MaryEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Protocol.TPraos.API.GetLedgerView (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Protocol.TPraos.API.GetLedgerView (Cardano.Ledger.Babbage.BabbageEra c)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.API.ChainTransitionError crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.API.ChainDepState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Protocol.TPraos.API.ChainDepState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Protocol.TPraos.API.ChainDepState crypto)
instance NoThunks.Class.NoThunks (Cardano.Protocol.TPraos.API.LedgerView crypto)
instance Cardano.Protocol.TPraos.API.PraosCrypto Cardano.Ledger.Crypto.StandardCrypto
