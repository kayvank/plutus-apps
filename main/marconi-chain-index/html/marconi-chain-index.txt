-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/plutus-apps#readme</a>.
@package marconi-chain-index
@version 1.2.0.0

module Marconi.ChainIndex.Indexers.Datum
type DatumIndex = SqliteIndex Event Notification Query Result
type Event = [(SlotNo, (DatumHash, ScriptData))]
type Query = DatumHash
type Result = Maybe ScriptData
type Notification = ()
newtype Depth
Depth :: Int -> Depth
open :: FilePath -> Depth -> IO DatumIndex
instance Database.SQLite.Simple.FromField.FromField Marconi.ChainIndex.Indexers.Datum.DatumHash
instance Database.SQLite.Simple.ToField.ToField Marconi.ChainIndex.Indexers.Datum.DatumHash
instance Codec.Serialise.Class.Serialise Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.FromField.FromField Cardano.Slotting.Slot.SlotNo
instance Database.SQLite.Simple.ToField.ToField Cardano.Slotting.Slot.SlotNo


-- | This module is a duplication of functionality from the
--   <a>LedgerState</a> module in the `cardano-api` Haskell project which
--   is not exposed .
--   
--   TODO: If `cardano-api` ever exposes this module, then we should use
--   that.
module Marconi.ChainIndex.Node.Client.GenesisConfig
data GenesisConfig
GenesisCardano :: !NodeConfig -> !Config -> !ShelleyConfig -> !AlonzoGenesis -> GenesisConfig
data ShelleyGenesisError
ShelleyGenesisReadError :: !FilePath -> !Text -> ShelleyGenesisError
ShelleyGenesisHashMismatch :: !GenesisHashShelley -> !GenesisHashShelley -> ShelleyGenesisError
ShelleyGenesisDecodeError :: !FilePath -> !Text -> ShelleyGenesisError
data AlonzoGenesisError
AlonzoGenesisReadError :: !FilePath -> !Text -> AlonzoGenesisError
AlonzoGenesisHashMismatch :: !GenesisHashAlonzo -> !GenesisHashAlonzo -> AlonzoGenesisError
AlonzoGenesisDecodeError :: !FilePath -> !Text -> AlonzoGenesisError
renderAlonzoGenesisError :: AlonzoGenesisError -> Text
renderShelleyGenesisError :: ShelleyGenesisError -> Text
renderHash :: Hash Blake2b_256 ByteString -> Text
data ShelleyConfig
ShelleyConfig :: !ShelleyGenesis StandardShelley -> !GenesisHashShelley -> ShelleyConfig
[scConfig] :: ShelleyConfig -> !ShelleyGenesis StandardShelley
[scGenesisHash] :: ShelleyConfig -> !GenesisHashShelley
newtype GenesisFile
GenesisFile :: FilePath -> GenesisFile
[unGenesisFile] :: GenesisFile -> FilePath
newtype GenesisHashByron
GenesisHashByron :: Text -> GenesisHashByron
[unGenesisHashByron] :: GenesisHashByron -> Text
newtype GenesisHashShelley
GenesisHashShelley :: Hash Blake2b_256 ByteString -> GenesisHashShelley
[unGenesisHashShelley] :: GenesisHashShelley -> Hash Blake2b_256 ByteString
newtype GenesisHashAlonzo
GenesisHashAlonzo :: Hash Blake2b_256 ByteString -> GenesisHashAlonzo
[unGenesisHashAlonzo] :: GenesisHashAlonzo -> Hash Blake2b_256 ByteString
newtype LedgerStateDir
LedgerStateDir :: FilePath -> LedgerStateDir
[unLedgerStateDir] :: LedgerStateDir -> FilePath
newtype NetworkName
NetworkName :: Text -> NetworkName
[unNetworkName] :: NetworkName -> Text
newtype NetworkConfigFile
NetworkConfigFile :: FilePath -> NetworkConfigFile
[unNetworkConfigFile] :: NetworkConfigFile -> FilePath
newtype SocketPath
SocketPath :: FilePath -> SocketPath
[unSocketPath] :: SocketPath -> FilePath
data NodeConfig
NodeConfig :: !Maybe Double -> !GenesisFile -> !GenesisHashByron -> !GenesisFile -> !GenesisHashShelley -> !GenesisFile -> !GenesisHashAlonzo -> !RequiresNetworkMagic -> !SoftwareVersion -> !ProtocolVersion -> !ProtocolTransitionParamsShelleyBased StandardShelley -> !ProtocolTransitionParamsShelleyBased StandardAllegra -> !ProtocolTransitionParamsShelleyBased StandardMary -> !TriggerHardFork -> !TriggerHardFork -> NodeConfig
[ncPBftSignatureThreshold] :: NodeConfig -> !Maybe Double
[ncByronGenesisFile] :: NodeConfig -> !GenesisFile
[ncByronGenesisHash] :: NodeConfig -> !GenesisHashByron
[ncShelleyGenesisFile] :: NodeConfig -> !GenesisFile
[ncShelleyGenesisHash] :: NodeConfig -> !GenesisHashShelley
[ncAlonzoGenesisFile] :: NodeConfig -> !GenesisFile
[ncAlonzoGenesisHash] :: NodeConfig -> !GenesisHashAlonzo
[ncRequiresNetworkMagic] :: NodeConfig -> !RequiresNetworkMagic
[ncByronSoftwareVersion] :: NodeConfig -> !SoftwareVersion
[ncByronProtocolVersion] :: NodeConfig -> !ProtocolVersion
[ncByronToShelley] :: NodeConfig -> !ProtocolTransitionParamsShelleyBased StandardShelley
[ncShelleyToAllegra] :: NodeConfig -> !ProtocolTransitionParamsShelleyBased StandardAllegra
[ncAllegraToMary] :: NodeConfig -> !ProtocolTransitionParamsShelleyBased StandardMary
[ncMaryToAlonzo] :: NodeConfig -> !TriggerHardFork
[ncAlonzoToBabbage] :: NodeConfig -> !TriggerHardFork
readNetworkConfig :: NetworkConfigFile -> ExceptT Text IO NodeConfig
adjustGenesisFilePath :: (FilePath -> FilePath) -> GenesisFile -> GenesisFile
mkAdjustPath :: FilePath -> FilePath -> FilePath
parseNodeConfig :: ByteString -> Either Text NodeConfig
readCardanoGenesisConfig :: NodeConfig -> ExceptT GenesisConfigError IO GenesisConfig
readByronGenesisConfig :: NodeConfig -> ExceptT GenesisConfigError IO Config
readShelleyGenesisConfig :: NodeConfig -> ExceptT GenesisConfigError IO ShelleyConfig
readAlonzoGenesisConfig :: NodeConfig -> ExceptT GenesisConfigError IO AlonzoGenesis
readAlonzoGenesis :: GenesisFile -> GenesisHashAlonzo -> ExceptT AlonzoGenesisError IO AlonzoGenesis
readShelleyGenesis :: GenesisFile -> GenesisHashShelley -> ExceptT ShelleyGenesisError IO ShelleyConfig
data GenesisConfigError
NEError :: !Text -> GenesisConfigError
NEByronConfig :: !FilePath -> !ConfigurationError -> GenesisConfigError
NEShelleyConfig :: !FilePath -> !Text -> GenesisConfigError
NEAlonzoConfig :: !FilePath -> !Text -> GenesisConfigError
NECardanoConfig :: !Text -> GenesisConfigError
renderGenesisConfigError :: GenesisConfigError -> Text
initExtLedgerStateVar :: GenesisConfig -> ExtLedgerState (HardForkBlock (CardanoEras StandardCrypto))
mkProtocolInfoCardano :: GenesisConfig -> ProtocolInfo IO (HardForkBlock (CardanoEras StandardCrypto))
shelleyProtVer :: NodeConfig -> ProtVer
shelleyPraosNonce :: ShelleyConfig -> Nonce
textShow :: Show a => a -> Text
readByteString :: FilePath -> Text -> ExceptT Text IO ByteString
instance GHC.Show.Show Marconi.ChainIndex.Node.Client.GenesisConfig.GenesisFile
instance GHC.Show.Show Marconi.ChainIndex.Node.Client.GenesisConfig.GenesisHashByron
instance GHC.Classes.Eq Marconi.ChainIndex.Node.Client.GenesisConfig.GenesisHashByron
instance GHC.Show.Show Marconi.ChainIndex.Node.Client.GenesisConfig.GenesisHashShelley
instance GHC.Classes.Eq Marconi.ChainIndex.Node.Client.GenesisConfig.GenesisHashShelley
instance GHC.Show.Show Marconi.ChainIndex.Node.Client.GenesisConfig.ShelleyGenesisError
instance GHC.Show.Show Marconi.ChainIndex.Node.Client.GenesisConfig.GenesisHashAlonzo
instance GHC.Classes.Eq Marconi.ChainIndex.Node.Client.GenesisConfig.GenesisHashAlonzo
instance GHC.Show.Show Marconi.ChainIndex.Node.Client.GenesisConfig.AlonzoGenesisError
instance GHC.Show.Show Marconi.ChainIndex.Node.Client.GenesisConfig.LedgerStateDir
instance GHC.Show.Show Marconi.ChainIndex.Node.Client.GenesisConfig.NetworkName
instance GHC.Show.Show Marconi.ChainIndex.Node.Client.GenesisConfig.NetworkConfigFile
instance GHC.Show.Show Marconi.ChainIndex.Node.Client.GenesisConfig.SocketPath
instance Data.Aeson.Types.FromJSON.FromJSON Marconi.ChainIndex.Node.Client.GenesisConfig.NodeConfig


-- | This module provides several type aliases and utility functions to
--   deal with them.
module Marconi.ChainIndex.Types

-- | Typre represents non empty list of Bech32 Shelley compatable addresses
type TargetAddresses = NonEmpty (Address ShelleyAddr)

-- | An alias for the current era, to ease the transition from one era to
--   the next one
type CurrentEra = BabbageEra
pattern AsCurrentEra :: AsType CurrentEra
pattern CurrentEra :: CardanoEra CurrentEra

-- | A Cardano TxOut of the current Era
type TxOut = TxOut CtxTx CurrentEra

-- | A reference to a transaction output. This is a pair of a transaction
--   reference, and an index indicating which of the outputs of that
--   transaction we are referring to.
type TxOutRef = TxIn
txOutRef :: TxId -> TxIx -> TxIn
utxoDbName :: FilePath
addressDatumDbName :: FilePath
datumDbName :: FilePath
scriptTxDbName :: FilePath
epochStateDbName :: FilePath
mintBurnDbName :: FilePath
newtype SecurityParam
SecurityParam :: Word64 -> SecurityParam
instance GHC.Show.Show Marconi.ChainIndex.Types.SecurityParam
instance GHC.Real.Integral Marconi.ChainIndex.Types.SecurityParam
instance GHC.Read.Read Marconi.ChainIndex.Types.SecurityParam
instance GHC.Num.Num Marconi.ChainIndex.Types.SecurityParam
instance GHC.Real.Real Marconi.ChainIndex.Types.SecurityParam
instance GHC.Enum.Enum Marconi.ChainIndex.Types.SecurityParam
instance GHC.Enum.Bounded Marconi.ChainIndex.Types.SecurityParam
instance GHC.Classes.Ord Marconi.ChainIndex.Types.SecurityParam
instance GHC.Classes.Eq Marconi.ChainIndex.Types.SecurityParam

module Marconi.ChainIndex.Orphans
mapLeft :: (a -> b) -> Either a c -> Either b c

-- | Helper to deserialize via SerialiseAsRawBytes instance
fromFieldViaRawBytes :: (SerialiseAsRawBytes a, Typeable a) => AsType a -> Field -> Ok a
encodeLedgerState :: LedgerState (CardanoBlock StandardCrypto) -> Encoding
decodeLedgerState :: forall s. Decoder s (LedgerState (CardanoBlock StandardCrypto))
instance Database.SQLite.Simple.ToField.ToField Cardano.Slotting.Slot.SlotNo
instance Database.SQLite.Simple.FromField.FromField Cardano.Slotting.Slot.SlotNo
instance Database.SQLite.Simple.ToField.ToField Cardano.Slotting.Block.BlockNo
instance Database.SQLite.Simple.FromField.FromField Cardano.Slotting.Block.BlockNo
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Value.AssetName
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Value.AssetName
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Value.Quantity
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Value.Quantity
instance Database.SQLite.Simple.ToField.ToField Marconi.ChainIndex.Types.SecurityParam
instance Database.SQLite.Simple.FromField.FromField Marconi.ChainIndex.Types.SecurityParam
instance Prettyprinter.Internal.Pretty Cardano.Api.Block.ChainTip
instance Prettyprinter.Internal.Pretty Cardano.Api.Block.ChainPoint
instance GHC.Classes.Ord Cardano.Api.Block.ChainPoint
instance Prettyprinter.Internal.Pretty (Cardano.Api.Hash.Hash Cardano.Api.Block.BlockHeader)
instance Database.SQLite.Simple.ToField.ToField (Cardano.Api.Hash.Hash Cardano.Api.Block.BlockHeader)
instance Database.SQLite.Simple.FromField.FromField (Cardano.Api.Hash.Hash Cardano.Api.Block.BlockHeader)
instance Prettyprinter.Internal.Pretty Cardano.Slotting.Slot.SlotNo
instance Prettyprinter.Internal.Pretty Cardano.Slotting.Block.BlockNo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Slotting.Block.BlockNo
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Slotting.Block.BlockNo
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Address.AddressAny
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Address.AddressAny
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.Address.AddressAny
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.Address.AddressAny
instance Database.SQLite.Simple.FromField.FromField (Cardano.Api.Hash.Hash Cardano.Api.ScriptData.ScriptData)
instance Database.SQLite.Simple.ToField.ToField (Cardano.Api.Hash.Hash Cardano.Api.ScriptData.ScriptData)
instance Codec.Serialise.Class.Serialise Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.ScriptData.ScriptData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Api.ScriptData.ScriptData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.ScriptData.ScriptData
instance Database.SQLite.Simple.ToRow.ToRow Cardano.Api.TxIn.TxIn
instance Database.SQLite.Simple.FromRow.FromRow Cardano.Api.TxIn.TxIn
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.TxIn.TxId
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.TxIn.TxId
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.TxIn.TxIx
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.TxIn.TxIx
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Value.Value
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Value.Value
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Script.ScriptInAnyLang
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Script.ScriptInAnyLang
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Script.ScriptHash
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Script.ScriptHash
instance Database.SQLite.Simple.ToField.ToField (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Cardano.Block.CardanoBlock Cardano.Ledger.Crypto.StandardCrypto))
instance Database.SQLite.Simple.FromField.FromField (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Cardano.Block.CardanoBlock Cardano.Ledger.Crypto.StandardCrypto))
instance Database.SQLite.Simple.ToField.ToField Cardano.Ledger.BaseTypes.Nonce
instance Database.SQLite.Simple.FromField.FromField Cardano.Ledger.BaseTypes.Nonce
instance Database.SQLite.Simple.ToField.ToField Cardano.Slotting.Slot.EpochNo
instance Database.SQLite.Simple.FromField.FromField Cardano.Slotting.Slot.EpochNo
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Value.Lovelace
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Value.Lovelace
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Certificate.PoolId
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Certificate.PoolId
instance Database.SQLite.Simple.ToField.ToField Cardano.Api.Value.PolicyId
instance Database.SQLite.Simple.FromField.FromField Cardano.Api.Value.PolicyId

module Marconi.ChainIndex.Logging
logging :: Trace IO Text -> Stream (Of (ChainSyncEvent (BlockInMode CardanoMode))) IO r -> Stream (Of (ChainSyncEvent (BlockInMode CardanoMode))) IO r


-- | Module for indexing the datums for all addresses in the Cardano
--   blockchain.
module Marconi.ChainIndex.Indexers.AddressDatum
type AddressDatumIndex = State AddressDatumHandle

-- | Define the <tt>handler</tt> data type, meant as a wrapper for the
--   connection type (in this case the SQLite connection). In this indexer,
--   we also add the number of events that we want to return from the
--   on-disk buffer.
data AddressDatumHandle
data family StorableEvent h
data family StorableQuery h
data family StorableResult h
toAddressDatumIndexEvent :: Maybe (Address ShelleyAddr -> Bool) -> [Tx era] -> ChainPoint -> StorableEvent AddressDatumHandle
type AddressDatumQuery = StorableQuery AddressDatumHandle
type AddressDatumResult = StorableResult AddressDatumHandle
newtype AddressDatumDepth
AddressDatumDepth :: Int -> AddressDatumDepth
open :: FilePath -> AddressDatumDepth -> IO AddressDatumIndex
instance GHC.Show.Show (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle)
instance GHC.Classes.Eq (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle)
instance GHC.Show.Show (Marconi.Core.Storable.StorableResult Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle)
instance GHC.Classes.Eq (Marconi.Core.Storable.StorableResult Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle)
instance GHC.Generics.Generic Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHashRow
instance GHC.Show.Show Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHashRow
instance GHC.Generics.Generic Marconi.ChainIndex.Indexers.AddressDatum.DatumRow
instance GHC.Show.Show Marconi.ChainIndex.Indexers.AddressDatum.DatumRow
instance Database.SQLite.Simple.FromRow.FromRow Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHashRow
instance Database.SQLite.Simple.FromRow.FromRow Marconi.ChainIndex.Indexers.AddressDatum.DatumRow
instance Database.SQLite.Simple.ToRow.ToRow Marconi.ChainIndex.Indexers.AddressDatum.DatumRow
instance Marconi.Core.Storable.Buffered Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle
instance Marconi.Core.Storable.Queryable Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle
instance Database.SQLite.Simple.ToRow.ToRow Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHashRow
instance GHC.Base.Semigroup (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle)
instance GHC.Base.Monoid (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle)
instance Marconi.Core.Storable.HasPoint (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle) Cardano.Api.Block.ChainPoint
instance Marconi.Core.Storable.Rewindable Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle
instance Marconi.Core.Storable.Resumable Marconi.ChainIndex.Indexers.AddressDatum.AddressDatumHandle


-- | Module for indexing the Utxos in the Cardano blockchain
module Marconi.ChainIndex.Indexers.Utxo
type UtxoIndexer = State UtxoHandle
data UtxoHandle
UtxoHandle :: !Connection -> !Int -> !Bool -> UtxoHandle

-- | SQLite connection
[hdlConnection] :: UtxoHandle -> !Connection

-- | depth before flushing to disk storage
[hdlDpeth] :: UtxoHandle -> !Int

-- | weather to perform SQLite vacuum to release space
[toVacuume] :: UtxoHandle -> !Bool
type QueryableAddresses = NonEmpty (StorableQuery UtxoHandle)
newtype Depth
Depth :: Int -> Depth
data Utxo
Utxo :: !AddressAny -> !TxId -> !TxIx -> !Maybe ScriptData -> !Maybe (Hash ScriptData) -> !Value -> !Maybe ScriptInAnyLang -> !Maybe ScriptHash -> Utxo
[_address] :: Utxo -> !AddressAny
[_txId] :: Utxo -> !TxId
[_txIx] :: Utxo -> !TxIx
[_datum] :: Utxo -> !Maybe ScriptData
[_datumHash] :: Utxo -> !Maybe (Hash ScriptData)
[_value] :: Utxo -> !Value
[_inlineScript] :: Utxo -> !Maybe ScriptInAnyLang
[_inlineScriptHash] :: Utxo -> !Maybe ScriptHash
value :: Lens' Utxo Value
txIx :: Lens' Utxo TxIx
txId :: Lens' Utxo TxId
inlineScriptHash :: Lens' Utxo (Maybe ScriptHash)
inlineScript :: Lens' Utxo (Maybe ScriptInAnyLang)
datumHash :: Lens' Utxo (Maybe (Hash ScriptData))
datum :: Lens' Utxo (Maybe ScriptData)
address :: Lens' Utxo AddressAny
newtype ChainPointRow
ChainPointRow :: ChainPoint -> ChainPointRow
[getChainPoint] :: ChainPointRow -> ChainPoint
data UtxoRow
UtxoRow :: !Utxo -> !SlotNo -> !Hash BlockHeader -> UtxoRow
[_urUtxo] :: UtxoRow -> !Utxo
[_urSlotNo] :: UtxoRow -> !SlotNo
[_urBlockHash] :: UtxoRow -> !Hash BlockHeader
urUtxo :: Lens' UtxoRow Utxo
urSlotNo :: Lens' UtxoRow SlotNo
urBlockHash :: Lens' UtxoRow (Hash BlockHeader)
eventIsBefore :: ChainPoint -> StorableEvent UtxoHandle -> Bool

-- | The effect of a transaction (or a number of them) on the tx output
--   set.
data TxOutBalance
TxOutBalance :: !Set TxIn -> !Set TxIn -> TxOutBalance

-- | Outputs newly added by the transaction(s)
[_tobUnspent] :: TxOutBalance -> !Set TxIn

-- | Outputs spent by the transaction(s)
[_tobSpent] :: TxOutBalance -> !Set TxIn
data Spent
Spent :: !TxId -> !TxIx -> !SlotNo -> !Hash BlockHeader -> Spent
[_sTxId] :: Spent -> !TxId
[_sTxIx] :: Spent -> !TxIx
[_sSlotNo] :: Spent -> !SlotNo
[_sBlockHash] :: Spent -> !Hash BlockHeader
sTxIx :: Lens' Spent TxIx
sTxId :: Lens' Spent TxId
sSlotNo :: Lens' Spent SlotNo
sBlockHash :: Lens' Spent (Hash BlockHeader)

-- | Open a connection to DB, and create resources The parameter ((k + 1) *
--   2) specifies the amount of events that are buffered. The larger the
--   number, the more RAM the indexer uses. However, we get improved SQL
--   queries due to batching more events together.
open :: FilePath -> Depth -> Bool -> IO UtxoIndexer
getSpentFrom :: StorableEvent UtxoHandle -> [Spent]

-- | Retrieve TxIns at a slotNo This function is used to reconstruct the
--   original UtxoEvent
getTxIns :: Connection -> SlotNo -> IO (Set TxIn)

-- | Convert UtxoRows to UtxoEvents
rowsToEvents :: (SlotNo -> IO (Set TxIn)) -> [UtxoRow] -> IO [StorableEvent UtxoHandle]

-- | merge in-memory events with SQL retreived UtxoRows Notes, a peroperty
--   of this merge is to remove all spent utxos from the resulting
--   [UtxoRow]
mergeInMemoryAndSql :: Foldable f => f (StorableEvent UtxoHandle) -> [UtxoRow] -> [UtxoRow]

-- | convert utxoEvent to utxoRow Note: No <tt>unspent</tt> computeation is
--   performed
eventToRows :: StorableEvent UtxoHandle -> [UtxoRow]

-- | Filter for events at the given address
eventsAtAddress :: Foldable f => AddressAny -> Maybe SlotNo -> f (StorableEvent UtxoHandle) -> [StorableEvent UtxoHandle]

-- | only store rows in the address list.
addressFilteredRows :: Foldable f => AddressAny -> Maybe SlotNo -> f (StorableEvent UtxoHandle) -> [UtxoRow]
utxoAtAddressQuery :: Foldable f => Connection -> f (StorableEvent UtxoHandle) -> StorableEvent UtxoHandle -> [Query] -> [NamedParam] -> IO (StorableResult UtxoHandle)

-- | Query memory buffer
queryBuffer :: Foldable f => QueryInterval ChainPoint -> AddressAny -> Maybe SlotNo -> f (StorableEvent UtxoHandle) -> StorableEvent UtxoHandle

-- | Convert from <tt>AddressInEra</tt> of the <a>CurrentEra</a> to
--   <tt>AddressAny</tt>.
toAddr :: AddressInEra era -> AddressAny

-- | Extract UtxoEvents from Cardano Block
getUtxoEventsFromBlock :: IsCardanoEra era => Maybe TargetAddresses -> Block era -> StorableEvent UtxoHandle

-- | Extract UtxoEvents from Cardano Transactions
getUtxoEvents :: IsCardanoEra era => Maybe TargetAddresses -> [Tx era] -> ChainPoint -> StorableEvent UtxoHandle

-- | does the transaction contain a targetAddress
isAddressInTarget :: Maybe TargetAddresses -> AddressAny -> Bool
getUtxos :: IsCardanoEra era => Maybe TargetAddresses -> Tx era -> Map TxIn Utxo

-- | get the inlineScript and inlineScriptHash
getRefScriptAndHash :: ReferenceScript era -> (Maybe ScriptInAnyLang, Maybe ScriptHash)

-- | Get the datum hash and datum or a transaction output.
getScriptDataAndHash :: TxOutDatum CtxTx era -> (Maybe ScriptData, Maybe (Hash ScriptData))

-- | remove spent transactions
rmSpent :: Set TxIn -> [Utxo] -> [Utxo]
getInputs :: Tx era -> Set TxIn

-- | Duplicated from cardano-api (not exposed in cardano-api) This function
--   should be removed when marconi will depend on a cardano-api version
--   that has accepted this PR:
--   <a>https://github.com/input-output-hk/cardano-node/pull/4569</a>
txScriptValidityToScriptValidity :: TxScriptValidity era -> ScriptValidity

-- | does the transaction contain a targetAddress
isAddressInTarget' :: TargetAddresses -> Utxo -> Bool
mkQueryableAddresses :: TargetAddresses -> QueryableAddresses
txOutBalanceFromTxs :: [Tx era] -> TxOutBalance
txOutBalanceFromTx :: Tx era -> TxOutBalance
convertTxOutToUtxo :: TxId -> TxIx -> TxOut CtxTx BabbageEra -> Utxo
instance GHC.Classes.Ord Marconi.ChainIndex.Indexers.Utxo.Spent
instance Marconi.Core.Storable.HasPoint (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.Utxo.UtxoHandle) Cardano.Api.Block.ChainPoint
instance Database.SQLite.Simple.ToRow.ToRow Marconi.ChainIndex.Indexers.Utxo.UtxoRow
instance Database.SQLite.Simple.FromRow.FromRow Marconi.ChainIndex.Indexers.Utxo.UtxoRow
instance Database.SQLite.Simple.FromRow.FromRow Marconi.ChainIndex.Indexers.Utxo.Spent
instance Database.SQLite.Simple.FromRow.FromRow Marconi.ChainIndex.Indexers.Utxo.ChainPointRow
instance Database.SQLite.Simple.ToRow.ToRow Marconi.ChainIndex.Indexers.Utxo.Spent
instance Marconi.Core.Storable.Buffered Marconi.ChainIndex.Indexers.Utxo.UtxoHandle
instance Marconi.Core.Storable.Queryable Marconi.ChainIndex.Indexers.Utxo.UtxoHandle
instance Marconi.Core.Storable.Rewindable Marconi.ChainIndex.Indexers.Utxo.UtxoHandle
instance Marconi.Core.Storable.Resumable Marconi.ChainIndex.Indexers.Utxo.UtxoHandle
instance GHC.Show.Show (Marconi.Core.Storable.StorableResult Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Classes.Eq (Marconi.Core.Storable.StorableResult Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Generics.Generic (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Show.Show (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Classes.Ord (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Classes.Eq (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Generics.Generic Marconi.ChainIndex.Indexers.Utxo.TxOutBalance
instance GHC.Show.Show Marconi.ChainIndex.Indexers.Utxo.TxOutBalance
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.Utxo.TxOutBalance
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.Utxo.Spent
instance GHC.Show.Show Marconi.ChainIndex.Indexers.Utxo.Spent
instance GHC.Base.Semigroup Marconi.ChainIndex.Indexers.Utxo.TxOutBalance
instance GHC.Base.Monoid Marconi.ChainIndex.Indexers.Utxo.TxOutBalance
instance Data.Aeson.Types.FromJSON.FromJSON Marconi.ChainIndex.Indexers.Utxo.UtxoRow
instance Data.Aeson.Types.ToJSON.ToJSON Marconi.ChainIndex.Indexers.Utxo.UtxoRow
instance Data.Aeson.Types.FromJSON.FromJSON Marconi.ChainIndex.Indexers.Utxo.ChainPointRow
instance Data.Aeson.Types.ToJSON.ToJSON Marconi.ChainIndex.Indexers.Utxo.ChainPointRow
instance GHC.Base.Semigroup (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Base.Monoid (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Generics.Generic Marconi.ChainIndex.Indexers.Utxo.UtxoRow
instance GHC.Classes.Ord Marconi.ChainIndex.Indexers.Utxo.UtxoRow
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.Utxo.UtxoRow
instance GHC.Show.Show Marconi.ChainIndex.Indexers.Utxo.UtxoRow
instance GHC.Generics.Generic Marconi.ChainIndex.Indexers.Utxo.ChainPointRow
instance GHC.Classes.Ord Marconi.ChainIndex.Indexers.Utxo.ChainPointRow
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.Utxo.ChainPointRow
instance GHC.Show.Show Marconi.ChainIndex.Indexers.Utxo.ChainPointRow
instance GHC.Classes.Ord Marconi.ChainIndex.Indexers.Utxo.Utxo
instance Data.Aeson.Types.FromJSON.FromJSON Marconi.ChainIndex.Indexers.Utxo.Utxo
instance Data.Aeson.Types.ToJSON.ToJSON Marconi.ChainIndex.Indexers.Utxo.Utxo
instance GHC.Classes.Ord (Marconi.Core.Storable.StorableQuery Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Classes.Eq (Marconi.Core.Storable.StorableQuery Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Show.Show (Marconi.Core.Storable.StorableQuery Marconi.ChainIndex.Indexers.Utxo.UtxoHandle)
instance GHC.Generics.Generic Marconi.ChainIndex.Indexers.Utxo.Utxo
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.Utxo.Utxo
instance GHC.Show.Show Marconi.ChainIndex.Indexers.Utxo.Utxo

module Marconi.ChainIndex.Indexers.ScriptTx
data ScriptTxHandle
ScriptTxHandle :: Connection -> Int -> ScriptTxHandle
[hdlConnection] :: ScriptTxHandle -> Connection
[hdlDepth] :: ScriptTxHandle -> Int
newtype Depth
Depth :: Int -> Depth
newtype TxCbor
TxCbor :: ByteString -> TxCbor
type ScriptTxIndexer = State ScriptTxHandle
data ScriptTxRow
ScriptTxRow :: !StorableQuery ScriptTxHandle -> !TxCbor -> !SlotNo -> !Hash BlockHeader -> ScriptTxRow
[scriptAddress] :: ScriptTxRow -> !StorableQuery ScriptTxHandle
[txCbor] :: ScriptTxRow -> !TxCbor
[txSlot] :: ScriptTxRow -> !SlotNo
[blockHash] :: ScriptTxRow -> !Hash BlockHeader
type Query = StorableQuery ScriptTxHandle
type Result = StorableResult ScriptTxHandle
toUpdate :: forall era. IsCardanoEra era => [Tx era] -> ChainPoint -> StorableEvent ScriptTxHandle
getTxBodyScripts :: forall era. TxBody era -> [StorableQuery ScriptTxHandle]
getTxScripts :: forall era. Tx era -> [StorableQuery ScriptTxHandle]
asEvents :: [ScriptTxRow] -> [StorableEvent ScriptTxHandle]
open :: FilePath -> Depth -> IO ScriptTxIndexer

-- | TODO: Remove when the following function is exported from
--   Cardano.Api.Script PR:
--   <a>https://github.com/input-output-hk/cardano-node/pull/4386</a>
fromShelleyBasedScript :: ShelleyBasedEra era -> Script (ShelleyLedgerEra era) -> ScriptInEra era
instance GHC.Classes.Eq (Marconi.Core.Storable.StorableQuery Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxHandle)
instance GHC.Show.Show (Marconi.Core.Storable.StorableQuery Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxHandle)
instance Database.SQLite.Simple.FromField.FromField Marconi.ChainIndex.Indexers.ScriptTx.TxCbor
instance Database.SQLite.Simple.ToField.ToField Marconi.ChainIndex.Indexers.ScriptTx.TxCbor
instance GHC.Show.Show Marconi.ChainIndex.Indexers.ScriptTx.TxCbor
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.ScriptTx.TxCbor
instance GHC.Show.Show (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxHandle)
instance GHC.Generics.Generic Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxRow
instance Database.SQLite.Simple.FromRow.FromRow Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxRow
instance Database.SQLite.Simple.ToRow.ToRow Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxRow
instance Marconi.Core.Storable.Buffered Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxHandle
instance Marconi.Core.Storable.Queryable Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxHandle
instance Marconi.Core.Storable.HasPoint (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxHandle) Cardano.Api.Block.ChainPoint
instance Database.SQLite.Simple.ToField.ToField (Marconi.Core.Storable.StorableQuery Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxHandle)
instance Database.SQLite.Simple.FromField.FromField (Marconi.Core.Storable.StorableQuery Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxHandle)
instance Marconi.Core.Storable.Rewindable Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxHandle
instance Marconi.Core.Storable.Resumable Marconi.ChainIndex.Indexers.ScriptTx.ScriptTxHandle


-- | Mint/burn event indexer, the result of which is an sqlite database
--   'mintburn.db' which has a table <tt>minting_policy_events</tt> with
--   the following fields:
--   
--   <ul>
--   <li>slotNo INT NOT NULL</li>
--   <li>blockHeaderHash INT NOT NULL</li>
--   <li>txId BLOB NOT NULL</li>
--   <li>policyId BLOB NOT NULL</li>
--   <li>assetName TEXT NOT NULL</li>
--   <li>quantity INT NOT NULL</li>
--   <li>redeemerIx INT NOT NULL</li>
--   <li>redeemerData BLOB NOT NULL</li>
--   </ul>
module Marconi.ChainIndex.Indexers.MintBurn
data TxMintEvent
TxMintEvent :: !SlotNo -> !Hash BlockHeader -> !NonEmpty (TxId, NonEmpty MintAsset) -> TxMintEvent
[txMintEventSlotNo] :: TxMintEvent -> !SlotNo
[txMintEventBlockHeaderHash] :: TxMintEvent -> !Hash BlockHeader
[txMintEventTxAssets] :: TxMintEvent -> !NonEmpty (TxId, NonEmpty MintAsset)
data MintAsset
MintAsset :: !PolicyId -> !AssetName -> !Quantity -> !Word64 -> !ScriptData -> MintAsset
[mintAssetPolicyId] :: MintAsset -> !PolicyId
[mintAssetAssetName] :: MintAsset -> !AssetName
[mintAssetQuantity] :: MintAsset -> !Quantity
[mintAssetRedeemerIdx] :: MintAsset -> !Word64
[mintAssetRedeemerData] :: MintAsset -> !ScriptData
toUpdate :: BlockInMode CardanoMode -> Maybe TxMintEvent
txMints :: Tx era -> Maybe (TxId, NonEmpty MintAsset)
txbMints :: TxBody era -> [MintAsset]
txRedeemers :: TxBody era -> Map RdmrPtr (Data (ShelleyLedgerEra era), ExUnits)
mintRedeemers :: TxBody era -> [(Word64, (Data (ShelleyLedgerEra era), ExUnits))]
getPolicyData :: TxBody era -> Value StandardCrypto -> [(PolicyId, AssetName, Quantity, Word64, ScriptData)]
fromMaryPolicyID :: PolicyID StandardCrypto -> PolicyId
fromMaryAssetName :: AssetName -> AssetName
fromAlonzoData :: Data ledgerera -> ScriptData
data TxMintRow
TxMintRow :: !SlotNo -> !Hash BlockHeader -> !TxId -> !PolicyId -> !AssetName -> !Quantity -> !Word64 -> !ScriptData -> TxMintRow
[_txMintRowSlotNo] :: TxMintRow -> !SlotNo
[_txMintRowBlockHeaderHash] :: TxMintRow -> !Hash BlockHeader
[_txMintRowTxId] :: TxMintRow -> !TxId
[_txMintRowPolicyId] :: TxMintRow -> !PolicyId
[_txMintRowAssetName] :: TxMintRow -> !AssetName
[_txMintRowQuantity] :: TxMintRow -> !Quantity
[_txMintRowRedeemerIdx] :: TxMintRow -> !Word64
[_txMintRowRedeemerData] :: TxMintRow -> !ScriptData
txMintRowTxId :: Lens' TxMintRow TxId
txMintRowSlotNo :: Lens' TxMintRow SlotNo
txMintRowRedeemerIdx :: Lens' TxMintRow Word64
txMintRowRedeemerData :: Lens' TxMintRow ScriptData
txMintRowQuantity :: Lens' TxMintRow Quantity
txMintRowPolicyId :: Lens' TxMintRow PolicyId
txMintRowBlockHeaderHash :: Lens' TxMintRow (Hash BlockHeader)
txMintRowAssetName :: Lens' TxMintRow AssetName
sqliteInit :: Connection -> IO ()
sqliteInsert :: Connection -> [TxMintEvent] -> IO ()
toRows :: TxMintEvent -> [TxMintRow]

-- | Input rows must be sorted by C.SlotNo.
fromRows :: [TxMintRow] -> [TxMintEvent]
queryStoredTxMintEvents :: Connection -> ([Query], [NamedParam]) -> IO [TxMintEvent]
intervalToWhereClause :: QueryInterval ChainPoint -> ([Query], [NamedParam])
groupBySlotAndHash :: [TxMintEvent] -> [TxMintEvent]
data MintBurnHandle
MintBurnHandle :: !Connection -> !SecurityParam -> MintBurnHandle
[sqlConnection] :: MintBurnHandle -> !Connection
[securityParam] :: MintBurnHandle -> !SecurityParam
type MintBurnIndexer = State MintBurnHandle
open :: FilePath -> SecurityParam -> IO MintBurnIndexer
instance GHC.Show.Show (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.MintBurn.MintBurnHandle)
instance GHC.Show.Show (Marconi.Core.Storable.StorableQuery Marconi.ChainIndex.Indexers.MintBurn.MintBurnHandle)
instance GHC.Show.Show (Marconi.Core.Storable.StorableResult Marconi.ChainIndex.Indexers.MintBurn.MintBurnHandle)
instance Marconi.Core.Storable.Queryable Marconi.ChainIndex.Indexers.MintBurn.MintBurnHandle
instance Marconi.Core.Storable.HasPoint (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.MintBurn.MintBurnHandle) Cardano.Api.Block.ChainPoint
instance Marconi.Core.Storable.Buffered Marconi.ChainIndex.Indexers.MintBurn.MintBurnHandle
instance Marconi.Core.Storable.Resumable Marconi.ChainIndex.Indexers.MintBurn.MintBurnHandle
instance Marconi.Core.Storable.Rewindable Marconi.ChainIndex.Indexers.MintBurn.MintBurnHandle
instance Data.Aeson.Types.FromJSON.FromJSON Marconi.ChainIndex.Indexers.MintBurn.TxMintRow
instance Data.Aeson.Types.ToJSON.ToJSON Marconi.ChainIndex.Indexers.MintBurn.TxMintRow
instance GHC.Classes.Ord Marconi.ChainIndex.Indexers.MintBurn.MintAsset
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.MintBurn.MintAsset
instance GHC.Show.Show Marconi.ChainIndex.Indexers.MintBurn.MintAsset
instance GHC.Classes.Ord Marconi.ChainIndex.Indexers.MintBurn.TxMintEvent
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.MintBurn.TxMintEvent
instance GHC.Show.Show Marconi.ChainIndex.Indexers.MintBurn.TxMintEvent
instance Database.SQLite.Simple.ToRow.ToRow Marconi.ChainIndex.Indexers.MintBurn.TxMintRow
instance Database.SQLite.Simple.FromRow.FromRow Marconi.ChainIndex.Indexers.MintBurn.TxMintRow
instance GHC.Generics.Generic Marconi.ChainIndex.Indexers.MintBurn.TxMintRow
instance GHC.Show.Show Marconi.ChainIndex.Indexers.MintBurn.TxMintRow
instance GHC.Classes.Ord Marconi.ChainIndex.Indexers.MintBurn.TxMintRow
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.MintBurn.TxMintRow

module Marconi.ChainIndex.CLI
chainPointParser :: Parser ChainPoint

-- | Exit program with error Note, if the targetAddress parser fails, or is
--   empty, there is nothing to do for the hotStore. In such case we should
--   fail fast
fromJustWithError :: Show e => Either e a -> a
pNetworkId :: Parser NetworkId
pMainnet :: Parser NetworkId
pTestnetMagic :: Parser NetworkMagic

-- | parses CLI params to valid NonEmpty list of Shelley addresses We error
--   out if there are any invalid addresses
multiString :: Mod OptionFields [Address ShelleyAddr] -> Parser TargetAddresses
parseCardanoAddresses :: String -> [Address ShelleyAddr]

-- | This executable is meant to exercise a set of indexers (for now
--   datumhash -&gt; datum) against the mainnet (meant to be used for
--   testing).
--   
--   In case you want to access the results of the datumhash indexer you
--   need to query the resulting database: $ sqlite3 datums.sqlite &gt;
--   select slotNo, datumHash, datum from kv_datumhsh_datum where slotNo =
--   39920450;
--   39920450|679a55b523ff8d61942b2583b76e5d49498468164802ef1ebe513c685d6fb5c2|X(002f9787436835852ea78d3c45fc3d436b324184
data Options
Options :: !String -> !NetworkId -> !ChainPoint -> !FilePath -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Maybe TargetAddresses -> !Maybe FilePath -> Options
[optionsSocketPath] :: Options -> !String
[optionsNetworkId] :: Options -> !NetworkId
[optionsChainPoint] :: Options -> !ChainPoint

-- | SQLite database directory path
[optionsDbPath] :: Options -> !FilePath
[optionsDisableUtxo] :: Options -> !Bool
[optionsDisableAddressDatum] :: Options -> !Bool
[optionsDisableDatum] :: Options -> !Bool
[optionsDisableScript] :: Options -> !Bool
[optionsDisableEpochState] :: Options -> !Bool
[optionsDisableMintBurn] :: Options -> !Bool
[optionsTargetAddresses] :: Options -> !Maybe TargetAddresses
[optionsNodeConfigPath] :: Options -> !Maybe FilePath
parseOptions :: IO Options
programParser :: String -> ParserInfo Options
optionsParser :: Parser Options
optAddressesParser :: Mod OptionFields [Address ShelleyAddr] -> Parser (Maybe TargetAddresses)
utxoDbPath :: Options -> Maybe FilePath
addressDatumDbPath :: Options -> Maybe FilePath
datumDbPath :: Options -> Maybe FilePath
scriptTxDbPath :: Options -> Maybe FilePath
epochStateDbPath :: Options -> Maybe FilePath
mintBurnDbPath :: Options -> Maybe FilePath
commonSocketPath :: Parser String
commonDbDir :: Parser String
commonVersionOption :: String -> Parser (a -> a)
getGitSha :: IO String
marconiDescr :: String -> InfoMod a
commonMaybePort :: Parser (Maybe Int)
commonMaybeTargetAddress :: Parser (Maybe TargetAddresses)
instance GHC.Show.Show Marconi.ChainIndex.CLI.Options

module Marconi.ChainIndex.Utils
isBlockRollbackable :: SecurityParam -> BlockNo -> ChainTip -> Bool

-- | Query security param from node
querySecurityParam :: NetworkId -> FilePath -> IO SecurityParam


-- | Module for indexing the stakepool delegation per epoch in the Cardano
--   blockchain.
--   
--   This module will create the SQL tables:
--   
--   + table: epoch_sdd
--   
--   <pre>
--   |---------+--------+----------+--------+-----------------+---------|
--   | epochNo | poolId | lovelace | slotNo | blockHeaderHash | blockNo |
--   |---------+--------+----------+--------+-----------------+---------|
--   </pre>
--   
--   + table: epoch_nonce
--   
--   <pre>
--   |---------+-------+--------+-----------------+---------|
--   | epochNo | nonce | slotNo | blockHeaderHash | blockNo |
--   |---------+-------+--------+-----------------+---------|
--   </pre>
--   
--   To create those tables, we need to compute the <tt>ExtLedgerState</tt>
--   from `ouroboros-network` (combination of `LedgerState, called
--   <tt>NewEpochState</tt> in `cardano-ledger`, and the
--   <tt>HeaderState</tt>) at each <tt>Rollforward</tt> chain sync event.
--   Using the <tt>ExtLegderState</tt>, we can easily compute the epoch
--   nonce as well as the stake pool delegation for that epoch.
--   
--   The main issue with this indexer is that building the ExtLedgerState
--   and saving it on disk for being able to resume is VERY resource
--   intensive. Syncing time for this indexer is over 20h and uses about
--   ~16GB of RAM (which will keep increasing as the blockchain continues
--   to grow).
--   
--   Here is a synopsis of what this indexer does.
--   
--   We assume that the construction of <tt>LedgerState</tt> is done
--   outside of this indexer (this module).
--   
--   <ul>
--   <li>the <a>insert</a> function is called with the *last* event of an
--   epoch (therefore, the last <tt>LedgerState</tt> before starting a new
--   epoch). We do that because we only care about the SDD (Stake Pool
--   Delegation) from the last block before a new epoch.</li>
--   </ul>
--   
--   Once the <a>StorableEvent</a> is stored on disk, we perform various
--   steps:
--   
--   <ol>
--   <li>we save the SDD for the current epoch in the <tt>epoch_sdd</tt>
--   table</li>
--   <li>we save the <tt>LedgerState</tt>s in the filesystem as binary
--   files (the ledger state file path has the format:
--   `ledgerState_<a>SLOT_NO</a>_<a>BLOCK_HEADER_HASH</a>_<a>BLOCK_NO</a>.bin`).
--   We only store a <tt>LedgerState</tt> if it's rollbackable or if the
--   last one of a given epoch. This step is necessary for resuming the
--   indexer.</li>
--   <li>we delete immutable <tt>LedgerState</tt> binary files expect
--   latest one (this step is necessary for</li>
--   </ol>
--   
--   The indexer provides the following queries:
--   
--   <ul>
--   <li>C.EpochNo -&gt; SDD (the actualy query that clients will be
--   interested in)</li>
--   <li>C.ChainPoint -&gt; LedgerState (query that is necessary for
--   resuming)</li>
--   </ul>
module Marconi.ChainIndex.Indexers.EpochState
type EpochStateIndex = State EpochStateHandle
data EpochStateHandle
data EpochSDDRow
EpochSDDRow :: !EpochNo -> !PoolId -> !Lovelace -> !SlotNo -> !Hash BlockHeader -> !BlockNo -> EpochSDDRow
[epochSDDRowEpochNo] :: EpochSDDRow -> !EpochNo
[epochSDDRowPoolId] :: EpochSDDRow -> !PoolId
[epochSDDRowLovelace] :: EpochSDDRow -> !Lovelace
[epochSDDRowSlotNo] :: EpochSDDRow -> !SlotNo
[epochSDDRowBlockHeaderHash] :: EpochSDDRow -> !Hash BlockHeader
[epochSDDRowBlockNo] :: EpochSDDRow -> !BlockNo
data EpochNonceRow
EpochNonceRow :: !EpochNo -> !Nonce -> !SlotNo -> !Hash BlockHeader -> !BlockNo -> EpochNonceRow
[epochNonceRowEpochNo] :: EpochNonceRow -> !EpochNo
[epochNonceRowNonce] :: EpochNonceRow -> !Nonce
[epochNonceRowSlotNo] :: EpochNonceRow -> !SlotNo
[epochNonceRowBlockHeaderHash] :: EpochNonceRow -> !Hash BlockHeader
[epochNonceRowBlockNo] :: EpochNonceRow -> !BlockNo
data family StorableEvent h
data family StorableQuery h
data family StorableResult h
toStorableEvent :: ExtLedgerState (HardForkBlock (CardanoEras StandardCrypto)) -> SlotNo -> Hash BlockHeader -> BlockNo -> ChainTip -> SecurityParam -> Bool -> StorableEvent EpochStateHandle
open :: TopLevelConfig (CardanoBlock StandardCrypto) -> FilePath -> FilePath -> SecurityParam -> IO (State EpochStateHandle)
getEpochNo :: ExtLedgerState (CardanoBlock StandardCrypto) -> Maybe EpochNo
instance GHC.Show.Show (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.EpochState.EpochStateHandle)
instance GHC.Classes.Eq (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.EpochState.EpochStateHandle)
instance Database.SQLite.Simple.ToRow.ToRow Marconi.ChainIndex.Indexers.EpochState.EpochSDDRow
instance Database.SQLite.Simple.FromRow.FromRow Marconi.ChainIndex.Indexers.EpochState.EpochSDDRow
instance GHC.Generics.Generic Marconi.ChainIndex.Indexers.EpochState.EpochSDDRow
instance GHC.Show.Show Marconi.ChainIndex.Indexers.EpochState.EpochSDDRow
instance GHC.Classes.Ord Marconi.ChainIndex.Indexers.EpochState.EpochSDDRow
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.EpochState.EpochSDDRow
instance Database.SQLite.Simple.ToRow.ToRow Marconi.ChainIndex.Indexers.EpochState.EpochNonceRow
instance Database.SQLite.Simple.FromRow.FromRow Marconi.ChainIndex.Indexers.EpochState.EpochNonceRow
instance GHC.Generics.Generic Marconi.ChainIndex.Indexers.EpochState.EpochNonceRow
instance GHC.Show.Show Marconi.ChainIndex.Indexers.EpochState.EpochNonceRow
instance GHC.Classes.Ord Marconi.ChainIndex.Indexers.EpochState.EpochNonceRow
instance GHC.Classes.Eq Marconi.ChainIndex.Indexers.EpochState.EpochNonceRow
instance GHC.Show.Show (Marconi.Core.Storable.StorableResult Marconi.ChainIndex.Indexers.EpochState.EpochStateHandle)
instance GHC.Classes.Eq (Marconi.Core.Storable.StorableResult Marconi.ChainIndex.Indexers.EpochState.EpochStateHandle)
instance Data.Aeson.Types.FromJSON.FromJSON Marconi.ChainIndex.Indexers.EpochState.EpochNonceRow
instance Data.Aeson.Types.ToJSON.ToJSON Marconi.ChainIndex.Indexers.EpochState.EpochNonceRow
instance Marconi.Core.Storable.Queryable Marconi.ChainIndex.Indexers.EpochState.EpochStateHandle
instance Data.Aeson.Types.FromJSON.FromJSON Marconi.ChainIndex.Indexers.EpochState.EpochSDDRow
instance Data.Aeson.Types.ToJSON.ToJSON Marconi.ChainIndex.Indexers.EpochState.EpochSDDRow
instance Marconi.Core.Storable.HasPoint (Marconi.Core.Storable.StorableEvent Marconi.ChainIndex.Indexers.EpochState.EpochStateHandle) Cardano.Api.Block.ChainPoint
instance Marconi.Core.Storable.Buffered Marconi.ChainIndex.Indexers.EpochState.EpochStateHandle
instance Marconi.Core.Storable.Rewindable Marconi.ChainIndex.Indexers.EpochState.EpochStateHandle
instance Marconi.Core.Storable.Resumable Marconi.ChainIndex.Indexers.EpochState.EpochStateHandle

module Marconi.ChainIndex.Indexers
getDatums :: BlockInMode CardanoMode -> [(SlotNo, (Hash ScriptData, ScriptData))]
scriptDataFromCardanoTxBody :: TxBody era -> Map (Hash ScriptData) ScriptData

-- | The way we synchronise channel consumption is by waiting on a QSemN
--   for each of the spawn indexers to finish processing the current event.
--   
--   The channel is used to transmit the next event to the listening
--   indexers. Note that even if the channel is unbound it will actually
--   only ever hold one event because it will be blocked until the
--   processing of the event finishes on all indexers.
--   
--   The indexer count is where we save the number of running indexers so
--   we know for how many we are waiting.
data Coordinator
Coordinator :: !TChan (ChainSyncEvent (BlockInMode CardanoMode)) -> !QSemN -> !Int -> Coordinator
[_channel] :: Coordinator -> !TChan (ChainSyncEvent (BlockInMode CardanoMode))
[_barrier] :: Coordinator -> !QSemN
[_indexerCount] :: Coordinator -> !Int
initialCoordinator :: Int -> IO Coordinator
type Worker = SecurityParam -> Coordinator -> FilePath -> IO [StorablePoint ScriptTxHandle]
datumWorker :: Worker
utxoWorker_ :: (UtxoIndexer -> IO ()) -> Depth -> Maybe TargetAddresses -> Coordinator -> TChan (ChainSyncEvent (BlockInMode CardanoMode)) -> FilePath -> IO (IO (), MVar UtxoIndexer)
utxoWorker :: (UtxoIndexer -> IO ()) -> Maybe TargetAddresses -> Worker
addressDatumWorker :: (StorableEvent AddressDatumHandle -> IO [()]) -> Maybe TargetAddresses -> Worker
addressDatumWorker_ :: (StorableEvent AddressDatumHandle -> IO [()]) -> Maybe TargetAddresses -> AddressDatumDepth -> Coordinator -> TChan (ChainSyncEvent (BlockInMode CardanoMode)) -> FilePath -> IO (IO (), MVar AddressDatumIndex)
scriptTxWorker_ :: (StorableEvent ScriptTxHandle -> IO [()]) -> Depth -> Coordinator -> TChan (ChainSyncEvent (BlockInMode CardanoMode)) -> FilePath -> IO (IO (), MVar ScriptTxIndexer)
scriptTxWorker :: (StorableEvent ScriptTxHandle -> IO [()]) -> Worker
epochStateWorker_ :: FilePath -> ((State EpochStateHandle, StorableEvent EpochStateHandle) -> IO ()) -> SecurityParam -> Coordinator -> TChan (ChainSyncEvent (BlockInMode CardanoMode)) -> FilePath -> IO (IO b, MVar EpochStateIndex)
epochStateWorker :: FilePath -> ((State EpochStateHandle, StorableEvent EpochStateHandle) -> IO ()) -> Worker
mintBurnWorker_ :: SecurityParam -> (TxMintEvent -> IO ()) -> Coordinator -> TChan (ChainSyncEvent (BlockInMode CardanoMode)) -> FilePath -> IO (IO b, MVar MintBurnIndexer)
mintBurnWorker :: (TxMintEvent -> IO ()) -> Worker
initializeIndexers :: SecurityParam -> [(Worker, FilePath)] -> IO ([ChainPoint], Coordinator)
mkIndexerStream :: Coordinator -> Stream (Of (ChainSyncEvent (BlockInMode CardanoMode))) IO r -> IO ()
runIndexers :: FilePath -> NetworkId -> ChainPoint -> Text -> [(Worker, Maybe FilePath)] -> IO ()
