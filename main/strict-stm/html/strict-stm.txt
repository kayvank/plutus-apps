-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Strict STM interface polymorphic over stm implementation.
--   
--   The `strict-stm` package gives a strict interface to stm, currently
--   either one provided by <a>stm</a> package for the <a>IO</a> monad or
--   `io-sim` package for the <a>IOSim</a> monad.
@package strict-stm
@version 0.1.0.0

module Control.Monad.Class.MonadSTM.Strict

-- | <a>catch</a> specialized for an <tt>stm</tt> monad.
catchSTM :: forall (m :: Type -> Type) e a. (MonadSTM m, MonadCatch (STM m), Exception e) => STM m a -> (e -> STM m a) -> STM m a

-- | <a>throwIO</a> specialised to <tt>stm</tt> monad.
throwSTM :: forall (m :: Type -> Type) e a. (MonadSTM m, MonadThrow (STM m), Exception e) => e -> STM m a
flushTBQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TBQueueDefault m a -> STM m [a]
lengthTBQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TBQueueDefault m a -> STM m Natural
isFullTBQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TBQueueDefault m a -> STM m Bool
isEmptyTBQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TBQueueDefault m a -> STM m Bool
writeTBQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TBQueueDefault m a -> a -> STM m ()
tryPeekTBQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TBQueueDefault m a -> STM m (Maybe a)
peekTBQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TBQueueDefault m a -> STM m a
tryReadTBQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TBQueueDefault m a -> STM m (Maybe a)
readTBQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TBQueueDefault m a -> STM m a
newTBQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => Natural -> STM m (TBQueueDefault m a)
labelTBQueueDefault :: forall (m :: Type -> Type) a. MonadLabelledSTM m => TBQueueDefault m a -> String -> STM m ()
tryPeekTQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TQueueDefault m a -> STM m (Maybe a)
peekTQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TQueueDefault m a -> STM m a
isEmptyTQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TQueueDefault m a -> STM m Bool
tryReadTQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TQueueDefault m a -> STM m (Maybe a)
readTQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TQueueDefault m a -> STM m a
writeTQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => TQueueDefault m a -> a -> STM m ()
newTQueueDefault :: forall (m :: Type -> Type) a. MonadSTM m => STM m (TQueueDefault m a)
labelTQueueDefault :: forall (m :: Type -> Type) a. MonadLabelledSTM m => TQueueDefault m a -> String -> STM m ()
isEmptyTMVarDefault :: forall (m :: Type -> Type) a. MonadSTM m => TMVarDefault m a -> STM m Bool
swapTMVarDefault :: forall (m :: Type -> Type) a. MonadSTM m => TMVarDefault m a -> a -> STM m a
tryReadTMVarDefault :: forall (m :: Type -> Type) a. MonadSTM m => TMVarDefault m a -> STM m (Maybe a)
readTMVarDefault :: forall (m :: Type -> Type) a. MonadSTM m => TMVarDefault m a -> STM m a
tryPutTMVarDefault :: forall (m :: Type -> Type) a. MonadSTM m => TMVarDefault m a -> a -> STM m Bool
putTMVarDefault :: forall (m :: Type -> Type) a. MonadSTM m => TMVarDefault m a -> a -> STM m ()
tryTakeTMVarDefault :: forall (m :: Type -> Type) a. MonadSTM m => TMVarDefault m a -> STM m (Maybe a)
takeTMVarDefault :: forall (m :: Type -> Type) a. MonadSTM m => TMVarDefault m a -> STM m a
newEmptyTMVarMDefault :: MonadSTM m => m (TMVarDefault m a)
newEmptyTMVarIODefault :: MonadSTM m => m (TMVarDefault m a)
newEmptyTMVarDefault :: forall (m :: Type -> Type) a. MonadSTM m => STM m (TMVarDefault m a)
newTMVarMDefault :: MonadSTM m => a -> m (TMVarDefault m a)
newTMVarIODefault :: MonadSTM m => a -> m (TMVarDefault m a)
newTMVarDefault :: forall (m :: Type -> Type) a. MonadSTM m => a -> STM m (TMVarDefault m a)
traceTMVarDefault :: forall (m :: Type -> Type) proxy a. MonadTraceSTM m => proxy m -> TMVarDefault m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
labelTMVarDefault :: forall (m :: Type -> Type) a. MonadLabelledSTM m => TMVarDefault m a -> String -> STM m ()
type family TBQueue (m :: Type -> Type) :: Type -> Type
type family TQueue (m :: Type -> Type) :: Type -> Type
type family STM (m :: Type -> Type) = (stm :: Type -> Type) | stm -> m
class (Monad m, Alternative STM m, MonadPlus STM m) => MonadSTM (m :: Type -> Type) where {
    type family STM (m :: Type -> Type) = (stm :: Type -> Type) | stm -> m;
    type family TQueue (m :: Type -> Type) :: Type -> Type;
    type family TBQueue (m :: Type -> Type) :: Type -> Type;
}
atomically :: (MonadSTM m, HasCallStack) => STM m a -> m a
retry :: MonadSTM m => STM m a
orElse :: MonadSTM m => STM m a -> STM m a -> STM m a
modifyTVar' :: MonadSTM m => TVar m a -> (a -> a) -> STM m ()
check :: MonadSTM m => Bool -> STM m ()
newTQueue :: MonadSTM m => STM m (TQueue m a)
readTQueue :: MonadSTM m => TQueue m a -> STM m a
tryReadTQueue :: MonadSTM m => TQueue m a -> STM m (Maybe a)
peekTQueue :: MonadSTM m => TQueue m a -> STM m a
tryPeekTQueue :: MonadSTM m => TQueue m a -> STM m (Maybe a)
writeTQueue :: MonadSTM m => TQueue m a -> a -> STM m ()
isEmptyTQueue :: MonadSTM m => TQueue m a -> STM m Bool
newTBQueue :: MonadSTM m => Natural -> STM m (TBQueue m a)
readTBQueue :: MonadSTM m => TBQueue m a -> STM m a
tryReadTBQueue :: MonadSTM m => TBQueue m a -> STM m (Maybe a)
peekTBQueue :: MonadSTM m => TBQueue m a -> STM m a
tryPeekTBQueue :: MonadSTM m => TBQueue m a -> STM m (Maybe a)
flushTBQueue :: MonadSTM m => TBQueue m a -> STM m [a]
writeTBQueue :: MonadSTM m => TBQueue m a -> a -> STM m ()

lengthTBQueue :: MonadSTM m => TBQueue m a -> STM m Natural
isEmptyTBQueue :: MonadSTM m => TBQueue m a -> STM m Bool
isFullTBQueue :: MonadSTM m => TBQueue m a -> STM m Bool
newTQueueIO :: MonadSTM m => m (TQueue m a)
newTBQueueIO :: MonadSTM m => Natural -> m (TBQueue m a)

-- | Labelled <a>TVar</a>s, <a>TMVar</a>s, <a>TQueue</a>s and
--   <a>TBQueue</a>s.
class MonadSTM m => MonadLabelledSTM (m :: Type -> Type)
labelTQueue :: MonadLabelledSTM m => TQueue m a -> String -> STM m ()
labelTBQueue :: MonadLabelledSTM m => TBQueue m a -> String -> STM m ()
labelTQueueIO :: MonadLabelledSTM m => TQueue m a -> String -> m ()
labelTBQueueIO :: MonadLabelledSTM m => TBQueue m a -> String -> m ()
type family InspectMonad (m :: Type -> Type) :: Type -> Type

-- | This type class is indented for 'io-sim', where one might want to
--   access <a>TVar</a> in the underlying <tt>ST</tt> monad.
class (MonadSTM m, Monad InspectMonad m) => MonadInspectSTM (m :: Type -> Type) where {
    type family InspectMonad (m :: Type -> Type) :: Type -> Type;
}
inspectTVar :: MonadInspectSTM m => proxy m -> TVar m a -> InspectMonad m a
inspectTMVar :: MonadInspectSTM m => proxy m -> TMVar m a -> InspectMonad m (Maybe a)

-- | A GADT which instructs how to trace the value. The <a>traceDynamic</a>
--   will use dynamic tracing, e.g. <a>traceM</a>; while <a>traceString</a>
--   will be traced with <tt>EventSay</tt>.
data TraceValue
[TraceValue] :: forall tr. Typeable tr => {traceDynamic :: Maybe tr, traceString :: Maybe String} -> TraceValue

-- | Use only dynamic tracer.
pattern TraceDynamic :: () => Typeable tr => tr -> TraceValue

-- | Use only string tracing.
pattern TraceString :: String -> TraceValue

-- | Do not trace the value.
pattern DontTrace :: TraceValue

-- | <a>MonadTraceSTM</a> allows to trace values of stm variables when stm
--   transaction is committed. This allows to verify invariants when a
--   variable is committed.
class MonadInspectSTM m => MonadTraceSTM (m :: Type -> Type)
traceTQueue :: MonadTraceSTM m => proxy m -> TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTBQueue :: MonadTraceSTM m => proxy m -> TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> STM m ()
traceTQueueIO :: MonadTraceSTM m => proxy m -> TQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
traceTBQueueIO :: MonadTraceSTM m => proxy m -> TBQueue m a -> (Maybe [a] -> [a] -> InspectMonad m TraceValue) -> m ()
data TMVarDefault (m :: Type -> Type) a
data TQueueDefault (m :: Type -> Type) a
TQueue :: !TVar m [a] -> !TVar m [a] -> TQueueDefault (m :: Type -> Type) a
data TBQueueDefault (m :: Type -> Type) a
TBQueue :: !TVar m Natural -> !TVar m [a] -> !TVar m Natural -> !TVar m [a] -> !Natural -> TBQueueDefault (m :: Type -> Type) a

-- | A newtype wrapper for an <a>STM</a> monad for monad transformers.
newtype WrappedSTM (t :: Trans) r (m :: Type -> Type) a
WrappedSTM :: STM m a -> WrappedSTM (t :: Trans) r (m :: Type -> Type) a
[runWrappedSTM] :: WrappedSTM (t :: Trans) r (m :: Type -> Type) a -> STM m a
type LazyTVar m = TVar m
type LazyTMVar m = TMVar m
data StrictTVar m a
labelTVar :: MonadLabelledSTM m => StrictTVar m a -> String -> STM m ()
labelTVarIO :: MonadLabelledSTM m => StrictTVar m a -> String -> m ()
traceTVar :: MonadTraceSTM m => proxy m -> StrictTVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> STM m ()
traceTVarIO :: MonadTraceSTM m => proxy m -> StrictTVar m a -> (Maybe a -> a -> InspectMonad m TraceValue) -> m ()
castStrictTVar :: LazyTVar m ~ LazyTVar n => StrictTVar m a -> StrictTVar n a

-- | Get the underlying <tt>TVar</tt>
--   
--   Since we obviously cannot guarantee that updates to this
--   <a>LazyTVar</a> will be strict, this should be used with caution.
toLazyTVar :: StrictTVar m a -> LazyTVar m a
fromLazyTVar :: LazyTVar m a -> StrictTVar m a
newTVar :: MonadSTM m => a -> STM m (StrictTVar m a)
newTVarIO :: MonadSTM m => a -> m (StrictTVar m a)
newTVarWithInvariant :: (MonadSTM m, HasCallStack) => (a -> Maybe String) -> a -> STM m (StrictTVar m a)
newTVarWithInvariantIO :: (MonadSTM m, HasCallStack) => (a -> Maybe String) -> a -> m (StrictTVar m a)
readTVar :: MonadSTM m => StrictTVar m a -> STM m a
readTVarIO :: MonadSTM m => StrictTVar m a -> m a
writeTVar :: (MonadSTM m, HasCallStack) => StrictTVar m a -> a -> STM m ()
modifyTVar :: MonadSTM m => StrictTVar m a -> (a -> a) -> STM m ()
stateTVar :: MonadSTM m => StrictTVar m s -> (s -> (a, s)) -> STM m a
swapTVar :: MonadSTM m => StrictTVar m a -> a -> STM m a
data StrictTMVar m a
labelTMVar :: MonadLabelledSTM m => StrictTMVar m a -> String -> STM m ()
labelTMVarIO :: MonadLabelledSTM m => StrictTMVar m a -> String -> m ()
traceTMVar :: MonadTraceSTM m => proxy m -> StrictTMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> STM m ()
traceTMVarIO :: MonadTraceSTM m => proxy m -> StrictTMVar m a -> (Maybe (Maybe a) -> Maybe a -> InspectMonad m TraceValue) -> m ()
castStrictTMVar :: LazyTMVar m ~ LazyTMVar n => StrictTMVar m a -> StrictTMVar n a
($sel:toLazyTMVar:StrictTMVar) :: StrictTMVar m a -> LazyTMVar m a
fromLazyTMVar :: LazyTMVar m a -> StrictTMVar m a
newTMVar :: MonadSTM m => a -> STM m (StrictTMVar m a)
newTMVarIO :: MonadSTM m => a -> m (StrictTMVar m a)
newEmptyTMVar :: MonadSTM m => STM m (StrictTMVar m a)
newEmptyTMVarIO :: MonadSTM m => m (StrictTMVar m a)
takeTMVar :: MonadSTM m => StrictTMVar m a -> STM m a
tryTakeTMVar :: MonadSTM m => StrictTMVar m a -> STM m (Maybe a)
putTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m ()
tryPutTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m Bool
readTMVar :: MonadSTM m => StrictTMVar m a -> STM m a
tryReadTMVar :: MonadSTM m => StrictTMVar m a -> STM m (Maybe a)
swapTMVar :: MonadSTM m => StrictTMVar m a -> a -> STM m a
isEmptyTMVar :: MonadSTM m => StrictTMVar m a -> STM m Bool

-- | Check invariant (if enabled) before continuing
--   
--   <tt>checkInvariant mErr x</tt> is equal to <tt>x</tt> if <tt>mErr ==
--   Nothing</tt>, and throws an error <tt>err</tt> if <tt>mErr == Just
--   err</tt>.
--   
--   This is exported so that other code that wants to conditionally check
--   invariants can reuse the same logic, rather than having to introduce
--   new per-package flags.
checkInvariant :: HasCallStack => Maybe String -> a -> a

-- | <i>Deprecated: Use stateTVar</i>
updateTVar :: MonadSTM m => StrictTVar m s -> (s -> (a, s)) -> STM m a

-- | <i>Deprecated: Use newTVarIO</i>
newTVarM :: MonadSTM m => a -> m (StrictTVar m a)

-- | <i>Deprecated: Use newTVarWithInvariantIO</i>
newTVarWithInvariantM :: (MonadSTM m, HasCallStack) => (a -> Maybe String) -> a -> m (StrictTVar m a)

-- | <i>Deprecated: Use newTVarIO</i>
newTMVarM :: MonadSTM m => a -> m (StrictTMVar m a)

-- | <i>Deprecated: Use newEmptyTMVarIO</i>
newEmptyTMVarM :: MonadSTM m => m (StrictTMVar m a)
