-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Executable specification of the Cardano blockchain
--   
--   Executable specification of the Cardano blockchain
@package byron-spec-chain
@version 0.1.0.0

module Byron.Spec.Chain.STS.Block
data BlockHeader
BlockHeader :: !Hash -> !Slot -> !VKey -> !Sig Hash -> !Hash -> !Hash -> !Hash -> BlockHeader

-- | Hash of the previous block header, or <a>genesisHash</a> in case of
--   the first block in a chain.
[_bhPrevHash] :: BlockHeader -> !Hash

-- | Absolute slot for which the block was generated.
[_bhSlot] :: BlockHeader -> !Slot

-- | Block issuer.
[_bhIssuer] :: BlockHeader -> !VKey

-- | Part of the block header which must be signed.
[_bhSig] :: BlockHeader -> !Sig Hash

-- | UTxO hash
[_bhUtxoHash] :: BlockHeader -> !Hash

-- | Delegation hash
[_bhDlgHash] :: BlockHeader -> !Hash

-- | Update payload hash
[_bhUpdHash] :: BlockHeader -> !Hash
bhUtxoHash :: Lens' BlockHeader Hash
bhUpdHash :: Lens' BlockHeader Hash
bhSlot :: Lens' BlockHeader Slot
bhSig :: Lens' BlockHeader (Sig Hash)
bhPrevHash :: Lens' BlockHeader Hash
bhIssuer :: Lens' BlockHeader VKey
bhDlgHash :: Lens' BlockHeader Hash
data BlockBody
BlockBody :: ![DCert] -> ![Tx] -> !Maybe UProp -> ![Vote] -> !ProtVer -> BlockBody

-- | Delegation certificates
[_bDCerts] :: BlockBody -> ![DCert]

-- | UTxO payload
[_bUtxo] :: BlockBody -> ![Tx]

-- | Update proposal payload
[_bUpdProp] :: BlockBody -> !Maybe UProp

-- | Update votes payload
[_bUpdVotes] :: BlockBody -> ![Vote]

-- | Protocol version
[_bProtVer] :: BlockBody -> !ProtVer
bUtxo :: Lens' BlockBody [Tx]
bUpdVotes :: Lens' BlockBody [Vote]
bUpdProp :: Lens' BlockBody (Maybe UProp)
bProtVer :: Lens' BlockBody ProtVer
bDCerts :: Lens' BlockBody [DCert]

-- | A block in the chain. The specification only models regular blocks
--   since epoch boundary blocks will be largely ignored in the
--   Byron-Shelley bridge.
data Block
Block :: BlockHeader -> BlockBody -> Block
[_bHeader] :: Block -> BlockHeader
[_bBody] :: Block -> BlockBody
bHeader :: Lens' Block BlockHeader
bBody :: Lens' Block BlockBody
mkBlock :: Hash -> Slot -> VKey -> ProtVer -> [DCert] -> Maybe UProp -> [Vote] -> [Tx] -> Block

-- | Dummy genesis hash.
genesisHash :: Hash

-- | Protocol version endorsment
bEndorsment :: Block -> (ProtVer, VKey)

-- | Slot the block is published in
bSlot :: Block -> Slot

-- | Block update payload
bUpdPayload :: Block -> (Maybe UProp, [Vote])

-- | Compute the abstract size (in words) that a block takes.
bSize :: Block -> Natural

-- | Compute the abstract size (in words) that a block body occupies.
bBodySize :: BlockBody -> Natural

-- | Compute the abstract size (in words) that a block header occupies.
bHeaderSize :: BlockHeader -> Natural

-- | Computes the hash of a header.
hashHeader :: BlockHeader -> Hash

-- | Computes the hash of the header.
bhToSign :: BlockHeader -> Hash
bhHash :: BlockHeader -> Hash

-- | Checks if a block is an epoch boundary block.
--   
--   The function always returns False because tests will be performed only
--   against chains without EBBs.
bIsEBB :: Block -> Bool

-- | Update a field of the block body, recomputing the hashes to get a
--   valid block.
updateBody :: Block -> (BlockBody -> BlockBody) -> Block
data BlockStats
BlockStats :: Word -> Word -> Word -> Word -> BlockStats

-- | Number of regular transactions
[blockStatsUtxo] :: BlockStats -> Word

-- | Number of delegation certificates
[blockStatsDCerts] :: BlockStats -> Word

-- | Number of update votes
[blockStatsUpdVotes] :: BlockStats -> Word

-- | Number of update proposals
--   
--   For a single block this will be 0 or 1.
[blockStatsUpdProp] :: BlockStats -> Word

-- | Count number of transactions in the block
--   
--   Returns the number of
--   
--   <ul>
--   <li>Regular transactions</li>
--   <li>Delegation certificates</li>
--   <li>Update votes</li>
--   <li>Update proposals (0 or 1)</li>
--   </ul>
blockStats :: Block -> BlockStats

-- | Block stats for an entire chain
--   
--   Computes minimum, maximum, and average values.
--   
--   Returns <a>Nothing</a> for the empty chain.
chainBlockStats :: [BlockStats] -> Maybe (BlockStats, BlockStats, BlockStats)
instance Test.Goblin.Core.AddShrinks Byron.Spec.Chain.STS.Block.BlockHeader
instance Test.Goblin.Core.AddShrinks Byron.Spec.Chain.STS.Block.BlockBody
instance Test.Goblin.Core.AddShrinks Byron.Spec.Chain.STS.Block.Block
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Chain.STS.Block.BlockHeader
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Chain.STS.Block.BlockBody
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Chain.STS.Block.Block
instance GHC.Show.Show Byron.Spec.Chain.STS.Block.BlockStats
instance Data.AbstractSize.HasTypeReps Byron.Spec.Chain.STS.Block.Block
instance Control.State.Transition.Generator.HasSizeInfo Byron.Spec.Chain.STS.Block.Block
instance Data.Data.Data Byron.Spec.Chain.STS.Block.Block
instance GHC.Show.Show Byron.Spec.Chain.STS.Block.Block
instance GHC.Generics.Generic Byron.Spec.Chain.STS.Block.Block
instance Data.AbstractSize.HasTypeReps Byron.Spec.Chain.STS.Block.BlockBody
instance Data.Data.Data Byron.Spec.Chain.STS.Block.BlockBody
instance GHC.Show.Show Byron.Spec.Chain.STS.Block.BlockBody
instance GHC.Generics.Generic Byron.Spec.Chain.STS.Block.BlockBody
instance Data.AbstractSize.HasTypeReps Byron.Spec.Chain.STS.Block.BlockHeader
instance Data.Data.Data Byron.Spec.Chain.STS.Block.BlockHeader
instance GHC.Show.Show Byron.Spec.Chain.STS.Block.BlockHeader
instance GHC.Generics.Generic Byron.Spec.Chain.STS.Block.BlockHeader
instance GHC.Classes.Eq Byron.Spec.Chain.STS.Block.BlockHeader

module Byron.Spec.Chain.STS.Rule.Bupi
type UpdatePayload = (Maybe UProp, [Vote], (ProtVer, VKey))
data BUPI
data BupiPredicateFailure
UPIREGFailure :: PredicateFailure UPIREG -> BupiPredicateFailure
UPIVOTESFailure :: PredicateFailure UPIVOTES -> BupiPredicateFailure
UPIENDFailure :: PredicateFailure UPIEND -> BupiPredicateFailure
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.Bupi.BUPI
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.Bupi.BupiPredicateFailure
instance GHC.Show.Show Byron.Spec.Chain.STS.Rule.Bupi.BupiPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Chain.STS.Rule.Bupi.BupiPredicateFailure
instance Control.State.Transition.Extended.STS Byron.Spec.Chain.STS.Rule.Bupi.BUPI
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPIREG Byron.Spec.Chain.STS.Rule.Bupi.BUPI
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPIVOTES Byron.Spec.Chain.STS.Rule.Bupi.BUPI
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPIEND Byron.Spec.Chain.STS.Rule.Bupi.BUPI

module Byron.Spec.Chain.STS.Rule.BBody
data BBODY

-- | These <a>PredicateFailure</a>s are all throwable.
data BbodyPredicateFailure
InvalidBlockSize :: BbodyPredicateFailure
InvalidUtxoHash :: BbodyPredicateFailure
InvalidDelegationHash :: BbodyPredicateFailure
InvalidUpdateProposalHash :: BbodyPredicateFailure
BUPIFailure :: PredicateFailure BUPI -> BbodyPredicateFailure
DelegationFailure :: PredicateFailure DELEG -> BbodyPredicateFailure
UTXOWSFailure :: PredicateFailure UTXOWS -> BbodyPredicateFailure
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.BBody.BBODY
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.BBody.BbodyPredicateFailure
instance GHC.Show.Show Byron.Spec.Chain.STS.Rule.BBody.BbodyPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Chain.STS.Rule.BBody.BbodyPredicateFailure
instance Control.State.Transition.Extended.STS Byron.Spec.Chain.STS.Rule.BBody.BBODY
instance Control.State.Transition.Extended.Embed Byron.Spec.Chain.STS.Rule.Bupi.BUPI Byron.Spec.Chain.STS.Rule.BBody.BBODY
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Delegation.DELEG Byron.Spec.Chain.STS.Rule.BBody.BBODY
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.STS.UTXOWS.UTXOWS Byron.Spec.Chain.STS.Rule.BBody.BBODY

module Byron.Spec.Chain.STS.Rule.Epoch

-- | Compute the epoch for the given _absolute_ slot and chain stability
--   parameter.
sEpoch :: HasCallStack => Slot -> BlockCount -> Epoch
data EPOCH
data EpochPredicateFailure
UPIECFailure :: PredicateFailure UPIEC -> EpochPredicateFailure
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.Epoch.EPOCH
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.Epoch.EpochPredicateFailure
instance GHC.Show.Show Byron.Spec.Chain.STS.Rule.Epoch.EpochPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Chain.STS.Rule.Epoch.EpochPredicateFailure
instance Control.State.Transition.Extended.STS Byron.Spec.Chain.STS.Rule.Epoch.EPOCH
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPIEC Byron.Spec.Chain.STS.Rule.Epoch.EPOCH

module Byron.Spec.Chain.STS.Rule.SigCnt
data SIGCNT

-- | These <a>PredicateFailure</a>s are all throwable.
data SigcntPredicateFailure

-- | The given genesis key issued too many blocks.
TooManyIssuedBlocks :: VKeyGenesis -> SigcntPredicateFailure

-- | The key signing the block is not a delegate of a genesis key.
NotADelegate :: SigcntPredicateFailure

-- | Generate an issuer that can still issue blocks according to the
--   <tt>SIGCNT</tt> rule. The issuers are taken from the range of the
--   delegation map passed as parameter.
--   
--   This generator will throw an error if no suitable issuer can be found,
--   which means that the block production halted.
issuer :: Environment SIGCNT -> State SIGCNT -> Gen VKey

-- | Generate a signature count threshold given a chain stability parameter
--   <tt>k</tt> and number of genesis keys <tt>ngk</tt>.
--   
--   This threshold must allow that all the (honest) genesis keys can issue
--   enough blocks to fill the rolling window of <tt>k</tt>. If this is not
--   possible, then the block production will halt since there will not be
--   valid issuers. So the threshold must make it possible to find an
--   integer <tt>n</tt> such that:
--   
--   <pre>
--   n &lt;= k * t
--   </pre>
--   
--   and
--   
--   <pre>
--   k &lt; ngk * n
--   = { algebra }
--   k / ngk &lt; n
--   </pre>
--   
--   We know there must be an integer in the interval
--   
--   <pre>
--   (k/ngk, k/ngk + 1]
--   </pre>
--   
--   So to satisfy the requirements above, we can pick a <tt>t</tt> such
--   that:
--   
--   <pre>
--   k/ngk + 1 &lt;= k * t
--   = { algebra }
--   1/ngk + 1/k &lt;= t
--   </pre>
--   
--   To pick a value for <tt>t</tt> we vary the proportion of honest keys.
sigCntT :: BlockCount -> Word8 -> Gen Double
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.SigCnt.SIGCNT
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.SigCnt.SigcntPredicateFailure
instance GHC.Show.Show Byron.Spec.Chain.STS.Rule.SigCnt.SigcntPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Chain.STS.Rule.SigCnt.SigcntPredicateFailure
instance Control.State.Transition.Extended.STS Byron.Spec.Chain.STS.Rule.SigCnt.SIGCNT

module Byron.Spec.Chain.STS.Rule.Pbft
data PBFT
data PbftPredicateFailure
SlotNotAfterLastBlock :: Slot -> Slot -> PbftPredicateFailure
SlotInTheFuture :: Slot -> Slot -> PbftPredicateFailure
PrevHashNotMatching :: Hash -> Hash -> PbftPredicateFailure
InvalidHeaderSignature :: VKey -> Sig Hash -> PbftPredicateFailure
SigCountFailure :: PredicateFailure SIGCNT -> PbftPredicateFailure
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.Pbft.PBFT
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.Pbft.PbftPredicateFailure
instance GHC.Show.Show Byron.Spec.Chain.STS.Rule.Pbft.PbftPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Chain.STS.Rule.Pbft.PbftPredicateFailure
instance Control.State.Transition.Extended.STS Byron.Spec.Chain.STS.Rule.Pbft.PBFT
instance Control.State.Transition.Extended.Embed Byron.Spec.Chain.STS.Rule.SigCnt.SIGCNT Byron.Spec.Chain.STS.Rule.Pbft.PBFT

module Byron.Spec.Chain.STS.Rule.Chain
data CHAIN
data ChainPredicateFailure
EpochFailure :: PredicateFailure EPOCH -> ChainPredicateFailure
HeaderSizeTooBig :: BlockHeader -> Natural -> Threshold Natural -> ChainPredicateFailure
BBodyFailure :: PredicateFailure BBODY -> ChainPredicateFailure
PBFTFailure :: PredicateFailure PBFT -> ChainPredicateFailure
MaximumBlockSize :: Natural -> Natural -> ChainPredicateFailure
LedgerDelegationFailure :: PredicateFailure DELEG -> ChainPredicateFailure
LedgerUTxOFailure :: PredicateFailure UTXOWS -> ChainPredicateFailure
isHeaderSizeTooBigFailure :: PredicateFailure CHAIN -> Bool
headerIsValid :: UPIState -> BlockHeader -> Rule CHAIN 'Transition ()

-- | Lens for the delegation interface state contained in the chain state.
disL :: Lens' (State CHAIN) DIState
data ShouldGenDelegation
GenDelegation :: ShouldGenDelegation
NoGenDelegation :: ShouldGenDelegation
data ShouldGenUTxO
GenUTxO :: ShouldGenUTxO
NoGenUTxO :: ShouldGenUTxO
data ShouldGenUpdate
GenUpdate :: ShouldGenUpdate
NoGenUpdate :: ShouldGenUpdate
sigGenChain :: ShouldGenDelegation -> ShouldGenUTxO -> ShouldGenUpdate -> Environment CHAIN -> State CHAIN -> Gen (Signal CHAIN)

-- | Produce an invalid hash for one of the three types of block payloads:
--   
--   <ul>
--   <li>Delegation</li>
--   <li>Update</li>
--   <li>UTxO</li>
--   </ul>
tamperWithPayloadHash :: Block -> Gen Block

-- | Generate a block in which one of the three types of payload hashes:
--   
--   <ul>
--   <li>Delegation</li>
--   <li>Update</li>
--   <li>UTxO</li>
--   </ul>
--   
--   is invalid.
invalidProofsBlockGen :: SignalGenerator CHAIN
coverInvalidBlockProofs :: forall m a. (MonadTest m, HasCallStack, Data a) => CoverPercentage -> a -> m ()
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.Chain.CHAIN
instance Data.Data.Data Byron.Spec.Chain.STS.Rule.Chain.ChainPredicateFailure
instance GHC.Show.Show Byron.Spec.Chain.STS.Rule.Chain.ChainPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Chain.STS.Rule.Chain.ChainPredicateFailure
instance Control.State.Transition.Generator.HasTrace Byron.Spec.Chain.STS.Rule.Chain.CHAIN
instance Control.State.Transition.Extended.STS Byron.Spec.Chain.STS.Rule.Chain.CHAIN
instance Control.State.Transition.Extended.Embed Byron.Spec.Chain.STS.Rule.Epoch.EPOCH Byron.Spec.Chain.STS.Rule.Chain.CHAIN
instance Control.State.Transition.Extended.Embed Byron.Spec.Chain.STS.Rule.BBody.BBODY Byron.Spec.Chain.STS.Rule.Chain.CHAIN
instance Control.State.Transition.Extended.Embed Byron.Spec.Chain.STS.Rule.Pbft.PBFT Byron.Spec.Chain.STS.Rule.Chain.CHAIN
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Delegation.DELEG Byron.Spec.Chain.STS.Rule.Chain.CHAIN
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.STS.UTXOWS.UTXOWS Byron.Spec.Chain.STS.Rule.Chain.CHAIN
instance Lens.Micro.Internal.Field1 (a, b, c, d, e, f) (a', b, c, d, e, f) a a'
instance Lens.Micro.Internal.Field5 (a, b, c, d, e, f) (a, b, c, d, e', f) e e'
