-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Wallet Backend for a Cardano node.
--   
--   Please see README.md
@package cardano-wallet-core
@version 2022.7.1


-- | Module containing extra <a>Api</a> functionality needed by the wallet.
module Cardano.Api.Extra

-- | Apply an era-parameterized function to an existentially-wrapped tx.
withShelleyBasedTx :: InAnyShelleyBasedEra Tx -> (forall era. IsShelleyBasedEra era => Tx era -> a) -> a

-- | Helper function for more easily creating an existential
--   <tt>InAnyCardanoEra Tx</tt>.
inAnyCardanoEra :: IsCardanoEra era => Tx era -> InAnyCardanoEra Tx

-- | <a>Downcast</a> an existentially wrapped tx.
asAnyShelleyBasedEra :: InAnyCardanoEra a -> Maybe (InAnyShelleyBasedEra a)


-- | A function to wait until a suitable time to delete a SQLite database
--   file, and a function to delete a SQLite database file, which isn't as
--   straightforward as it sounds.
module Cardano.DB.Sqlite.Delete

-- | Remove a SQLite database file.
--   
--   If <a>SQLite temporary files</a> are present (<tt>-wal</tt> and
--   <tt>-shm</tt>), we remove them as well. Normally, they would be
--   removed when the SQLite connection is closed. But we attempt to remove
--   them anyway, in case cardano-wallet was unable to close the SQLite
--   connection.
--   
--   Additionally, on Windows, the deletion operations will be retried for
--   a short time if they fail. The reason for this is that a FileDelete
--   command just marks a file for deletion. The file is really only
--   removed when the last handle to the file is closed. Unfortunately
--   there are a lot of system services that can have a file temporarily
--   opened using a shared read-only lock, such as the built in AV and
--   search indexer.
--   
--   We can't really guarantee that these are all off, so what we can do is
--   whenever after an rm the file still exists to try again and wait a
--   bit.
--   
--   See <a>https://github.com/haskell/directory/issues/96</a> for more
--   information about this issue.
deleteSqliteDatabase :: Tracer IO DeleteSqliteDatabaseLog -> FilePath -> IO ()

-- | A variant of <a>deleteSqliteDatabase</a> where the caller can specify
--   the <a>RetryPolicy</a>.
deleteSqliteDatabase' :: Tracer IO DeleteSqliteDatabaseLog -> RetryPolicy -> FilePath -> IO ()

-- | Recommended retry policy for <a>deleteSqliteDatabase</a>.
deleteSqliteDatabaseRetryPolicy :: RetryPolicy

-- | Log messages that may arise from <a>deleteSqliteDatabase</a>.
data DeleteSqliteDatabaseLog
MsgRetryDelete :: Int -> DeleteSqliteDatabaseLog
MsgGaveUpDelete :: String -> DeleteSqliteDatabaseLog

-- | Mutable variable containing reference counts to IDs of type
--   <tt>ix</tt>.
data RefCount ix

-- | Construct a <a>RefCount</a> with zero references.
newRefCount :: Ord ix => IO (RefCount ix)

-- | Acquire a reference to the given identifier, perform the given action,
--   then release the reference. Multiple <a>withRef</a> calls can take
--   references at the same time.
withRef :: Ord ix => RefCount ix -> ix -> IO a -> IO a

-- | Attempt to wait until all <a>withRef</a> calls for the given
--   identifier have completed, then perform an action.
--   
--   This will block for up to 2 minutes before running the action. The
--   action is passed the reference count, which should be <tt>0</tt> under
--   normal conditions.
--   
--   No new references can be taken using <a>withRef</a> while the action
--   is running.
waitForFree :: Ord ix => Tracer IO (Maybe Int) -> RefCount ix -> ix -> (Int -> IO a) -> IO a

-- | A variant of <a>waitForFree</a> where the caller can specify the
--   <a>RetryPolicy</a>.
waitForFree' :: Ord ix => Tracer IO (Maybe Int) -> RetryPolicy -> RefCount ix -> ix -> (Int -> IO a) -> IO a

-- | Recommended retry schedule for polling the <a>RefCount</a>. It will
--   poll for up to 2 minutes.
waitForFreeRetryPolicy :: RetryPolicy
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.DB.Sqlite.Delete.DeleteSqliteDatabaseLog
instance GHC.Classes.Eq Cardano.DB.Sqlite.Delete.DeleteSqliteDatabaseLog
instance GHC.Show.Show Cardano.DB.Sqlite.Delete.DeleteSqliteDatabaseLog
instance GHC.Generics.Generic Cardano.DB.Sqlite.Delete.DeleteSqliteDatabaseLog
instance Data.Text.Class.ToText Cardano.DB.Sqlite.Delete.DeleteSqliteDatabaseLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.DB.Sqlite.Delete.DeleteSqliteDatabaseLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.DB.Sqlite.Delete.DeleteSqliteDatabaseLog


-- | Re-exports functionality provided by module <a>Credential</a>, but
--   with a safer interface.
module Cardano.Ledger.Credential.Safe

-- | Pointer to a slot number, transaction index and an index in
--   certificate list.
data Ptr

-- | Safely constructs a <a>Ptr</a> without silent truncation of slot
--   numbers.
--   
--   Use <a>toSlotNo32</a> to convert an ordinary <a>SlotNo</a> to a
--   <a>SlotNo32</a>.
--   
--   This function should satisfy the following property:
--   
--   <pre>
--   safeUnwrapPtr (safePtr s t c) == (s, t, c)
--   </pre>
safePtr :: SlotNo32 -> TxIx -> CertIx -> Ptr

-- | Safely deconstructs a <a>Ptr</a>.
--   
--   Use <a>fromSlotNo32</a> to convert the returned slot number to a
--   <a>SlotNo</a>.
--   
--   This function should satisfy the following property:
--   
--   <pre>
--   safeUnwrapPtr (safePtr s t c) == (s, t, c)
--   </pre>
safeUnwrapPtr :: Ptr -> (SlotNo32, TxIx, CertIx)

-- | A 32-bit wide slot number.
newtype SlotNo32
SlotNo32 :: Word32 -> SlotNo32

-- | Converts an ordinary <a>SlotNo</a> into a <a>SlotNo32</a>.
--   
--   Returns <a>Nothing</a> if the slot number could not be converted
--   safely.
toSlotNo32 :: SlotNo -> Maybe SlotNo32

-- | Converts a <a>SlotNo32</a> into an ordinary <a>SlotNo</a>.
fromSlotNo32 :: SlotNo32 -> SlotNo
instance GHC.Show.Show Cardano.Ledger.Credential.Safe.SlotNo32
instance GHC.Classes.Ord Cardano.Ledger.Credential.Safe.SlotNo32
instance GHC.Num.Num Cardano.Ledger.Credential.Safe.SlotNo32
instance GHC.Classes.Eq Cardano.Ledger.Credential.Safe.SlotNo32

module Cardano.Api.Gen
genAddressAny :: Gen AddressAny
genAddressByron :: Gen (Address ByronAddr)
genAddressInEra :: CardanoEra era -> Gen (AddressInEra era)
genAddressShelley :: Gen (Address ShelleyAddr)
genAlphaNum :: Gen Char
genAssetIdNoAda :: Gen AssetId
genAssetName :: Gen AssetName
genByronKeyWitness :: Gen (KeyWitness ByronEra)
genCertIx :: Gen CertIx
genCostModel :: Gen CostModel
genCostModels :: Gen (Map AnyPlutusScriptVersion CostModel)
genEncodingBoundaryLovelace :: Gen Lovelace
genEpochNo :: Gen EpochNo
genExecutionUnitPrices :: Gen ExecutionUnitPrices
genExecutionUnits :: Gen ExecutionUnits
genExtraKeyWitnesses :: CardanoEra era -> Gen (TxExtraKeyWitnesses era)
genLovelace :: Gen Lovelace
genMIRPot :: Gen MIRPot
genMIRTarget :: Gen MIRTarget
genNat :: Gen Natural
genNetworkId :: Gen NetworkId
genNetworkMagic :: Gen NetworkMagic
genPaymentCredential :: Gen PaymentCredential
genPlutusScript :: PlutusScriptVersion lang -> Gen (PlutusScript lang)
genPolicyId :: Gen PolicyId
genPoolId :: Gen PoolId
genProtocolParameters :: Gen ProtocolParameters
genProtocolParametersUpdate :: Gen ProtocolParametersUpdate
genPtr :: Gen Ptr
genRational :: Gen Rational
genRationalInt64 :: Gen Rational
genScript :: ScriptLanguage lang -> Gen (Script lang)
genScriptData :: Gen ScriptData
genScriptHash :: Gen ScriptHash
genScriptInAnyLang :: Gen ScriptInAnyLang
genScriptInEra :: CardanoEra era -> Gen (ScriptInEra era)
genScriptValidity :: Gen ScriptValidity
genScriptWitnessStake :: ScriptLanguageInEra lang era -> Gen (ScriptWitness WitCtxStake era)
genSeed :: Int -> Gen Seed
genShelleyHash :: Gen (Hash Blake2b_256 EraIndependentTxBody)
genShelleyWitnessSigningKey :: Gen ShelleyWitnessSigningKey

-- | Generate a positive or negative quantity.
genSignedQuantity :: Gen Quantity

-- | Generate a <a>Value</a> which could represent the balance of a partial
--   transaction, where both ada and other assets can be included, and
--   quantities can be both positive and negative.
genSignedValue :: Gen Value
genSigningKey :: Key keyrole => AsType keyrole -> Gen (SigningKey keyrole)
genSimpleScript :: SimpleScriptVersion lang -> Gen (SimpleScript lang)
genSlotNo :: Gen SlotNo
genSlotNo32 :: Gen SlotNo32
genStakeAddress :: Gen StakeAddress
genStakeAddressReference :: Gen StakeAddressReference
genStakeCredential :: Gen StakeCredential
genStakePoolMetadata :: Gen StakePoolMetadata
genStakePoolMetadataReference :: Gen StakePoolMetadataReference
genStakePoolParameters :: Gen StakePoolParameters
genStakePoolRelay :: Gen StakePoolRelay
genTtl :: Gen SlotNo
genTx :: Gen (InAnyCardanoEra Tx)
genTxAuxScripts :: CardanoEra era -> Gen (TxAuxScripts era)
genTxBody :: IsCardanoEra era => CardanoEra era -> Gen (TxBody era)
genTxBodyContent :: CardanoEra era -> Gen (TxBodyContent BuildTx era)

-- | Similar to <a>genTxBody</a>, but with a distribution better suitable
--   for testing balancing.
genTxBodyForBalancing :: IsCardanoEra era => CardanoEra era -> Gen (TxBody era)
genTxCertificate :: Gen Certificate
genTxCertificates :: CardanoEra era -> Gen (TxCertificates BuildTx era)
genTxFee :: CardanoEra era -> Gen (TxFee era)
genTxForBalancing :: forall era. IsCardanoEra era => CardanoEra era -> Gen (Tx era)
genTxId :: Gen TxId
genTxIn :: Gen TxIn
genTxIndex :: Gen TxIx
genTxInEra :: forall era. IsCardanoEra era => CardanoEra era -> Gen (Tx era)
genTxInsCollateral :: CardanoEra era -> Gen (TxInsCollateral era)
genTxIx :: Gen TxIx
genTxMetadata :: Gen TxMetadata
genTxMetadataInEra :: CardanoEra era -> Gen (TxMetadataInEra era)
genTxMetadataValue :: Gen TxMetadataValue
genTxMintValue :: forall era. CardanoEra era -> Gen (TxMintValue BuildTx era)
genTxOut :: CardanoEra era -> Gen (TxOut ctx era)
genTxOutDatum :: CardanoEra era -> Gen (TxOutDatum ctx era)
genTxOutValue :: CardanoEra era -> Gen (TxOutValue era)
genTxReturnCollateral :: CardanoEra era -> Gen (TxReturnCollateral ctx era)
genTxScriptValidity :: CardanoEra era -> Gen (TxScriptValidity era)
genTxTotalCollateral :: CardanoEra era -> Gen (TxTotalCollateral era)
genTxValidityLowerBound :: CardanoEra era -> Gen (TxValidityLowerBound era)
genTxValidityRange :: CardanoEra era -> Gen (TxValidityLowerBound era, TxValidityUpperBound era)
genTxValidityUpperBound :: CardanoEra era -> Gen (TxValidityUpperBound era)
genTxWithdrawals :: CardanoEra era -> Gen (TxWithdrawals BuildTx era)
genUnsignedQuantity :: Gen Quantity
genUpdateProposal :: CardanoEra era -> Gen (TxUpdateProposal era)

-- | Generate a <a>Value</a> suitable for minting, i.e. non-ADA asset ID
--   and a positive or negative quantity.
genValueForMinting :: Gen Value

-- | Generate a <a>Value</a> suitable for usage in a transaction output,
--   i.e. any asset ID and a positive quantity.
genValueForTxOut :: Gen Value
genVerificationKey :: Key keyrole => AsType keyrole -> Gen (VerificationKey keyrole)
genVerificationKeyHash :: Key keyrole => AsType keyrole -> Gen (Hash keyrole)
genWithdrawalInfo :: CardanoEra era -> Gen (StakeAddress, Lovelace, BuildTxWith BuildTx (Witness WitCtxStake era))
genWitness :: CardanoEra era -> TxBody era -> Gen (KeyWitness era)
genWitnesses :: CardanoEra era -> TxBody era -> Gen [KeyWitness era]
genWitnessNetworkIdOrByronAddress :: Gen WitnessNetworkIdOrByronAddress
genWitnessStake :: CardanoEra era -> Gen (Witness WitCtxStake era)
instance System.Random.Random Cardano.Api.Value.Lovelace
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Api.StakePoolMetadata.StakePoolMetadata


-- | This module provides a utility function <a>variants</a> for parsing
--   JSON values using one out of many parsers.
module Cardano.Wallet.Api.Aeson.Variant

-- | Construct a parser for <tt>a</tt> from parsers for its variants.
--   
--   The parser succeeds iff exactly one of the predicates of the variants
--   succeeds and the parser of that variant also succeeds. Using the
--   predicate in this way improves error messages in case of parse
--   failure.
--   
--   For example, <a>variants</a> can be used to parse a JSON value into a
--   disjoint sum (<a>Either</a>) without needing a tag representing the
--   <a>Left</a>/<a>Right</a> cases. Instead, the predicates of the
--   variants can be used to disambiguate a <a>Value</a> by checking the
--   presence of absence of certain JSON object keys.
variants :: String -> [Variant a] -> Value -> Parser a

-- | Specification of a JSON parser suitable for <a>variants</a>.
data Variant a

-- | Define a <a>Variant</a> for parsing a JSON value.
--   
--   A predicate checks whether a given <a>Value</a> belongs to this
--   variant; the <a>Value</a> is parsed only if this this check succeeds.
variant :: String -> (Object -> Bool) -> (Value -> Parser a) -> Variant a
instance GHC.Base.Functor Cardano.Wallet.Api.Aeson.Variant.Variant


-- | Optional TLS support for mutual client-server authentication on top of
--   a Wai application.
module Cardano.Wallet.Api.Server.Tls

-- | Path to a x.509 PKI for mutual client-server authentication.
data TlsConfiguration
TlsConfiguration :: !FilePath -> !FilePath -> !FilePath -> TlsConfiguration
[tlsCaCert] :: TlsConfiguration -> !FilePath
[tlsSvCert] :: TlsConfiguration -> !FilePath
[tlsSvKey] :: TlsConfiguration -> !FilePath
requireClientAuth :: TlsConfiguration -> TLSSettings
instance GHC.Show.Show Cardano.Wallet.Api.Server.Tls.TlsConfiguration


-- | Abstract data type that describes a policy for keeping and discarding
--   checkpoints. To be used with the <tt>Checkpoints</tt> type.
module Cardano.Wallet.Checkpoints.Policy
type BlockHeight = Integer

-- | <ul>
--   <li><i>CheckpointPolicy</i></li>
--   </ul>
--   
--   To save memory and time, we do not store every checkpoint. Instead, a
--   <a>CheckpointPolicy</a> determines which checkpoints to store and
--   which ones to discard. The <tt>extendAndPrune</tt> functions consults
--   such a policy and drops checkpoints as it deems necessary.
--   
--   A <a>CheckpointPolicy</a> determines whether a checkpoint is worth
--   storing only based on its block height. The boolean
--   
--   keepWhereTip policy tip blockheight
--   
--   indicates whether the checkpoint should be stored (<a>True</a>) or not
--   (<a>False</a>). It is important that this function does not oscillate:
--   If <tt>blockheight &lt;= tip</tt>, the function result may change from
--   <a>True</a> to <a>False</a> as the <tt>tip</tt> increases, but not the
--   other way round. This is because we can only create checkpoints the
--   first time we read the corresponding block.
--   
--   TODO: The <tt>Checkpoints</tt> collection currently relies on
--   <tt>Slot</tt> instead of <a>BlockHeight</a> to store checkpoints. We
--   need to better integrate this with <a>BlockHeight</a>.
--   
--   I (Heinrich) actually prefer <tt>Slot</tt>. However, not every slot
--   contains a block, and we would lose too many checkpoints if we based
--   the decision of whether to keep a checkpoint or not based on the slot
--   number alone. In contrast, block height is "dense".
data CheckpointPolicy

-- | Assuming that the tip of the chain is at block height <tt>tip</tt>,
--   <tt>nextCheckpoint policy tip height</tt> returns the smallest
--   <tt>height'</tt> satisfying @height' &gt;= height# at which the next
--   checkpoint is to be made.
nextCheckpoint :: CheckpointPolicy -> BlockHeight -> BlockHeight -> Maybe BlockHeight

-- | Assuming that the tip of the chain is at block height <tt>tip</tt>,
--   the value <tt>keepWhereTip policy tip height</tt> indicates whether a
--   checkpoint should (<a>True</a>) or should not (<a>False</a>) be stored
--   at <tt>height</tt>.
keepWhereTip :: CheckpointPolicy -> BlockHeight -> BlockHeight -> Bool

-- | List all checkpoints for a given tip.
toListAtTip :: CheckpointPolicy -> BlockHeight -> [BlockHeight]

-- | The <a>CheckpointPolicy</a> that keeps only the genesis block.
atGenesis :: CheckpointPolicy

-- | The <a>CheckpointPolicy</a> that only keeps the tip of the chain.
atTip :: CheckpointPolicy

-- | <tt>trailingArithmetic n height</tt> keeps <tt>n</tt> checkpoints at
--   block heights that are multiples of <tt>height</tt> and which are
--   closest to the tip of the chain. (Fewer than <tt>n</tt> checkpoints
--   are kept while the chain is too short to accommodate all checkpoints.)
trailingArithmetic :: Integer -> BlockHeight -> CheckpointPolicy

-- | Note [sparseArithmeticPolicy]
--   
--   The <a>sparseArithmetic</a> checkpoint policy contains essentially two
--   sets of checkpoints: One fairly dense set near the tip of the chain in
--   order to handle frequent potential rollbacks, and one sparse set that
--   spans the entire epoch stability window. These two sets are arranged
--   as arithmetic sequences.
--   
--   This policy is motivated by the following observations:
--   
--   <ul>
--   <li>We can't rollback for more than `k = epochStability` blocks in the
--   past</li>
--   <li>It is pretty fast to re-sync a few hundred blocks</li>
--   <li>Small rollbacks near the tip may occur more often than long
--   ones</li>
--   </ul>
--   
--   Hence, we should strive to
--   
--   <ul>
--   <li>Prune any checkpoint that are more than <tt>k</tt> blocks in the
--   past</li>
--   <li>Keep only one checkpoint every <tt>largeGap</tt> ~100 blocks</li>
--   <li>But still keep ~10 most recent checkpoints to cope with small
--   rollbacks.</li>
--   </ul>
--   
--   Roughly, the <a>sparseArithmetic</a>
--   
--   0 ..... N*largeGap .... (N+1)*largeGap .. .. M*smallGap (M+1)*smallGap
--   tip |_______________________________________________________________|
--   epochStability
--   
--   Note: In the event where chain following "fails completely" (because,
--   for example, the node has switch to a different chain, different by
--   more than <tt>k</tt>), we have no choice but rolling back from
--   genesis. Therefore, we need to keep the very first checkpoint in the
--   database, no matter what.
sparseArithmetic :: BlockHeight -> CheckpointPolicy

-- | A sensible default checkpoint policy; currently
--   <a>sparseArithmetic</a>.
defaultPolicy :: BlockHeight -> CheckpointPolicy

-- | A reasonable gap size used internally in
--   <tt>sparseArithmeticPolicy</tt>.
--   
--   <tt>Reasonable</tt> means that it's not _too frequent_ and it's not
--   too large. A value that is too small in front of k would require
--   generating much more checkpoints than necessary.
--   
--   A value that is larger than <tt>k</tt> may have dramatic consequences
--   in case of deep rollbacks.
--   
--   As a middle ground, we current choose `k / 3`, which is justified by:
--   
--   <ul>
--   <li>The current bandwidth of the network layer (several thousands
--   blocks per seconds)</li>
--   <li>The current value of k = 2160</li>
--   </ul>
--   
--   So, `k / 3` = 720, which corresponds to around a second of time needed
--   to catch up in case of large rollbacks (if our local node has caught
--   up already).
gapSize :: BlockHeight -> Integer
instance GHC.Base.Semigroup Cardano.Wallet.Checkpoints.Policy.CheckpointPolicy
instance GHC.Base.Monoid Cardano.Wallet.Checkpoints.Policy.CheckpointPolicy


-- | This module provides the <a>SelectionContext</a> class, which provides
--   a shared context for types used by coin selection.
module Cardano.Wallet.CoinSelection.Internal.Context

-- | Provides a shared context for types used by coin selection.
class (Buildable (Address c), Buildable (UTxO c), Ord (Address c), Ord (UTxO c), Show (Address c), Show (UTxO c)) => SelectionContext c where {
    
    -- | A target address to which payments can be made.
    type family Address c;
    
    -- | A unique identifier for an individual UTxO.
    type family UTxO c;
}


-- | Temporary compatibility functions for the ghc-8.10 update.
module Cardano.Wallet.Compat
(^?) :: s -> ((a -> Const (First a) a) -> s -> Const (First a) s) -> Maybe a
infixl 8 ^?


-- | This module contains utility functions for logging and mapping trace
--   data.
module Cardano.Wallet.Logging

-- | Tracer transformer which converts 'Trace m a' to 'Tracer m a' by
--   wrapping typed log messages into a <a>LogObject</a>.
trMessage :: (MonadIO m, HasPrivacyAnnotation a, HasSeverityAnnotation a) => Tracer m (LoggerName, LogObject a) -> Tracer m a

-- | Tracer transformer which transforms traced items to their
--   <a>ToText</a> representation and further traces them as a
--   <a>LogObject</a>. If the <a>ToText</a> representation is empty, then
--   no tracing happens.
trMessageText :: (MonadIO m, ToText a, HasPrivacyAnnotation a, HasSeverityAnnotation a) => Tracer m (LoggerName, LogObject Text) -> Tracer m a

-- | Converts a <a>Text</a> trace into any other type of trace that has a
--   <a>ToText</a> instance.
transformTextTrace :: ToText a => Trace IO Text -> Trace IO a

-- | Creates a tracer that prints any <a>ToText</a> log message. This is
--   useful for debugging functions in the REPL, when you need a
--   <a>Tracer</a> object.
stdoutTextTracer :: (MonadIO m, ToText a) => Tracer m a

-- | Run an <a>ExceptT</a> action, then trace its result, all in one step.
--   This is a more basic version of <tt>resultTracer</tt>.
traceWithExceptT :: Monad m => Tracer m (Either e a) -> ExceptT e m a -> ExceptT e m a

-- | Log around an <a>ExceptT</a> action. The result of the action is
--   captured as an <a>Either</a> in the log message. Other unexpected
--   exceptions are captured in the <a>BracketLog'</a>.
traceResult :: MonadUnliftIO m => Tracer m (BracketLog' (Either e r)) -> ExceptT e m r -> ExceptT e m r

-- | Format a tracer message from <a>traceResult</a> as multiline text.
formatResultMsg :: (Show e, IsList t, Item t ~ (Text, v), Buildable v, Buildable r) => Text -> t -> BracketLog' (Either e r) -> Builder

-- | Same as <a>formatResultMsg</a>, but accepts result formatters as
--   parameters.
formatResultMsgWith :: (IsList t, Item t ~ (Text, v), Buildable v) => (e -> Builder) -> (r -> Builder) -> Text -> t -> BracketLog' (Either e r) -> Builder

-- | A good default mapping of message severities for <a>traceResult</a>.
resultSeverity :: Severity -> BracketLog' (Either e r) -> Severity

-- | Trace around an action, where the result doesn't matter.
type BracketLog = BracketLog' SomeResult

-- | Used for tracing around an action.
data BracketLog' r

-- | Logged before the action starts.
BracketStart :: BracketLog' r

-- | Logged after the action finishes.
BracketFinish :: r -> BracketLog' r

-- | Logged when the action throws an exception.
BracketException :: LoggedException SomeException -> BracketLog' r

-- | Logged when the action receives an async exception.
BracketAsyncException :: LoggedException SomeException -> BracketLog' r

-- | Exception wrapper with typeclass instances that exception types often
--   don't have.
newtype LoggedException e
LoggedException :: e -> LoggedException e

-- | Run a monadic action with <a>BracketLog</a> traced around it.
bracketTracer :: MonadUnliftIO m => Tracer m BracketLog -> m a -> m a

-- | Run a monadic action with <a>BracketLog</a> traced around it.
bracketTracer' :: MonadUnliftIO m => (r -> a) -> Tracer m (BracketLog' a) -> m r -> m r

-- | Simplified wrapper for <a>mkOutcomeExtractor</a>. This produces a
--   timings <a>Tracer</a> from a <a>Tracer</a> of messages <tt>a</tt>, and
--   a function which can extract the <a>BracketLog</a> from <tt>a</tt>.
--   
--   The extractor function can provide <tt>ctx</tt>, which could be the
--   name of the timed operation for example.
--   
--   The produced tracer will make just one trace for each finished
--   bracket. It contains the <tt>ctx</tt> from the extractor and the time
--   difference.
produceTimings :: (MonadUnliftIO m, MonadMask m) => (a -> Maybe (ctx, BracketLog)) -> Tracer m (ctx, DiffTime) -> m (Tracer m a)

-- | Convert an IO tracer to a <tt>m</tt> tracer.
unliftIOTracer :: MonadIO m => Tracer IO a -> Tracer m a

-- | Conditional mapping of a <a>Tracer</a>.
flatContramapTracer :: Monad m => (a -> Maybe b) -> Tracer m b -> Tracer m a
instance (GHC.Show.Show e, GHC.Classes.Ord e) => GHC.Classes.Ord (Cardano.Wallet.Logging.LoggedException e)
instance GHC.Show.Show e => GHC.Show.Show (Cardano.Wallet.Logging.LoggedException e)
instance GHC.Generics.Generic (Cardano.Wallet.Logging.LoggedException e)
instance GHC.Base.Functor Cardano.Wallet.Logging.BracketLog'
instance Data.Aeson.Types.ToJSON.ToJSON r => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Logging.BracketLog' r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Cardano.Wallet.Logging.BracketLog' r)
instance GHC.Show.Show r => GHC.Show.Show (Cardano.Wallet.Logging.BracketLog' r)
instance GHC.Generics.Generic (Cardano.Wallet.Logging.BracketLog' r)
instance GHC.Classes.Eq Cardano.Wallet.Logging.SomeResult
instance GHC.Show.Show Cardano.Wallet.Logging.SomeResult
instance GHC.Generics.Generic Cardano.Wallet.Logging.SomeResult
instance Control.Monad.IO.Class.MonadIO m => Control.Tracer.Transformers.ObserveOutcome.Outcome m (ctx, Cardano.Wallet.Logging.BracketLog)
instance Formatting.Buildable.Buildable Cardano.Wallet.Logging.SomeResult
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Logging.SomeResult
instance Formatting.Buildable.Buildable r => Data.Text.Class.ToText (Cardano.Wallet.Logging.BracketLog' r)
instance Formatting.Buildable.Buildable r => Formatting.Buildable.Buildable (Cardano.Wallet.Logging.BracketLog' r)
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation (Cardano.Wallet.Logging.BracketLog' r)
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation (Cardano.Wallet.Logging.BracketLog' r)
instance Control.Monad.IO.Class.MonadIO m => Control.Tracer.Transformers.ObserveOutcome.Outcome m (Cardano.Wallet.Logging.BracketLog' r)
instance Control.DeepSeq.NFData e => Control.DeepSeq.NFData (Cardano.Wallet.Logging.LoggedException e)
instance Control.DeepSeq.NFData (Cardano.Wallet.Logging.LoggedException GHC.Exception.Type.SomeException)
instance GHC.Exception.Type.Exception e => Data.Text.Class.ToText (Cardano.Wallet.Logging.LoggedException e)
instance GHC.Exception.Type.Exception e => Formatting.Buildable.Buildable (Cardano.Wallet.Logging.LoggedException e)
instance GHC.Show.Show e => GHC.Classes.Eq (Cardano.Wallet.Logging.LoggedException e)
instance GHC.Exception.Type.Exception e => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Logging.LoggedException e)
instance (Control.Monad.IO.Class.MonadIO m, Data.Text.Class.ToText a, Cardano.BM.Data.Tracer.HasPrivacyAnnotation a, Cardano.BM.Data.Tracer.HasSeverityAnnotation a) => Cardano.BM.Data.Tracer.Transformable Data.Text.Internal.Text m a


-- | Provides functions for checking if TCP ports can be connected to, or
--   are available to listen on.
--   
--   These can be used for: - Waiting until a server in another process has
--   started. - Start servers for testing when there may be multiple test
--   suites running in parallel.
module Cardano.Wallet.Network.Ports

-- | Port number. Use the <tt>Num</tt> instance (i.e. use a literal) to
--   create a <tt>PortNumber</tt> value.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   
--   &gt;&gt;&gt; show (12345 :: PortNumber)
--   "12345"
--   
--   &gt;&gt;&gt; 50000 &lt; (51000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 &lt; (52000 :: PortNumber)
--   True
--   
--   &gt;&gt;&gt; 50000 + (10000 :: PortNumber)
--   60000
--   </pre>
data PortNumber

-- | Find a TCPv4 port which is likely to be free for listening on
--   <tt>localhost</tt>. This binds a socket, receives an OS-assigned port,
--   then closes the socket.
--   
--   Note that this is vulnerable to race conditions if another process
--   binds the port returned by <a>getRandomPort</a> before this process
--   does.
--   
--   Do not use this unless you have no other option.
getRandomPort :: IO PortNumber

-- | Checks whether <tt>connect()</tt> to a given TCPv4 <a>SockAddr</a>
--   succeeds or returns <a>eCONNREFUSED</a>.
--   
--   Rethrows connection exceptions in all other cases (e.g. when the host
--   is unroutable).
--   
--   Code courtesy of nh2: <a>https://stackoverflow.com/a/57022572</a>
isPortOpen :: SockAddr -> IO Bool

-- | Creates a <tt>SockAttr</tt> from host IP and port number.
--   
--   Example: &gt; simpleSockAddr (127,0,0,1) 8000
simpleSockAddr :: (Word8, Word8, Word8, Word8) -> PortNumber -> SockAddr

-- | Get the port from a URI, which is assumed to be a HTTP or HTTPS URL.
portFromURL :: URI -> PortNumber

-- | Get a list of random TCPv4 ports that currently do not have any
--   servers listening on them. It may return less than the requested
--   number of ports.
--   
--   Note that this method of allocating ports is subject to race
--   conditions. Production code should use better methods such as passing
--   a listening socket to the child process.
randomUnusedTCPPorts :: Int -> IO [Int]


-- | Module for orphans which would be too inconvenient to avoid.
module Cardano.Wallet.Orphans
instance Formatting.Buildable.Buildable Cardano.Slotting.Slot.SlotNo
instance GHC.Classes.Ord Cardano.Api.TxMetadata.TxMetadata
instance Formatting.Buildable.Buildable Cardano.Api.TxMetadata.TxMetadata
instance Control.DeepSeq.NFData Cardano.Api.TxMetadata.TxMetadata
instance Control.DeepSeq.NFData Cardano.Api.TxMetadata.TxMetadataValue
instance GHC.Classes.Eq Ouroboros.Consensus.HardFork.History.Qry.PastHorizonException


module Cardano.Wallet.Primitive.Passphrase.Types

-- | An encapsulated passphrase. The inner format is free, but the wrapper
--   helps readability in function signatures.
--   
--   Some type parameters in use are:
--   
--   <ul>
--   <li><tt>"user"</tt> - a passphrase entered by the user through the
--   API. The <a>FromText</a> instance enforces password length rules.</li>
--   <li><tt>"lenient"</tt> - like <tt>"user"</tt>, except without a
--   minimum length restriction in <a>FromText</a>.`</li>
--   <li><tt>"encryption"</tt> - the user's passphrase, transformed so that
--   it can be used as the key for encrypting wallet keys.</li>
--   <li><tt>"salt"</tt> - the random salt part of a hashed
--   passphrase.</li>
--   </ul>
newtype Passphrase (purpose :: Symbol)
Passphrase :: ScrubbedBytes -> Passphrase (purpose :: Symbol)
[unPassphrase] :: Passphrase (purpose :: Symbol) -> ScrubbedBytes
class PassphraseMinLength (purpose :: Symbol)

-- | Minimal Length for a passphrase, for lack of better validations
passphraseMinLength :: PassphraseMinLength purpose => Proxy purpose -> Int
class PassphraseMaxLength (purpose :: Symbol)

-- | Maximum length for a passphrase
passphraseMaxLength :: PassphraseMaxLength purpose => Proxy purpose -> Int
validatePassphrase :: forall purpose. (PassphraseMaxLength purpose, PassphraseMinLength purpose) => Text -> Either String (Passphrase purpose)
newtype PassphraseHash
PassphraseHash :: ScrubbedBytes -> PassphraseHash
[getPassphraseHash] :: PassphraseHash -> ScrubbedBytes

-- | A type to capture which encryption scheme should be used
data PassphraseScheme

-- | Legacy encryption scheme for passphrases
EncryptWithScrypt :: PassphraseScheme

-- | Encryption scheme used since cardano-wallet
EncryptWithPBKDF2 :: PassphraseScheme
data WalletPassphraseInfo
WalletPassphraseInfo :: UTCTime -> PassphraseScheme -> WalletPassphraseInfo
[lastUpdatedAt] :: WalletPassphraseInfo -> UTCTime
[passphraseScheme] :: WalletPassphraseInfo -> PassphraseScheme

-- | Indicate a failure when checking for a given <a>Passphrase</a> match
data ErrWrongPassphrase
ErrWrongPassphrase :: ErrWrongPassphrase
ErrPassphraseSchemeUnsupported :: PassphraseScheme -> ErrWrongPassphrase
instance Data.ByteArray.Types.ByteArrayAccess (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase purpose)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase purpose)
instance GHC.Base.Monoid (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase purpose)
instance GHC.Base.Semigroup (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase purpose)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase purpose)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase purpose)
instance GHC.Read.Read Cardano.Wallet.Primitive.Passphrase.Types.PassphraseScheme
instance GHC.Show.Show Cardano.Wallet.Primitive.Passphrase.Types.PassphraseScheme
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Passphrase.Types.PassphraseScheme
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Passphrase.Types.PassphraseScheme
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Passphrase.Types.PassphraseScheme
instance Data.ByteArray.Types.ByteArray Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash
instance Data.ByteArray.Types.ByteArrayAccess Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash
instance GHC.Show.Show Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash
instance GHC.Show.Show Cardano.Wallet.Primitive.Passphrase.Types.WalletPassphraseInfo
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Passphrase.Types.WalletPassphraseInfo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Passphrase.Types.WalletPassphraseInfo
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Passphrase.Types.WalletPassphraseInfo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Passphrase.Types.ErrWrongPassphrase
instance GHC.Show.Show Cardano.Wallet.Primitive.Passphrase.Types.ErrWrongPassphrase
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Passphrase.Types.ErrWrongPassphrase
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Passphrase.Types.ErrWrongPassphrase
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Passphrase.Types.WalletPassphraseInfo
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Passphrase.Types.PassphraseScheme
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Passphrase.Types.PassphraseScheme
instance Cardano.Wallet.Primitive.Passphrase.Types.PassphraseMaxLength "user"
instance Cardano.Wallet.Primitive.Passphrase.Types.PassphraseMaxLength "lenient"
instance (Cardano.Wallet.Primitive.Passphrase.Types.PassphraseMaxLength purpose, Cardano.Wallet.Primitive.Passphrase.Types.PassphraseMinLength purpose) => Data.Text.Class.FromText (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase purpose)
instance Cardano.Wallet.Primitive.Passphrase.Types.PassphraseMinLength "user"
instance Cardano.Wallet.Primitive.Passphrase.Types.PassphraseMinLength "lenient"
instance Crypto.Random.Types.MonadRandom ((->) (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase "salt"))
instance Data.Text.Class.ToText (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase purpose)


-- | Generating and verifying hashes of wallet passwords.
module Cardano.Wallet.Primitive.Passphrase.Current

-- | Encrypt a <a>Passphrase</a> into a format that is suitable for storing
--   on disk
encryptPassphrase :: MonadRandom m => Passphrase "encryption" -> m PassphraseHash
checkPassphrase :: Passphrase "encryption" -> PassphraseHash -> Either ErrWrongPassphrase ()
preparePassphrase :: Passphrase "user" -> Passphrase "encryption"
genSalt :: MonadRandom m => m (Passphrase "salt")


-- | This module provides the main <a>Address</a> data type used by the
--   wallet.
module Cardano.Wallet.Primitive.Types.Address

-- | Representation of Cardano addresses.
--   
--   Addresses are basically a human-friendly representation of public
--   keys. Historically in Cardano, there exist different sort of
--   addresses, and new ones are to come. So far, we can distinguish
--   between three types of address:
--   
--   <ul>
--   <li>Byron Random addresses, which holds a payload with derivation path
--   details</li>
--   <li>Byron Sequential addresses, also known as Icarus'style
--   addresses</li>
--   <li>Shelley base addresses, see also
--   <a>implementation-decisions/address</a></li>
--   </ul>
--   
--   For more details, see also <a>About Address Derivation</a>
--   
--   Shelley base addresses can be divided into two types:
--   
--   <ul>
--   <li>Single Addresses: which only hold a public spending key</li>
--   <li>Group Addresses: which hold both a spending and delegation
--   keys</li>
--   </ul>
--   
--   It'll therefore seem legitimate to represent addresses as:
--   
--   <pre>
--   data Address
--     = ByronAddress !ByteString
--     | SingleAddress !XPub
--     | GroupAddress !XPub XPub
--   </pre>
--   
--   However, there's a major drawback to this approach: we have to
--   consider all three constructors everywhere, and make sure we test
--   every function using them three despite having no need for such
--   fine-grained representation.
--   
--   Indeed, from the wallet core code, addresses are nothing more than an
--   opaque bunch of bytes that can be compared with each other. When
--   signing transactions, we have to look up addresses anyway and
--   therefore can re-derive their corresponding public keys. The only
--   moment the distinction between address types matters is when it comes
--   to representing addresses at the edge of the application (the API
--   layer). And here, this is precisely where we need to also what target
--   backend we're connected to. Different backends use different encodings
--   which may not be compatible.
--   
--   Therefore, for simplicity, it's easier to consider addresses as
--   "bytes", and only peak into these bytes whenever we need to do
--   something with them. This makes it fairly clear that addresses are
--   just an opaque string for the wallet layer and that the underlying
--   encoding is rather agnostic to the underlying backend.
newtype Address
Address :: ByteString -> Address
[unAddress] :: Address -> ByteString

-- | Denotes if an address has been previously used or not... whether that
--   be in the output of a transaction on the blockchain or one in our
--   pending set.
data AddressState
Used :: AddressState
Unused :: AddressState
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Address.Address
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.Address.Address
instance Data.Hashable.Class.Hashable Cardano.Wallet.Primitive.Types.Address.Address
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Address.Address
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Address.Address
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Address.Address
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Address.Address
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Address.AddressState
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Address.AddressState
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Address.AddressState
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.Address.AddressState
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.Address.AddressState
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.Address.AddressState
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.Address.AddressState
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Address.AddressState
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Address.AddressState
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Address.Address
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.Address.Address
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.Address.Address


-- | An address pool caches a collection of addresses. The purpose of this
--   data structure is to aid in BIP-44 style address discovery with an
--   address gap.
module Cardano.Wallet.Address.Pool

-- | An address pool caches a collection of addresses (type <tt>addr</tt>)
--   which are derived from a numeric index (type <tt>ix</tt>).
data Pool addr ix

-- | Mapping from a numeric index to its corresponding address.
--   
--   This mapping is supposed to be (practically) a one-way function: Given
--   an <tt>addr</tt>, it is impossible to compute the preimage <tt>ix</tt>
--   in practice. The purpose of the <a>Pool</a> data structure is to help
--   inverting this function regardless. The idea is that addresses with
--   small indices <tt>0,1,â€¦</tt> are <a>Used</a> before addresses with
--   larger indices; specifically, only less than <a>gap</a> many addresses
--   in sequence may be <a>Unused</a> before the next <a>Used</a> address.
--   This usage scheme restricts the search space considerably and allows
--   us to practically invert the <a>addressFromIx</a> function.
addressFromIx :: Pool addr ix -> ix -> addr

-- | Partial, cached inverse of the <a>addressFromIx</a>. This map contains
--   all cached addresses <tt>addr</tt>, their corresponding indices
--   <tt>ix</tt>, and whether they are <a>Used</a> or <a>Unused</a>. See
--   <a>prop_sequence</a>.
addresses :: Pool addr ix -> Map addr (ix, AddressState)

-- | Sorted list of all addresses that are marked <a>Used</a> in the pool.
usedAddresses :: Pool addr ix -> [addr]

-- | The pool gap determines how <a>Used</a> and <a>Unused</a> have to be
--   distributed. See <a>prop_gap</a> and <a>prop_fresh</a>.
gap :: Pool addr ix -> Int

-- | Look up an address in the pool.
lookup :: Ord addr => addr -> Pool addr ix -> Maybe ix

-- | Number of addresses cached in the pool.
size :: Pool addr ix -> Int

-- | Given an index <tt>ix</tt>, return the enumerated successor <tt>Just
--   (succ ix)</tt> as long as the address corresponding to this successor
--   is still in the pool.
--   
--   This function is useful for address discovery in a light client
--   setting, where the discovery procedure is: Start with index <tt>ix =
--   0</tt>, query the corresponding address in an explorer,
--   <tt>update</tt> address pool and repeat with <tt>successor ix</tt>
--   until the latter returns <a>Nothing</a>. According to the BIP-44
--   standard, the account may not contain any other addresses than the
--   ones discovered.
--   
--   This function is not useful for generating change addresses, as it
--   does not take <a>Used</a> or <a>Unused</a> status into account.
successor :: Enum ix => Pool addr ix -> ix -> Maybe ix

-- | Create a new address pool.
new :: (Ord addr, Enum ix) => (ix -> addr) -> Int -> Pool addr ix

-- | Replace the collection of addresses in a pool, but only if this
--   collection satisfies the necessary invariants such as
--   <a>prop_sequence</a> etc.
load :: (Ord addr, Ord ix, Enum ix) => Pool addr ix -> Map addr (ix, AddressState) -> Maybe (Pool addr ix)

-- | Update an address to the <a>Used</a> status and create new
--   <a>Unused</a> addresses in order to satisfy <a>prop_fresh</a>.
--   
--   Does nothing if the address was not in the pool.
update :: (Ord addr, Enum ix) => addr -> Pool addr ix -> Pool addr ix

-- | Remove all previously discovered addresses, i.e. create a new pool
--   with the same <a>addressFromIx</a> and <a>gap</a> as the old pool.
clear :: (Ord addr, Enum ix) => Pool addr ix -> Pool addr ix

-- | Discover transactions and addresses by using an efficient query
--   <tt>addr -&gt; m txs</tt> and an address pool.
discover :: (Enum ix, Ord addr, Monad m, Monoid txs, Eq txs) => (addr -> m txs) -> Pool addr ix -> m (txs, Pool addr ix)

-- | Replace the collection of addresses in a pool, but skips checking the
--   invariants.
loadUnsafe :: Pool addr ix -> Map addr (ix, AddressState) -> Pool addr ix

-- | Internal invariant: The indices of the addresses in a pool form a
--   finite sequence beginning with <a>fromEnum</a><tt> 0</tt>.
prop_sequence :: (Ord ix, Enum ix) => Pool addr ix -> Bool

-- | Internal invariant: If we order the <a>addresses</a> by their indices,
--   then there are always <i>less than</i> <a>gap</a> many <a>Unused</a>
--   addresses between two consecutive <a>Used</a> addresses, or before the
--   first <a>Used</a> address.
prop_gap :: Ord ix => Pool addr ix -> Bool

-- | Internal invariant: If we order the <a>addresses</a> by their indices,
--   there are exactly <a>gap</a> many <a>Unused</a> addresses after the
--   last <a>Used</a> address.
prop_fresh :: Ord ix => Pool addr ix -> Bool

-- | Internal invariant: All <a>addresses</a> in the pool have been
--   generated from their index via the pool <a>addressFromIx</a>.
prop_fromIx :: Eq addr => Pool addr ix -> Bool

-- | Internal invariant: The pool satisfies all invariants above.
prop_consistent :: (Ord ix, Enum ix, Eq addr) => Pool addr ix -> Bool
instance GHC.Generics.Generic (Cardano.Wallet.Address.Pool.Pool addr ix)
instance (Control.DeepSeq.NFData addr, Control.DeepSeq.NFData ix) => Control.DeepSeq.NFData (Cardano.Wallet.Address.Pool.Pool addr ix)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Address.Pool.Pool addr ix)
instance (GHC.Show.Show addr, GHC.Show.Show ix) => GHC.Show.Show (Cardano.Wallet.Address.Pool.Pool addr ix)

module Cardano.Wallet.Primitive.Types.Address.Gen
genAddress :: Gen Address
shrinkAddress :: Address -> [Address]

-- | Computes the parity of an address.
--   
--   Parity is defined in the following way:
--   
--   <ul>
--   <li>even-parity address: an address with a pop count (Hamming weight)
--   that is even.</li>
--   <li>odd-parity address: an address with a pop count (Hamming weight)
--   that is odd.</li>
--   </ul>
--   
--   Examples of even-parity and odd-parity addresses:
--   
--   <ul>
--   <li>0b00000000 : even (Hamming weight = 0)</li>
--   <li>0b00000001 : odd (Hamming weight = 1)</li>
--   <li>0b00000010 : odd (Hamming weight = 1)</li>
--   <li>0b00000011 : even (Hamming weight = 2)</li>
--   <li>0b00000100 : odd (Hamming weight = 1)</li>
--   <li>...</li>
--   <li>0b11111110 : odd (Hamming weight = 7)</li>
--   <li>0b11111111 : even (Hamming weight = 8)</li>
--   </ul>
addressParity :: Address -> Parity

-- | Represents the parity of a value (whether the value is even or odd).
data Parity
Even :: Parity
Odd :: Parity
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Address.Gen.Parity
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Address.Gen.Parity


-- | Provides the <a>ProtocolMagic</a> type and related constants.
module Cardano.Wallet.Primitive.Types.ProtocolMagic

-- | Magic constant associated with a given network.
newtype ProtocolMagic
ProtocolMagic :: Int32 -> ProtocolMagic
[getProtocolMagic] :: ProtocolMagic -> Int32

-- | Hard-coded protocol magic for the Byron MainNet
mainnetMagic :: ProtocolMagic

-- | Derive testnet magic from a type-level Nat
testnetMagic :: forall pm. KnownNat pm => ProtocolMagic
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.ProtocolMagic.ProtocolMagic
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.ProtocolMagic.ProtocolMagic
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.ProtocolMagic.ProtocolMagic
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.ProtocolMagic.ProtocolMagic
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.ProtocolMagic.ProtocolMagic
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.ProtocolMagic.ProtocolMagic
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.ProtocolMagic.ProtocolMagic
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.ProtocolMagic.ProtocolMagic

module Cardano.Wallet.Primitive.Types.TokenQuantity

-- | Represents an integral quantity of tokens.
--   
--   At present, we use <a>Natural</a> as our underlying type, as the only
--   use case for these quantities is to be included in token bundles held
--   within transaction outputs, and these must never be negative.
--   
--   When we build support for minting and burning of tokens, we may wish
--   to parameterize this type and allow it to be instantiated with
--   <a>Integer</a>.
newtype TokenQuantity
TokenQuantity :: Natural -> TokenQuantity
[unTokenQuantity] :: TokenQuantity -> Natural
zero :: TokenQuantity
add :: TokenQuantity -> TokenQuantity -> TokenQuantity

-- | Subtracts the second token quantity from the first.
--   
--   Returns <a>Nothing</a> if the first quantity is less than the second
--   quantity.
subtract :: TokenQuantity -> TokenQuantity -> Maybe TokenQuantity

-- | Finds the predecessor of a given token quantity.
--   
--   Returns <a>Nothing</a> if the given quantity is zero.
pred :: TokenQuantity -> Maybe TokenQuantity

-- | Finds the predecessor of a given token quantity.
--   
--   Returns <a>zero</a> if the given quantity is <a>zero</a>.
--   
--   Satisfies the following property:
--   
--   <pre>
--   &gt;&gt;&gt; predZero x == x `difference` 1
--   </pre>
predZero :: TokenQuantity -> TokenQuantity

-- | Finds the successor of a given token quantity.
succ :: TokenQuantity -> TokenQuantity

-- | Subtracts the second token quantity from the first.
--   
--   Returns <a>zero</a> if the first quantity is less than the second
--   quantity.
difference :: TokenQuantity -> TokenQuantity -> TokenQuantity

-- | Computes the equipartition of a token quantity into <tt>n</tt> smaller
--   quantities.
--   
--   An <i>equipartition</i> of a token quantity is a <i>partition</i> of
--   that quantity into <tt>n</tt> smaller quantities whose values differ
--   by no more than 1.
--   
--   The resultant list is sorted in ascending order.
equipartition :: TokenQuantity -> NonEmpty a -> NonEmpty TokenQuantity

-- | Partitions a token quantity into a number of parts, where the size of
--   each part is proportional (modulo rounding) to the size of its
--   corresponding element in the given list of weights, and the number of
--   parts is equal to the number of weights.
--   
--   Returns <a>Nothing</a> if the sum of weights is equal to zero.
partition :: TokenQuantity -> NonEmpty TokenQuantity -> Maybe (NonEmpty TokenQuantity)

-- | Partitions a token quantity into a number of parts, where the size of
--   each part is proportional (modulo rounding) to the size of its
--   corresponding element in the given list of weights, and the number of
--   parts is equal to the number of weights.
--   
--   This function always satisfies the following properties:
--   
--   <pre>
--   fold   (partitionDefault q ws) == c
--   </pre>
--   
--   <pre>
--   length (partitionDefault q ws) == length ws
--   </pre>
--   
--   If the sum of weights is equal to zero, then this function returns an
--   <a>equipartition</a> satisfying the following property:
--   
--   <pre>
--   partitionDefault q ws == equipartition q ws
--   </pre>
partitionDefault :: TokenQuantity -> NonEmpty TokenQuantity -> NonEmpty TokenQuantity
isNonZero :: TokenQuantity -> Bool
isZero :: TokenQuantity -> Bool

-- | Subtracts the second token quantity from the first.
--   
--   Pre-condition: the first quantity is not less than the second
--   quantity.
--   
--   Throws a run-time exception if the pre-condition is violated.
unsafeSubtract :: TokenQuantity -> TokenQuantity -> TokenQuantity
instance Data.Hashable.Class.Hashable Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity

module Cardano.Wallet.Primitive.Types.TokenQuantity.Gen
chooseTokenQuantity :: (TokenQuantity, TokenQuantity) -> Gen TokenQuantity
genTokenQuantity :: Gen TokenQuantity
genTokenQuantityPositive :: Gen TokenQuantity

-- | Generates token quantities across the full range of what may be
--   encoded within a single on-chain token bundle.
--   
--   This generator has a slight bias towards the limits of the range, but
--   otherwise generates values uniformly across the whole range.
--   
--   This can be useful when testing roundtrip conversions between
--   different types.
genTokenQuantityFullRange :: Gen TokenQuantity
shrinkTokenQuantity :: TokenQuantity -> [TokenQuantity]
shrinkTokenQuantityPositive :: TokenQuantity -> [TokenQuantity]
shrinkTokenQuantityFullRange :: TokenQuantity -> [TokenQuantity]

-- | Partitions a token quantity randomly into a given number of parts.
--   
--   Satisfies the following properties:
--   
--   <pre>
--   forAll (genTokenQuantityPartition q i) $ (==       q) . fold
--   </pre>
--   
--   <pre>
--   forAll (genTokenQuantityPartition q i) $ (== max 1 i) . length
--   </pre>
genTokenQuantityPartition :: TokenQuantity -> Int -> Gen (NonEmpty TokenQuantity)


-- | General utility functions.
module Cardano.Wallet.Util

-- | Request a CallStack.
--   
--   NOTE: The implicit parameter <tt>?callStack :: CallStack</tt> is an
--   implementation detail and <b>should not</b> be considered part of the
--   <a>CallStack</a> API, we may decide to change the implementation in
--   the future.
type HasCallStack = ?callStack :: CallStack

-- | Calls the <a>error</a> function, which will usually crash the program.
internalError :: HasCallStack => Builder -> a

-- | Take the first <a>Just</a> from a list of <a>Maybe</a>, or die trying.
--   There is no alternative.
tina :: HasCallStack => Builder -> [Maybe a] -> a

-- | Checks whether or not an invariant holds, by applying the given
--   predicate to the given value.
--   
--   If the invariant does not hold (indicated by the predicate function
--   returning <a>False</a>), throws an error with the specified message.
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [1,2,3] (not . null)
--   [1, 2, 3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [] (not . null)
--   *** Exception: not empty
--   </pre>
invariant :: HasCallStack => String -> a -> (a -> Bool) -> a

-- | Tests whether an <tt>Exception</tt> was caused by
--   <a>internalError</a>.
isInternalError :: ErrorCall -> Maybe String

-- | Evaluates a pure expression to WHNF and handles any occurrence of
--   <a>internalError</a>.
--   
--   This is intended for use in testing. Don't use this in application
--   code -- that's what normal IO exceptions are for.
tryInternalError :: MonadUnliftIO m => a -> m (Either String a)

-- | A polymorphic wrapper type with a custom show instance to display data
--   through <a>Buildable</a> instances.
newtype ShowFmt a
ShowFmt :: a -> ShowFmt a
[unShowFmt] :: ShowFmt a -> a

-- | Map a function to the first element of a list. Does nothing if the
--   list is empty.
mapFirst :: (a -> a) -> [a] -> [a]

-- | Effectfully modify the state of a state-monad transformer stack.
modifyM :: forall m s. Monad m => (s -> m s) -> StateT s m ()
uriToText :: URI -> Text
parseURI :: Text -> Either TextDecodingError URI
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Util.ShowFmt a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Util.ShowFmt a)
instance GHC.Generics.Generic (Cardano.Wallet.Util.ShowFmt a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Wallet.Util.ShowFmt a)
instance Formatting.Buildable.Buildable a => GHC.Show.Show (Cardano.Wallet.Util.ShowFmt a)


-- | Types and functions relating to hash values.
module Cardano.Wallet.Primitive.Types.Hash
newtype Hash (tag :: Symbol)
Hash :: ByteString -> Hash (tag :: Symbol)
[getHash] :: Hash (tag :: Symbol) -> ByteString
hashFromText :: forall t. KnownSymbol t => Int -> Text -> Either TextDecodingError (Hash t)

-- | Constructs a hash that is good enough for testing.
mockHash :: Show a => a -> Hash whatever
instance Data.Hashable.Class.Hashable (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance GHC.Read.Read (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance Data.ByteArray.Types.ByteArrayAccess (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance NoThunks.Class.NoThunks (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance Data.Text.Class.ToText (Cardano.Wallet.Primitive.Types.Hash.Hash tag)
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash.Hash "Tx")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash.Hash "Account")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash.Hash "Genesis")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash.Hash "Block")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash.Hash "BlockHeader")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash.Hash "RewardAccount")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash.Hash "TokenPolicy")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash.Hash "Datum")
instance Data.Text.Class.FromText (Cardano.Wallet.Primitive.Types.Hash.Hash "VerificationKey")

module Cardano.Wallet.Primitive.Types.TokenPolicy

-- | Token policy identifiers, represented by the hash of the monetary
--   policy script.
newtype TokenPolicyId

-- | Construct a <a>TokenPolicyId</a> without any validation.
UnsafeTokenPolicyId :: Hash "TokenPolicy" -> TokenPolicyId
[$sel:unTokenPolicyId:UnsafeTokenPolicyId] :: TokenPolicyId -> Hash "TokenPolicy"

-- | Token names, defined by the monetary policy script.
newtype TokenName

-- | Construct a <a>TokenName</a> without any validation.
UnsafeTokenName :: ByteString -> TokenName
[$sel:unTokenName:UnsafeTokenName] :: TokenName -> ByteString

-- | Construct a <a>TokenName</a>, validating that the length does not
--   exceed <a>tokenNameMaxLength</a>.
mkTokenName :: ByteString -> Either String TokenName

-- | The empty asset name.
--   
--   Asset names may be empty, where a monetary policy script only mints a
--   single asset, or where one asset should be considered as the "default"
--   token for the policy.
nullTokenName :: TokenName

-- | The maximum length of a valid token name.
tokenNameMaxLength :: Int
newtype TokenFingerprint
UnsafeTokenFingerprint :: Text -> TokenFingerprint
[$sel:unTokenFingerprint:UnsafeTokenFingerprint] :: TokenFingerprint -> Text

-- | Construct a fingerprint from a <a>TokenPolicyId</a> and
--   <a>TokenName</a>. The fingerprint is not necessarily unique, but can
--   be used in user-facing interfaces as a comparison mechanism.
mkTokenFingerprint :: TokenPolicyId -> TokenName -> TokenFingerprint

-- | Information about an asset, from a source external to the chain.
data AssetMetadata
AssetMetadata :: Text -> Text -> Maybe Text -> Maybe AssetURL -> Maybe AssetLogo -> Maybe AssetDecimals -> AssetMetadata
[$sel:name:AssetMetadata] :: AssetMetadata -> Text
[$sel:description:AssetMetadata] :: AssetMetadata -> Text
[$sel:ticker:AssetMetadata] :: AssetMetadata -> Maybe Text
[$sel:url:AssetMetadata] :: AssetMetadata -> Maybe AssetURL
[$sel:logo:AssetMetadata] :: AssetMetadata -> Maybe AssetLogo
[$sel:decimals:AssetMetadata] :: AssetMetadata -> Maybe AssetDecimals

-- | The validated URL for the asset.
newtype AssetURL
AssetURL :: URI -> AssetURL
[$sel:unAssetURL:AssetURL] :: AssetURL -> URI

-- | Specify an asset logo as an image data payload
newtype AssetLogo
AssetLogo :: ByteString -> AssetLogo
[$sel:unAssetLogo:AssetLogo] :: AssetLogo -> ByteString
newtype AssetDecimals
AssetDecimals :: Int -> AssetDecimals
[$sel:unAssetDecimals:AssetDecimals] :: AssetDecimals -> Int
validateMetadataDecimals :: AssetDecimals -> Either String AssetDecimals
validateMetadataName :: Text -> Either String Text
validateMetadataTicker :: Text -> Either String Text
validateMetadataDescription :: Text -> Either String Text
validateMetadataURL :: Text -> Either String AssetURL
validateMetadataLogo :: AssetLogo -> Either String AssetLogo
instance Data.Hashable.Class.Hashable Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Data.Hashable.Class.Hashable Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Data.Hashable.Class.Hashable Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenPolicy.AssetLogo
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenPolicy.AssetLogo
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenPolicy.AssetLogo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenPolicy.AssetLogo
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenPolicy.AssetMetadata
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenPolicy.AssetMetadata
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenPolicy.AssetMetadata
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenPolicy.AssetMetadata
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenPolicy.AssetMetadata
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenPolicy.AssetLogo
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId

module Cardano.Wallet.Primitive.Types.TokenPolicy.Gen
genTokenName :: Gen TokenName
genTokenNameLargeRange :: Gen TokenName
genTokenPolicyId :: Gen TokenPolicyId
genTokenPolicyIdLargeRange :: Gen TokenPolicyId
shrinkTokenName :: TokenName -> [TokenName]
shrinkTokenPolicyId :: TokenPolicyId -> [TokenPolicyId]
testTokenNames :: [TokenName]
testTokenPolicyIds :: [TokenPolicyId]
mkTokenName :: Char -> TokenName
mkTokenPolicyId :: Char -> TokenPolicyId


-- | Provides the <a>TokenMap</a> type, which represents a map of named
--   non-ada token quantities scoped by token policy.
--   
--   The <a>TokenMap</a> type does not provide a way to store ada
--   quantities. If you also need to store ada quantities, use the
--   <tt>TokenBundle</tt> type.
--   
--   This module is meant to be imported qualified. For example:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Cardano.Wallet.Primitive.Types.TokenMap as TM
--   </pre>
module Cardano.Wallet.Primitive.Types.TokenMap

-- | A map of named token quantities, grouped by token policy.
--   
--   The token map data structure has an important invariant: all token
--   quantities held within a map are non-zero.
--   
--   This means that:
--   
--   <ul>
--   <li>using the <a>setQuantity</a> function to add a zero-valued
--   quantity to a map is equivalent to applying the identity operation to
--   that map.</li>
--   <li>using the <a>setQuantity</a> function to change an existing
--   quantity to zero is equivalent to removing that quantity from the
--   map.</li>
--   </ul>
--   
--   As a consequence of this invariant, the token map data structure is
--   always in its canonical form: we can perform an equality check without
--   needing any extra canonicalization steps.
data TokenMap

-- | A combination of a token policy identifier and a token name that can
--   be used as a compound identifier.
data AssetId
AssetId :: !TokenPolicyId -> !TokenName -> AssetId
[$sel:tokenPolicyId:AssetId] :: AssetId -> !TokenPolicyId
[$sel:tokenName:AssetId] :: AssetId -> !TokenName

-- | The empty token map.
empty :: TokenMap

-- | Creates a singleton token map with just one token quantity.
--   
--   If the specified token quantity is zero, then the resultant map will
--   be equal to the <a>empty</a> map.
singleton :: AssetId -> TokenQuantity -> TokenMap

-- | Creates a token map from a flat list.
--   
--   If a token name appears more than once in the list under the same
--   policy, its associated quantities will be added together in the
--   resultant map.
fromFlatList :: [(AssetId, TokenQuantity)] -> TokenMap

-- | Creates a token map from a nested list.
--   
--   If a token name appears more than once in the list under the same
--   policy, its associated quantities will be added together in the
--   resultant map.
fromNestedList :: [(TokenPolicyId, NonEmpty (TokenName, TokenQuantity))] -> TokenMap

-- | Creates a token map from a nested map.
fromNestedMap :: Map TokenPolicyId (NonEmptyMap TokenName TokenQuantity) -> TokenMap

-- | Converts a token map to a flat list.
toFlatList :: TokenMap -> [(AssetId, TokenQuantity)]

-- | Converts a token map to a nested list.
toNestedList :: TokenMap -> [(TokenPolicyId, NonEmpty (TokenName, TokenQuantity))]

-- | Converts a token map to a nested map.
toNestedMap :: TokenMap -> Map TokenPolicyId (NonEmptyMap TokenName TokenQuantity)
filter :: (AssetId -> Bool) -> TokenMap -> TokenMap

-- | Adds one token map to another.
add :: TokenMap -> TokenMap -> TokenMap

-- | Subtracts the second token map from the first.
--   
--   Returns <a>Nothing</a> if the second map is not less than or equal to
--   the first map when compared with the <a>leq</a> function.
subtract :: TokenMap -> TokenMap -> Maybe TokenMap

-- | Analogous to <tt>Set.difference</tt>, return the difference between
--   two token maps.
--   
--   The following property holds: prop&gt; x <a>leq</a> (x
--   <a>difference</a> y) <a>add</a> y
--   
--   Note that there's a <a>leq</a> rather than equality, which we'd expect
--   if this was subtraction of integers. I.e.
--   
--   <pre>
--   &gt;&gt;&gt; (0 - 1) + 1
--   0
--   </pre>
--   
--   whereas
--   
--   <pre>
--   &gt;&gt;&gt; let oneToken = singleton aid (TokenQuantity 1)
--   
--   &gt;&gt;&gt; (mempty `difference` oneToken) `add` oneToken
--   oneToken
--   </pre>
difference :: TokenMap -> TokenMap -> TokenMap

-- | Computes the intersection of two token maps.
--   
--   Analogous to <tt>Set.intersection</tt>.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; m1 = [("a", 1), ("b", 2), ("c", 3)          ]
--   
--   &gt;&gt;&gt; m2 = [          ("b", 3), ("c", 2), ("d", 1)]
--   
--   &gt;&gt;&gt; intersection m1 m2
--            [          ("b", 2), ("c", 2)          ]
--   </pre>
intersection :: TokenMap -> TokenMap -> TokenMap

-- | Returns the number of unique assets in a token map.
size :: TokenMap -> Int

-- | Returns true if and only if the given map is empty.
isEmpty :: TokenMap -> Bool

-- | Returns true if and only if the given map is not empty.
isNotEmpty :: TokenMap -> Bool

-- | Gets the quantity associated with a given asset.
--   
--   If the given map does not have an entry for the specified asset, this
--   function returns a value of zero.
getQuantity :: TokenMap -> AssetId -> TokenQuantity

-- | Updates the quantity associated with a given asset.
--   
--   If the given quantity is zero, the resultant map will not have an
--   entry for the given asset.
setQuantity :: TokenMap -> AssetId -> TokenQuantity -> TokenMap

-- | Returns true if and only if the given map has a non-zero quantity for
--   the given asset.
hasQuantity :: TokenMap -> AssetId -> Bool

-- | Uses the specified function to adjust the quantity associated with a
--   given asset.
--   
--   If the result of adjusting the quantity is equal to zero, the
--   resultant map will not have an entry for the given asset.
adjustQuantity :: TokenMap -> AssetId -> (TokenQuantity -> TokenQuantity) -> TokenMap

-- | Removes the quantity associated with the given asset.
--   
--   This is equivalent to calling <a>setQuantity</a> with a value of zero.
removeQuantity :: TokenMap -> AssetId -> TokenMap

-- | Get the largest quantity from this map.
maximumQuantity :: TokenMap -> TokenQuantity

-- | Partitions a token map into <tt>n</tt> smaller maps, where the asset
--   sets of the resultant maps are disjoint.
--   
--   In the resultant maps, the smallest asset set size and largest asset
--   set size will differ by no more than 1.
--   
--   The quantities of each asset are unchanged.
equipartitionAssets :: TokenMap -> NonEmpty a -> NonEmpty TokenMap

-- | Partitions a token map into <tt>n</tt> smaller maps, where the
--   quantity of each token is equipartitioned across the resultant maps.
--   
--   In the resultant maps, the smallest quantity and largest quantity of a
--   given token will differ by no more than 1.
--   
--   The resultant list is sorted into ascending order when maps are
--   compared with the <a>leq</a> function.
equipartitionQuantities :: TokenMap -> NonEmpty a -> NonEmpty TokenMap

-- | Partitions a token map into <tt>n</tt> smaller maps, where the
--   quantity of each token is equipartitioned across the resultant maps,
--   with the goal that no token quantity in any of the resultant maps
--   exceeds the given upper bound.
--   
--   The value <tt>n</tt> is computed automatically, and is the minimum
--   value required to achieve the goal that no token quantity in any of
--   the resulting maps exceeds the maximum allowable token quantity.
equipartitionQuantitiesWithUpperBound :: TokenMap -> TokenQuantity -> NonEmpty TokenMap

-- | Defines a lexicographic ordering.
newtype Lexicographic a
Lexicographic :: a -> Lexicographic a
[$sel:unLexicographic:Lexicographic] :: Lexicographic a -> a

-- | When used with the <a>Buildable</a> or <a>ToJSON</a> instances,
--   provides a flat serialization style, where token quantities are paired
--   with their asset identifiers.
newtype Flat a
Flat :: a -> Flat a
[$sel:getFlat:Flat] :: Flat a -> a

-- | When used with the <a>Buildable</a> or <a>ToJSON</a> instances,
--   provides a nested serialization style, where token quantities are
--   grouped by policy identifier.
newtype Nested a
Nested :: a -> Nested a
[$sel:getNested:Nested] :: Nested a -> a
getAssets :: TokenMap -> Set AssetId
mapAssetIds :: (AssetId -> AssetId) -> TokenMap -> TokenMap

-- | Subtracts the second token map from the first.
--   
--   Pre-condition: the second map is less than or equal to the first map
--   when compared with the <a>leq</a> function.
--   
--   Throws a run-time exception if the pre-condition is violated.
unsafeSubtract :: TokenMap -> TokenMap -> TokenMap
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenMap.TokenMap
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.TokenMap.TokenMap
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenMap.TokenMap
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenMap.TokenMap
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenMap.AssetId
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.TokenMap.AssetId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenMap.AssetId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenMap.AssetId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenMap.AssetId
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Primitive.Types.TokenMap.Lexicographic a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.TokenMap.Lexicographic a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Primitive.Types.TokenMap.Flat a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.TokenMap.Flat a)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.TokenMap.Flat a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.TokenMap.Flat a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Primitive.Types.TokenMap.Nested a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.TokenMap.Nested a)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.TokenMap.Nested a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.TokenMap.Nested a)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenMap.FlatAssetQuantity
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenMap.NestedTokenQuantity
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenMap.NestedMapEntry
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Primitive.Types.TokenMap.Nested Cardano.Wallet.Primitive.Types.TokenMap.TokenMap)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Primitive.Types.TokenMap.Nested Cardano.Wallet.Primitive.Types.TokenMap.TokenMap)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.TokenMap.NestedMapEntry
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.TokenMap.NestedMapEntry
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.TokenMap.NestedTokenQuantity
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.TokenMap.NestedTokenQuantity
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Primitive.Types.TokenMap.Flat Cardano.Wallet.Primitive.Types.TokenMap.TokenMap)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Primitive.Types.TokenMap.Flat Cardano.Wallet.Primitive.Types.TokenMap.TokenMap)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.TokenMap.FlatAssetQuantity
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.TokenMap.FlatAssetQuantity
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.TokenMap.Nested Cardano.Wallet.Primitive.Types.TokenMap.TokenMap)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.TokenMap.Flat Cardano.Wallet.Primitive.Types.TokenMap.TokenMap)
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.TokenMap.Lexicographic Cardano.Wallet.Primitive.Types.TokenMap.TokenMap)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenMap.AssetId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenMap.TokenMap
instance Data.Hashable.Class.Hashable Cardano.Wallet.Primitive.Types.TokenMap.TokenMap
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.TokenMap.TokenMap
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.TokenMap.TokenMap
instance (TypeError ...) => GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenMap.TokenMap
instance Algebra.PartialOrd.PartialOrd Cardano.Wallet.Primitive.Types.TokenMap.TokenMap

module Cardano.Wallet.Primitive.Types.TokenMap.Gen
genAssetId :: Gen AssetId
genAssetIdLargeRange :: Gen AssetId
genTokenMap :: Gen TokenMap
genTokenMapSmallRange :: Gen TokenMap
shrinkAssetId :: AssetId -> [AssetId]
shrinkTokenMap :: TokenMap -> [TokenMap]
newtype AssetIdF
AssetIdF :: AssetId -> AssetIdF

-- | Partitions a token map randomly into a given number of parts.
--   
--   Satisfies the following properties:
--   
--   <pre>
--   forAll (genTokenMapPartition m i) $ (== m      ) . fold
--   </pre>
--   
--   <pre>
--   forAll (genTokenMapPartition m i) $ (== max 1 i) . length
--   </pre>
genTokenMapPartition :: TokenMap -> Int -> Gen (NonEmpty TokenMap)

-- | Like <a>genTokenMapPartition</a>, but with empty values removed from
--   the result.
genTokenMapPartitionNonNull :: TokenMap -> Int -> Gen [TokenMap]
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.TokenMap.Gen.AssetIdF
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenMap.Gen.AssetIdF
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenMap.Gen.AssetIdF
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenMap.Gen.AssetIdF
instance Test.QuickCheck.Function.Function Cardano.Wallet.Primitive.Types.TokenMap.Gen.AssetIdF
instance Test.QuickCheck.Arbitrary.CoArbitrary Cardano.Wallet.Primitive.Types.TokenMap.Gen.AssetIdF


-- | This module provides the <a>RewardAccount</a> data type.
module Cardano.Wallet.Primitive.Types.RewardAccount

-- | A reward account is used in group-type addresses for delegation.
--   
--   It is the public key of the account address.
newtype RewardAccount
RewardAccount :: ByteString -> RewardAccount
[unRewardAccount] :: RewardAccount -> ByteString
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount

module Cardano.Wallet.Primitive.Types.RewardAccount.Gen
genRewardAccount :: Gen RewardAccount
shrinkRewardAccount :: RewardAccount -> [RewardAccount]


-- | Template Haskell function for getting the git revision from the local
--   repo. This is a separate module due to the GHC stage restriction.
module Cardano.Wallet.Version.TH

-- | Git revision found by running <tt>git rev-parse</tt>. If <tt>git</tt>
--   could not be executed, then this will be an empty string.
gitRevFromGit :: Q Exp


-- | This module provides a utility for ordering concurrent actions via
--   locks.
module Control.Concurrent.Concierge

-- | At a <a>Concierge</a>, you can obtain a lock and enforce sequential
--   execution of concurrent <a>IO</a> actions.
--   
--   Back in the old days, hotel concierges used to give out keys. But
--   after the cryptocurrency revolution, they give out locks. :) (The term
--   <i>lock</i> is standard terminology in concurrent programming.)
data Concierge m lock

-- | Create a new <a>Concierge</a> that keeps track of locks.
newConcierge :: MonadSTM m => m (Concierge m lock)

-- | Obtain a lock from a <a>Concierge</a> and run an <a>IO</a> action.
--   
--   If the same (equal) lock is already taken at this <a>Concierge</a>,
--   the thread will be blocked until the lock becomes available.
--   
--   The action may throw a synchronous or asynchronous exception. In both
--   cases, the lock is returned to the concierge.
atomicallyWith :: (Ord lock, MonadIO m, MonadThrow m) => Concierge IO lock -> lock -> m a -> m a

-- | More polymorphic version of <a>atomicallyWith</a>.
atomicallyWithLifted :: (Ord lock, MonadSTM m, MonadThread m, MonadThrow n) => (forall b. m b -> n b) -> Concierge m lock -> lock -> n a -> n a


-- | <a>Unchecked</a> helps convert a checked exception (<a>ExceptT</a>)
--   into an unchecked exception (instance of the <a>Exception</a> class).
module Control.Monad.Exception.Unchecked
throwUnchecked :: (Monad m, Typeable e, Show e) => ExceptT e m b -> m b
catchUnchecked :: (MonadCatch m, Typeable e, Show e) => m a -> ExceptT e m a
throwSomeException :: Either SomeException t -> (t -> p) -> p
instance GHC.Show.Show e => GHC.Show.Show (Control.Monad.Exception.Unchecked.Unchecked e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Control.Monad.Exception.Unchecked.Unchecked e)
instance (Data.Typeable.Internal.Typeable e, GHC.Show.Show e) => GHC.Exception.Type.Exception (Control.Monad.Exception.Unchecked.Unchecked e)


-- | Common hashing functions used and re-used across the codebase.
module Crypto.Hash.Utils

-- | Hash a byte string using Blake2b with a 256-bit (32-byte) digest.
blake2b256 :: ByteArrayAccess a => a -> ByteString

-- | Hash a byte string using Blake2b with a 224-bit (28-byte) digest.
blake2b224 :: ByteArrayAccess a => a -> ByteString


-- | Support for verifying hashed passwords from the old wallet codebase.
--   
--   These passwords were encrypted by the <tt>scrypt</tt> package using
--   the following parameters: - logN = 14 - r = 8 - p = 1 - outputLength =
--   64
--   
--   It is possible to disable support for legacy password hashing by
--   compiling with the <tt>-scrypt</tt> Cabal flag.
module Cardano.Wallet.Primitive.Passphrase.Legacy

-- | Verify a wallet spending password using the legacy Byron scrypt
--   encryption scheme.
checkPassphrase :: Passphrase "encryption" -> PassphraseHash -> Maybe Bool
preparePassphrase :: Passphrase "user" -> Passphrase "encryption"

-- | This is for use by test cases only. Use only the implementation from
--   the <tt>scrypt</tt> package for application code.
checkPassphraseTestingOnly :: Passphrase "encryption" -> PassphraseHash -> Bool

-- | This is for use by test cases only.
encryptPassphraseTestingOnly :: MonadRandom m => Passphrase "encryption" -> m PassphraseHash
haveScrypt :: Bool

-- | Extract salt field from pipe-delimited password hash. This will fail
--   unless there are exactly 5 fields
getSalt :: PassphraseHash -> Maybe (Passphrase "salt")
genSalt :: MonadRandom m => m (Passphrase "salt")


-- | Hashing of wallet passwords.
module Cardano.Wallet.Primitive.Passphrase

-- | An encapsulated passphrase. The inner format is free, but the wrapper
--   helps readability in function signatures.
--   
--   Some type parameters in use are:
--   
--   <ul>
--   <li><tt>"user"</tt> - a passphrase entered by the user through the
--   API. The <a>FromText</a> instance enforces password length rules.</li>
--   <li><tt>"lenient"</tt> - like <tt>"user"</tt>, except without a
--   minimum length restriction in <a>FromText</a>.`</li>
--   <li><tt>"encryption"</tt> - the user's passphrase, transformed so that
--   it can be used as the key for encrypting wallet keys.</li>
--   <li><tt>"salt"</tt> - the random salt part of a hashed
--   passphrase.</li>
--   </ul>
newtype Passphrase (purpose :: Symbol)
Passphrase :: ScrubbedBytes -> Passphrase (purpose :: Symbol)
[unPassphrase] :: Passphrase (purpose :: Symbol) -> ScrubbedBytes
class PassphraseMinLength (purpose :: Symbol)

-- | Minimal Length for a passphrase, for lack of better validations
passphraseMinLength :: PassphraseMinLength purpose => Proxy purpose -> Int
class PassphraseMaxLength (purpose :: Symbol)

-- | Maximum length for a passphrase
passphraseMaxLength :: PassphraseMaxLength purpose => Proxy purpose -> Int
validatePassphrase :: forall purpose. (PassphraseMaxLength purpose, PassphraseMinLength purpose) => Text -> Either String (Passphrase purpose)
newtype PassphraseHash
PassphraseHash :: ScrubbedBytes -> PassphraseHash
[getPassphraseHash] :: PassphraseHash -> ScrubbedBytes

-- | A type to capture which encryption scheme should be used
data PassphraseScheme

-- | Legacy encryption scheme for passphrases
EncryptWithScrypt :: PassphraseScheme

-- | Encryption scheme used since cardano-wallet
EncryptWithPBKDF2 :: PassphraseScheme
currentPassphraseScheme :: PassphraseScheme
data WalletPassphraseInfo
WalletPassphraseInfo :: UTCTime -> PassphraseScheme -> WalletPassphraseInfo
[lastUpdatedAt] :: WalletPassphraseInfo -> UTCTime
[passphraseScheme] :: WalletPassphraseInfo -> PassphraseScheme

-- | Hashes a <a>Passphrase</a> into a format that is suitable for storing
--   on disk. It will always use the current scheme: pbkdf2-hmac-sha512.
encryptPassphrase :: MonadRandom m => Passphrase "user" -> m (PassphraseScheme, PassphraseHash)
encryptPassphrase' :: MonadRandom m => PassphraseScheme -> Passphrase "user" -> m PassphraseHash

-- | Check whether a <a>Passphrase</a> matches with a stored <tt>Hash</tt>
checkPassphrase :: PassphraseScheme -> Passphrase "user" -> PassphraseHash -> Either ErrWrongPassphrase ()

-- | Manipulation done on legacy passphrases before used for encryption.
preparePassphrase :: PassphraseScheme -> Passphrase "user" -> Passphrase "encryption"

-- | Re-encrypts a wallet private key with a new passphrase.
--   
--   <ul>
--   <li>*Important**: This function doesn't check that the old passphrase
--   is correct! Caller is expected to have already checked that. Using an
--   incorrect passphrase here will lead to very bad thing.</li>
--   </ul>
changePassphraseXPrv :: (PassphraseScheme, Passphrase "user") -> (PassphraseScheme, Passphrase "user") -> XPrv -> XPrv

-- | Re-encrypts a wallet private key with a new passphrase.
checkAndChangePassphraseXPrv :: MonadRandom m => ((PassphraseScheme, PassphraseHash), Passphrase "user") -> Passphrase "user" -> XPrv -> m (Either ErrWrongPassphrase ((PassphraseScheme, PassphraseHash), XPrv))

-- | Indicate a failure when checking for a given <a>Passphrase</a> match
data ErrWrongPassphrase
ErrWrongPassphrase :: ErrWrongPassphrase
ErrPassphraseSchemeUnsupported :: PassphraseScheme -> ErrWrongPassphrase

module Cardano.Wallet.Primitive.Passphrase.Gen
genUserPassphrase :: Gen (Passphrase "user")
shrinkUserPassphrase :: Passphrase "user" -> [Passphrase "user"]
genPassphraseScheme :: Gen PassphraseScheme
genEncryptionPassphrase :: Gen (Passphrase "encryption")


-- | Primitives for performing address derivation for some given schemes.
--   This is where most of the crypto happens in the wallet and, it is
--   quite important to ensure that the implementations match with other
--   Cardano wallets (like cardano-sl, Yoroi/Icarus, or cardano-cli)
--   
--   The actual implementations are in the following modules:
--   
--   <ul>
--   <li><a>Cardano.Wallet.Primitive.AddressDerivation.Shelley</a></li>
--   <li><a>Cardano.Wallet.Primitive.AddressDerivation.Byron</a></li>
--   </ul>
module Cardano.Wallet.Primitive.AddressDerivation

-- | Typically used as a phantom type parameter, a witness to the type of
--   the key being used.
--   
--   For example, <tt>key 'RootK XPrv</tt>, represents the private key at
--   the root of the HD hierarchy.
--   
--   According to BIP-0044 / CIP-1852, we have the following keys in our HD
--   hierarchy:
--   
--   <pre>
--   m | purpose' | cointype' | account' | role | address
--   </pre>
--   
--   Plus, we also have script keys (which are used in shared wallets) and
--   policy keys (which are used in minting and burning).
data Depth
RootK :: Depth
PurposeK :: Depth
CoinTypeK :: Depth
AccountK :: Depth
RoleK :: Depth
AddressK :: Depth
ScriptK :: Depth
PolicyK :: Depth

-- | A derivation index, with phantom-types to disambiguate derivation
--   type.
--   
--   <pre>
--   let accountIx = Index 'Hardened 'AccountK
--   let addressIx = Index 'Soft 'AddressK
--   </pre>
newtype Index (derivationType :: DerivationType) (level :: Depth)
Index :: Word32 -> Index (derivationType :: DerivationType) (level :: Depth)
[getIndex] :: Index (derivationType :: DerivationType) (level :: Depth) -> Word32

-- | Marker for addresses type engaged. We want to handle four cases here.
--   The first two are pertinent to UTxO accounting, next handles rewards
--   from participation in staking the last one is used for getting
--   verification keys used in scripts. (a) external chain is used for
--   addresses that are part of the <tt>advertised</tt> targets of a given
--   transaction (b) internal change is for addresses used to handle the
--   change of a the transaction within a given wallet (c) the addresses
--   for a reward account (d) used for keys used inside scripts
data Role
UtxoExternal :: Role
UtxoInternal :: Role
MutableAccount :: Role

-- | Bring a <a>Role</a> type back to the term-level. This requires a type
--   application and either a scoped type variable, or an explicit passing
--   of a <a>Role</a>.
--   
--   <pre>
--   &gt;&gt;&gt; roleVal @'UtxoExternal
--   UtxoExternal
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; roleVal @chain
--   ...
--   </pre>
roleVal :: forall (c :: Role). Typeable c => Role

-- | smart-constructor for getting a derivation index that refers to
--   external utxo.
utxoExternal :: Index 'Soft 'RoleK

-- | smart-constructor for getting a derivation index that refers to
--   internal utxo.
utxoInternal :: Index 'Soft 'RoleK

-- | smart-constructor for getting a derivation index that refers to stake
--   key level (a.k.a mutable account)
mutableAccount :: Index 'Soft 'RoleK
zeroAccount :: Index 'Soft 'AddressK

-- | Full path to the stake key. There's only one.
stakeDerivationPath :: DerivationPrefix -> NonEmpty DerivationIndex

-- | Type of derivation that should be used with the given indexes.
--   
--   In theory, we should only consider two derivation types: soft and
--   hard.
--   
--   However, historically, addresses in Cardano used to be generated
--   across the both soft and hard domain. We therefore introduce a
--   <a>WholeDomain</a> derivation type that is the exact union of
--   <a>Hardened</a> and <a>Soft</a>.
data DerivationType
Hardened :: DerivationType
Soft :: DerivationType
WholeDomain :: DerivationType

-- | An interface for doing hard derivations from the root private key
class HardDerivation (key :: Depth -> Type -> Type) where {
    type family AddressIndexDerivationType key :: DerivationType;
}

-- | Derives account private key from the given root private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAccountPrivateKey :: HardDerivation key => Passphrase "encryption" -> key 'RootK XPrv -> Index 'Hardened 'AccountK -> key 'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   It is preferred to use <a>deriveAddressPublicKey</a> whenever possible
--   to avoid having to manipulate passphrases and private keys.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAddressPrivateKey :: HardDerivation key => Passphrase "encryption" -> key 'AccountK XPrv -> Role -> Index (AddressIndexDerivationType key) 'AddressK -> key 'AddressK XPrv

-- | An interface for doing soft derivations from an account public key
class HardDerivation key => SoftDerivation (key :: Depth -> Type -> Type)

-- | Derives address public key from the given account public key, using
--   derivation scheme 2 (see <a>cardano-crypto</a> package for more
--   details).
--   
--   This is the preferred way of deriving new sequential address public
--   keys.
deriveAddressPublicKey :: SoftDerivation key => key 'AccountK XPub -> Role -> Index 'Soft 'AddressK -> key 'AddressK XPub

-- | Each <tt>SeqState</tt> is like a bucket of addresses associated with
--   an <tt>account</tt>. An <tt>account</tt> corresponds to a subset of an
--   HD tree as defined in BIP-0039.
--   
--   cardano-wallet implements two similar HD schemes on top of BIP-0039
--   that are:
--   
--   <ul>
--   <li>BIP-0044 (for so-called Icarus wallets)</li>
--   <li>CIP-1815 (for so-called Shelley and Jormungandr wallets)</li>
--   </ul>
--   
--   Both scheme works by considering 5 levels of derivation from an
--   initial root key (see also <a>Depth</a> from
--   Cardano.Wallet.Primitive.AddressDerivation). A SeqState keeps track of
--   indexes from the two last levels of a derivation branch. The
--   <a>DerivationPrefix</a> defines the first three indexes chosen for
--   this particular <tt>SeqState</tt>.
newtype DerivationPrefix
DerivationPrefix :: (Index 'Hardened 'PurposeK, Index 'Hardened 'CoinTypeK, Index 'Hardened 'AccountK) -> DerivationPrefix

-- | A thin wrapper around derivation indexes. This can be used to
--   represent derivation path as homogeneous lists of
--   <a>DerivationIndex</a>. This is slightly more convenient than having
--   to carry heterogeneous lists of 'Index depth type' and works fine
--   because:
--   
--   <ol>
--   <li>The <tt>depth</tt> matters not because what the depth captures is
--   actually the position of the index in that list. It makes sense to
--   carry at the type level when manipulating standalone indexes to avoid
--   mistakes, but when treating them as a part of a list it is
--   redundant.</li>
--   <li>The derivationType is captured by representing indexes as plain
--   Word32. The Soft / Hardened notation is for easing human-readability
--   but in the end, a soft index is simply a value &lt; 2^31, whereas a
--   "hardened" index is simply a value &gt;= 2^31. Therefore, instead of
--   representing indexes as derivationType + relative index within 0 and
--   2^31, we can represent them as just an index between 0 and 2^32, which
--   is what DerivationIndex does.</li>
--   </ol>
newtype DerivationIndex
DerivationIndex :: Word32 -> DerivationIndex
[getDerivationIndex] :: DerivationIndex -> Word32
liftIndex :: LiftIndex derivation => Index derivation level -> Index 'WholeDomain level
hashVerificationKey :: WalletKey key => KeyRole -> key depth XPub -> KeyHash

-- | A reward account is used in group-type addresses for delegation.
--   
--   It is the public key of the account address.
newtype RewardAccount
RewardAccount :: ByteString -> RewardAccount
[unRewardAccount] :: RewardAccount -> ByteString

-- | Derivation of a reward account, as a type-class because different
--   between key types (in particular, JÃ¶rmungandr vs Shelley).
class ToRewardAccount k
toRewardAccount :: ToRewardAccount k => k 'AddressK XPub -> RewardAccount
someRewardAccount :: ToRewardAccount k => SomeMnemonic -> (XPrv, RewardAccount, NonEmpty DerivationIndex)

-- | Derive a reward account from a root private key. It is agreed by
--   standard that every HD wallet will use only a single reward account.
--   This account is located into a special derivation path and uses the
--   first index of that path.
deriveRewardAccount :: (HardDerivation k, Bounded (Index (AddressIndexDerivationType k) 'AddressK)) => Passphrase "encryption" -> k 'RootK XPrv -> k 'AddressK XPrv

-- | Encode a <a>ByteString</a> in base16
hex :: ByteArrayAccess bin => bin -> ByteString

-- | Decode a <a>ByteString</a> from base16
fromHex :: ByteArray bout => ByteString -> Either String bout

-- | Available network options.
--   
--   <ul>
--   <li><tt>Mainnet</tt>: is a shortcut for quickly pointing to mainnet.
--   On Byron and Shelley, it assumes no discrimination. It has a known
--   magic and known genesis parameters.</li>
--   <li><tt>Testnet</tt>: can be used to identify any network that has a
--   custom genesis and, that requires _explicit_ network discrimination in
--   addresses. Genesis file needs to be passed explicitly when starting
--   the application.</li>
--   <li><tt>Staging</tt>: very much like testnet, but like mainnet,
--   assumes to no address discrimination. Genesis file needs to be passed
--   explicitly when starting the application.</li>
--   </ul>
data NetworkDiscriminant
Mainnet :: NetworkDiscriminant
Testnet :: Nat -> NetworkDiscriminant
Staging :: Nat -> NetworkDiscriminant
class NetworkDiscriminantVal (n :: NetworkDiscriminant)
networkDiscriminantVal :: NetworkDiscriminantVal n => Text

-- | Encoding of addresses for certain key types and backend targets.
class MkKeyFingerprint key Address => PaymentAddress (network :: NetworkDiscriminant) key

-- | Convert a public key to a payment <a>Address</a> valid for the given
--   network discrimination.
--   
--   Note that <a>paymentAddress</a> is ambiguous and requires therefore a
--   type application.
paymentAddress :: PaymentAddress network key => key 'AddressK XPub -> Address

-- | Lift a payment fingerprint back into a payment address.
liftPaymentAddress :: PaymentAddress network key => KeyFingerprint "payment" key -> Address
class PaymentAddress network key => DelegationAddress (network :: NetworkDiscriminant) key

-- | Convert a public key and a staking key to a delegation <a>Address</a>
--   valid for the given network discrimination. Funds sent to this address
--   will be delegated according to the delegation settings attached to the
--   delegation key.
--   
--   Note that <a>delegationAddress</a> is ambiguous and requires therefore
--   a type application.
delegationAddress :: DelegationAddress network key => key 'AddressK XPub -> key 'AddressK XPub -> Address

-- | Lift a payment fingerprint back into a delegation address.
liftDelegationAddress :: DelegationAddress network key => KeyFingerprint "payment" key -> key 'AddressK XPub -> Address

-- | The class of keys for which addresses are bounded in length.
class BoundedAddressLength key

-- | Returns the longest address that the wallet can generate for a given
--   key.
--   
--   This is useful in situations where we want to compute some function of
--   an output under construction (such as a minimum UTxO value), but don't
--   yet have convenient access to a real address.
--   
--   Please note that this address should:
--   
--   <ul>
--   <li>never be used for anything besides its length and validity
--   properties.</li>
--   <li>never be used as a payment target within a real transaction.</li>
--   </ul>
maxLengthAddressFor :: BoundedAddressLength key => Proxy key -> Address
class WalletKey (key :: Depth -> Type -> Type)

-- | Re-encrypt a private key using a different passphrase.
--   
--   <ul>
--   <li>*Important**: This function doesn't check that the old passphrase
--   is correct! Caller is expected to have already checked that. Using an
--   incorrect passphrase here will lead to very bad thing.</li>
--   </ul>
changePassphrase :: WalletKey key => (PassphraseScheme, Passphrase "user") -> (PassphraseScheme, Passphrase "user") -> key depth XPrv -> key depth XPrv

-- | Extract the public key part of a private key.
publicKey :: WalletKey key => key depth XPrv -> key depth XPub

-- | Hash a public key to some other representation.
digest :: (WalletKey key, HashAlgorithm a) => key depth XPub -> Digest a

-- | Get a short, human-readable string descriptor that uniquely identifies
--   the specified key type.
keyTypeDescriptor :: WalletKey key => Proxy key -> String

-- | Unwrap the <a>WalletKey</a> to use the <a>XPrv</a> or <a>XPub</a>.
getRawKey :: WalletKey key => key depth raw -> raw

-- | Lift <a>XPrv</a> or <a>XPub</a> to <a>WalletKey</a>.
liftRawKey :: WalletKey key => raw -> key depth raw

-- | Operations for saving a private key into a database, and restoring it
--   from a database. The keys should be encoded in hexadecimal strings.
class PersistPrivateKey (key :: Type -> Type)

-- | Convert a private key and its password hash into hexadecimal strings
--   suitable for storing in a text file or database column.
serializeXPrv :: PersistPrivateKey key => (key XPrv, PassphraseHash) -> (ByteString, ByteString)

-- | The reverse of <a>serializeXPrv</a>. This may fail if the inputs are
--   not valid hexadecimal strings, or if the key is of the wrong length.
unsafeDeserializeXPrv :: PersistPrivateKey key => (ByteString, ByteString) -> (key XPrv, PassphraseHash)

-- | Operations for saving a public key into a database, and restoring it
--   from a database. The keys should be encoded in hexadecimal strings.
class PersistPublicKey (key :: Type -> Type)

-- | Convert a private key and its password hash into hexadecimal strings
--   suitable for storing in a text file or database column.
serializeXPub :: PersistPublicKey key => key XPub -> ByteString

-- | Convert a public key into hexadecimal strings suitable for storing in
--   a text file or database column.
unsafeDeserializeXPub :: PersistPublicKey key => ByteString -> key XPub

-- | Produce <a>KeyFingerprint</a> for existing types. A fingerprint here
--   uniquely identifies part of an address. It can refer to either the
--   payment key or, if any, the delegation key of an address.
--   
--   The fingerprint obeys the following rules:
--   
--   <ul>
--   <li>If two addresses are the same, then they have the same
--   fingerprints</li>
--   <li>It is possible to lift the fingerprint back into an address</li>
--   </ul>
--   
--   This second rule pretty much fixes what can be chosen as a fingerprint
--   for various key types:
--   
--   <ol>
--   <li>For <tt>ByronKey</tt>, it can only be the address itself!</li>
--   <li>For <tt>ShelleyKey</tt>, then the "payment" fingerprint refers to
--   the payment key within a single or grouped address.</li>
--   </ol>
class Show from => MkKeyFingerprint (key :: Depth -> Type -> Type) from
paymentKeyFingerprint :: MkKeyFingerprint key from => from -> Either (ErrMkKeyFingerprint key from) (KeyFingerprint "payment" key)
data ErrMkKeyFingerprint key from
ErrInvalidAddress :: from -> Proxy key -> ErrMkKeyFingerprint key from

-- | Something that uniquely identifies a public key. Typically, a hash of
--   that key or the key itself.
newtype KeyFingerprint (s :: Symbol) key
KeyFingerprint :: ByteString -> KeyFingerprint (s :: Symbol) key
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.AddressDerivation.Role
instance GHC.Classes.Ord Cardano.Wallet.Primitive.AddressDerivation.Role
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.Role
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.Role
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDerivation.Role
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.DerivationIndex
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDerivation.DerivationIndex
instance GHC.Classes.Ord Cardano.Wallet.Primitive.AddressDerivation.DerivationIndex
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.DerivationIndex
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Classes.Ord Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance forall (s :: GHC.Types.Symbol) k (key :: k). GHC.Classes.Ord (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint s key)
instance forall (s :: GHC.Types.Symbol) k (key :: k). GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint s key)
instance forall (s :: GHC.Types.Symbol) k (key :: k). GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint s key)
instance forall (s :: GHC.Types.Symbol) k (key :: k). GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint s key)
instance forall k (key :: k) from. GHC.Classes.Eq from => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.ErrMkKeyFingerprint key from)
instance forall k (key :: k) from. GHC.Show.Show from => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.ErrMkKeyFingerprint key from)
instance Cardano.Wallet.Primitive.AddressDerivation.DelegationAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet k => Cardano.Wallet.Primitive.AddressDerivation.DelegationAddress ('Cardano.Wallet.Primitive.AddressDerivation.Staging pm) k
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet k => Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress ('Cardano.Wallet.Primitive.AddressDerivation.Staging pm) k
instance forall k (s :: GHC.Types.Symbol) (key :: k). Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint s key)
instance Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminantVal 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet
instance GHC.TypeNats.KnownNat pm => Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminantVal ('Cardano.Wallet.Primitive.AddressDerivation.Testnet pm)
instance GHC.TypeNats.KnownNat pm => Cardano.Wallet.Primitive.AddressDerivation.NetworkDiscriminantVal ('Cardano.Wallet.Primitive.AddressDerivation.Staging pm)
instance Cardano.Wallet.Primitive.AddressDerivation.LiftIndex 'Cardano.Wallet.Primitive.AddressDerivation.Hardened
instance Cardano.Wallet.Primitive.AddressDerivation.LiftIndex 'Cardano.Wallet.Primitive.AddressDerivation.Soft
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDerivation.DerivationIndex
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDerivation.DerivationIndex
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Hardened level)
instance GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Soft level)
instance GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.WholeDomain level)
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Hardened level)
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.Soft level)
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index 'Cardano.Wallet.Primitive.AddressDerivation.WholeDomain level)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDerivation.Index derivationType level)
instance (GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index derivation level), GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index derivation level)) => Data.Text.Class.FromText (Cardano.Wallet.Primitive.AddressDerivation.Index derivation level)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDerivation.DerivationIndex
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDerivation.Role
instance GHC.Enum.Enum Cardano.Wallet.Primitive.AddressDerivation.Role
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDerivation.Role
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDerivation.Role


-- | Definition of <tt>Shared</tt> Keys.
module Cardano.Wallet.Primitive.AddressDerivation.SharedKey

-- | A cryptographic key for Shared address derivation, with phantom-types
--   to disambiguate derivation paths
--   
--   <pre>
--   let rootPrivateKey = SharedKey 'RootK XPrv
--   let accountPubKey = SharedKey 'AccountK XPub
--   let addressPubKey = SharedKey 'AddressK XPub
--   </pre>
newtype SharedKey (depth :: Depth) key
SharedKey :: key -> SharedKey (depth :: Depth) key
[getKey] :: SharedKey (depth :: Depth) key -> key

-- | Purpose for shared wallets is a constant set to 1854' (or 0x8000073E)
--   following the original CIP-1854 Multi-signature Wallets.
--   
--   It indicates that the subtree of this node is used according to this
--   specification.
--   
--   Hardened derivation is used at this level.
purposeCIP1854 :: Index 'Hardened 'PurposeK
constructAddressFromIx :: forall (n :: NetworkDiscriminant). Typeable n => Role -> ScriptTemplate -> Maybe ScriptTemplate -> Index 'Soft 'ScriptK -> Address

-- | Convert 'NetworkDiscriminant type parameter to <a>NetworkTag</a>.
toNetworkTag :: forall (n :: NetworkDiscriminant). Typeable n => NetworkTag
replaceCosignersWithVerKeys :: Role -> ScriptTemplate -> Index 'Soft 'ScriptK -> Script KeyHash
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey depth key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey depth key)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey depth key)


-- | This module provides functions and types that extend those provided by
--   the <tt>aeson</tt> package.
module Data.Aeson.Extra
parseBoundedIntegral :: forall a. (Bounded a, Integral a) => String -> Value -> Parser a


-- | This module provides functions and types that extend those provided by
--   the <a>Random</a> module hierarchy.
module Control.Monad.Random.Extra

-- | A seed for the standard random number generator.
--   
--   This type is equivalent to the internal state of a <a>StdGen</a>, but
--   provides a representation that is more convenient for construction and
--   serialization.
--   
--   The number of possible seeds is identical to the number of valid
--   states of the <a>StdGen</a> type, but unlike the <a>StdGen</a> type,
--   whose state has an internal invariant that must not be broken, values
--   of the <a>StdGenSeed</a> type are correct by construction.
newtype StdGenSeed
StdGenSeed :: Word127 -> StdGenSeed
[unStdGenSeed] :: StdGenSeed -> Word127

-- | Creates a new <a>StdGenSeed</a> from within a random monadic context.
stdGenSeed :: MonadRandom m => m StdGenSeed

-- | Converts a <a>StdGenSeed</a> value to a <a>StdGen</a> value.
--   
--   This function satisfies the following properties:
--   
--   <pre>
--   &gt;&gt;&gt; stdGenFromSeed . stdGenToSeed == id
--   
--   &gt;&gt;&gt; stdGenToSeed . stdGenFromSeed == id
--   </pre>
stdGenFromSeed :: StdGenSeed -> StdGen

-- | Converts a <a>StdGen</a> value to a <a>StdGenSeed</a> value.
--   
--   This function satisfies the following properties:
--   
--   <pre>
--   &gt;&gt;&gt; stdGenFromSeed . stdGenToSeed == id
--   
--   &gt;&gt;&gt; stdGenToSeed . stdGenFromSeed == id
--   </pre>
stdGenToSeed :: StdGen -> StdGenSeed

-- | Provides a stateless context for computations that must be non-random.
--   
--   This type is useful for testing functions that require a
--   <a>MonadRandom</a> context, but when actual randomness is not required
--   or even desired.
newtype NonRandom a
NonRandom :: a -> NonRandom a
[runNonRandom] :: NonRandom a -> a
instance GHC.Show.Show Control.Monad.Random.Extra.StdGenSeed
instance GHC.Classes.Ord Control.Monad.Random.Extra.StdGenSeed
instance GHC.Generics.Generic Control.Monad.Random.Extra.StdGenSeed
instance GHC.Enum.Bounded Control.Monad.Random.Extra.StdGenSeed
instance GHC.Classes.Eq Control.Monad.Random.Extra.StdGenSeed
instance GHC.Show.Show a => GHC.Show.Show (Control.Monad.Random.Extra.NonRandom a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Monad.Random.Extra.NonRandom a)
instance GHC.Generics.Generic (Control.Monad.Random.Extra.NonRandom a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Monad.Random.Extra.NonRandom a)
instance Control.Monad.Random.Class.MonadRandom Control.Monad.Random.Extra.NonRandom
instance System.Random.Internal.RandomGen Control.Monad.Random.Extra.NonRandomGen
instance GHC.Base.Functor Control.Monad.Random.Extra.NonRandom
instance GHC.Base.Applicative Control.Monad.Random.Extra.NonRandom
instance GHC.Base.Monad Control.Monad.Random.Extra.NonRandom
instance Data.Aeson.Types.ToJSON.ToJSON Control.Monad.Random.Extra.StdGenSeed
instance Data.Aeson.Types.FromJSON.FromJSON Control.Monad.Random.Extra.StdGenSeed

module Data.Function.Utils

-- | Apply a function <tt>n</tt> times to the specified input.
applyN :: Integral n => n -> (a -> a) -> a -> a


-- | Representation of values with an associated (free) unit of measure.
--   Useful to disambiguate primitive types like <a>Int</a> or
--   <a>String</a> which can be in different bases depending on the
--   context.
module Data.Quantity

-- | <tt>Quantity (unit :: Symbol) a</tt> is a primitive <tt>a</tt>
--   multiplied by an <tt>unit</tt>.
--   
--   Example:
--   
--   Instead of providing the unit implicitly as a comment, or a part of a
--   name
--   
--   <pre>
--   &gt;&gt;&gt; a :: Word32 -- in lovelace
--   </pre>
--   
--   we can write
--   
--   <pre>
--   &gt;&gt;&gt; a :: Quantity "lovelace" Word32
--   </pre>
--   
--   which now has a different type from
--   
--   <pre>
--   &gt;&gt;&gt; b :: Quantity "lovelace/byte" Word32
--   </pre>
--   
--   so mixing them up is more difficult.
--   
--   The unit is mostly a phantom type, but it is also included in the
--   <tt>ToJSON</tt>/<tt>FromJSON</tt> instances.
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode $ Quantity @"lovelace" 14
--   {"unit":"lovelace","quantity":14}
--   </pre>
newtype Quantity (unit :: Symbol) a
Quantity :: a -> Quantity (unit :: Symbol) a
[getQuantity] :: Quantity (unit :: Symbol) a -> a

-- | Opaque Haskell type to represent values between 0 and 100 (incl).
data Percentage
data MkPercentageError
PercentageOutOfBoundsError :: MkPercentageError

-- | Safe constructor for <a>Percentage</a>
--   
--   Takes an input in the range [0, 1].
mkPercentage :: Rational -> Either MkPercentageError Percentage
getPercentage :: Percentage -> Rational

-- | Safe way to make a <a>Percentage</a> by clipping values that are out
--   of bounds.
clipToPercentage :: Rational -> Percentage

-- | The complement is the amount that is missing to make it 100%.
--   
--   Example: The <a>complementPercentage</a> of 0.7 is 0.3.
complementPercentage :: Percentage -> Percentage

-- | Turn a <tt>Percentage</tt> to a <tt>Double</tt> (without any extra
--   rounding.)
percentageToDouble :: Percentage -> Double
instance GHC.Show.Show a => GHC.Show.Show (Data.Quantity.Quantity unit a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Data.Quantity.Quantity unit a)
instance GHC.Enum.Enum a => GHC.Enum.Enum (Data.Quantity.Quantity unit a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Data.Quantity.Quantity unit a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Quantity.Quantity unit a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Quantity.Quantity unit a)
instance GHC.Generics.Generic (Data.Quantity.Quantity unit a)
instance GHC.Show.Show Data.Quantity.Percentage
instance GHC.Classes.Ord Data.Quantity.Percentage
instance GHC.Classes.Eq Data.Quantity.Percentage
instance GHC.Generics.Generic Data.Quantity.Percentage
instance GHC.Classes.Eq Data.Quantity.MkPercentageError
instance GHC.Show.Show Data.Quantity.MkPercentageError
instance NoThunks.Class.NoThunks Data.Quantity.Percentage
instance Control.DeepSeq.NFData Data.Quantity.Percentage
instance Formatting.Buildable.Buildable Data.Quantity.Percentage
instance Data.Aeson.Types.ToJSON.ToJSON Data.Quantity.Percentage
instance Data.Aeson.Types.FromJSON.FromJSON Data.Quantity.Percentage
instance GHC.Enum.Bounded Data.Quantity.Percentage
instance Data.Text.Class.ToText Data.Quantity.Percentage
instance Data.Text.Class.FromText Data.Quantity.Percentage
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Data.Quantity.Quantity unit a)
instance GHC.Base.Functor (Data.Quantity.Quantity any)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.Quantity.Quantity unit a)
instance (GHC.TypeLits.KnownSymbol unit, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Data.Quantity.Quantity unit a)
instance (GHC.TypeLits.KnownSymbol unit, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Data.Quantity.Quantity unit a)
instance Data.Text.Class.FromText b => Data.Text.Class.FromText (Data.Quantity.Quantity sym b)
instance Data.Text.Class.ToText b => Data.Text.Class.ToText (Data.Quantity.Quantity sym b)
instance (GHC.TypeLits.KnownSymbol unit, Formatting.Buildable.Buildable a) => Formatting.Buildable.Buildable (Data.Quantity.Quantity unit a)


-- | This module provides the <a>Coin</a> data type, which represents a
--   quantity of lovelace.
module Cardano.Wallet.Primitive.Types.Coin

-- | A <a>Coin</a> represents a quantity of lovelace.
--   
--   Reminder: 1 ada = 1,000,000 lovelace.
--   
--   The <a>Coin</a> type has <a>Semigroup</a> and <a>Monoid</a> instances
--   that correspond to ordinary addition and summation.
newtype Coin
Coin :: Natural -> Coin
[unCoin] :: Coin -> Natural

-- | Constructs a <a>Coin</a> from an <a>Integral</a> value.
--   
--   Returns <a>Nothing</a> if the given value is negative.
fromIntegral :: (Bits i, Integral i) => i -> Maybe Coin

-- | Constructs a <a>Coin</a> from a <a>Natural</a> value.
fromNatural :: Natural -> Coin

-- | Constructs a <a>Coin</a> from a <a>Word64</a> value.
fromWord64 :: Word64 -> Coin

-- | Converts a <a>Coin</a> to an <a>Integer</a> value.
toInteger :: Coin -> Integer

-- | Converts a <a>Coin</a> to a <a>Natural</a> value.
toNatural :: Coin -> Natural

-- | Converts a <a>Coin</a> to a <a>Quantity</a>.
--   
--   Returns <a>Nothing</a> if the given value does not fit within the
--   bounds of the target type.
toQuantity :: (Bits i, Integral i) => Coin -> Maybe (Quantity n i)

-- | Converts a <a>Coin</a> to a <a>Word64</a> value.
--   
--   Returns <a>Nothing</a> if the given value does not fit within the
--   bounds of a 64-bit word.
toWord64 :: Coin -> Maybe Word64

-- | Constructs a <a>Coin</a> from an <a>Integral</a> value.
--   
--   Callers of this function must take responsibility for checking that
--   the given value is not negative.
--   
--   Produces a run-time error if the given value is negative.
unsafeFromIntegral :: HasCallStack => (Bits i, Integral i, Show i) => i -> Coin

-- | Converts a <a>Coin</a> to a <a>Quantity</a>.
--   
--   Callers of this function must take responsibility for checking that
--   the given value will fit within the bounds of the target type.
--   
--   Produces a run-time error if the given value is out of bounds.
unsafeToQuantity :: HasCallStack => (Bits i, Integral i) => Coin -> Quantity n i

-- | Converts a <a>Coin</a> to a <a>Word64</a> value.
--   
--   Callers of this function must take responsibility for checking that
--   the given value will fit within the bounds of a 64-bit word.
--   
--   Produces a run-time error if the given value is out of bounds.
unsafeToWord64 :: HasCallStack => Coin -> Word64

-- | Calculates the combined value of two coins.
add :: Coin -> Coin -> Coin

-- | Subtracts the second coin from the first.
--   
--   Returns <a>Nothing</a> if the second coin is strictly greater than the
--   first.
subtract :: Coin -> Coin -> Maybe Coin

-- | Subtracts the second coin from the first.
--   
--   Returns 'Coin 0' if the second coin is strictly greater than the
--   first.
difference :: Coin -> Coin -> Coin

-- | Absolute difference between two coin amounts. The result is never
--   negative.
distance :: Coin -> Coin -> Coin

-- | Computes the equipartition of a coin into <tt>n</tt> smaller coins.
--   
--   An <i>equipartition</i> of a coin is a <i>partition</i> of that coin
--   into <tt>n</tt> smaller coins whose values differ by no more than 1.
--   
--   The resultant list is sorted in ascending order.
equipartition :: Coin -> NonEmpty a -> NonEmpty Coin

-- | Partitions a coin into a number of parts, where the size of each part
--   is proportional (modulo rounding) to the size of its corresponding
--   element in the given list of weights, and the number of parts is equal
--   to the number of weights.
--   
--   Returns <a>Nothing</a> if the sum of weights is equal to zero.
partition :: Coin -> NonEmpty Coin -> Maybe (NonEmpty Coin)

-- | Partitions a coin into a number of parts, where the size of each part
--   is proportional (modulo rounding) to the size of its corresponding
--   element in the given list of weights, and the number of parts is equal
--   to the number of weights.
--   
--   This function always satisfies the following properties:
--   
--   <pre>
--   fold   (partitionDefault c ws) == c
--   </pre>
--   
--   <pre>
--   length (partitionDefault c ws) == length ws
--   </pre>
--   
--   If the sum of weights is equal to zero, then this function returns an
--   <a>equipartition</a> satisfying the following property:
--   
--   <pre>
--   partitionDefault c ws == equipartition c ws
--   </pre>
partitionDefault :: Coin -> NonEmpty Coin -> NonEmpty Coin

-- | Partitions a coin into a number of parts, where the size of each part
--   is proportional (modulo rounding) to the size of its corresponding
--   element in the given list of weights, and the number of parts is equal
--   to the number of weights.
--   
--   Throws a run-time error if the sum of weights is equal to zero.
unsafePartition :: HasCallStack => Coin -> NonEmpty Coin -> NonEmpty Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Coin.Coin
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.Coin.Coin
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Coin.Coin
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Coin.Coin
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Coin.Coin
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.Coin.Coin
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.Coin.Coin
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.Coin.Coin
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.Coin.Coin
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Coin.Coin
instance Data.Hashable.Class.Hashable Cardano.Wallet.Primitive.Types.Coin.Coin
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Coin.Coin


-- | Provides the <a>TokenBundle</a> type, which combines a <a>Coin</a>
--   (lovelace) value with a map of named token quantities, scoped by token
--   policy.
--   
--   This module is meant to be imported qualified. For example:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Cardano.Wallet.Primitive.Types.TokenBundle as TB
--   </pre>
module Cardano.Wallet.Primitive.Types.TokenBundle

-- | Combines a <a>Coin</a> (lovelace) value with a map of named token
--   quantities, grouped by token policy.
data TokenBundle
TokenBundle :: !Coin -> !TokenMap -> TokenBundle
[$sel:coin:TokenBundle] :: TokenBundle -> !Coin
[$sel:tokens:TokenBundle] :: TokenBundle -> !TokenMap

-- | A combination of a token policy identifier and a token name that can
--   be used as a compound identifier.
data AssetId
AssetId :: !TokenPolicyId -> !TokenName -> AssetId
[$sel:tokenPolicyId:AssetId] :: AssetId -> !TokenPolicyId
[$sel:tokenName:AssetId] :: AssetId -> !TokenName

-- | The empty token bundle.
empty :: TokenBundle

-- | Creates a token bundle from a coin and a flat list of token
--   quantities.
--   
--   If a token name appears more than once in the list under the same
--   policy, its associated quantities will be added together in the
--   resultant bundle.
fromFlatList :: Coin -> [(AssetId, TokenQuantity)] -> TokenBundle

-- | Creates a token bundle from a coin and a nested list of token
--   quantities.
--   
--   If a token name appears more than once in the list under the same
--   policy, its associated quantities will be added together in the
--   resultant bundle.
fromNestedList :: Coin -> [(TokenPolicyId, NonEmpty (TokenName, TokenQuantity))] -> TokenBundle
fromNestedMap :: (Coin, Map TokenPolicyId (NonEmptyMap TokenName TokenQuantity)) -> TokenBundle
fromTokenMap :: TokenMap -> TokenBundle

-- | Converts a token bundle to a coin and a flat list of token quantities.
toFlatList :: TokenBundle -> (Coin, [(AssetId, TokenQuantity)])

-- | Creates a singleton token bundle from an ada <a>Coin</a> value.
fromCoin :: Coin -> TokenBundle

-- | Coerces a token bundle to an ada <a>Coin</a> value.
--   
--   Returns a coin if (and only if) the token bundle has no other tokens.
toCoin :: TokenBundle -> Maybe Coin

-- | Indicates <a>True</a> if (and only if) a token bundle has no tokens
--   other than an ada <a>Coin</a> value.
isCoin :: TokenBundle -> Bool

-- | Gets the current ada <a>Coin</a> value from a token bundle.
--   
--   If you need to assert that a bundle has no other tokens, consider
--   using the <a>toCoin</a> function instead.
getCoin :: TokenBundle -> Coin

-- | Sets the current ada <a>Coin</a> value for a token bundle.
setCoin :: TokenBundle -> Coin -> TokenBundle

-- | Adds one token bundle to another.
add :: TokenBundle -> TokenBundle -> TokenBundle

-- | Subtracts the second token bundle from the first.
--   
--   Returns <a>Nothing</a> if the second bundle is not less than or equal
--   to the first bundle when compared with the <a>leq</a> function.
subtract :: TokenBundle -> TokenBundle -> Maybe TokenBundle

-- | Analogous to <tt>Set.difference</tt>, return the difference between
--   two token maps.
--   
--   The following property holds: prop&gt; x <a>leq</a> (x
--   <a>difference</a> y) <a>add</a> y
--   
--   Note that there's a <a>leq</a> rather than equality, which we'd expect
--   if this was subtraction of integers. I.e.
--   
--   <pre>
--   &gt;&gt;&gt; (0 - 1) + 1
--   0
--   </pre>
--   
--   whereas
--   
--   <pre>
--   &gt;&gt;&gt; let oneToken = fromFlatList coin [(aid, TokenQuantity 1)]
--   
--   &gt;&gt;&gt; (mempty `difference` oneToken) `add` oneToken
--   oneToken
--   </pre>
difference :: TokenBundle -> TokenBundle -> TokenBundle

-- | Gets the quantity associated with a given asset.
--   
--   If the given bundle does not have an entry for the specified asset,
--   this function returns a value of zero.
getQuantity :: TokenBundle -> AssetId -> TokenQuantity

-- | Returns true if and only if the given bundle has a non-zero quantity
--   for the given asset.
hasQuantity :: TokenBundle -> AssetId -> Bool

-- | Sets the quantity associated with a given asset.
--   
--   If the given quantity is zero, the resultant bundle will not have an
--   entry for the given asset.
setQuantity :: TokenBundle -> AssetId -> TokenQuantity -> TokenBundle

-- | Partitions a token bundle into <tt>n</tt> smaller bundles, where the
--   asset sets of the resultant bundles are disjoint.
--   
--   In the resultant bundles, the smallest asset set size and largest
--   asset set size will differ by no more than 1.
--   
--   The ada <a>Coin</a> quantity is equipartitioned across the resulting
--   bundles.
--   
--   The quantities of each non-ada asset are unchanged.
equipartitionAssets :: TokenBundle -> NonEmpty a -> NonEmpty TokenBundle

-- | Partitions a token bundle into <tt>n</tt> smaller bundles, where the
--   quantity of each token is equipartitioned across the resultant
--   bundles, with the goal that no token quantity in any of the resultant
--   bundles exceeds the given upper bound.
--   
--   The value <tt>n</tt> is computed automatically, and is the minimum
--   value required to achieve the goal that no token quantity in any of
--   the resulting bundles exceeds the maximum allowable token quantity.
equipartitionQuantitiesWithUpperBound :: TokenBundle -> TokenQuantity -> NonEmpty TokenBundle

-- | Defines a lexicographic ordering.
newtype Lexicographic a
Lexicographic :: a -> Lexicographic a
[$sel:unLexicographic:Lexicographic] :: Lexicographic a -> a

-- | When used with the <a>Buildable</a> or <a>ToJSON</a> instances,
--   provides a flat serialization style, where token quantities are paired
--   with their asset identifiers.
newtype Flat a
Flat :: a -> Flat a
[$sel:getFlat:Flat] :: Flat a -> a

-- | When used with the <a>Buildable</a> or <a>ToJSON</a> instances,
--   provides a nested serialization style, where token quantities are
--   grouped by policy identifier.
newtype Nested a
Nested :: a -> Nested a
[$sel:getNested:Nested] :: Nested a -> a
getAssets :: TokenBundle -> Set AssetId
mapAssetIds :: (AssetId -> AssetId) -> TokenBundle -> TokenBundle

-- | Subtracts the second token bundle from the first.
--   
--   Pre-condition: the second bundle is less than or equal to the first
--   bundle when compared with the <a>leq</a> function.
--   
--   Throws a run-time exception if the pre-condition is violated.
unsafeSubtract :: TokenBundle -> TokenBundle -> TokenBundle
instance Data.Hashable.Class.Hashable Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle
instance (TypeError ...) => GHC.Classes.Ord Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle
instance Algebra.PartialOrd.PartialOrd Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.TokenMap.Lexicographic Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.TokenMap.Flat Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.TokenMap.Nested Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)


-- | Provides internal functions for the <a>UTxOIndex</a> type, which
--   indexes a UTxO set by asset identifier.
--   
--   The index makes it possible to efficiently compute the subset of a
--   UTxO set containing a particular asset, or to select just a single
--   UTxO containing a particular asset, without having to search linearly
--   through the entire UTxO set.
--   
--   See the documentation for <a>UTxOIndex</a> for more details.
module Cardano.Wallet.Primitive.Types.UTxOIndex.Internal

-- | A UTxO set that is indexed by asset identifier.
--   
--   The index provides a mapping from assets to subsets of the UTxO set.
--   
--   A UTxO appears in the set for a particular asset if and only if its
--   associated value has a non-zero quantity of that asset.
--   
--   The index makes it possible to efficiently compute the subset of a
--   UTxO set containing a particular asset, or to select just a single
--   UTxO containing a particular asset, without having to search linearly
--   through the entire UTxO set.
--   
--   The index also keeps track of the current UTxO balance of all assets,
--   making it possible to efficiently look up the total quantity of a
--   particular asset without having to sum across the entire UTxO set.
--   
--   The UTxO index data structure has an invariant that can be checked
--   with the <a>checkInvariant</a> function.
data UTxOIndex u

-- | An index with no entries.
empty :: UTxOIndex u

-- | Creates a singleton index from the specified UTxO identifier and
--   value.
singleton :: Ord u => u -> TokenBundle -> UTxOIndex u

-- | Constructs an index from a sequence of entries.
--   
--   Note that this operation is potentially expensive as it must construct
--   an index from scratch, and therefore should only be used sparingly.
--   
--   If the given sequence contains more than one mapping for the same UTxO
--   identifier, the mapping that appears latest in the sequence will take
--   precedence, and all others will be ignored.
fromSequence :: (Foldable f, Ord u) => f (u, TokenBundle) -> UTxOIndex u

-- | Constructs an index from a map.
--   
--   Note that this operation is potentially expensive as it must construct
--   an index from scratch, and therefore should only be used sparingly.
fromMap :: Ord u => Map u TokenBundle -> UTxOIndex u

-- | Converts an index to a list of its constituent entries.
--   
--   Consider using <a>fold</a> if your goal is to consume all entries in
--   the output.
toList :: UTxOIndex u -> [(u, TokenBundle)]

-- | Converts an index into a map.
--   
--   Consider using <a>fold</a> if your goal is to consume all entries in
--   the output.
toMap :: UTxOIndex u -> Map u TokenBundle

-- | Folds strictly over the constituent entries of an index.
fold :: (a -> u -> TokenBundle -> a) -> a -> UTxOIndex u -> a

-- | Inserts an entry that maps the given UTxO identifier to the given
--   value.
--   
--   If the index has an existing value for the specified UTxO identifier,
--   the value referred to by that identifier will be replaced with the
--   specified value.
insert :: Ord u => u -> TokenBundle -> UTxOIndex u -> UTxOIndex u

-- | Inserts multiple entries into an index.
--   
--   See <a>insert</a>.
insertMany :: (Foldable f, Ord u) => f (u, TokenBundle) -> UTxOIndex u -> UTxOIndex u

-- | Deletes the entry corresponding to the given UTxO identifier.
--   
--   If the index has no existing entry for the specified identifier, the
--   result of applying this function will be equivalent to the identity
--   function.
delete :: forall u. Ord u => u -> UTxOIndex u -> UTxOIndex u

-- | Deletes multiple entries from an index.
--   
--   See <a>delete</a>.
deleteMany :: (Foldable f, Ord u) => f u -> UTxOIndex u -> UTxOIndex u

-- | Filters an index.
filter :: Ord u => (u -> Bool) -> UTxOIndex u -> UTxOIndex u

-- | Partitions an index.
partition :: Ord u => (u -> Bool) -> UTxOIndex u -> (UTxOIndex u, UTxOIndex u)

-- | Returns the complete set of all assets contained in an index.
assets :: UTxOIndex u -> Set Asset
balance :: UTxOIndex u -> TokenBundle

-- | Returns the value corresponding to the given UTxO identifier.
--   
--   If the index has no such identifier, this function returns
--   <a>Nothing</a>.
lookup :: Ord u => u -> UTxOIndex u -> Maybe TokenBundle

-- | Returns <a>True</a> if (and only if) the index has an entry for the
--   given UTxO identifier.
member :: Ord u => u -> UTxOIndex u -> Bool

-- | Returns <a>True</a> if (and only if) the index is empty.
null :: UTxOIndex u -> Bool

-- | Returns the total number of UTxO entries held within the index.
size :: UTxOIndex u -> Int
difference :: Ord u => UTxOIndex u -> UTxOIndex u -> UTxOIndex u

-- | Indicates whether a pair of UTxO indices are disjoint.
disjoint :: Ord u => UTxOIndex u -> UTxOIndex u -> Bool

-- | Specifies a filter for selecting UTxO entries.
data SelectionFilter asset

-- | Matches UTxOs that contain only the given asset and no other assets.
SelectSingleton :: asset -> SelectionFilter asset

-- | Matches UTxOs that contain the given asset and exactly one other
--   asset.
SelectPairWith :: asset -> SelectionFilter asset

-- | Matches UTxOs that contain the given asset and any number of other
--   assets.
SelectAnyWith :: asset -> SelectionFilter asset

-- | Matches all UTxOs regardless of what assets they contain.
SelectAny :: SelectionFilter asset

-- | Selects an entry at random from the index according to the given
--   filter.
--   
--   Returns the selected entry and an updated index with the entry
--   removed.
--   
--   Returns <a>Nothing</a> if there were no matching entries.
selectRandom :: forall m u. (MonadRandom m, Ord u) => UTxOIndex u -> SelectionFilter Asset -> m (Maybe ((u, TokenBundle), UTxOIndex u))

-- | Selects an entry at random from the index according to the given
--   filters.
--   
--   This function traverses the specified list of filters in descending
--   order of priority, from left to right.
--   
--   When considering a particular filter:
--   
--   <ul>
--   <li>if the function is able to select a UTxO entry that matches, it
--   terminates with that entry and an updated index with the entry
--   removed.</li>
--   <li>if the function is not able to select a UTxO entry that matches,
--   it traverses to the next filter available.</li>
--   </ul>
--   
--   This function returns <a>Nothing</a> if (and only if) it traverses the
--   entire list of filters without successfully selecting a UTxO entry.
selectRandomWithPriority :: (MonadRandom m, Ord u) => UTxOIndex u -> NonEmpty (SelectionFilter Asset) -> m (Maybe ((u, TokenBundle), UTxOIndex u))

-- | A type capable of representing any asset, including both ada and
--   non-ada assets.
--   
--   TODO: ADP-1449 Move this type away from the <a>UTxOIndex</a> module
--   and replace all usages of it with a type parameter.
data Asset
AssetLovelace :: Asset
Asset :: AssetId -> Asset

-- | Returns the set of assets associated with a given <a>TokenBundle</a>.
--   
--   Both ada and non-ada assets are included in the set returned.
--   
--   TODO: ADP-1449 Move this function away from the <a>UTxOIndex</a>
--   module once the type of assets has been generalized.
tokenBundleAssets :: TokenBundle -> Set Asset

-- | Returns the number of assets associated with a given
--   <a>TokenBundle</a>.
--   
--   Both ada and non-ada assets are included in the total count returned.
--   
--   TODO: ADP-1449 Move this function away from the <a>UTxOIndex</a>
--   module once the type of assets has been generalized.
tokenBundleAssetCount :: TokenBundle -> Int

-- | Indicates whether or not a given bundle includes a given asset.
--   
--   Both ada and non-ada assets can be queried.
--   
--   TODO: ADP-1449 Move this function away from the <a>UTxOIndex</a>
--   module once the type of assets has been generalized.
tokenBundleHasAsset :: TokenBundle -> Asset -> Bool

-- | Represents different categories of token bundles.
data BundleCategory asset
BundleWithNoAssets :: BundleCategory asset
BundleWithOneAsset :: asset -> BundleCategory asset
BundleWithTwoAssets :: (asset, asset) -> BundleCategory asset
BundleWithMultipleAssets :: Set asset -> BundleCategory asset

-- | Categorizes a token bundle by how many assets it contains.
categorizeTokenBundle :: TokenBundle -> BundleCategory Asset

-- | Selects an element at random from the given set.
--   
--   Returns <a>Nothing</a> if (and only if) the given set is empty.
selectRandomSetMember :: MonadRandom m => Set a -> m (Maybe a)

-- | The result of checking the invariant with the <a>checkInvariant</a>
--   function.
data InvariantStatus

-- | Indicates a successful check of the invariant.
InvariantHolds :: InvariantStatus

-- | Indicates that the cached <a>balance</a> value is incorrect.
InvariantBalanceError :: BalanceError -> InvariantStatus

-- | Indicates that the <tt>index</tt> is missing one or more entries.
InvariantIndexIncomplete :: InvariantStatus

-- | Indicates that the <tt>index</tt> has one or more unnecessary entries.
InvariantIndexNonMinimal :: InvariantStatus

-- | Indicates that the index sets are not consistent.
InvariantIndexInconsistent :: InvariantStatus

-- | Indicates that the <tt>index</tt> and the cached <a>balance</a> value
--   disagree about which assets are included.
InvariantAssetsInconsistent :: InvariantStatus

-- | Checks whether or not the invariant holds.
checkInvariant :: Ord u => UTxOIndex u -> InvariantStatus
instance Data.Traversable.Traversable Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.SelectionFilter
instance GHC.Show.Show asset => GHC.Show.Show (Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.SelectionFilter asset)
instance GHC.Base.Functor Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.SelectionFilter
instance Data.Foldable.Foldable Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.SelectionFilter
instance GHC.Classes.Eq asset => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.SelectionFilter asset)
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.Asset
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.Asset
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.Asset
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.Asset
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.Asset
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.UTxOIndex u)
instance (GHC.Read.Read u, GHC.Classes.Ord u) => GHC.Read.Read (Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.UTxOIndex u)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.UTxOIndex u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.UTxOIndex u)
instance GHC.Show.Show asset => GHC.Show.Show (Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.BundleCategory asset)
instance GHC.Classes.Eq asset => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.BundleCategory asset)
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.BalanceError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.BalanceError
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.BalanceStatus
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.BalanceStatus
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.InvariantStatus
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.InvariantStatus
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.Asset
instance Control.DeepSeq.NFData u => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.UTxOIndex.Internal.UTxOIndex u)


-- | Provides the <a>UTxOIndex</a> type, which indexes a UTxO set by asset
--   identifier.
--   
--   The index makes it possible to efficiently compute the subset of a
--   UTxO set containing a particular asset, or to select just a single
--   UTxO containing a particular asset, without having to search linearly
--   through the entire UTxO set.
--   
--   See the documentation for <a>UTxOIndex</a> for more details.
--   
--   This module is meant to be imported qualified. For example:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Cardano.Wallet.Primitive.Types.UTxOIndex as UTxOIndex
--   </pre>
module Cardano.Wallet.Primitive.Types.UTxOIndex

-- | A UTxO set that is indexed by asset identifier.
--   
--   The index provides a mapping from assets to subsets of the UTxO set.
--   
--   A UTxO appears in the set for a particular asset if and only if its
--   associated value has a non-zero quantity of that asset.
--   
--   The index makes it possible to efficiently compute the subset of a
--   UTxO set containing a particular asset, or to select just a single
--   UTxO containing a particular asset, without having to search linearly
--   through the entire UTxO set.
--   
--   The index also keeps track of the current UTxO balance of all assets,
--   making it possible to efficiently look up the total quantity of a
--   particular asset without having to sum across the entire UTxO set.
--   
--   The UTxO index data structure has an invariant that can be checked
--   with the <a>checkInvariant</a> function.
data UTxOIndex u

-- | An index with no entries.
empty :: UTxOIndex u

-- | Creates a singleton index from the specified UTxO identifier and
--   value.
singleton :: Ord u => u -> TokenBundle -> UTxOIndex u

-- | Constructs an index from a map.
--   
--   Note that this operation is potentially expensive as it must construct
--   an index from scratch, and therefore should only be used sparingly.
fromMap :: Ord u => Map u TokenBundle -> UTxOIndex u

-- | Constructs an index from a sequence of entries.
--   
--   Note that this operation is potentially expensive as it must construct
--   an index from scratch, and therefore should only be used sparingly.
--   
--   If the given sequence contains more than one mapping for the same UTxO
--   identifier, the mapping that appears latest in the sequence will take
--   precedence, and all others will be ignored.
fromSequence :: (Foldable f, Ord u) => f (u, TokenBundle) -> UTxOIndex u

-- | Converts an index to a list of its constituent entries.
--   
--   Consider using <a>fold</a> if your goal is to consume all entries in
--   the output.
toList :: UTxOIndex u -> [(u, TokenBundle)]

-- | Converts an index into a map.
--   
--   Consider using <a>fold</a> if your goal is to consume all entries in
--   the output.
toMap :: UTxOIndex u -> Map u TokenBundle

-- | Folds strictly over the constituent entries of an index.
fold :: (a -> u -> TokenBundle -> a) -> a -> UTxOIndex u -> a

-- | Inserts an entry that maps the given UTxO identifier to the given
--   value.
--   
--   If the index has an existing value for the specified UTxO identifier,
--   the value referred to by that identifier will be replaced with the
--   specified value.
insert :: Ord u => u -> TokenBundle -> UTxOIndex u -> UTxOIndex u

-- | Inserts multiple entries into an index.
--   
--   See <a>insert</a>.
insertMany :: (Foldable f, Ord u) => f (u, TokenBundle) -> UTxOIndex u -> UTxOIndex u

-- | Deletes the entry corresponding to the given UTxO identifier.
--   
--   If the index has no existing entry for the specified identifier, the
--   result of applying this function will be equivalent to the identity
--   function.
delete :: forall u. Ord u => u -> UTxOIndex u -> UTxOIndex u

-- | Deletes multiple entries from an index.
--   
--   See <a>delete</a>.
deleteMany :: (Foldable f, Ord u) => f u -> UTxOIndex u -> UTxOIndex u

-- | Filters an index.
filter :: Ord u => (u -> Bool) -> UTxOIndex u -> UTxOIndex u

-- | Partitions an index.
partition :: Ord u => (u -> Bool) -> UTxOIndex u -> (UTxOIndex u, UTxOIndex u)

-- | Returns the complete set of all assets contained in an index.
assets :: UTxOIndex u -> Set Asset
balance :: UTxOIndex u -> TokenBundle

-- | Returns the value corresponding to the given UTxO identifier.
--   
--   If the index has no such identifier, this function returns
--   <a>Nothing</a>.
lookup :: Ord u => u -> UTxOIndex u -> Maybe TokenBundle

-- | Returns <a>True</a> if (and only if) the index has an entry for the
--   given UTxO identifier.
member :: Ord u => u -> UTxOIndex u -> Bool

-- | Returns <a>True</a> if (and only if) the index is empty.
null :: UTxOIndex u -> Bool

-- | Returns the total number of UTxO entries held within the index.
size :: UTxOIndex u -> Int
difference :: Ord u => UTxOIndex u -> UTxOIndex u -> UTxOIndex u

-- | Indicates whether a pair of UTxO indices are disjoint.
disjoint :: Ord u => UTxOIndex u -> UTxOIndex u -> Bool

-- | A type capable of representing any asset, including both ada and
--   non-ada assets.
--   
--   TODO: ADP-1449 Move this type away from the <a>UTxOIndex</a> module
--   and replace all usages of it with a type parameter.
data Asset
AssetLovelace :: Asset
Asset :: AssetId -> Asset

-- | Specifies a filter for selecting UTxO entries.
data SelectionFilter asset

-- | Matches UTxOs that contain only the given asset and no other assets.
SelectSingleton :: asset -> SelectionFilter asset

-- | Matches UTxOs that contain the given asset and exactly one other
--   asset.
SelectPairWith :: asset -> SelectionFilter asset

-- | Matches UTxOs that contain the given asset and any number of other
--   assets.
SelectAnyWith :: asset -> SelectionFilter asset

-- | Matches all UTxOs regardless of what assets they contain.
SelectAny :: SelectionFilter asset

-- | Selects an entry at random from the index according to the given
--   filter.
--   
--   Returns the selected entry and an updated index with the entry
--   removed.
--   
--   Returns <a>Nothing</a> if there were no matching entries.
selectRandom :: forall m u. (MonadRandom m, Ord u) => UTxOIndex u -> SelectionFilter Asset -> m (Maybe ((u, TokenBundle), UTxOIndex u))

-- | Selects an entry at random from the index according to the given
--   filters.
--   
--   This function traverses the specified list of filters in descending
--   order of priority, from left to right.
--   
--   When considering a particular filter:
--   
--   <ul>
--   <li>if the function is able to select a UTxO entry that matches, it
--   terminates with that entry and an updated index with the entry
--   removed.</li>
--   <li>if the function is not able to select a UTxO entry that matches,
--   it traverses to the next filter available.</li>
--   </ul>
--   
--   This function returns <a>Nothing</a> if (and only if) it traverses the
--   entire list of filters without successfully selecting a UTxO entry.
selectRandomWithPriority :: (MonadRandom m, Ord u) => UTxOIndex u -> NonEmpty (SelectionFilter Asset) -> m (Maybe ((u, TokenBundle), UTxOIndex u))


-- | Provides the <a>UTxOSelection</a> type, which represents a selection
--   of UTxO entries from a UTxO set.
--   
--   It consists of a pair of UTxO sets:
--   
--   <ul>
--   <li>the selected set: UTxOs that have already been selected;</li>
--   <li>the leftover set: UTxOs that have not yet been selected.</li>
--   </ul>
--   
--   To construct a <a>UTxOSelection</a> where none of the UTxOs are
--   selected, use the <a>fromIndex</a> function.
--   
--   To construct a <a>UTxOSelection</a> where some of the UTxOs are
--   selected, use either the <a>fromIndexFiltered</a> or the
--   <a>fromIndexPair</a> functions.
--   
--   To select an element (and move it from the leftover set to the
--   selected set), use the <a>select</a> function.
--   
--   A <a>UTxOSelection</a> can be promoted to a
--   <a>UTxOSelectionNonEmpty</a>, indicating that the selected set
--   contains at least one UTxO. To promote a selection, either use the
--   <a>toNonEmpty</a> function to assert that it is non-empty, or use the
--   <a>select</a> function to select a single entry.
module Cardano.Wallet.Primitive.Types.UTxOSelection
class HasUTxOSelectionState s u => IsUTxOSelection s u

-- | A selection for which <a>isNonEmpty</a> may be <a>False</a>.
data UTxOSelection u

-- | A selection for which <a>isNonEmpty</a> must be <a>True</a>.
data UTxOSelectionNonEmpty u

-- | A completely empty selection with no selected or leftover UTxOs.
empty :: UTxOSelection u

-- | Creates a selection where none of the UTxOs are selected.
--   
--   All UTxOs in the index will be added to the leftover set.
fromIndex :: UTxOIndex u -> UTxOSelection u

-- | Creates a selection from an index and a filter.
--   
--   All UTxOs that match the given filter will be added to the selected
--   set, whereas all UTxOs that do not match will be added to the leftover
--   set.
fromIndexFiltered :: Ord u => (u -> Bool) -> UTxOIndex u -> UTxOSelection u

-- | Creates a selection from a pair of indices.
--   
--   The 1st index in the pair represents the leftover set. The 2nd index
--   in the pair represents the selected set.
--   
--   Any items that are in both sets are removed from the leftover set.
fromIndexPair :: Ord u => (UTxOIndex u, UTxOIndex u) -> UTxOSelection u

-- | Converts a selection to a pair of indices.
--   
--   The 1st index in the pair represents the leftover set. The 2nd index
--   in the pair represents the selected set.
toIndexPair :: IsUTxOSelection s u => s u -> (UTxOIndex u, UTxOIndex u)

-- | Demotes a non-empty selection to an ordinary selection.
fromNonEmpty :: UTxOSelectionNonEmpty u -> UTxOSelection u

-- | Promotes an ordinary selection to a non-empty selection.
--   
--   Returns <a>Nothing</a> if the the selected set is empty.
toNonEmpty :: IsUTxOSelection s u => s u -> Maybe (UTxOSelectionNonEmpty u)

-- | Returns <a>True</a> if and only if the selected set is empty.
isEmpty :: IsUTxOSelection s u => s u -> Bool

-- | Returns <a>True</a> if and only if the selected set is non-empty.
isNonEmpty :: IsUTxOSelection s u => s u -> Bool

-- | Returns <a>True</a> if the given <tt>InputId</tt> is a member of
--   either set.
--   
--   Otherwise, returns <a>False</a>.
isMember :: IsUTxOSelection s u => Ord u => u -> s u -> Bool

-- | Returns <a>True</a> iff. the given <tt>InputId</tt> is a member of the
--   leftover set.
isLeftover :: IsUTxOSelection s u => Ord u => u -> s u -> Bool

-- | Returns <a>True</a> iff. the given <tt>InputId</tt> is a member of the
--   selected set.
isSelected :: IsUTxOSelection s u => Ord u => u -> s u -> Bool

-- | Returns <a>True</a> iff. the first selection is a sub-selection of the
--   second.
--   
--   A selection <tt>s1</tt> is a sub-selection of selection <tt>s2</tt> if
--   (and only if) it is possible to transform <tt>s1</tt> into <tt>s2</tt>
--   through zero or more applications of the <a>select</a> function.
isSubSelectionOf :: IsUTxOSelection s1 u => IsUTxOSelection s2 u => Ord u => s1 u -> s2 u -> Bool

-- | Returns <a>True</a> iff. the first selection is a proper sub-selection
--   of the second.
--   
--   A selection <tt>s1</tt> is a proper sub-selection of selection
--   <tt>s2</tt> if (and only if) it is possible to transform <tt>s1</tt>
--   into <tt>s2</tt> through one or more applications of the <a>select</a>
--   function.
isProperSubSelectionOf :: IsUTxOSelection s1 u => IsUTxOSelection s2 u => Ord u => s1 u -> s2 u -> Bool

-- | Computes the available balance.
--   
--   The available balance is the sum of the selected and the leftover
--   balances.
--   
--   It predicts what <a>selectedBalance</a> would be if every single UTxO
--   were selected.
--   
--   This result of this function remains constant over applications of
--   <a>select</a> and <a>selectMany</a>:
--   
--   <pre>
--   &gt;&gt;&gt; availableBalance s == availableBalance (selectMany is s)
--   </pre>
availableBalance :: IsUTxOSelection s u => s u -> TokenBundle

-- | Computes the complete map of all available UTxOs.
--   
--   The available UTxO set is the union of the selected and leftover UTxO
--   sets.
--   
--   It predicts what <a>selectedMap</a> would be if every single UTxO were
--   selected.
--   
--   This result of this function remains constant over applications of
--   <a>select</a> and <a>selectMany</a>:
--   
--   <pre>
--   &gt;&gt;&gt; availableMap s == availableMap (selectMany is s)
--   </pre>
availableMap :: IsUTxOSelection s u => Ord u => s u -> Map u TokenBundle

-- | Computes the size of the available UTxO set.
availableSize :: IsUTxOSelection s u => s u -> Int

-- | Retrieves the balance of leftover UTxOs.
leftoverBalance :: IsUTxOSelection s u => s u -> TokenBundle

-- | Retrieves the size of the leftover UTxO set.
leftoverSize :: IsUTxOSelection s u => s u -> Int

-- | Retrieves an index of the leftover UTxOs.
leftoverIndex :: IsUTxOSelection s u => s u -> UTxOIndex u

-- | Retrieves a list of the leftover UTxOs.
leftoverList :: IsUTxOSelection s u => s u -> [(u, TokenBundle)]

-- | Retrieves a map of the leftover UTxOs.
leftoverMap :: IsUTxOSelection s u => s u -> Map u TokenBundle

-- | Retrieves the balance of selected UTxOs.
selectedBalance :: IsUTxOSelection s u => s u -> TokenBundle

-- | Retrieves the size of the selected UTxO set.
selectedSize :: IsUTxOSelection s u => s u -> Int

-- | Retrieves an index of the selected UTxOs.
selectedIndex :: IsUTxOSelection s u => s u -> UTxOIndex u

-- | Retrieves a list of the selected UTxOs.
selectedList :: IsUTxOSelection s u => s u -> SelectedList s u

-- | Retrieves a map of the selected UTxOs.
selectedMap :: IsUTxOSelection s u => s u -> Map u TokenBundle

-- | Moves a single entry from the leftover set to the selected set.
--   
--   Returns <a>Nothing</a> if the given entry is not a member of the
--   leftover set.
select :: IsUTxOSelection s u => Ord u => u -> s u -> Maybe (UTxOSelectionNonEmpty u)

-- | Moves multiple entries from the leftover set to the selected set.
selectMany :: IsUTxOSelection s u => Ord u => Foldable f => f u -> s u -> s u
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.Primitive.Types.UTxOSelection.State u)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.UTxOSelection.State u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.UTxOSelection.State u)
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.Primitive.Types.UTxOSelection.UTxOSelection u)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.UTxOSelection.UTxOSelection u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.UTxOSelection.UTxOSelection u)
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.Primitive.Types.UTxOSelection.UTxOSelectionNonEmpty u)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.UTxOSelection.UTxOSelectionNonEmpty u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.UTxOSelection.UTxOSelectionNonEmpty u)
instance Cardano.Wallet.Primitive.Types.UTxOSelection.HasUTxOSelectionState Cardano.Wallet.Primitive.Types.UTxOSelection.UTxOSelectionNonEmpty u
instance Cardano.Wallet.Primitive.Types.UTxOSelection.IsUTxOSelection Cardano.Wallet.Primitive.Types.UTxOSelection.UTxOSelectionNonEmpty u
instance Cardano.Wallet.Primitive.Types.UTxOSelection.HasUTxOSelectionState Cardano.Wallet.Primitive.Types.UTxOSelection.UTxOSelection u
instance Cardano.Wallet.Primitive.Types.UTxOSelection.IsUTxOSelection Cardano.Wallet.Primitive.Types.UTxOSelection.UTxOSelection u


-- | This module provides the main transaction data types used by the
--   wallet.
module Cardano.Wallet.Primitive.Types.Tx

-- | Primitive <tt>Tx</tt>-type.
--   
--   Currently tailored for jormungandr in that inputs are <tt>(TxIn,
--   Coin)</tt> instead of <tt>TxIn</tt>. We might have to revisit this
--   when supporting another node.
data Tx
Tx :: Hash "Tx" -> !Maybe Coin -> ![(TxIn, Coin)] -> ![(TxIn, Coin)] -> ![TxOut] -> !Maybe TxOut -> !Map RewardAccount Coin -> !Maybe TxMetadata -> !Maybe TxScriptValidity -> Tx

-- | JÃ¶rmungandr computes transaction id by hashing the full content of the
--   transaction, which includes witnesses. Therefore, we need either to
--   keep track of the witnesses to be able to re-compute the tx id every
--   time, or, simply keep track of the id itself.
[$sel:txId:Tx] :: Tx -> Hash "Tx"

-- | Explicit fee for that transaction, if available. Fee are available
--   explicitly in Shelley, but not in Byron although in Byron they can
--   easily be re-computed from the delta between outputs and inputs.
[$sel:fee:Tx] :: Tx -> !Maybe Coin

-- | NOTE: Order of inputs matters in the transaction representation. The
--   transaction id is computed from the binary representation of a tx, for
--   which inputs are serialized in a specific order.
[$sel:resolvedInputs:Tx] :: Tx -> ![(TxIn, Coin)]

-- | NOTE: The order of collateral inputs matters in the transaction
--   representation. The transaction id is computed from the binary
--   representation of a tx, for which collateral inputs are serialized in
--   a specific order.
[$sel:resolvedCollateralInputs:Tx] :: Tx -> ![(TxIn, Coin)]

-- | NOTE: Order of outputs matters in the transaction representations.
--   Outputs are used as inputs for next transactions which refer to them
--   using their indexes. It matters also for serialization.
[$sel:outputs:Tx] :: Tx -> ![TxOut]

-- | An output that is only created if a transaction script fails.
[$sel:collateralOutput:Tx] :: Tx -> !Maybe TxOut

-- | Withdrawals (of funds from a registered reward account) embedded in a
--   transaction. The order does not matter.
[$sel:withdrawals:Tx] :: Tx -> !Map RewardAccount Coin

-- | Semi-structured application-specific extension data stored in the
--   transaction on chain.
--   
--   This is not to be confused with <a>TxMeta</a>, which is information
--   about a transaction derived from the ledger.
--   
--   See Appendix E of <a>Shelley Ledger: Delegation/Incentives Design
--   Spec</a>.
[$sel:metadata:Tx] :: Tx -> !Maybe TxMetadata

-- | Tag indicating whether non-native scripts in this transaction passed
--   validation. This is added by the block creator when constructing the
--   block. May be <a>Nothing</a> for pre-Alonzo and pending transactions.
[$sel:scriptValidity:Tx] :: Tx -> !Maybe TxScriptValidity
data TxIn
TxIn :: !Hash "Tx" -> !Word32 -> TxIn
[$sel:inputId:TxIn] :: TxIn -> !Hash "Tx"
[$sel:inputIx:TxIn] :: TxIn -> !Word32
data TxOut
TxOut :: !Address -> !TokenBundle -> TxOut
[$sel:address:TxOut] :: TxOut -> !Address
[$sel:tokens:TxOut] :: TxOut -> !TokenBundle
data TxChange derivationPath
TxChange :: !Address -> !Coin -> !TokenMap -> derivationPath -> TxChange derivationPath
[$sel:address:TxChange] :: TxChange derivationPath -> !Address
[$sel:amount:TxChange] :: TxChange derivationPath -> !Coin
[$sel:assets:TxChange] :: TxChange derivationPath -> !TokenMap
[$sel:derivationPath:TxChange] :: TxChange derivationPath -> derivationPath

-- | Additional information about a transaction, derived from the
--   transaction and ledger state. This should not be confused with
--   <a>TxMetadata</a> which is application-specific data included with the
--   transaction.
--   
--   TODO: TxProperties or TxProps would be a good name for this type.
data TxMeta
TxMeta :: !TxStatus -> !Direction -> !SlotNo -> !Quantity "block" Word32 -> !Coin -> !Maybe SlotNo -> TxMeta
[$sel:status:TxMeta] :: TxMeta -> !TxStatus
[$sel:direction:TxMeta] :: TxMeta -> !Direction
[$sel:slotNo:TxMeta] :: TxMeta -> !SlotNo
[$sel:blockHeight:TxMeta] :: TxMeta -> !Quantity "block" Word32

-- | Amount seen from the perspective of the wallet. Refers either to a
--   spent value for outgoing transaction, or a received value on incoming
--   transaction.
[$sel:amount:TxMeta] :: TxMeta -> !Coin

-- | The slot at which a pending transaction will no longer be accepted
--   into mempools.
[$sel:expiry:TxMeta] :: TxMeta -> !Maybe SlotNo
newtype TxMetadata
TxMetadata :: Map Word64 TxMetadataValue -> TxMetadata
data TxMetadataValue
TxMetaMap :: [(TxMetadataValue, TxMetadataValue)] -> TxMetadataValue
TxMetaList :: [TxMetadataValue] -> TxMetadataValue
TxMetaNumber :: Integer -> TxMetadataValue
TxMetaBytes :: ByteString -> TxMetadataValue
TxMetaText :: Text -> TxMetadataValue
data TxStatus

-- | Created, but not yet in a block.
Pending :: TxStatus

-- | Has been found in a block.
InLedger :: TxStatus

-- | Time to live (TTL) has passed.
Expired :: TxStatus

-- | An unsigned transaction.
--   
--   See <a>Tx</a> for a signed transaction.
data UnsignedTx input output change withdrawal
UnsignedTx :: [input] -> [input] -> [output] -> [change] -> [withdrawal] -> UnsignedTx input output change withdrawal
[$sel:unsignedCollateral:UnsignedTx] :: UnsignedTx input output change withdrawal -> [input]

-- | Inputs are *necessarily* non-empty because Cardano requires at least
--   one UTxO input per transaction to prevent replayable transactions.
--   (each UTxO being unique, including at least one UTxO in the
--   transaction body makes it seemingly unique).
--   
--   <ul>
--   <li>However* when used to represent the inputs known by the wallet, in
--   contrast to all inputs, it can be empty.</li>
--   </ul>
[$sel:unsignedInputs:UnsignedTx] :: UnsignedTx input output change withdrawal -> [input]
[$sel:unsignedOutputs:UnsignedTx] :: UnsignedTx input output change withdrawal -> [output]
[$sel:unsignedChange:UnsignedTx] :: UnsignedTx input output change withdrawal -> [change]
[$sel:unsignedWithdrawals:UnsignedTx] :: UnsignedTx input output change withdrawal -> [withdrawal]

-- | Full expanded and resolved information about a transaction, suitable
--   for presentation to the user.
data TransactionInfo
TransactionInfo :: !Hash "Tx" -> !Maybe Coin -> ![(TxIn, Coin, Maybe TxOut)] -> ![(TxIn, Coin, Maybe TxOut)] -> ![TxOut] -> !Maybe TxOut -> !Map RewardAccount Coin -> !TxMeta -> Quantity "block" Natural -> UTCTime -> !Maybe TxMetadata -> !Maybe TxScriptValidity -> TransactionInfo

-- | Transaction ID of this transaction
[$sel:txInfoId:TransactionInfo] :: TransactionInfo -> !Hash "Tx"

-- | Explicit transaction fee
[$sel:txInfoFee:TransactionInfo] :: TransactionInfo -> !Maybe Coin

-- | Transaction inputs and (maybe) corresponding outputs of the source.
--   Source information can only be provided for outgoing payments.
[$sel:txInfoInputs:TransactionInfo] :: TransactionInfo -> ![(TxIn, Coin, Maybe TxOut)]

-- | Collateral inputs and (maybe) corresponding outputs.
[$sel:txInfoCollateralInputs:TransactionInfo] :: TransactionInfo -> ![(TxIn, Coin, Maybe TxOut)]

-- | Payment destination.
[$sel:txInfoOutputs:TransactionInfo] :: TransactionInfo -> ![TxOut]

-- | An output that is only created if a transaction script fails.
[$sel:txInfoCollateralOutput:TransactionInfo] :: TransactionInfo -> !Maybe TxOut

-- | Withdrawals on this transaction.
[$sel:txInfoWithdrawals:TransactionInfo] :: TransactionInfo -> !Map RewardAccount Coin

-- | Other information calculated from the transaction.
[$sel:txInfoMeta:TransactionInfo] :: TransactionInfo -> !TxMeta

-- | Number of slots since the transaction slot.
[$sel:txInfoDepth:TransactionInfo] :: TransactionInfo -> Quantity "block" Natural

-- | Creation time of the block including this transaction.
[$sel:txInfoTime:TransactionInfo] :: TransactionInfo -> UTCTime

-- | Application-specific extension data.
[$sel:txInfoMetadata:TransactionInfo] :: TransactionInfo -> !Maybe TxMetadata

-- | Tag indicating whether non-native scripts in this transaction passed
--   validation. This is added by the block creator when constructing the
--   block. May be <a>Nothing</a> for pre-Alonzo and pending transactions.
[$sel:txInfoScriptValidity:TransactionInfo] :: TransactionInfo -> !Maybe TxScriptValidity

-- | The effect of a <tt>Transaction</tt> on the wallet balance.
data Direction

-- | The wallet balance decreases.
Outgoing :: Direction

-- | The wallet balance increases or stays the same.
Incoming :: Direction

-- | Information about when a transaction was submitted to the local node.
--   This is used for scheduling resubmissions.
data LocalTxSubmissionStatus tx
LocalTxSubmissionStatus :: !Hash "Tx" -> !tx -> !SlotNo -> !SlotNo -> LocalTxSubmissionStatus tx
[$sel:txId:LocalTxSubmissionStatus] :: LocalTxSubmissionStatus tx -> !Hash "Tx"
[$sel:submittedTx:LocalTxSubmissionStatus] :: LocalTxSubmissionStatus tx -> !tx

-- | Time of first successful submission to the local node.
[$sel:firstSubmission:LocalTxSubmissionStatus] :: LocalTxSubmissionStatus tx -> !SlotNo

-- | Time of most recent resubmission attempt.
[$sel:latestSubmission:LocalTxSubmissionStatus] :: LocalTxSubmissionStatus tx -> !SlotNo

-- | A function capable of assessing the size of a token bundle relative to
--   the upper limit of what can be included in a single transaction
--   output.
--   
--   In general, a token bundle size assessment function <tt>f</tt> should
--   satisfy the following properties:
--   
--   <ul>
--   <li>Enlarging a bundle that exceeds the limit should also result in a
--   bundle that exceeds the limit: <tt> f b1 ==
--   TokenBundleSizeExceedsLimit ==&gt; f (b1 <tt>add</tt> b2) ==
--   TokenBundleSizeExceedsLimit </tt></li>
--   <li>Shrinking a bundle that's within the limit should also result in a
--   bundle that's within the limit: <tt> f b1 == TokenBundleWithinLimit
--   ==&gt; f (b1 <tt>difference</tt> b2) == TokenBundleWithinLimit
--   </tt></li>
--   </ul>
newtype TokenBundleSizeAssessor
TokenBundleSizeAssessor :: (TokenBundle -> TokenBundleSizeAssessment) -> TokenBundleSizeAssessor
[$sel:assessTokenBundleSize:TokenBundleSizeAssessor] :: TokenBundleSizeAssessor -> TokenBundle -> TokenBundleSizeAssessment

-- | Indicates the size of a token bundle relative to the upper limit of
--   what can be included in a single transaction output, defined by the
--   protocol.
data TokenBundleSizeAssessment

-- | Indicates that the size of a token bundle does not exceed the maximum
--   size that can be included in a transaction output.
TokenBundleSizeWithinLimit :: TokenBundleSizeAssessment

-- | Indicates that the size of a token bundle exceeds the maximum size
--   that can be included in a transaction output.
TokenBundleSizeExceedsLimit :: TokenBundleSizeAssessment

-- | Indicates whether or not a transaction is marked as having an invalid
--   script.
--   
--   Pre-Alonzo era, scripts were not supported.
data TxScriptValidity

-- | The transaction is not marked as having an invalid script.
TxScriptValid :: TxScriptValidity

-- | The transaction is marked as having an invalid script.
TxScriptInvalid :: TxScriptValidity

-- | Identify the location of a <a>ScriptWitness</a> within the context of
--   a <a>TxBody</a>. These are indexes of the objects within the
--   transaction that need or can use script witnesses: inputs, minted
--   assets, withdrawals and certificates. These are simple numeric
--   indices, enumerated from zero. Thus the indices are not stable if the
--   transaction body is modified.
data ScriptWitnessIndex

-- | The n'th transaction input, in the order of the <a>TxId</a>s.
ScriptWitnessIndexTxIn :: !Word -> ScriptWitnessIndex

-- | The n'th minting <a>PolicyId</a>, in the order of the
--   <a>PolicyId</a>s.
ScriptWitnessIndexMint :: !Word -> ScriptWitnessIndex

-- | The n'th certificate, in the list order of the certificates.
ScriptWitnessIndexCertificate :: !Word -> ScriptWitnessIndex

-- | The n'th withdrawal, in the order of the <a>StakeAddress</a>s.
ScriptWitnessIndexWithdrawal :: !Word -> ScriptWitnessIndex

-- | <a>SealedTx</a> is a transaction for any hard fork era, possibly
--   incomplete, possibly unsigned, with dual representations to make it
--   convenient to use.
--   
--   Serialisation/deserialisation is usually done at the application
--   boundaries (e.g. in the API server), and then the wallet core can use
--   it either as a <a>ByteString</a>, or as a <a>Tx</a>.
--   
--   Construct it with either <a>sealedTxFromCardano</a> or
--   <a>sealedTxFromBytes</a>.
data SealedTx
cardanoTxIdeallyNoLaterThan :: AnyCardanoEra -> SealedTx -> InAnyCardanoEra Tx

-- | Deserialise a transaction to construct a <a>SealedTx</a>.
sealedTxFromBytes :: ByteString -> Either DecoderError SealedTx

-- | Deserialise a transaction to construct a <a>SealedTx</a>.
sealedTxFromBytes' :: AnyCardanoEra -> ByteString -> Either DecoderError SealedTx

-- | Construct a <a>SealedTx</a> from a <a>Cardano.Api</a> transaction.
sealedTxFromCardano :: InAnyCardanoEra Tx -> SealedTx

-- | Construct a <a>SealedTx</a> from a <a>Cardano.Api</a> transaction.
sealedTxFromCardano' :: IsCardanoEra era => Tx era -> SealedTx

-- | Construct a <a>SealedTx</a> from a <a>TxBody</a>.
sealedTxFromCardanoBody :: IsCardanoEra era => TxBody era -> SealedTx

-- | Get the serialised transaction body and witnesses from a
--   <a>SealedTx</a>.
getSerialisedTxParts :: SealedTx -> SerialisedTxParts

-- | Only use this for tests.
unsafeSealedTxFromBytes :: HasCallStack => ByteString -> SealedTx

-- | A serialised transaction that may be only partially signed, or even
--   invalid.
newtype SerialisedTx
SerialisedTx :: ByteString -> SerialisedTx
[$sel:payload:SerialisedTx] :: SerialisedTx -> ByteString

-- | <tt>SerialisedTxParts</tt> is a serialised transaction body, and a
--   possibly incomplete set of serialised witnesses.
data SerialisedTxParts
SerialisedTxParts :: ByteString -> [ByteString] -> SerialisedTxParts
[$sel:serialisedTxBody:SerialisedTxParts] :: SerialisedTxParts -> ByteString
[$sel:serialisedTxWitnesses:SerialisedTxParts] :: SerialisedTxParts -> [ByteString]
getSealedTxBody :: SealedTx -> InAnyCardanoEra TxBody
getSealedTxWitnesses :: SealedTx -> [InAnyCardanoEra KeyWitness]

-- | Serialise a <a>SealedTx</a> for storage in a database field. The
--   difference between <a>persistSealedTx</a> and
--   <a>$sel:serialisedTx:SealedTx</a> is that this function has a special
--   check for values created by <a>mockSealedTx</a>.
persistSealedTx :: SealedTx -> ByteString

-- | Deserialise a <a>SealedTx</a> which has been stored in a database
--   field. This function includes a special check for <a>mockSealedTx</a>
--   values.
unPersistSealedTx :: ByteString -> Either Text SealedTx

-- | Construct a <a>SealedTx</a> from a string which need not be a
--   well-formed serialised Cardano transaction.
--   
--   Be careful using the <a>SealedTx</a>, because any attempt to evaluate
--   its <tt>cardanoTx</tt> field will crash.
mockSealedTx :: HasCallStack => ByteString -> SealedTx

-- | <tt>a <a>withinEra</a> b</tt> is <a>True</a> iff <tt>b</tt> is the
--   same era as <tt>a</tt>, or an earlier one.
withinEra :: AnyCardanoEra -> AnyCardanoEra -> Bool

-- | Reconstruct a transaction info from a transaction.
fromTransactionInfo :: TransactionInfo -> Tx
inputs :: Tx -> [TxIn]
collateralInputs :: Tx -> [TxIn]

-- | True if the given metadata refers to a pending transaction
isPending :: TxMeta -> Bool

-- | Drop time-specific information
toTxHistory :: TransactionInfo -> (Tx, TxMeta)
txIns :: Set Tx -> Set TxIn

-- | Test whether the given metadata map is empty.
txMetadataIsNull :: TxMetadata -> Bool
txOutCoin :: TxOut -> Coin

-- | Increments the <a>Coin</a> value of a <a>TxOut</a>.
--   
--   Satisfies the following property for all values of <tt>c</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; txOutSubtractCoin c . txOutAddCoin c == id
--   </pre>
txOutAddCoin :: Coin -> TxOut -> TxOut

-- | Decrements the <a>Coin</a> value of a <a>TxOut</a>.
--   
--   Satisfies the following property for all values of <tt>c</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; txOutSubtractCoin c . txOutAddCoin c == id
--   </pre>
--   
--   If the given <a>Coin</a> is greater than the <a>Coin</a> value of the
--   given <a>TxOut</a>, the resulting <a>TxOut</a> will have a <a>Coin</a>
--   value of zero.
txOutSubtractCoin :: Coin -> TxOut -> TxOut

-- | Returns <a>True</a> if (and only if) the given transaction is marked
--   as having an invalid script.
--   
--   This function does not actually verify the validity of scripts; it
--   merely checks for the presence or absence of the
--   <a>TxScriptInvalid</a> marker.
txScriptInvalid :: Tx -> Bool

-- | The smallest quantity of lovelace that can appear in a transaction
--   output's token bundle.
txOutMinCoin :: Coin

-- | The greatest quantity of lovelace that can appear in a transaction
--   output's token bundle.
txOutMaxCoin :: Coin

-- | The smallest token quantity that can appear in a transaction output's
--   token bundle.
txOutMinTokenQuantity :: TokenQuantity

-- | The greatest token quantity that can appear in a transaction output's
--   token bundle.
--   
--   Although the ledger specification allows token quantities of unlimited
--   sizes, in practice we'll only see transaction outputs where the token
--   quantities are bounded by the size of a <a>Word64</a>.
txOutMaxTokenQuantity :: TokenQuantity

-- | The greatest quantity of any given token that can be minted or burned
--   in a transaction.
txMintBurnMaxTokenQuantity :: TokenQuantity

-- | Provides an abstract cost and size model for transactions.
--   
--   This allows parts of a transaction to be costed (or sized)
--   individually, without having to compute the cost (or size) of an
--   entire transaction.
--   
--   Note that the following functions assume one witness is required per
--   input:
--   
--   <ul>
--   <li><a>$sel:txInputCost:TxConstraints</a></li>
--   <li><a>$sel:txInputSize:TxConstraints</a></li>
--   </ul>
--   
--   This will lead to slight overestimation in the case of UTxOs that
--   share the same payment key.
data TxConstraints
TxConstraints :: Coin -> TxSize -> Coin -> TxSize -> (TokenBundle -> Coin) -> (TokenBundle -> TxSize) -> TxSize -> TokenQuantity -> (Address -> TokenMap -> Coin) -> (Address -> TokenBundle -> Bool) -> (Coin -> Coin) -> (Coin -> TxSize) -> TxSize -> TxConstraints

-- | The constant cost of an empty transaction.
[$sel:txBaseCost:TxConstraints] :: TxConstraints -> Coin

-- | The constant size of an empty transaction.
[$sel:txBaseSize:TxConstraints] :: TxConstraints -> TxSize

-- | The constant cost of a transaction input, assuming one witness is
--   required per input.
[$sel:txInputCost:TxConstraints] :: TxConstraints -> Coin

-- | The constant size of a transaction input, assuming one witness is
--   required per input.
[$sel:txInputSize:TxConstraints] :: TxConstraints -> TxSize

-- | The variable cost of a transaction output.
[$sel:txOutputCost:TxConstraints] :: TxConstraints -> TokenBundle -> Coin

-- | The variable size of a transaction output.
[$sel:txOutputSize:TxConstraints] :: TxConstraints -> TokenBundle -> TxSize

-- | The maximum size of a transaction output.
[$sel:txOutputMaximumSize:TxConstraints] :: TxConstraints -> TxSize

-- | The maximum token quantity that can appear in a transaction output.
[$sel:txOutputMaximumTokenQuantity:TxConstraints] :: TxConstraints -> TokenQuantity

-- | The variable minimum ada quantity of a transaction output.
[$sel:txOutputMinimumAdaQuantity:TxConstraints] :: TxConstraints -> Address -> TokenMap -> Coin

-- | Returns <a>True</a> if the given <a>TokenBundle</a> has a <a>Coin</a>
--   value that is below the minimum required.
[$sel:txOutputBelowMinimumAdaQuantity:TxConstraints] :: TxConstraints -> Address -> TokenBundle -> Bool

-- | The variable cost of a reward withdrawal.
[$sel:txRewardWithdrawalCost:TxConstraints] :: TxConstraints -> Coin -> Coin

-- | The variable size of a reward withdrawal.
[$sel:txRewardWithdrawalSize:TxConstraints] :: TxConstraints -> Coin -> TxSize

-- | The maximum size of a transaction.
[$sel:txMaximumSize:TxConstraints] :: TxConstraints -> TxSize
txOutputCoinCost :: TxConstraints -> Coin -> Coin
txOutputCoinSize :: TxConstraints -> Coin -> TxSize
txOutputHasValidSize :: TxConstraints -> TokenBundle -> Bool
txOutputHasValidTokenQuantities :: TxConstraints -> TokenMap -> Bool

-- | The size of a transaction, or part of a transaction, in bytes.
newtype TxSize
TxSize :: Natural -> TxSize
[$sel:unTxSize:TxSize] :: TxSize -> Natural

-- | Computes the absolute distance between two transaction size
--   quantities.
txSizeDistance :: TxSize -> TxSize -> TxSize
txAssetIds :: Tx -> Set AssetId
txOutAssetIds :: TxOut -> Set AssetId
txMapAssetIds :: (AssetId -> AssetId) -> Tx -> Tx
txMapTxIds :: (Hash "Tx" -> Hash "Tx") -> Tx -> Tx
txRemoveAssetId :: Tx -> AssetId -> Tx
txOutMapAssetIds :: (AssetId -> AssetId) -> TxOut -> TxOut
txOutRemoveAssetId :: TxOut -> AssetId -> TxOut
coinIsValidForTxOut :: Coin -> Bool

-- | Converts the given <a>Coin</a> value to a value that can be included
--   in a transaction output.
--   
--   Callers of this function must take responsibility for checking that
--   the given value is:
--   
--   <ul>
--   <li>not smaller than <a>txOutMinCoin</a></li>
--   <li>not greater than <a>txOutMaxCoin</a></li>
--   </ul>
--   
--   This function throws a run-time error if the pre-condition is
--   violated.
unsafeCoinToTxOutCoinValue :: HasCallStack => Coin -> Word64
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx.TxIn
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.TxIn
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.TxIn
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.TxIn
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.Tx.TxIn
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.TxOut
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.TxOut
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.Tx.TxOut
instance ((TypeError ...), GHC.Classes.Ord derivationPath) => GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.Tx.TxChange derivationPath)
instance GHC.Classes.Eq derivationPath => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Tx.TxChange derivationPath)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.Tx.TxChange derivationPath)
instance GHC.Show.Show derivationPath => GHC.Show.Show (Cardano.Wallet.Primitive.Types.Tx.TxChange derivationPath)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance (GHC.Show.Show input, GHC.Show.Show output, GHC.Show.Show change, GHC.Show.Show withdrawal) => GHC.Show.Show (Cardano.Wallet.Primitive.Types.Tx.UnsignedTx input output change withdrawal)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.Tx.UnsignedTx input output change withdrawal)
instance (GHC.Classes.Eq input, GHC.Classes.Eq output, GHC.Classes.Eq change, GHC.Classes.Eq withdrawal) => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Tx.UnsignedTx input output change withdrawal)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.Direction
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx.Direction
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.Direction
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.Tx.Direction
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.Tx.Direction
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.Direction
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.TxMeta
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx.TxMeta
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.TxMeta
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.TxMeta
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.SealedTx
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.SerialisedTx
instance Data.ByteArray.Types.ByteArrayAccess Cardano.Wallet.Primitive.Types.Tx.SerialisedTx
instance Data.ByteArray.Types.ByteArray Cardano.Wallet.Primitive.Types.Tx.SerialisedTx
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.Tx.SerialisedTx
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.Tx.SerialisedTx
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx.SerialisedTx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.SerialisedTx
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.SerialisedTx
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.SerialisedTx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.SerialisedTxParts
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.SerialisedTxParts
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.SerialisedTxParts
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx.TxScriptValidity
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.TxScriptValidity
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.TxScriptValidity
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.TxScriptValidity
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.TransactionInfo
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.TransactionInfo
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.TransactionInfo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.Tx
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx.Tx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.Tx
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.Tx
instance GHC.Base.Functor Cardano.Wallet.Primitive.Types.Tx.LocalTxSubmissionStatus
instance GHC.Classes.Eq tx => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Tx.LocalTxSubmissionStatus tx)
instance GHC.Show.Show tx => GHC.Show.Show (Cardano.Wallet.Primitive.Types.Tx.LocalTxSubmissionStatus tx)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.Tx.LocalTxSubmissionStatus tx)
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.TokenBundleSizeAssessment
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.TokenBundleSizeAssessment
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.TokenBundleSizeAssessment
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.TokenBundleSizeAssessor
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.TxSize
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.TxSize
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx.TxSize
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.TxSize
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.TxConstraints
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.TxSize
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.Tx.TxSize
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.Tx.TxSize
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.Tx
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Tx.Tx
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.TransactionInfo
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Tx.TxScriptValidity
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.TxScriptValidity
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.SealedTx
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Tx.SealedTx
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.SealedTx
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.SealedTx
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Tx.TxMeta
instance Formatting.Buildable.Buildable a => Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.Tx.WithDirection a)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.TxMeta
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.Direction
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Tx.Direction
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.Tx.Direction
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.Tx.Direction
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx.TxOut
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.TxOut
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Tx.TxOut
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.Tx.TxIn, Cardano.Wallet.Primitive.Types.Tx.TxOut)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Tx.TxIn
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Tx.TxIn


-- | This module provides the main <a>UTxO</a> data type used by the
--   wallet.
module Cardano.Wallet.Primitive.Types.UTxO
newtype UTxO
UTxO :: Map TxIn TxOut -> UTxO
[unUTxO] :: UTxO -> Map TxIn TxOut

-- | Domain of a <a>UTxO</a> = the set of <i>inputs</i> of the <i>utxo</i>.
dom :: UTxO -> Set TxIn
null :: UTxO -> Bool
size :: UTxO -> Int

-- | Compute the balance of a UTxO
balance :: UTxO -> TokenBundle

-- | a âŠ† b
isSubsetOf :: UTxO -> UTxO -> Bool
empty :: UTxO

-- | Indicates whether a pair of UTxO sets are disjoint.
disjoint :: UTxO -> UTxO -> Bool

-- | insâ‹ª u
excluding :: UTxO -> Set TxIn -> UTxO

-- | insâŠ² u
restrictedBy :: UTxO -> Set TxIn -> UTxO

-- | u âŠ³ outs
restrictedTo :: UTxO -> Set TxOut -> UTxO
difference :: UTxO -> UTxO -> UTxO

-- | Partitions a UTxO set according to a condition.
--   
--   <pre>
--   filter p a == a &amp;&amp; filter (not . p) b == b
--     where (a,b) = partition p utxo
--   </pre>
partition :: (TxIn -> Bool) -> UTxO -> (UTxO, UTxO)

-- | Lookup an input in the UTXO
lookup :: TxIn -> UTxO -> Maybe TxOut

-- | Filters a UTxO set according to a condition.
filter :: (TxIn -> Bool) -> UTxO -> UTxO

-- | Filters a <a>UTxO</a> set with an indicator function on <a>Address</a>
--   values.
--   
--   Returns the subset of UTxO entries that have addresses for which the
--   given indicator function returns <a>True</a>.
filterByAddressM :: forall f. Monad f => (Address -> f Bool) -> UTxO -> f UTxO

-- | Filters a <a>UTxO</a> set with an indicator function on <a>Address</a>
--   values.
--   
--   Returns the subset of UTxO entries that have addresses for which the
--   given indicator function returns <a>True</a>.
--   
--   filterByAddress f u = runIdentity $ filterByAddressM (pure . f) u
--   filterByAddress (const True) u = u filterByAddress (const False) u =
--   mempty filterByAddress f mempty = mempty filterByAddress f u
--   <a>isSubsetOf</a> u
filterByAddress :: (Address -> Bool) -> UTxO -> UTxO

-- | Converts a UTxO set into a list of UTxO elements.
toList :: UTxO -> [(TxIn, TxOut)]

-- | Efficient delta encoding for <a>UTxO</a>.
data DeltaUTxO

-- | First exclude these inputs
excluded :: DeltaUTxO -> Set TxIn

-- | Then receive these additional outputs.
received :: DeltaUTxO -> UTxO

-- | Exclude a set of transaction inputs, typically because we spend them.
excludingD :: UTxO -> Set TxIn -> (DeltaUTxO, UTxO)

-- | Receive additional <a>UTxO</a> / union.
receiveD :: UTxO -> UTxO -> (DeltaUTxO, UTxO)
assetIds :: UTxO -> Set AssetId
txIds :: UTxO -> Set (Hash "Tx")
mapAssetIds :: (AssetId -> AssetId) -> UTxO -> UTxO

-- | Applies a mapping on transaction identifiers to a <a>UTxO</a> set.
--   
--   If the provided mapping gives rise to a collision within the
--   <a>TxIn</a> key set, then only the smallest <a>TxOut</a> is retained,
--   according to the <a>Ord</a> instance for <a>TxOut</a>.
mapTxIds :: (Hash "Tx" -> Hash "Tx") -> UTxO -> UTxO
removeAssetId :: UTxO -> AssetId -> UTxO
data UTxOStatistics
UTxOStatistics :: ![HistogramBar] -> !Word64 -> BoundType -> UTxOStatistics
[histogram] :: UTxOStatistics -> ![HistogramBar]
[allStakes] :: UTxOStatistics -> !Word64
[boundType] :: UTxOStatistics -> BoundType
data BoundType
data HistogramBar
HistogramBar :: !Word64 -> !Word64 -> HistogramBar
[bucketUpperBound] :: HistogramBar -> !Word64
[bucketCount] :: HistogramBar -> !Word64

-- | A more generic function for computing UTxO statistics on some other
--   type of data that maps to UTxO's values.
computeStatistics :: (a -> [Word64]) -> BoundType -> [a] -> UTxOStatistics

-- | Compute UtxoStatistics from UTxOs
computeUtxoStatistics :: BoundType -> UTxO -> UTxOStatistics

-- | Smart-constructor to create bounds using a log-10 scale
log10 :: BoundType
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.UTxO.UTxO
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.UTxO.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.UTxO.UTxO
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxO.UTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxO.UTxO
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxO.UTxO
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxO.DeltaUTxO
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxO.DeltaUTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxO.DeltaUTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxO.HistogramBar
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.UTxO.HistogramBar
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxO.HistogramBar
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxO.HistogramBar
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxO.BoundType
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.UTxO.BoundType
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxO.BoundType
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxO.BoundType
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.UTxO.UTxOStatistics
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.UTxO.UTxOStatistics
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.UTxO.UTxOStatistics
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.UTxO.UTxOStatistics
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.UTxO.UTxOStatistics
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.UTxO.UTxOStatistics
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.UTxO.BoundType
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.UTxO.HistogramBar
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.UTxO.HistogramBar
instance Data.Delta.Delta Cardano.Wallet.Primitive.Types.UTxO.DeltaUTxO
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Types.UTxO.DeltaUTxO
instance GHC.Base.Monoid Cardano.Wallet.Primitive.Types.UTxO.DeltaUTxO
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.UTxO.UTxO
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.UTxO.UTxO


-- | Types and functions relating to Plutus script redeemers
module Cardano.Wallet.Primitive.Types.Redeemer
data Redeemer
RedeemerSpending :: ByteString -> TxIn -> Redeemer
RedeemerMinting :: ByteString -> TokenPolicyId -> Redeemer
RedeemerRewarding :: ByteString -> StakeAddress -> Redeemer
redeemerData :: Redeemer -> ByteString
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Redeemer.Redeemer
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Redeemer.Redeemer
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Redeemer.Redeemer
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Redeemer.Redeemer


-- | A wrapper around TxMetadata to allow different JSON codecs. (ADP-1596)
--   see
--   <a>https://github.com/input-output-hk/cardano-node/blob/master/cardano-api/src/Cardano/Api/TxMetadata.hs</a>
module Cardano.Wallet.Api.Types.SchemaMetadata

-- | A tag to select the json codec
data TxMetadataSchema
TxMetadataNoSchema :: TxMetadataSchema
TxMetadataDetailedSchema :: TxMetadataSchema

-- | A wrapper to drive the json codec of metadata
data TxMetadataWithSchema
TxMetadataWithSchema :: TxMetadataSchema -> TxMetadata -> TxMetadataWithSchema

-- | How to codec the metadata into json
[txMetadataWithSchema_schema] :: TxMetadataWithSchema -> TxMetadataSchema

-- | The metadata
[txMetadataWithSchema_metadata] :: TxMetadataWithSchema -> TxMetadata

-- | Parses a Boolean "simple-metadata" API flag.
--   
--   <pre>
--   toSimpleMetadataFlag . parseSimpleMetadataFlag == id
--   </pre>
--   
--   <pre>
--   parseSimpleMetadataFlag . toSimpleMetadataFlag == id
--   </pre>
parseSimpleMetadataFlag :: Bool -> TxMetadataSchema

-- | Produces a Boolean "simple-metadata" API flag.
--   
--   <pre>
--   toSimpleMetadataFlag . parseSimpleMetadataFlag == id
--   </pre>
--   
--   <pre>
--   parseSimpleMetadataFlag . toSimpleMetadataFlag == id
--   </pre>
toSimpleMetadataFlag :: TxMetadataSchema -> Bool
detailedMetadata :: TxMetadata -> TxMetadataWithSchema
noSchemaMetadata :: TxMetadata -> TxMetadataWithSchema
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.SchemaMetadata.TxMetadataSchema
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.SchemaMetadata.TxMetadataSchema
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.SchemaMetadata.TxMetadataSchema
instance GHC.Show.Show Cardano.Wallet.Api.Types.SchemaMetadata.TxMetadataSchema
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.SchemaMetadata.TxMetadataWithSchema
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.SchemaMetadata.TxMetadataWithSchema
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.SchemaMetadata.TxMetadataWithSchema
instance GHC.Show.Show Cardano.Wallet.Api.Types.SchemaMetadata.TxMetadataWithSchema
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.SchemaMetadata.TxMetadataWithSchema
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.SchemaMetadata.TxMetadataWithSchema


-- | Defines the <a>MinimumUTxO</a> type and related functions.
module Cardano.Wallet.Primitive.Types.MinimumUTxO

-- | Represents a function for computing minimum UTxO values.
data MinimumUTxO
[MinimumUTxONone] :: MinimumUTxO
[MinimumUTxOConstant] :: Coin -> MinimumUTxO
[MinimumUTxOForShelleyBasedEraOf] :: MinimumUTxOForShelleyBasedEra -> MinimumUTxO

-- | Represents a minimum UTxO function that is specific to a Shelley-based
--   era.
data MinimumUTxOForShelleyBasedEra
[MinimumUTxOForShelleyBasedEra] :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> MinimumUTxOForShelleyBasedEra
minimumUTxONone :: MinimumUTxO
minimumUTxOConstant :: Coin -> MinimumUTxO
minimumUTxOForShelleyBasedEra :: ShelleyBasedEra era -> PParams (ShelleyLedgerEra era) -> MinimumUTxO
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.MinimumUTxO.MinimumUTxO
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.MinimumUTxO.MinimumUTxO
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.MinimumUTxO.MinimumUTxO
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.MinimumUTxO.MinimumUTxO
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.MinimumUTxO.MinimumUTxOForShelleyBasedEra
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.MinimumUTxO.MinimumUTxOForShelleyBasedEra
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.MinimumUTxO.MinimumUTxOForShelleyBasedEra
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.MinimumUTxO.MinimumUTxOForShelleyBasedEra

module Cardano.Wallet.Primitive.Types.Coin.Gen
chooseCoin :: (Coin, Coin) -> Gen Coin
genCoin :: Gen Coin
genCoinPositive :: Gen Coin
shrinkCoin :: Coin -> [Coin]
shrinkCoinPositive :: Coin -> [Coin]

-- | Partitions a coin randomly into a given number of parts.
--   
--   Satisfies the following properties:
--   
--   <pre>
--   forAll (genCoinPartition c i) $ (==       c) . fold
--   </pre>
--   
--   <pre>
--   forAll (genCoinPartition c i) $ (== max 1 i) . length
--   </pre>
genCoinPartition :: Coin -> Int -> Gen (NonEmpty Coin)

module Cardano.Wallet.Primitive.Types.TokenBundle.Gen
genTokenBundleSmallRange :: Gen TokenBundle
genTokenBundleSmallRangePositive :: Gen TokenBundle
genTokenBundle :: Gen TokenBundle
shrinkTokenBundle :: TokenBundle -> [TokenBundle]
shrinkTokenBundleSmallRange :: TokenBundle -> [TokenBundle]
shrinkTokenBundleSmallRangePositive :: TokenBundle -> [TokenBundle]

-- | Partitions a token bundle randomly into a given number of parts.
--   
--   Satisfies the following properties:
--   
--   <pre>
--   forAll (genTokenBundlePartition b i) $ (==       b) . fold
--   </pre>
--   
--   <pre>
--   forAll (genTokenBundlePartition b i) $ (== max 1 i) . length
--   </pre>
genTokenBundlePartition :: TokenBundle -> Int -> Gen (NonEmpty TokenBundle)

-- | Like <a>genTokenBundlePartition</a>, but with empty values removed
--   from the result.
genTokenBundlePartitionNonNull :: TokenBundle -> Int -> Gen [TokenBundle]

module Cardano.Wallet.Primitive.Types.UTxOIndex.Gen
genUTxOIndex :: forall u. Ord u => Gen u -> Gen (UTxOIndex u)
genUTxOIndexLarge :: Ord u => Gen u -> Gen (UTxOIndex u)
genUTxOIndexLargeN :: forall u. Ord u => Gen u -> Int -> Gen (UTxOIndex u)
shrinkUTxOIndex :: forall u. Ord u => (u -> [u]) -> UTxOIndex u -> [UTxOIndex u]

module Cardano.Wallet.Primitive.Types.UTxOSelection.Gen
genUTxOSelection :: forall u. (Ord u, Show u) => Gen u -> Gen (UTxOSelection u)
genUTxOSelectionNonEmpty :: (Ord u, Show u) => Gen u -> Gen (UTxOSelectionNonEmpty u)
shrinkUTxOSelection :: Ord u => (u -> [u]) -> UTxOSelection u -> [UTxOSelection u]
shrinkUTxOSelectionNonEmpty :: Ord u => (u -> [u]) -> UTxOSelectionNonEmpty u -> [UTxOSelectionNonEmpty u]


-- | Defines generators and shrinkers for the <a>MinimumUTxO</a> data type.
module Cardano.Wallet.Primitive.Types.MinimumUTxO.Gen
genMinimumUTxO :: Gen MinimumUTxO
genMinimumUTxOForShelleyBasedEra :: Gen MinimumUTxOForShelleyBasedEra
shrinkMinimumUTxO :: MinimumUTxO -> [MinimumUTxO]
shrinkMinimumUTxOForShelleyBasedEra :: MinimumUTxOForShelleyBasedEra -> [MinimumUTxOForShelleyBasedEra]

-- | A test value of the Shelley-era <tt>minUTxOValue</tt> parameter.
--   
--   Value derived from 'mainnet-shelley-genesis.json'.
testParameter_minUTxOValue_Shelley :: Coin

-- | A test value of the Allegra-era <tt>minUTxOValue</tt> parameter.
--   
--   Value derived from 'mainnet-shelley-genesis.json'.
testParameter_minUTxOValue_Allegra :: Coin

-- | A test value of the Mary-era <tt>minUTxOValue</tt> parameter.
--   
--   Value derived from 'mainnet-shelley-genesis.json'.
testParameter_minUTxOValue_Mary :: Coin

-- | A test value of the Alonzo-era <tt>coinsPerUTxOWord</tt> parameter.
--   
--   Value derived from 'mainnet-alonzo-genesis.json'.
testParameter_coinsPerUTxOWord_Alonzo :: Coin

-- | A test value of the Babbage-era <tt>coinsPerUTxOByte</tt> parameter.
--   
--   Value derived from 'mainnet-alonzo-genesis.json': &gt;&gt;&gt; 34_482
--   <a>div</a> 8 == 4_310
testParameter_coinsPerUTxOByte_Babbage :: Coin

module Cardano.Wallet.Primitive.Delegation.UTxO

-- | Calculate how much <a>Coin</a> exists on each `Maybe RewardAccount` in
--   the <a>UTxO</a> given a way to extract `Maybe RewardAccount` from an
--   <a>Address</a>.
--   
--   This is intended to be used with <tt>rewardAccountFromAddress</tt>,
--   which exists elsewhere because of the cardano-wallet-core /
--   cardano-wallet split.
stakeKeyCoinDistr :: (Address -> Maybe RewardAccount) -> UTxO -> Map (Maybe RewardAccount) Coin


-- | Module for <a>DelegationState</a>.
module Cardano.Wallet.Primitive.Delegation.State

-- | Delegation state
--   
--   <h3>Goals</h3>
--   
--   <ol>
--   <li>Allow a wallet to have an arbitrary number of stake keys</li>
--   <li>Ensure those stake keys can be automatically discovered
--   on-chain</li>
--   <li>Ensure the wallet is always aware of all stake keys it registers,
--   even in the case of concurrent user actions on multiple wallet
--   instances, and old wallet software.</li>
--   </ol>
--   
--   <h3>How</h3>
--   
--   We track a consecutive range of keys that is extended with delegation
--   of the next unused key, and shrunk with key de-registration. We use a
--   <a>PointerUTxO</a> to ensure that transactions changing the state
--   can't be accepted to the ledger in any other order than intended. We
--   also need some special care regarding stake key 0, which old wallet
--   software could try to de-register.
--   
--   <h3>Diagram</h3>
--   
--   Diagram of states, where the list denotes active (registered
--   <i>and</i> delegating) keys.
--   
--   Here we assume the minUTxOValue is 1 ada.
--   
--   Note that intermediate steps for the <a>PointerUTxO</a> should be
--   skipped within a transaction. E.g. to transition from [] to [0,1,2] we
--   should deposit 1 ada to key 3, skipping key 2.
--   
--   See the implementation of <a>setPortfolioOf</a> and <a>applyTx</a> for
--   more details.
--   
--   <pre>
--   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
--   â”‚                    â”‚           â”‚                    â”‚                     â”‚                    â”‚            â”‚                     â”‚
--   â”‚                    â”‚           â”‚                    â”‚       Pointer       â”‚                    â”‚            â”‚                     â”‚
--   â”‚                    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚                    â”‚ â”€â”€â”€â”€â”€â”€depositâ”€â”€â”€â”€â”€â”€â–¶â”‚                    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚                     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
--   â”‚                    â”‚           â”‚                    â”‚                     â”‚       [0,1]        â”‚            â”‚       [0,1,2]       â”‚
--   â”‚         []         â”‚           â”‚        [0]         â”‚                     â”‚1 ada held by key 2 â”‚            â”‚ 1 ada held by key 3 â”‚
--   â”‚                    â”‚           â”‚                    â”‚                     â”‚                    â”‚            â”‚                     â”‚
--   â”‚                    â”‚           â”‚                    â”‚       Pointer       â”‚                    â”‚            â”‚                     â”‚
--   â”‚                    â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚                    â”‚ â—€â”€â”€â”€â”€â”€deposit â”€â”€â”€â”€â”€â”€â”‚                    â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--   â”‚                    â”‚           â”‚                    â”‚       returned      â”‚                    â”‚            â”‚                     â”‚
--   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â—€â”€â”€â”       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²            â–²â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–²            â–²
--                            â””â”€â”€â”€â”                                                     â”‚       â–²     â””â”€â”         â”Œâ”˜      â”‚       â–²      â””â”€â”         â”Œâ”˜
--   Normal states                â””â”€â”€â”€â”                                                 â”‚       â”‚       â””â”€â”     â”Œâ”€â”˜       â”‚       â”‚        â””â”€â”     â”Œâ”€â”˜
--                                    â””â”€â”€â”€â”                                             â”‚       â”‚         â””â”€â” â”Œâ”€â”˜         â”‚       â”‚          â””â”€â” â”Œâ”€â”˜
--   â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â””â”€â”€â”€â”â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â”‚â•³â•³â•³â•³â•³â•³â•³â”‚â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â”‚ â”‚â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â•³â”‚â•³â•³â•³â•³â•³â•³â•³â”‚â•³â•³â•³â•³â•³â•³â–¶     â”œâ”€â”¤
--                                            â””â”€â”€â”€â”                                     â”‚       â”‚         â”Œâ”€â”˜ â””â”€â”         â”‚       â”‚          â”Œâ”€â”˜ â””â”€â”
--   States caused by                             â””â”€â”€â”€â”€â”Pointer                         â–¼       â”‚       â”Œâ”€â”˜     â””â”€â”       â–¼       â”‚        â”Œâ”€â”˜     â””â”€â”
--   old wallet                                        â””deposit                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”€â”˜         â””â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”€â”˜         â””â”€
--   de-registering                                     returnedâ”€â”               â”‚                    â”‚            â”‚                     â”‚
--   stake-key 0                                                 â””â”€â”€â”€â”€â”          â”‚                    â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ â”‚                     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶
--   of multi-stake                                                   â””â”€â”€â”€â”€â”     â”‚                    â”‚            â”‚                     â”‚
--   key wallet                                                            â””â”€â”€â”€â”€ â”‚        [1]         â”‚            â”‚        [1,2]        â”‚
--                                                                               â”‚1 ada held by key 2 â”‚            â”‚ 1 ada held by key 3 â”‚
--                                                                               â”‚                    â”‚            â”‚                     â”‚
--                                                                               â”‚                    â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚                     â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
--                                                                               â”‚                    â”‚            â”‚                     â”‚
--                                                                               â”‚                    â”‚            â”‚                     â”‚
--                                                                               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--   </pre>
data DelegationState k
DelegationState :: k 'AccountK XPub -> State -> DelegationState k

-- | The account public key from which the stake keys should be derived.
[rewardAccountKey] :: DelegationState k -> k 'AccountK XPub
[state] :: DelegationState k -> State

-- | Construct the initial delegation state.
initialDelegationState :: k 'AccountK XPub -> DelegationState k

-- | All stake keys worth listing to the user.
--   
--   May include: 1. Active stake keys 2. The next un-active key
--   
--   NOTE: In theory we might want also present stake keys that are
--   unexpectedly registered, as they could be de-registered to reclaim the
--   deposit, but this should in-practice never happen.
--   
--   If <tt>sn</tt> denotes the state with <tt>n</tt> registered and
--   delegating keys: &gt;&gt;&gt; presentableKeys s0 [0] &gt;&gt;&gt;
--   presentableKeys s1 [0, 1] &gt;&gt;&gt; presentableKeys s2 [0, 1, 2]
presentableKeys :: SoftDerivation k => DelegationState k -> [k 'AddressK XPub]
usableKeys :: SoftDerivation k => DelegationState k -> [k 'AddressK XPub]

-- | For testing. Returns all registered and delegating stake keys.
activeKeys :: SoftDerivation k => DelegationState k -> [k 'AddressK XPub]
keyAtIx :: SoftDerivation k => DelegationState k -> Index 'Soft 'AddressK -> k 'AddressK XPub
lastActiveIx :: DelegationState k -> Maybe (Index 'Soft 'AddressK)
data PointerUTxO
PointerUTxO :: TxIn -> Coin -> PointerUTxO
[pTxIn] :: PointerUTxO -> TxIn
[pCoin] :: PointerUTxO -> Coin

-- | The internal state, without the account key.
--   
--   TODO: Perhaps we should model this as <tt>S = S1 * S2, where S1 =
--   Bool, S2 = ix * UTxOPointer</tt> - having two "concurrent" states
--   tracking stake keys, where the first one is identical to legacy
--   single-stake key wallets.
--   
--   Maybe that would help simplify <a>applyTx</a> and
--   <a>setPortfolioOf</a>...
data State

-- | No active stake keys. The initial state of a new wallet.
Zero :: State

-- | The first stake-key (index 0) is registered and either delegating or
--   about to be delegating.
One :: State

-- | There is more than one active stake keys. Can only be reached using
--   wallets with support for multiple stake keys.
More :: !Index 'Soft 'AddressK -> PointerUTxO -> !Key0Status -> State

-- | Is key 0 still registered? For compatibility with single-stake-key
--   wallets, we need to track this.
--   
--   <pre>
--   &gt;&gt;&gt; activeKeys (More (toEnum 3) p ValidKey0)
--   [0, 1, 2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; activeKeys (More (toEnum 3) p MissingKey0)
--   [1, 2]
--   </pre>
--   
--   (pseudocode; requires a bit more boilerplate to compile)
--   
--   See the implementation of <tt>applyTx</tt> for how it is used.
data Key0Status
ValidKey0 :: Key0Status
MissingKey0 :: Key0Status

-- | A transaction type specific to <a>DelegationState</a>.
--   
--   Intended to be converted both from and to a more real transaction
--   type.
--   
--   When constructing a real transaction from <a>Tx</a>, these
--   <a>outputs</a> should appear before other outputs. In the theoretical
--   event that there's also a user-specified output with the same payment
--   key as the pointer output, <a>applyTx</a> will track the first one as
--   the new pointer.
data Tx
Tx :: [Cert] -> [(TxIn, Coin)] -> [TxOut] -> Tx
[certs] :: Tx -> [Cert]
[inputs] :: Tx -> [(TxIn, Coin)]
[outputs] :: Tx -> [TxOut]
data Cert
RegisterKey :: RewardAccount -> Cert

-- | Which pool we're delegating to is here (and for now) irrelevant. The
--   main thing is that there exists a witness on-chain for this stake key
--   (registration certs don't require witnesses)
--   
--   TODO: We may also want to add the PoolId here.
Delegate :: RewardAccount -> Cert
DeRegisterKey :: RewardAccount -> Cert

-- | Apply a <a>Tx</a> to a <a>DelegationState</a>.
--   
--   Expects the <tt>PointerUTxO</tt> to be correctly managed, and will
--   panic otherwise.
applyTx :: forall k. (SoftDerivation k, ToRewardAccount k, MkKeyFingerprint k Address, MkKeyFingerprint k (k 'AddressK XPub)) => Tx -> Hash "Tx" -> DelegationState k -> DelegationState k

-- | Given a <a>DelegationState</a>, produce a <a>Tx</a> registering or
--   de-registering stake-keys, in order to have <tt>n</tt> stake-keys.
--   
--   E.g. <tt>setPortfolioOf s0 _ _ 2</tt> creates a tx which after
--   application causes the state to have <tt>activeKeys == [0,1]</tt>
--   
--   Returns <tt>Nothing</tt> if the target <tt>n</tt> is already reached.
setPortfolioOf :: (SoftDerivation k, ToRewardAccount k) => DelegationState k -> Coin -> (k 'AddressK XPub -> Address) -> (RewardAccount -> Bool) -> Int -> Maybe Tx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Delegation.State.Key0Status
instance GHC.Show.Show Cardano.Wallet.Primitive.Delegation.State.Key0Status
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Delegation.State.Key0Status
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Delegation.State.PointerUTxO
instance GHC.Show.Show Cardano.Wallet.Primitive.Delegation.State.PointerUTxO
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Delegation.State.PointerUTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Delegation.State.PointerUTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Delegation.State.State
instance GHC.Show.Show Cardano.Wallet.Primitive.Delegation.State.State
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Delegation.State.State
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Delegation.State.DelegationState k)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Delegation.State.Cert
instance GHC.Show.Show Cardano.Wallet.Primitive.Delegation.State.Cert
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Delegation.State.Cert
instance GHC.Show.Show Cardano.Wallet.Primitive.Delegation.State.Tx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Delegation.State.Tx
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Delegation.State.Tx
instance (GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub)) => GHC.Show.Show (Cardano.Wallet.Primitive.Delegation.State.DelegationState k)
instance (GHC.Classes.Eq (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), GHC.Classes.Eq (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub)) => GHC.Classes.Eq (Cardano.Wallet.Primitive.Delegation.State.DelegationState k)
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.Delegation.State.Tx
instance (Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub)) => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Delegation.State.DelegationState k)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Delegation.State.State
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Delegation.State.Key0Status


-- | For a UTxO to be considered a suitable collateral input, it must: - Be
--   a pure ADA UTxO (no tokens) - Require a verification key witness to be
--   spent - Not be locked by a script
--   
--   UTxOs of this kind are sometimes referred to as <a>VK</a> inputs.
module Cardano.Wallet.Primitive.Collateral

-- | Address type | Payment Credential | Stake Credential | Header, first
--   nibble |
--   |--------------------+--------------------+------------------+----------------------|
--   | Base address | keyhash | keyhash | 0000 | | | scripthash | keyhash |
--   0001 | | | keyhash | scripthash | 0010 | | | scripthash | scripthash |
--   0011 | | Pointer address | keyhash | ptr | 0100 | | | scripthash | ptr
--   | 0101 | | Enterprise address | keyhash | - | 0110 | | | scripthash |
--   0 | 0111 | | Bootstrap address | keyhash | - | 1000 | | Stake address
--   | - | keyhash | 1110 | | | - | scripthash | 1111 | | Future formats |
--   ? | ? | 1001-1101 |
--   
--   We represent these types of addresses with the following data types:
--   
--   The type of the address.
data AddressType
BaseAddress :: Credential -> Credential -> AddressType
PointerAddress :: Credential -> AddressType
EnterpriseAddress :: Credential -> AddressType
StakeAddress :: Credential -> AddressType

-- | A Bootstrap (a.k.a. Byron) address
BootstrapAddress :: AddressType

-- | The type of the credential used in an address.
data Credential
CredentialKeyHash :: Credential
CredentialScriptHash :: Credential

-- | If the given <tt>TxOut</tt> represents a UTxO that is suitable for use
--   as a collateral input, returns <tt>Just</tt> along with the total ADA
--   value of the UTxO. Otherwise returns <tt>Nothing</tt> if it is not a
--   suitable collateral value.
asCollateral :: TxOut -> Maybe Coin

-- | Indicates whether or not the given address is suitable for collateral.
addressSuitableForCollateral :: Address -> Bool

-- | A simple function which determines if an <tt>AddressType</tt> is
--   suitable for use as collateral. Only <tt>AddressType</tt>s with a "key
--   hash" payment credential are considered suitable for use as
--   collateral.
addressTypeSuitableForCollateral :: AddressType -> Bool

-- | Construct an <tt>AddressType</tt> from the binary representation.
addressTypeFromHeaderNibble :: Word4 -> Maybe AddressType

-- | Get an AddressType from a binary stream.
getAddressType :: Get AddressType

-- | Get the address type of a given address.
addressType :: Address -> Maybe AddressType

-- | Return the binary representation of an <tt>AddressType</tt>.
addressTypeToHeaderNibble :: AddressType -> Word4

-- | Write an AddressType to a binary stream.
putAddressType :: AddressType -> Put
instance GHC.Show.Show Cardano.Wallet.Primitive.Collateral.Credential
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Collateral.Credential
instance GHC.Show.Show Cardano.Wallet.Primitive.Collateral.AddressType
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Collateral.AddressType


-- | Provides functions for selecting coins for use as collateral from a
--   UTxO set.
--   
--   See the documentation for <a>performSelection</a> for more details.
module Cardano.Wallet.CoinSelection.Internal.Collateral

-- | Selects coins for collateral.
--   
--   This function tries two strategies in the following order, picking the
--   first strategy that succeeds:
--   
--   <ol>
--   <li>Attempt to select an amount of collateral that is as small as
--   possible.</li>
--   <li>Attempt to select collateral from the largest coins
--   available.</li>
--   </ol>
--   
--   The first strategy, given unlimited computation time, will always
--   produce an optimal result: the smallest possible amount of collateral.
--   However, if the required search space is large, and if the
--   <a>$sel:searchSpaceLimit:SelectionConstraints</a> parameter is set to
--   a value that's smaller than the required search space size, then this
--   strategy will fail without computing a result.
--   
--   The second strategy sacrifices optimality and always produces a result
--   if one is available, by looking only at the very largest coins
--   available. This result can be computed very quickly, without using
--   much search space.
--   
--   The combination of these two strategies means that we can satisfy the
--   following properties:
--   
--   If the attempt to select collateral succeeds:
--   
--   <pre>
--   &gt;&gt;&gt; sum  coinsSelected â‰¥ minimumSelectionAmount
--   
--   &gt;&gt;&gt; size coinsSelected â‰¤ maximumSelectionSize
--   
--   &gt;&gt;&gt; coinsSelected âŠ† coinsAvailable
--   </pre>
--   
--   If the attempt to select collateral fails:
--   
--   <pre>
--   &gt;&gt;&gt; sum  largestCombinationAvailable &lt; minimumSelectionAmount
--   
--   &gt;&gt;&gt; size largestCombinationAvailable â‰¤ maximumSelectionSize
--   
--   &gt;&gt;&gt; largestCombinationAvailable âŠ† coinsAvailable
--   </pre>
performSelection :: forall u. Ord u => PerformSelection u

-- | The type of all functions that perform selections.
type PerformSelection u = SelectionConstraints -> SelectionParams u -> Either (SelectionCollateralError u) (SelectionResult u)

-- | Specifies all constraints required for collateral selection.
--   
--   Selection constraints:
--   
--   <ul>
--   <li>are dependent on the current set of protocol parameters.</li>
--   <li>are not specific to a given selection.</li>
--   <li>place limits on the selection algorithm, enabling it to produce
--   selections that are acceptable to the ledger.</li>
--   </ul>
data SelectionConstraints
SelectionConstraints :: Int -> SearchSpaceLimit -> SelectionConstraints

-- | An upper bound on the number of unique coins that can be selected as
--   collateral.
[$sel:maximumSelectionSize:SelectionConstraints] :: SelectionConstraints -> Int

-- | An upper bound on the search space size, to protect the wallet against
--   computations that use excessive amounts of time or space.
[$sel:searchSpaceLimit:SelectionConstraints] :: SelectionConstraints -> SearchSpaceLimit

-- | Specifies all parameters that are specific to a given selection.
data SelectionParams u
SelectionParams :: Map u Coin -> Coin -> SelectionParams u

-- | The set of all coins available for selection as collateral.
[$sel:coinsAvailable:SelectionParams] :: SelectionParams u -> Map u Coin

-- | A lower bound on the sum of coins to be selected as collateral.
[$sel:minimumSelectionAmount:SelectionParams] :: SelectionParams u -> Coin

-- | Represents a successful selection of collateral.
newtype SelectionResult u
SelectionResult :: Map u Coin -> SelectionResult u

-- | The coins that were selected for collateral.
[$sel:coinsSelected:SelectionResult] :: SelectionResult u -> Map u Coin

-- | A completely empty result, with no inputs selected.
selectionResultEmpty :: SelectionResult u

-- | Represents an unsuccessful attempt to select collateral.
data SelectionCollateralError u
SelectionCollateralError :: Map u Coin -> Coin -> SelectionCollateralError u

-- | The largest combination of coins available.
[$sel:largestCombinationAvailable:SelectionCollateralError] :: SelectionCollateralError u -> Map u Coin

-- | A lower bound on the sum of coins to be selected as collateral.
[$sel:minimumSelectionAmount:SelectionCollateralError] :: SelectionCollateralError u -> Coin

-- | Specifies an upper bound on the search space size.
data SearchSpaceLimit

-- | Specifies an upper bound on the number of coin combinations that can
--   be considered in any single step.
SearchSpaceLimit :: Int -> SearchSpaceLimit

-- | Specifies that there is no search space limit. This should only be
--   used for testing purposes.
UnsafeNoSearchSpaceLimit :: SearchSpaceLimit

-- | The default search space limit.
--   
--   This constant is used by the test suite, so we can be reasonably
--   confident that performing selections with this limit will not use
--   inordinate amounts of time and space.
searchSpaceLimitDefault :: SearchSpaceLimit

-- | Attempts to select an amount of collateral that is as small as
--   possible.
--   
--   This function, given unlimited computation time, will always produce
--   an optimal result: the smallest possible amount of collateral.
--   However, if the required search space is large, and if the
--   <a>$sel:searchSpaceLimit:SelectionConstraints</a> parameter is set to
--   a value that's smaller than the required search space size, then this
--   function will return without computing a result.
selectCollateralSmallest :: forall u. Ord u => PerformSelection u

-- | Selects collateral from the largest coins available.
--   
--   This function sacrifices optimality and always produces a result if
--   one is available, by looking only at the very largest coins available.
--   
--   This result can be computed very quickly, without using much search
--   space.
selectCollateralLargest :: forall u. Ord u => PerformSelection u
data SearchSpaceRequirement

-- | Indicates a known search space requirement.
SearchSpaceRequirement :: Int -> SearchSpaceRequirement

-- | Indicates that the search space requirement is unknown.
SearchSpaceRequirementUnknown :: SearchSpaceRequirement
guardSearchSpaceSize :: SearchSpaceRequirement -> SearchSpaceLimit -> Maybe a -> Maybe a

-- | Generates all submaps of a given map.
--   
--   This function is analogous to <a>powerSet</a>.
--   
--   For a map <tt>m</tt> of size <tt>n</tt>, this function will generate
--   all possible submaps, including the empty map and the original map
--   <tt>m</tt>.
submaps :: forall a b. (Ord a, Ord b) => Map a b -> Set (Map a b)

-- | Generates all subsequences of size <tt>k</tt> from a particular
--   sequence.
--   
--   Warning: this function can use an excessive amount of time and space.
--   
--   To check how many results would be returned without actually
--   generating them, use the <a>numberOfSubsequencesOfSize</a> function.
--   
--   Properties:
--   
--   <pre>
--   &gt;&gt;&gt; all (== k) (length &lt;$&gt; xs `subsequencesOfSize` k)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; length (xs `subsequencesOfSize` k) ==
--   
--   &gt;&gt;&gt; length xs `numberOfSubsequencesOfSize` k
--   </pre>
subsequencesOfSize :: [a] -> Int -> [[a]]

-- | Computes the number of subsequences generated by
--   <a>subsequencesOfSize</a>.
--   
--   This function can be used to determine whether calling
--   <a>subsequencesOfSize</a> would use an excessive amount of time and
--   space, and if so, avoid calling it.
--   
--   Returns <a>Nothing</a> if the result is larger than 'maxBound :: Int'.
numberOfSubsequencesOfSize :: Int -> Int -> Maybe Int

-- | Applies a sequence of functions to an argument until one succeeds.
--   
--   This function iterates through the specified sequence from left to
--   right, applying each function to the given argument, and returning the
--   very first <a>Right</a> result encountered, without evaluating the
--   subsequent functions.
--   
--   If none of the given functions produces a <a>Right</a> result, then
--   this function returns the <a>Left</a> result produced by the last
--   function in the sequence.
firstRight :: NonEmpty (a -> Either e r) -> a -> Either e r

-- | Takes items from a list until a predicate becomes true.
--   
--   The returned list is a prefix of the original list, and includes the
--   very first item that satisfies the predicate.
takeUntil :: (a -> Bool) -> [a] -> [a]
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionParams u)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionParams u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionParams u)
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.Collateral.SearchSpaceLimit
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.Collateral.SearchSpaceLimit
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionConstraints
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionConstraints
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionConstraints
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionResult u)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionResult u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionResult u)
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionCollateralError u)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionCollateralError u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Collateral.SelectionCollateralError u)


-- | Provides an algorithm for producing a balanced coin selection with
--   change, where the fee is paid for.
--   
--   This module uses the Random-Round-Robin coin selection algorithm for
--   multi-asset UTxO sets.
--   
--   See documentation for the <a>performSelection</a> function for more
--   details on how to perform a selection.
module Cardano.Wallet.CoinSelection.Internal.Balance
type PerformSelection m f ctx = SelectionConstraints ctx -> SelectionParamsOf f ctx -> m (Either (SelectionBalanceError ctx) (SelectionResultOf f ctx))

-- | Performs a coin selection and generates change bundles in one step.
--   
--   Provided that <a>isUTxOBalanceSufficient</a> returns <a>True</a> for
--   the given selection criteria, this function guarantees to return a
--   <a>SelectionResult</a> for which <a>selectionHasValidSurplus</a>
--   returns <a>True</a>.
performSelection :: forall m ctx. (HasCallStack, MonadRandom m, SelectionContext ctx) => PerformSelection m [] ctx

-- | Transforms a coin selection function that requires a non-empty list of
--   outputs into a function that accepts an empty list of outputs.
--   
--   If the original list is already non-empty, this function does not
--   alter the parameters or the result in any way, such that:
--   
--   params == transformParams params result == transformResult result
--   
--   If the original list is empty, this function:
--   
--   <ol>
--   <li>applies a balance-preserving transformation to the parameters,
--   adding a single minimal ada-only output to act as a change generation
--   target, such that:computeUTxOBalanceSufficiencyInfo params ==
--   computeUTxOBalanceSufficiencyInfo (transformParams params)</li>
--   <li>applies an inverse transformation to the result, removing the
--   output, such that:selectionSurplus result == selectionSurplus
--   (transformResult result)selectionHasValidSurplus constraints result
--   ==&gt; selectionHasValidSurplus constraints (transformResult
--   result)</li>
--   </ol>
performSelectionEmpty :: forall m ctx. Functor m => PerformSelection m NonEmpty ctx -> PerformSelection m [] ctx

-- | Specifies all constraints required for coin selection.
--   
--   Selection constraints:
--   
--   <ul>
--   <li>place limits on the coin selection algorithm, enabling it to
--   produce selections that are acceptable to the ledger.</li>
--   <li>are dependent on the current set of protocol parameters.</li>
--   <li>are not specific to a given selection.</li>
--   </ul>
data SelectionConstraints ctx
SelectionConstraints :: (TokenBundle -> TokenBundleSizeAssessment) -> (Address ctx -> TokenMap -> Coin) -> (SelectionSkeleton ctx -> Coin) -> ([(Address ctx, TokenBundle)] -> SelectionLimit) -> Address ctx -> Coin -> TokenQuantity -> Address ctx -> SelectionConstraints ctx

-- | Assesses the size of a token bundle relative to the upper limit of
--   what can be included in a transaction output. See documentation for
--   the <a>TokenBundleSizeAssessor</a> type to learn about the expected
--   properties of this field.
[$sel:assessTokenBundleSize:SelectionConstraints] :: SelectionConstraints ctx -> TokenBundle -> TokenBundleSizeAssessment

-- | Computes the minimum ada quantity required for a given output.
[$sel:computeMinimumAdaQuantity:SelectionConstraints] :: SelectionConstraints ctx -> Address ctx -> TokenMap -> Coin

-- | Computes the minimum cost of a given selection skeleton.
[$sel:computeMinimumCost:SelectionConstraints] :: SelectionConstraints ctx -> SelectionSkeleton ctx -> Coin

-- | Computes an upper bound for the number of ordinary inputs to select,
--   given a current set of outputs.
[$sel:computeSelectionLimit:SelectionConstraints] :: SelectionConstraints ctx -> [(Address ctx, TokenBundle)] -> SelectionLimit
[$sel:maximumLengthChangeAddress:SelectionConstraints] :: SelectionConstraints ctx -> Address ctx

-- | Specifies the largest ada quantity that can appear in the token bundle
--   of an output.
[$sel:maximumOutputAdaQuantity:SelectionConstraints] :: SelectionConstraints ctx -> Coin

-- | Specifies the largest non-ada quantity that can appear in the token
--   bundle of an output.
[$sel:maximumOutputTokenQuantity:SelectionConstraints] :: SelectionConstraints ctx -> TokenQuantity
[$sel:nullAddress:SelectionConstraints] :: SelectionConstraints ctx -> Address ctx
type SelectionParams = SelectionParamsOf []

-- | Specifies all parameters that are specific to a given selection.
data SelectionParamsOf f ctx
SelectionParams :: !f (Address ctx, TokenBundle) -> !UTxOSelection (UTxO ctx) -> !Coin -> !Coin -> !TokenMap -> !TokenMap -> SelectionStrategy -> SelectionParamsOf f ctx

-- | The complete set of outputs to be covered.
[$sel:outputsToCover:SelectionParams] :: SelectionParamsOf f ctx -> !f (Address ctx, TokenBundle)

-- | Specifies a set of UTxOs that are available for selection as inputs
--   and optionally, a subset that has already been selected.
--   
--   Further entries from this set will be selected to cover any deficit.
[$sel:utxoAvailable:SelectionParams] :: SelectionParamsOf f ctx -> !UTxOSelection (UTxO ctx)

-- | An extra source of ada.
[$sel:extraCoinSource:SelectionParams] :: SelectionParamsOf f ctx -> !Coin

-- | An extra sink for ada.
[$sel:extraCoinSink:SelectionParams] :: SelectionParamsOf f ctx -> !Coin

-- | Assets to mint: these provide input value to a transaction.
--   
--   By minting tokens, we generally decrease the burden of the selection
--   algorithm, allowing it to select fewer UTxO entries in order to cover
--   the required outputs.
[$sel:assetsToMint:SelectionParams] :: SelectionParamsOf f ctx -> !TokenMap

-- | Assets to burn: these consume output value from a transaction.
--   
--   By burning tokens, we generally increase the burden of the selection
--   algorithm, requiring it to select more UTxO entries in order to cover
--   the burn.
[$sel:assetsToBurn:SelectionParams] :: SelectionParamsOf f ctx -> !TokenMap

-- | Specifies which selection strategy to use. See
--   <a>SelectionStrategy</a>.
[$sel:selectionStrategy:SelectionParams] :: SelectionParamsOf f ctx -> SelectionStrategy

-- | A skeleton selection that can be used to estimate the cost of a final
--   selection.
--   
--   Change outputs are deliberately stripped of their asset quantities, as
--   the fee estimation function must be agnostic to the magnitudes of
--   these quantities.
--   
--   Increasing or decreasing the quantity of a particular asset in a
--   change output must not change the estimated cost of a selection.
data SelectionSkeleton ctx
SelectionSkeleton :: !Int -> ![(Address ctx, TokenBundle)] -> ![Set AssetId] -> SelectionSkeleton ctx
[$sel:skeletonInputCount:SelectionSkeleton] :: SelectionSkeleton ctx -> !Int
[$sel:skeletonOutputs:SelectionSkeleton] :: SelectionSkeleton ctx -> ![(Address ctx, TokenBundle)]
[$sel:skeletonChange:SelectionSkeleton] :: SelectionSkeleton ctx -> ![Set AssetId]
type SelectionResult = SelectionResultOf []

-- | The result of performing a successful selection.
data SelectionResultOf f ctx
SelectionResult :: !NonEmpty (UTxO ctx, TokenBundle) -> !Coin -> !Coin -> !f (Address ctx, TokenBundle) -> ![TokenBundle] -> !TokenMap -> !TokenMap -> SelectionResultOf f ctx

-- | A (non-empty) list of inputs selected from
--   <a>$sel:utxoAvailable:SelectionParams</a>.
[$sel:inputsSelected:SelectionResult] :: SelectionResultOf f ctx -> !NonEmpty (UTxO ctx, TokenBundle)

-- | An extra source of ada.
[$sel:extraCoinSource:SelectionResult] :: SelectionResultOf f ctx -> !Coin

-- | An extra sink for ada.
[$sel:extraCoinSink:SelectionResult] :: SelectionResultOf f ctx -> !Coin

-- | A list of outputs covered.
[$sel:outputsCovered:SelectionResult] :: SelectionResultOf f ctx -> !f (Address ctx, TokenBundle)

-- | A list of generated change outputs.
[$sel:changeGenerated:SelectionResult] :: SelectionResultOf f ctx -> ![TokenBundle]

-- | The assets to mint.
[$sel:assetsToMint:SelectionResult] :: SelectionResultOf f ctx -> !TokenMap

-- | The assets to burn.
[$sel:assetsToBurn:SelectionResult] :: SelectionResultOf f ctx -> !TokenMap

-- | Indicates a choice of selection strategy.
--   
--   A <a>SelectionStrategy</a> determines <b>how much</b> of each asset
--   the selection algorithm will attempt to select from the available UTxO
--   set, relative to the minimum amount necessary to make the selection
--   balance.
--   
--   The default <a>SelectionStrategy</a> is
--   <a>SelectionStrategyOptimal</a>, which when specified will cause the
--   selection algorithm to attempt to select around <b><i>twice</i></b>
--   the minimum possible amount of each asset from the available UTxO set,
--   making it possible to generate change outputs that are roughly the
--   same sizes and shapes as the user-specified outputs.
--   
--   Specifying <a>SelectionStrategyMinimal</a> will cause the selection
--   algorithm to only select <b>just enough</b> of each asset from the
--   available UTxO set to meet the minimum amount. The selection process
--   will terminate as soon as the minimum amount of each asset is covered.
--   
--   The "optimal" strategy is recommended for most situations, as using
--   this strategy will help to ensure that a wallet's UTxO distribution
--   can evolve over time to resemble the typical distribution of payments
--   made by the wallet owner. This increases the likelihood that future
--   selections will succeed, and lowers the amortized cost of future
--   transactions.
--   
--   The "minimal" strategy is recommended only for situations where it is
--   not possible to create a selection with the "optimal" strategy. It is
--   advised to use this strategy only when necessary, as it increases the
--   likelihood of generating change outputs that are much smaller than
--   user-specified outputs. If this strategy is used regularly, the UTxO
--   set can evolve to a state where the distribution no longer resembles
--   the typical distribution of payments made by the user. This increases
--   the likelihood that future selections will not succeed, and increases
--   the amortized cost of future transactions.
data SelectionStrategy
SelectionStrategyMinimal :: SelectionStrategy
SelectionStrategyOptimal :: SelectionStrategy

-- | Represents the set of errors that may occur while performing a
--   selection.
data SelectionBalanceError ctx
BalanceInsufficient :: BalanceInsufficientError -> SelectionBalanceError ctx
SelectionLimitReached :: SelectionLimitReachedError ctx -> SelectionBalanceError ctx
UnableToConstructChange :: UnableToConstructChangeError -> SelectionBalanceError ctx
EmptyUTxO :: SelectionBalanceError ctx

-- | Indicates that the balance of available UTxO entries is insufficient
--   to cover the balance required.
--   
--   See <a>computeUTxOBalanceSufficiency</a>.
data BalanceInsufficientError
BalanceInsufficientError :: !TokenBundle -> !TokenBundle -> BalanceInsufficientError

-- | The balance of <a>$sel:utxoAvailable:SelectionParams</a>.
[$sel:utxoBalanceAvailable:BalanceInsufficientError] :: BalanceInsufficientError -> !TokenBundle

-- | The balance of <a>$sel:outputsToCover:SelectionParams</a>.
[$sel:utxoBalanceRequired:BalanceInsufficientError] :: BalanceInsufficientError -> !TokenBundle
data UnableToConstructChangeError
UnableToConstructChangeError :: !Coin -> !Coin -> UnableToConstructChangeError

-- | The minimal required cost needed for the transaction to be considered
--   valid. This does not include min Ada values.
[$sel:requiredCost:UnableToConstructChangeError] :: UnableToConstructChangeError -> !Coin

-- | The additional coin quantity that would be required to cover the
--   selection cost and minimum coin quantity of each change output.
[$sel:shortfall:UnableToConstructChangeError] :: UnableToConstructChangeError -> !Coin

-- | Specifies a limit to adhere to when performing a selection.
type SelectionLimit = SelectionLimitOf Int
data SelectionLimitOf a

-- | Indicates that there is no limit.
NoLimit :: SelectionLimitOf a

-- | Indicates a maximum limit on the number of inputs to select.
MaximumInputLimit :: a -> SelectionLimitOf a

-- | Indicates whether or not the given selection limit has been exceeded.
selectionLimitExceeded :: IsUTxOSelection s u => s u -> SelectionLimit -> Bool

-- | Indicates that the balance of selected UTxO entries was insufficient
--   to cover the balance required while remaining within the selection
--   limit.
data SelectionLimitReachedError ctx
SelectionLimitReachedError :: !TokenBundle -> ![(UTxO ctx, TokenBundle)] -> !NonEmpty (Address ctx, TokenBundle) -> SelectionLimitReachedError ctx

-- | The UTXO balance required.
[$sel:utxoBalanceRequired:SelectionLimitReachedError] :: SelectionLimitReachedError ctx -> !TokenBundle

-- | The inputs that could be selected while satisfying the
--   <a>$sel:selectionLimit:RunSelectionParams</a>.
[$sel:inputsSelected:SelectionLimitReachedError] :: SelectionLimitReachedError ctx -> ![(UTxO ctx, TokenBundle)]
[$sel:outputsToCover:SelectionLimitReachedError] :: SelectionLimitReachedError ctx -> !NonEmpty (Address ctx, TokenBundle)

-- | Reduces a selection limit by a given reduction amount.
--   
--   If the given reduction amount is positive, then this function will
--   reduce the selection limit by that amount.
--   
--   If the given reduction amount is zero or negative, then this function
--   will return the original limit unchanged.
reduceSelectionLimitBy :: SelectionLimit -> Int -> SelectionLimit

-- | Indicates the difference between total input value and total output
--   value of a <a>SelectionResult</a>.
--   
--   There are two possibilities:
--   
--   <ul>
--   <li><a>SelectionSurplus</a></li>
--   </ul>
--   
--   Indicates a surplus, when the total input value is greater than or
--   equal to the total output value.
--   
--   <ul>
--   <li><a>SelectionDeficit</a></li>
--   </ul>
--   
--   Indicates a deficit, when the total input value is NOT greater than or
--   equal to the total output value.
data SelectionDelta a
SelectionSurplus :: a -> SelectionDelta a
SelectionDeficit :: a -> SelectionDelta a

-- | Calculates the selection delta for all assets.
--   
--   See <a>SelectionDelta</a>.
selectionDeltaAllAssets :: Foldable f => SelectionResultOf f ctx -> SelectionDelta TokenBundle

-- | Calculates the ada selection delta.
--   
--   See <a>SelectionDelta</a>.
selectionDeltaCoin :: Foldable f => SelectionResultOf f ctx -> SelectionDelta Coin

-- | Indicates whether or not a selection result has a valid surplus.
selectionHasValidSurplus :: Foldable f => SelectionConstraints ctx -> SelectionResultOf f ctx -> Bool

-- | Calculates the ada selection surplus, assuming there is a surplus.
--   
--   If there is a surplus, then this function returns that surplus. If
--   there is a deficit, then this function returns zero.
--   
--   Use <a>selectionDeltaCoin</a> if you wish to handle the case where
--   there is a deficit.
selectionSurplusCoin :: Foldable f => SelectionResultOf f ctx -> Coin

-- | Computes the minimum required cost of a selection.
selectionMinimumCost :: Foldable f => SelectionConstraints ctx -> SelectionResultOf f ctx -> Coin

-- | Computes the maximum acceptable cost of a selection.
--   
--   This function acts as a safety limit to ensure that fees of selections
--   produced by <a>performSelection</a> are not excessively high.
--   
--   Ideally, we'd always be able to generate selections with fees that are
--   precisely equal to <a>selectionMinimumCost</a>. However, in some
--   situations it may be necessary to exceed this cost very slightly.
--   
--   This function provides a conservative upper bound to a selection cost
--   that we can reference from within property tests.
--   
--   See <a>selectionHasValidSurplus</a>.
selectionMaximumCost :: Foldable f => SelectionConstraints ctx -> SelectionResultOf f ctx -> Coin

-- | Converts a selection into a skeleton.
selectionSkeleton :: Foldable f => SelectionResultOf f ctx -> SelectionSkeleton ctx

-- | Indicates whether the balance of available UTxO entries is sufficient.
--   
--   See <a>computeUTxOBalanceSufficiency</a>.
data UTxOBalanceSufficiency

-- | Indicates that the UTxO balance is sufficient.
UTxOBalanceSufficient :: UTxOBalanceSufficiency

-- | Indicates that the UTxO balance is insufficient.
UTxOBalanceInsufficient :: UTxOBalanceSufficiency

-- | Gives more information about UTxO balance sufficiency.
--   
--   See <a>computeUTxOBalanceSufficiencyInfo</a>.
data UTxOBalanceSufficiencyInfo
UTxOBalanceSufficiencyInfo :: TokenBundle -> TokenBundle -> TokenBundle -> UTxOBalanceSufficiency -> UTxOBalanceSufficiencyInfo

-- | See <a>computeUTxOBalanceAvailable</a>.
[$sel:available:UTxOBalanceSufficiencyInfo] :: UTxOBalanceSufficiencyInfo -> TokenBundle

-- | See <a>computeUTxOBalanceRequired</a>.
[$sel:required:UTxOBalanceSufficiencyInfo] :: UTxOBalanceSufficiencyInfo -> TokenBundle

-- | The difference between
--   <a>$sel:available:UTxOBalanceSufficiencyInfo</a> and
--   <a>$sel:required:UTxOBalanceSufficiencyInfo</a>.
[$sel:difference:UTxOBalanceSufficiencyInfo] :: UTxOBalanceSufficiencyInfo -> TokenBundle

-- | Whether or not the balance is sufficient.
[$sel:sufficiency:UTxOBalanceSufficiencyInfo] :: UTxOBalanceSufficiencyInfo -> UTxOBalanceSufficiency
computeBalanceInOut :: Foldable f => SelectionParamsOf f ctx -> (TokenBundle, TokenBundle)
computeDeficitInOut :: Foldable f => SelectionParamsOf f ctx -> (TokenBundle, TokenBundle)

-- | Computes the balance of UTxO entries available for selection.
computeUTxOBalanceAvailable :: SelectionParamsOf f ctx -> TokenBundle

-- | Computes the balance of UTxO entries required to be selected.
computeUTxOBalanceRequired :: Foldable f => SelectionParamsOf f ctx -> TokenBundle

-- | Computes the UTxO balance sufficiency.
--   
--   See <a>UTxOBalanceSufficiency</a>.
computeUTxOBalanceSufficiency :: Foldable f => SelectionParamsOf f ctx -> UTxOBalanceSufficiency

-- | Computes information about the UTxO balance sufficiency.
--   
--   See <a>UTxOBalanceSufficiencyInfo</a>.
computeUTxOBalanceSufficiencyInfo :: Foldable f => SelectionParamsOf f ctx -> UTxOBalanceSufficiencyInfo

-- | Indicates whether or not the UTxO balance is sufficient.
--   
--   The balance of available UTxO entries is sufficient if (and only if)
--   it is greater than or equal to the required balance.
isUTxOBalanceSufficient :: Foldable f => SelectionParamsOf f ctx -> Bool
runSelection :: forall m u. (MonadRandom m, Ord u) => RunSelectionParams u -> m (UTxOSelection u)
runSelectionNonEmpty :: (MonadRandom m, Ord u) => RunSelectionParams u -> m (Maybe (UTxOSelectionNonEmpty u))
runSelectionNonEmptyWith :: Monad m => (UTxOSelection u -> m (Maybe (UTxOSelectionNonEmpty u))) -> UTxOSelection u -> m (Maybe (UTxOSelectionNonEmpty u))

-- | Parameters for <a>runSelection</a>.
data RunSelectionParams u
RunSelectionParams :: SelectionLimit -> UTxOSelection u -> TokenBundle -> SelectionStrategy -> RunSelectionParams u

-- | A limit to adhere to when performing a selection.
[$sel:selectionLimit:RunSelectionParams] :: RunSelectionParams u -> SelectionLimit

-- | UTxO entries available for selection.
[$sel:utxoAvailable:RunSelectionParams] :: RunSelectionParams u -> UTxOSelection u

-- | Minimum balance to cover.
[$sel:minimumBalance:RunSelectionParams] :: RunSelectionParams u -> TokenBundle

-- | Specifies which selection strategy to use. See
--   <a>SelectionStrategy</a>.
[$sel:selectionStrategy:RunSelectionParams] :: RunSelectionParams u -> SelectionStrategy

-- | Runs just a single step of a coin selection.
--   
--   It returns an updated state if (and only if) the updated selection
--   represents an improvement over the selection in the previous state.
--   
--   An improvement, for a given token quantity, is defined in the
--   following way:
--   
--   <ul>
--   <li>If the total selected token quantity of the previous selection had
--   not yet reached 100% of the output token quantity, any additional
--   selection is considered to be an improvement.</li>
--   <li>If the total selected token quantity of the previous selection had
--   already reached or surpassed 100% of the output token quantity, any
--   additional selection is considered to be an improvement if and only if
--   it takens the total selected token quantity closer to the target token
--   quantity, but not further away.</li>
--   </ul>
runSelectionStep :: forall m state state'. Monad m => SelectionLens m state state' -> state -> m (Maybe state')

-- | Provides a lens on the current selection state.
--   
--   A <a>SelectionLens</a> gives <a>runSelectionStep</a> just the
--   information it needs to make a decision, and no more.
data SelectionLens m state state'
SelectionLens :: (state -> Natural) -> (state' -> Natural) -> (state -> m (Maybe state')) -> Natural -> SelectionStrategy -> SelectionLens m state state'
[$sel:currentQuantity:SelectionLens] :: SelectionLens m state state' -> state -> Natural
[$sel:updatedQuantity:SelectionLens] :: SelectionLens m state state' -> state' -> Natural
[$sel:selectQuantity:SelectionLens] :: SelectionLens m state state' -> state -> m (Maybe state')
[$sel:minimumQuantity:SelectionLens] :: SelectionLens m state state' -> Natural
[$sel:selectionStrategy:SelectionLens] :: SelectionLens m state state' -> SelectionStrategy
assetSelectionLens :: (MonadRandom m, Ord u) => SelectionLimit -> SelectionStrategy -> (AssetId, TokenQuantity) -> SelectionLens m (UTxOSelection u) (UTxOSelectionNonEmpty u)
coinSelectionLens :: (MonadRandom m, Ord u) => SelectionLimit -> SelectionStrategy -> Coin -> SelectionLens m (UTxOSelection u) (UTxOSelectionNonEmpty u)

-- | Criteria for the <a>makeChange</a> function.
data MakeChangeCriteria minCoinFor bundleSizeAssessor
MakeChangeCriteria :: minCoinFor -> bundleSizeAssessor -> Coin -> Coin -> Coin -> NonEmpty TokenBundle -> NonEmpty TokenBundle -> TokenMap -> TokenMap -> Coin -> TokenQuantity -> MakeChangeCriteria minCoinFor bundleSizeAssessor

-- | A function that computes the minimum required ada quantity for a
--   particular output.
[$sel:minCoinFor:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> minCoinFor

-- | A function to assess the size of a token bundle.
[$sel:bundleSizeAssessor:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> bundleSizeAssessor

-- | The minimal (and optimal) delta between the total ada balance of all
--   input bundles and the total ada balance of all output and change
--   bundles, where:
--   
--   delta = getCoin (fold inputBundles) - getCoin (fold outputBundles) -
--   getCoin (fold changeBundles)
--   
--   This typically captures fees plus key deposits.
[$sel:requiredCost:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> Coin

-- | An extra source of ada.
[$sel:extraCoinSource:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> Coin

-- | An extra sink for ada.
[$sel:extraCoinSink:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> Coin

-- | Token bundles of selected inputs.
[$sel:inputBundles:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> NonEmpty TokenBundle

-- | Token bundles of original outputs.
[$sel:outputBundles:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> NonEmpty TokenBundle

-- | Assets to mint: these provide input value to a transaction.
[$sel:assetsToMint:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> TokenMap

-- | Assets to burn: these consume output value from a transaction.
[$sel:assetsToBurn:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> TokenMap

-- | Specifies the largest ada quantity that can appear in the token bundle
--   of an output.
[$sel:maximumOutputAdaQuantity:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> Coin

-- | Specifies the largest non-ada quantity that can appear in the token
--   bundle of an output.
[$sel:maximumOutputTokenQuantity:MakeChangeCriteria] :: MakeChangeCriteria minCoinFor bundleSizeAssessor -> TokenQuantity

-- | Constructs change bundles for a set of selected inputs and outputs.
--   
--   Returns <a>Nothing</a> if the specified inputs do not provide enough
--   ada to satisfy the minimum delta and minimum ada quantities of the
--   change bundles generated.
--   
--   This function will generate runtime errors if:
--   
--   <ol>
--   <li>The total balance of all outputs is not less than or equal to the
--   total balance of all inputs.</li>
--   <li>The total ada balance of all outputs is zero.</li>
--   </ol>
--   
--   Pre-condition (1) should be satisfied by any result produced by the
--   <a>runSelection</a> function.
--   
--   Pre-condition (2) should be satisfied by assigning a minimum ada
--   quantity to every output token bundle.
makeChange :: MakeChangeCriteria (TokenMap -> Coin) TokenBundleSizeAssessor -> Either UnableToConstructChangeError [TokenBundle]

-- | Constructs a list of ada change outputs based on the given
--   distribution.
--   
--   If the sum of weights in given distribution is equal to zero, this
--   function throws a runtime error.
--   
--   The length of the output list is always the same as the length of the
--   input list, and the sum of its quantities is always exactly equal to
--   the <a>Coin</a> value given as the second argument.
makeChangeForCoin :: HasCallStack => NonEmpty Coin -> Coin -> NonEmpty Coin

-- | Constructs change outputs for a user-specified asset: an asset that
--   was present in the original set of outputs.
--   
--   If the given asset does not appear in the given distribution, this
--   function returns a list of empty token maps. Otherwise, the given
--   token quantity is partitioned into a list of quantities that are
--   proportional to the weights within the given input distribution,
--   modulo rounding.
--   
--   The length of the output list is always the same as the the length of
--   the input list, and the sum of its quantities is either zero, or
--   exactly equal to the token quantity in the second argument.
makeChangeForUserSpecifiedAsset :: NonEmpty TokenMap -> (AssetId, TokenQuantity) -> NonEmpty TokenMap

-- | Constructs change outputs for a non-user-specified asset: an asset
--   that was not present in the original set of outputs.
--   
--   This function constructs a list of change outputs by preserving the
--   input distribution as much as possible. Note that only the length of
--   the first argument is used.
--   
--   The length of the output list is always the same as the length of the
--   input list, and the sum of its quantities is always exactly equal to
--   the sum of all token quantities given in the second argument.
--   
--   The resultant list is sorted into ascending order when maps are
--   compared with the <a>leq</a> function.
makeChangeForNonUserSpecifiedAsset :: NonEmpty a -> (AssetId, NonEmpty TokenQuantity) -> NonEmpty TokenMap

-- | Constructs change outputs for all non-user-specified assets: assets
--   that were not present in the original set of outputs.
--   
--   The resultant list is sorted into ascending order when maps are
--   compared with the <a>leq</a> function.
makeChangeForNonUserSpecifiedAssets :: NonEmpty a -> Map AssetId (NonEmpty TokenQuantity) -> NonEmpty TokenMap

-- | Assigns coin quantities to a list of pre-computed asset change maps.
--   
--   Each pre-computed asset change map must be paired with the original
--   coin value of its corresponding output.
--   
--   This function:
--   
--   <ul>
--   <li>expects the list of pre-computed asset change maps to be sorted in
--   an order that ensures all empty token maps are at the start of the
--   list.</li>
--   <li>attempts to assign a minimum ada quantity to every change map, but
--   iteratively drops empty change maps from the start of the list if the
--   amount of ada is insufficient to cover them all.</li>
--   <li>continues dropping empty change maps from the start of the list
--   until it is possible to assign a minimum ada value to all remaining
--   entries.</li>
--   <li>returns a list that is identical in length to the input list if
--   (and only if) it was possible to assign a minimum ada quantity to all
--   change maps.</li>
--   <li>returns a list that is shorter than the input list if it was only
--   possible to assign a minimum ada quantity to a suffix of the given
--   list.</li>
--   <li>fails if (and only if) there was not enough ada available to
--   assign the minimum ada quantity to all non-empty change maps.</li>
--   </ul>
assignCoinsToChangeMaps :: HasCallStack => Coin -> (TokenMap -> Coin) -> NonEmpty (TokenMap, Coin) -> Either Coin [TokenBundle]

-- | Generates a map of all non-user-specified assets and their quantities.
--   
--   Each key in the resulting map corresponds to an asset that was NOT
--   included in the original set of user-specified outputs, but that was
--   nevertheless selected during the selection process.
--   
--   The value associated with each key corresponds to the complete list of
--   all discrete non-zero quantities of that asset present in the selected
--   inputs.
collateNonUserSpecifiedAssetQuantities :: NonEmpty TokenMap -> Set AssetId -> Map AssetId (NonEmpty TokenQuantity)

-- | Adds a minted asset quantity to a list of change maps.
--   
--   This function always adds the given quantity to the final change map
--   in the given list.
--   
--   Example:
--   
--   Suppose we have the following list of change maps:
--   
--   <ul>
--   <li><i> [ (<a>B</a>, 7) </i></li>
--   <li><i> [(<a>A</a>, 1), (<a>B</a>, 8) </i></li>
--   <li><i> [(<a>A</a>, 2), (<a>B</a>, 9) </i></li>
--   <li><i> [(<a>A</a>, 3), (<a>B</a>, 9) </i></li>
--   <li><i> [(<a>A</a>, 4), (<a>B</a>, 12) </i></li>
--   </ul>
--   
--   If we add 4 tokens of asset <a>A</a>, we obtain the following result:
--   
--   <ul>
--   <li><i> [ (<a>B</a>, 7) </i></li>
--   <li><i> [(<a>A</a>, 1), (<a>B</a>, 8) </i></li>
--   <li><i> [(<a>A</a>, 2), (<a>B</a>, 9) </i></li>
--   <li><i> [(<a>A</a>, 3), (<a>B</a>, 9) </i></li>
--   <li><i> [(<a>A</a>, 8), (<a>B</a>, 12) </i> -- Increased by 4</li>
--   </ul>
--   
--   Provided that the specified change maps are in ascending partial
--   order, this function guarantees that the resulting change maps will
--   also be in ascending partial order.
--   
--   The length of the given list is preserved in the output list.
addMintValueToChangeMaps :: (AssetId, TokenQuantity) -> NonEmpty TokenMap -> NonEmpty TokenMap

-- | Adds minted values for multiple assets to a list of change maps.
--   
--   Plural of <tt>addMintValueToChangeMaps</tt>.
addMintValuesToChangeMaps :: TokenMap -> NonEmpty TokenMap -> NonEmpty TokenMap

-- | Removes a burned asset quantity from a list of change maps.
--   
--   For a given asset <tt>a</tt> and reduction target <tt>t</tt>, this
--   function traverses the given list from left to right, reducing the
--   quantity of asset <tt>a</tt> in each change map until the reduction
--   target <tt>t</tt> has been met, or until the list is exhausted.
--   
--   For each change map <tt>m</tt> under consideration:
--   
--   <ul>
--   <li>if the quantity <tt>q</tt> of asset <tt>a</tt> in map <tt>m</tt>
--   is less than or equal to the remaining required reduction <tt>r</tt>,
--   it will be replaced with a zero (effectively eliminating asset
--   <tt>a</tt> from the map).</li>
--   <li>if the quantity <tt>q</tt> of asset <tt>a</tt> in map <tt>m</tt>
--   is greater than the remaining required reduction <tt>r</tt>, it will
--   be replaced with the absolute difference between <tt>q</tt> and
--   <tt>r</tt>.</li>
--   </ul>
--   
--   If the total quantity of the given asset in the given change maps is
--   greater than the specified reduction target, the total reduction will
--   be equal to the specified reduction target. Otherwise, the given asset
--   will be completely eliminated from all change maps.
--   
--   Example:
--   
--   Suppose we have the following list of change maps:
--   
--   <ul>
--   <li><i> [ (<a>B</a>, 7) </i></li>
--   <li><i> [(<a>A</a>, 1), (<a>B</a>, 8) </i></li>
--   <li><i> [(<a>A</a>, 2), (<a>B</a>, 9) </i></li>
--   <li><i> [(<a>A</a>, 3), (<a>B</a>, 9) </i></li>
--   <li><i> [(<a>A</a>, 4), (<a>B</a>, 12) </i></li>
--   </ul>
--   
--   If our target is to reduce the quantity of asset <a>A</a> by 4, then
--   we should obtain the following result:
--   
--   <ul>
--   <li><i> [ (<a>B</a>, 7) </i> -- Unable to reduce (already 0)</li>
--   <li><i> [ (<a>B</a>, 8) </i> -- Reduced by 1 (and eliminated from
--   map)</li>
--   <li><i> [ (<a>B</a>, 9) </i> -- Reduced by 2 (and eliminated from
--   map)</li>
--   <li><i> [(<a>A</a>, 2), (<a>B</a>, 9) </i> -- Reduced by 1</li>
--   <li><i> [(<a>A</a>, 4), (<a>B</a>, 12) </i></li>
--   </ul>
--   
--   Provided that the specified change maps are in ascending partial
--   order, this function guarantees that the resulting change maps will
--   also be in ascending partial order.
--   
--   The length of the given list is preserved in the output list.
removeBurnValueFromChangeMaps :: (AssetId, TokenQuantity) -> NonEmpty TokenMap -> NonEmpty TokenMap

-- | Removes burned values for multiple assets from a list of change maps.
--   
--   Plural of <tt>removeBurnValueFromChangeMaps</tt>.
removeBurnValuesFromChangeMaps :: TokenMap -> NonEmpty TokenMap -> NonEmpty TokenMap

-- | Reduces the total value of the given list of token quantities by the
--   given reduction target.
--   
--   This function traverses the given list of quantities from left to
--   right, reducing each quantity in turn until the total reduction is
--   equal to the given reduction target, or until the list is exhausted.
--   
--   For each quantity <tt>q</tt> under consideration:
--   
--   <ul>
--   <li>if <tt>q</tt> is less than or equal to the remaining required
--   reduction <tt>r</tt>, it will be replaced with a zero.</li>
--   <li>if <tt>q</tt> is greater than the remaining required reduction
--   <tt>r</tt>, it will be replaced with the absolute difference between
--   <tt>q</tt> and <tt>r</tt>.</li>
--   </ul>
--   
--   If the total value in the list is less than the reduction target, the
--   result will be a list of zeros.
--   
--   Provided the given list is in ascending order, the resulting list is
--   also guaranteed to be in ascending order.
--   
--   The length of the given list is preserved in the output.
reduceTokenQuantities :: TokenQuantity -> NonEmpty TokenQuantity -> NonEmpty TokenQuantity

-- | Splits a bundle into smaller bundles if its asset count is excessive
--   when measured with the given <tt>isExcessive</tt> indicator function.
--   
--   Returns a list of smaller bundles for which <tt>isExcessive</tt>
--   returns <a>False</a>.
splitBundleIfAssetCountExcessive :: TokenBundle -> (TokenBundle -> Bool) -> NonEmpty TokenBundle

-- | Splits bundles with excessive asset counts into smaller bundles.
--   
--   Only token bundles where the <tt>isExcessive</tt> indicator function
--   returns <a>True</a> will be split.
--   
--   Returns a list of smaller bundles for which <tt>isExcessive</tt>
--   returns <a>False</a>.
--   
--   If none of the bundles in the given list has an excessive asset count,
--   this function will return the original list.
splitBundlesWithExcessiveAssetCounts :: NonEmpty TokenBundle -> (TokenBundle -> Bool) -> NonEmpty TokenBundle

-- | Splits bundles with excessive token quantities into smaller bundles.
--   
--   Only token bundles containing quantities that exceed the maximum token
--   quantity will be split.
--   
--   If none of the bundles in the given list contain a quantity that
--   exceeds the maximum token quantity, this function will return the
--   original list.
splitBundlesWithExcessiveTokenQuantities :: NonEmpty TokenBundle -> TokenQuantity -> NonEmpty TokenBundle
groupByKey :: forall k v. Ord k => [(k, v)] -> Map k (NonEmpty v)
ungroupByKey :: forall k v. Map k (NonEmpty v) -> [(k, v)]
runRoundRobin :: s -> (s' -> s) -> [s -> Maybe s'] -> s
runRoundRobinM :: Monad m => s -> (s' -> s) -> [s -> m (Maybe s')] -> m s
newtype AssetCount a
AssetCount :: a -> AssetCount a
[$sel:unAssetCount:AssetCount] :: AssetCount a -> a
distance :: Natural -> Natural -> Natural
mapMaybe :: (a -> Maybe b) -> NonEmpty a -> [b]

-- | Calculate the missing balance from a
--   <tt>BalanceInsufficientError</tt>.
balanceMissing :: BalanceInsufficientError -> TokenBundle
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.Balance.SelectionStrategy
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.Balance.SelectionStrategy
instance GHC.Enum.Enum Cardano.Wallet.CoinSelection.Internal.Balance.SelectionStrategy
instance GHC.Enum.Bounded Cardano.Wallet.CoinSelection.Internal.Balance.SelectionStrategy
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionParamsOf f ctx)
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.Balance.UTxOBalanceSufficiency
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.Balance.UTxOBalanceSufficiency
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.Balance.UTxOBalanceSufficiencyInfo
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.Internal.Balance.UTxOBalanceSufficiencyInfo
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.Balance.UTxOBalanceSufficiencyInfo
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionSkeleton ctx)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionLimitOf a)
instance GHC.Base.Functor Cardano.Wallet.CoinSelection.Internal.Balance.SelectionLimitOf
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionLimitOf a)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionConstraints ctx)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionResultOf f ctx)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionDelta a)
instance GHC.Base.Functor Cardano.Wallet.CoinSelection.Internal.Balance.SelectionDelta
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionDelta a)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionLimitReachedError ctx)
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.Balance.BalanceInsufficientError
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.Balance.BalanceInsufficientError
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.Internal.Balance.BalanceInsufficientError
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.Balance.UnableToConstructChangeError
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.Balance.UnableToConstructChangeError
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.Internal.Balance.UnableToConstructChangeError
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionBalanceError ctx)
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Balance.RunSelectionParams u)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Balance.RunSelectionParams u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Balance.RunSelectionParams u)
instance (GHC.Show.Show minCoinFor, GHC.Show.Show bundleSizeAssessor) => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Balance.MakeChangeCriteria minCoinFor bundleSizeAssessor)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Balance.MakeChangeCriteria minCoinFor bundleSizeAssessor)
instance (GHC.Classes.Eq minCoinFor, GHC.Classes.Eq bundleSizeAssessor) => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Balance.MakeChangeCriteria minCoinFor bundleSizeAssessor)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Balance.AssetCount a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Balance.AssetCount a)
instance (GHC.Classes.Eq (f (Cardano.Wallet.CoinSelection.Internal.Context.Address ctx, Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)), GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Context.UTxO ctx)) => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionParamsOf f ctx)
instance (GHC.Show.Show (f (Cardano.Wallet.CoinSelection.Internal.Context.Address ctx, Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)), GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Context.UTxO ctx)) => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionParamsOf f ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionSkeleton ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionSkeleton ctx)
instance (GHC.Classes.Eq (f (Cardano.Wallet.CoinSelection.Internal.Context.Address ctx, Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)), GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Context.UTxO ctx)) => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionResultOf f ctx)
instance (GHC.Show.Show (f (Cardano.Wallet.CoinSelection.Internal.Context.Address ctx, Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)), GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Context.UTxO ctx)) => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionResultOf f ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionBalanceError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionBalanceError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionLimitReachedError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionLimitReachedError ctx)
instance GHC.Classes.Ord (Cardano.Wallet.CoinSelection.Internal.Balance.AssetCount Cardano.Wallet.Primitive.Types.TokenMap.TokenMap)
instance Formatting.Buildable.Buildable a => Formatting.Buildable.Buildable (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionDelta a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionLimitOf a)

module Cardano.Wallet.CoinSelection.Internal.Balance.Gen
genSelectionLimit :: Gen SelectionLimit
genSelectionSkeleton :: Gen (Address ctx) -> Gen (SelectionSkeleton ctx)
genSelectionStrategy :: Gen SelectionStrategy
shrinkSelectionLimit :: SelectionLimit -> [SelectionLimit]
shrinkSelectionSkeleton :: (Address ctx -> [Address ctx]) -> SelectionSkeleton ctx -> [SelectionSkeleton ctx]
shrinkSelectionStrategy :: SelectionStrategy -> [SelectionStrategy]


-- | This module provides INTERNAL functions and types for coin selection.
--   
--   It is recommended to import from <a>CoinSelection</a> instead.
module Cardano.Wallet.CoinSelection.Internal

-- | Performs a coin selection.
--   
--   This function has the following responsibilities:
--   
--   <ul>
--   <li>selecting inputs from the UTxO set to pay for user-specified
--   outputs;</li>
--   <li>selecting inputs from the UTxO set to pay for collateral;</li>
--   <li>producing change outputs to return excess value to the
--   wallet;</li>
--   <li>balancing a selection to pay for the transaction fee.</li>
--   </ul>
--   
--   This function guarantees that given a set of
--   <a>SelectionConstraints</a> <tt>cs</tt> and <a>SelectionParams</a>
--   <tt>ps</tt>:
--   
--   <ul>
--   <li>if creation of a selection succeeds, a value <tt>s</tt> of type
--   <a>Selection</a> will be returned for which the following property
--   holds:<pre>&gt;&gt;&gt; verifySelection cs ps s == VerificationSuccess
--   </pre></li>
--   <li>if creation of a selection fails, a value <tt>e</tt> of type
--   <a>SelectionError</a> will be returned for which the following
--   property holds:<pre>&gt;&gt;&gt; verifySelectionError cs ps e ==
--   VerificationSuccess </pre></li>
--   </ul>
performSelection :: (HasCallStack, MonadRandom m, SelectionContext ctx) => PerformSelection m ctx (Selection ctx)

-- | Represents a balanced selection.
data Selection ctx
Selection :: !NonEmpty (UTxO ctx, TokenBundle) -> ![(UTxO ctx, Coin)] -> ![(Address ctx, TokenBundle)] -> ![TokenBundle] -> !TokenMap -> !TokenMap -> !Coin -> !Coin -> Selection ctx

-- | Selected inputs.
[$sel:inputs:Selection] :: Selection ctx -> !NonEmpty (UTxO ctx, TokenBundle)

-- | Selected collateral inputs.
[$sel:collateral:Selection] :: Selection ctx -> ![(UTxO ctx, Coin)]

-- | User-specified outputs
[$sel:outputs:Selection] :: Selection ctx -> ![(Address ctx, TokenBundle)]

-- | Generated change outputs.
[$sel:change:Selection] :: Selection ctx -> ![TokenBundle]

-- | Assets to mint.
[$sel:assetsToMint:Selection] :: Selection ctx -> !TokenMap

-- | Assets to burn.
[$sel:assetsToBurn:Selection] :: Selection ctx -> !TokenMap

-- | An extra source of ada.
[$sel:extraCoinSource:Selection] :: Selection ctx -> !Coin

-- | An extra sink for ada.
[$sel:extraCoinSink:Selection] :: Selection ctx -> !Coin

-- | Specifies all constraints required for coin selection.
--   
--   Selection constraints:
--   
--   <ul>
--   <li>are dependent on the current set of protocol parameters.</li>
--   <li>are not specific to a given selection.</li>
--   <li>place limits on the coin selection algorithm, enabling it to
--   produce selections that are acceptable to the ledger.</li>
--   </ul>
data SelectionConstraints ctx
SelectionConstraints :: (TokenBundle -> TokenBundleSizeAssessment) -> Coin -> (Address ctx -> TokenMap -> Coin) -> (Address ctx -> TokenBundle -> Bool) -> (SelectionSkeleton ctx -> Coin) -> ([(Address ctx, TokenBundle)] -> SelectionLimit) -> Int -> Natural -> Coin -> TokenQuantity -> Address ctx -> Address ctx -> SelectionConstraints ctx

-- | Assesses the size of a token bundle relative to the upper limit of
--   what can be included in a transaction output. See documentation for
--   the <tt>TokenBundleSizeAssessor</tt> type to learn about the expected
--   properties of this field.
[$sel:assessTokenBundleSize:SelectionConstraints] :: SelectionConstraints ctx -> TokenBundle -> TokenBundleSizeAssessment

-- | Amount that should be taken from/returned back to the wallet for each
--   stake key registration/de-registration in the transaction.
[$sel:certificateDepositAmount:SelectionConstraints] :: SelectionConstraints ctx -> Coin

-- | Computes the minimum ada quantity required for a given output.
[$sel:computeMinimumAdaQuantity:SelectionConstraints] :: SelectionConstraints ctx -> Address ctx -> TokenMap -> Coin

-- | Returns <a>True</a> if the given <a>TokenBundle</a> has a <a>Coin</a>
--   value that is below the minimum required.
[$sel:isBelowMinimumAdaQuantity:SelectionConstraints] :: SelectionConstraints ctx -> Address ctx -> TokenBundle -> Bool

-- | Computes the minimum cost of a given selection skeleton.
[$sel:computeMinimumCost:SelectionConstraints] :: SelectionConstraints ctx -> SelectionSkeleton ctx -> Coin

-- | Computes an upper bound for the number of ordinary inputs to select,
--   given a current set of outputs.
[$sel:computeSelectionLimit:SelectionConstraints] :: SelectionConstraints ctx -> [(Address ctx, TokenBundle)] -> SelectionLimit

-- | Specifies an inclusive upper bound on the number of unique inputs that
--   can be selected as collateral.
[$sel:maximumCollateralInputCount:SelectionConstraints] :: SelectionConstraints ctx -> Int

-- | Specifies the minimum required amount of collateral as a percentage of
--   the total transaction fee.
[$sel:minimumCollateralPercentage:SelectionConstraints] :: SelectionConstraints ctx -> Natural

-- | Specifies the largest ada quantity that can appear in the token bundle
--   of an output.
[$sel:maximumOutputAdaQuantity:SelectionConstraints] :: SelectionConstraints ctx -> Coin

-- | Specifies the largest non-ada quantity that can appear in the token
--   bundle of an output.
[$sel:maximumOutputTokenQuantity:SelectionConstraints] :: SelectionConstraints ctx -> TokenQuantity
[$sel:maximumLengthChangeAddress:SelectionConstraints] :: SelectionConstraints ctx -> Address ctx
[$sel:nullAddress:SelectionConstraints] :: SelectionConstraints ctx -> Address ctx

-- | Indicates that an error occurred while performing a coin selection.
data SelectionError ctx
SelectionBalanceErrorOf :: SelectionBalanceError ctx -> SelectionError ctx
SelectionCollateralErrorOf :: SelectionCollateralError ctx -> SelectionError ctx
SelectionOutputErrorOf :: SelectionOutputError ctx -> SelectionError ctx

-- | Specifies all parameters that are specific to a given selection.
data SelectionParams ctx
SelectionParams :: !TokenMap -> !TokenMap -> !Coin -> !Coin -> ![(Address ctx, TokenBundle)] -> !Coin -> !Natural -> !Natural -> !SelectionCollateralRequirement -> !Map (UTxO ctx) Coin -> !UTxOSelection (UTxO ctx) -> SelectionStrategy -> SelectionParams ctx

-- | Specifies a set of assets to burn.
[$sel:assetsToBurn:SelectionParams] :: SelectionParams ctx -> !TokenMap

-- | Specifies a set of assets to mint.
[$sel:assetsToMint:SelectionParams] :: SelectionParams ctx -> !TokenMap

-- | Specifies extra <a>Coin</a> in.
[$sel:extraCoinIn:SelectionParams] :: SelectionParams ctx -> !Coin

-- | Specifies extra <a>Coin</a> out.
[$sel:extraCoinOut:SelectionParams] :: SelectionParams ctx -> !Coin

-- | Specifies a set of outputs that must be paid for.
[$sel:outputsToCover:SelectionParams] :: SelectionParams ctx -> ![(Address ctx, TokenBundle)]

-- | Specifies the value of a withdrawal from a reward account.
[$sel:rewardWithdrawal:SelectionParams] :: SelectionParams ctx -> !Coin

-- | Number of deposits for stake key registrations.
[$sel:certificateDepositsTaken:SelectionParams] :: SelectionParams ctx -> !Natural

-- | Number of deposits from stake key de-registrations.
[$sel:certificateDepositsReturned:SelectionParams] :: SelectionParams ctx -> !Natural

-- | Specifies the collateral requirement for this selection.
[$sel:collateralRequirement:SelectionParams] :: SelectionParams ctx -> !SelectionCollateralRequirement

-- | Specifies a set of UTxOs that are available for selection as
--   collateral inputs.
--   
--   This set is allowed to intersect with
--   <a>$sel:utxoAvailableForInputs:SelectionParams</a>, since the ledger
--   does not require that these sets are disjoint.
[$sel:utxoAvailableForCollateral:SelectionParams] :: SelectionParams ctx -> !Map (UTxO ctx) Coin

-- | Specifies a set of UTxOs that are available for selection as ordinary
--   inputs and optionally, a subset that has already been selected.
--   
--   Further entries from this set will be selected to cover any deficit.
[$sel:utxoAvailableForInputs:SelectionParams] :: SelectionParams ctx -> !UTxOSelection (UTxO ctx)

-- | Specifies which selection strategy to use. See
--   <a>SelectionStrategy</a>.
[$sel:selectionStrategy:SelectionParams] :: SelectionParams ctx -> SelectionStrategy

-- | A skeleton selection that can be used to estimate the cost of a final
--   selection.
--   
--   Change outputs are deliberately stripped of their asset quantities, as
--   the fee estimation function must be agnostic to the magnitudes of
--   these quantities.
--   
--   Increasing or decreasing the quantity of a particular asset in a
--   change output must not change the estimated cost of a selection.
data SelectionSkeleton ctx
SelectionSkeleton :: !Int -> ![(Address ctx, TokenBundle)] -> ![Set AssetId] -> SelectionSkeleton ctx
[$sel:skeletonInputCount:SelectionSkeleton] :: SelectionSkeleton ctx -> !Int
[$sel:skeletonOutputs:SelectionSkeleton] :: SelectionSkeleton ctx -> ![(Address ctx, TokenBundle)]
[$sel:skeletonChange:SelectionSkeleton] :: SelectionSkeleton ctx -> ![Set AssetId]

-- | Assigns minimal ada quantities to outputs without ada quantities.
--   
--   This function only modifies outputs that have an ada quantity of zero.
--   Outputs that have non-zero ada quantities will not be modified.
prepareOutputsWith :: forall f address. Functor f => (address -> TokenMap -> Coin) -> f (address, TokenBundle) -> f (address, TokenBundle)

-- | Indicates a problem when preparing outputs for a coin selection.
data SelectionOutputError ctx
SelectionOutputCoinInsufficient :: SelectionOutputCoinInsufficientError ctx -> SelectionOutputError ctx
SelectionOutputSizeExceedsLimit :: SelectionOutputSizeExceedsLimitError ctx -> SelectionOutputError ctx
SelectionOutputTokenQuantityExceedsLimit :: SelectionOutputTokenQuantityExceedsLimitError ctx -> SelectionOutputError ctx
data SelectionOutputCoinInsufficientError ctx
SelectionOutputCoinInsufficientError :: Coin -> (Address ctx, TokenBundle) -> SelectionOutputCoinInsufficientError ctx
[$sel:minimumExpectedCoin:SelectionOutputCoinInsufficientError] :: SelectionOutputCoinInsufficientError ctx -> Coin
[$sel:output:SelectionOutputCoinInsufficientError] :: SelectionOutputCoinInsufficientError ctx -> (Address ctx, TokenBundle)
newtype SelectionOutputSizeExceedsLimitError ctx
SelectionOutputSizeExceedsLimitError :: (Address ctx, TokenBundle) -> SelectionOutputSizeExceedsLimitError ctx
[$sel:outputThatExceedsLimit:SelectionOutputSizeExceedsLimitError] :: SelectionOutputSizeExceedsLimitError ctx -> (Address ctx, TokenBundle)

-- | Indicates that a token quantity exceeds the maximum quantity that can
--   appear in a transaction output's token bundle.
data SelectionOutputTokenQuantityExceedsLimitError ctx
SelectionOutputTokenQuantityExceedsLimitError :: !Address ctx -> !AssetId -> !TokenQuantity -> !TokenQuantity -> SelectionOutputTokenQuantityExceedsLimitError ctx

-- | The address to which this token quantity was to be sent.
[$sel:address:SelectionOutputTokenQuantityExceedsLimitError] :: SelectionOutputTokenQuantityExceedsLimitError ctx -> !Address ctx

-- | The asset identifier to which this token quantity corresponds.
[$sel:asset:SelectionOutputTokenQuantityExceedsLimitError] :: SelectionOutputTokenQuantityExceedsLimitError ctx -> !AssetId

-- | The token quantity that exceeded the bound.
[$sel:quantity:SelectionOutputTokenQuantityExceedsLimitError] :: SelectionOutputTokenQuantityExceedsLimitError ctx -> !TokenQuantity

-- | The maximum allowable token quantity.
[$sel:quantityMaxBound:SelectionOutputTokenQuantityExceedsLimitError] :: SelectionOutputTokenQuantityExceedsLimitError ctx -> !TokenQuantity

-- | The result of verifying a post condition.
data VerificationResult
VerificationSuccess :: VerificationResult
VerificationFailure :: NonEmpty VerificationFailureReason -> VerificationResult

-- | Verifies a <a>Selection</a> for correctness.
--   
--   This function is provided primarily as a convenience for testing. As
--   such, it's not usually necessary to call this function from ordinary
--   application code, unless you suspect that a <a>Selection</a> is
--   incorrect in some way.
verifySelection :: SelectionContext ctx => VerifySelection ctx

-- | Verifies a <a>SelectionError</a> for correctness.
--   
--   This function is provided primarily as a convenience for testing. As
--   such, it's not usually necessary to call this function from ordinary
--   application code, unless you suspect that a <a>SelectionError</a> is
--   incorrect in some way.
verifySelectionError :: SelectionContext ctx => VerifySelectionError (SelectionError ctx) ctx

-- | Indicates the difference between total input value and total output
--   value of a <a>SelectionResult</a>.
--   
--   There are two possibilities:
--   
--   <ul>
--   <li><a>SelectionSurplus</a></li>
--   </ul>
--   
--   Indicates a surplus, when the total input value is greater than or
--   equal to the total output value.
--   
--   <ul>
--   <li><a>SelectionDeficit</a></li>
--   </ul>
--   
--   Indicates a deficit, when the total input value is NOT greater than or
--   equal to the total output value.
data SelectionDelta a
SelectionSurplus :: a -> SelectionDelta a
SelectionDeficit :: a -> SelectionDelta a

-- | Calculates the selection delta for all assets.
--   
--   See <a>SelectionDelta</a>.
selectionDeltaAllAssets :: Selection ctx -> SelectionDelta TokenBundle

-- | Calculates the ada selection delta.
--   
--   See <a>SelectionDelta</a>.
selectionDeltaCoin :: Selection ctx -> SelectionDelta Coin

-- | Indicates whether or not a selection has a valid surplus.
--   
--   This function returns <a>True</a> if and only if the selection has a
--   delta that is a *surplus*, and that surplus is greater than or equal
--   to the result of <a>selectionMinimumCost</a>.
--   
--   See <a>SelectionDelta</a>.
selectionHasValidSurplus :: SelectionConstraints ctx -> SelectionParams ctx -> Selection ctx -> Bool

-- | Computes the minimum required cost of a selection.
selectionMinimumCost :: SelectionConstraints ctx -> SelectionParams ctx -> Selection ctx -> Coin

-- | Calculates the ada selection surplus, assuming there is a surplus.
--   
--   If there is a surplus, then this function returns that surplus. If
--   there is a deficit, then this function returns zero.
--   
--   Use <a>selectionDeltaCoin</a> if you wish to handle the case where
--   there is a deficit.
selectionSurplusCoin :: Selection ctx -> Coin

-- | Represents an unsuccessful attempt to select collateral.
data SelectionCollateralError ctx
SelectionCollateralError :: Map (UTxO ctx) Coin -> Coin -> SelectionCollateralError ctx

-- | The largest combination of coins available.
[$sel:largestCombinationAvailable:SelectionCollateralError] :: SelectionCollateralError ctx -> Map (UTxO ctx) Coin

-- | A lower bound on the sum of coins to be selected as collateral.
[$sel:minimumSelectionAmount:SelectionCollateralError] :: SelectionCollateralError ctx -> Coin

-- | Indicates the collateral requirement for a selection.
data SelectionCollateralRequirement

-- | Indicates that collateral is required.
SelectionCollateralRequired :: SelectionCollateralRequirement

-- | Indicates that collateral is not required.
SelectionCollateralNotRequired :: SelectionCollateralRequirement

-- | Computes the total amount of collateral within a selection.
selectionCollateral :: Selection ctx -> Coin

-- | Indicates <a>True</a> if and only if collateral is required.
selectionCollateralRequired :: SelectionParams ctx -> Bool

-- | Indicates whether or not a selection has sufficient collateral.
selectionHasSufficientCollateral :: SelectionConstraints ctx -> SelectionParams ctx -> Selection ctx -> Bool

-- | Computes the minimum required amount of collateral for a selection.
selectionMinimumCollateral :: SelectionConstraints ctx -> SelectionParams ctx -> Selection ctx -> Coin

-- | Parameters for <a>computeMinimumCollateral</a>.
data ComputeMinimumCollateralParams
ComputeMinimumCollateralParams :: Natural -> Coin -> ComputeMinimumCollateralParams
[$sel:minimumCollateralPercentage:ComputeMinimumCollateralParams] :: ComputeMinimumCollateralParams -> Natural
[$sel:transactionFee:ComputeMinimumCollateralParams] :: ComputeMinimumCollateralParams -> Coin

-- | Computes the minimum required amount of collateral given a fee and a
--   minimum collateral percentage.
computeMinimumCollateral :: ComputeMinimumCollateralParams -> Coin

-- | Creates constraints and parameters for <a>performSelection</a>.
toBalanceConstraintsParams :: forall ctx. (SelectionConstraints ctx, SelectionParams ctx) -> (SelectionConstraints ctx, SelectionParams ctx)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.SelectionConstraints ctx)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.SelectionCollateralError ctx)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.Selection ctx)
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.VerificationResult
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionCollateralSufficient
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionCollateralSufficient
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionCollateralSuitable u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionCollateralSuitable u)
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionDeltaValid
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionDeltaValid
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionInputCountWithinLimit
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionInputCountWithinLimit
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.SelectionOutputCoinInsufficientError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputCoinsSufficient ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputCoinsSufficient ctx)
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.FailureToVerifyBalanceInsufficientError
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.FailureToVerifyBalanceInsufficientError
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifyEmptyUTxOError u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifyEmptyUTxOError u)
instance GHC.Show.Show address => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputCoinInsufficientError address)
instance GHC.Classes.Eq address => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputCoinInsufficientError address)
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionLimitReachedError u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionLimitReachedError u)
instance GHC.Show.Show u => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionCollateralError u)
instance GHC.Classes.Eq u => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionCollateralError u)
instance GHC.Show.Show address => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputSizeExceedsLimitError address)
instance GHC.Classes.Eq address => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputSizeExceedsLimitError address)
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.SelectionCollateralRequirement
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.Internal.SelectionCollateralRequirement
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.SelectionCollateralRequirement
instance GHC.Enum.Enum Cardano.Wallet.CoinSelection.Internal.SelectionCollateralRequirement
instance GHC.Enum.Bounded Cardano.Wallet.CoinSelection.Internal.SelectionCollateralRequirement
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.SelectionParams ctx)
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.ComputeMinimumCollateralParams
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.Internal.ComputeMinimumCollateralParams
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.ComputeMinimumCollateralParams
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.SelectionOutputSizeExceedsLimitError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext address => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputSizesWithinLimit address)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext address => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputSizesWithinLimit address)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.SelectionOutputTokenQuantityExceedsLimitError ctx)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.Internal.SelectionOutputError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputTokenQuantityExceedsLimitError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputTokenQuantityExceedsLimitError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext address => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputTokenQuantitiesWithinLimit address)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext address => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifySelectionOutputTokenQuantitiesWithinLimit address)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.SelectionParams ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.SelectionParams ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.SelectionError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.SelectionError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.SelectionCollateralError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.SelectionCollateralError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.Selection ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.Selection ctx)
instance GHC.Show.Show Cardano.Wallet.CoinSelection.Internal.VerificationFailureReason
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.SelectionOutputCoinInsufficientError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.SelectionOutputCoinInsufficientError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.FailureToVerifyUnableToConstructChangeError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.FailureToVerifyUnableToConstructChangeError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.SelectionOutputError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.SelectionOutputError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.SelectionOutputSizeExceedsLimitError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.SelectionOutputSizeExceedsLimitError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.Internal.SelectionOutputTokenQuantityExceedsLimitError ctx)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext ctx => GHC.Show.Show (Cardano.Wallet.CoinSelection.Internal.SelectionOutputTokenQuantityExceedsLimitError ctx)
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.Internal.VerificationResult
instance GHC.Base.Monoid Cardano.Wallet.CoinSelection.Internal.VerificationResult
instance GHC.Base.Semigroup Cardano.Wallet.CoinSelection.Internal.VerificationResult


-- | This module provides a wallet-specific interface for coin selection.
--   
--   Coin selection handles the following responsibilities:
--   
--   <ul>
--   <li>selecting inputs from the UTxO set to pay for user-specified
--   outputs;</li>
--   <li>selecting inputs from the UTxO set to pay for collateral;</li>
--   <li>producing change outputs to return excess value to the
--   wallet;</li>
--   <li>balancing a selection to pay for the transaction fee.</li>
--   </ul>
--   
--   Use the <a>performSelection</a> function to perform a coin selection.
module Cardano.Wallet.CoinSelection

-- | A selection context for the wallet.
data WalletSelectionContext

-- | A type of unique UTxO identifier for the wallet.
data WalletUTxO
WalletUTxO :: TxIn -> Address -> WalletUTxO
[$sel:txIn:WalletUTxO] :: WalletUTxO -> TxIn
[$sel:address:WalletUTxO] :: WalletUTxO -> Address
toExternalUTxO :: (WalletUTxO, TokenBundle) -> (TxIn, TxOut)
toExternalUTxOMap :: Map WalletUTxO TokenBundle -> UTxO
toInternalUTxO :: (TxIn, TxOut) -> (WalletUTxO, TokenBundle)
toInternalUTxOMap :: UTxO -> Map WalletUTxO TokenBundle
toExternalSelection :: Selection WalletSelectionContext -> Selection
toInternalSelection :: (change -> TokenBundle) -> SelectionOf change -> Selection WalletSelectionContext

-- | Performs a coin selection.
--   
--   This function has the following responsibilities:
--   
--   <ul>
--   <li>selecting inputs from the UTxO set to pay for user-specified
--   outputs;</li>
--   <li>selecting inputs from the UTxO set to pay for collateral;</li>
--   <li>producing change outputs to return excess value to the
--   wallet;</li>
--   <li>balancing a selection to pay for the transaction fee.</li>
--   </ul>
--   
--   See <a>performSelection</a> for more details.
performSelection :: forall m. (HasCallStack, MonadRandom m) => SelectionConstraints -> SelectionParams -> ExceptT (SelectionError WalletSelectionContext) m Selection

-- | The default type of selection.
--   
--   In this type of selection, change values do not have addresses
--   assigned.
type Selection = SelectionOf TokenBundle

-- | Indicates the collateral requirement for a selection.
data SelectionCollateralRequirement

-- | Indicates that collateral is required.
SelectionCollateralRequired :: SelectionCollateralRequirement

-- | Indicates that collateral is not required.
SelectionCollateralNotRequired :: SelectionCollateralRequirement

-- | Specifies all constraints required for coin selection.
--   
--   Selection constraints:
--   
--   <ul>
--   <li>are dependent on the current set of protocol parameters.</li>
--   <li>are not specific to a given selection.</li>
--   <li>place limits on the coin selection algorithm, enabling it to
--   produce selections that are acceptable to the ledger.</li>
--   </ul>
data SelectionConstraints
SelectionConstraints :: (TokenBundle -> TokenBundleSizeAssessment) -> Coin -> (Address -> TokenMap -> Coin) -> (Address -> TokenBundle -> Bool) -> (SelectionSkeleton -> Coin) -> ([TxOut] -> SelectionLimit) -> Int -> Natural -> Address -> SelectionConstraints

-- | Assesses the size of a token bundle relative to the upper limit of
--   what can be included in a transaction output. See documentation for
--   the <tt>TokenBundleSizeAssessor</tt> type to learn about the expected
--   properties of this field.
[$sel:assessTokenBundleSize:SelectionConstraints] :: SelectionConstraints -> TokenBundle -> TokenBundleSizeAssessment

-- | Amount that should be taken from/returned back to the wallet for each
--   stake key registration/de-registration in the transaction.
[$sel:certificateDepositAmount:SelectionConstraints] :: SelectionConstraints -> Coin

-- | Computes the minimum ada quantity required for a given output.
[$sel:computeMinimumAdaQuantity:SelectionConstraints] :: SelectionConstraints -> Address -> TokenMap -> Coin

-- | Returns <a>True</a> if the given <a>TokenBundle</a> has a <a>Coin</a>
--   value that is below the minimum required.
[$sel:isBelowMinimumAdaQuantity:SelectionConstraints] :: SelectionConstraints -> Address -> TokenBundle -> Bool

-- | Computes the minimum cost of a given selection skeleton.
[$sel:computeMinimumCost:SelectionConstraints] :: SelectionConstraints -> SelectionSkeleton -> Coin

-- | Computes an upper bound for the number of ordinary inputs to select,
--   given a current set of outputs.
[$sel:computeSelectionLimit:SelectionConstraints] :: SelectionConstraints -> [TxOut] -> SelectionLimit

-- | Specifies an inclusive upper bound on the number of unique inputs that
--   can be selected as collateral.
[$sel:maximumCollateralInputCount:SelectionConstraints] :: SelectionConstraints -> Int

-- | Specifies the minimum required amount of collateral as a percentage of
--   the total transaction fee.
[$sel:minimumCollateralPercentage:SelectionConstraints] :: SelectionConstraints -> Natural
[$sel:maximumLengthChangeAddress:SelectionConstraints] :: SelectionConstraints -> Address

-- | Indicates that an error occurred while performing a coin selection.
data SelectionError ctx
SelectionBalanceErrorOf :: SelectionBalanceError ctx -> SelectionError ctx
SelectionCollateralErrorOf :: SelectionCollateralError ctx -> SelectionError ctx
SelectionOutputErrorOf :: SelectionOutputError ctx -> SelectionError ctx

-- | Specifies a limit to adhere to when performing a selection.
type SelectionLimit = SelectionLimitOf Int
data SelectionLimitOf a

-- | Indicates that there is no limit.
NoLimit :: SelectionLimitOf a

-- | Indicates a maximum limit on the number of inputs to select.
MaximumInputLimit :: a -> SelectionLimitOf a

-- | Represents a balanced selection.
data SelectionOf change
Selection :: !NonEmpty (TxIn, TxOut) -> ![(TxIn, TxOut)] -> ![TxOut] -> ![change] -> !TokenMap -> !TokenMap -> !Coin -> !Coin -> SelectionOf change

-- | Selected inputs.
[$sel:inputs:Selection] :: SelectionOf change -> !NonEmpty (TxIn, TxOut)

-- | Selected collateral inputs.
[$sel:collateral:Selection] :: SelectionOf change -> ![(TxIn, TxOut)]

-- | User-specified outputs
[$sel:outputs:Selection] :: SelectionOf change -> ![TxOut]

-- | Generated change outputs.
[$sel:change:Selection] :: SelectionOf change -> ![change]

-- | Assets to mint.
[$sel:assetsToMint:Selection] :: SelectionOf change -> !TokenMap

-- | Assets to burn.
[$sel:assetsToBurn:Selection] :: SelectionOf change -> !TokenMap

-- | An extra source of ada.
[$sel:extraCoinSource:Selection] :: SelectionOf change -> !Coin

-- | An extra sink for ada.
[$sel:extraCoinSink:Selection] :: SelectionOf change -> !Coin

-- | Specifies all parameters that are specific to a given selection.
data SelectionParams
SelectionParams :: !TokenMap -> !TokenMap -> !Coin -> !Coin -> ![TxOut] -> !Coin -> !Natural -> !Natural -> !SelectionCollateralRequirement -> !Map WalletUTxO TokenBundle -> !UTxOSelection WalletUTxO -> SelectionStrategy -> SelectionParams

-- | Specifies a set of assets to burn.
[$sel:assetsToBurn:SelectionParams] :: SelectionParams -> !TokenMap

-- | Specifies a set of assets to mint.
[$sel:assetsToMint:SelectionParams] :: SelectionParams -> !TokenMap

-- | Specifies extra <a>Coin</a> in.
[$sel:extraCoinIn:SelectionParams] :: SelectionParams -> !Coin

-- | Specifies extra <a>Coin</a> out.
[$sel:extraCoinOut:SelectionParams] :: SelectionParams -> !Coin

-- | Specifies a set of outputs that must be paid for.
[$sel:outputsToCover:SelectionParams] :: SelectionParams -> ![TxOut]

-- | Specifies the value of a withdrawal from a reward account.
[$sel:rewardWithdrawal:SelectionParams] :: SelectionParams -> !Coin

-- | Number of deposits for stake key registrations.
[$sel:certificateDepositsTaken:SelectionParams] :: SelectionParams -> !Natural

-- | Number of deposits from stake key de-registrations.
[$sel:certificateDepositsReturned:SelectionParams] :: SelectionParams -> !Natural

-- | Specifies the collateral requirement for this selection.
[$sel:collateralRequirement:SelectionParams] :: SelectionParams -> !SelectionCollateralRequirement

-- | Specifies a set of UTxOs that are available for selection as
--   collateral inputs.
--   
--   This set is allowed to intersect with
--   <a>$sel:utxoAvailableForInputs:SelectionParams</a>, since the ledger
--   does not require that these sets are disjoint.
[$sel:utxoAvailableForCollateral:SelectionParams] :: SelectionParams -> !Map WalletUTxO TokenBundle

-- | Specifies a set of UTxOs that are available for selection as ordinary
--   inputs and optionally, a subset that has already been selected.
--   
--   Further entries from this set will be selected to cover any deficit.
[$sel:utxoAvailableForInputs:SelectionParams] :: SelectionParams -> !UTxOSelection WalletUTxO

-- | Specifies which selection strategy to use. See
--   <a>SelectionStrategy</a>.
[$sel:selectionStrategy:SelectionParams] :: SelectionParams -> SelectionStrategy

-- | Indicates a choice of selection strategy.
--   
--   A <a>SelectionStrategy</a> determines <b>how much</b> of each asset
--   the selection algorithm will attempt to select from the available UTxO
--   set, relative to the minimum amount necessary to make the selection
--   balance.
--   
--   The default <a>SelectionStrategy</a> is
--   <a>SelectionStrategyOptimal</a>, which when specified will cause the
--   selection algorithm to attempt to select around <b><i>twice</i></b>
--   the minimum possible amount of each asset from the available UTxO set,
--   making it possible to generate change outputs that are roughly the
--   same sizes and shapes as the user-specified outputs.
--   
--   Specifying <a>SelectionStrategyMinimal</a> will cause the selection
--   algorithm to only select <b>just enough</b> of each asset from the
--   available UTxO set to meet the minimum amount. The selection process
--   will terminate as soon as the minimum amount of each asset is covered.
--   
--   The "optimal" strategy is recommended for most situations, as using
--   this strategy will help to ensure that a wallet's UTxO distribution
--   can evolve over time to resemble the typical distribution of payments
--   made by the wallet owner. This increases the likelihood that future
--   selections will succeed, and lowers the amortized cost of future
--   transactions.
--   
--   The "minimal" strategy is recommended only for situations where it is
--   not possible to create a selection with the "optimal" strategy. It is
--   advised to use this strategy only when necessary, as it increases the
--   likelihood of generating change outputs that are much smaller than
--   user-specified outputs. If this strategy is used regularly, the UTxO
--   set can evolve to a state where the distribution no longer resembles
--   the typical distribution of payments made by the user. This increases
--   the likelihood that future selections will not succeed, and increases
--   the amortized cost of future transactions.
data SelectionStrategy
SelectionStrategyMinimal :: SelectionStrategy
SelectionStrategyOptimal :: SelectionStrategy

-- | A skeleton selection that can be used to estimate the cost of a final
--   selection.
--   
--   Change outputs are deliberately stripped of their asset quantities, as
--   the fee estimation function must be agnostic to the magnitudes of
--   these quantities.
--   
--   Increasing or decreasing the quantity of a particular asset in a
--   change output must not change the estimated cost of a selection.
data SelectionSkeleton
SelectionSkeleton :: !Int -> ![TxOut] -> ![Set AssetId] -> SelectionSkeleton
[$sel:skeletonInputCount:SelectionSkeleton] :: SelectionSkeleton -> !Int
[$sel:skeletonOutputs:SelectionSkeleton] :: SelectionSkeleton -> ![TxOut]
[$sel:skeletonChange:SelectionSkeleton] :: SelectionSkeleton -> ![Set AssetId]

-- | Creates an empty <a>SelectionSkeleton</a>.
emptySkeleton :: SelectionSkeleton

-- | Indicates that the balance of available UTxO entries is insufficient
--   to cover the balance required.
--   
--   See <a>computeUTxOBalanceSufficiency</a>.
data BalanceInsufficientError
BalanceInsufficientError :: !TokenBundle -> !TokenBundle -> BalanceInsufficientError

-- | The balance of <a>$sel:utxoAvailable:SelectionParams</a>.
[$sel:utxoBalanceAvailable:BalanceInsufficientError] :: BalanceInsufficientError -> !TokenBundle

-- | The balance of <a>$sel:outputsToCover:SelectionParams</a>.
[$sel:utxoBalanceRequired:BalanceInsufficientError] :: BalanceInsufficientError -> !TokenBundle

-- | Represents the set of errors that may occur while performing a
--   selection.
data SelectionBalanceError ctx
BalanceInsufficient :: BalanceInsufficientError -> SelectionBalanceError ctx
SelectionLimitReached :: SelectionLimitReachedError ctx -> SelectionBalanceError ctx
UnableToConstructChange :: UnableToConstructChangeError -> SelectionBalanceError ctx
EmptyUTxO :: SelectionBalanceError ctx

-- | Represents an unsuccessful attempt to select collateral.
data SelectionCollateralError ctx

-- | Indicates a problem when preparing outputs for a coin selection.
data SelectionOutputError ctx
SelectionOutputCoinInsufficient :: SelectionOutputCoinInsufficientError ctx -> SelectionOutputError ctx
SelectionOutputSizeExceedsLimit :: SelectionOutputSizeExceedsLimitError ctx -> SelectionOutputError ctx
SelectionOutputTokenQuantityExceedsLimit :: SelectionOutputTokenQuantityExceedsLimitError ctx -> SelectionOutputError ctx
data SelectionOutputCoinInsufficientError ctx
SelectionOutputCoinInsufficientError :: Coin -> (Address ctx, TokenBundle) -> SelectionOutputCoinInsufficientError ctx
[$sel:minimumExpectedCoin:SelectionOutputCoinInsufficientError] :: SelectionOutputCoinInsufficientError ctx -> Coin
[$sel:output:SelectionOutputCoinInsufficientError] :: SelectionOutputCoinInsufficientError ctx -> (Address ctx, TokenBundle)
newtype SelectionOutputSizeExceedsLimitError ctx
SelectionOutputSizeExceedsLimitError :: (Address ctx, TokenBundle) -> SelectionOutputSizeExceedsLimitError ctx
[$sel:outputThatExceedsLimit:SelectionOutputSizeExceedsLimitError] :: SelectionOutputSizeExceedsLimitError ctx -> (Address ctx, TokenBundle)

-- | Indicates that a token quantity exceeds the maximum quantity that can
--   appear in a transaction output's token bundle.
data SelectionOutputTokenQuantityExceedsLimitError ctx
SelectionOutputTokenQuantityExceedsLimitError :: !Address ctx -> !AssetId -> !TokenQuantity -> !TokenQuantity -> SelectionOutputTokenQuantityExceedsLimitError ctx

-- | The address to which this token quantity was to be sent.
[$sel:address:SelectionOutputTokenQuantityExceedsLimitError] :: SelectionOutputTokenQuantityExceedsLimitError ctx -> !Address ctx

-- | The asset identifier to which this token quantity corresponds.
[$sel:asset:SelectionOutputTokenQuantityExceedsLimitError] :: SelectionOutputTokenQuantityExceedsLimitError ctx -> !AssetId

-- | The token quantity that exceeded the bound.
[$sel:quantity:SelectionOutputTokenQuantityExceedsLimitError] :: SelectionOutputTokenQuantityExceedsLimitError ctx -> !TokenQuantity

-- | The maximum allowable token quantity.
[$sel:quantityMaxBound:SelectionOutputTokenQuantityExceedsLimitError] :: SelectionOutputTokenQuantityExceedsLimitError ctx -> !TokenQuantity
data UnableToConstructChangeError
UnableToConstructChangeError :: !Coin -> !Coin -> UnableToConstructChangeError

-- | The minimal required cost needed for the transaction to be considered
--   valid. This does not include min Ada values.
[$sel:requiredCost:UnableToConstructChangeError] :: UnableToConstructChangeError -> !Coin

-- | The additional coin quantity that would be required to cover the
--   selection cost and minimum coin quantity of each change output.
[$sel:shortfall:UnableToConstructChangeError] :: UnableToConstructChangeError -> !Coin
makeSelectionReportDetailed :: Selection -> SelectionReportDetailed
makeSelectionReportSummarized :: Selection -> SelectionReportSummarized

-- | Includes detailed information about a selection.
data SelectionReportDetailed

-- | Includes summarized information about a selection.
--   
--   Each data point can be serialized as a single line of text.
data SelectionReportSummarized

-- | Calculate the missing balance from a
--   <tt>BalanceInsufficientError</tt>.
balanceMissing :: BalanceInsufficientError -> TokenBundle

-- | Computes the ada surplus of a selection, assuming there is a surplus.
selectionDelta :: (change -> Coin) -> SelectionOf change -> Coin
instance GHC.Show.Show Cardano.Wallet.CoinSelection.WalletUTxO
instance GHC.Classes.Ord Cardano.Wallet.CoinSelection.WalletUTxO
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.WalletUTxO
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.WalletUTxO
instance GHC.Show.Show Cardano.Wallet.CoinSelection.SelectionParams
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.SelectionParams
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.SelectionParams
instance GHC.Show.Show Cardano.Wallet.CoinSelection.SelectionSkeleton
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.SelectionSkeleton
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.SelectionSkeleton
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.SelectionConstraints
instance GHC.Show.Show change => GHC.Show.Show (Cardano.Wallet.CoinSelection.SelectionOf change)
instance GHC.Classes.Eq change => GHC.Classes.Eq (Cardano.Wallet.CoinSelection.SelectionOf change)
instance GHC.Generics.Generic (Cardano.Wallet.CoinSelection.SelectionOf change)
instance GHC.Show.Show Cardano.Wallet.CoinSelection.SelectionReportSummarized
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.SelectionReportSummarized
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.SelectionReportSummarized
instance GHC.Show.Show Cardano.Wallet.CoinSelection.SelectionReportDetailed
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.SelectionReportDetailed
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.SelectionReportDetailed
instance GHC.Show.Show Cardano.Wallet.CoinSelection.SelectionReport
instance GHC.Generics.Generic Cardano.Wallet.CoinSelection.SelectionReport
instance GHC.Classes.Eq Cardano.Wallet.CoinSelection.SelectionReport
instance Formatting.Buildable.Buildable Cardano.Wallet.CoinSelection.SelectionReport
instance Formatting.Buildable.Buildable Cardano.Wallet.CoinSelection.SelectionReportDetailed
instance Formatting.Buildable.Buildable Cardano.Wallet.CoinSelection.SelectionReportSummarized
instance Formatting.Buildable.Buildable (Cardano.Wallet.CoinSelection.SelectionOf Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)
instance Formatting.Buildable.Buildable (Cardano.Wallet.CoinSelection.SelectionOf Cardano.Wallet.Primitive.Types.Tx.TxOut)
instance Cardano.Wallet.CoinSelection.Internal.Context.SelectionContext Cardano.Wallet.CoinSelection.WalletSelectionContext
instance Formatting.Buildable.Buildable Cardano.Wallet.CoinSelection.WalletUTxO
instance Formatting.Buildable.Buildable (Cardano.Wallet.CoinSelection.WalletUTxO, Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)


-- | These are (partial) CBOR decoders for Byron binary types. Note that we
--   ignore most of the block's and header's content and only retrieve the
--   pieces of information relevant to us, wallet (we do assume a trusted
--   node and therefore, we needn't to care about verifying signatures and
--   blocks themselves).
--   
--   The format described in the decoders below are the one used in the
--   Byron era of Cardano and will endure in the first stages of Shelley.
--   They are also used by components like the Rust
--   <a>cardano-http-bridge</a>.
module Cardano.Byron.Codec.Cbor
decodeAddressDerivationPath :: Passphrase "addr-derivation-payload" -> Decoder s (Maybe (Index 'WholeDomain 'AccountK, Index 'WholeDomain 'AddressK))
decodeAddressPayload :: Decoder s ByteString

-- | The attributes are pairs of numeric tags and bytes, where the bytes
--   will be CBOR-encoded stuff. This decoder does not enforce "canonicity"
--   of entries.
decodeAllAttributes :: Decoder s [(Word8, ByteString)]
decodeDerivationPathAttr :: Passphrase "addr-derivation-payload" -> [(Word8, ByteString)] -> Decoder s (Maybe (Index 'WholeDomain 'AccountK, Index 'WholeDomain 'AddressK))
decodeTx :: Decoder s ([TxIn], [TxOut])

-- | Encode a public key to a corresponding Cardano Address. The encoding
--   of the attributes part of an address is left out to the caller; This
--   allows for distinguishing between Sequential and Random addresses (the
--   former doesn't have any attributes to encode).
--   
--   <pre>
--   -- Old / Random Addresses
--   let encodeAddrAttributes = mempty
--        &lt;&gt; CBOR.encodeMapLen 1
--        &lt;&gt; CBOR.encodeWord8 1
--        &lt;&gt; encodeDerivationPath (hdPassphrase rootXPub) accIx addrIx
--   let addr = encodeAddress xpub encodeAddrAttributes
--   
--   -- New / Sequential Addresses
--   let encodeAddrAttributes = mempty &lt;&gt; CBOR.encodeMapLen 0
--   let addr = encodeAddress xpub encodeAddrAttributes
--   </pre>
--   
--   Note that we are passing the behavior to encode attributes as a
--   parameter here and do not handle multiple cases in
--   <a>encodeAddress</a> itself for multiple reasons:
--   
--   <ul>
--   <li>Inversion of control gives us a nicer implementation overall</li>
--   <li>Encoding attributes for Random addresses requires more context
--   than just the public key (like the wallet root id and some extra logic
--   for encoding passphrases). This is just scheme-specific and is better
--   left out of this particular function</li>
--   </ul>
encodeAddress :: XPub -> [Encoding] -> Encoding
encodeAttributes :: [Encoding] -> Encoding
encodeDerivationPathAttr :: Passphrase "addr-derivation-payload" -> Index 'WholeDomain 'AccountK -> Index 'WholeDomain 'AddressK -> Encoding
encodeProtocolMagicAttr :: ProtocolMagic -> Encoding
encodeTx :: ([TxIn], [TxOut]) -> Encoding

-- | Shortcut for deserialising a strict <tt>Bytestring</tt> with the given
--   decoder.
deserialiseCbor :: (forall s. Decoder s a) -> ByteString -> Maybe a

-- | Decode an arbitrary long list. CBOR introduce a "break" character to
--   mark the end of the list, so we simply decode each item until we
--   encounter a break character.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeListIndef decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeListIndef :: forall s a. Decoder s a -> Decoder s [a]

-- | Byron CBOR encodings often have CBOR nested in CBOR. This helps
--   decoding a particular <a>ByteString</a> that represents a CBOR object.
decodeNestedBytes :: MonadFail m => (forall s. Decoder s r) -> ByteString -> m r


-- | Implementation of address derivation for the random scheme, as
--   implemented by the legacy Cardano wallets.
--   
--   For full documentation of the key derivation schemes, see the
--   <a>Cardano.Crypto.Wallet</a> module, and the implementation in
--   <a>cardano-crypto</a>.
module Cardano.Wallet.Primitive.AddressDerivation.Byron

-- | Material for deriving HD random scheme keys, which can be used for
--   making addresses.
data ByronKey (depth :: Depth) key
ByronKey :: key -> DerivationPathFrom depth -> Passphrase "addr-derivation-payload" -> ByronKey (depth :: Depth) key

-- | The raw private or public key.
[getKey] :: ByronKey (depth :: Depth) key -> key

-- | The address derivation indices for the level of this key.
[derivationPath] :: ByronKey (depth :: Depth) key -> DerivationPathFrom depth

-- | Used for encryption of payload containing address derivation path.
[payloadPassphrase] :: ByronKey (depth :: Depth) key -> Passphrase "addr-derivation-payload"

-- | The hierarchical derivation indices for a given level/depth.
type family DerivationPathFrom (depth :: Depth) :: Type

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: DerivationPathFrom depth -> SomeMnemonic -> Passphrase "encryption" -> ByronKey depth XPrv

-- | Generate a root key from a corresponding seed. The seed should be at
--   least 16 bytes.
generateKeyFromSeed :: SomeMnemonic -> Passphrase "encryption" -> ByronKey 'RootK XPrv

-- | The amount of entropy carried by a BIP-39 12-word mnemonic is 16
--   bytes.
minSeedLengthBytes :: Int
unsafeMkByronKeyFromMasterKey :: DerivationPathFrom depth -> XPrv -> ByronKey depth XPrv
mkByronKeyFromMasterKey :: XPrv -> ByronKey 'RootK XPrv

-- | Derives account private key from the given root private key, using
--   derivation scheme 1.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAccountPrivateKey :: Passphrase "encryption" -> ByronKey 'RootK XPrv -> Index 'WholeDomain 'AccountK -> ByronKey 'AccountK XPrv

-- | Derives address private key from the given account private key, using
--   derivation scheme 1.
--   
--   NOTE: The caller is expected to provide the corresponding passphrase
--   (and to have checked that the passphrase is valid). Providing a wrong
--   passphrase will not make the function fail but will instead, yield an
--   incorrect new key that doesn't belong to the wallet.
deriveAddressPrivateKey :: Passphrase "encryption" -> ByronKey 'AccountK XPrv -> Index 'WholeDomain 'AddressK -> ByronKey 'AddressK XPrv
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey depth key)
instance (GHC.Show.Show key, GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Byron.DerivationPathFrom depth)) => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey depth key)
instance (GHC.Classes.Eq key, GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Byron.DerivationPathFrom depth)) => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey depth key)
instance (Control.DeepSeq.NFData key, Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Byron.DerivationPathFrom depth)) => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey depth key)
instance Cardano.Wallet.Primitive.AddressDerivation.WalletKey Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance GHC.TypeNats.KnownNat pm => Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress ('Cardano.Wallet.Primitive.AddressDerivation.Testnet pm) Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey Cardano.Wallet.Primitive.Types.Address.Address
instance Cardano.Wallet.Primitive.AddressDerivation.BoundedAddressLength Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance Cardano.Wallet.Primitive.AddressDerivation.HardDerivation Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPrivateKey (Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey 'Cardano.Wallet.Primitive.AddressDerivation.RootK)


-- | This module contains the core primitive of a Wallet. This is roughly a
--   Haskell translation of the <a>Formal Specification for a Cardano
--   Wallet</a>
--   
--   It doesn't contain any particular business-logic code, but defines a
--   few primitive operations on Wallet core types as well.
module Cardano.Wallet.Primitive.Types

-- | A block on the chain, as the wallet sees it.
data Block
Block :: !BlockHeader -> ![Tx] -> ![DelegationCertificate] -> Block
[$sel:header:Block] :: Block -> !BlockHeader
[$sel:transactions:Block] :: Block -> ![Tx]
[$sel:delegations:Block] :: Block -> ![DelegationCertificate]
data BlockHeader
BlockHeader :: SlotNo -> Quantity "block" Word32 -> !Hash "BlockHeader" -> !Maybe (Hash "BlockHeader") -> BlockHeader
[$sel:slotNo:BlockHeader] :: BlockHeader -> SlotNo
[$sel:blockHeight:BlockHeader] :: BlockHeader -> Quantity "block" Word32
[$sel:headerHash:BlockHeader] :: BlockHeader -> !Hash "BlockHeader"
[$sel:parentHeaderHash:BlockHeader] :: BlockHeader -> !Maybe (Hash "BlockHeader")

-- | Check whether a block with a given <a>BlockHeader</a> is the genesis
--   block.
isGenesisBlockHeader :: BlockHeader -> Bool

-- | A point on the blockchain is either the genesis block, or a block with
--   a hash that was created at a particular <a>SlotNo</a>.
--   
--   TODO:
--   
--   <ul>
--   <li>This type is essentially a copy of the <a>ChainPoint</a> type. We
--   want to import it from there when overhauling our types.</li>
--   <li>That said, using <a>WithOrigin</a> would not be bad.</li>
--   <li><a>BlockHeader</a> is also a good type for rerencing points on the
--   chain, but it's less compatible with the types in
--   ouroboros-network.</li>
--   </ul>
data ChainPoint
ChainPointAtGenesis :: ChainPoint
ChainPoint :: !SlotNo -> !Hash "BlockHeader" -> ChainPoint

-- | Compare the slot numbers of two <a>ChainPoint</a>s, but where the
--   <a>ChainPointAtGenesis</a> comes before all other slot numbers.
compareSlot :: ChainPoint -> ChainPoint -> Ordering

-- | Convert a <a>BlockHeader</a> into a <a>ChainPoint</a>.
chainPointFromBlockHeader :: BlockHeader -> ChainPoint

-- | A point in (slot) time, which is either genesis (<a>Origin</a>) or has
--   a slot number (<a>At</a>).
--   
--   In contrast to <a>ChainPoint</a>, the type <a>Slot</a> does not refer
--   to a point on an actual chain with valid block hashes, but merely to a
--   timeslot which can hold a single block. This implies:
--   
--   <ul>
--   <li><a>Slot</a> has a linear ordering implemented in the <a>Ord</a>
--   class (where <tt>Origin &lt; At slot</tt>).</li>
--   <li>Using <a>Slot</a> in QuickCheck testing requires less context
--   (such as an actual simulated chain.)</li>
--   </ul>
type Slot = WithOrigin SlotNo
data WithOrigin t
Origin :: WithOrigin t
At :: !t -> WithOrigin t

-- | Retrieve the slot of a <a>ChainPoint</a>.
toSlot :: ChainPoint -> Slot

-- | Represents an abstract notion of a certificate publication time.
--   
--   Certificates published at later times take precedence over
--   certificates published at earlier times.
data CertificatePublicationTime
CertificatePublicationTime :: SlotNo -> Word64 -> CertificatePublicationTime
[$sel:slotNo:CertificatePublicationTime] :: CertificatePublicationTime -> SlotNo

-- | Indicates the relative position of a publication within a slot.
[$sel:slotInternalIndex:CertificatePublicationTime] :: CertificatePublicationTime -> Word64

-- | Represent a delegation certificate.
data DelegationCertificate
CertDelegateNone :: RewardAccount -> DelegationCertificate
CertDelegateFull :: RewardAccount -> PoolId -> DelegationCertificate
CertRegisterKey :: RewardAccount -> DelegationCertificate
dlgCertAccount :: DelegationCertificate -> RewardAccount
dlgCertPoolId :: DelegationCertificate -> Maybe PoolId

-- | Indicates the current life cycle status of a pool.
data PoolLifeCycleStatus

-- | Indicates that a pool is not registered.
PoolNotRegistered :: PoolLifeCycleStatus

-- | Indicates that a pool is registered BUT NOT marked for retirement.
--   Records the latest registration certificate.
PoolRegistered :: PoolRegistrationCertificate -> PoolLifeCycleStatus

-- | Indicates that a pool is registered AND ALSO marked for retirement.
--   Records the latest registration and retirement certificates.
PoolRegisteredAndRetired :: PoolRegistrationCertificate -> PoolRetirementCertificate -> PoolLifeCycleStatus

-- | Pool ownership data from the stake pool registration certificate.
data PoolRegistrationCertificate
PoolRegistrationCertificate :: !PoolId -> ![PoolOwner] -> Percentage -> Coin -> Coin -> Maybe (StakePoolMetadataUrl, StakePoolMetadataHash) -> PoolRegistrationCertificate
[$sel:poolId:PoolRegistrationCertificate] :: PoolRegistrationCertificate -> !PoolId
[$sel:poolOwners:PoolRegistrationCertificate] :: PoolRegistrationCertificate -> ![PoolOwner]
[$sel:poolMargin:PoolRegistrationCertificate] :: PoolRegistrationCertificate -> Percentage
[$sel:poolCost:PoolRegistrationCertificate] :: PoolRegistrationCertificate -> Coin
[$sel:poolPledge:PoolRegistrationCertificate] :: PoolRegistrationCertificate -> Coin
[$sel:poolMetadata:PoolRegistrationCertificate] :: PoolRegistrationCertificate -> Maybe (StakePoolMetadataUrl, StakePoolMetadataHash)
data PoolRetirementCertificate
PoolRetirementCertificate :: !PoolId -> !EpochNo -> PoolRetirementCertificate
[$sel:poolId:PoolRetirementCertificate] :: PoolRetirementCertificate -> !PoolId

-- | The first epoch when the pool becomes inactive.
[$sel:retirementEpoch:PoolRetirementCertificate] :: PoolRetirementCertificate -> !EpochNo

-- | Sum-type of pool registration- and retirement- certificates. Mirrors
--   the <tt>PoolCert</tt> type in cardano-ledger-specs.
data PoolCertificate
Registration :: PoolRegistrationCertificate -> PoolCertificate
Retirement :: PoolRetirementCertificate -> PoolCertificate
getPoolCertificatePoolId :: PoolCertificate -> PoolId
setPoolCertificatePoolId :: PoolId -> PoolCertificate -> PoolCertificate
getPoolRegistrationCertificate :: PoolLifeCycleStatus -> Maybe PoolRegistrationCertificate
getPoolRetirementCertificate :: PoolLifeCycleStatus -> Maybe PoolRetirementCertificate
data NonWalletCertificate
GenesisCertificate :: NonWalletCertificate
MIRCertificate :: NonWalletCertificate
data Certificate
CertificateOfDelegation :: DelegationCertificate -> Certificate
CertificateOfPool :: PoolCertificate -> Certificate
CertificateOther :: NonWalletCertificate -> Certificate

-- | Records the complete set of parameters currently in use by the network
--   that are relevant to the wallet.
data NetworkParameters
NetworkParameters :: GenesisParameters -> SlottingParameters -> ProtocolParameters -> NetworkParameters

-- | See <a>GenesisParameters</a>.
[$sel:genesisParameters:NetworkParameters] :: NetworkParameters -> GenesisParameters

-- | See <a>SlottingParameters</a>.
[$sel:slottingParameters:NetworkParameters] :: NetworkParameters -> SlottingParameters

-- | See <a>ProtocolParameters</a>.
[$sel:protocolParameters:NetworkParameters] :: NetworkParameters -> ProtocolParameters

-- | Parameters defined by the <b>genesis block</b>.
--   
--   At present, these values cannot be changed through the update system.
--   
--   They can only be changed through a soft or hard fork.
data GenesisParameters
GenesisParameters :: Hash "Genesis" -> StartTime -> GenesisParameters

-- | Hash of the very first block
[$sel:getGenesisBlockHash:GenesisParameters] :: GenesisParameters -> Hash "Genesis"

-- | Start time of the chain.
[$sel:getGenesisBlockDate:GenesisParameters] :: GenesisParameters -> StartTime
data SlottingParameters
SlottingParameters :: SlotLength -> EpochLength -> ActiveSlotCoefficient -> Quantity "block" Word32 -> SlottingParameters

-- | Length, in seconds, of a slot.
[$sel:getSlotLength:SlottingParameters] :: SlottingParameters -> SlotLength

-- | Number of slots in a single epoch.
[$sel:getEpochLength:SlottingParameters] :: SlottingParameters -> EpochLength

-- | a.k.a <tt>f</tt>, in Genesis/Praos, corresponds to the % of active
--   slots (i.e. slots for which someone can be elected as leader).
--   
--   Determines the value of <a>stabilityWindowShelley</a>.
[$sel:getActiveSlotCoefficient:SlottingParameters] :: SlottingParameters -> ActiveSlotCoefficient

-- | a.k.a <tt>k</tt>, used to compute the 'stability window' on the chain
--   (i.e. the longest possible chain fork in slots).
--   
--   Determines the value of <a>stabilityWindowByron</a> and
--   <a>stabilityWindowShelley</a>.
[$sel:getSecurityParameter:SlottingParameters] :: SlottingParameters -> Quantity "block" Word32

-- | Protocol parameters that can be changed through the update system.
data ProtocolParameters
ProtocolParameters :: DecentralizationLevel -> TxParameters -> Word16 -> MinimumUTxO -> Coin -> EraInfo EpochNo -> Word16 -> Natural -> Maybe ExecutionUnitPrices -> Maybe ProtocolParameters -> ProtocolParameters

-- | The current level of decentralization in the network.
[$sel:decentralizationLevel:ProtocolParameters] :: ProtocolParameters -> DecentralizationLevel

-- | Parameters that affect transaction construction.
[$sel:txParameters:ProtocolParameters] :: ProtocolParameters -> TxParameters

-- | The current desired number of stakepools in the network. Also known as
--   k parameter.
[$sel:desiredNumberOfStakePools:ProtocolParameters] :: ProtocolParameters -> Word16

-- | Represents a way of calculating minimum UTxO values.
[$sel:minimumUTxO:ProtocolParameters] :: ProtocolParameters -> MinimumUTxO

-- | Registering a stake key requires storage on the node and as such needs
--   a deposit. There may be more actions that require deposit (such as
--   registering a stake pool).
[$sel:stakeKeyDeposit:ProtocolParameters] :: ProtocolParameters -> Coin

-- | Contains information about when each era did start if it has already
--   happened, or otherwise when it will start, if the hard-fork time is
--   confirmed on-chain.
--   
--   Note: this is not a practical way to tell the current era.
[$sel:eras:ProtocolParameters] :: ProtocolParameters -> EraInfo EpochNo

-- | Limit on the maximum number of collateral inputs present in a
--   transaction.
[$sel:maximumCollateralInputCount:ProtocolParameters] :: ProtocolParameters -> Word16

-- | Specifies the minimum required amount of collateral as a percentage of
--   the total transaction fee.
[$sel:minimumCollateralPercentage:ProtocolParameters] :: ProtocolParameters -> Natural

-- | The prices for <a>ExecutionUnits</a> as a fraction of a
--   <tt>Lovelace</tt> and used to determine the fee for the use of a
--   script within a transaction, based on the <a>ExecutionUnits</a> needed
--   by the use of the script.
[$sel:executionUnitPrices:ProtocolParameters] :: ProtocolParameters -> Maybe ExecutionUnitPrices

-- | Get the last known node's protocol parameters. In principle, these can
--   only change once per epoch.
[$sel:currentNodeProtocolParameters:ProtocolParameters] :: ProtocolParameters -> Maybe ProtocolParameters

-- | Parameters that relate to the construction of <b>transactions</b>.
data TxParameters
TxParameters :: FeePolicy -> Quantity "byte" Word16 -> TokenBundleMaxSize -> ExecutionUnits -> TxParameters

-- | Formula for calculating the transaction fee.
[$sel:getFeePolicy:TxParameters] :: TxParameters -> FeePolicy

-- | Maximum size of a transaction (soft or hard limit).
[$sel:getTxMaxSize:TxParameters] :: TxParameters -> Quantity "byte" Word16

-- | Maximum size of a serialized <tt>TokenBundle</tt> (_maxValSize in the
--   Alonzo ledger)
[$sel:getTokenBundleMaxSize:TxParameters] :: TxParameters -> TokenBundleMaxSize

-- | Max total script execution resources units allowed per tx
[$sel:getMaxExecutionUnits:TxParameters] :: TxParameters -> ExecutionUnits

-- | The maximum size of a serialized <tt>TokenBundle</tt>
--   (<tt>_maxValSize</tt> in the Alonzo ledger)
newtype TokenBundleMaxSize
TokenBundleMaxSize :: TxSize -> TokenBundleMaxSize
[$sel:unTokenBundleMaxSize:TokenBundleMaxSize] :: TokenBundleMaxSize -> TxSize

-- | Represents <tt>info</tt> about the starting epoch/time of all possible
--   eras.
--   
--   Field values can be either: - Just pastEpochBoundary - the network
--   forked to this era in the past. - Just futureEpochBoundary - the
--   hard-fork to this era is confirmed, but it hasn't yet occured. -
--   Nothing - the hard-fork to this era is not yet confirmed.
--   
--   Note: this type is not a practical way to tell what the current era
--   is.
--   
--   It is expected that there is an order, <tt>byron, shelley, allegra,
--   mary</tt>, by which the <tt>Maybe</tt> fields are filled in.
--   
--   It might be cumbersome to work with this type. <i>But</i> we don't
--   need to. A product of <tt>Maybe</tt> is both what we can query from
--   the node, and what we need to provide in the wallet API.
data EraInfo info
EraInfo :: Maybe info -> Maybe info -> Maybe info -> Maybe info -> Maybe info -> Maybe info -> EraInfo info
[$sel:byron:EraInfo] :: EraInfo info -> Maybe info
[$sel:shelley:EraInfo] :: EraInfo info -> Maybe info
[$sel:allegra:EraInfo] :: EraInfo info -> Maybe info
[$sel:mary:EraInfo] :: EraInfo info -> Maybe info
[$sel:alonzo:EraInfo] :: EraInfo info -> Maybe info
[$sel:babbage:EraInfo] :: EraInfo info -> Maybe info
emptyEraInfo :: EraInfo info
newtype ActiveSlotCoefficient
ActiveSlotCoefficient :: Double -> ActiveSlotCoefficient
[$sel:unActiveSlotCoefficient:ActiveSlotCoefficient] :: ActiveSlotCoefficient -> Double

-- | Indicates the current level of decentralization in the network.
--   
--   According to the Design Specification for Delegation and Incentives in
--   Cardano, the decentralization parameter <b><i>d</i></b> is a value in
--   the range '[0, 1]', where:
--   
--   <ul>
--   <li><b><i>d</i></b> = '1' indicates that the network is <i>completely
--   federalized</i>.</li>
--   <li><b><i>d</i></b> = '0' indicates that the network is <i>completely
--   decentralized</i>.</li>
--   </ul>
--   
--   However, in Cardano Wallet, we represent the decentralization level as
--   a percentage, where:
--   
--   <ul>
--   <li>' 0 %' indicates that the network is <i>completely
--   federalized</i>.</li>
--   <li>'100 %' indicates that the network is <i>completely
--   decentralized</i>.</li>
--   </ul>
data DecentralizationLevel
($sel:getDecentralizationLevel:DecentralizationLevel) :: DecentralizationLevel -> Percentage
getFederationPercentage :: DecentralizationLevel -> Percentage
fromDecentralizationLevel :: Percentage -> DecentralizationLevel

-- | Percentage of federated nodes. Equal to the "decentralization
--   parameter" <i>d</i> from the ledger specification.
fromFederationPercentage :: Percentage -> DecentralizationLevel

-- | Number of slots in a single epoch
newtype EpochLength
EpochLength :: Word32 -> EpochLength
[$sel:unEpochLength:EpochLength] :: EpochLength -> Word32
newtype EpochNo
EpochNo :: Word31 -> EpochNo
[$sel:unEpochNo:EpochNo] :: EpochNo -> Word31

-- | Convert the specified value into an <a>EpochNo</a>, or fail if the
--   value is too large.
unsafeEpochNo :: HasCallStack => Word32 -> EpochNo
isValidEpochNo :: EpochNo -> Bool

-- | A linear equation of a free variable <tt>x</tt>. Represents the <tt>x
--   -&gt; a + b*x</tt> function where <tt>x</tt> can be either a
--   transaction size in bytes or a number of inputs + outputs.
newtype FeePolicy
LinearFee :: LinearFunction Double -> FeePolicy
data LinearFunction a
LinearFunction :: a -> a -> LinearFunction a
[$sel:intercept:LinearFunction] :: LinearFunction a -> a
[$sel:slope:LinearFunction] :: LinearFunction a -> a

-- | A slot identifier is the combination of an epoch and slot.
data SlotId
SlotId :: !EpochNo -> !SlotInEpoch -> SlotId
[$sel:epochNumber:SlotId] :: SlotId -> !EpochNo
[$sel:slotNumber:SlotId] :: SlotId -> !SlotInEpoch

-- | The 0-based index for the Ourboros time slot.
newtype SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64

-- | Duration of a single slot.
newtype SlotLength
SlotLength :: NominalDiffTime -> SlotLength
[$sel:unSlotLength:SlotLength] :: SlotLength -> NominalDiffTime
newtype SlotInEpoch
SlotInEpoch :: Word32 -> SlotInEpoch
[$sel:unSlotInEpoch:SlotInEpoch] :: SlotInEpoch -> Word32

-- | Blockchain start time
newtype StartTime
StartTime :: UTCTime -> StartTime

-- | In Byron, this stability window is equal to 2k slots, where _k_ is the
--   <a>$sel:getSecurityParameter:SlottingParameters</a>
stabilityWindowByron :: SlottingParameters -> Quantity "block" Word64

-- | In Shelley, this stability window is equal to _3k/f_ slots where _k_
--   is the <a>$sel:getSecurityParameter:SlottingParameters</a> and _f_ is
--   the <a>ActiveSlotCoefficient</a>.
stabilityWindowShelley :: SlottingParameters -> Quantity "block" Word64
data ExecutionUnits
ExecutionUnits :: Natural -> Natural -> ExecutionUnits

-- | This corresponds roughly to the time to execute a script.
[$sel:executionSteps:ExecutionUnits] :: ExecutionUnits -> Natural

-- | This corresponds roughly to the peak memory used during script
--   execution.
[$sel:executionMemory:ExecutionUnits] :: ExecutionUnits -> Natural
data ExecutionUnitPrices
ExecutionUnitPrices :: Rational -> Rational -> ExecutionUnitPrices
[$sel:pricePerStep:ExecutionUnitPrices] :: ExecutionUnitPrices -> Rational
[$sel:pricePerMemoryUnit:ExecutionUnitPrices] :: ExecutionUnitPrices -> Rational

-- | Additional information about a wallet that can't simply be derived
--   from the blockchain like <tt>Wallet s</tt> is.
--   
--   Whereas <tt>Wallet s</tt> in <a>Primitive</a> can be updated using
--   <tt>applyBlock</tt>, <tt>WalletMetadata</tt> can not*.
--   
--   <ul>
--   <li>) Except for possibly <a>$sel:status:WalletDelegationNext</a> and
--   <a>$sel:delegation:WalletMetadata</a>...</li>
--   </ul>
data WalletMetadata
WalletMetadata :: !WalletName -> !UTCTime -> !Maybe WalletPassphraseInfo -> !WalletDelegation -> WalletMetadata
[$sel:name:WalletMetadata] :: WalletMetadata -> !WalletName
[$sel:creationTime:WalletMetadata] :: WalletMetadata -> !UTCTime
[$sel:passphraseInfo:WalletMetadata] :: WalletMetadata -> !Maybe WalletPassphraseInfo
[$sel:delegation:WalletMetadata] :: WalletMetadata -> !WalletDelegation
newtype WalletId
WalletId :: Digest Blake2b_160 -> WalletId
[$sel:getWalletId:WalletId] :: WalletId -> Digest Blake2b_160

-- | Length-restricted name of a wallet
newtype WalletName
WalletName :: Text -> WalletName
[$sel:getWalletName:WalletName] :: WalletName -> Text

-- | Calling 'fromText @WalletName' on shorter string will fail.
walletNameMinLength :: Int

-- | Calling 'fromText @WalletName' on a longer string will fail.
walletNameMaxLength :: Int
data WalletDelegation
WalletDelegation :: !WalletDelegationStatus -> ![WalletDelegationNext] -> WalletDelegation
[$sel:active:WalletDelegation] :: WalletDelegation -> !WalletDelegationStatus
[$sel:next:WalletDelegation] :: WalletDelegation -> ![WalletDelegationNext]
data WalletDelegationStatus
NotDelegating :: WalletDelegationStatus
Delegating :: !PoolId -> WalletDelegationStatus
data WalletDelegationNext
WalletDelegationNext :: !EpochNo -> !WalletDelegationStatus -> WalletDelegationNext
[$sel:changesAt:WalletDelegationNext] :: WalletDelegationNext -> !EpochNo
[$sel:status:WalletDelegationNext] :: WalletDelegationNext -> !WalletDelegationStatus
class IsDelegatingTo a
isDelegatingTo :: IsDelegatingTo a => (PoolId -> Bool) -> a -> Bool
data StakePoolsSummary
StakePoolsSummary :: Int -> Map PoolId Coin -> Map PoolId Percentage -> StakePoolsSummary
[$sel:nOpt:StakePoolsSummary] :: StakePoolsSummary -> Int
[$sel:rewards:StakePoolsSummary] :: StakePoolsSummary -> Map PoolId Coin
[$sel:stake:StakePoolsSummary] :: StakePoolsSummary -> Map PoolId Percentage

-- | Identifies a stake pool. For JÃ¶rmungandr a <a>PoolId</a> is the
--   blake2b-256 hash of the stake pool registration certificate.
newtype PoolId
PoolId :: ByteString -> PoolId
[$sel:getPoolId:PoolId] :: PoolId -> ByteString

-- | A stake pool owner, which is a public key encoded in bech32 with
--   prefix ed25519_pk.
newtype PoolOwner
PoolOwner :: ByteString -> PoolOwner
[$sel:getPoolOwner:PoolOwner] :: PoolOwner -> ByteString
poolIdBytesLength :: [Int]

-- | Decode a Bech32 encoded <a>PoolId</a>.
decodePoolIdBech32 :: Text -> Either TextDecodingError PoolId

-- | Encode <a>PoolId</a> as Bech32 with "pool" hrp.
encodePoolIdBech32 :: PoolId -> Text

-- | Information about a stake pool.
--   
--   The metadata information is not used directly by cardano-wallet, but
--   rather passed straight through to API consumers.
data StakePoolMetadata
StakePoolMetadata :: StakePoolTicker -> Text -> Maybe Text -> Text -> StakePoolMetadata

-- | Very short human-readable ID for the stake pool.
[$sel:ticker:StakePoolMetadata] :: StakePoolMetadata -> StakePoolTicker

-- | Name of the stake pool.
[$sel:name:StakePoolMetadata] :: StakePoolMetadata -> Text

-- | Short description of the stake pool.
[$sel:description:StakePoolMetadata] :: StakePoolMetadata -> Maybe Text

-- | Absolute URL for the stake pool's homepage link.
[$sel:homepage:StakePoolMetadata] :: StakePoolMetadata -> Text

-- | A newtype to wrap metadata hash.
--   
--   NOTE: not using the <a>Hash</a> type as this newtype is primarily for
--   database interop which doesn't quite like DataKinds.
newtype StakePoolMetadataHash
StakePoolMetadataHash :: ByteString -> StakePoolMetadataHash

-- | A newtype to wrap metadata Url, mostly needed for database lookups and
--   signature clarity.
newtype StakePoolMetadataUrl
StakePoolMetadataUrl :: Text -> StakePoolMetadataUrl

-- | Very short name for a stake pool.
newtype StakePoolTicker
StakePoolTicker :: Text -> StakePoolTicker
[$sel:unStakePoolTicker:StakePoolTicker] :: StakePoolTicker -> Text
data StakeKeyCertificate
StakeKeyRegistration :: StakeKeyCertificate
StakeKeyDeregistration :: StakeKeyCertificate
data PoolMetadataGCStatus
NotApplicable :: PoolMetadataGCStatus
NotStarted :: PoolMetadataGCStatus
Restarting :: POSIXTime -> PoolMetadataGCStatus
HasRun :: POSIXTime -> PoolMetadataGCStatus

-- | Represents a sort order, applicable to the results returned by a
--   query.
data SortOrder

-- | Sort in ascending order.
Ascending :: SortOrder

-- | Sort in descending order.
Descending :: SortOrder

-- | Represents a range of values.
--   
--   A range is defined by two <i>optional</i> bounds:
--   
--   <ol>
--   <li>an <i>inclusive</i> lower bound</li>
--   <li>an <i>inclusive</i> upper bound</li>
--   </ol>
--   
--   There are four cases:
--   
--   TODO: table
data Range a
Range :: Maybe a -> Maybe a -> Range a
[$sel:inclusiveLowerBound:Range] :: Range a -> Maybe a
[$sel:inclusiveUpperBound:Range] :: Range a -> Maybe a

-- | Represents a range boundary.
data RangeBound a
NegativeInfinity :: RangeBound a
InclusiveBound :: a -> RangeBound a
PositiveInfinity :: RangeBound a

-- | The range that includes everything.
wholeRange :: Range a

-- | Returns <a>True</a> if (and only if) the given range has an upper
--   bound and the specified value is greater than the upper bound.
isAfterRange :: Ord a => a -> Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given range has a lower bound
--   and the specified value is smaller than the lower bound.
isBeforeRange :: Ord a => a -> Range a -> Bool

-- | Returns <a>True</a> if (and only if) the first given range is a
--   subrange of the second given range.
isSubrangeOf :: Ord a => Range a -> Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given value is not smaller
--   than the lower bound (if present) of the given range and is not
--   greater than the upper bound (if present) of the given range.
isWithinRange :: Ord a => a -> Range a -> Bool

-- | Apply a function to the lower bound of a range.
mapRangeLowerBound :: (a -> a) -> Range a -> Range a

-- | Apply a function to the upper bound of a range.
mapRangeUpperBound :: (a -> a) -> Range a -> Range a

-- | Returns <a>True</a> if (and only if) the given range has both a lower
--   and upper bound.
rangeIsFinite :: Range a -> Bool

-- | Returns <a>True</a> if (and only if) the range covers exactly one
--   value.
rangeIsSingleton :: Eq a => Range a -> Bool

-- | Returns <a>True</a> if (and only if) the lower bound of a range is not
--   greater than its upper bound.
rangeIsValid :: Ord a => Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given range has a lower
--   bound.
rangeHasLowerBound :: Range a -> Bool

-- | Returns <a>True</a> if (and only if) the given range has an upper
--   bound.
rangeHasUpperBound :: Range a -> Bool

-- | Get the lower bound of a <a>Range</a>.
rangeLowerBound :: Range a -> RangeBound a

-- | Get the upper bound of a <a>Range</a>.
rangeUpperBound :: Range a -> RangeBound a

-- | A newtype to wrap raw bytestring representing signed data, captured
--   with a phantom type.
newtype Signature (what :: Type)
Signature :: ByteString -> Signature (what :: Type)
[$sel:getSignature:Signature] :: Signature (what :: Type) -> ByteString

-- | Wallet application settings. These are stored at runtime and
--   potentially mutable.
data Settings
Settings :: PoolMetadataSource -> Settings
[$sel:poolMetadataSource:Settings] :: Settings -> PoolMetadataSource

-- | A SMASH server is either an absolute http or https url.
--   
--   Don't export SmashServer constructor, use <tt>fromText</tt> instance
--   instead.
data SmashServer
($sel:unSmashServer:SmashServer) :: SmashServer -> URI

-- | Source of Stake Pool Metadata aggregation.
data PoolMetadataSource
FetchNone :: PoolMetadataSource
FetchDirect :: PoolMetadataSource
FetchSMASH :: SmashServer -> PoolMetadataSource
defaultSettings :: Settings
unsafeToPMS :: URI -> PoolMetadataSource
newtype TokenMetadataServer
TokenMetadataServer :: URI -> TokenMetadataServer
[$sel:unTokenMetadataServer:TokenMetadataServer] :: TokenMetadataServer -> URI

-- | Various internal states of the pool DB that need to survive wallet
--   restarts. These aren't exposed settings.
data InternalState
InternalState :: Maybe POSIXTime -> InternalState
[$sel:lastMetadataGC:InternalState] :: InternalState -> Maybe POSIXTime
defaultInternalState :: InternalState
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletName
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.SortOrder
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Primitive.Types.Range a)
instance GHC.Base.Functor Cardano.Wallet.Primitive.Types.Range
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Range a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.Types.RangeBound a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.RangeBound a)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolMetadataGCStatus
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolMetadataGCStatus
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolMetadataGCStatus
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.StakePoolTicker
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.StakePoolTicker
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.StakePoolTicker
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.StakePoolTicker
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.StakePoolTicker
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.StakePoolMetadata
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.StakePoolMetadata
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.StakePoolMetadata
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.StakePoolMetadata
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.PoolOwner
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolOwner
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolOwner
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolOwner
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.StakePoolsSummary
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.StakePoolsSummary
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.BlockHeader
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.ChainPoint
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.ChainPoint
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.ChainPoint
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.ChainPoint
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.LinearFunction a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Primitive.Types.LinearFunction a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.LinearFunction a)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.FeePolicy
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.FeePolicy
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.FeePolicy
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.DerivationIndex
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.DerivationIndex
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.DerivationIndex
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.DerivationIndex
instance GHC.Real.Fractional Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Num.Num Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance GHC.Base.Functor Cardano.Wallet.Primitive.Types.EraInfo
instance GHC.Show.Show info => GHC.Show.Show (Cardano.Wallet.Primitive.Types.EraInfo info)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.EraInfo info)
instance GHC.Classes.Eq info => GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.EraInfo info)
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.ExecutionUnits
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.ExecutionUnits
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.ExecutionUnits
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.ExecutionUnitPrices
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.ExecutionUnitPrices
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.ExecutionUnitPrices
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.DecentralizationLevel
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.DecentralizationLevel
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.DecentralizationLevel
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.DecentralizationLevel
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenBundleMaxSize
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenBundleMaxSize
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenBundleMaxSize
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TxParameters
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TxParameters
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TxParameters
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.SlotInEpoch
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.SlotInEpoch
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.SlotInEpoch
instance GHC.Num.Num Cardano.Wallet.Primitive.Types.SlotInEpoch
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlotInEpoch
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.SlotInEpoch
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotInEpoch
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.SlotInEpoch
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotInEpoch
instance GHC.Enum.Enum Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Num.Num Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.EpochNo
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotId
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.ProtocolParameters
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.ProtocolParameters
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.ProtocolParameters
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletDelegation
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletDelegation
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletDelegation
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.WalletMetadata
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlotLength
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlotLength
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlotLength
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.EpochLength
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.EpochLength
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.EpochLength
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SlottingParameters
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SlottingParameters
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SlottingParameters
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.StartTime
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.GenesisParameters
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.GenesisParameters
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.GenesisParameters
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.NetworkParameters
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.NetworkParameters
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.NetworkParameters
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.DelegationCertificate
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.DelegationCertificate
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.DelegationCertificate
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.DelegationCertificate
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Block
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Block
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Block
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Block
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.StakeKeyCertificate
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.StakeKeyCertificate
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.StakeKeyCertificate
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.StakeKeyCertificate
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.PoolRetirementCertificate
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolRetirementCertificate
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolRetirementCertificate
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolRetirementCertificate
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.PoolCertificate
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolCertificate
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolCertificate
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolCertificate
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.NonWalletCertificate
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.NonWalletCertificate
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.NonWalletCertificate
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.NonWalletCertificate
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Certificate
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Certificate
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Certificate
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.CertificatePublicationTime
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.CertificatePublicationTime
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.CertificatePublicationTime
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.CertificatePublicationTime
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolLifeCycleStatus
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.PoolLifeCycleStatus
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolLifeCycleStatus
instance Data.ByteArray.Types.ByteArrayAccess (Cardano.Wallet.Primitive.Types.Signature what)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Types.Signature what)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Types.Signature what)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Types.Signature what)
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.TokenMetadataServer
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.TokenMetadataServer
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.TokenMetadataServer
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.SmashServer
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.SmashServer
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.SmashServer
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.PoolMetadataSource
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.PoolMetadataSource
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.PoolMetadataSource
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Settings
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Settings
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Settings
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.InternalState
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.InternalState
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.InternalState
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.PoolMetadataSource
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.PoolMetadataSource
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.PoolMetadataSource
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.PoolMetadataSource
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.SmashServer
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.SmashServer
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.TokenMetadataServer
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.TokenMetadataServer
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Certificate
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.NonWalletCertificate
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.NonWalletCertificate
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.NonWalletCertificate
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.PoolCertificate
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.PoolRetirementCertificate
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.PoolRetirementCertificate
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.PoolRegistrationCertificate
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.StakeKeyCertificate
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.Block
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Block
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.DelegationCertificate
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.NetworkParameters
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.NetworkParameters
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.GenesisParameters
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.GenesisParameters
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.StartTime
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.SlottingParameters
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.SlottingParameters
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.EpochLength
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.SlotLength
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletMetadata
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletMetadata
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletDelegation
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletDelegation
instance Cardano.Wallet.Primitive.Types.IsDelegatingTo Cardano.Wallet.Primitive.Types.WalletDelegation
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance Cardano.Wallet.Primitive.Types.IsDelegatingTo Cardano.Wallet.Primitive.Types.WalletDelegationNext
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.ProtocolParameters
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.ProtocolParameters
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.SlotId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.SlotId
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Types.EraInfo Cardano.Wallet.Primitive.Types.EpochNo)
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.EpochNo
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.EpochNo
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.EpochNo
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.EpochNo
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TxParameters
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.TxParameters
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.TokenBundleMaxSize
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Wallet.Primitive.Types.TokenBundleMaxSize
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.DecentralizationLevel
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.DecentralizationLevel
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.ExecutionUnitPrices
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.ExecutionUnitPrices
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.ExecutionUnitPrices
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.ExecutionUnitPrices
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.ExecutionUnits
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.ExecutionUnits
instance Control.DeepSeq.NFData info => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.EraInfo info)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.DerivationIndex
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.DerivationIndex
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.DerivationIndex
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.FeePolicy
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.FeePolicy
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.FeePolicy
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Types.LinearFunction a)
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.Slot
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.ChainPoint
instance NoThunks.Class.NoThunks Cardano.Wallet.Primitive.Types.ChainPoint
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.ChainPoint
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.BlockHeader
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.BlockHeader
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.StakePoolsSummary
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.PoolOwner
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.PoolOwner
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.PoolOwner
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.PoolOwner
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.PoolOwner
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.PoolOwner
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance Cardano.Wallet.Primitive.Types.IsDelegatingTo Cardano.Wallet.Primitive.Types.WalletDelegationStatus
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.PoolId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.PoolId
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.PoolId
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.PoolId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.StakePoolMetadata
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.StakePoolTicker
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.StakePoolTicker
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.StakePoolTicker
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.SortOrder
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.SortOrder
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletId
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.WalletId
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.WalletId
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Types.WalletName
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.Types.WalletName
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Types.WalletName
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Types.WalletName


-- | A client used to query asset metadata from the Cardano
--   metadata-server.
--   
--   The OpenAPI specification is here:
--   <a>https://github.com/input-output-hk/metadata-server/blob/master/specifications/api/openapi.yaml</a>
--   
--   An important consideration is that cardano-wallet should not trust the
--   metadata-server operator to produce correct, valid, authentic, or even
--   non-malicious data.
--   
--   In future, signatures of property values will be checked to determine
--   authenticity. The exact details are not yet specified.
--   
--   In any case, we should not rely on the validation that the
--   metadata-server may or may not have applied to the user-supplied
--   metadata.
module Cardano.Wallet.TokenMetadata

-- | Helper for adding metadata to sets of assets.
fillMetadata :: (Foldable t, Functor t) => TokenMetadataClient IO -> t AssetId -> (Either TokenMetadataError (Maybe AssetMetadata) -> AssetId -> a) -> IO (t a)

-- | Represents a client for the metadata server.
data TokenMetadataClient m

-- | Construct a <a>TokenMetadataClient</a> for use with
--   <a>getTokenMetadata</a>.
newMetadataClient :: Tracer IO TokenMetadataLog -> Maybe TokenMetadataServer -> IO (TokenMetadataClient IO)

-- | Fetches metadata for a list of assets using the given client.
getTokenMetadata :: TokenMetadataClient IO -> [AssetId] -> IO (Either TokenMetadataError [(AssetId, AssetMetadata)])

-- | The possible errors which can occur when fetching metadata.
data TokenMetadataError

-- | Unhandled exception
TokenMetadataClientError :: LoggedException SomeException -> TokenMetadataError

-- | Error with HTTP request
TokenMetadataFetchError :: LoggedException HttpException -> TokenMetadataError

-- | Error from aeson decoding of JSON
TokenMetadataJSONParseError :: ByteString -> String -> TokenMetadataError
data TokenMetadataLog
MsgNotConfigured :: TokenMetadataLog
MsgFetchRequest :: BatchRequest -> BracketLog -> TokenMetadataLog
MsgFetchRequestBody :: URI -> ByteString -> TokenMetadataLog
MsgFetchMetadataMaxSize :: Int -> TokenMetadataLog
MsgFetchResult :: BatchRequest -> Either TokenMetadataError BatchResponse -> TokenMetadataLog
MsgFetchMetadataTime :: BatchRequest -> DiffTime -> TokenMetadataLog
metadataClient :: Tracer IO TokenMetadataLog -> TokenMetadataServer -> Manager -> BatchRequest -> IO (Either TokenMetadataError BatchResponse)

-- | Models a request to the <tt>POST <i>metadata</i>query</tt> endpoint of
--   the metadata server -- the only one that we need.
data BatchRequest
BatchRequest :: [Subject] -> [PropertyName] -> BatchRequest
[$sel:subjects:BatchRequest] :: BatchRequest -> [Subject]
[$sel:properties:BatchRequest] :: BatchRequest -> [PropertyName]

-- | Models the response from the <tt>POST <i>metadata</i>query</tt>
--   endpoint of the metadata server. This should contain properties each
--   subject in the <a>BatchRequest</a>.
newtype BatchResponse
BatchResponse :: [SubjectProperties] -> BatchResponse
[$sel:getBatchResponse:BatchResponse] :: BatchResponse -> [SubjectProperties]

-- | Property values and signatures for a given subject.
data SubjectProperties
SubjectProperties :: Subject -> Maybe Signature -> (Maybe (Property "name"), Maybe (Property "description"), Maybe (Property "ticker"), Maybe (Property "url"), Maybe (Property "logo"), Maybe (Property "decimals")) -> SubjectProperties
[$sel:subject:SubjectProperties] :: SubjectProperties -> Subject
[$sel:owner:SubjectProperties] :: SubjectProperties -> Maybe Signature
[$sel:properties:SubjectProperties] :: SubjectProperties -> (Maybe (Property "name"), Maybe (Property "description"), Maybe (Property "ticker"), Maybe (Property "url"), Maybe (Property "logo"), Maybe (Property "decimals"))

-- | A property value and its signatures.
data Property name
Property :: Either (String, Value) (PropertyValue name) -> [Signature] -> Int -> Property name

-- | The result of JSON parsing and validating the property value.
[$sel:value:Property] :: Property name -> Either (String, Value) (PropertyValue name)

-- | Zero or more signatures of the property value.
[$sel:signatures:Property] :: Property name -> [Signature]

-- | Counter to prevent replaying old signatures.
[$sel:sequenceNumber:Property] :: Property name -> Int

-- | Metadata property identifier.
newtype PropertyName
PropertyName :: Text -> PropertyName
[$sel:unPropertyName:PropertyName] :: PropertyName -> Text
propertyName :: forall name. KnownSymbol name => Property name -> PropertyName

-- | The type of a given property name.
type family PropertyValue (name :: Symbol) :: Type

-- | A metadata server subject, which can be any string.
newtype Subject
Subject :: Text -> Subject
[$sel:unSubject:Subject] :: Subject -> Text

-- | Will be used in future for checking integrity and authenticity of
--   metadata.
data Signature
Signature :: ByteString -> ByteString -> Signature
[$sel:signature:Signature] :: Signature -> ByteString
[$sel:publicKey:Signature] :: Signature -> ByteString

-- | Convert metadata server properties response into an
--   <a>AssetMetadata</a> record. Only the values are taken. Signatures are
--   ignored (for now).
metadataFromProperties :: SubjectProperties -> Maybe AssetMetadata
instance Data.Hashable.Class.Hashable Cardano.Wallet.TokenMetadata.Subject
instance Data.String.IsString Cardano.Wallet.TokenMetadata.Subject
instance GHC.Classes.Ord Cardano.Wallet.TokenMetadata.Subject
instance GHC.Classes.Eq Cardano.Wallet.TokenMetadata.Subject
instance GHC.Show.Show Cardano.Wallet.TokenMetadata.Subject
instance GHC.Generics.Generic Cardano.Wallet.TokenMetadata.Subject
instance Data.Hashable.Class.Hashable Cardano.Wallet.TokenMetadata.PropertyName
instance Data.String.IsString Cardano.Wallet.TokenMetadata.PropertyName
instance GHC.Classes.Eq Cardano.Wallet.TokenMetadata.PropertyName
instance GHC.Show.Show Cardano.Wallet.TokenMetadata.PropertyName
instance GHC.Generics.Generic Cardano.Wallet.TokenMetadata.PropertyName
instance GHC.Classes.Eq Cardano.Wallet.TokenMetadata.BatchRequest
instance GHC.Show.Show Cardano.Wallet.TokenMetadata.BatchRequest
instance GHC.Generics.Generic Cardano.Wallet.TokenMetadata.BatchRequest
instance GHC.Classes.Eq Cardano.Wallet.TokenMetadata.Signature
instance GHC.Show.Show Cardano.Wallet.TokenMetadata.Signature
instance GHC.Generics.Generic Cardano.Wallet.TokenMetadata.Signature
instance GHC.Generics.Generic (Cardano.Wallet.TokenMetadata.Property name)
instance GHC.Classes.Eq Cardano.Wallet.TokenMetadata.SubjectProperties
instance GHC.Show.Show Cardano.Wallet.TokenMetadata.SubjectProperties
instance GHC.Generics.Generic Cardano.Wallet.TokenMetadata.SubjectProperties
instance GHC.Classes.Eq Cardano.Wallet.TokenMetadata.BatchResponse
instance GHC.Show.Show Cardano.Wallet.TokenMetadata.BatchResponse
instance GHC.Generics.Generic Cardano.Wallet.TokenMetadata.BatchResponse
instance GHC.Classes.Eq Cardano.Wallet.TokenMetadata.TokenMetadataError
instance GHC.Show.Show Cardano.Wallet.TokenMetadata.TokenMetadataError
instance GHC.Generics.Generic Cardano.Wallet.TokenMetadata.TokenMetadataError
instance GHC.Classes.Eq Cardano.Wallet.TokenMetadata.TokenMetadataLog
instance GHC.Show.Show Cardano.Wallet.TokenMetadata.TokenMetadataLog
instance GHC.Classes.Eq (Cardano.Wallet.TokenMetadata.Encoded base)
instance GHC.Show.Show (Cardano.Wallet.TokenMetadata.Encoded base)
instance GHC.Generics.Generic (Cardano.Wallet.TokenMetadata.Encoded base)
instance GHC.Show.Show (Cardano.Wallet.TokenMetadata.PropertyValue name) => GHC.Show.Show (Cardano.Wallet.TokenMetadata.Property name)
instance GHC.Classes.Eq (Cardano.Wallet.TokenMetadata.PropertyValue name) => GHC.Classes.Eq (Cardano.Wallet.TokenMetadata.Property name)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.TokenMetadata.Encoded 'Data.ByteArray.Encoding.Base16)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.TokenMetadata.Encoded 'Data.ByteArray.Encoding.Base64)
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.TokenMetadata.TokenMetadataLog
instance Data.Text.Class.ToText Cardano.Wallet.TokenMetadata.TokenMetadataLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.TokenMetadata.TokenMetadataLog
instance Control.DeepSeq.NFData Cardano.Wallet.TokenMetadata.TokenMetadataError
instance Data.Text.Class.ToText Cardano.Wallet.TokenMetadata.TokenMetadataError
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.TokenMetadata.BatchResponse
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.TokenMetadata.SubjectProperties
instance (Cardano.Wallet.TokenMetadata.HasValidator name, Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.TokenMetadata.PropertyValue name)) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.TokenMetadata.Property name)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.TokenMetadata.Signature
instance Cardano.Wallet.TokenMetadata.HasValidator "name"
instance Cardano.Wallet.TokenMetadata.HasValidator "description"
instance Cardano.Wallet.TokenMetadata.HasValidator "ticker"
instance Cardano.Wallet.TokenMetadata.HasValidator "url"
instance Cardano.Wallet.TokenMetadata.HasValidator "logo"
instance Cardano.Wallet.TokenMetadata.HasValidator "decimals"
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.TokenMetadata.BatchRequest
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.TokenMetadata.PropertyName
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.TokenMetadata.PropertyName
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.TokenMetadata.Subject
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.TokenMetadata.Subject
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.TokenPolicy.AssetLogo
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals


-- | Contains tools for converting between <tt>SlotNo</tt>,
--   <tt>EpochNo</tt>, <tt>SlotInEpoch</tt>, <tt>UTCTime</tt>.
module Cardano.Wallet.Primitive.Slotting

-- | A query for time, slot and epoch conversions. Can be interpreted using
--   <tt>interpretQuery</tt>.
--   
--   <h2>Differences to the underlying consensus <a>Qry</a></h2>
--   
--   <tt>HF.Qry</tt> can only be interpreted in a single era. If you have
--   
--   <pre>
--   q1 = epochOf someSlotInByron
--   q2 = epochOf someSlotInShelley
--   </pre>
--   
--   <tt>HF.interpretQuery</tt> could interpret both individually, but
--   
--   <pre>
--   q3 = q1 &gt;&gt; q2
--   </pre>
--   
--   would fail.
--   
--   This wrapper exists to fix this.
--   
--   We also provide <tt>QStartTime</tt>.
data Qry :: Type -> Type

-- | Note: This fails when the node is far enough behind that we in the
--   present are beyond its safe zone.
currentEpoch :: MonadIO m => TimeInterpreter m -> m EpochNo

-- | Query the epoch corresponding to a flat slot number.
epochOf :: SlotNo -> Qry EpochNo

-- | Query the absolute time at which a slot starts.
slotToUTCTime :: SlotNo -> Qry UTCTime

-- | Query the relative time at which a slot starts.
slotToRelTime :: SlotNo -> Qry RelativeTime

-- | Query to convert a flat <a>SlotNo</a> to a <a>SlotId</a>, which is the
--   epoch number, and the local slot index.
toSlotId :: SlotNo -> Qry SlotId

-- | Transforms the given inclusive time range into an inclusive slot
--   range.
slotRangeFromRelativeTimeRange :: Range RelativeTime -> Qry (Range SlotNo)
slotRangeFromTimeRange :: Range UTCTime -> Qry (Maybe (Range SlotNo))

-- | Translate <a>EpochNo</a> to the <a>SlotNo</a> of the first slot in
--   that epoch
firstSlotInEpoch :: EpochNo -> Qry SlotNo
ongoingSlotAt :: RelativeTime -> Qry SlotNo
ceilingSlotAt :: RelativeTime -> Qry SlotNo

-- | Query the absolute times at which an epoch starts and ends.
--   
--   Querying the end time of <i>this</i> epoch is preferable to querying
--   the start time of the <i>next</i> epoch, because the next epoch may be
--   outside the forecast range, and result in <a>PastHorizonException</a>.
timeOfEpoch :: EpochNo -> Qry (UTCTime, UTCTime)

-- | Query the blockchain start time. This is part of the
--   <a>TimeInterpreter</a> environment.
getStartTime :: Qry StartTime

-- | <a>RelativeTime</a> is time relative to the <a>SystemStart</a>
data RelativeTime

-- | Same as <a>toRelativeTime</a>, but has error handling for times before
--   the system start. No other functions in this module will accept UTC
--   times.
toRelativeTime :: StartTime -> UTCTime -> Maybe RelativeTime

-- | This function returns a chain-relative time range if (and only if) the
--   specified UTC time range intersects with the life of the blockchain.
--   
--   If, on the other hand, the specified time range terminates before the
--   start of the blockchain, this function returns <a>Nothing</a>.
toRelativeTimeRange :: Range UTCTime -> StartTime -> Maybe (Range RelativeTime)

-- | Query the absolute time corresponding to a blockchain-relative time.
fromRelativeTime :: RelativeTime -> Qry UTCTime
addRelTime :: NominalDiffTime -> RelativeTime -> RelativeTime

-- | System start
--   
--   Slots are counted from the system start.
data SystemStart
getSystemStart :: TimeInterpreter m -> SystemStart

-- | The current system time, compared to the blockchain start time of the
--   given <a>TimeInterpreter</a>.
--   
--   If the current time is before the system start (this would only happen
--   when launching testnets), the relative time is reported as 0.
currentRelativeTime :: MonadIO m => TimeInterpreter n -> m RelativeTime

-- | The current system time, compared to the given blockchain start time.
--   
--   If the current time is before the system start (this would only happen
--   when launching testnets), let's just say we're in epoch 0.
--   
--   TODO: Use io-sim-classes for easier testing.
getCurrentTimeRelativeFromStart :: StartTime -> IO RelativeTime

-- | A <tt>TimeInterpreter</tt> is a way for the wallet to run things of
--   type <tt>Qry a</tt>, with a system start time as context.
data TimeInterpreter m

-- | An <a>Interpreter</a> for a single era, where the
--   <tt>SlottingParameters</tt> cannot change.
--   
--   Queries will never fail with <tt>mkSingleEraInterpreter</tt>.
mkSingleEraInterpreter :: HasCallStack => StartTime -> SlottingParameters -> TimeInterpreter Identity

-- | Set up a <a>TimeInterpreter</a> for a given start time, and an
--   <a>Interpreter</a> queried from the ledger layer.
mkTimeInterpreter :: Monad m => Tracer m TimeInterpreterLog -> StartTime -> m (Interpreter eras) -> TimeInterpreter (ExceptT PastHorizonException m)

-- | We tried to convert something that is past the horizon
--   
--   That is, we tried to convert something that is past the point in time
--   beyond which we lack information due to uncertainty about the next
--   hard fork.
data PastHorizonException
PastHorizon :: CallStack -> Some ClosedExpr -> [EraSummary] -> PastHorizonException

-- | Callstack to the call to <a>runQuery</a>
[pastHorizonCallStack] :: PastHorizonException -> CallStack

-- | The <a>Expr</a> we tried to evaluate
[pastHorizonExpression] :: PastHorizonException -> Some ClosedExpr

-- | The <a>EraSummary</a>s that we tried to evaluate the <a>Expr</a>
--   against
[pastHorizonSummary] :: PastHorizonException -> [EraSummary]

-- | Run a query.
interpretQuery :: HasCallStack => Monad m => TimeInterpreter m -> Qry a -> m a
data TimeInterpreterLog
MsgInterpreterPastHorizon :: Maybe String -> StartTime -> PastHorizonException -> TimeInterpreterLog

-- | Information about epochs
--   
--   Different epochs may have different sizes and different slot lengths.
--   This information is encapsulated by <a>EpochInfo</a>. It is
--   parameterized over a monad <tt>m</tt> because the information about
--   how long each epoch is may depend on information derived from the
--   blockchain itself. It ultimately requires acess to state, and so
--   either uses the monad for that or uses the monad to reify failure due
--   to cached state information being too stale for the current query.
data EpochInfo (m :: Type -> Type)
toEpochInfo :: forall m. Applicative m => TimeInterpreter m -> m (EpochInfo (ExceptT PastHorizonException Identity))

-- | Extend the safe zone to make the TimeInterpreter return predictions
--   where it otherwise would have failed with
--   <tt>PastHorizonException</tt>. This should be used with great caution,
--   and if we can get away from it, that would also be great. Also
--   ADP-575.
--   
--   From the underlying ouroboros-consensus function:
--   
--   UNSAFE: extend the safe zone of the current era of the given
--   <a>Interpreter</a> to be <i>unbounded</i>, ignoring any future hard
--   forks.
--   
--   This only has effect when the <a>Interpreter</a> was obtained in an
--   era that was <i>not the final one</i> (in the final era, this is a
--   no-op). The <a>Interpreter</a> will be made to believe that the
--   current era is the final era, making its horizon unbounded, and thus
--   never returning a <a>PastHorizonException</a>.
--   
--   Use of this function is <i>strongly discouraged</i>, as it will ignore
--   any future hard forks, and the results produced by the
--   <a>Interpreter</a> can thus be incorrect.
unsafeExtendSafeZone :: TimeInterpreter (ExceptT PastHorizonException IO) -> TimeInterpreter IO

-- | Takes a motivation of why <tt>TimeInterpreter</tt> shouldn't fail
--   interpreting queries.
--   
--   Unexpected <tt>PastHorizonException</tt>s will be thrown in IO, and
--   traced with Error severity along with the provided motivation.
neverFails :: String -> TimeInterpreter (ExceptT PastHorizonException IO) -> TimeInterpreter IO

-- | Pre-fetches a snapshot of the epoch history from the node, such that
--   the resulting <a>TimeInterpreter</a> doesn't require <a>IO</a>.
--   
--   Please consider <i>not</i> using this function, as it disables all
--   logging.
snapshot :: TimeInterpreter (ExceptT PastHorizonException IO) -> IO (TimeInterpreter (Either PastHorizonException))

-- | Change the underlying monad of the TimeInterpreter with a natural
--   transformation.
hoistTimeInterpreter :: (forall a. m a -> n a) -> TimeInterpreter m -> TimeInterpreter n

-- | Makes <tt>PastHorizonException</tt> be thrown in <tt>IO</tt>.
--   
--   Will <i>not</i> cause <tt>PastHorizonException</tt> to be tracer with
--   Error severity, unlike <tt>neverFails</tt>.
expectAndThrowFailures :: TimeInterpreter (ExceptT PastHorizonException IO) -> TimeInterpreter IO
instance GHC.Show.Show Cardano.Wallet.Primitive.Slotting.TimeInterpreterLog
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Slotting.TimeInterpreterLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.Primitive.Slotting.TimeInterpreterLog
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.Slotting.TimeInterpreterLog
instance GHC.Base.Functor Cardano.Wallet.Primitive.Slotting.Qry
instance GHC.Base.Applicative Cardano.Wallet.Primitive.Slotting.Qry
instance GHC.Base.Monad Cardano.Wallet.Primitive.Slotting.Qry


-- | An extra interface for operation on transactions (e.g. creating
--   witnesses, estimating size...). This makes it possible to decouple
--   those operations from our wallet layer, keeping the implementation
--   flexible to various backends.
module Cardano.Wallet.Transaction
data TransactionLayer k tx
TransactionLayer :: (AnyCardanoEra -> (XPrv, Passphrase "encryption") -> (Address -> Maybe (k 'AddressK XPrv, Passphrase "encryption")) -> ProtocolParameters -> TransactionCtx -> SelectionOf TxOut -> Either ErrMkTransaction (Tx, tx)) -> (AnyCardanoEra -> (XPrv, Passphrase "encryption") -> (KeyHash, XPrv, Passphrase "encryption") -> (Address -> Maybe (k 'AddressK XPrv, Passphrase "encryption")) -> (TxIn -> Maybe Address) -> tx -> tx) -> (AnyCardanoEra -> XPub -> ProtocolParameters -> TransactionCtx -> SelectionOf TxOut -> Either ErrMkTransaction tx) -> (AnyCardanoEra -> ProtocolParameters -> TransactionCtx -> SelectionSkeleton -> Coin) -> (ProtocolParameters -> [Redeemer] -> Coin) -> (forall era. IsShelleyBasedEra era => ProtocolParameters -> Tx era -> Coin) -> (forall era. IsShelleyBasedEra era => ProtocolParameters -> Tx era -> TxSize) -> (forall era. IsShelleyBasedEra era => Tx era -> ProtocolParameters -> UTxO -> [(TxIn, TxOut, Maybe (Hash "Datum"))] -> Value) -> (FeePolicy -> Coin -> TxFeeAndChange [TxOut] -> Either ErrMoreSurplusNeeded (TxFeeAndChange [TxOut])) -> (AnyCardanoEra -> ProtocolParameters -> TransactionCtx -> [TxOut] -> SelectionLimit) -> (TokenBundleMaxSize -> TokenBundleSizeAssessor) -> (AnyCardanoEra -> ProtocolParameters -> TxConstraints) -> (AnyCardanoEra -> tx -> (Tx, TokenMapWithScripts, TokenMapWithScripts, [Certificate], Maybe ValidityIntervalExplicit)) -> (forall era. IsShelleyBasedEra era => Tx era -> TxUpdate -> Either ErrUpdateSealedTx (Tx era)) -> (forall era. IsShelleyBasedEra era => ProtocolParameters -> TimeInterpreter (Either PastHorizonException) -> (TxIn -> Maybe (TxOut, Maybe (Hash "Datum"))) -> [Redeemer] -> Tx era -> Either ErrAssignRedeemers (Tx era)) -> TransactionLayer k tx

-- | Construct a standard transaction
--   
--   " Standard " here refers to the fact that we do not deal with
--   redemption, multisignature transactions, etc.
--   
--   This expects as a first argument a mean to compute or lookup private
--   key corresponding to a particular address.
[$sel:mkTransaction:TransactionLayer] :: TransactionLayer k tx -> AnyCardanoEra -> (XPrv, Passphrase "encryption") -> (Address -> Maybe (k 'AddressK XPrv, Passphrase "encryption")) -> ProtocolParameters -> TransactionCtx -> SelectionOf TxOut -> Either ErrMkTransaction (Tx, tx)

-- | Add Vk witnesses to a transaction for known inputs.
--   
--   If inputs can't be resolved, they are simply skipped, hence why this
--   function cannot fail.
[$sel:addVkWitnesses:TransactionLayer] :: TransactionLayer k tx -> AnyCardanoEra -> (XPrv, Passphrase "encryption") -> (KeyHash, XPrv, Passphrase "encryption") -> (Address -> Maybe (k 'AddressK XPrv, Passphrase "encryption")) -> (TxIn -> Maybe Address) -> tx -> tx

-- | Construct a standard unsigned transaction
--   
--   " Standard " here refers to the fact that we do not deal with
--   redemption, multisignature transactions, etc.
--   
--   The function returns CBOR-ed transaction body to be signed in another
--   step.
[$sel:mkUnsignedTransaction:TransactionLayer] :: TransactionLayer k tx -> AnyCardanoEra -> XPub -> ProtocolParameters -> TransactionCtx -> SelectionOf TxOut -> Either ErrMkTransaction tx

-- | Compute a minimal fee amount necessary to pay for a given selection
--   This also includes necessary deposits.
[$sel:calcMinimumCost:TransactionLayer] :: TransactionLayer k tx -> AnyCardanoEra -> ProtocolParameters -> TransactionCtx -> SelectionSkeleton -> Coin

-- | Compute the maximum execution cost of scripts in a given transaction.
[$sel:maxScriptExecutionCost:TransactionLayer] :: TransactionLayer k tx -> ProtocolParameters -> [Redeemer] -> Coin

-- | Evaluate a minimal fee amount necessary to pay for a given tx using
--   ledger's functionality
--   
--   Will estimate how many witnesses there <i>should be</i>, so it works
--   even for unsigned transactions.
[$sel:evaluateMinimumFee:TransactionLayer] :: TransactionLayer k tx -> forall era. IsShelleyBasedEra era => ProtocolParameters -> Tx era -> Coin

-- | Estimate the size of the transaction when fully signed.
[$sel:estimateSignedTxSize:TransactionLayer] :: TransactionLayer k tx -> forall era. IsShelleyBasedEra era => ProtocolParameters -> Tx era -> TxSize

-- | Evaluate the balance of a transaction using the ledger. The balance is
--   defined as <tt>(value consumed by transaction) - (value produced by
--   transaction)</tt>. For a transaction to be valid, it must have a
--   balance of zero.
--   
--   Note that the fee-field of the transaction affects the balance, and is
--   not automatically the minimum fee.
--   
--   The function takes two UTxOs of different types and merges them. The
--   reason is to workaround a combination of: 1. The wallet <a>UTxO</a>
--   type doesn't support Datum hashes 2. A 'UTxO -&gt; Cardano.UTxO'
--   conversion function is not available in the cardano-wallet-core
--   package, only cardano-wallet. (This package boundary will soon
--   hopefully go away, however)
[$sel:evaluateTransactionBalance:TransactionLayer] :: TransactionLayer k tx -> forall era. IsShelleyBasedEra era => Tx era -> ProtocolParameters -> UTxO -> [(TxIn, TxOut, Maybe (Hash "Datum"))] -> Value

-- | Distributes a surplus transaction balance between the given change
--   outputs and the given fee. This function is aware of the fact that any
--   increase in a <a>Coin</a> value could increase the size and fee
--   requirement of a transaction.
--   
--   When comparing the original fee and change outputs to the adjusted fee
--   and change outputs, this function guarantees that:
--   
--   <ul>
--   <li>The number of the change outputs remains constant;</li>
--   <li>The fee quantity either remains the same or increases.</li>
--   <li>For each change output:</li>
--   <li>the ada quantity either remains constant or increases.</li>
--   <li>non-ada quantities remain the same.</li>
--   <li>The surplus is conserved: The total increase in the fee and change
--   ada quantities is exactly equal to the surplus.</li>
--   <li>Any increase in cost is covered: If the total cost has increased
--   by ð›¿c, then the fee value will have increased by at least ð›¿c.</li>
--   </ul>
--   
--   If the cost of distributing the provided surplus is greater than the
--   surplus itself, the function will return <a>ErrMoreSurplusNeeded</a>.
--   If the provided surplus is greater or equal to
--   <tt>maximumCostOfIncreasingCoin feePolicy</tt>, the function will
--   always return <a>Right</a>.
[$sel:distributeSurplus:TransactionLayer] :: TransactionLayer k tx -> FeePolicy -> Coin -> TxFeeAndChange [TxOut] -> Either ErrMoreSurplusNeeded (TxFeeAndChange [TxOut])
[$sel:computeSelectionLimit:TransactionLayer] :: TransactionLayer k tx -> AnyCardanoEra -> ProtocolParameters -> TransactionCtx -> [TxOut] -> SelectionLimit

-- | A function to assess the size of a token bundle.
[$sel:tokenBundleSizeAssessor:TransactionLayer] :: TransactionLayer k tx -> TokenBundleMaxSize -> TokenBundleSizeAssessor
[$sel:constraints:TransactionLayer] :: TransactionLayer k tx -> AnyCardanoEra -> ProtocolParameters -> TxConstraints

-- | Decode an externally-created transaction.
[$sel:decodeTx:TransactionLayer] :: TransactionLayer k tx -> AnyCardanoEra -> tx -> (Tx, TokenMapWithScripts, TokenMapWithScripts, [Certificate], Maybe ValidityIntervalExplicit)

-- | Update tx by adding additional inputs and outputs
[$sel:updateTx:TransactionLayer] :: TransactionLayer k tx -> forall era. IsShelleyBasedEra era => Tx era -> TxUpdate -> Either ErrUpdateSealedTx (Tx era)
[$sel:assignScriptRedeemers:TransactionLayer] :: TransactionLayer k tx -> forall era. IsShelleyBasedEra era => ProtocolParameters -> TimeInterpreter (Either PastHorizonException) -> (TxIn -> Maybe (TxOut, Maybe (Hash "Datum"))) -> [Redeemer] -> Tx era -> Either ErrAssignRedeemers (Tx era)

-- | Whether the user is attempting any particular delegation action.
data DelegationAction
RegisterKeyAndJoin :: PoolId -> DelegationAction
Join :: PoolId -> DelegationAction
Quit :: DelegationAction

-- | Some additional context about a transaction. This typically contains
--   details that are known upfront about the transaction and are used to
--   construct it from inputs selected from the wallet's UTxO.
data TransactionCtx
TransactionCtx :: Withdrawal -> Maybe TxMetadata -> (Maybe SlotNo, SlotNo) -> Maybe DelegationAction -> Coin -> (TokenMap, Map AssetId (Script KeyHash)) -> (TokenMap, Map AssetId (Script KeyHash)) -> SelectionCollateralRequirement -> !Coin -> TransactionCtx

-- | Withdrawal amount from a reward account, can be zero.
[$sel:txWithdrawal:TransactionCtx] :: TransactionCtx -> Withdrawal

-- | User or application-defined metadata to embed in the transaction.
[$sel:txMetadata:TransactionCtx] :: TransactionCtx -> Maybe TxMetadata

-- | Transaction optional starting slot and expiry (TTL) slot for which the
--   transaction is valid.
[$sel:txValidityInterval:TransactionCtx] :: TransactionCtx -> (Maybe SlotNo, SlotNo)

-- | An additional delegation to take.
[$sel:txDelegationAction:TransactionCtx] :: TransactionCtx -> Maybe DelegationAction

-- | Total execution cost of plutus scripts, determined by their execution
--   units and prices obtained from network.
[$sel:txPlutusScriptExecutionCost:TransactionCtx] :: TransactionCtx -> Coin

-- | The assets to mint.
[$sel:txAssetsToMint:TransactionCtx] :: TransactionCtx -> (TokenMap, Map AssetId (Script KeyHash))

-- | The assets to burn.
[$sel:txAssetsToBurn:TransactionCtx] :: TransactionCtx -> (TokenMap, Map AssetId (Script KeyHash))

-- | The collateral requirement.
[$sel:txCollateralRequirement:TransactionCtx] :: TransactionCtx -> SelectionCollateralRequirement

-- | Extra fees. Some parts of a transaction are not representable using
--   cardano-wallet types, which makes it useful to account for them like
--   this. For instance: datums.
[$sel:txFeePadding:TransactionCtx] :: TransactionCtx -> !Coin

-- | A default context with sensible placeholder. Can be used to reduce
--   repetition for changing only sub-part of the default context.
defaultTransactionCtx :: TransactionCtx
data Withdrawal
WithdrawalSelf :: RewardAccount -> NonEmpty DerivationIndex -> Coin -> Withdrawal
WithdrawalExternal :: RewardAccount -> NonEmpty DerivationIndex -> Coin -> Withdrawal
NoWithdrawal :: Withdrawal
withdrawalToCoin :: Withdrawal -> Coin

-- | Describes modifications that can be made to a <a>Tx</a> using
--   <a>$sel:updateTx:TransactionLayer</a>.
data TxUpdate
TxUpdate :: [(TxIn, TxOut)] -> [TxIn] -> [TxOut] -> TxFeeUpdate -> TxUpdate
[$sel:extraInputs:TxUpdate] :: TxUpdate -> [(TxIn, TxOut)]

-- | Only used in the Alonzo era and later. Will be silently ignored in
--   previous eras.
[$sel:extraCollateral:TxUpdate] :: TxUpdate -> [TxIn]
[$sel:extraOutputs:TxUpdate] :: TxUpdate -> [TxOut]

-- | Set a new fee or use the old one.
[$sel:feeUpdate:TxUpdate] :: TxUpdate -> TxFeeUpdate

-- | Method to use when updating the fee of a transaction.
data TxFeeUpdate

-- | Instead of updating the fee, just use the old fee of the Tx (no-op for
--   fee update).
UseOldTxFee :: TxFeeUpdate

-- | Specify a new fee to use instead.
UseNewTxFee :: Coin -> TxFeeUpdate
data TokenMapWithScripts
TokenMapWithScripts :: !TokenMap -> !Map TokenPolicyId AnyScript -> TokenMapWithScripts
[$sel:txTokenMap:TokenMapWithScripts] :: TokenMapWithScripts -> !TokenMap
[$sel:txScripts:TokenMapWithScripts] :: TokenMapWithScripts -> !Map TokenPolicyId AnyScript
emptyTokenMapWithScripts :: TokenMapWithScripts
data AnyScript
NativeScript :: !Script KeyHash -> AnyScript
PlutusScript :: !PlutusScriptInfo -> AnyScript
newtype PlutusScriptInfo
PlutusScriptInfo :: PlutusVersion -> PlutusScriptInfo
[$sel:languageVersion:PlutusScriptInfo] :: PlutusScriptInfo -> PlutusVersion
data PlutusVersion
PlutusVersionV1 :: PlutusVersion
PlutusVersionV2 :: PlutusVersion

-- | Small helper record to disambiguate between a fee and change Coin
--   values. Used by <a>$sel:distributeSurplus:TransactionLayer</a>.
data TxFeeAndChange change
TxFeeAndChange :: Coin -> change -> TxFeeAndChange change
[$sel:fee:TxFeeAndChange] :: TxFeeAndChange change -> Coin
[$sel:change:TxFeeAndChange] :: TxFeeAndChange change -> change

-- | Manipulates a <a>TxFeeAndChange</a> value.
mapTxFeeAndChange :: (Coin -> Coin) -> (change1 -> change2) -> TxFeeAndChange change1 -> TxFeeAndChange change2
data ValidityIntervalExplicit
ValidityIntervalExplicit :: !Quantity "slot" Word64 -> !Quantity "slot" Word64 -> ValidityIntervalExplicit
[$sel:invalidBefore:ValidityIntervalExplicit] :: ValidityIntervalExplicit -> !Quantity "slot" Word64
[$sel:invalidHereafter:ValidityIntervalExplicit] :: ValidityIntervalExplicit -> !Quantity "slot" Word64

-- | Possible signing error
data ErrSignTx

-- | We tried to sign a transaction with inputs that are unknown to us?
ErrSignTxAddressUnknown :: TxIn -> ErrSignTx

-- | TODO: [ADP-919] Remove ErrSignTxUnimplemented
ErrSignTxUnimplemented :: ErrSignTx
data ErrMkTransaction
ErrMkTransactionNoSuchWallet :: WalletId -> ErrMkTransaction

-- | We failed to construct a transaction for some reasons.
ErrMkTransactionTxBodyError :: Text -> ErrMkTransaction

-- | Should never happen, means that that we have programmatically provided
--   an invalid era.
ErrMkTransactionInvalidEra :: AnyCardanoEra -> ErrMkTransaction
ErrMkTransactionJoinStakePool :: ErrCannotJoin -> ErrMkTransaction
ErrMkTransactionQuitStakePool :: ErrCannotQuit -> ErrMkTransaction
ErrMkTransactionIncorrectTTL :: PastHorizonException -> ErrMkTransaction
data ErrCannotJoin
ErrAlreadyDelegating :: PoolId -> ErrCannotJoin
ErrNoSuchPool :: PoolId -> ErrCannotJoin
data ErrCannotQuit
ErrNotDelegatingOrAboutTo :: ErrCannotQuit
ErrNonNullRewards :: Coin -> ErrCannotQuit
newtype ErrUpdateSealedTx

-- | The <tt>SealedTx</tt> couldn't not be updated because the *n* existing
--   key-witnesses would have been rendered invalid.
ErrExistingKeyWitnesses :: Int -> ErrUpdateSealedTx
data ErrAssignRedeemers

-- | Failed to assign execution units for a particular redeemer. The
--   <a>String</a> indicates the reason of the failure.
--   
--   TODO: Refine this type to avoid the <a>String</a> and provides a
--   better sum-type of possible errors.
ErrAssignRedeemersScriptFailure :: Redeemer -> String -> ErrAssignRedeemers

-- | The given redeemer target couldn't be located in the transaction.
ErrAssignRedeemersTargetNotFound :: Redeemer -> ErrAssignRedeemers

-- | Redeemer's data isn't a valid Plutus' data.
ErrAssignRedeemersInvalidData :: Redeemer -> String -> ErrAssignRedeemers

-- | Mistranslating of hashes, credentials, certificates etc.
ErrAssignRedeemersTranslationError :: TranslationError StandardCrypto -> ErrAssignRedeemers

-- | Error for when its impossible for
--   <a>$sel:distributeSurplus:TransactionLayer</a> to distribute the
--   surplus. As long as the surplus is larger than
--   <tt>costOfIncreasingCoin</tt>, this should never happen.
newtype ErrMoreSurplusNeeded
ErrMoreSurplusNeeded :: Coin -> ErrMoreSurplusNeeded
instance GHC.Show.Show Cardano.Wallet.Transaction.TxFeeUpdate
instance GHC.Classes.Eq Cardano.Wallet.Transaction.TxFeeUpdate
instance GHC.Classes.Eq Cardano.Wallet.Transaction.Withdrawal
instance GHC.Show.Show Cardano.Wallet.Transaction.Withdrawal
instance GHC.Generics.Generic Cardano.Wallet.Transaction.DelegationAction
instance GHC.Classes.Eq Cardano.Wallet.Transaction.DelegationAction
instance GHC.Show.Show Cardano.Wallet.Transaction.DelegationAction
instance GHC.Classes.Eq Cardano.Wallet.Transaction.TransactionCtx
instance GHC.Generics.Generic Cardano.Wallet.Transaction.TransactionCtx
instance GHC.Show.Show Cardano.Wallet.Transaction.TransactionCtx
instance Control.DeepSeq.NFData Cardano.Wallet.Transaction.PlutusVersion
instance GHC.Show.Show Cardano.Wallet.Transaction.PlutusVersion
instance GHC.Generics.Generic Cardano.Wallet.Transaction.PlutusVersion
instance GHC.Classes.Eq Cardano.Wallet.Transaction.PlutusVersion
instance Control.DeepSeq.NFData Cardano.Wallet.Transaction.PlutusScriptInfo
instance GHC.Show.Show Cardano.Wallet.Transaction.PlutusScriptInfo
instance GHC.Generics.Generic Cardano.Wallet.Transaction.PlutusScriptInfo
instance GHC.Classes.Eq Cardano.Wallet.Transaction.PlutusScriptInfo
instance Control.DeepSeq.NFData Cardano.Wallet.Transaction.AnyScript
instance GHC.Show.Show Cardano.Wallet.Transaction.AnyScript
instance GHC.Generics.Generic Cardano.Wallet.Transaction.AnyScript
instance GHC.Classes.Eq Cardano.Wallet.Transaction.AnyScript
instance GHC.Classes.Eq Cardano.Wallet.Transaction.TokenMapWithScripts
instance GHC.Generics.Generic Cardano.Wallet.Transaction.TokenMapWithScripts
instance GHC.Show.Show Cardano.Wallet.Transaction.TokenMapWithScripts
instance GHC.Show.Show Cardano.Wallet.Transaction.ErrAssignRedeemers
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ErrAssignRedeemers
instance GHC.Generics.Generic Cardano.Wallet.Transaction.ErrAssignRedeemers
instance GHC.Show.Show Cardano.Wallet.Transaction.ErrSignTx
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ErrSignTx
instance GHC.Generics.Generic Cardano.Wallet.Transaction.ErrSignTx
instance GHC.Show.Show Cardano.Wallet.Transaction.ErrCannotJoin
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ErrCannotJoin
instance GHC.Generics.Generic Cardano.Wallet.Transaction.ErrCannotJoin
instance GHC.Show.Show Cardano.Wallet.Transaction.ErrCannotQuit
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ErrCannotQuit
instance GHC.Show.Show Cardano.Wallet.Transaction.ErrMkTransaction
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ErrMkTransaction
instance GHC.Generics.Generic Cardano.Wallet.Transaction.ErrMkTransaction
instance GHC.Show.Show Cardano.Wallet.Transaction.ErrUpdateSealedTx
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ErrUpdateSealedTx
instance GHC.Generics.Generic Cardano.Wallet.Transaction.ErrUpdateSealedTx
instance GHC.Show.Show Cardano.Wallet.Transaction.ErrMoreSurplusNeeded
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ErrMoreSurplusNeeded
instance GHC.Generics.Generic Cardano.Wallet.Transaction.ErrMoreSurplusNeeded
instance GHC.Show.Show change => GHC.Show.Show (Cardano.Wallet.Transaction.TxFeeAndChange change)
instance GHC.Classes.Eq change => GHC.Classes.Eq (Cardano.Wallet.Transaction.TxFeeAndChange change)
instance Control.DeepSeq.NFData Cardano.Wallet.Transaction.ValidityIntervalExplicit
instance GHC.Show.Show Cardano.Wallet.Transaction.ValidityIntervalExplicit
instance GHC.Classes.Eq Cardano.Wallet.Transaction.ValidityIntervalExplicit
instance GHC.Generics.Generic Cardano.Wallet.Transaction.ValidityIntervalExplicit
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Transaction.ValidityIntervalExplicit
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Transaction.ValidityIntervalExplicit
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Transaction.PlutusScriptInfo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Transaction.PlutusScriptInfo
instance Data.Text.Class.ToText Cardano.Wallet.Transaction.PlutusVersion
instance Data.Text.Class.FromText Cardano.Wallet.Transaction.PlutusVersion
instance Formatting.Buildable.Buildable Cardano.Wallet.Transaction.DelegationAction


-- | Functionality for calculating <tt>SyncProgress</tt> of wallets.
module Cardano.Wallet.Primitive.SyncProgress
data SyncProgress
Ready :: SyncProgress
Syncing :: !Quantity "percent" Percentage -> SyncProgress
NotResponding :: SyncProgress
newtype SyncTolerance
SyncTolerance :: NominalDiffTime -> SyncTolerance

-- | Construct a <a>SyncTolerance</a> from a number of <b>seconds</b>
mkSyncTolerance :: Int -> SyncTolerance

-- | Estimate restoration progress based on:
--   
--   <ul>
--   <li>The slot of the latest block consumed (our progress)</li>
--   <li>The slot corresponding to the latest wall-clock time (our
--   target)</li>
--   </ul>
--   
--   The estimated progress is the quotient of these two quantities.
--   
--   In the Cardano consensus protocol, only a fraction of slots contains
--   blocks. Hence, the progress percentage will often be &lt; 100%, as the
--   slot corresponding to the current wall-clock time may not be filled
--   with a block. The sync tolerance should be large enough to accommodate
--   this issue.
syncProgress :: (HasCallStack, Monad m) => SyncTolerance -> TimeInterpreter m -> SlotNo -> RelativeTime -> m SyncProgress
instance GHC.Show.Show Cardano.Wallet.Primitive.SyncProgress.SyncProgress
instance GHC.Classes.Eq Cardano.Wallet.Primitive.SyncProgress.SyncProgress
instance GHC.Generics.Generic Cardano.Wallet.Primitive.SyncProgress.SyncProgress
instance GHC.Show.Show Cardano.Wallet.Primitive.SyncProgress.SyncTolerance
instance GHC.Classes.Eq Cardano.Wallet.Primitive.SyncProgress.SyncTolerance
instance GHC.Generics.Generic Cardano.Wallet.Primitive.SyncProgress.SyncTolerance
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.SyncProgress.SyncTolerance
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.SyncProgress.SyncTolerance
instance NoThunks.Class.NoThunks Cardano.Wallet.Primitive.SyncProgress.SyncProgress
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.SyncProgress.SyncProgress
instance GHC.Classes.Ord Cardano.Wallet.Primitive.SyncProgress.SyncProgress
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.SyncProgress.SyncProgress


-- | This module provides the <a>BlockSummary</a> type which summarizes a
--   contiguous sequence of blocks.
module Cardano.Wallet.Primitive.BlockSummary

-- | A <a>BlockSummary</a> summarizes the data contained in a contiguous
--   sequence of blocks.
--   
--   However, instead of storing the sequence of blocks of directly as a
--   Haskell list, the <a>BlockSummary</a> only provides a
--   <a>$sel:query:BlockSummary</a> function which looks up all
--   transactions associated to a given addresses. In addition, this query
--   function is monadic, which means that it can call out to an external
--   data source.
data BlockSummary m addr txs
BlockSummary :: !BlockHeader -> !BlockHeader -> (addr -> m txs) -> BlockSummary m addr txs
[$sel:from:BlockSummary] :: BlockSummary m addr txs -> !BlockHeader
[$sel:to:BlockSummary] :: BlockSummary m addr txs -> !BlockHeader
[$sel:query:BlockSummary] :: BlockSummary m addr txs -> addr -> m txs

-- | <a>BlockSummary</a> used for light-mode.
type LightSummary m = BlockSummary m (Either Address RewardAccount) ChainEvents

-- | <a>BlockEvents</a>, always ordered by slot.
data ChainEvents

-- | Create <a>ChainEvents</a> from a list of block events (which do not
--   need to be in order.)
fromBlockEvents :: [BlockEvents] -> ChainEvents

-- | List of <a>BlockEvents</a>, in ascending order. (No duplicate blocks,
--   all transactions within block in order).
toAscBlockEvents :: ChainEvents -> [BlockEvents]

-- | Events (such as txs, delegations) within a single block that are
--   potentially relevant to the wallet. This can be the entire block, or a
--   pre-filtered version of it.
data BlockEvents
BlockEvents :: !Slot -> !Quantity "block" Word32 -> Sublist Tx -> Sublist DelegationCertificate -> BlockEvents
[$sel:slot:BlockEvents] :: BlockEvents -> !Slot
[$sel:blockHeight:BlockEvents] :: BlockEvents -> !Quantity "block" Word32

-- | (Index of the transaction within the block, transaction data)
--   INVARIANT: The list is ordered by ascending index.
[$sel:transactions:BlockEvents] :: BlockEvents -> Sublist Tx

-- | (Index of the delegation within the block, delegation data) INVARIANT:
--   The list is ordered by ascending index.
[$sel:delegations:BlockEvents] :: BlockEvents -> Sublist DelegationCertificate

-- | Get the <a>BlockEvents</a> corresponding to an entire <a>Block</a>.
fromEntireBlock :: Block -> BlockEvents

-- | A data type representing a sublist of a total list. Such a sublist
--   typically arises by filtering and keeps track of the indices of the
--   filtered list elements.
--   
--   In order to represent sublists of <a>DelegationCertificate</a>, we do
--   not use a single <a>Int</a>, but a pair <tt>(Index1,Index2)</tt> as
--   index internally. This internal index is not part of the (safe) API of
--   <a>Sublist</a>.
--   
--   The main purpose of this data type is optimization: When processing
--   whole <a>Block</a>, we want to avoid copying and redecorating the
--   entire list of transactions in that <a>Block</a>; instead, we want to
--   copy a pointer to this list.
data Sublist a

-- | Filter a <a>Sublist</a> by a predicate.
filterSublist :: (a -> Bool) -> Sublist a -> Sublist a

-- | Construct a <a>Sublist</a> representing the whole list.
wholeList :: [a] -> Sublist a

-- | For testing: Convert a list of blocks into a <a>BlockSummary</a>.
--   Unfortunately, as <tt>TxIn</tt> references are not resolved, we can
--   only find transactions with relevant <a>TxOut</a>.
summarizeOnTxOut :: NonEmpty Block -> LightSummary Identity
mkChainEvents :: Map Slot BlockEvents -> ChainEvents

-- | Merge two <a>Sublist</a> assuming that they are sublists of the
--   <i>same</i> list.
mergeSublist :: Sublist a -> Sublist a -> Sublist a

-- | Construct a <a>Sublist</a> from a list of indexed items.
unsafeMkSublist :: [((Index1, Index2), a)] -> Sublist a
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.BlockSummary.BlockSummary m addr txs)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Primitive.BlockSummary.Sublist a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.BlockSummary.Sublist a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.BlockSummary.Sublist a)
instance GHC.Show.Show Cardano.Wallet.Primitive.BlockSummary.BlockEvents
instance GHC.Generics.Generic Cardano.Wallet.Primitive.BlockSummary.BlockEvents
instance GHC.Classes.Ord Cardano.Wallet.Primitive.BlockSummary.BlockEvents
instance GHC.Classes.Eq Cardano.Wallet.Primitive.BlockSummary.BlockEvents
instance GHC.Show.Show Cardano.Wallet.Primitive.BlockSummary.ChainEvents
instance GHC.Classes.Ord Cardano.Wallet.Primitive.BlockSummary.ChainEvents
instance GHC.Classes.Eq Cardano.Wallet.Primitive.BlockSummary.ChainEvents
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.BlockSummary.ChainEvents
instance GHC.Base.Monoid Cardano.Wallet.Primitive.BlockSummary.ChainEvents
instance GHC.Base.Functor Cardano.Wallet.Primitive.BlockSummary.Sublist
instance Data.Foldable.Foldable Cardano.Wallet.Primitive.BlockSummary.Sublist


-- | This module contains types for address discovery. The two address
--   discovery schemes implemented are:
--   
--   <ul>
--   <li><a>Cardano.Wallet.Primitive.AddressDiscovery.Sequential</a></li>
--   <li><a>Cardano.Wallet.Primitive.AddressDiscovery.Random</a></li>
--   </ul>
module Cardano.Wallet.Primitive.AddressDiscovery

-- | Checks whether or not a given entity belongs to us.
--   
--   This abstraction exists to give us the ability to keep the wallet
--   business logic agnostic to the address derivation and discovery
--   mechanisms.
--   
--   This is needed because two different address schemes lives on Cardano:
--   
--   <ul>
--   <li>A hierarchical random scheme: rather <tt>custom</tt> made, with
--   several flaws; this is the original and now legacy address
--   scheme.</li>
--   <li>A hierarchical sequential scheme: a new scheme based on the
--   BIP-0044 specification, which is better suited for our present
--   needs.</li>
--   </ul>
--   
--   In practice, we will need a wallet that can support both, even if not
--   at the same time, and this little abstraction can buy us this without
--   introducing too much overhead.
class IsOurs s entity
isOurs :: IsOurs s entity => entity -> s -> (Maybe (NonEmpty DerivationIndex), s)

-- | More powerful than <a>isOurs</a>, this abstractions offer the
--   underlying state the ability to find / compute the address private key
--   corresponding to a given known address.
--   
--   Requiring <a>IsOwned</a> as a constraint supposed that there is a way
--   to recover the root private key of a particular wallet. This isn't
--   true for externally owned wallet which would delegate its key
--   management to a third party (like a hardware Ledger or Trezor).
class IsOurs s Address => IsOwned s key
isOwned :: IsOwned s key => s -> (key 'RootK XPrv, Passphrase "encryption") -> Address -> Maybe (key 'AddressK XPrv, Passphrase "encryption")

-- | Abstracting over change address generation. In theory, this is only
--   needed for sending transactions on a wallet following a particular
--   scheme. This abstractions allows for defining an heuristic to pick new
--   change address. For instance, in BIP-44, change addresses belong to a
--   particular change chain (also called "Internal Chain").
class GenChange s where {
    type family ArgGenChange s :: Type;
}
genChange :: GenChange s => ArgGenChange s -> s -> (Address, s)

-- | Ordering addresses by discovery date.
--   
--   If <tt>a1</tt> has been discovered before <tt>a2</tt>, then the
--   following equation holds:
--   
--   <pre>
--   compareDiscovery s a1 a2 == LT
--   </pre>
--   
--   If <tt>a1</tt> has been discovered after <tt>a2</tt>, then the
--   following equation holds:
--   
--   <pre>
--   compareDiscovery s a1 a2 == GT
--   </pre>
--   
--   Note that, if an address isn't known it is considered not discovered
--   and therefore, is always _greater than_ any known address.
class CompareDiscovery s
compareDiscovery :: CompareDiscovery s => s -> Address -> Address -> Ordering

-- | Extract the list of all known addresses.
--   
--   NOTE: Change addresses aren't considered "known" until they've been
--   used. The rationale is that, we don't want users or consumers of the
--   wallet to be using change addresses prematurely.
class KnownAddresses s
knownAddresses :: KnownAddresses s => s -> [(Address, AddressState, NonEmpty DerivationIndex)]
class GetPurpose (key :: Depth -> Type -> Type)
getPurpose :: GetPurpose key => Index 'Hardened 'PurposeK
class GetAccount s (key :: Depth -> Type -> Type) | s -> key
getAccount :: GetAccount s key => s -> key 'AccountK XPub

-- | One master node (seed) can be used for unlimited number of independent
--   cryptocoins such as Bitcoin, Litecoin or Namecoin. However, sharing
--   the same space for various cryptocoins has some disadvantages.
--   
--   This level creates a separate subtree for every cryptocoin, avoiding
--   reusing addresses across cryptocoins and improving privacy issues.
--   
--   Coin type is a constant, set for each cryptocoin. For Cardano this
--   constant is set to 1815' (or 0x80000717). 1815 is the birthyear of our
--   beloved Ada Lovelace.
--   
--   Hardened derivation is used at this level.
coinTypeAda :: Index 'Hardened 'CoinTypeK

-- | Checks whether the address discovery state <tt>s</tt> works in
--   light-mode and returns a procedure for discovering addresses if that
--   is indeed the case.
class MaybeLight s
maybeDiscover :: MaybeLight s => Maybe (LightDiscoverTxs s)

-- | Function that discovers transactions based on an address.
newtype DiscoverTxs addr txs s
DiscoverTxs :: (forall m. Monad m => (addr -> m txs) -> s -> m (txs, s)) -> DiscoverTxs addr txs s
[discoverTxs] :: DiscoverTxs addr txs s -> forall m. Monad m => (addr -> m txs) -> s -> m (txs, s)

-- | An ordered set of pending indexes. This keep track of indexes used
data PendingIxs k

-- | An empty pending set of change indexes.
--   
--   NOTE: We do not define a <a>Monoid</a> instance here because there's
--   no rational of combining two pending sets.
emptyPendingIxs :: PendingIxs k
pendingIxsToList :: PendingIxs k -> [Index 'Soft k]

-- | Construct a <a>PendingIxs</a> from a list, ensuring that it is a set
--   of indexes in descending order.
pendingIxsFromList :: [Index 'Soft k] -> PendingIxs k

-- | Get the next change index; If every available indexes have already
--   been taken, we'll rotate the pending set and re-use already provided
--   indexes.
nextChangeIndex :: forall (key :: Depth -> Type -> Type) k. Pool (KeyFingerprint "payment" key) (Index 'Soft k) -> PendingIxs k -> (Index 'Soft k, PendingIxs k)

-- | Update the set of pending indexes by discarding every indexes _below_
--   the given index.
--   
--   Why is that?
--   
--   Because we really do care about the higher index that was last used in
--   order to know from where we can generate new indexes.
updatePendingIxs :: Index 'Soft k -> PendingIxs k -> PendingIxs k
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.PendingIxs k)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.PendingIxs k)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.PendingIxs k)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.PendingIxs k)


-- | This module implements the "business logic" to manage a Cardano
--   wallet. It is a direct implementation of the model, with extensions,
--   from the <a>Formal Specification for a Cardano Wallet</a>.
--   
--   In other words, this module is about how the wallet keeps track of its
--   internal state, specifically the <a>UTxO</a> set and the address
--   discovery state. This module is intentionally agnostic to specific
--   address formats, and instead relies on the <a>IsOurs</a> abstraction.
--   It is also agnostic to issues such as how blocks are retrieved from
--   the network, or how the state is serialized and cached in the local
--   database.
--   
--   All those functions are pure and there's no reason to shove in any
--   sort of side-effects in here. ðŸ™‚
module Cardano.Wallet.Primitive.Model

-- | Abstract data type representing a wallet state.
--   
--   A <a>Wallet</a> keeps track of transaction outputs and associated
--   addresses that belong to <i>us</i> -- we are able to spend these
--   outputs because we know the corresponding signing key belonging to the
--   output. Hence, we are able to produce witness engaging those outputs
--   as they become inputs in forthcoming transactions according to UTxO
--   model. This information is associated to a particular point on the
--   blockchain.
--   
--   Internally, a <a>Wallet</a> keeps track of
--   
--   <ul>
--   <li>UTxOs</li>
--   <li>Known &amp; used addresses, via address discovery state</li>
--   <li>The associated <a>BlockHeader</a> indicating the point on the
--   chain.</li>
--   </ul>
--   
--   The <a>Wallet</a> is parameterized over a single type:
--   
--   <ul>
--   <li><tt>s</tt> is a <i>state</i> used to keep track of known
--   addresses. Typically, this state will be an instance of the
--   <a>IsOurs</a> class, e.g. <tt><a>IsOurs</a> s
--   <a>Address</a></tt>.</li>
--   </ul>
--   
--   A few examples to make it concrete:
--   
--   <pre>
--   Wallet (RndState k n)
--   Wallet (SeqState n ShelleyKey)
--   </pre>
data Wallet s

-- | Create an empty wallet and apply the given genesis block.
--   
--   The wallet tip will be the genesis block header.
initWallet :: (IsOurs s Address, IsOurs s RewardAccount) => Block -> s -> ([(Tx, TxMeta)], Wallet s)

-- | Update the address discovery state of a wallet.
updateState :: s -> Wallet s -> Wallet s

-- | Represents the subset of data from a single block that are relevant to
--   a particular wallet, discovered when applying a block to that wallet.
data FilteredBlock
FilteredBlock :: !Slot -> ![(Tx, TxMeta)] -> ![DelegationCertificate] -> FilteredBlock

-- | The slot of this block.
[$sel:slot:FilteredBlock] :: FilteredBlock -> !Slot

-- | The set of transactions that affect the wallet, list in the same order
--   which they appeared in the block.
[$sel:transactions:FilteredBlock] :: FilteredBlock -> ![(Tx, TxMeta)]

-- | Stake delegations made on behalf of the wallet, listed in the order in
--   which they appear on the chain. If the list contains more than
--   element, those that appear later in the list supersede those that
--   appear earlier on.
[$sel:delegations:FilteredBlock] :: FilteredBlock -> ![DelegationCertificate]

-- | Apply a single block to a wallet.
--   
--   This is the most fundamental way of making a wallet evolve.
--   
--   Returns an updated wallet, as well as the address data relevant to the
--   wallet that were discovered while applying the block.
applyBlock :: (IsOurs s Address, IsOurs s RewardAccount) => Block -> Wallet s -> (FilteredBlock, (DeltaWallet s, Wallet s))

-- | Apply multiple blocks in sequence to an existing wallet and return a
--   list of intermediate wallet states.
--   
--   If the input blocks are a <a>List</a>, then one intermediate wallet
--   state is returned for each block in the list. If the input blocks are
--   a <a>Summary</a>, then only one final wallet state is returned.
--   
--   More specifically, for an initial wallet state <tt>w0</tt> and a
--   <a>List</a> of of blocks
--   
--   <pre>
--   bs = [b1, b2, â€¦, bn]@
--   </pre>
--   
--   , the function returns
--   
--   @ [ (filtered b1, (delta w0 -&gt; w1 , w1 = w0 + b1)) , (filtered b2,
--   (delta w1 -&gt; w2 , w2 = w1 + b2)) , â€¦ , (filtered bn, (delta w(n-1)
--   -&gt; wn, wn = w(n-1)+bn)) ]
--   
--   Here:
--   
--   <ul>
--   <li><tt>filtered bj</tt> refers to the set of transactions contained
--   in the block <tt>bj</tt> that were actually applied to the wallet
--   state.</li>
--   <li><tt>wi + bj</tt> refers to the wallet state obtained after
--   applying the block <tt>bi</tt> to the wallet <tt>wj</tt>.</li>
--   <li>delta wi -&gt; wj<tt> refers to the delta that was applied in
--   order to obtain </tt>wj<tt> from </tt>wi@.</li>
--   </ul>
applyBlocks :: (IsOurs s Address, IsOurs s RewardAccount, Monad m) => BlockData m (Either Address RewardAccount) ChainEvents s -> Wallet s -> m (NonEmpty ([FilteredBlock], (DeltaWallet s, Wallet s)))

-- | Apply multiple blocks in sequence to an existing wallet and return the
--   final wallet state as well as the transactions that were applied.
applyBlockData :: (IsOurs s Address, IsOurs s RewardAccount, Monad m) => BlockData m (Either Address RewardAccount) ChainEvents s -> Wallet s -> m ([FilteredBlock], (DeltaWallet s, Wallet s))

-- | BlockData which has been paired with discovery facilities.
data BlockData m addr tx s
List :: NonEmpty Block -> BlockData m addr tx s
Summary :: DiscoverTxs addr tx s -> BlockSummary m addr tx -> BlockData m addr tx s

-- | First <a>BlockHeader</a> of the blocks represented by
--   <a>BlockData</a>.
firstHeader :: BlockData m addr txs s -> BlockHeader

-- | Last <a>BlockHeader</a> of the blocks represented by <a>BlockData</a>.
lastHeader :: BlockData m addr txs s -> BlockHeader

-- | Header of the latest applied block (current tip)
($sel:currentTip:Wallet) :: Wallet s -> BlockHeader

-- | Address discovery state
($sel:getState:Wallet) :: Wallet s -> s

-- | Available balance = <a>balance</a> . <a>availableUTxO</a>
availableBalance :: Set Tx -> Wallet s -> TokenBundle

-- | Total balance = <a>balance</a> . <a>totalUTxO</a> +? rewards
totalBalance :: (IsOurs s Address, IsOurs s RewardAccount) => Set Tx -> Coin -> Wallet s -> TokenBundle

-- | Computes the total <a>UTxO</a> set of a wallet.
--   
--   This total <a>UTxO</a> set is a projection of how the wallet's UTxO
--   set would look if all pending transactions were applied successfully.
--   
--   <pre>
--   &gt;&gt;&gt; totalUTxO pendingTxs wallet
--   
--   &gt;&gt;&gt; = utxo wallet
--   
--   &gt;&gt;&gt; âˆ’ inputs pendingTxs
--   
--   &gt;&gt;&gt; âˆª change pendingTxs
--   </pre>
totalUTxO :: IsOurs s Address => Set Tx -> Wallet s -> UTxO

-- | Available UTxO = <tt>pending â‹ª utxo</tt>
availableUTxO :: Set Tx -> Wallet s -> UTxO

-- | Unspent tx outputs belonging to this wallet
($sel:utxo:Wallet) :: Wallet s -> UTxO

-- | Delta encoding for <a>Wallet</a>.
data DeltaWallet s

-- | Construct a wallet from the exact given state.
--   
--   Using this function instead of <a>initWallet</a> and <a>applyBlock</a>
--   allows the wallet invariants to be broken. Therefore it should only be
--   used in the special case of loading wallet checkpoints from the
--   database (where it is assumed a valid wallet was stored into the
--   database).
unsafeInitWallet :: UTxO -> BlockHeader -> s -> Wallet s

-- | Remove unspent outputs that are consumed by the given transaction.
--   
--   <pre>
--   spendTx tx u <tt>isSubsetOf</tt> u
--   balance (spendTx tx u) &lt;= balance u
--   balance (spendTx tx u) = balance u - balance (u <tt>restrictedBy</tt> inputs tx)
--   spendTx tx u = u <a>excluding</a> inputs tx
--   spendTx tx (filterByAddress f u) = filterByAddress f (spendTx tx u)
--   spendTx tx (u &lt;&gt; utxoFromTx tx) = spendTx tx u &lt;&gt; utxoFromTx tx
--   </pre>
spendTx :: Tx -> UTxO -> UTxO

-- | Generates a UTxO set from a transaction.
--   
--   The generated UTxO set corresponds to the value provided by the
--   transaction.
--   
--   It is important for transaction outputs to be ordered correctly, as
--   their indices within this ordering will determine how they are
--   referenced as transaction inputs in subsequent blocks.
--   
--   Assuming the transaction is not marked as having an invalid script,
--   the following properties should hold:
--   
--   <pre>
--   balance (utxoFromTx tx) == foldMap tokens (outputs tx)
--   </pre>
--   
--   <pre>
--   size    (utxoFromTx tx) == length         (outputs tx)
--   </pre>
--   
--   <pre>
--   toList  (utxoFromTx tx) == toList         (outputs tx)
--   </pre>
--   
--   However, if the transaction is marked as having an invalid script,
--   then the following properties should hold:
--   
--   <pre>
--   balance (utxoFromTx tx) == foldMap tokens (collateralOutput tx)
--   </pre>
--   
--   <pre>
--   size    (utxoFromTx tx) == length         (collateralOutput tx)
--   </pre>
--   
--   <pre>
--   toList  (utxoFromTx tx) == toList         (collateralOutput tx)
--   </pre>
utxoFromTx :: Tx -> UTxO

-- | Generates a UTxO set from the ordinary outputs of a transaction.
--   
--   This function ignores the transaction's script validity.
utxoFromTxOutputs :: Tx -> UTxO

-- | Generates a UTxO set from the collateral outputs of a transaction.
--   
--   This function ignores the transaction's script validity.
utxoFromTxCollateralOutputs :: Tx -> UTxO

-- | Applies a transaction to a UTxO, moving it from one state to another.
--   
--   When applying a transaction to a UTxO: 1. We need to remove any
--   unspents that have been spent in the transaction. 2. Add any unspents
--   that we've received via the transaction. In this function, we assume
--   that all outputs belong to us.
--   
--   Properties:
--   
--   <pre>
--   balance (applyTxToUTxO tx u) = balance u
--                                + balance (utxoFromTx tx)
--                                - balance (u <tt>restrictedBy</tt> inputs tx)
--   unUTxO (applyTxToUTxO tx u) = unUTxO u
--       <a>union</a> unUTxO (utxoFromTx tx)
--       <a>difference</a> unUTxO (u <tt>restrictedBy</tt> inputs tx)
--   applyTxToUTxO tx u = spend tx u &lt;&gt; utxoFromTx tx
--   applyTxToUTxO tx u = spend tx (u &lt;&gt; utxoFromTx tx)
--   </pre>
applyTxToUTxO :: Tx -> UTxO -> UTxO

-- | Apply the given transaction to the <a>UTxO</a>. Return <a>Just</a> if
--   and only if the transaction is relevant to the wallet (changes the
--   <a>UTxO</a> set or makes a withdrawal).
--   
--   It satisfies the following property:
--   
--   <pre>
--   isJust (applyOurTxToUTxO slot bh state1 tx u) = b
--     where (b, state1) = runState (isOurTx tx u) state0
--   </pre>
applyOurTxToUTxO :: (IsOurs s Address, IsOurs s RewardAccount) => Slot -> Quantity "block" Word32 -> s -> Tx -> UTxO -> Maybe ((Tx, TxMeta), DeltaUTxO, UTxO)

-- | Retrieve the change <a>UTxO</a> contained in a set of pending
--   transactions.
--   
--   We perform <i>some</i> address discovery within the list of pending
--   addresses, but we do not store the result. Instead, we essentially
--   assume that the address discovery state <tt>s</tt> contains enough
--   information to collect the change addresses in the pending
--   transactions.
--   
--   Caveats: * Rollbacks can invalidate this assumption. ðŸ™ˆ * The order of
--   pending transactions is based on transaction hashes, and typically
--   does not agree with the order in which we have submitted them onto the
--   chain. Hence, the address discovery phase is not really very
--   effective. TODO: Add slot to <a>Tx</a> and sort the pending set by
--   slot.
changeUTxO :: IsOurs s Address => Set Tx -> s -> UTxO

-- | Perform address discovery on a <a>Block</a> by going through all
--   transactions and delegation certificates in the block.
discoverAddressesBlock :: (IsOurs s Address, IsOurs s RewardAccount) => Block -> s -> (DeltaAddressBook s, s)

-- | Perform address and transaction discovery on <a>BlockData</a>,
discoverFromBlockData :: (IsOurs s Address, IsOurs s RewardAccount, Monad m) => BlockData m (Either Address RewardAccount) ChainEvents s -> s -> m (ChainEvents, s)

-- | Add an address to the address discovery state, iff it belongs to us.
updateOurs :: IsOurs s addr => s -> addr -> s
instance GHC.Show.Show s => GHC.Show.Show (Cardano.Wallet.Primitive.Model.Wallet s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Cardano.Wallet.Primitive.Model.Wallet s)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Model.Wallet s)
instance GHC.Show.Show s => GHC.Show.Show (Cardano.Wallet.Primitive.Model.DeltaWallet s)
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Model.FilteredBlock
instance GHC.Show.Show Cardano.Wallet.Primitive.Model.FilteredBlock
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Model.FilteredBlock
instance Data.Delta.Delta (Cardano.Wallet.Primitive.Model.DeltaWallet s)
instance Control.DeepSeq.NFData s => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Model.Wallet s)
instance Formatting.Buildable.Buildable s => Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.Model.Wallet s)


-- | An implementation of address discovery for the random address scheme
--   as used by the legacy Cardano wallets.
module Cardano.Wallet.Primitive.AddressDiscovery.Random

-- | HD random address discovery state and key material for AD.
data RndState (network :: NetworkDiscriminant)
RndState :: Passphrase "addr-derivation-payload" -> Index 'Hardened 'AccountK -> Map DerivationPath (Address, AddressState) -> Map DerivationPath Address -> StdGen -> RndState (network :: NetworkDiscriminant)

-- | The HD derivation passphrase
[hdPassphrase] :: RndState (network :: NetworkDiscriminant) -> Passphrase "addr-derivation-payload"

-- | The account index used for address _generation_ in this wallet. Note
--   that addresses will be _discovered_ from any and all account indices,
--   regardless of this value.
[accountIndex] :: RndState (network :: NetworkDiscriminant) -> Index 'Hardened 'AccountK

-- | The addresses which have so far been discovered, and their derivation
--   paths.
[discoveredAddresses] :: RndState (network :: NetworkDiscriminant) -> Map DerivationPath (Address, AddressState)

-- | The addresses which have been generated for use as change addresses,
--   and their derivation paths. Once addresses have been discovered they
--   are removed from this set and added to <tt>addresses</tt>.
[pendingAddresses] :: RndState (network :: NetworkDiscriminant) -> Map DerivationPath Address

-- | The state of the RNG.
[gen] :: RndState (network :: NetworkDiscriminant) -> StdGen
class RndStateLike s

-- | Initialize the HD random address discovery state from a root key and
--   RNG seed.
mkRndState :: ByronKey 'RootK XPrv -> Int -> RndState n

-- | Shortcut type alias for HD random address derivation path.
type DerivationPath = (Index 'WholeDomain 'AccountK, Index 'WholeDomain 'AddressK)
toDerivationIndexes :: DerivationPath -> NonEmpty DerivationIndex
importAddress :: RndStateLike s => Address -> s -> Either ErrImportAddress s
newtype ErrImportAddress
ErrAddrDoesNotBelong :: Address -> ErrImportAddress
addPendingAddress :: RndStateLike s => Address -> DerivationPath -> s -> s

-- | Use the key material in <a>RndState</a> to derive a change address.
deriveRndStateAddress :: forall n. PaymentAddress n ByronKey => ByronKey 'RootK XPrv -> Passphrase "encryption" -> DerivationPath -> Address

-- | Randomly generates an address derivation path for a given account. If
--   the path is already in the "blacklist", it will try generating
--   another.
--   
--   Note that performance of this function will degrade poorly as more of
--   the account's address space is used up. We may have to improve it
--   later.
findUnusedPath :: StdGen -> Index 'Hardened 'AccountK -> Set DerivationPath -> (DerivationPath, StdGen)

-- | Returns the set of derivation paths that should not be used for new
--   address generation because they are already in use.
unavailablePaths :: RndStateLike s => s -> Set DerivationPath

-- | Default account used for generating new derivation paths.
defaultAccountIndex :: RndStateLike s => s -> Index 'Hardened 'AccountK

-- | Default random number generator.
withRNG :: RndStateLike s => s -> (StdGen -> (a, StdGen)) -> (a, s)

-- | An "unsound" alternative that can be used for benchmarking and stress
--   testing. It re-uses the same underlying structure as the
--   <a>RndState</a> but it discover addresses based on an arbitrary ratio
--   instead of decrypting the derivation path.
--   
--   The proportion is stored as a type-level parameter so that we don't
--   have to alter the database schema to store it. It simply exists and
--   depends on the caller creating the wallet to define it.
newtype RndAnyState (network :: NetworkDiscriminant) (p :: Nat)
RndAnyState :: RndState network -> RndAnyState (network :: NetworkDiscriminant) (p :: Nat)
[innerState] :: RndAnyState (network :: NetworkDiscriminant) (p :: Nat) -> RndState network

-- | Initialize the HD random address discovery state from a root key and
--   RNG seed.
--   
--   The type parameter is expected to be a ratio of addresses we ought to
--   simply recognize as ours. It is expressed in per-myriad, so "1" means
--   0.01%, "100" means 1% and 10000 means 100%.
mkRndAnyState :: forall (p :: Nat) n. () => ByronKey 'RootK XPrv -> Int -> RndAnyState n p
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState network)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState network)
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Random.ErrImportAddress
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Random.ErrImportAddress
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDiscovery.Random.ErrImportAddress
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState network p)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState network p)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p)
instance Cardano.Wallet.Primitive.AddressDiscovery.Random.RndStateLike (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p)
instance GHC.TypeNats.KnownNat p => Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p) Cardano.Wallet.Primitive.Types.Address.Address
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p) Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance GHC.TypeNats.KnownNat p => Cardano.Wallet.Primitive.AddressDiscovery.IsOwned (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p) Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress n Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey => Cardano.Wallet.Primitive.AddressDiscovery.GenChange (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p)
instance Cardano.Wallet.Primitive.AddressDiscovery.CompareDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p)
instance Cardano.Wallet.Primitive.AddressDiscovery.KnownAddresses (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p)
instance Cardano.Wallet.Primitive.AddressDiscovery.MaybeLight (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p)
instance Cardano.Wallet.Primitive.AddressDiscovery.Random.RndStateLike (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n)
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress n Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey => Cardano.Wallet.Primitive.AddressDiscovery.GenChange (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState network)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState network)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState network)
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n) Cardano.Wallet.Primitive.Types.Address.Address
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n) Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOwned (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n) Cardano.Wallet.Primitive.AddressDerivation.Byron.ByronKey
instance Cardano.Wallet.Primitive.AddressDiscovery.CompareDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n)
instance Cardano.Wallet.Primitive.AddressDiscovery.KnownAddresses (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n)
instance Cardano.Wallet.Primitive.AddressDiscovery.MaybeLight (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n)


-- | Derivation of policy keys which are used to create scripts for the
--   purposes of minting and burning. Derived according to CIP-1855
--   (https:/<i>github.com</i>cardano-foundation<i>CIPs</i>blob<i>b2e9d02cb9a71ba9e754a432c78197428abf7e4c</i>CIP-1855/CIP-1855.md).
--   
--   The policy keys are derived from the following path:
--   
--   m <i> purpose' </i> coin_type' / policy_ix' m <i> 1855' </i> 1815' /
--   [2^31 .. 2^32-1]'
--   
--   Where purpose' and coin_type' are fixed, and each new policy_ix'
--   represents a different policy key.
module Cardano.Wallet.Primitive.AddressDerivation.MintBurn

-- | Purpose for forged policy keys is a constant set to 1855' (or
--   0x8000073F) following the original CIP-1855: "Forging policy keys for
--   HD Wallets".
--   
--   It indicates that the subtree of this node is used according to this
--   specification.
--   
--   Hardened derivation is used at this level.
purposeCIP1855 :: Index 'Hardened 'PurposeK

-- | Derive the policy private key that should be used to create mint/burn
--   scripts, as well as the key hash of the policy public key.
derivePolicyKeyAndHash :: WalletKey key => Passphrase "encryption" -> key 'RootK XPrv -> Index 'Hardened 'PolicyK -> (key 'PolicyK XPrv, KeyHash)

-- | Derive the policy private key that should be used to create mint/burn
--   scripts.
derivePolicyPrivateKey :: Passphrase purpose -> XPrv -> Index 'Hardened 'PolicyK -> XPrv
policyDerivationPath :: NonEmpty DerivationIndex
toTokenMapAndScript :: forall key. WalletKey key => Script Cosigner -> Map Cosigner XPub -> TokenName -> Natural -> (AssetId, TokenQuantity, Script KeyHash)
toTokenPolicyId :: forall key. WalletKey key => Script Cosigner -> Map Cosigner XPub -> TokenPolicyId
scriptSlotIntervals :: Script a -> [Interval Natural]
withinSlotInterval :: SlotNo -> SlotNo -> [Interval Natural] -> Bool


-- | An implementation of address discovery for the sequential address
--   derivation scheme specified in BIP-0044.
--   
--   The management of _accounts_ is left-out for this implementation
--   focuses on a single account. In practice, one wants to manage a set of
--   pools, one per account.
module Cardano.Wallet.Primitive.AddressDiscovery.Sequential

-- | Maximum number of consecutive undiscovered addresses allowed
data AddressPoolGap

-- | Possible errors when casting to an <a>AddressPoolGap</a>
newtype MkAddressPoolGapError
ErrGapOutOfRange :: Integer -> MkAddressPoolGapError

-- | A default <a>AddressPoolGap</a>, as suggested in BIP-0044
defaultAddressPoolGap :: AddressPoolGap
getAddressPoolGap :: AddressPoolGap -> Word32

-- | Smart constructor for <a>AddressPoolGap</a>
mkAddressPoolGap :: Integer -> Either MkAddressPoolGapError AddressPoolGap

-- | Constructor which allows by-passing the address pool gap boundary
--   limitations. A practical use-case for this are sequential wallets for
--   which we don't have access to the whole history which therefore
--   require using arbitrary big gaps in order to discover addresses with
--   indexes separated by possible huge gaps.
--   
--   This defies a bit the purpose of this type though.
mkUnboundedAddressPoolGap :: Word32 -> AddressPoolGap

-- | An address pool which keeps track of sequential addresses. To create a
--   new pool, see <a>newSeqAddressPool</a>.
newtype SeqAddressPool (c :: Role) (key :: Depth -> Type -> Type)
SeqAddressPool :: Pool (KeyFingerprint "payment" key) (Index 'Soft 'AddressK) -> SeqAddressPool (c :: Role) (key :: Depth -> Type -> Type)
[getPool] :: SeqAddressPool (c :: Role) (key :: Depth -> Type -> Type) -> Pool (KeyFingerprint "payment" key) (Index 'Soft 'AddressK)
getGap :: SeqAddressPool c k -> AddressPoolGap

-- | Create a new Address pool from a list of addresses. Note that, the
--   list is expected to be ordered in sequence (first indexes, first in
--   the list).
newSeqAddressPool :: forall (n :: NetworkDiscriminant) c key. (SupportsDiscovery n key, Typeable c) => key 'AccountK XPub -> AddressPoolGap -> SeqAddressPool c key
unsafePaymentKeyFingerprint :: forall k from. (HasCallStack, MkKeyFingerprint k from) => from -> KeyFingerprint "payment" k

-- | A state to keep track of sequential addresses as described in
--   <a>BIP-44</a>
--   
--   Internally, the state keeps track of a few things for us and is it is
--   parameterized by a type <tt>n</tt> which captures a particular network
--   discrimination. This enables the state to be agnostic to the
--   underlying address format.
data SeqState (n :: NetworkDiscriminant) k
SeqState :: !SeqAddressPool 'UtxoInternal k -> !SeqAddressPool 'UtxoExternal k -> !PendingIxs 'AddressK -> k 'AccountK XPub -> Maybe (k 'PolicyK XPub) -> k 'AddressK XPub -> DerivationPrefix -> SeqState (n :: NetworkDiscriminant) k

-- | Addresses living on the <a>UtxoInternal</a>
[internalPool] :: SeqState (n :: NetworkDiscriminant) k -> !SeqAddressPool 'UtxoInternal k

-- | Addresses living on the <a>UtxoExternal</a>
[externalPool] :: SeqState (n :: NetworkDiscriminant) k -> !SeqAddressPool 'UtxoExternal k

-- | Indexes from the internal pool that have been used in pending
--   transactions. The list is maintained sorted in descending order (cf:
--   <a>PendingIxs</a>)
[pendingChangeIxs] :: SeqState (n :: NetworkDiscriminant) k -> !PendingIxs 'AddressK

-- | The account public key associated with this state
[accountXPub] :: SeqState (n :: NetworkDiscriminant) k -> k 'AccountK XPub

-- | The policy public key associated with this state derived for policy
--   key hardened index=0
[policyXPub] :: SeqState (n :: NetworkDiscriminant) k -> Maybe (k 'PolicyK XPub)

-- | Reward account public key associated with this wallet
[rewardAccountKey] :: SeqState (n :: NetworkDiscriminant) k -> k 'AddressK XPub

-- | Derivation path prefix from a root key up to the internal account
[derivationPrefix] :: SeqState (n :: NetworkDiscriminant) k -> DerivationPrefix

-- | Each <tt>SeqState</tt> is like a bucket of addresses associated with
--   an <tt>account</tt>. An <tt>account</tt> corresponds to a subset of an
--   HD tree as defined in BIP-0039.
--   
--   cardano-wallet implements two similar HD schemes on top of BIP-0039
--   that are:
--   
--   <ul>
--   <li>BIP-0044 (for so-called Icarus wallets)</li>
--   <li>CIP-1815 (for so-called Shelley and Jormungandr wallets)</li>
--   </ul>
--   
--   Both scheme works by considering 5 levels of derivation from an
--   initial root key (see also <a>Depth</a> from
--   Cardano.Wallet.Primitive.AddressDerivation). A SeqState keeps track of
--   indexes from the two last levels of a derivation branch. The
--   <a>DerivationPrefix</a> defines the first three indexes chosen for
--   this particular <tt>SeqState</tt>.
newtype DerivationPrefix
DerivationPrefix :: (Index 'Hardened 'PurposeK, Index 'Hardened 'CoinTypeK, Index 'Hardened 'AccountK) -> DerivationPrefix

-- | Purpose is a constant set to 44' (or 0x8000002C) following the
--   original BIP-44 specification.
--   
--   It indicates that the subtree of this node is used according to this
--   specification.
--   
--   Hardened derivation is used at this level.
purposeBIP44 :: Index 'Hardened 'PurposeK

-- | Purpose is a constant set to 1852' (or 0x8000073c) following the
--   BIP-44 extension for Cardano:
--   
--   
--   <a>https://github.com/input-output-hk/implementation-decisions/blob/e2d1bed5e617f0907bc5e12cf1c3f3302a4a7c42/text/1852-hd-chimeric.md</a>
--   
--   It indicates that the subtree of this node is used according to this
--   specification.
--   
--   Hardened derivation is used at this level.
purposeCIP1852 :: Index 'Hardened 'PurposeK

-- | One master node (seed) can be used for unlimited number of independent
--   cryptocoins such as Bitcoin, Litecoin or Namecoin. However, sharing
--   the same space for various cryptocoins has some disadvantages.
--   
--   This level creates a separate subtree for every cryptocoin, avoiding
--   reusing addresses across cryptocoins and improving privacy issues.
--   
--   Coin type is a constant, set for each cryptocoin. For Cardano this
--   constant is set to 1815' (or 0x80000717). 1815 is the birthyear of our
--   beloved Ada Lovelace.
--   
--   Hardened derivation is used at this level.
coinTypeAda :: Index 'Hardened 'CoinTypeK

-- | Construct a Sequential state for a wallet from root private key and
--   password.
mkSeqStateFromRootXPrv :: forall n k. (WalletKey k, SupportsDiscovery n k, (k == SharedKey) ~ 'False) => (k 'RootK XPrv, Passphrase "encryption") -> Index 'Hardened 'PurposeK -> AddressPoolGap -> SeqState n k

-- | Construct a Sequential state for a wallet from public account key.
mkSeqStateFromAccountXPub :: forall (n :: NetworkDiscriminant) k. (SupportsDiscovery n k, (k == SharedKey) ~ 'False) => k 'AccountK XPub -> Maybe (k 'PolicyK XPub) -> Index 'Hardened 'PurposeK -> AddressPoolGap -> SeqState n k

-- | Discover addresses and transactions using an efficient query <tt>addr
--   -&gt; m txs</tt>. Does <i>not</i> take <a>RewardAccount</a> into
--   account.
discoverSeq :: forall n k m. (PaymentAddress n k, Monad m) => (Either Address RewardAccount -> m ChainEvents) -> SeqState n k -> m (ChainEvents, SeqState n k)

-- | Discover addresses and transactions using an efficient query <tt>addr
--   -&gt; m txs</tt>. Does take <a>RewardAccount</a> into account.
discoverSeqWithRewards :: forall n k m. (DelegationAddress n k, ToRewardAccount k, Monad m) => (Either Address RewardAccount -> m ChainEvents) -> SeqState n k -> m (ChainEvents, SeqState n k)

-- | An "unsound" alternative that can be used for benchmarking and stress
--   testing. It re-uses the same underlying structure as the
--   <a>SeqState</a> but it discovers addresses based on an arbitrary ratio
--   instead of respecting BIP-44 discovery.
--   
--   The proportion is stored as a type-level parameter so that we don't
--   have to alter the database schema to store it. It simply exists and
--   depends on the caller creating the wallet to define it.
newtype SeqAnyState (network :: NetworkDiscriminant) key (p :: Nat)
SeqAnyState :: SeqState network key -> SeqAnyState (network :: NetworkDiscriminant) key (p :: Nat)
[innerState] :: SeqAnyState (network :: NetworkDiscriminant) key (p :: Nat) -> SeqState network key

-- | Initialize the HD random address discovery state from a root key and
--   RNG seed.
--   
--   The type parameter is expected to be a ratio of addresses we ought to
--   simply recognize as ours. It is expressed in per-myriad, so "1" means
--   0.01%, "100" means 1% and 10000 means 100%.
mkSeqAnyState :: forall (p :: Nat) n k. (SupportsDiscovery n k, WalletKey k, (k == SharedKey) ~ 'False) => (k 'RootK XPrv, Passphrase "encryption") -> Index 'Hardened 'PurposeK -> AddressPoolGap -> SeqAnyState n k p
instance GHC.Classes.Ord Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Sequential.MkAddressPoolGapError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Sequential.MkAddressPoolGapError
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAddressPool c key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAddressPool c key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState network key p)
instance (GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.PolicyK Cardano.Crypto.Wallet.XPub), GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint "payment" k)) => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance (GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.PolicyK Cardano.Crypto.Wallet.XPub), GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint "payment" k)) => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p)
instance (Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.PolicyK Cardano.Crypto.Wallet.XPub), Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint "payment" k)) => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p)
instance GHC.TypeNats.KnownNat p => Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p) Cardano.Wallet.Primitive.Types.Address.Address
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p) Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance (Cardano.Wallet.Primitive.AddressDerivation.AddressIndexDerivationType k GHC.Types.~ 'Cardano.Wallet.Primitive.AddressDerivation.Soft, GHC.TypeNats.KnownNat p) => Cardano.Wallet.Primitive.AddressDiscovery.IsOwned (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p) k
instance Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation k => Cardano.Wallet.Primitive.AddressDiscovery.GenChange (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p)
instance Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SupportsDiscovery n k => Cardano.Wallet.Primitive.AddressDiscovery.CompareDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p)
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress n k => Cardano.Wallet.Primitive.AddressDiscovery.KnownAddresses (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p)
instance Cardano.Wallet.Primitive.AddressDiscovery.MaybeLight (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p)
instance (Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.PolicyK Cardano.Crypto.Wallet.XPub), Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint "payment" k)) => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance (GHC.Classes.Eq (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub), GHC.Classes.Eq (k 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub), GHC.Classes.Eq (k 'Cardano.Wallet.Primitive.AddressDerivation.PolicyK Cardano.Crypto.Wallet.XPub), GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.KeyFingerprint "payment" k)) => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SupportsDiscovery n k => Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) Cardano.Wallet.Primitive.Types.Address.Address
instance Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation k => Cardano.Wallet.Primitive.AddressDiscovery.GenChange (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance (Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) Cardano.Wallet.Primitive.Types.Address.Address, Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SupportsDiscovery n k, Cardano.Wallet.Primitive.AddressDerivation.AddressIndexDerivationType k GHC.Types.~ 'Cardano.Wallet.Primitive.AddressDerivation.Soft) => Cardano.Wallet.Primitive.AddressDiscovery.IsOwned (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) k
instance Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SupportsDiscovery n k => Cardano.Wallet.Primitive.AddressDiscovery.CompareDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress n k => Cardano.Wallet.Primitive.AddressDiscovery.KnownAddresses (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)
instance Cardano.Wallet.Primitive.AddressDiscovery.GetAccount (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) k
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAddressPool c k)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAddressPool c k)
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance GHC.Enum.Enum Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (key 'Cardano.Wallet.Primitive.AddressDerivation.AccountK) => Formatting.Buildable.Buildable (key 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (key 'Cardano.Wallet.Primitive.AddressDerivation.PolicyK) => Formatting.Buildable.Buildable (key 'Cardano.Wallet.Primitive.AddressDerivation.PolicyK Cardano.Crypto.Wallet.XPub)
instance Formatting.Buildable.Buildable (Cardano.Address.Script.ScriptTemplate, GHC.Maybe.Maybe Cardano.Address.Script.ScriptTemplate)
instance Formatting.Buildable.Buildable Cardano.Address.Script.ScriptTemplate


-- | An implementation of shared script state using scheme specified in
--   CIP-1854 Multi-signature Wallets.
module Cardano.Wallet.Primitive.AddressDiscovery.Shared

-- | Convenient alias for commonly used class contexts on keys.
type SupportsDiscovery (n :: NetworkDiscriminant) k = (MkKeyFingerprint k (Proxy n, k 'AddressK XPub), MkKeyFingerprint k Address, SoftDerivation k, Typeable n)

-- | Shared wallet is a new kind of wallet owned by one or more co-signers.
--   In this type of the wallet, addresses are defined by two monetary
--   scripts (one for the ownership of assets and the other one for the
--   ownership of stake). The two scripts can be the same, different, also
--   the script for the ownership of stake can be absent.
--   
--   The shared wallet can be in two states: pending or ready. In a pending
--   state the wallet does not have account public keys for all co-signers,
--   and hence discovery of script addresses co-shared with other
--   co-signers is not possible. In a ready state the wallet has account
--   public keys for all co-signers and co-shared script address discovery
--   is possible.
--   
--   The shared wallet is instantiated with an account public key,
--   derivation path needed to recreate it for a holder of this shared
--   wallet, ie., one of the co-signers. In order to construct correctly
--   the wallet, ie., enable co-shared script addresses discovery the
--   following is needed:
--   
--   <ul>
--   <li>a way to determine what range of indices are checked on the
--   ledger. Mechanism of address pool, also adopted for sequential
--   wallets, is used. The idea is to track all indices starting from 0 and
--   up to N. N is variable as addresses are discovered (and marked as Used
--   in consequence). The pool of addresses is enlarged in such way that
--   the number of consecutive Unused addresses equals to address pool gap
--   of the address pool. Hence, the address pool gap needs to be
--   specified.</li>
--   <li>script template for payment credential contains information about
--   all collected account public keys for all parties engaged, here named
--   co-signers. Also the skeleton determining script structure is
--   provided. In this sense script is predetermined from the beginning and
--   can variate only in verification key part that replaces co-signers in
--   the script skeleton. The places where a specific cosigner is present
--   is to be replaced with the derived verification key using the
--   co-signer's account public key and the index that was chosen. This is
--   the reason why we need complete set of account public keys for each
--   co-signer to realize address discovery. The script template can be
--   translated into a corresponding script, which hash is used in the
--   address, only when account public keys for all cosigners specified in
--   script are collected.The index for derivation is the same for each
--   cosigner's derivation. The same index is used in both scripts that
--   represent payment or delegation credential. Verification keys are
--   derived using role=3 for payment credential.</li>
--   <li>optional script template for delegation credential contains all
--   information as in case of the script template for payment credential.
--   One difference is that the verification keys are derived using role=4
--   for delegation credential.</li>
--   </ul>
--   
--   When both script are present, the base address (with both credentials)
--   is expected to be discovered. When script template for delegation
--   credential is missing then enterprise address (non-stakable) is
--   expected.
data SharedState (n :: NetworkDiscriminant) k
SharedState :: !DerivationPrefix -> !k 'AccountK XPub -> !ScriptTemplate -> !Maybe ScriptTemplate -> !AddressPoolGap -> !Readiness (SharedAddressPools k) -> SharedState (n :: NetworkDiscriminant) k

-- | Derivation path prefix from a root key up to the account key
[derivationPrefix] :: SharedState (n :: NetworkDiscriminant) k -> !DerivationPrefix

-- | The account public key of an initiator of the shared wallet
[accountXPub] :: SharedState (n :: NetworkDiscriminant) k -> !k 'AccountK XPub

-- | Script template together with a map of account keys and cosigners for
--   payment credential.
[paymentTemplate] :: SharedState (n :: NetworkDiscriminant) k -> !ScriptTemplate

-- | Script template together with a map of account keys and cosigners for
--   staking credential. If not specified then the same template as for
--   payment is used.
[delegationTemplate] :: SharedState (n :: NetworkDiscriminant) k -> !Maybe ScriptTemplate

-- | Address pool gap to be used in the address pool of shared state
[poolGap] :: SharedState (n :: NetworkDiscriminant) k -> !AddressPoolGap

-- | Readiness status of the shared state. The state is ready if all
--   cosigner public keys have been obtained. In this case, an address pool
--   is allocated
[ready] :: SharedState (n :: NetworkDiscriminant) k -> !Readiness (SharedAddressPools k)

-- | Readiness status of the shared state.
data Readiness a
Pending :: Readiness a
Active :: !a -> Readiness a
data SharedAddressPools (key :: Depth -> Type -> Type)
SharedAddressPools :: !SharedAddressPool 'UtxoExternal key -> !SharedAddressPool 'UtxoInternal key -> !PendingIxs 'ScriptK -> SharedAddressPools (key :: Depth -> Type -> Type)
[externalPool] :: SharedAddressPools (key :: Depth -> Type -> Type) -> !SharedAddressPool 'UtxoExternal key
[internalPool] :: SharedAddressPools (key :: Depth -> Type -> Type) -> !SharedAddressPool 'UtxoInternal key
[pendingChangeIxs] :: SharedAddressPools (key :: Depth -> Type -> Type) -> !PendingIxs 'ScriptK

-- | An address pool which keeps track of shared addresses. To create a new
--   pool, see <a>newSharedAddressPool</a>.
newtype SharedAddressPool (c :: Role) (key :: Depth -> Type -> Type)
SharedAddressPool :: Pool (KeyFingerprint "payment" key) (Index 'Soft 'ScriptK) -> SharedAddressPool (c :: Role) (key :: Depth -> Type -> Type)
[getPool] :: SharedAddressPool (c :: Role) (key :: Depth -> Type -> Type) -> Pool (KeyFingerprint "payment" key) (Index 'Soft 'ScriptK)

-- | Create a new shared address pool from complete script templates.
newSharedAddressPool :: forall (n :: NetworkDiscriminant) c key. (key ~ SharedKey, SupportsDiscovery n key, Typeable c) => AddressPoolGap -> ScriptTemplate -> Maybe ScriptTemplate -> SharedAddressPool c key

-- | Possible errors from adding a co-signer key to the shared wallet
--   state.
data ErrAddCosigner

-- | Adding key for a cosigner for a non-existent delegation template is
--   not allowed.
NoDelegationTemplate :: ErrAddCosigner

-- | Adding key for a cosigners for a given script is possible for the
--   cosigner present in the script template.
NoSuchCosigner :: CredentialType -> Cosigner -> ErrAddCosigner

-- | Adding the same key for different cosigners for a given script is not
--   allowed.
KeyAlreadyPresent :: CredentialType -> ErrAddCosigner

-- | Adding is possible only to pending shared wallet.
WalletAlreadyActive :: ErrAddCosigner

-- | Updating key is possible only for other cosigners, not cosigner
--   belonging to the shared wallet.
CannotUpdateSharedWalletKey :: ErrAddCosigner
data ErrScriptTemplate
ErrScriptTemplateInvalid :: !CredentialType -> !ErrValidateScriptTemplate -> ErrScriptTemplate
ErrScriptTemplateMissingKey :: !CredentialType -> !Text -> ErrScriptTemplate

-- | Create a new SharedState from public account key.
mkSharedStateFromAccountXPub :: (SupportsDiscovery n k, WalletKey k, k ~ SharedKey) => k 'AccountK XPub -> Index 'Hardened 'AccountK -> AddressPoolGap -> ScriptTemplate -> Maybe ScriptTemplate -> SharedState n k

-- | Create a new SharedState from root private key and password.
mkSharedStateFromRootXPrv :: (SupportsDiscovery n k, WalletKey k, k ~ SharedKey) => (k 'RootK XPrv, Passphrase "encryption") -> Index 'Hardened 'AccountK -> AddressPoolGap -> ScriptTemplate -> Maybe ScriptTemplate -> SharedState n k

-- | The cosigner with his account public key is updated per template.
--   
--   For each template the script is checked for presence of the cosigner:
--   * If present, then the key is inserted into the state. * Otherwise,
--   fail with <a>NoSuchCosigner</a>. If the key is already present it is
--   going to be updated. For a given template all keys must be unique. If
--   already present key is tried to be added, <a>KeyAlreadyPresent</a>
--   error is produced. The updating works only with pending shared state,
--   
--   When an active shared state is used <a>WalletAlreadyActive</a> error
--   is triggered.
--   
--   Updating the key for delegation script can be successful only if
--   delegation script is present. Otherwise, <a>NoDelegationTemplate</a>
--   error is triggered.
addCosignerAccXPub :: (SupportsDiscovery n k, WalletKey k, k ~ SharedKey) => (Cosigner, k 'AccountK XPub) -> CredentialType -> SharedState n k -> Either ErrAddCosigner (SharedState n k)
isShared :: SupportsDiscovery n k => Address -> SharedState n k -> (Maybe (Index 'Soft 'ScriptK), SharedState n k)
retrieveAllCosigners :: Script Cosigner -> [Cosigner]
validateScriptTemplates :: WalletKey k => k 'AccountK XPub -> ValidationLevel -> ScriptTemplate -> Maybe ScriptTemplate -> Either ErrScriptTemplate ()
toSharedWalletId :: (WalletKey k, k ~ SharedKey) => k 'AccountK XPub -> ScriptTemplate -> Maybe ScriptTemplate -> Digest Blake2b_160
data CredentialType
Payment :: CredentialType
Delegation :: CredentialType
liftPaymentAddress :: forall (n :: NetworkDiscriminant) (k :: Depth -> Type -> Type). Typeable n => KeyFingerprint "payment" k -> Address
liftDelegationAddress :: forall (n :: NetworkDiscriminant) (k :: Depth -> Type -> Type). Typeable n => Index 'Soft 'ScriptK -> ScriptTemplate -> KeyFingerprint "payment" k -> Address
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedAddressPool c key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedAddressPool c key)
instance GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedAddressPools key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedAddressPools key)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Shared.Readiness a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Shared.Readiness a)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Shared.Readiness a)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.AddressDiscovery.Shared.CredentialType
instance GHC.Generics.Generic Cardano.Wallet.Primitive.AddressDiscovery.Shared.CredentialType
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Shared.CredentialType
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Shared.CredentialType
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Shared.ErrScriptTemplate
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Shared.ErrScriptTemplate
instance GHC.Show.Show Cardano.Wallet.Primitive.AddressDiscovery.Shared.ErrAddCosigner
instance GHC.Classes.Eq Cardano.Wallet.Primitive.AddressDiscovery.Shared.ErrAddCosigner
instance GHC.Show.Show (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub) => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k)
instance Data.Text.Class.ToText Cardano.Wallet.Primitive.AddressDiscovery.Shared.CredentialType
instance Data.Text.Class.FromText Cardano.Wallet.Primitive.AddressDiscovery.Shared.CredentialType
instance Control.DeepSeq.NFData (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub) => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k)
instance GHC.Classes.Eq (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK Cardano.Crypto.Wallet.XPub) => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (k 'Cardano.Wallet.Primitive.AddressDerivation.AccountK) => Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k)
instance Cardano.Wallet.Primitive.AddressDiscovery.Shared.SupportsDiscovery n k => Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k) Cardano.Wallet.Primitive.Types.Address.Address
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k) Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Cardano.Wallet.Primitive.AddressDiscovery.GetAccount (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k) k
instance Cardano.Wallet.Primitive.AddressDiscovery.Shared.SupportsDiscovery n k => Cardano.Wallet.Primitive.AddressDiscovery.CompareDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k)
instance Data.Typeable.Internal.Typeable n => Cardano.Wallet.Primitive.AddressDiscovery.KnownAddresses (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k)
instance Cardano.Wallet.Primitive.AddressDiscovery.MaybeLight (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k)
instance Cardano.Wallet.Primitive.AddressDiscovery.GenChange (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n k)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Shared.Readiness a)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedAddressPools key)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedAddressPools key)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedAddressPools key)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedAddressPool c k)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedAddressPool c k)
instance Data.Text.Class.ToText Cardano.Address.Script.ErrValidateScriptTemplate


-- | Implementation of address derivation for <tt>Shelley</tt> Keys.
module Cardano.Wallet.Primitive.AddressDerivation.Shelley

-- | A cryptographic key for Shelley address derivation, with phantom-types
--   to disambiguate derivation paths
--   
--   <pre>
--   let rootPrivateKey = ShelleyKey 'RootK XPrv
--   let accountPubKey = ShelleyKey 'AccountK XPub
--   let addressPubKey = ShelleyKey 'AddressK XPub
--   </pre>
newtype ShelleyKey (depth :: Depth) key
ShelleyKey :: key -> ShelleyKey (depth :: Depth) key
[getKey] :: ShelleyKey (depth :: Depth) key -> key

-- | The minimum seed length for <a>generateKeyFromSeed</a> and
--   <a>unsafeGenerateKeyFromSeed</a>.
minSeedLengthBytes :: Int

-- | Generate a root key from a corresponding seed. The seed should be at
--   least 16 bytes.
generateKeyFromSeed :: (SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> ShelleyKey 'RootK XPrv

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: (SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> ShelleyKey depth XPrv
unsafeGenerateKeyFromSeedShelley :: (SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> XPrv
deriveAccountPrivateKeyShelley :: Index 'Hardened 'PurposeK -> Passphrase "encryption" -> XPrv -> Index 'Hardened 'AccountK -> XPrv
deriveAddressPrivateKeyShelley :: Enum a => Passphrase "encryption" -> XPrv -> a -> Index derivationType level -> XPrv
deriveAddressPublicKeyShelley :: Enum a => XPub -> a -> Index derivationType level -> XPub
toRewardAccountRaw :: XPub -> RewardAccount
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey depth key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey depth key)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey depth key)
instance Cardano.Wallet.Primitive.AddressDerivation.HardDerivation Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.WalletKey Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDiscovery.GetPurpose Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress ('Cardano.Wallet.Primitive.AddressDerivation.Testnet pm) Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.DelegationAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.DelegationAddress ('Cardano.Wallet.Primitive.AddressDerivation.Testnet pm) Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey Cardano.Wallet.Primitive.Types.Address.Address
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey (Data.Proxy.Proxy n, Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub)
instance Cardano.Wallet.Primitive.AddressDerivation.BoundedAddressLength Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey) Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Cardano.Wallet.Primitive.AddressDerivation.ToRewardAccount Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey
instance Cardano.Wallet.Primitive.AddressDerivation.DelegationAddress n Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey => Cardano.Wallet.Primitive.AddressDiscovery.MaybeLight (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPrivateKey (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey 'Cardano.Wallet.Primitive.AddressDerivation.RootK)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (Cardano.Wallet.Primitive.AddressDerivation.Shelley.ShelleyKey depth)


-- | Implementation of address derivation for <tt>Shared</tt> Keys.
module Cardano.Wallet.Primitive.AddressDerivation.Shared

-- | A cryptographic key for Shared address derivation, with phantom-types
--   to disambiguate derivation paths
--   
--   <pre>
--   let rootPrivateKey = SharedKey 'RootK XPrv
--   let accountPubKey = SharedKey 'AccountK XPub
--   let addressPubKey = SharedKey 'AddressK XPub
--   </pre>
newtype SharedKey (depth :: Depth) key
SharedKey :: key -> SharedKey (depth :: Depth) key
[getKey] :: SharedKey (depth :: Depth) key -> key

-- | Generate a root key from a corresponding seed. The seed should be at
--   least 16 bytes.
generateKeyFromSeed :: (SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> SharedKey 'RootK XPrv

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: (SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> SharedKey depth XPrv

-- | Purpose for shared wallets is a constant set to 1854' (or 0x8000073E)
--   following the original CIP-1854 Multi-signature Wallets.
--   
--   It indicates that the subtree of this node is used according to this
--   specification.
--   
--   Hardened derivation is used at this level.
purposeCIP1854 :: Index 'Hardened 'PurposeK
instance Cardano.Wallet.Primitive.AddressDerivation.HardDerivation Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey
instance Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey
instance Cardano.Wallet.Primitive.AddressDerivation.WalletKey Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey
instance Cardano.Wallet.Primitive.AddressDiscovery.GetPurpose Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPrivateKey (Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey 'Cardano.Wallet.Primitive.AddressDerivation.RootK)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey depth)
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey Cardano.Wallet.Primitive.Types.Address.Address
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey (Data.Proxy.Proxy n, Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub)
instance Cardano.Wallet.Primitive.AddressDerivation.BoundedAddressLength Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey


-- | Address books consist of a <a>Prologue</a> and discovered addresses
--   (<a>Discoveries</a>).
module Cardano.Wallet.Address.Book

-- | FIXME LATER during ADP-1043: Move <a>Prologue</a> and
--   <a>Discoveries</a> closer into address types.
class (Eq (Prologue s), Eq (Discoveries s)) => AddressBookIso s where {
    
    -- | Address information contained in the prologue of the address book,
    --   such as public keys or the address gap.
    data family Prologue s :: Type;
    
    -- | Addresses that were collected during discovery on the blockchain.
    data family Discoveries s :: Type;
}

-- | Isomorphism between the address book type <tt>s</tt> and its two
--   components.
addressIso :: AddressBookIso s => Iso' s (Prologue s, Discoveries s)
getPrologue :: AddressBookIso s => s -> Prologue s
getDiscoveries :: AddressBookIso s => s -> Discoveries s

-- | Address data from sequential address pool. The phantom type parameter
--   <tt>c</tt> prevents mixing up the internal with the external pool.
newtype SeqAddressMap (c :: Role) (key :: Depth -> Type -> Type)
SeqAddressMap :: Map (KeyFingerprint "payment" key) (Index 'Soft 'AddressK, AddressState) -> SeqAddressMap (c :: Role) (key :: Depth -> Type -> Type)
newtype SharedAddressMap (c :: Role) (key :: Depth -> Type -> Type)
SharedAddressMap :: Map (KeyFingerprint "payment" key) (Index 'Soft 'ScriptK, AddressState) -> SharedAddressMap (c :: Role) (key :: Depth -> Type -> Type)
instance GHC.Classes.Eq (Cardano.Wallet.Address.Book.SeqAddressMap c key)
instance GHC.Classes.Eq (Cardano.Wallet.Address.Book.SharedAddressMap c key)
instance (key GHC.Types.~ Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey) => Cardano.Wallet.Address.Book.AddressBookIso (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n key)
instance ((key Data.Type.Equality.== Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey) GHC.Types.~ 'GHC.Types.False, GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n key)) => Cardano.Wallet.Address.Book.AddressBookIso (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n key)
instance ((key Data.Type.Equality.== Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey) GHC.Types.~ 'GHC.Types.False, GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n key)) => Cardano.Wallet.Address.Book.AddressBookIso (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n key p)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) => GHC.Classes.Eq (Cardano.Wallet.Address.Book.Prologue (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p))
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) => GHC.Classes.Eq (Cardano.Wallet.Address.Book.Discoveries (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p))
instance Formatting.Buildable.Buildable (Cardano.Wallet.Address.Book.Prologue (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k))
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) => GHC.Classes.Eq (Cardano.Wallet.Address.Book.Prologue (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k))
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k) => GHC.Classes.Eq (Cardano.Wallet.Address.Book.Discoveries (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k))
instance (key GHC.Types.~ Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey) => Formatting.Buildable.Buildable (Cardano.Wallet.Address.Book.Prologue (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n key))
instance (key GHC.Types.~ Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey) => GHC.Classes.Eq (Cardano.Wallet.Address.Book.Prologue (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n key))
instance (key GHC.Types.~ Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey) => GHC.Classes.Eq (Cardano.Wallet.Address.Book.Discoveries (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n key))
instance Cardano.Wallet.Address.Book.AddressBookIso (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p)
instance GHC.Classes.Eq (Cardano.Wallet.Address.Book.Prologue (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p))
instance GHC.Classes.Eq (Cardano.Wallet.Address.Book.Discoveries (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p))
instance Cardano.Wallet.Address.Book.AddressBookIso (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Address.Book.Prologue (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n))
instance GHC.Classes.Eq (Cardano.Wallet.Address.Book.Prologue (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n))
instance GHC.Classes.Eq (Cardano.Wallet.Address.Book.Discoveries (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n))


-- | Implementation of address derivation for <tt>Icarus</tt> keys. This
--   uses the Byron derivation for addresses, but on top of the derivation
--   scheme V2.
module Cardano.Wallet.Primitive.AddressDerivation.Icarus

-- | A cryptographic key for sequential-scheme address derivation, with
--   phantom-types to disambiguate key types.
--   
--   <pre>
--   let rootPrivateKey = IcarusKey 'RootK XPrv
--   let accountPubKey = IcarusKey 'AccountK XPub
--   let addressPubKey = IcarusKey 'AddressK XPub
--   </pre>
newtype IcarusKey (depth :: Depth) key
IcarusKey :: key -> IcarusKey (depth :: Depth) key
[getKey] :: IcarusKey (depth :: Depth) key -> key

-- | Generate a root key from a corresponding seed. The seed should be at
--   least 16 bytes.
generateKeyFromSeed :: SomeMnemonic -> Passphrase "encryption" -> IcarusKey 'RootK XPrv

-- | Hardware Ledger devices generates keys from mnemonic using a different
--   approach (different from the rest of Cardano).
--   
--   It is a combination of:
--   
--   <ul>
--   <li><a>SLIP 0010</a></li>
--   <li><a>BIP 0032</a></li>
--   <li><a>BIP 0039</a></li>
--   <li><a>RFC 8032</a></li>
--   <li>What seems to be arbitrary changes from Ledger regarding the
--   calculation of the initial chain code and generation of the root
--   private key.</li>
--   </ul>
generateKeyFromHardwareLedger :: SomeMnemonic -> Passphrase "encryption" -> IcarusKey 'RootK XPrv

-- | Generate a new key from seed. Note that the <tt>depth</tt> is left
--   open so that the caller gets to decide what type of key this is. This
--   is mostly for testing, in practice, seeds are used to represent root
--   keys, and one should use <a>generateKeyFromSeed</a>.
unsafeGenerateKeyFromSeed :: SomeMnemonic -> Passphrase "encryption" -> IcarusKey depth XPrv

-- | The minimum seed length for <a>generateKeyFromSeed</a> and
--   <a>unsafeGenerateKeyFromSeed</a>.
minSeedLengthBytes :: Int
instance GHC.Classes.Eq key => GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey depth key)
instance GHC.Show.Show key => GHC.Show.Show (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey depth key)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey depth key)
instance Control.DeepSeq.NFData key => Control.DeepSeq.NFData (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey depth key)
instance Cardano.Wallet.Primitive.AddressDerivation.HardDerivation Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDerivation.WalletKey Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDiscovery.GetPurpose Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance GHC.TypeNats.KnownNat pm => Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress ('Cardano.Wallet.Primitive.AddressDerivation.Testnet pm) Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey Cardano.Wallet.Primitive.Types.Address.Address
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress n Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey => Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey (Data.Proxy.Proxy n, Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Crypto.Wallet.XPub)
instance Cardano.Wallet.Primitive.AddressDiscovery.IsOurs (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey) Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress n Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey => Cardano.Wallet.Primitive.AddressDiscovery.MaybeLight (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey)
instance Cardano.Wallet.Primitive.AddressDerivation.BoundedAddressLength Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPrivateKey (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey 'Cardano.Wallet.Primitive.AddressDerivation.RootK)
instance Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (Cardano.Wallet.Primitive.AddressDerivation.Icarus.IcarusKey depth)


-- | Provides various <a>Address</a> constants used by the wallet or its
--   tests.
module Cardano.Wallet.Primitive.Types.Address.Constants

-- | A dummy <a>Address</a> of the greatest length that the wallet can
--   generate.
--   
--   Please note that this address should:
--   
--   <ul>
--   <li>never be used for anything besides its length and validity
--   properties.</li>
--   <li>never be used as a payment target within a real transaction.</li>
--   </ul>
maxLengthAddress :: Address

-- | A dummy <a>Address</a> of the shortest length that the wallet can
--   generate.
--   
--   Please note that this address should:
--   
--   <ul>
--   <li>never be used for anything besides its length and validity
--   properties.</li>
--   <li>never be used as a payment target within a real transaction.</li>
--   </ul>
minLengthAddress :: Address


-- | This module contains functions for incrementally constructing a
--   selection to be included in a migration plan.
--   
--   A selection is the basis for a single transaction.
--   
--   Use <a>create</a> to create a selection with one or more inputs. Use
--   <a>extend</a> to extend a selection with an additional input.
module Cardano.Wallet.Primitive.Migration.Selection

-- | A selection is the basis for a single transaction.
--   
--   Use <a>create</a> to create a selection with one or more inputs. Use
--   <a>extend</a> to extend a selection with an additional input. Use
--   <a>verify</a> to verify the correctness of a selection.
data Selection input
Selection :: !NonEmpty input -> !TokenBundle -> !NonEmpty TokenBundle -> !Coin -> !Coin -> !TxSize -> !Coin -> Selection input

-- | The selected inputs.
[$sel:inputIds:Selection] :: Selection input -> !NonEmpty input

-- | The total balance of value provided by the inputs.
[$sel:inputBalance:Selection] :: Selection input -> !TokenBundle

-- | The outputs, adjusted to pay for the fee.
[$sel:outputs:Selection] :: Selection input -> !NonEmpty TokenBundle

-- | The actual fee payable for this selection.
[$sel:fee:Selection] :: Selection input -> !Coin

-- | The excess over the minimum permissible fee for this selection.
[$sel:feeExcess:Selection] :: Selection input -> !Coin

-- | The size of this selection.
[$sel:size:Selection] :: Selection input -> !TxSize

-- | The reward withdrawal amount, if any.
[$sel:rewardWithdrawal:Selection] :: Selection input -> !Coin

-- | Indicates a failure to create or extend a selection.
data SelectionError

-- | Indicates that the desired selection would not have enough ada to pay
--   for the minimum permissible fee.
SelectionAdaInsufficient :: SelectionError

-- | Indicates that the desired selection would exceed the maximum
--   selection size.
SelectionFull :: SelectionFullError -> SelectionError
data SelectionFullError
SelectionFullError :: TxSize -> TxSize -> SelectionFullError
[$sel:selectionSizeMaximum:SelectionFullError] :: SelectionFullError -> TxSize
[$sel:selectionSizeRequired:SelectionFullError] :: SelectionFullError -> TxSize
newtype RewardWithdrawal
RewardWithdrawal :: Coin -> RewardWithdrawal
[$sel:unRewardWithdrawal:RewardWithdrawal] :: RewardWithdrawal -> Coin

-- | Creates a selection with the given inputs.
--   
--   Guarantees the following property for a returned selection <tt>s</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; verify s == SelectionCorrect
--   </pre>
--   
--   Returns <a>SelectionAdaInsufficient</a> if the desired selection would
--   not have enough ada to pay for the fee.
--   
--   Returns <a>SelectionFull</a> if the desired selection would exceed the
--   maximum selection size.
create :: TxConstraints -> RewardWithdrawal -> NonEmpty (input, TokenBundle) -> Either SelectionError (Selection input)

-- | Extends a selection with an additional input.
--   
--   Guarantees the following property for a returned selection <tt>s</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; verify s == SelectionCorrect
--   </pre>
--   
--   Returns <a>SelectionAdaInsufficient</a> if the desired selection would
--   not have enough ada to pay for the fee.
--   
--   Returns <a>SelectionFull</a> if the desired selection would exceed the
--   maximum selection size.
extend :: TxConstraints -> Selection input -> (input, TokenBundle) -> Either SelectionError (Selection input)

-- | Balances the fee for a given selection.
--   
--   The ada quantities of the outputs are maximized in order to minimize
--   the fee excess.
--   
--   Pre-condition: outputs have minimal ada quantities.
--   
--   Guarantees the following property for a returned selection <tt>s</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; verify s == SelectionCorrect
--   </pre>
balance :: TxConstraints -> Selection input -> Either SelectionError (Selection input)

-- | Adds value (obtained from an input) to an existing set of output maps.
--   
--   This function attempts to merge the given value into one of the
--   existing output maps. If merging is successful, then the returned
--   output map list will be identical in length and content to the
--   original output map list, except for the merged output.
--   
--   If the given value cannot be merged into one of the existing output
--   maps (because it would cause an output to exceed the output size
--   limit), then this function appends the given output map to the given
--   output map list, effectively creating a new output.
--   
--   Pre-condition: all output maps in the given list must be within the
--   output size limit.
--   
--   Assuming the above pre-condition is met, this function guarantees that
--   all output maps in the returned list will also be within the output
--   size limit.
addValueToOutputs :: TxConstraints -> [TokenMap] -> TokenMap -> NonEmpty TokenMap

-- | Minimizes the given fee excess by adding ada to the given output
--   bundles.
--   
--   This function:
--   
--   <ul>
--   <li>guarantees to leave all non-ada quantities unchanged.</li>
--   <li>guarantees to not change the length of the list.</li>
--   <li>guarantees that each resulting output bundle will have an ada
--   quantity that is greater than or equal to its original ada
--   quantity.</li>
--   <li>guarantees that the resulting fee excess will be less than or
--   equal to the original fee excess.</li>
--   <li>does not check that the given ada quantities are above the minimum
--   required for each output, and therefore only guarantees that the
--   resulting ada quantities will be above the minimum required if the
--   caller makes this guarantee for the original output bundles.</li>
--   </ul>
--   
--   This function aims to adjust as few output bundles as possible, and in
--   the ideal case, will increase the ada quantity of just one output
--   bundle.
--   
--   Increasing the ada quantity of an output may increase the overall cost
--   of that output, as increasing an ada quantity may increase the length
--   of the binary representation used to encode that quantity.
--   
--   By maximizing the ada increase of a single output, and minimizing the
--   ada increases of the remaining outputs, we can minimize the cost
--   increase of the overall selection, and therefore maximize the chance
--   of being able to pay for the selection.
--   
--   This is a consequence of the following mathematical relationship:
--   
--   Consider a non-negative integer constant <tt>a</tt> defined in terms
--   of a summation of a fixed number <tt>n</tt> of non-negative integer
--   variables:
--   
--   <pre>
--   &gt;&gt;&gt; a = a1 + a2 + a3 + ... + an
--   </pre>
--   
--   Now consider the total space <tt>s</tt> required to encode all of the
--   variables:
--   
--   <pre>
--   &gt;&gt;&gt; s = length a1 + length a2 + length a3 + ... + length an
--   </pre>
--   
--   For any given number base, we can get close to the minimal value of
--   <tt>s</tt> by making the following assignments:
--   
--   <pre>
--   &gt;&gt;&gt; a1 := a
--   
--   &gt;&gt;&gt; a2 := 0
--   
--   &gt;&gt;&gt; a3 := 0
--   
--   &gt;&gt;&gt; ...
--   
--   &gt;&gt;&gt; an := 0
--   </pre>
--   
--   Consider the following example, working in base 10:
--   
--   <pre>
--   &gt;&gt;&gt; a = 999
--   
--   &gt;&gt;&gt; n = 9
--   </pre>
--   
--   If we were to use a flat distribution, where the constant is
--   partitioned into <tt>n</tt> equal quantities (modulo rounding), our
--   space cost <tt>s</tt> would be:
--   
--   <pre>
--   &gt;&gt;&gt; s = length  a1 + length  a2 + length  a3 + ... + length  a9
--   
--   &gt;&gt;&gt; s = length 111 + length 111 + length 111 + ... + length 111
--   
--   &gt;&gt;&gt; s =          3 +          3 +          3 + ... +          3
--   
--   &gt;&gt;&gt; s =          3 Ã— 9
--   
--   &gt;&gt;&gt; s = 27
--   </pre>
--   
--   But by maximizing <tt>a1</tt> and minimizing the remaining variables,
--   we can obtain the following smaller space cost:
--   
--   <pre>
--   &gt;&gt;&gt; s = length  a1 + length  a2 + length  a3 + ... + length  a9
--   
--   &gt;&gt;&gt; s = length 999 + length   0 + length   0 + ... + length   0
--   
--   &gt;&gt;&gt; s =          3 +          1 +          1 + ... +          1
--   
--   &gt;&gt;&gt; s =          3 +          8
--   
--   &gt;&gt;&gt; s = 11
--   </pre>
minimizeFee :: TxConstraints -> (Coin, NonEmpty TokenBundle) -> (Coin, NonEmpty TokenBundle)

-- | Minimizes the given fee excess by adding ada to the given output.
--   
--   This function:
--   
--   <ul>
--   <li>guarantees to leave all non-ada quantities unchanged.</li>
--   <li>increases the ada quantity of the given output until it is no
--   longer economically worthwhile to increase it further (i.e., if the
--   cost of a further increase would be greater than the increase
--   itself).</li>
--   <li>guarantees that the resulting output bundle will have an ada
--   quantity that is greater than or equal to its original ada
--   quantity.</li>
--   <li>guarantees that the resulting fee excess will be less than or
--   equal to the original fee excess.</li>
--   </ul>
--   
--   Returns the minimized fee excess and the modified output.
minimizeFeeStep :: TxConstraints -> (Coin, TokenBundle) -> (Coin, TokenBundle)

-- | Calculates the current fee for a selection.
computeCurrentFee :: Selection input -> Either NegativeCoin Coin

-- | Calculates the current size of a selection.
computeCurrentSize :: TxConstraints -> Selection input -> TxSize

-- | Calculates the minimum permissible fee for a selection.
computeMinimumFee :: TxConstraints -> Selection input -> Coin

-- | Verifies a selection for correctness.
--   
--   This function is provided primarily as a convenience for testing. As
--   such, it's not usually necessary to call this function from ordinary
--   application code, unless you suspect that a selection value is
--   incorrect in some way.
verify :: TxConstraints -> Selection input -> SelectionCorrectness

-- | Indicates whether or not a selection is correct.
data SelectionCorrectness
SelectionCorrect :: SelectionCorrectness
SelectionIncorrect :: SelectionCorrectnessError -> SelectionCorrectness
instance GHC.Show.Show input => GHC.Show.Show (Cardano.Wallet.Primitive.Migration.Selection.Selection input)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Migration.Selection.Selection input)
instance GHC.Classes.Eq input => GHC.Classes.Eq (Cardano.Wallet.Primitive.Migration.Selection.Selection input)
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.RewardWithdrawal
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.RewardWithdrawal
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionFullError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionFullError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionAssetBalanceIncorrectError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionAssetBalanceIncorrectError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionFeeExcessIncorrectError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionFeeExcessIncorrectError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionOutputBelowMinimumAdaQuantityError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionOutputBelowMinimumAdaQuantityError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionOutputSizeExceedsLimitError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionOutputSizeExceedsLimitError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionSizeIncorrectError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionSizeIncorrectError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionSizeExceedsLimitError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionSizeExceedsLimitError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.NegativeCoin
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.NegativeCoin
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionFeeInsufficientError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionFeeInsufficientError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionFeeIncorrectError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionFeeIncorrectError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionCorrectnessError
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionCorrectnessError
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Selection.SelectionCorrectness
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Selection.SelectionCorrectness


-- | This module contains an algorithm for planning migrations at a high
--   level.
--   
--   It determines how to partition the UTxO set into entries of different
--   types, and in which order to add entries to selections, in order to
--   maximize the number of entries that can be successfully migrated.
--   
--   Use <a>createPlan</a> to create a migration plan.
module Cardano.Wallet.Primitive.Migration.Planning

-- | Creates a migration plan for the given categorized UTxO set and reward
--   withdrawal amount.
--   
--   See <a>MigrationPlan</a>.
createPlan :: TxConstraints -> CategorizedUTxO input -> RewardWithdrawal -> MigrationPlan input

-- | Represents a plan for migrating a set of UTxO entries.
--   
--   Use <a>createPlan</a> to create a migration plan.
data MigrationPlan input
MigrationPlan :: ![Selection input] -> !CategorizedUTxO input -> !Coin -> MigrationPlan input

-- | A list of generated selections: each selection is the basis for a
--   single transaction.
[$sel:selections:MigrationPlan] :: MigrationPlan input -> ![Selection input]

-- | The portion of the UTxO that was not selected.
[$sel:unselected:MigrationPlan] :: MigrationPlan input -> !CategorizedUTxO input

-- | The total fee payable: equal to the sum of the fees of the individual
--   selections.
[$sel:totalFee:MigrationPlan] :: MigrationPlan input -> !Coin
data CategorizedUTxO input
CategorizedUTxO :: ![(input, TokenBundle)] -> ![(input, TokenBundle)] -> ![(input, TokenBundle)] -> CategorizedUTxO input
[$sel:supporters:CategorizedUTxO] :: CategorizedUTxO input -> ![(input, TokenBundle)]
[$sel:freeriders:CategorizedUTxO] :: CategorizedUTxO input -> ![(input, TokenBundle)]
[$sel:ignorables:CategorizedUTxO] :: CategorizedUTxO input -> ![(input, TokenBundle)]
data UTxOEntryCategory

-- | A coin or bundle that is capable of paying for its own marginal fee
--   and the base transaction fee.
Supporter :: UTxOEntryCategory

-- | A coin or bundle that is not capable of paying for itself.
Freerider :: UTxOEntryCategory

-- | A coin that should not be added to a selection, because its value is
--   lower than the marginal fee for an input.
Ignorable :: UTxOEntryCategory
categorizeUTxO :: TxConstraints -> UTxO -> CategorizedUTxO (TxIn, TxOut)
categorizeUTxOEntries :: forall input. TxConstraints -> [(input, TokenBundle)] -> CategorizedUTxO input
categorizeUTxOEntry :: TxConstraints -> TokenBundle -> UTxOEntryCategory
uncategorizeUTxO :: CategorizedUTxO (TxIn, TxOut) -> UTxO
uncategorizeUTxOEntries :: CategorizedUTxO input -> [(input, TokenBundle)]
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.Planning.UTxOEntryCategory
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.Planning.UTxOEntryCategory
instance GHC.Show.Show input => GHC.Show.Show (Cardano.Wallet.Primitive.Migration.Planning.CategorizedUTxO input)
instance GHC.Classes.Eq input => GHC.Classes.Eq (Cardano.Wallet.Primitive.Migration.Planning.CategorizedUTxO input)
instance GHC.Show.Show input => GHC.Show.Show (Cardano.Wallet.Primitive.Migration.Planning.MigrationPlan input)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Migration.Planning.MigrationPlan input)
instance GHC.Classes.Eq input => GHC.Classes.Eq (Cardano.Wallet.Primitive.Migration.Planning.MigrationPlan input)


-- | This module provides a public API for planning wallet migrations.
--   
--   Use <a>createPlan</a> to create a migration plan.
module Cardano.Wallet.Primitive.Migration

-- | Creates a migration plan for the given UTxO set and reward withdrawal
--   amount.
--   
--   See <a>MigrationPlan</a>.
createPlan :: TxConstraints -> UTxO -> RewardWithdrawal -> MigrationPlan

-- | Represents a plan for migrating a <a>UTxO</a> set.
--   
--   See <a>createPlan</a> to create a migration plan.
data MigrationPlan
MigrationPlan :: ![Selection (TxIn, TxOut)] -> !UTxO -> !Coin -> MigrationPlan

-- | A list of generated selections: each selection is the basis for a
--   single transaction.
[$sel:selections:MigrationPlan] :: MigrationPlan -> ![Selection (TxIn, TxOut)]

-- | The portion of the UTxO that was not selected.
[$sel:unselected:MigrationPlan] :: MigrationPlan -> !UTxO

-- | The total fee payable: equal to the sum of the fees of the individual
--   selections.
[$sel:totalFee:MigrationPlan] :: MigrationPlan -> !Coin
newtype RewardWithdrawal
RewardWithdrawal :: Coin -> RewardWithdrawal
[$sel:unRewardWithdrawal:RewardWithdrawal] :: RewardWithdrawal -> Coin

-- | A selection is the basis for a single transaction.
--   
--   Use <a>create</a> to create a selection with one or more inputs. Use
--   <a>extend</a> to extend a selection with an additional input. Use
--   <a>verify</a> to verify the correctness of a selection.
data Selection input
Selection :: !NonEmpty input -> !TokenBundle -> !NonEmpty TokenBundle -> !Coin -> !Coin -> !TxSize -> !Coin -> Selection input

-- | The selected inputs.
[$sel:inputIds:Selection] :: Selection input -> !NonEmpty input

-- | The total balance of value provided by the inputs.
[$sel:inputBalance:Selection] :: Selection input -> !TokenBundle

-- | The outputs, adjusted to pay for the fee.
[$sel:outputs:Selection] :: Selection input -> !NonEmpty TokenBundle

-- | The actual fee payable for this selection.
[$sel:fee:Selection] :: Selection input -> !Coin

-- | The excess over the minimum permissible fee for this selection.
[$sel:feeExcess:Selection] :: Selection input -> !Coin

-- | The size of this selection.
[$sel:size:Selection] :: Selection input -> !TxSize

-- | The reward withdrawal amount, if any.
[$sel:rewardWithdrawal:Selection] :: Selection input -> !Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Migration.MigrationPlan
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Migration.MigrationPlan
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Migration.MigrationPlan

module Cardano.Wallet.Network

-- | Interface for network capabilities.
data NetworkLayer m block
NetworkLayer :: (Tracer IO ChainFollowLog -> ChainFollower m ChainPoint BlockHeader (NonEmpty block) -> m ()) -> Maybe (ChainFollower m ChainPoint BlockHeader (LightBlocks m Block) -> m ()) -> m BlockHeader -> m AnyCardanoEra -> m ProtocolParameters -> m SlottingParameters -> ((BlockHeader -> m ()) -> m ()) -> (SealedTx -> ExceptT ErrPostTx m ()) -> (Coin -> m StakePoolsSummary) -> (RewardAccount -> m Coin) -> (Set RewardAccount -> m (Map RewardAccount Coin)) -> TimeInterpreter (ExceptT PastHorizonException m) -> (SlotNo -> m SyncProgress) -> NetworkLayer m block

-- | Connect to the node and run the ChainSync protocol. The callbacks
--   provided in the <a>ChainFollower</a> argument are used to handle
--   intersection finding, the arrival of new blocks, and rollbacks.
[chainSync] :: NetworkLayer m block -> Tracer IO ChainFollowLog -> ChainFollower m ChainPoint BlockHeader (NonEmpty block) -> m ()

-- | Connect to a data source that offers an efficient query <tt>Address
--   -&gt; Transactions</tt>.
[lightSync] :: NetworkLayer m block -> Maybe (ChainFollower m ChainPoint BlockHeader (LightBlocks m Block) -> m ())

-- | Get the current tip from the chain producer
[currentNodeTip] :: NetworkLayer m block -> m BlockHeader

-- | Get the era the node is currently in.
[currentNodeEra] :: NetworkLayer m block -> m AnyCardanoEra

-- | Get the last known protocol parameters. In principle, these can only
--   change once per epoch.
[currentProtocolParameters] :: NetworkLayer m block -> m ProtocolParameters

-- | Get the last known slotting parameters. In principle, these can only
--   change once per era.
[currentSlottingParameters] :: NetworkLayer m block -> m SlottingParameters

-- | Register a callback for when the node tip changes. This function
--   should never finish, unless the callback throws an exception, which
--   will be rethrown by this function.
[watchNodeTip] :: NetworkLayer m block -> (BlockHeader -> m ()) -> m ()

-- | Broadcast a transaction to the chain producer
[postTx] :: NetworkLayer m block -> SealedTx -> ExceptT ErrPostTx m ()
[stakeDistribution] :: NetworkLayer m block -> Coin -> m StakePoolsSummary

-- | Return the cached reward balance of an account.
--   
--   If there is no cached value, it will return `Coin 0`, and add the
--   account to the internal set of observed account, such that it will be
--   fetched later.
[getCachedRewardAccountBalance] :: NetworkLayer m block -> RewardAccount -> m Coin

-- | Fetch the reward account balance of a set of accounts without any
--   caching.
[fetchRewardAccountBalances] :: NetworkLayer m block -> Set RewardAccount -> m (Map RewardAccount Coin)
[timeInterpreter] :: NetworkLayer m block -> TimeInterpreter (ExceptT PastHorizonException m)

-- | Compute the ratio between the provided <a>SlotNo</a> and the slot
--   corresponding to the current wall-clock time.
--   
--   Unlike using <a>syncProgress</a> after retrieving a
--   <a>timeInterpreter</a>, this function will return <a>NotResponding</a>
--   rather than block in the edge case when the era history has not yet
--   been fetched from the node on startup.
[syncProgress] :: NetworkLayer m block -> SlotNo -> m SyncProgress

-- | Error while trying to send a transaction
newtype ErrPostTx
ErrPostTxValidationError :: Text -> ErrPostTx

-- | A collection of callbacks to use with the <a>chainSync</a> function.
data ChainFollower m point tip blocks
ChainFollower :: (Integer -> CheckpointPolicy) -> m [point] -> (blocks -> tip -> m ()) -> (point -> m point) -> ChainFollower m point tip blocks

-- | The policy for creating and pruning checkpoints that is used by the
--   <a>ChainFollower</a>. The argument of this field is the
--   <tt>epochStability</tt>.
--   
--   Exposing this policy here enables any chain synchronizer which does
--   not retrieve full blocks, such as <a>lightSync</a>, to specifically
--   target those block heights at which the <a>ChainFollower</a> intends
--   to create checkpoints.
[checkpointPolicy] :: ChainFollower m point tip blocks -> Integer -> CheckpointPolicy

-- | Callback for reading the local tip. Used to negotiate the intersection
--   with the node.
--   
--   A response of [] is interpreted as <tt>Origin</tt> -- i.e. the chain
--   will be served from genesis.
[readChainPoints] :: ChainFollower m point tip blocks -> m [point]

-- | Callback for rolling forward.
--   
--   Implementors _may_ delete old checkpoints while rolling forward.
[rollForward] :: ChainFollower m point tip blocks -> blocks -> tip -> m ()

-- | Roll back to the requested slot, or further, and return the point
--   actually rolled back to.
--   
--   <b>Example 1:</b>
--   
--   If the follower stores checkpoints for all blocks, we can always roll
--   back to the requested point exactly.
--   
--   <pre>
--   -- If
--   knownSlots follower <tt>shouldReturn</tt> [0,1,2,3]
--   let requested = SlotNo 2
--   -- Then
--   actual &lt;- rollBackward follower requested
--   knownSlots follower shouldReturn` [0,1,2]
--   actual <tt>shouldBe</tt> SlotNo 2
--   </pre>
--   
--   Note that the slotNos are unlikely to be consecutive in real life, but
--   this doesn't matter, as ouroboros-network asks us to rollback to
--   points, corresponding to blocks.
--   
--   <b>Example 2:</b>
--   
--   <pre>
--   -- If
--   knownSlots follower <tt>shouldReturn</tt> [0,9,10]
--   let requested = SlotNo 2
--   -- Then
--   actual &lt;- rollBackward follower requested
--   knownSlots follower shouldReturn` [0]
--   actual <tt>shouldBe</tt> SlotNo 0
--   </pre>
[rollBackward] :: ChainFollower m point tip blocks -> point -> m point
mapChainFollower :: Functor m => (point1 -> point2) -> (point2 -> point1) -> (tip2 -> tip1) -> (blocks2 -> blocks1) -> ChainFollower m point1 tip1 blocks1 -> ChainFollower m point2 tip2 blocks2

-- | Higher level log of a chain follower. Includes computed statistics
--   about synchronization progress.
data ChainFollowLog
MsgChainSync :: ChainSyncLog BlockHeader ChainPoint -> ChainFollowLog
MsgFollowStats :: FollowStats Rearview -> ChainFollowLog
MsgStartFollowing :: ChainFollowLog

-- | Low-level logs of the ChainSync mini-protocol
data ChainSyncLog block point
MsgChainFindIntersect :: [point] -> ChainSyncLog block point
MsgChainRollForward :: NonEmpty block -> point -> ChainSyncLog block point
MsgChainRollBackward :: point -> Int -> ChainSyncLog block point
MsgChainTip :: point -> ChainSyncLog block point
MsgLocalTip :: point -> ChainSyncLog block point
MsgTipDistance :: Natural -> ChainSyncLog block point
mapChainSyncLog :: (b1 -> b2) -> (p1 -> p2) -> ChainSyncLog b1 p1 -> ChainSyncLog b2 p2

-- | Monitors health and statistics by inspecting the messages submitted to
--   a <a>ChainSyncLog</a> tracer.
--   
--   Statistics are computed in regular time intervals. In order to do
--   that, the monitor runs in separate thread. The results are submitted
--   to the outer <a>ChainFollowLog</a> tracer.
withFollowStatsMonitoring :: Tracer IO ChainFollowLog -> (SlotNo -> IO SyncProgress) -> (Tracer IO (ChainSyncLog BlockHeader ChainPoint) -> IO ()) -> IO ()

-- | Statistics of interest from the follow-function.
--   
--   The <tt>f</tt> allows us to use <a>Rearview</a> to keep track of both
--   current and previously logged stats, and perform operations over it in
--   a nice way.
data FollowStats f
FollowStats :: !f Int -> !f Int -> !f ChainPoint -> !f UTCTime -> !f SyncProgress -> FollowStats f
[blocksApplied] :: FollowStats f -> !f Int
[rollbacks] :: FollowStats f -> !f Int
[localTip] :: FollowStats f -> !f ChainPoint

-- | NOTE: Current time is not updated until <tt>flush</tt> is called.
[time] :: FollowStats f -> !f UTCTime

-- | NOTE: prog is not updated until <tt>flush</tt> is called.
[prog] :: FollowStats f -> !f SyncProgress

-- | A <a>Rearview</a> consists of a past value and a present value. Useful
--   for keeping track of past logs.
--   
--   The idea is to 1. Reconstruct a model of the <tt>current</tt>
--   <tt>state</tt> using a <tt>Trace</tt> 2. Sometimes log the difference
--   between the <tt>current</tt> state and the most recently logged one.
data Rearview a
Rearview :: !a -> !a -> Rearview a

-- | Most previously logged state
[past] :: Rearview a -> !a

-- | Not-yet logged state
[current] :: Rearview a -> !a
emptyStats :: UTCTime -> FollowStats Rearview

-- | Update the current statistics based on a new log message.
updateStats :: ChainSyncLog block ChainPoint -> FollowStats Rearview -> FollowStats Rearview
instance GHC.Classes.Eq Cardano.Wallet.Network.ErrPostTx
instance GHC.Show.Show Cardano.Wallet.Network.ErrPostTx
instance GHC.Generics.Generic Cardano.Wallet.Network.ErrPostTx
instance GHC.Generics.Generic (Cardano.Wallet.Network.ChainSyncLog block point)
instance (GHC.Classes.Eq point, GHC.Classes.Eq block) => GHC.Classes.Eq (Cardano.Wallet.Network.ChainSyncLog block point)
instance (GHC.Show.Show point, GHC.Show.Show block) => GHC.Show.Show (Cardano.Wallet.Network.ChainSyncLog block point)
instance GHC.Generics.Generic (Cardano.Wallet.Network.FollowStats f)
instance GHC.Generics.Generic (Cardano.Wallet.Network.Rearview a)
instance GHC.Base.Functor Cardano.Wallet.Network.Rearview
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Network.Rearview a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Network.Rearview a)
instance GHC.Generics.Generic Cardano.Wallet.Network.ChainFollowLog
instance GHC.Classes.Eq Cardano.Wallet.Network.ChainFollowLog
instance GHC.Show.Show Cardano.Wallet.Network.ChainFollowLog
instance NoThunks.Class.NoThunks (Cardano.Wallet.Network.FollowStats Cardano.Wallet.Network.Rearview)
instance GHC.Show.Show (Cardano.Wallet.Network.FollowStats Cardano.Wallet.Network.Rearview)
instance GHC.Classes.Eq (Cardano.Wallet.Network.FollowStats Cardano.Wallet.Network.Rearview)
instance GHC.Base.Functor m => GHC.Base.Functor (Cardano.Wallet.Network.NetworkLayer m)
instance Data.Text.Class.ToText Cardano.Wallet.Network.ChainFollowLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.Network.ChainFollowLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.Network.ChainFollowLog
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Cardano.Wallet.Network.Rearview a)
instance Data.Text.Class.ToText (Cardano.Wallet.Network.FollowStats Cardano.Wallet.Network.Rearview)
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation (Cardano.Wallet.Network.FollowStats Cardano.Wallet.Network.Rearview)
instance Data.Text.Class.ToText (Cardano.Wallet.Network.ChainSyncLog Cardano.Wallet.Primitive.Types.BlockHeader Cardano.Wallet.Primitive.Types.ChainPoint)
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation (Cardano.Wallet.Network.ChainSyncLog block point)
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation (Cardano.Wallet.Network.ChainSyncLog block point)
instance Data.Text.Class.ToText Cardano.Wallet.Network.ErrPostTx

module Cardano.Wallet.Network.Light

-- | Blockchain data source suitable for the implementation of
--   <a>lightSync</a>.
data LightSyncSource m block addr txs
LightSyncSource :: (block -> BlockHeader) -> m BlockHeader -> (BlockHeight -> m (Consensual BlockHeader)) -> (BlockHeader -> m (Consensual (Maybe BlockHeader))) -> (ChainPoint -> m (Consensual BlockHeader)) -> (ChainPoint -> m (Consensual [block])) -> (BlockHeader -> BlockHeader -> addr -> m txs) -> LightSyncSource m block addr txs

-- | Get the <a>BlockHeader</a> of a given <tt>block</tt>.
[getHeader] :: LightSyncSource m block addr txs -> block -> BlockHeader

-- | Latest tip of the chain.
[getTip] :: LightSyncSource m block addr txs -> m BlockHeader

-- | Get the <a>BlockHeader</a> at a given block height.
[getBlockHeaderAtHeight] :: LightSyncSource m block addr txs -> BlockHeight -> m (Consensual BlockHeader)

-- | Get the next block header.
[getNextBlockHeader] :: LightSyncSource m block addr txs -> BlockHeader -> m (Consensual (Maybe BlockHeader))

-- | Get the full <a>BlockHeader</a> belonging to a given
--   <a>ChainPoint</a>. Return <a>Nothing</a> if the point is not consensus
--   anymore.
[getBlockHeaderAt] :: LightSyncSource m block addr txs -> ChainPoint -> m (Consensual BlockHeader)

-- | Get several blocks immediately following the given
--   <tt>Chainpoint</tt>.
[getNextBlocks] :: LightSyncSource m block addr txs -> ChainPoint -> m (Consensual [block])

-- | Transactions for a given address and point range.
[getAddressTxs] :: LightSyncSource m block addr txs -> BlockHeader -> BlockHeader -> addr -> m txs
type LightBlocks m block addr txs = Either (NonEmpty block) (BlockSummary m addr txs)
hoistLightSyncSource :: (forall a. m a -> n a) -> LightSyncSource m block addr txs -> LightSyncSource n block addr txs

-- | Drive a <a>ChainFollower</a> using a <a>LightSyncSource</a>. Never
--   returns.
lightSync :: MonadDelay m => Tracer m LightLayerLog -> LightSyncSource m block addr txs -> ChainFollower m ChainPoint BlockHeader (LightBlocks m block addr txs) -> m Void

-- | <a>Consensual</a> represents the result of query on the blockchain.
--   Either the result is a value that is part of the consensus chain, or
--   the result is an indication that the consensus had changed before the
--   entire value could be retrieved.
data Consensual a
NotConsensual :: Consensual a
Consensual :: a -> Consensual a
data LightLayerLog
MsgLightRollForward :: ChainPoint -> BlockHeader -> BlockHeader -> BlockHeader -> LightLayerLog
MsgLightRolledForward :: BlockHeader -> LightLayerLog
MsgLightRollBackward :: ChainPoint -> ChainPoint -> LightLayerLog
instance GHC.Show.Show (Cardano.Wallet.Network.Light.NextPointMove block)
instance Data.Traversable.Traversable Cardano.Wallet.Network.Light.Consensual
instance Data.Foldable.Foldable Cardano.Wallet.Network.Light.Consensual
instance GHC.Base.Functor Cardano.Wallet.Network.Light.Consensual
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Network.Light.Consensual a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Network.Light.Consensual a)
instance GHC.Generics.Generic Cardano.Wallet.Network.Light.LightLayerLog
instance GHC.Classes.Eq Cardano.Wallet.Network.Light.LightLayerLog
instance GHC.Show.Show Cardano.Wallet.Network.Light.LightLayerLog
instance Data.Text.Class.ToText Cardano.Wallet.Network.Light.LightLayerLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.Network.Light.LightLayerLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.Network.Light.LightLayerLog
instance Formatting.Buildable.Buildable a => Formatting.Buildable.Buildable (Cardano.Wallet.Network.Light.Consensual a)


-- | This module contains instances and types necessary for storing wallets
--   in a SQL database with Persistent.
--   
--   It's in a separate module due to the GHC stage restriction.
--   
--   The ToJSON/FromJSON and Read instance orphans exist due to class
--   constraints on Persistent functions.
module Cardano.Wallet.DB.Sqlite.Types

-- | Settings for generating the Persistent types.
sqlSettings' :: MkPersistSettings

-- | <a>fromText</a> but with a simpler error type.
fromText' :: FromText a => Text -> Either Text a

-- | Aeson parser defined in terms of <a>fromText</a>
aesonFromText :: FromText a => String -> Value -> Parser a

-- | <a>fromPersistValue</a> defined in terms of <a>fromText</a>
fromPersistValueFromText :: FromText a => PersistValue -> Either Text a

-- | <a>fromPersistValue</a> defined in terms of the <a>Read</a> class
fromPersistValueRead :: Read a => PersistValue -> Either Text a
directionToBool :: Direction -> Bool
directionFromBool :: Bool -> Direction

-- | Wraps 'Hash <a>Tx</a>' because the persistent entity syntax doesn't
--   seem to support parameterized types.
newtype TxId
TxId :: Hash "Tx" -> TxId
[getTxId] :: TxId -> Hash "Tx"
newtype BlockId
BlockId :: Hash "BlockHeader" -> BlockId
[getBlockId] :: BlockId -> Hash "BlockHeader"

-- | Magic value that denotes the hash of the parent of the genesis block
--   (which does not exist). This value is used for serializing the Nothing
--   case of the #parentHeaderHash field.
hashOfNoParent :: Hash "BlockHeader"
fromMaybeHash :: Maybe (Hash "BlockHeader") -> BlockId
toMaybeHash :: BlockId -> Maybe (Hash "BlockHeader")
persistSlotNo :: SlotNo -> PersistValue
unPersistSlotNo :: PersistValue -> Either Text SlotNo
mkEpochNo :: Word32 -> Either Text EpochNo
persistEpochNo :: EpochNo -> PersistValue

-- | In <tt>random &lt; 1.2</tt> there used to be an <tt>instance Read
--   StdGen</tt>, but no longer.
--   
--   The format used to look like this: <tt> 5889121503043413025
--   17512980752375952679 </tt>
stdGenFromString :: String -> Either Text StdGen

-- | Equivalent to the old <tt>random &lt; 1.2</tt> <a>StdGen</a>
--   <a>Show</a> instance.
stdGenToString :: StdGen -> String
newtype HDPassphrase
HDPassphrase :: Passphrase "addr-derivation-payload" -> HDPassphrase

-- | Newtype to get a MonadFail instance for <tt>Either Text</tt>.
--   
--   We need it to use <tt>parseTimeM</tt>.
newtype EitherText a
EitherText :: Either Text a -> EitherText a
[getEitherText] :: EitherText a -> Either Text a
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Classes.Ord Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Classes.Ord Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance GHC.Base.Monad Cardano.Wallet.DB.Sqlite.Types.EitherText
instance GHC.Base.Applicative Cardano.Wallet.DB.Sqlite.Types.EitherText
instance GHC.Base.Functor Cardano.Wallet.DB.Sqlite.Types.EitherText
instance Database.Persist.Class.PersistField.PersistField Data.Time.Clock.Internal.POSIXTime.POSIXTime
instance Control.Monad.Fail.MonadFail Cardano.Wallet.DB.Sqlite.Types.EitherText
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance GHC.Read.Read Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Types.BlockId
instance GHC.Read.Read Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Web.PathPieces.PathPiece Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Types.TxId
instance GHC.Read.Read Cardano.Wallet.DB.Sqlite.Types.TxId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.DB.Sqlite.Types.TxId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.DB.Sqlite.Types.TxId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.DB.Sqlite.Types.TxId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.DB.Sqlite.Types.TxId
instance Web.PathPieces.PathPiece Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.StakeKeyCertificate
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.StakeKeyCertificate
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Tx.Direction
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Tx.Direction
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.FeePolicy
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.FeePolicy
instance Database.Persist.Class.PersistField.PersistField Data.Quantity.Percentage
instance Database.Persist.Sql.Class.PersistFieldSql Data.Quantity.Percentage
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.WalletId
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.WalletId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Primitive.Types.WalletId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Primitive.Types.WalletId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.WalletId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.WalletId
instance Web.PathPieces.PathPiece Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Slotting.Slot.SlotNo
instance GHC.Read.Read Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistField.PersistField Cardano.Slotting.Slot.SlotNo
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Slotting.Slot.SlotNo
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Slotting.Slot.SlotNo
instance Web.PathPieces.PathPiece Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.EpochNo
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.EpochNo
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Primitive.Types.EpochNo
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Primitive.Types.EpochNo
instance Web.PathPieces.PathPiece Cardano.Wallet.Primitive.Types.EpochNo
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance Database.Persist.Class.PersistField.PersistField Cardano.Api.TxMetadata.TxMetadata
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Api.TxMetadata.TxMetadata
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Tx.SealedTx
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Tx.SealedTx
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Address.Address
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Address.Address
instance Data.Text.Class.ToText Cardano.Address.Script.ScriptHash
instance Data.Text.Class.FromText Cardano.Address.Script.ScriptHash
instance Database.Persist.Class.PersistField.PersistField Cardano.Address.Script.ScriptHash
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Address.Script.ScriptHash
instance Database.Persist.Class.PersistField.PersistField (Cardano.Address.Script.Script Cardano.Address.Script.Cosigner)
instance Database.Persist.Sql.Class.PersistFieldSql (Cardano.Address.Script.Script Cardano.Address.Script.Cosigner)
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.AddressDiscovery.Shared.CredentialType
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.AddressDiscovery.Shared.CredentialType
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.AddressDerivation.Role
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.AddressDerivation.Role
instance Database.Persist.Sql.Class.PersistFieldSql System.Random.Internal.StdGen
instance Database.Persist.Class.PersistField.PersistField System.Random.Internal.StdGen
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.PoolId
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.PoolId
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.PoolId
instance Web.PathPieces.PathPiece Cardano.Wallet.Primitive.Types.PoolId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.PoolId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.PoolId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Primitive.Types.PoolId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Primitive.Types.PoolId
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.PoolOwner
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.PoolOwner
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.PoolOwner
instance Data.Text.Class.FromText [Cardano.Wallet.Primitive.Types.PoolOwner]
instance Database.Persist.Class.PersistField.PersistField [Cardano.Wallet.Primitive.Types.PoolOwner]
instance Database.Persist.Sql.Class.PersistFieldSql [Cardano.Wallet.Primitive.Types.PoolOwner]
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Passphrase.Types.PassphraseScheme
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Passphrase.Types.PassphraseScheme
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.StakePoolTicker
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.StakePoolTicker
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Web.PathPieces.PathPiece Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance GHC.Read.Read Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Web.PathPieces.PathPiece Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Web.PathPieces.PathPiece Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Address.AddressState
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Address.AddressState
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.PoolMetadataSource
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.PoolMetadataSource
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.Primitive.Types.Tx.TxScriptValidity
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.Primitive.Types.Tx.TxScriptValidity
instance Database.Persist.Sql.Class.PersistFieldSql Data.Time.Clock.Internal.POSIXTime.POSIXTime


-- | Auto-generated Sqlite &amp; Persistent machinery via Template-Haskell.
--   This has been moved into a separate file so that we can treat it
--   slightly differently when computing code-coverage.
module Cardano.Pool.DB.Sqlite.TH
data InternalState
InternalState :: !Maybe POSIXTime -> InternalState
[lastGCMetadata] :: InternalState -> !Maybe POSIXTime
type InternalStateId = Key InternalState
data Settings
Settings :: !PoolMetadataSource -> Settings
[settingsPoolMetadataSource] :: Settings -> !PoolMetadataSource
type SettingsId = Key Settings
data ArbitrarySeed
ArbitrarySeed :: !StdGen -> ArbitrarySeed
[seedSeed] :: ArbitrarySeed -> !StdGen
type ArbitrarySeedId = Key ArbitrarySeed
data PoolProduction
PoolProduction :: !PoolId -> !SlotNo -> !BlockId -> !BlockId -> !Word32 -> PoolProduction
[poolProductionPoolId] :: PoolProduction -> !PoolId
[poolProductionSlot] :: PoolProduction -> !SlotNo
[poolProductionHeaderHash] :: PoolProduction -> !BlockId
[poolProductionParentHash] :: PoolProduction -> !BlockId
[poolProductionBlockHeight] :: PoolProduction -> !Word32
type PoolProductionId = Key PoolProduction
data BlockHeader
BlockHeader :: !SlotNo -> !BlockId -> !BlockId -> !Word32 -> BlockHeader
[blockSlot] :: BlockHeader -> !SlotNo
[blockHeaderHash] :: BlockHeader -> !BlockId
[blockParentHash] :: BlockHeader -> !BlockId
[blockHeight] :: BlockHeader -> !Word32
type BlockHeaderId = Key BlockHeader
data StakeDistribution
StakeDistribution :: !PoolId -> !Word64 -> !Word64 -> StakeDistribution
[stakeDistributionPoolId] :: StakeDistribution -> !PoolId
[stakeDistributionEpoch] :: StakeDistribution -> !Word64
[stakeDistributionStake] :: StakeDistribution -> !Word64
type StakeDistributionId = Key StakeDistribution
data PoolOwner
PoolOwner :: !PoolId -> !SlotNo -> !Word64 -> !PoolOwner -> !Word8 -> PoolOwner
[poolOwnerPoolId] :: PoolOwner -> !PoolId
[poolOwnerSlot] :: PoolOwner -> !SlotNo
[poolOwnerSlotInternalIndex] :: PoolOwner -> !Word64
[poolOwnerOwner] :: PoolOwner -> !PoolOwner
[poolOwnerIndex] :: PoolOwner -> !Word8
type PoolOwnerId = Key PoolOwner
data PoolRegistration
PoolRegistration :: !PoolId -> !SlotNo -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Maybe StakePoolMetadataUrl -> !Maybe StakePoolMetadataHash -> PoolRegistration
[poolRegistrationPoolId] :: PoolRegistration -> !PoolId
[poolRegistrationSlot] :: PoolRegistration -> !SlotNo
[poolRegistrationSlotInternalIndex] :: PoolRegistration -> !Word64
[poolRegistrationMarginNumerator] :: PoolRegistration -> !Word64
[poolRegistrationMarginDenominator] :: PoolRegistration -> !Word64
[poolRegistrationCost] :: PoolRegistration -> !Word64
[poolRegistrationPledge] :: PoolRegistration -> !Word64
[poolRegistrationMetadataUrl] :: PoolRegistration -> !Maybe StakePoolMetadataUrl
[poolRegistrationMetadataHash] :: PoolRegistration -> !Maybe StakePoolMetadataHash
type PoolRegistrationId = Key PoolRegistration
data PoolDelistment
PoolDelistment :: !PoolId -> PoolDelistment
[delistedPoolId] :: PoolDelistment -> !PoolId
type PoolDelistmentId = Key PoolDelistment
data PoolRetirement
PoolRetirement :: !PoolId -> !SlotNo -> !Word64 -> !Word64 -> PoolRetirement
[poolRetirementPoolId] :: PoolRetirement -> !PoolId
[poolRetirementSlot] :: PoolRetirement -> !SlotNo
[poolRetirementSlotInternalIndex] :: PoolRetirement -> !Word64
[poolRetirementEpoch] :: PoolRetirement -> !Word64
type PoolRetirementId = Key PoolRetirement
data PoolMetadata
PoolMetadata :: !StakePoolMetadataHash -> !Text -> !StakePoolTicker -> !Maybe Text -> !Text -> PoolMetadata
[poolMetadataHash] :: PoolMetadata -> !StakePoolMetadataHash
[poolMetadataName] :: PoolMetadata -> !Text
[poolMetadataTicker] :: PoolMetadata -> !StakePoolTicker
[poolMetadataDescription] :: PoolMetadata -> !Maybe Text
[poolMetadataHomepage] :: PoolMetadata -> !Text
type PoolMetadataId = Key PoolMetadata
data PoolMetadataFetchAttempts
PoolMetadataFetchAttempts :: !StakePoolMetadataHash -> !StakePoolMetadataUrl -> !UTCTime -> !Word8 -> PoolMetadataFetchAttempts
[poolFetchAttemptsMetadataHash] :: PoolMetadataFetchAttempts -> !StakePoolMetadataHash
[poolFetchAttemptsMetadataUrl] :: PoolMetadataFetchAttempts -> !StakePoolMetadataUrl
[poolFetchAttemptsRetryAfter] :: PoolMetadataFetchAttempts -> !UTCTime
[poolFetchAttemptsRetryCount] :: PoolMetadataFetchAttempts -> !Word8
type PoolMetadataFetchAttemptsId = Key PoolMetadataFetchAttempts
migrateAll :: Migration
entityDefListFormigrateAll :: [EntityDef]
fk_registration_pool_id :: PoolOwner -> Key PoolRegistration
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.InternalState
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.InternalState
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.Settings
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.Settings
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolProduction)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.BlockHeader
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.BlockHeader
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.BlockHeader)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.PoolDelistment
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.PoolDelistment
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolDelistment)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.PoolRetirement
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.PoolRetirement
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRetirement)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRetirement)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRetirement)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRetirement)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRetirement)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.PoolMetadata
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.PoolMetadata
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadata)
instance GHC.Generics.Generic Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts
instance GHC.Show.Show Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts)
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts
instance Database.Persist.Class.PersistEntity.SymbolToField "poolFetchAttemptsMetadataHash" Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Database.Persist.Class.PersistEntity.SymbolToField "poolFetchAttemptsMetadataUrl" Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl
instance Database.Persist.Class.PersistEntity.SymbolToField "poolFetchAttemptsRetryAfter" Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts Data.Time.Clock.Internal.UTCTime.UTCTime
instance Database.Persist.Class.PersistEntity.SymbolToField "poolFetchAttemptsRetryCount" Cardano.Pool.DB.Sqlite.TH.PoolMetadataFetchAttempts GHC.Word.Word8
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.PoolMetadata
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.PoolMetadata
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.PoolMetadata
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolMetadata
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolMetadata
instance Database.Persist.Class.PersistEntity.SymbolToField "poolMetadataHash" Cardano.Pool.DB.Sqlite.TH.PoolMetadata Cardano.Wallet.Primitive.Types.StakePoolMetadataHash
instance Database.Persist.Class.PersistEntity.SymbolToField "poolMetadataName" Cardano.Pool.DB.Sqlite.TH.PoolMetadata Data.Text.Internal.Text
instance Database.Persist.Class.PersistEntity.SymbolToField "poolMetadataTicker" Cardano.Pool.DB.Sqlite.TH.PoolMetadata Cardano.Wallet.Primitive.Types.StakePoolTicker
instance Database.Persist.Class.PersistEntity.SymbolToField "poolMetadataDescription" Cardano.Pool.DB.Sqlite.TH.PoolMetadata (GHC.Maybe.Maybe Data.Text.Internal.Text)
instance Database.Persist.Class.PersistEntity.SymbolToField "poolMetadataHomepage" Cardano.Pool.DB.Sqlite.TH.PoolMetadata Data.Text.Internal.Text
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.PoolRetirement
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.PoolRetirement
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.PoolRetirement
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRetirement)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRetirement)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRetirement)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRetirement)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolRetirement
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolRetirement
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRetirementPoolId" Cardano.Pool.DB.Sqlite.TH.PoolRetirement Cardano.Wallet.Primitive.Types.PoolId
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRetirementSlot" Cardano.Pool.DB.Sqlite.TH.PoolRetirement Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRetirementSlotInternalIndex" Cardano.Pool.DB.Sqlite.TH.PoolRetirement GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRetirementEpoch" Cardano.Pool.DB.Sqlite.TH.PoolRetirement GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.PoolDelistment
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.PoolDelistment
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.PoolDelistment
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolDelistment
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolDelistment
instance Database.Persist.Class.PersistEntity.SymbolToField "delistedPoolId" Cardano.Pool.DB.Sqlite.TH.PoolDelistment Cardano.Wallet.Primitive.Types.PoolId
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolRegistration)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolRegistration
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRegistrationPoolId" Cardano.Pool.DB.Sqlite.TH.PoolRegistration Cardano.Wallet.Primitive.Types.PoolId
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRegistrationSlot" Cardano.Pool.DB.Sqlite.TH.PoolRegistration Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRegistrationSlotInternalIndex" Cardano.Pool.DB.Sqlite.TH.PoolRegistration GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRegistrationMarginNumerator" Cardano.Pool.DB.Sqlite.TH.PoolRegistration GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRegistrationMarginDenominator" Cardano.Pool.DB.Sqlite.TH.PoolRegistration GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRegistrationCost" Cardano.Pool.DB.Sqlite.TH.PoolRegistration GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRegistrationPledge" Cardano.Pool.DB.Sqlite.TH.PoolRegistration GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRegistrationMetadataUrl" Cardano.Pool.DB.Sqlite.TH.PoolRegistration (GHC.Maybe.Maybe Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl)
instance Database.Persist.Class.PersistEntity.SymbolToField "poolRegistrationMetadataHash" Cardano.Pool.DB.Sqlite.TH.PoolRegistration (GHC.Maybe.Maybe Cardano.Wallet.Primitive.Types.StakePoolMetadataHash)
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.PoolOwner)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolOwner
instance Database.Persist.Class.PersistEntity.SymbolToField "poolOwnerPoolId" Cardano.Pool.DB.Sqlite.TH.PoolOwner Cardano.Wallet.Primitive.Types.PoolId
instance Database.Persist.Class.PersistEntity.SymbolToField "poolOwnerSlot" Cardano.Pool.DB.Sqlite.TH.PoolOwner Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "poolOwnerSlotInternalIndex" Cardano.Pool.DB.Sqlite.TH.PoolOwner GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.SymbolToField "poolOwnerOwner" Cardano.Pool.DB.Sqlite.TH.PoolOwner Cardano.Wallet.Primitive.Types.PoolOwner
instance Database.Persist.Class.PersistEntity.SymbolToField "poolOwnerIndex" Cardano.Pool.DB.Sqlite.TH.PoolOwner GHC.Word.Word8
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.StakeDistribution)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.StakeDistribution
instance Database.Persist.Class.PersistEntity.SymbolToField "stakeDistributionPoolId" Cardano.Pool.DB.Sqlite.TH.StakeDistribution Cardano.Wallet.Primitive.Types.PoolId
instance Database.Persist.Class.PersistEntity.SymbolToField "stakeDistributionEpoch" Cardano.Pool.DB.Sqlite.TH.StakeDistribution GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.SymbolToField "stakeDistributionStake" Cardano.Pool.DB.Sqlite.TH.StakeDistribution GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.BlockHeader
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.BlockHeader
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.BlockHeader
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.BlockHeader
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.BlockHeader
instance Database.Persist.Class.PersistEntity.SymbolToField "blockSlot" Cardano.Pool.DB.Sqlite.TH.BlockHeader Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "blockHeaderHash" Cardano.Pool.DB.Sqlite.TH.BlockHeader Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Class.PersistEntity.SymbolToField "blockParentHash" Cardano.Pool.DB.Sqlite.TH.BlockHeader Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Class.PersistEntity.SymbolToField "blockHeight" Cardano.Pool.DB.Sqlite.TH.BlockHeader GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.PoolProduction
instance Database.Persist.Class.PersistEntity.SymbolToField "poolProductionPoolId" Cardano.Pool.DB.Sqlite.TH.PoolProduction Cardano.Wallet.Primitive.Types.PoolId
instance Database.Persist.Class.PersistEntity.SymbolToField "poolProductionSlot" Cardano.Pool.DB.Sqlite.TH.PoolProduction Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "poolProductionHeaderHash" Cardano.Pool.DB.Sqlite.TH.PoolProduction Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Class.PersistEntity.SymbolToField "poolProductionParentHash" Cardano.Pool.DB.Sqlite.TH.PoolProduction Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Class.PersistEntity.SymbolToField "poolProductionBlockHeight" Cardano.Pool.DB.Sqlite.TH.PoolProduction GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.SqlBackend.Internal.SqlBackend Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed
instance Database.Persist.Class.PersistEntity.SymbolToField "id" Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed)
instance Database.Persist.Class.PersistEntity.SymbolToField "seedSeed" Cardano.Pool.DB.Sqlite.TH.ArbitrarySeed System.Random.Internal.StdGen
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.Settings
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.Settings
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.Settings
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.SqlBackend.Internal.SqlBackend Cardano.Pool.DB.Sqlite.TH.Settings
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.Settings
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.Settings
instance Database.Persist.Class.PersistEntity.SymbolToField "id" Cardano.Pool.DB.Sqlite.TH.Settings (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.Settings)
instance Database.Persist.Class.PersistEntity.SymbolToField "settingsPoolMetadataSource" Cardano.Pool.DB.Sqlite.TH.Settings Cardano.Wallet.Primitive.Types.PoolMetadataSource
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Pool.DB.Sqlite.TH.InternalState
instance Database.Persist.Class.PersistField.PersistField Cardano.Pool.DB.Sqlite.TH.InternalState
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Pool.DB.Sqlite.TH.InternalState
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.SqlBackend.Internal.SqlBackend Cardano.Pool.DB.Sqlite.TH.InternalState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Pool.DB.Sqlite.TH.InternalState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Pool.DB.Sqlite.TH.InternalState
instance Database.Persist.Class.PersistEntity.SymbolToField "id" Cardano.Pool.DB.Sqlite.TH.InternalState (Database.Persist.Class.PersistEntity.Key Cardano.Pool.DB.Sqlite.TH.InternalState)
instance Database.Persist.Class.PersistEntity.SymbolToField "lastGCMetadata" Cardano.Pool.DB.Sqlite.TH.InternalState (GHC.Maybe.Maybe Data.Time.Clock.Internal.POSIXTime.POSIXTime)


-- | Auto-generated Sqlite &amp; Persistent machinery via Template-Haskell.
--   This has been moved into a separate file so that we can treat it
--   slightly differently when computing code-coverage.
--   
--   More than 6K lines end-up being generated from the instructions below!
--   As a result, we're going to ignore code-coverage on the following
--   module and, no hand-written functions should be written in this
--   module!
module Cardano.Wallet.DB.Sqlite.Schema
data Wallet
Wallet :: !WalletId -> !UTCTime -> !Text -> !Maybe UTCTime -> !Maybe PassphraseScheme -> !BlockId -> !UTCTime -> Wallet
[walId] :: Wallet -> !WalletId
[walCreationTime] :: Wallet -> !UTCTime
[walName] :: Wallet -> !Text
[walPassphraseLastUpdatedAt] :: Wallet -> !Maybe UTCTime
[walPassphraseScheme] :: Wallet -> !Maybe PassphraseScheme
[walGenesisHash] :: Wallet -> !BlockId
[walGenesisStart] :: Wallet -> !UTCTime
type WalletId = Key Wallet
data PrivateKey
PrivateKey :: !WalletId -> !ByteString -> !ByteString -> PrivateKey
[privateKeyWalletId] :: PrivateKey -> !WalletId
[privateKeyRootKey] :: PrivateKey -> !ByteString
[privateKeyHash] :: PrivateKey -> !ByteString
type PrivateKeyId = Key PrivateKey
data TxMeta
TxMeta :: !TxId -> !WalletId -> !TxStatus -> !Direction -> !SlotNo -> !Word32 -> !Coin -> !Maybe TxMetadata -> !Maybe SlotNo -> !Maybe Word64 -> !Maybe Bool -> TxMeta
[txMetaTxId] :: TxMeta -> !TxId
[txMetaWalletId] :: TxMeta -> !WalletId
[txMetaStatus] :: TxMeta -> !TxStatus
[txMetaDirection] :: TxMeta -> !Direction
[txMetaSlot] :: TxMeta -> !SlotNo
[txMetaBlockHeight] :: TxMeta -> !Word32
[txMetaAmount] :: TxMeta -> !Coin
[txMetadata] :: TxMeta -> !Maybe TxMetadata
[txMetaSlotExpires] :: TxMeta -> !Maybe SlotNo
[txMetaFee] :: TxMeta -> !Maybe Word64
[txMetaScriptValidity] :: TxMeta -> !Maybe Bool
type TxMetaId = Key TxMeta
data TxIn
TxIn :: !TxId -> !Int -> !TxId -> !Word32 -> !Coin -> TxIn
[txInputTxId] :: TxIn -> !TxId
[txInputOrder] :: TxIn -> !Int
[txInputSourceTxId] :: TxIn -> !TxId
[txInputSourceIndex] :: TxIn -> !Word32
[txInputSourceAmount] :: TxIn -> !Coin
type TxInId = Key TxIn
data TxCollateral
TxCollateral :: !TxId -> !Int -> !TxId -> !Word32 -> !Coin -> TxCollateral
[txCollateralTxId] :: TxCollateral -> !TxId
[txCollateralOrder] :: TxCollateral -> !Int
[txCollateralSourceTxId] :: TxCollateral -> !TxId
[txCollateralSourceIndex] :: TxCollateral -> !Word32
[txCollateralSourceAmount] :: TxCollateral -> !Coin
type TxCollateralId = Key TxCollateral
data TxOut
TxOut :: !TxId -> !Word32 -> !Address -> !Coin -> TxOut
[txOutputTxId] :: TxOut -> !TxId
[txOutputIndex] :: TxOut -> !Word32
[txOutputAddress] :: TxOut -> !Address
[txOutputAmount] :: TxOut -> !Coin
type TxOutId = Key TxOut
data TxOutToken
TxOutToken :: !TxId -> !Word32 -> !TokenPolicyId -> !TokenName -> !TokenQuantity -> TxOutToken
[txOutTokenTxId] :: TxOutToken -> !TxId
[txOutTokenTxIndex] :: TxOutToken -> !Word32
[txOutTokenPolicyId] :: TxOutToken -> !TokenPolicyId
[txOutTokenName] :: TxOutToken -> !TokenName
[txOutTokenQuantity] :: TxOutToken -> !TokenQuantity
type TxOutTokenId = Key TxOutToken
data TxCollateralOut
TxCollateralOut :: !TxId -> !Address -> !Coin -> TxCollateralOut
[txCollateralOutTxId] :: TxCollateralOut -> !TxId
[txCollateralOutAddress] :: TxCollateralOut -> !Address
[txCollateralOutAmount] :: TxCollateralOut -> !Coin
type TxCollateralOutId = Key TxCollateralOut
data TxCollateralOutToken
TxCollateralOutToken :: !TxId -> !TokenPolicyId -> !TokenName -> !TokenQuantity -> TxCollateralOutToken
[txCollateralOutTokenTxId] :: TxCollateralOutToken -> !TxId
[txCollateralOutTokenPolicyId] :: TxCollateralOutToken -> !TokenPolicyId
[txCollateralOutTokenName] :: TxCollateralOutToken -> !TokenName
[txCollateralOutTokenQuantity] :: TxCollateralOutToken -> !TokenQuantity
type TxCollateralOutTokenId = Key TxCollateralOutToken
data TxWithdrawal
TxWithdrawal :: !TxId -> !Coin -> !RewardAccount -> TxWithdrawal
[txWithdrawalTxId] :: TxWithdrawal -> !TxId
[txWithdrawalAmount] :: TxWithdrawal -> !Coin
[txWithdrawalAccount] :: TxWithdrawal -> !RewardAccount
type TxWithdrawalId = Key TxWithdrawal
data LocalTxSubmission
LocalTxSubmission :: !TxId -> !WalletId -> !SlotNo -> !SealedTx -> LocalTxSubmission
[localTxSubmissionTxId] :: LocalTxSubmission -> !TxId
[localTxSubmissionWalletId] :: LocalTxSubmission -> !WalletId
[localTxSubmissionLastSlot] :: LocalTxSubmission -> !SlotNo
[localTxSubmissionTx] :: LocalTxSubmission -> !SealedTx
type LocalTxSubmissionId = Key LocalTxSubmission
data Checkpoint
Checkpoint :: !WalletId -> !SlotNo -> !BlockId -> !BlockId -> !Word32 -> Checkpoint
[checkpointWalletId] :: Checkpoint -> !WalletId
[checkpointSlot] :: Checkpoint -> !SlotNo
[checkpointHeaderHash] :: Checkpoint -> !BlockId
[checkpointParentHash] :: Checkpoint -> !BlockId
[checkpointBlockHeight] :: Checkpoint -> !Word32
type CheckpointId = Key Checkpoint
data ProtocolParameters
ProtocolParameters :: !WalletId -> !FeePolicy -> !Word16 -> !Percentage -> !Word16 -> !Coin -> !Maybe EpochNo -> !Coin -> ProtocolParameters
[protocolParametersWalletId] :: ProtocolParameters -> !WalletId
[protocolParametersFeePolicy] :: ProtocolParameters -> !FeePolicy
[protocolParametersTxMaxSize] :: ProtocolParameters -> !Word16
[protocolParametersDecentralizationLevel] :: ProtocolParameters -> !Percentage
[protocolParametersDesiredNumberOfPools] :: ProtocolParameters -> !Word16
[protocolParametersMinimumUtxoValue] :: ProtocolParameters -> !Coin
[protocolParametersHardforkEpoch] :: ProtocolParameters -> !Maybe EpochNo
[protocolParametersKeyDeposit] :: ProtocolParameters -> !Coin
type ProtocolParametersId = Key ProtocolParameters
data StakeKeyCertificate
StakeKeyCertificate :: !WalletId -> !SlotNo -> !StakeKeyCertificate -> StakeKeyCertificate
[stakeKeyCertWalletId] :: StakeKeyCertificate -> !WalletId
[stakeKeyCertSlot] :: StakeKeyCertificate -> !SlotNo
[stakeKeyCertType] :: StakeKeyCertificate -> !StakeKeyCertificate
type StakeKeyCertificateId = Key StakeKeyCertificate
data DelegationCertificate
DelegationCertificate :: !WalletId -> !SlotNo -> !Maybe PoolId -> DelegationCertificate
[certWalletId] :: DelegationCertificate -> !WalletId
[certSlot] :: DelegationCertificate -> !SlotNo
[certPoolId] :: DelegationCertificate -> !Maybe PoolId
type DelegationCertificateId = Key DelegationCertificate
data DelegationReward
DelegationReward :: !WalletId -> !Word64 -> DelegationReward
[rewardWalletId] :: DelegationReward -> !WalletId
[rewardAccountBalance] :: DelegationReward -> !Word64
type DelegationRewardId = Key DelegationReward
data UTxO
UTxO :: !WalletId -> !SlotNo -> !TxId -> !Word32 -> !Address -> !Coin -> UTxO
[utxoWalletId] :: UTxO -> !WalletId
[utxoSlot] :: UTxO -> !SlotNo
[utxoInputId] :: UTxO -> !TxId
[utxoInputIndex] :: UTxO -> !Word32
[utxoOutputAddress] :: UTxO -> !Address
[utxoOutputCoin] :: UTxO -> !Coin
type UTxOId = Key UTxO
data UTxOToken
UTxOToken :: !WalletId -> !SlotNo -> !TxId -> !Word32 -> !TokenPolicyId -> !TokenName -> !TokenQuantity -> UTxOToken
[utxoTokenWalletId] :: UTxOToken -> !WalletId
[utxoTokenSlot] :: UTxOToken -> !SlotNo
[utxoTokenTxId] :: UTxOToken -> !TxId
[utxoTokenTxIndex] :: UTxOToken -> !Word32
[utxoTokenPolicyId] :: UTxOToken -> !TokenPolicyId
[utxoTokenName] :: UTxOToken -> !TokenName
[utxoTokenQuantity] :: UTxOToken -> !TokenQuantity
type UTxOTokenId = Key UTxOToken
data SeqState
SeqState :: !WalletId -> !AddressPoolGap -> !AddressPoolGap -> !ByteString -> !Maybe ByteString -> !ByteString -> !DerivationPrefix -> SeqState
[seqStateWalletId] :: SeqState -> !WalletId
[seqStateExternalGap] :: SeqState -> !AddressPoolGap
[seqStateInternalGap] :: SeqState -> !AddressPoolGap
[seqStateAccountXPub] :: SeqState -> !ByteString
[seqStatePolicyXPub] :: SeqState -> !Maybe ByteString
[seqStateRewardXPub] :: SeqState -> !ByteString
[seqStateDerivationPrefix] :: SeqState -> !DerivationPrefix
type SeqStateId = Key SeqState
data SeqStateAddress
SeqStateAddress :: !WalletId -> !SlotNo -> !Address -> !Word32 -> !Role -> !AddressState -> SeqStateAddress
[seqStateAddressWalletId] :: SeqStateAddress -> !WalletId
[seqStateAddressSlot] :: SeqStateAddress -> !SlotNo
[seqStateAddressAddress] :: SeqStateAddress -> !Address
[seqStateAddressIndex] :: SeqStateAddress -> !Word32
[seqStateAddressRole] :: SeqStateAddress -> !Role
[seqStateAddressStatus] :: SeqStateAddress -> !AddressState
type SeqStateAddressId = Key SeqStateAddress
data SeqStatePendingIx
SeqStatePendingIx :: !WalletId -> !Word32 -> SeqStatePendingIx
[seqStatePendingWalletId] :: SeqStatePendingIx -> !WalletId
[seqStatePendingIxIndex] :: SeqStatePendingIx -> !Word32
type SeqStatePendingIxId = Key SeqStatePendingIx
data RndState
RndState :: !WalletId -> !Word32 -> !StdGen -> !HDPassphrase -> RndState
[rndStateWalletId] :: RndState -> !WalletId
[rndStateAccountIndex] :: RndState -> !Word32
[rndStateGen] :: RndState -> !StdGen
[rndStateHdPassphrase] :: RndState -> !HDPassphrase
type RndStateId = Key RndState
data RndStateAddress
RndStateAddress :: !WalletId -> !SlotNo -> !Word32 -> !Word32 -> !Address -> !AddressState -> RndStateAddress
[rndStateAddressWalletId] :: RndStateAddress -> !WalletId
[rndStateAddressSlot] :: RndStateAddress -> !SlotNo
[rndStateAddressAccountIndex] :: RndStateAddress -> !Word32
[rndStateAddressIndex] :: RndStateAddress -> !Word32
[rndStateAddressAddress] :: RndStateAddress -> !Address
[rndStateAddressStatus] :: RndStateAddress -> !AddressState
type RndStateAddressId = Key RndStateAddress
data RndStatePendingAddress
RndStatePendingAddress :: !WalletId -> !Word32 -> !Word32 -> !Address -> RndStatePendingAddress
[rndStatePendingAddressWalletId] :: RndStatePendingAddress -> !WalletId
[rndStatePendingAddressAccountIndex] :: RndStatePendingAddress -> !Word32
[rndStatePendingAddressIndex] :: RndStatePendingAddress -> !Word32
[rndStatePendingAddressAddress] :: RndStatePendingAddress -> !Address
type RndStatePendingAddressId = Key RndStatePendingAddress
data SharedState
SharedState :: !WalletId -> !ByteString -> !AddressPoolGap -> !Script Cosigner -> !Maybe (Script Cosigner) -> !DerivationPrefix -> SharedState
[sharedStateWalletId] :: SharedState -> !WalletId
[sharedStateAccountXPub] :: SharedState -> !ByteString
[sharedStateScriptGap] :: SharedState -> !AddressPoolGap
[sharedStatePaymentScript] :: SharedState -> !Script Cosigner
[sharedStateDelegationScript] :: SharedState -> !Maybe (Script Cosigner)
[sharedStateDerivationPrefix] :: SharedState -> !DerivationPrefix
type SharedStateId = Key SharedState
data SharedStatePendingIx
SharedStatePendingIx :: !WalletId -> !Word32 -> SharedStatePendingIx
[sharedStatePendingWalletId] :: SharedStatePendingIx -> !WalletId
[sharedStatePendingIxIndex] :: SharedStatePendingIx -> !Word32
type SharedStatePendingIxId = Key SharedStatePendingIx
data CosignerKey
CosignerKey :: !WalletId -> !CredentialType -> !ByteString -> !Word8 -> CosignerKey
[cosignerKeyWalletId] :: CosignerKey -> !WalletId
[cosignerKeyCredential] :: CosignerKey -> !CredentialType
[cosignerKeyAccountXPub] :: CosignerKey -> !ByteString
[cosignerKeyIndex] :: CosignerKey -> !Word8
type CosignerKeyId = Key CosignerKey
migrateAll :: Migration
entityDefListFormigrateAll :: [EntityDef]
cosigner_key :: CosignerKey -> Key Wallet
shared_state_address_pending :: SharedStatePendingIx -> Key Wallet
shared_state :: SharedState -> Key Wallet
rnd_state_pending_address :: RndStatePendingAddress -> Key Wallet
rnd_state_address :: RndStateAddress -> Key Checkpoint
rnd_state :: RndState -> Key Wallet
seq_state_address_pending :: SeqStatePendingIx -> Key Wallet
seq_state_address :: SeqStateAddress -> Key Checkpoint
seq_state :: SeqState -> Key Wallet
utxot :: UTxOToken -> Key Checkpoint
utxo :: UTxO -> Key Checkpoint
delegationReward :: DelegationReward -> Key Wallet
delegationCertificate :: DelegationCertificate -> Key Wallet
stakeKeyRegistration :: StakeKeyCertificate -> Key Wallet
fk_wallet_protocol_parameters :: ProtocolParameters -> Key Wallet
checkpoint :: Checkpoint -> Key Wallet
fk_tx_meta :: LocalTxSubmission -> Key TxMeta
txCollateralOut :: TxCollateralOutToken -> Key TxCollateralOut
txOut :: TxOutToken -> Key TxOut
fk_wallet_tx_meta :: TxMeta -> Key Wallet
fk_wallet_private_key :: PrivateKey -> Key Wallet
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.Wallet
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.Wallet
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Wallet)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.PrivateKey
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.PrivateKey
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.PrivateKey)
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Schema.TxMeta
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.TxMeta
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.TxMeta
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxMeta)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxMeta)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxMeta)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxMeta)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxMeta)
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Schema.TxIn
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.TxIn
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.TxIn
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxIn)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxIn)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxIn)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxIn)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxIn)
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Schema.TxCollateral
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.TxCollateral
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.TxCollateral
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Schema.TxOut
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.TxOut
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.TxOut
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOut)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOut)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOut)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOut)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOut)
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Schema.TxOutToken
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.TxOutToken
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.TxOutToken
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOutToken)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOutToken)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOutToken)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOutToken)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOutToken)
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut)
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken)
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.Checkpoint
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.Checkpoint
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Checkpoint)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Checkpoint)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Checkpoint)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Checkpoint)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Checkpoint)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.DelegationReward
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.DelegationReward
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationReward)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.UTxO
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.UTxO
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxO)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxO)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxO)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxO)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxO)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.UTxOToken
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.UTxOToken
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.SeqState
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.SeqState
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqState)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.RndState
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.RndState
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndState)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.SharedState
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.SharedState
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedState)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx
instance GHC.Generics.Generic (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx)
instance GHC.Generics.Generic Cardano.Wallet.DB.Sqlite.Schema.CosignerKey
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Schema.CosignerKey
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance Web.Internal.HttpApiData.FromHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance Web.Internal.HttpApiData.ToHttpApiData (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance Web.PathPieces.PathPiece (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance GHC.Classes.Ord (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance GHC.Classes.Eq (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance GHC.Read.Read (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance GHC.Show.Show (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.CosignerKey
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.CosignerKey
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.CosignerKey
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.SqlBackend.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.Schema.CosignerKey
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.CosignerKey
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.CosignerKey
instance Database.Persist.Class.PersistEntity.SymbolToField "id" Cardano.Wallet.DB.Sqlite.Schema.CosignerKey (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.CosignerKey)
instance Database.Persist.Class.PersistEntity.SymbolToField "cosignerKeyWalletId" Cardano.Wallet.DB.Sqlite.Schema.CosignerKey Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "cosignerKeyCredential" Cardano.Wallet.DB.Sqlite.Schema.CosignerKey Cardano.Wallet.Primitive.AddressDiscovery.Shared.CredentialType
instance Database.Persist.Class.PersistEntity.SymbolToField "cosignerKeyAccountXPub" Cardano.Wallet.DB.Sqlite.Schema.CosignerKey Data.ByteString.Internal.ByteString
instance Database.Persist.Class.PersistEntity.SymbolToField "cosignerKeyIndex" Cardano.Wallet.DB.Sqlite.Schema.CosignerKey GHC.Word.Word8
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx
instance Database.Persist.Class.PersistEntity.SymbolToField "sharedStatePendingWalletId" Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "sharedStatePendingIxIndex" Cardano.Wallet.DB.Sqlite.Schema.SharedStatePendingIx GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.SharedState
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.SharedState
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.SharedState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.SharedState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.SharedState
instance Database.Persist.Class.PersistEntity.SymbolToField "sharedStateWalletId" Cardano.Wallet.DB.Sqlite.Schema.SharedState Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "sharedStateAccountXPub" Cardano.Wallet.DB.Sqlite.Schema.SharedState Data.ByteString.Internal.ByteString
instance Database.Persist.Class.PersistEntity.SymbolToField "sharedStateScriptGap" Cardano.Wallet.DB.Sqlite.Schema.SharedState Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Database.Persist.Class.PersistEntity.SymbolToField "sharedStatePaymentScript" Cardano.Wallet.DB.Sqlite.Schema.SharedState (Cardano.Address.Script.Script Cardano.Address.Script.Cosigner)
instance Database.Persist.Class.PersistEntity.SymbolToField "sharedStateDelegationScript" Cardano.Wallet.DB.Sqlite.Schema.SharedState (GHC.Maybe.Maybe (Cardano.Address.Script.Script Cardano.Address.Script.Cosigner))
instance Database.Persist.Class.PersistEntity.SymbolToField "sharedStateDerivationPrefix" Cardano.Wallet.DB.Sqlite.Schema.SharedState Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.SqlBackend.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress
instance Database.Persist.Class.PersistEntity.SymbolToField "id" Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress)
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStatePendingAddressWalletId" Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStatePendingAddressAccountIndex" Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStatePendingAddressIndex" Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStatePendingAddressAddress" Cardano.Wallet.DB.Sqlite.Schema.RndStatePendingAddress Cardano.Wallet.Primitive.Types.Address.Address
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.SqlBackend.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress
instance Database.Persist.Class.PersistEntity.SymbolToField "id" Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress)
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStateAddressWalletId" Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStateAddressSlot" Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStateAddressAccountIndex" Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStateAddressIndex" Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStateAddressAddress" Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress Cardano.Wallet.Primitive.Types.Address.Address
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStateAddressStatus" Cardano.Wallet.DB.Sqlite.Schema.RndStateAddress Cardano.Wallet.Primitive.Types.Address.AddressState
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.RndState
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.RndState
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.RndState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.RndState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.RndState
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStateWalletId" Cardano.Wallet.DB.Sqlite.Schema.RndState Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStateAccountIndex" Cardano.Wallet.DB.Sqlite.Schema.RndState GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStateGen" Cardano.Wallet.DB.Sqlite.Schema.RndState System.Random.Internal.StdGen
instance Database.Persist.Class.PersistEntity.SymbolToField "rndStateHdPassphrase" Cardano.Wallet.DB.Sqlite.Schema.RndState Cardano.Wallet.DB.Sqlite.Types.HDPassphrase
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStatePendingWalletId" Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStatePendingIxIndex" Cardano.Wallet.DB.Sqlite.Schema.SeqStatePendingIx GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.SqlBackend.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress
instance Database.Persist.Class.PersistEntity.SymbolToField "id" Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress)
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateAddressWalletId" Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateAddressSlot" Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateAddressAddress" Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress Cardano.Wallet.Primitive.Types.Address.Address
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateAddressIndex" Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateAddressRole" Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress Cardano.Wallet.Primitive.AddressDerivation.Role
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateAddressStatus" Cardano.Wallet.DB.Sqlite.Schema.SeqStateAddress Cardano.Wallet.Primitive.Types.Address.AddressState
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.SeqState
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.SeqState
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.SeqState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.SeqState
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.SeqState
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateWalletId" Cardano.Wallet.DB.Sqlite.Schema.SeqState Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateExternalGap" Cardano.Wallet.DB.Sqlite.Schema.SeqState Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateInternalGap" Cardano.Wallet.DB.Sqlite.Schema.SeqState Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateAccountXPub" Cardano.Wallet.DB.Sqlite.Schema.SeqState Data.ByteString.Internal.ByteString
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStatePolicyXPub" Cardano.Wallet.DB.Sqlite.Schema.SeqState (GHC.Maybe.Maybe Data.ByteString.Internal.ByteString)
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateRewardXPub" Cardano.Wallet.DB.Sqlite.Schema.SeqState Data.ByteString.Internal.ByteString
instance Database.Persist.Class.PersistEntity.SymbolToField "seqStateDerivationPrefix" Cardano.Wallet.DB.Sqlite.Schema.SeqState Cardano.Wallet.Primitive.AddressDerivation.DerivationPrefix
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.UTxOToken
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.UTxOToken
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.UTxOToken
instance Database.Persist.Class.PersistStore.ToBackendKey Database.Persist.SqlBackend.Internal.SqlBackend Cardano.Wallet.DB.Sqlite.Schema.UTxOToken
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.UTxOToken
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.UTxOToken
instance Database.Persist.Class.PersistEntity.SymbolToField "id" Cardano.Wallet.DB.Sqlite.Schema.UTxOToken (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxOToken)
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoTokenWalletId" Cardano.Wallet.DB.Sqlite.Schema.UTxOToken Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoTokenSlot" Cardano.Wallet.DB.Sqlite.Schema.UTxOToken Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoTokenTxId" Cardano.Wallet.DB.Sqlite.Schema.UTxOToken Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoTokenTxIndex" Cardano.Wallet.DB.Sqlite.Schema.UTxOToken GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoTokenPolicyId" Cardano.Wallet.DB.Sqlite.Schema.UTxOToken Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoTokenName" Cardano.Wallet.DB.Sqlite.Schema.UTxOToken Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoTokenQuantity" Cardano.Wallet.DB.Sqlite.Schema.UTxOToken Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.UTxO
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.UTxO
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.UTxO
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxO)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxO)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxO)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.UTxO)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.UTxO
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.UTxO
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoWalletId" Cardano.Wallet.DB.Sqlite.Schema.UTxO Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoSlot" Cardano.Wallet.DB.Sqlite.Schema.UTxO Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoInputId" Cardano.Wallet.DB.Sqlite.Schema.UTxO Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoInputIndex" Cardano.Wallet.DB.Sqlite.Schema.UTxO GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoOutputAddress" Cardano.Wallet.DB.Sqlite.Schema.UTxO Cardano.Wallet.Primitive.Types.Address.Address
instance Database.Persist.Class.PersistEntity.SymbolToField "utxoOutputCoin" Cardano.Wallet.DB.Sqlite.Schema.UTxO Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.DelegationReward
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.DelegationReward
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.DelegationReward
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.DelegationReward
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.DelegationReward
instance Database.Persist.Class.PersistEntity.SymbolToField "rewardWalletId" Cardano.Wallet.DB.Sqlite.Schema.DelegationReward Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "rewardAccountBalance" Cardano.Wallet.DB.Sqlite.Schema.DelegationReward GHC.Word.Word64
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate
instance Database.Persist.Class.PersistEntity.SymbolToField "certWalletId" Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "certSlot" Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "certPoolId" Cardano.Wallet.DB.Sqlite.Schema.DelegationCertificate (GHC.Maybe.Maybe Cardano.Wallet.Primitive.Types.PoolId)
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate
instance Database.Persist.Class.PersistEntity.SymbolToField "stakeKeyCertWalletId" Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "stakeKeyCertSlot" Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "stakeKeyCertType" Cardano.Wallet.DB.Sqlite.Schema.StakeKeyCertificate Cardano.Wallet.Primitive.Types.StakeKeyCertificate
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters
instance Database.Persist.Class.PersistEntity.SymbolToField "protocolParametersWalletId" Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "protocolParametersFeePolicy" Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters Cardano.Wallet.Primitive.Types.FeePolicy
instance Database.Persist.Class.PersistEntity.SymbolToField "protocolParametersTxMaxSize" Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters GHC.Word.Word16
instance Database.Persist.Class.PersistEntity.SymbolToField "protocolParametersDecentralizationLevel" Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters Data.Quantity.Percentage
instance Database.Persist.Class.PersistEntity.SymbolToField "protocolParametersDesiredNumberOfPools" Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters GHC.Word.Word16
instance Database.Persist.Class.PersistEntity.SymbolToField "protocolParametersMinimumUtxoValue" Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Class.PersistEntity.SymbolToField "protocolParametersHardforkEpoch" Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters (GHC.Maybe.Maybe Cardano.Wallet.Primitive.Types.EpochNo)
instance Database.Persist.Class.PersistEntity.SymbolToField "protocolParametersKeyDeposit" Cardano.Wallet.DB.Sqlite.Schema.ProtocolParameters Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.Checkpoint
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.Checkpoint
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.Checkpoint
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Checkpoint)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Checkpoint)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Checkpoint)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.Checkpoint)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.Checkpoint
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.Checkpoint
instance Database.Persist.Class.PersistEntity.SymbolToField "checkpointWalletId" Cardano.Wallet.DB.Sqlite.Schema.Checkpoint Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "checkpointSlot" Cardano.Wallet.DB.Sqlite.Schema.Checkpoint Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "checkpointHeaderHash" Cardano.Wallet.DB.Sqlite.Schema.Checkpoint Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Class.PersistEntity.SymbolToField "checkpointParentHash" Cardano.Wallet.DB.Sqlite.Schema.Checkpoint Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Class.PersistEntity.SymbolToField "checkpointBlockHeight" Cardano.Wallet.DB.Sqlite.Schema.Checkpoint GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission)
instance Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission
instance Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission
instance Database.Persist.Class.PersistEntity.SymbolToField "localTxSubmissionTxId" Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "localTxSubmissionWalletId" Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "localTxSubmissionLastSlot" Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "localTxSubmissionTx" Cardano.Wallet.DB.Sqlite.Schema.LocalTxSubmission Cardano.Wallet.Primitive.Types.Tx.SealedTx
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal
instance Database.Persist.Class.PersistEntity.SymbolToField "txWithdrawalTxId" Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "txWithdrawalAmount" Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Class.PersistEntity.SymbolToField "txWithdrawalAccount" Cardano.Wallet.DB.Sqlite.Schema.TxWithdrawal Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralOutTokenTxId" Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralOutTokenPolicyId" Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralOutTokenName" Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralOutTokenQuantity" Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOutToken Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralOutTxId" Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralOutAddress" Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut Cardano.Wallet.Primitive.Types.Address.Address
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralOutAmount" Cardano.Wallet.DB.Sqlite.Schema.TxCollateralOut Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.TxOutToken
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.TxOutToken
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.TxOutToken
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOutToken)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOutToken)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOutToken)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOutToken)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxOutToken
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxOutToken
instance Database.Persist.Class.PersistEntity.SymbolToField "txOutTokenTxId" Cardano.Wallet.DB.Sqlite.Schema.TxOutToken Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "txOutTokenTxIndex" Cardano.Wallet.DB.Sqlite.Schema.TxOutToken GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "txOutTokenPolicyId" Cardano.Wallet.DB.Sqlite.Schema.TxOutToken Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId
instance Database.Persist.Class.PersistEntity.SymbolToField "txOutTokenName" Cardano.Wallet.DB.Sqlite.Schema.TxOutToken Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName
instance Database.Persist.Class.PersistEntity.SymbolToField "txOutTokenQuantity" Cardano.Wallet.DB.Sqlite.Schema.TxOutToken Cardano.Wallet.Primitive.Types.TokenQuantity.TokenQuantity
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.TxOut
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.TxOut
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.TxOut
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOut)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOut)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOut)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxOut)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxOut
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxOut
instance Database.Persist.Class.PersistEntity.SymbolToField "txOutputTxId" Cardano.Wallet.DB.Sqlite.Schema.TxOut Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "txOutputIndex" Cardano.Wallet.DB.Sqlite.Schema.TxOut GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "txOutputAddress" Cardano.Wallet.DB.Sqlite.Schema.TxOut Cardano.Wallet.Primitive.Types.Address.Address
instance Database.Persist.Class.PersistEntity.SymbolToField "txOutputAmount" Cardano.Wallet.DB.Sqlite.Schema.TxOut Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.TxCollateral
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.TxCollateral
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.TxCollateral
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxCollateral
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxCollateral
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralTxId" Cardano.Wallet.DB.Sqlite.Schema.TxCollateral Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralOrder" Cardano.Wallet.DB.Sqlite.Schema.TxCollateral GHC.Types.Int
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralSourceTxId" Cardano.Wallet.DB.Sqlite.Schema.TxCollateral Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralSourceIndex" Cardano.Wallet.DB.Sqlite.Schema.TxCollateral GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "txCollateralSourceAmount" Cardano.Wallet.DB.Sqlite.Schema.TxCollateral Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.TxIn
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.TxIn
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.TxIn
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxIn)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxIn)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxIn)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxIn)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxIn
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxIn
instance Database.Persist.Class.PersistEntity.SymbolToField "txInputTxId" Cardano.Wallet.DB.Sqlite.Schema.TxIn Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "txInputOrder" Cardano.Wallet.DB.Sqlite.Schema.TxIn GHC.Types.Int
instance Database.Persist.Class.PersistEntity.SymbolToField "txInputSourceTxId" Cardano.Wallet.DB.Sqlite.Schema.TxIn Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "txInputSourceIndex" Cardano.Wallet.DB.Sqlite.Schema.TxIn GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "txInputSourceAmount" Cardano.Wallet.DB.Sqlite.Schema.TxIn Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.TxMeta
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.TxMeta
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.TxMeta
instance Database.Persist.Class.PersistField.PersistField (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxMeta)
instance Database.Persist.Sql.Class.PersistFieldSql (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxMeta)
instance Data.Aeson.Types.ToJSON.ToJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxMeta)
instance Data.Aeson.Types.FromJSON.FromJSON (Database.Persist.Class.PersistEntity.Key Cardano.Wallet.DB.Sqlite.Schema.TxMeta)
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxMeta
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.TxMeta
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetaTxId" Cardano.Wallet.DB.Sqlite.Schema.TxMeta Cardano.Wallet.DB.Sqlite.Types.TxId
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetaWalletId" Cardano.Wallet.DB.Sqlite.Schema.TxMeta Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetaStatus" Cardano.Wallet.DB.Sqlite.Schema.TxMeta Cardano.Wallet.Primitive.Types.Tx.TxStatus
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetaDirection" Cardano.Wallet.DB.Sqlite.Schema.TxMeta Cardano.Wallet.Primitive.Types.Tx.Direction
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetaSlot" Cardano.Wallet.DB.Sqlite.Schema.TxMeta Cardano.Slotting.Slot.SlotNo
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetaBlockHeight" Cardano.Wallet.DB.Sqlite.Schema.TxMeta GHC.Word.Word32
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetaAmount" Cardano.Wallet.DB.Sqlite.Schema.TxMeta Cardano.Wallet.Primitive.Types.Coin.Coin
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetadata" Cardano.Wallet.DB.Sqlite.Schema.TxMeta (GHC.Maybe.Maybe Cardano.Api.TxMetadata.TxMetadata)
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetaSlotExpires" Cardano.Wallet.DB.Sqlite.Schema.TxMeta (GHC.Maybe.Maybe Cardano.Slotting.Slot.SlotNo)
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetaFee" Cardano.Wallet.DB.Sqlite.Schema.TxMeta (GHC.Maybe.Maybe GHC.Word.Word64)
instance Database.Persist.Class.PersistEntity.SymbolToField "txMetaScriptValidity" Cardano.Wallet.DB.Sqlite.Schema.TxMeta (GHC.Maybe.Maybe GHC.Types.Bool)
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.PrivateKey
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.PrivateKey
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.PrivateKey
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.PrivateKey
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.PrivateKey
instance Database.Persist.Class.PersistEntity.SymbolToField "privateKeyWalletId" Cardano.Wallet.DB.Sqlite.Schema.PrivateKey Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "privateKeyRootKey" Cardano.Wallet.DB.Sqlite.Schema.PrivateKey Data.ByteString.Internal.ByteString
instance Database.Persist.Class.PersistEntity.SymbolToField "privateKeyHash" Cardano.Wallet.DB.Sqlite.Schema.PrivateKey Data.ByteString.Internal.ByteString
instance Database.Persist.Class.PersistEntity.PersistEntity Cardano.Wallet.DB.Sqlite.Schema.Wallet
instance Database.Persist.Class.PersistField.PersistField Cardano.Wallet.DB.Sqlite.Schema.Wallet
instance Database.Persist.Sql.Class.PersistFieldSql Cardano.Wallet.DB.Sqlite.Schema.Wallet
instance (TypeError ...) => Database.Persist.Class.PersistUnique.OnlyOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.Wallet
instance (TypeError ...) => Database.Persist.Class.PersistUnique.AtLeastOneUniqueKey Cardano.Wallet.DB.Sqlite.Schema.Wallet
instance Database.Persist.Class.PersistEntity.SymbolToField "walId" Cardano.Wallet.DB.Sqlite.Schema.Wallet Cardano.Wallet.Primitive.Types.WalletId
instance Database.Persist.Class.PersistEntity.SymbolToField "walCreationTime" Cardano.Wallet.DB.Sqlite.Schema.Wallet Data.Time.Clock.Internal.UTCTime.UTCTime
instance Database.Persist.Class.PersistEntity.SymbolToField "walName" Cardano.Wallet.DB.Sqlite.Schema.Wallet Data.Text.Internal.Text
instance Database.Persist.Class.PersistEntity.SymbolToField "walPassphraseLastUpdatedAt" Cardano.Wallet.DB.Sqlite.Schema.Wallet (GHC.Maybe.Maybe Data.Time.Clock.Internal.UTCTime.UTCTime)
instance Database.Persist.Class.PersistEntity.SymbolToField "walPassphraseScheme" Cardano.Wallet.DB.Sqlite.Schema.Wallet (GHC.Maybe.Maybe Cardano.Wallet.Primitive.Passphrase.Types.PassphraseScheme)
instance Database.Persist.Class.PersistEntity.SymbolToField "walGenesisHash" Cardano.Wallet.DB.Sqlite.Schema.Wallet Cardano.Wallet.DB.Sqlite.Types.BlockId
instance Database.Persist.Class.PersistEntity.SymbolToField "walGenesisStart" Cardano.Wallet.DB.Sqlite.Schema.Wallet Data.Time.Clock.Internal.UTCTime.UTCTime


-- | Data type <a>TxHistory</a> for storing a set of transactions.
--   Transactions are encoded "as" expressed in DB tables.
module Cardano.Wallet.DB.Store.Transactions.Model

-- | Verbs to change a <a>TxHistory</a>.
data DeltaTxHistory

-- | Add new set of transactions. Overwrites transactions whose id is
--   already present in the <a>TxHistory</a>.
Append :: TxHistory -> DeltaTxHistory

-- | Try to remove the transaction at the given transaction id.
DeleteTx :: TxId -> DeltaTxHistory

-- | Shortcut type for transaction history where inputs are not decorated
--   with their corresponding <a>TxOut</a>.
type TxHistory = TxHistoryF 'Without

-- | Transactions history is <a>TxRelationF</a>s indexed by <a>TxId</a>
newtype TxHistoryF f
TxHistoryF :: Map TxId (TxRelationF f) -> TxHistoryF f

-- | A low level definition of a transaction covering all transaction
--   content by collecting all related-to-index database rows.
--   Normalization is performed anyway after the first relation level. All
--   values used here are records in the database. Foreign keys are used to
--   group data correctly, but they are not removed from the data.
data TxRelationF (f :: Decoration)
TxRelationF :: [DecorateWithTxOut f TxIn] -> [DecorateWithTxOut f TxCollateral] -> [(TxOut, [TxOutToken])] -> Maybe (TxCollateralOut, [TxCollateralOutToken]) -> [TxWithdrawal] -> TxRelationF (f :: Decoration)
[$sel:ins:TxRelationF] :: TxRelationF (f :: Decoration) -> [DecorateWithTxOut f TxIn]
[$sel:collateralIns:TxRelationF] :: TxRelationF (f :: Decoration) -> [DecorateWithTxOut f TxCollateral]
[$sel:outs:TxRelationF] :: TxRelationF (f :: Decoration) -> [(TxOut, [TxOutToken])]
[$sel:collateralOuts:TxRelationF] :: TxRelationF (f :: Decoration) -> Maybe (TxCollateralOut, [TxCollateralOutToken])
[$sel:withdrawals:TxRelationF] :: TxRelationF (f :: Decoration) -> [TxWithdrawal]
tokenCollateralOrd :: TxCollateralOutToken -> (TokenPolicyId, TokenName)
tokenOutOrd :: TxOutToken -> (TokenPolicyId, TokenName)

-- | Convert high level transactions definition in low level DB history
mkTxHistory :: [Tx] -> TxHistory

-- | A kind to index the 2 flavours of a <a>TxRelationF</a>, with or
--   without <tt>TxOuts</tt>
data Decoration
Without :: Decoration
With :: Decoration

-- | A context that carries a TxOut together with its tokens (this will be
--   needed in the future for the DB Layer to reconstruct
--   <tt>TransactionInfo</tt>).
data WithTxOut txin
WithTxOut :: txin -> Maybe (TxOut, [TxOutToken]) -> WithTxOut txin
[$sel:txIn:WithTxOut] :: WithTxOut txin -> txin
[$sel:context:WithTxOut] :: WithTxOut txin -> Maybe (TxOut, [TxOutToken])
decorateWithTxOuts :: TxHistoryF 'Without -> TxHistoryF 'With
mkTxIn :: TxId -> (Int, (TxIn, Coin)) -> TxIn
mkTxCollateral :: TxId -> (Int, (TxIn, Coin)) -> TxCollateral
mkTxOut :: TxId -> (Word32, TxOut) -> (TxOut, [TxOutToken])
undecorateFromTxOuts :: TxHistoryF 'With -> TxHistoryF 'Without
instance GHC.Base.Functor Cardano.Wallet.DB.Store.Transactions.Model.WithTxOut
instance GHC.Classes.Eq txin => GHC.Classes.Eq (Cardano.Wallet.DB.Store.Transactions.Model.WithTxOut txin)
instance GHC.Show.Show txin => GHC.Show.Show (Cardano.Wallet.DB.Store.Transactions.Model.WithTxOut txin)
instance GHC.Generics.Generic (Cardano.Wallet.DB.Store.Transactions.Model.TxRelationF f)
instance GHC.Generics.Generic (Cardano.Wallet.DB.Store.Transactions.Model.TxHistoryF f)
instance GHC.Generics.Generic Cardano.Wallet.DB.Store.Transactions.Model.DeltaTxHistory
instance GHC.Classes.Eq Cardano.Wallet.DB.Store.Transactions.Model.DeltaTxHistory
instance GHC.Show.Show Cardano.Wallet.DB.Store.Transactions.Model.DeltaTxHistory
instance (GHC.Classes.Eq (Cardano.Wallet.DB.Store.Transactions.Model.DecorateWithTxOut f Cardano.Wallet.DB.Sqlite.Schema.TxIn), GHC.Classes.Eq (Cardano.Wallet.DB.Store.Transactions.Model.DecorateWithTxOut f Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)) => GHC.Classes.Eq (Cardano.Wallet.DB.Store.Transactions.Model.TxRelationF f)
instance (GHC.Show.Show (Cardano.Wallet.DB.Store.Transactions.Model.DecorateWithTxOut f Cardano.Wallet.DB.Sqlite.Schema.TxIn), GHC.Show.Show (Cardano.Wallet.DB.Store.Transactions.Model.DecorateWithTxOut f Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)) => GHC.Show.Show (Cardano.Wallet.DB.Store.Transactions.Model.TxRelationF f)
instance (GHC.Classes.Eq (Cardano.Wallet.DB.Store.Transactions.Model.DecorateWithTxOut f Cardano.Wallet.DB.Sqlite.Schema.TxIn), GHC.Classes.Eq (Cardano.Wallet.DB.Store.Transactions.Model.DecorateWithTxOut f Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)) => GHC.Classes.Eq (Cardano.Wallet.DB.Store.Transactions.Model.TxHistoryF f)
instance (GHC.Show.Show (Cardano.Wallet.DB.Store.Transactions.Model.DecorateWithTxOut f Cardano.Wallet.DB.Sqlite.Schema.TxIn), GHC.Show.Show (Cardano.Wallet.DB.Store.Transactions.Model.DecorateWithTxOut f Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)) => GHC.Show.Show (Cardano.Wallet.DB.Store.Transactions.Model.TxHistoryF f)
instance Formatting.Buildable.Buildable Cardano.Wallet.DB.Store.Transactions.Model.DeltaTxHistory
instance Data.Delta.Delta Cardano.Wallet.DB.Store.Transactions.Model.DeltaTxHistory
instance GHC.Base.Monoid (Cardano.Wallet.DB.Store.Transactions.Model.TxHistoryF f)
instance GHC.Base.Semigroup (Cardano.Wallet.DB.Store.Transactions.Model.TxHistoryF f)
instance (GHC.Show.Show (Cardano.Wallet.DB.Store.Transactions.Model.DecorateWithTxOut f Cardano.Wallet.DB.Sqlite.Schema.TxIn), GHC.Show.Show (Cardano.Wallet.DB.Store.Transactions.Model.DecorateWithTxOut f Cardano.Wallet.DB.Sqlite.Schema.TxCollateral)) => Formatting.Buildable.Buildable (Cardano.Wallet.DB.Store.Transactions.Model.TxHistoryF f)


-- | Implementation of a <a>Store</a> for <a>TxHistory</a>.
module Cardano.Wallet.DB.Store.Transactions.Store

-- | Select transactions history from the database
selectTxHistory :: SqlPersistT IO TxHistory

-- | Insert multiple transactions
putTxHistory :: TxHistory -> SqlPersistT IO ()
mkStoreTransactions :: Store (SqlPersistT IO) DeltaTxHistory


-- | Pure, low level model for a collection of "meta transactions", i.e.
--   additional data (<a>TxMeta</a>) that the wallet stores for each
--   transaction. Meta transactions are encoded "as" expressed in DB
--   tables.
module Cardano.Wallet.DB.Store.Meta.Model

-- | All meta-transactions changes, including the addition of new
--   meta-transactions, which has to be done in sync with the transactions
--   store.
data DeltaTxMetaHistory
Manipulate :: ManipulateTxMetaHistory -> DeltaTxMetaHistory
Expand :: TxMetaHistory -> DeltaTxMetaHistory

-- | Verbs for <a>TxMeta</a> changes that can be issued independently from
--   the transaction store.
data ManipulateTxMetaHistory

-- | Remove a meta if it is <i>not</i> in the ledger.
PruneTxMetaHistory :: TxId -> ManipulateTxMetaHistory

-- | Change the state of any meta to <tt>Expired</tt> if the given slot is
--   equal or after its expiration slot.
AgeTxMetaHistory :: SlotNo -> ManipulateTxMetaHistory

-- | Remove all incoming transactions created after the given slot and mark
--   all outgoing transactions after the given slot as <tt>Pending</tt>.
RollBackTxMetaHistory :: SlotNo -> ManipulateTxMetaHistory

-- | A collection of <a>TxMeta</a>, indexed by transaction identifier.
newtype TxMetaHistory
TxMetaHistory :: Map TxId TxMeta -> TxMetaHistory
[relations] :: TxMetaHistory -> Map TxId TxMeta

-- | Compute a <a>TxMetaHistory</a> for a wallet.
mkTxMetaHistory :: WalletId -> [(Tx, TxMeta)] -> TxMetaHistory
instance GHC.Base.Semigroup Cardano.Wallet.DB.Store.Meta.Model.TxMetaHistory
instance GHC.Base.Monoid Cardano.Wallet.DB.Store.Meta.Model.TxMetaHistory
instance GHC.Show.Show Cardano.Wallet.DB.Store.Meta.Model.TxMetaHistory
instance GHC.Classes.Eq Cardano.Wallet.DB.Store.Meta.Model.TxMetaHistory
instance GHC.Generics.Generic Cardano.Wallet.DB.Store.Meta.Model.TxMetaHistory
instance GHC.Show.Show Cardano.Wallet.DB.Store.Meta.Model.ManipulateTxMetaHistory
instance GHC.Classes.Eq Cardano.Wallet.DB.Store.Meta.Model.ManipulateTxMetaHistory
instance GHC.Classes.Eq Cardano.Wallet.DB.Store.Meta.Model.DeltaTxMetaHistory
instance GHC.Show.Show Cardano.Wallet.DB.Store.Meta.Model.DeltaTxMetaHistory
instance Formatting.Buildable.Buildable Cardano.Wallet.DB.Store.Meta.Model.DeltaTxMetaHistory
instance Data.Delta.Delta Cardano.Wallet.DB.Store.Meta.Model.DeltaTxMetaHistory
instance Data.Delta.Delta Cardano.Wallet.DB.Store.Meta.Model.ManipulateTxMetaHistory
instance Formatting.Buildable.Buildable Cardano.Wallet.DB.Store.Meta.Model.TxMetaHistory


-- | Pure model for the transactions (<tt>Tx</tt>) and metadata about them
--   (<a>TxMeta</a>) in a collection of wallets.
module Cardano.Wallet.DB.Store.Wallets.Model

-- | Verbs to change transactions store and wallet-indexed meta stores.
data DeltaTxWalletsHistory

-- | Add transactions and meta for a wallet.
ExpandTxWalletsHistory :: WalletId -> [(Tx, TxMeta)] -> DeltaTxWalletsHistory

-- | Change metas for a wallet.
ChangeTxMetaWalletsHistory :: WalletId -> ManipulateTxMetaHistory -> DeltaTxWalletsHistory

-- | Delete all transactions that have no metas.
GarbageCollectTxWalletsHistory :: DeltaTxWalletsHistory

-- | Remove all metas of a wallet.
RemoveWallet :: WalletId -> DeltaTxWalletsHistory

-- | Transactions history is a shared transactions store together with a
--   set of meta-transactions stores indexed by wallet.
type TxWalletsHistory = (TxHistory, Map WalletId TxMetaHistory)
walletsLinkedTransactions :: Map WalletId TxMetaHistory -> Set TxId

-- | Compute a high level view of a transaction known as
--   <tt>TransactionInfo</tt> from a <a>TxMeta</a> and a
--   <a>TxRelationF</a>. Assumes that these data refer to the same
--   <a>TxId</a>, does <i>not</i> check this.
mkTransactionInfo :: Monad m => TimeInterpreter m -> BlockHeader -> TxRelationF 'With -> TxMeta -> m TransactionInfo
instance GHC.Classes.Eq Cardano.Wallet.DB.Store.Wallets.Model.DeltaTxWalletsHistory
instance GHC.Show.Show Cardano.Wallet.DB.Store.Wallets.Model.DeltaTxWalletsHistory
instance Data.Delta.Delta Cardano.Wallet.DB.Store.Wallets.Model.DeltaTxWalletsHistory
instance Formatting.Buildable.Buildable Cardano.Wallet.DB.Store.Wallets.Model.DeltaTxWalletsHistory


-- | Low level <a>Store</a> for a collection of meta-transactions, i.e.
--   additional data (<a>TxMeta</a>) that the wallet stores for each
--   transaction. Meta-transactions are specific to a wallet.
module Cardano.Wallet.DB.Store.Meta.Store

-- | Create an SQL store to hold meta transactions for a wallet.
mkStoreMetaTransactions :: WalletId -> Store (SqlPersistT IO) DeltaTxMetaHistory


-- | Implementation of a store for <tt>TxWalletsHistory</tt>
module Cardano.Wallet.DB.Store.Wallets.Store

-- | Store for <a>DeltaTxWalletsHistory</a>.
mkStoreTxWalletsHistory :: Store (SqlPersistT IO) DeltaTxWalletsHistory

-- | Verbs to change transactions store and wallet-indexed meta stores.
data DeltaTxWalletsHistory

-- | Add transactions and meta for a wallet.
ExpandTxWalletsHistory :: WalletId -> [(Tx, TxMeta)] -> DeltaTxWalletsHistory

-- | Change metas for a wallet.
ChangeTxMetaWalletsHistory :: WalletId -> ManipulateTxMetaHistory -> DeltaTxWalletsHistory

-- | Delete all transactions that have no metas.
GarbageCollectTxWalletsHistory :: DeltaTxWalletsHistory

-- | Remove all metas of a wallet.
RemoveWallet :: WalletId -> DeltaTxWalletsHistory

-- | Store for a map of <a>DeltaTxMetaHistory</a> of multiple different
--   wallets.
mkStoreWalletsMeta :: Store (SqlPersistT IO) (DeltaMap WalletId DeltaTxMetaHistory)


-- | An implementation of the wallet database using only pure functions.
--   
--   These functions and types model the behaviour of the SQLite database
--   backend, and are used for QuickCheck state machine testing, and the
--   MVar database backend.
module Cardano.Wallet.DB.Pure.Implementation

-- | Model database, parameterised by the wallet ID type, the wallet AD
--   state type, the target backend, and the private key type.
--   
--   Tne type parameters exist so that simpler mock types can be used in
--   place of actual wallet types.
data Database wid s xprv
Database :: !Map wid (WalletDatabase s xprv) -> !Map (Hash "Tx") Tx -> Database wid s xprv

-- | Wallet-related information.
[$sel:wallets:Database] :: Database wid s xprv -> !Map wid (WalletDatabase s xprv)

-- | In the database, transactions are global and not associated with any
--   particular wallet.
[$sel:txs:Database] :: Database wid s xprv -> !Map (Hash "Tx") Tx

-- | Model database record for a single wallet.
data WalletDatabase s xprv
WalletDatabase :: !Map SlotNo (Wallet s) -> !Map SlotNo (Maybe PoolId) -> !Map SlotNo StakeKeyCertificate -> !WalletMetadata -> !Map (Hash "Tx") TxMeta -> !Maybe xprv -> !GenesisParameters -> !Coin -> !Map (Hash "Tx") (SealedTx, SlotNo) -> WalletDatabase s xprv
[$sel:checkpoints:WalletDatabase] :: WalletDatabase s xprv -> !Map SlotNo (Wallet s)
[$sel:certificates:WalletDatabase] :: WalletDatabase s xprv -> !Map SlotNo (Maybe PoolId)
[$sel:stakeKeys:WalletDatabase] :: WalletDatabase s xprv -> !Map SlotNo StakeKeyCertificate
[$sel:metadata:WalletDatabase] :: WalletDatabase s xprv -> !WalletMetadata
[$sel:txHistory:WalletDatabase] :: WalletDatabase s xprv -> !Map (Hash "Tx") TxMeta
[$sel:xprv:WalletDatabase] :: WalletDatabase s xprv -> !Maybe xprv
[$sel:genesisParameters:WalletDatabase] :: WalletDatabase s xprv -> !GenesisParameters
[$sel:rewardAccountBalance:WalletDatabase] :: WalletDatabase s xprv -> !Coin
[$sel:submittedTxs:WalletDatabase] :: WalletDatabase s xprv -> !Map (Hash "Tx") (SealedTx, SlotNo)

-- | Produces an empty model database.
emptyDatabase :: Ord wid => Database wid s xprv

-- | Shorthand for the readTxHistory result type.
type TxHistory = [(Tx, TxMeta)]

-- | Shorthand for the putTxHistory argument type.
type TxHistoryMap = Map (Hash "Tx") (Tx, TxMeta)

-- | Apply optional filters on slotNo and sort using the default sort order
--   (first time/slotNo, then by TxId) to a <a>TxHistory</a>.
filterTxHistory :: Maybe Coin -> SortOrder -> Range SlotNo -> TxHistory -> TxHistory

-- | A database model operation, which is a function that takes a database
--   and returns: * a value, which is a query of the database, or an error;
--   and * a (possibly) modified database.
type ModelOp wid s xprv a = Database wid s xprv -> (Either (Err wid) a, Database wid s xprv)

-- | All of the possible errors that any of the model database functions
--   might return.
data Err wid
NoSuchWallet :: wid -> Err wid
WalletAlreadyExists :: wid -> Err wid
NoSuchTx :: wid -> Hash "Tx" -> Err wid
CantRemoveTxInLedger :: wid -> Hash "Tx" -> Err wid
mCleanDB :: Ord wid => ModelOp wid s xprv ()
mInitializeWallet :: forall wid s xprv. Ord wid => wid -> Wallet s -> WalletMetadata -> TxHistory -> GenesisParameters -> ModelOp wid s xprv ()
mRemoveWallet :: Ord wid => wid -> ModelOp wid s xprv ()
mListWallets :: Ord wid => ModelOp wid s xprv [wid]
mPutCheckpoint :: Ord wid => wid -> Wallet s -> ModelOp wid s xprv ()
mReadCheckpoint :: Ord wid => wid -> ModelOp wid s xprv (Maybe (Wallet s))
mListCheckpoints :: Ord wid => wid -> ModelOp wid s xprv [ChainPoint]
mRollbackTo :: Ord wid => wid -> Slot -> ModelOp wid s xprv ChainPoint
mPutWalletMeta :: Ord wid => wid -> WalletMetadata -> ModelOp wid s xprv ()
mReadWalletMeta :: Ord wid => TimeInterpreter Identity -> wid -> ModelOp wid s xprv (Maybe WalletMetadata)
mPutDelegationCertificate :: Ord wid => wid -> DelegationCertificate -> SlotNo -> ModelOp wid s xprv ()
mIsStakeKeyRegistered :: Ord wid => wid -> ModelOp wid s xprv Bool
mPutTxHistory :: forall wid s xprv. Ord wid => wid -> TxHistory -> ModelOp wid s xprv ()
mReadTxHistory :: forall wid s xprv. Ord wid => TimeInterpreter Identity -> wid -> Maybe Coin -> SortOrder -> Range SlotNo -> Maybe TxStatus -> ModelOp wid s xprv [TransactionInfo]
mPutLocalTxSubmission :: Ord wid => wid -> Hash "Tx" -> SealedTx -> SlotNo -> ModelOp wid s xprv ()
mReadLocalTxSubmissionPending :: Ord wid => wid -> ModelOp wid s xprv [LocalTxSubmissionStatus SealedTx]
mUpdatePendingTxForExpiry :: Ord wid => wid -> SlotNo -> ModelOp wid s xprv ()
mRemovePendingOrExpiredTx :: Ord wid => wid -> Hash "Tx" -> ModelOp wid s xprv ()
mPutPrivateKey :: Ord wid => wid -> xprv -> ModelOp wid s xprv ()
mReadPrivateKey :: Ord wid => wid -> ModelOp wid s xprv (Maybe xprv)
mReadGenesisParameters :: Ord wid => wid -> ModelOp wid s xprv (Maybe GenesisParameters)
mPutDelegationRewardBalance :: Ord wid => wid -> Coin -> ModelOp wid s xprv ()
mReadDelegationRewardBalance :: Ord wid => wid -> ModelOp wid s xprv Coin
mCheckWallet :: Ord wid => wid -> ModelOp wid s xprv ()
instance (Control.DeepSeq.NFData s, Control.DeepSeq.NFData xprv) => Control.DeepSeq.NFData (Cardano.Wallet.DB.Pure.Implementation.WalletDatabase s xprv)
instance GHC.Generics.Generic (Cardano.Wallet.DB.Pure.Implementation.WalletDatabase s xprv)
instance (GHC.Classes.Eq s, GHC.Classes.Eq xprv) => GHC.Classes.Eq (Cardano.Wallet.DB.Pure.Implementation.WalletDatabase s xprv)
instance (GHC.Show.Show s, GHC.Show.Show xprv) => GHC.Show.Show (Cardano.Wallet.DB.Pure.Implementation.WalletDatabase s xprv)
instance (Control.DeepSeq.NFData wid, Control.DeepSeq.NFData s, Control.DeepSeq.NFData xprv) => Control.DeepSeq.NFData (Cardano.Wallet.DB.Pure.Implementation.Database wid s xprv)
instance GHC.Generics.Generic (Cardano.Wallet.DB.Pure.Implementation.Database wid s xprv)
instance Data.Traversable.Traversable Cardano.Wallet.DB.Pure.Implementation.Err
instance Data.Foldable.Foldable Cardano.Wallet.DB.Pure.Implementation.Err
instance GHC.Base.Functor Cardano.Wallet.DB.Pure.Implementation.Err
instance GHC.Classes.Eq wid => GHC.Classes.Eq (Cardano.Wallet.DB.Pure.Implementation.Err wid)
instance GHC.Show.Show wid => GHC.Show.Show (Cardano.Wallet.DB.Pure.Implementation.Err wid)
instance (GHC.Show.Show wid, GHC.Show.Show s, GHC.Show.Show xprv) => GHC.Show.Show (Cardano.Wallet.DB.Pure.Implementation.Database wid s xprv)
instance (GHC.Classes.Eq wid, GHC.Classes.Eq xprv, GHC.Classes.Eq s) => GHC.Classes.Eq (Cardano.Wallet.DB.Pure.Implementation.Database wid s xprv)


-- | Data type that represents a collection of checkpoints. Each
--   checkpoints is associated with a <tt>Slot</tt>.
module Cardano.Wallet.Checkpoints

-- | Collection of checkpoints indexed by <tt>Slot</tt>.
data Checkpoints a

-- | Map of checkpoints. Always contains the genesis checkpoint.
checkpoints :: Checkpoints a -> Map Slot a

-- | Turn the list of checkpoints into a map of checkpoints.
--   
--   FIXME LATER during ADP-1043: The database actually does not store the
--   checkpoint at genesis, but the checkpoint after that. Hence, this
--   function does not check whether the genesis checkpoint is in the list
--   of checkpoints.
loadCheckpoints :: [(Slot, a)] -> Checkpoints a

-- | Begin with the genesis checkpoint.
fromGenesis :: a -> Checkpoints a

-- | Get the checkpoint with the largest <tt>SlotNo</tt>.
getLatest :: Checkpoints a -> (Slot, a)

-- | Find the nearest <tt>Checkpoint</tt> that is either at the given point
--   or before.
findNearestPoint :: Checkpoints a -> Slot -> Maybe Slot
data DeltaCheckpoints a
PutCheckpoint :: Slot -> a -> DeltaCheckpoints a
RollbackTo :: Slot -> DeltaCheckpoints a

-- | Restrict to the intersection of this list with the checkpoints that
--   are already present. The genesis checkpoint will always be present.
RestrictTo :: [Slot] -> DeltaCheckpoints a
type DeltasCheckpoints a = [DeltaCheckpoints a]

-- | Captures the configuration for the <a>sparseCheckpoints</a> function.
--   
--   NOTE: large values of <a>edgeSize</a> aren't recommended as they would
--   mean storing many unnecessary checkpoints. In Ouroboros Praos, there's
--   a reasonable probability for small forks each a few blocks deep so it
--   makes sense to maintain a small part that is denser near the edge.
data SparseCheckpointsConfig
SparseCheckpointsConfig :: Word8 -> Word32 -> SparseCheckpointsConfig
[edgeSize] :: SparseCheckpointsConfig -> Word8
[epochStability] :: SparseCheckpointsConfig -> Word32

-- | A sensible default to use in production. See also
--   <a>SparseCheckpointsConfig</a>
defaultSparseCheckpointsConfig :: Quantity "block" Word32 -> SparseCheckpointsConfig

-- | Storing EVERY checkpoints in the database is quite expensive and
--   useless. We make the following assumptions:
--   
--   <ul>
--   <li>We can't rollback for more than `k=epochStability` blocks in the
--   past</li>
--   <li>It is pretty fast to re-sync a few hundred blocks</li>
--   <li>Small rollbacks may occur more often than deep ones</li>
--   </ul>
--   
--   So, as we insert checkpoints, we make sure to:
--   
--   <ul>
--   <li>Prune any checkpoint that more than <tt>k</tt> blocks in the
--   past</li>
--   <li>Keep only one checkpoint every 100 blocks</li>
--   <li>But still keep ~10 most recent checkpoints to cope with small
--   rollbacks</li>
--   </ul>
--   
--   <b>Example 1</b>: Inserting <tt>cp153</tt>
--   
--   â„¹: <tt>cp142</tt> is discarded and <tt>cp153</tt> inserted.
--   
--   <pre>
--    Currently in DB:
--   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€  â”€â”€â”¬â”€â”€â”€â”
--   â”‚cp000 â”‚cp100 â”‚cp142 â”‚..    ..â”‚cp152 â”‚
--   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€  â”€â”€â”´â”€â”€â”€â”˜
--    Want in DB:
--   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€  â”€â”€â”¬â”€â”€â”€â”
--   â”‚cp000 â”‚cp100 â”‚cp143 â”‚..    ..â”‚cp153 â”‚
--   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€  â”€â”€â”´â”€â”€â”€â”˜
--    
--   </pre>
--   
--   <b>Example 2</b>: Inserting <tt>cp111</tt>
--   
--   â„¹: <tt>cp100</tt> is kept and <tt>cp111</tt> inserted.
--   
--   <pre>
--    Currently in DB:
--   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€  â”€â”€â”¬â”€â”€â”€â”
--   â”‚cp000 â”‚cp100 â”‚cp101 â”‚..    ..â”‚cp110 â”‚
--   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€  â”€â”€â”´â”€â”€â”€â”˜
--    Want in DB:
--   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€  â”€â”€â”¬â”€â”€â”€â”
--   â”‚cp000 â”‚cp100 â”‚cp101 â”‚..    ..â”‚cp111 â”‚
--   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€  â”€â”€â”´â”€â”€â”€â”˜
--    
--   </pre>
--   
--   NOTE: There might be cases where the chain following "fails" (because,
--   for example, the node has switched to a different chain, different by
--   more than k), and in such cases, we have no choice but rolling back
--   from genesis. Therefore, we need to keep the very first checkpoint in
--   the database, no matter what.
sparseCheckpoints :: SparseCheckpointsConfig -> Quantity "block" Word32 -> [Word32]

-- | A reasonable gap size used internally in <a>sparseCheckpoints</a>.
--   
--   <tt>Reasonable</tt> means that it's not _too frequent_ and it's not
--   too large. A value that is too small in front of k would require
--   generating much more checkpoints than necessary.
--   
--   A value that is larger than <tt>k</tt> may have dramatic consequences
--   in case of deep rollbacks.
--   
--   As a middle ground, we current choose `k / 3`, which is justified by:
--   
--   <ul>
--   <li>The current speed of the network layer (several thousands blocks
--   per seconds)</li>
--   <li>The current value of k = 2160</li>
--   </ul>
--   
--   So, `k / 3` = 720, which should remain around a second of time needed
--   to catch up in case of large rollbacks.
gapSize :: SparseCheckpointsConfig -> Word32
instance GHC.Generics.Generic (Cardano.Wallet.Checkpoints.Checkpoints a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Checkpoints.Checkpoints a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Checkpoints.Checkpoints a)
instance GHC.Show.Show Cardano.Wallet.Checkpoints.SparseCheckpointsConfig
instance Data.Delta.Delta (Cardano.Wallet.Checkpoints.DeltaCheckpoints a)
instance Formatting.Buildable.Buildable (Cardano.Wallet.Checkpoints.DeltaCheckpoints a)


-- | Pure data type which represents the entire wallet state, including all
--   checkpoints.
--   
--   FIXME during ADP-1043: Actually include everything, e.g. TxHistory,
--   Pending transactions, â€¦
module Cardano.Wallet.DB.WalletState

-- | Wallet state. Currently includes:
--   
--   <ul>
--   <li>Prologue of the address discovery state</li>
--   <li>Checkpoints of UTxO and of discoveries of the address discovery
--   state.</li>
--   </ul>
--   
--   FIXME during ADP-1043: Include also TxHistory, pending transactions,
--   â€¦, everything.
data WalletState s
WalletState :: !Prologue s -> !Checkpoints (WalletCheckpoint s) -> WalletState s
[prologue] :: WalletState s -> !Prologue s
[checkpoints] :: WalletState s -> !Checkpoints (WalletCheckpoint s)

-- | Create a wallet from the genesis block.
fromGenesis :: AddressBookIso s => Wallet s -> Maybe (WalletState s)

-- | Get the wallet checkpoint with the largest slot number
getLatest :: AddressBookIso s => WalletState s -> Wallet s

-- | Find the nearest <tt>Checkpoint</tt> that is either at the given point
--   or before.
findNearestPoint :: WalletState s -> Slot -> Maybe Slot

-- | Data stored in a single checkpoint. Only includes the <a>UTxO</a> and
--   the <a>Discoveries</a>, but not the <a>Prologue</a>.
data WalletCheckpoint s
WalletCheckpoint :: !BlockHeader -> !UTxO -> !Discoveries s -> WalletCheckpoint s
[currentTip] :: WalletCheckpoint s -> !BlockHeader
[utxo] :: WalletCheckpoint s -> !UTxO
[discoveries] :: WalletCheckpoint s -> !Discoveries s

-- | Convert a stored <a>WalletCheckpoint</a> to the legacy <a>Wallet</a>
--   state.
toWallet :: AddressBookIso s => Prologue s -> WalletCheckpoint s -> Wallet s

-- | Convert a legacy <a>Wallet</a> state to a <a>Prologue</a> and a
--   <a>WalletCheckpoint</a>
fromWallet :: AddressBookIso s => Wallet s -> (Prologue s, WalletCheckpoint s)

-- | Helper function: Get the block height of a wallet checkpoint.
getBlockHeight :: WalletCheckpoint s -> Word32

-- | Helper function: Get the <tt>Slot</tt> of a wallet checkpoint.
getSlot :: WalletCheckpoint s -> Slot
data DeltaWalletState1 s

-- | Replace the prologue of the address discovery state
ReplacePrologue :: Prologue s -> DeltaWalletState1 s

-- | Update the wallet checkpoints.
UpdateCheckpoints :: DeltasCheckpoints (WalletCheckpoint s) -> DeltaWalletState1 s
type DeltaWalletState s = [DeltaWalletState1 s]

-- | Delta type for <a>Map</a>.
data DeltaMap key da
Insert :: key -> Base da -> DeltaMap key da
Delete :: key -> DeltaMap key da
Adjust :: key -> da -> DeltaMap key da

-- | Can't perform given operation because there's no wallet
newtype ErrNoSuchWallet
ErrNoSuchWallet :: WalletId -> ErrNoSuchWallet

-- | Adjust a specific wallet if it exists or return
--   <a>ErrNoSuchWallet</a>.
adjustNoSuchWallet :: WalletId -> (ErrNoSuchWallet -> e) -> (w -> Either e (dw, b)) -> Map WalletId w -> (Maybe (DeltaMap WalletId dw), Either e b)
instance GHC.Generics.Generic (Cardano.Wallet.DB.WalletState.WalletCheckpoint s)
instance GHC.Generics.Generic (Cardano.Wallet.DB.WalletState.WalletState s)
instance GHC.Show.Show Cardano.Wallet.DB.WalletState.ErrNoSuchWallet
instance GHC.Classes.Eq Cardano.Wallet.DB.WalletState.ErrNoSuchWallet
instance Cardano.Wallet.Address.Book.AddressBookIso s => GHC.Classes.Eq (Cardano.Wallet.DB.WalletState.WalletCheckpoint s)
instance Cardano.Wallet.Address.Book.AddressBookIso s => GHC.Classes.Eq (Cardano.Wallet.DB.WalletState.WalletState s)
instance Data.Delta.Delta (Cardano.Wallet.DB.WalletState.DeltaWalletState1 s)
instance Formatting.Buildable.Buildable (Cardano.Wallet.DB.WalletState.DeltaWalletState1 s)
instance GHC.Show.Show (Cardano.Wallet.DB.WalletState.DeltaWalletState1 s)


-- | Database / Persistence layer for the wallet backend. This is where we
--   define the interface allowing us to store and fetch various data on
--   our wallets.
module Cardano.Wallet.DB

-- | A Database interface for storing various things in a DB. In practice,
--   we'll need some extra constraints on the wallet state that allows us
--   to serialize and unserialize it (e.g. <tt>forall s. (Serialize s)
--   =&gt; ...</tt>)
--   
--   NOTE:
--   
--   We can't use record accessors on the DBLayer as it carries an
--   existential within its constructor. We are forced to pattern-match on
--   the <a>DBLayer</a> record type in order to be able to use its methods
--   in any context. With NamedFieldPuns, or RecordWildCards, this can be
--   quite easy:
--   
--   <pre>
--   myFunction DBLayer{..} = do
--       ...
--   
--   myOtherFunction DBLayer{atomically,initializeWallet} = do
--       ...
--   </pre>
--   
--   Alternatively, in some other context where the database may not be a
--   function argument but come from a different source, it is possible to
--   simply rely on 'Data.Function.(&amp;)' to easily pattern match on it:
--   
--   <pre>
--   myFunction arg0 arg1 = db &amp; DBLayer{..} -&gt; do
--       ...
--     where
--       db = ...
--   </pre>
--   
--   Note that it isn't possible to simply use a <tt>where</tt> clause or a
--   <tt>let</tt> binding here as the semantic for those are slightly
--   different: we really need a pattern match here!
data DBLayer m s k
DBLayer :: (WalletId -> Wallet s -> WalletMetadata -> [(Tx, TxMeta)] -> GenesisParameters -> ExceptT ErrWalletAlreadyExists stm ()) -> (WalletId -> ExceptT ErrNoSuchWallet stm ()) -> stm [WalletId] -> DBVar stm (DeltaMap WalletId (DeltaWalletState s)) -> (WalletId -> Wallet s -> ExceptT ErrNoSuchWallet stm ()) -> (WalletId -> stm (Maybe (Wallet s))) -> (WalletId -> stm [ChainPoint]) -> (WalletId -> WalletMetadata -> ExceptT ErrNoSuchWallet stm ()) -> (WalletId -> stm (Maybe WalletMetadata)) -> (WalletId -> ExceptT ErrNoSuchWallet stm Bool) -> (WalletId -> DelegationCertificate -> SlotNo -> ExceptT ErrNoSuchWallet stm ()) -> (WalletId -> Coin -> ExceptT ErrNoSuchWallet stm ()) -> (WalletId -> stm Coin) -> (WalletId -> [(Tx, TxMeta)] -> ExceptT ErrNoSuchWallet stm ()) -> (WalletId -> Maybe Coin -> SortOrder -> Range SlotNo -> Maybe TxStatus -> stm [TransactionInfo]) -> (WalletId -> Hash "Tx" -> ExceptT ErrNoSuchWallet stm (Maybe TransactionInfo)) -> (WalletId -> Hash "Tx" -> SealedTx -> SlotNo -> ExceptT ErrPutLocalTxSubmission stm ()) -> (WalletId -> stm [LocalTxSubmissionStatus SealedTx]) -> (WalletId -> SlotNo -> ExceptT ErrNoSuchWallet stm ()) -> (WalletId -> Hash "Tx" -> ExceptT ErrRemoveTx stm ()) -> (WalletId -> (k 'RootK XPrv, PassphraseHash) -> ExceptT ErrNoSuchWallet stm ()) -> (WalletId -> stm (Maybe (k 'RootK XPrv, PassphraseHash))) -> (WalletId -> stm (Maybe GenesisParameters)) -> (WalletId -> Slot -> ExceptT ErrNoSuchWallet stm ChainPoint) -> (WalletId -> Quantity "block" Word32 -> ExceptT ErrNoSuchWallet stm ()) -> (forall a. stm a -> m a) -> DBLayer m s k

-- | Initialize a database entry for a given wallet. <a>putCheckpoint</a>,
--   <a>putWalletMeta</a>, <a>putTxHistory</a> or
--   <tt>putProtocolParameters</tt> will actually all fail if they are
--   called _first_ on a wallet.
[initializeWallet] :: DBLayer m s k -> WalletId -> Wallet s -> WalletMetadata -> [(Tx, TxMeta)] -> GenesisParameters -> ExceptT ErrWalletAlreadyExists stm ()

-- | Remove a given wallet and all its associated data (checkpoints,
--   metadata, tx history ...)
[removeWallet] :: DBLayer m s k -> WalletId -> ExceptT ErrNoSuchWallet stm ()

-- | Get the list of all known wallets in the DB, possibly empty.
[listWallets] :: DBLayer m s k -> stm [WalletId]

-- | <a>DBVar</a> containing the <tt>WalletState</tt> of each wallet in the
--   database. Currently contains all <tt>Checkpoints</tt> of the
--   <tt>UTxO</tt> and the <tt>Discoveries</tt>, as well as the
--   <tt>Prologue</tt> of the address discovery state.
--   
--   Intended to replace <a>putCheckpoint</a> and <a>readCheckpoint</a> in
--   the short-term, and all other functions in the long-term.
[walletsDB] :: DBLayer m s k -> DBVar stm (DeltaMap WalletId (DeltaWalletState s))

-- | Replace the current checkpoint for a given wallet. We do not handle
--   rollbacks yet, and therefore only stores the latest available
--   checkpoint.
--   
--   If the wallet doesn't exist, this operation returns an error.
[putCheckpoint] :: DBLayer m s k -> WalletId -> Wallet s -> ExceptT ErrNoSuchWallet stm ()

-- | Fetch the most recent checkpoint of a given wallet.
--   
--   Return <a>Nothing</a> if there's no such wallet.
[readCheckpoint] :: DBLayer m s k -> WalletId -> stm (Maybe (Wallet s))

-- | List all known checkpoint tips, ordered by slot ids from the oldest to
--   the newest.
[listCheckpoints] :: DBLayer m s k -> WalletId -> stm [ChainPoint]

-- | Replace an existing wallet metadata with the given one.
--   
--   If the wallet doesn't exist, this operation returns an error
[putWalletMeta] :: DBLayer m s k -> WalletId -> WalletMetadata -> ExceptT ErrNoSuchWallet stm ()

-- | Fetch a wallet metadata, if they exist.
--   
--   Return <a>Nothing</a> if there's no such wallet.
[readWalletMeta] :: DBLayer m s k -> WalletId -> stm (Maybe WalletMetadata)
[isStakeKeyRegistered] :: DBLayer m s k -> WalletId -> ExceptT ErrNoSuchWallet stm Bool

-- | Binds a stake pool id to a wallet. This will have an influence on the
--   wallet metadata: the last known certificate will indicate to which
--   pool a wallet is currently delegating.
--   
--   This is done separately from <a>putWalletMeta</a> because certificate
--   declarations are:
--   
--   <ol>
--   <li>Stored on-chain.</li>
--   <li>Affected by rollbacks (or said differently, tied to a
--   <a>SlotNo</a>).</li>
--   </ol>
[putDelegationCertificate] :: DBLayer m s k -> WalletId -> DelegationCertificate -> SlotNo -> ExceptT ErrNoSuchWallet stm ()

-- | Store the latest known reward account balance.
--   
--   This is separate from checkpoints because the data corresponds to the
--   node tip. This is separate from putWalletMeta because it's not meta
--   data
[putDelegationRewardBalance] :: DBLayer m s k -> WalletId -> Coin -> ExceptT ErrNoSuchWallet stm ()

-- | Get the reward account balance.
--   
--   Returns zero if the wallet isn't found or if wallet hasn't delegated
--   stake.
[readDelegationRewardBalance] :: DBLayer m s k -> WalletId -> stm Coin

-- | Augments the transaction history for a known wallet.
--   
--   If an entry for a particular transaction already exists it is not
--   altered nor merged (just ignored).
--   
--   If the wallet doesn't exist, this operation returns an error.
[putTxHistory] :: DBLayer m s k -> WalletId -> [(Tx, TxMeta)] -> ExceptT ErrNoSuchWallet stm ()

-- | Fetch the current transaction history of a known wallet, ordered by
--   descending slot number.
--   
--   Returns an empty list if the wallet isn't found.
[readTxHistory] :: DBLayer m s k -> WalletId -> Maybe Coin -> SortOrder -> Range SlotNo -> Maybe TxStatus -> stm [TransactionInfo]

-- | Fetch the latest transaction by id, returns Nothing when the
--   transaction isn't found.
--   
--   If the wallet doesn't exist, this operation returns an error.
[getTx] :: DBLayer m s k -> WalletId -> Hash "Tx" -> ExceptT ErrNoSuchWallet stm (Maybe TransactionInfo)

-- | Add or update a transaction in the local submission pool with the most
--   recent submission slot.
[putLocalTxSubmission] :: DBLayer m s k -> WalletId -> Hash "Tx" -> SealedTx -> SlotNo -> ExceptT ErrPutLocalTxSubmission stm ()

-- | List all transactions from the local submission pool which are still
--   pending as of the latest checkpoint of the given wallet. The slot
--   numbers for first submission and most recent submission are included.
[readLocalTxSubmissionPending] :: DBLayer m s k -> WalletId -> stm [LocalTxSubmissionStatus SealedTx]

-- | Removes any expired transactions from the pending set and marks their
--   status as expired.
[updatePendingTxForExpiry] :: DBLayer m s k -> WalletId -> SlotNo -> ExceptT ErrNoSuchWallet stm ()

-- | Manually remove a pending transaction.
[removePendingOrExpiredTx] :: DBLayer m s k -> WalletId -> Hash "Tx" -> ExceptT ErrRemoveTx stm ()

-- | Store or replace a private key for a given wallet. Note that wallet
--   _could_ be stored and manipulated without any private key associated
--   to it. A private key is only seldomly required for very specific
--   operations (like transaction signing).
[putPrivateKey] :: DBLayer m s k -> WalletId -> (k 'RootK XPrv, PassphraseHash) -> ExceptT ErrNoSuchWallet stm ()

-- | Read a previously stored private key and its associated passphrase
--   hash.
[readPrivateKey] :: DBLayer m s k -> WalletId -> stm (Maybe (k 'RootK XPrv, PassphraseHash))

-- | Read the *Byron* genesis parameters.
[readGenesisParameters] :: DBLayer m s k -> WalletId -> stm (Maybe GenesisParameters)

-- | Drops all checkpoints and transaction data which have appeared after
--   the given <a>ChainPoint</a>.
--   
--   Returns the actual <a>ChainPoint</a> to which the database has rolled
--   back. Its slot is guaranteed to be earlier than (or identical to) the
--   given point of rollback but can't be guaranteed to be exactly the same
--   because the database may only keep sparse checkpoints.
[rollbackTo] :: DBLayer m s k -> WalletId -> Slot -> ExceptT ErrNoSuchWallet stm ChainPoint

-- | Prune database entities and remove entities that can be discarded.
--   
--   The second argument represents the stability window, or said length of
--   the deepest rollback.
[prune] :: DBLayer m s k -> WalletId -> Quantity "block" Word32 -> ExceptT ErrNoSuchWallet stm ()

-- | Execute operations of the database in isolation and atomically.
[atomically] :: DBLayer m s k -> forall a. stm a -> m a

-- | Instantiate database layers at will
data DBFactory m s k
DBFactory :: (forall a. WalletId -> (DBLayer m s k -> IO a) -> IO a) -> (WalletId -> IO ()) -> IO [WalletId] -> DBFactory m s k

-- | Creates a new or use an existing database, maintaining an open
--   connection so long as necessary
[withDatabase] :: DBFactory m s k -> forall a. WalletId -> (DBLayer m s k -> IO a) -> IO a

-- | Erase any trace of the database
[removeDatabase] :: DBFactory m s k -> WalletId -> IO ()

-- | List existing wallet database found on disk.
[listDatabases] :: DBFactory m s k -> IO [WalletId]

-- | Clean a database by removing all wallets.
cleanDB :: DBLayer m s k -> m ()

-- | Can't read the database file because it's in a bad format (corrupted,
--   too old, â€¦)
data ErrBadFormat
ErrBadFormatAddressPrologue :: ErrBadFormat
ErrBadFormatCheckpoints :: ErrBadFormat

-- | Forbidden operation was executed on an already existing wallet
newtype ErrWalletAlreadyExists
ErrWalletAlreadyExists :: WalletId -> ErrWalletAlreadyExists

-- | Indicates that the specified transaction hash is not found in the
--   transaction history of the given wallet.
data ErrNoSuchTransaction
ErrNoSuchTransaction :: WalletId -> Hash "Tx" -> ErrNoSuchTransaction

-- | Can't remove pending or expired transaction.
data ErrRemoveTx
ErrRemoveTxNoSuchWallet :: ErrNoSuchWallet -> ErrRemoveTx
ErrRemoveTxNoSuchTransaction :: ErrNoSuchTransaction -> ErrRemoveTx
ErrRemoveTxAlreadyInLedger :: Hash "Tx" -> ErrRemoveTx

-- | Can't add a transaction to the local tx submission pool.
data ErrPutLocalTxSubmission
ErrPutLocalTxSubmissionNoSuchWallet :: ErrNoSuchWallet -> ErrPutLocalTxSubmission
ErrPutLocalTxSubmissionNoSuchTransaction :: ErrNoSuchTransaction -> ErrPutLocalTxSubmission
instance GHC.Show.Show Cardano.Wallet.DB.ErrBadFormat
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrBadFormat
instance GHC.Show.Show Cardano.Wallet.DB.ErrNoSuchTransaction
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrNoSuchTransaction
instance GHC.Show.Show Cardano.Wallet.DB.ErrRemoveTx
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrRemoveTx
instance GHC.Show.Show Cardano.Wallet.DB.ErrPutLocalTxSubmission
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrPutLocalTxSubmission
instance GHC.Show.Show Cardano.Wallet.DB.ErrWalletAlreadyExists
instance GHC.Classes.Eq Cardano.Wallet.DB.ErrWalletAlreadyExists
instance GHC.Exception.Type.Exception Cardano.Wallet.DB.ErrBadFormat


-- | Dummy implementation of the database-layer, using <a>MVar</a>. This
--   may be good for testing to compare with an implementation on a real
--   data store, or to use when compiling the wallet for targets which
--   don't have SQLite.
module Cardano.Wallet.DB.Pure.Layer

-- | Instantiate a new in-memory "database" layer that simply stores data
--   in a local MVar. Data vanishes if the software is shut down.
newDBLayer :: forall m s k. (MonadUnliftIO m, MonadFail m) => TimeInterpreter Identity -> m (DBLayer m s k)
instance GHC.Show.Show Cardano.Wallet.DB.Pure.Layer.MVarDBError
instance GHC.Exception.Type.Exception Cardano.Wallet.DB.Pure.Layer.MVarDBError


-- | Provides wallet layer functions that are used by API layer. Uses both
--   <a>Cardano.Wallet.DB</a> and <a>Cardano.Wallet.Network</a> to realize
--   its role as being intermediary between the three.
--   
--   Functions of the wallet layer are often parameterized with variables
--   following the convention below:
--   
--   <ul>
--   <li><tt>s</tt>: A <b>s</b>tate used to keep track of known addresses.
--   Typically, possible values for this parameter are described in
--   <a>AddressDiscovery</a> sub-modules. For instance <tt>SeqState</tt> or
--   <tt>Rnd State</tt>.</li>
--   <li><tt>k</tt>: A <b>k</b>ey derivation scheme intrinsically connected
--   to the underlying discovery state <tt>s</tt>. This describes how the
--   hierarchical structure of a wallet is defined as well as the
--   relationship between secret keys and public addresses.</li>
--   </ul>
module Cardano.Wallet
data WalletLayer m s (k :: Depth -> Type -> Type)
WalletLayer :: Tracer m WalletWorkerLog -> (Block, NetworkParameters) -> NetworkLayer m Block -> TransactionLayer k SealedTx -> DBLayer m s k -> WalletLayer m s (k :: Depth -> Type -> Type)
type HasDBLayer m s k = HasType (DBLayer m s k)
dbLayer :: forall m s k ctx. HasDBLayer m s k ctx => Lens' ctx (DBLayer m s k)
type HasLogger m msg = HasType (Tracer m msg)
logger :: forall m msg ctx. HasLogger m msg ctx => Lens' ctx (Tracer m msg)

-- | This module is only interested in one block-, and tx-type. This
--   constraint hides that choice, for some ease of use.
type HasNetworkLayer m = HasType (NetworkLayer m Block)
networkLayer :: forall m ctx. HasNetworkLayer m ctx => Lens' ctx (NetworkLayer m Block)
type HasTransactionLayer k = HasType (TransactionLayer k SealedTx)
transactionLayer :: forall k ctx. HasTransactionLayer k ctx => Lens' ctx (TransactionLayer k SealedTx)
type HasGenesisData = HasType (Block, NetworkParameters)
genesisData :: forall ctx. HasGenesisData ctx => Lens' ctx (Block, NetworkParameters)

-- | Initialise and store a new wallet, returning its ID.
createWallet :: forall ctx m s k. (MonadUnliftIO m, MonadTime m, HasGenesisData ctx, HasDBLayer m s k ctx, IsOurs s Address, IsOurs s RewardAccount) => ctx -> WalletId -> WalletName -> s -> ExceptT ErrWalletAlreadyExists m WalletId

-- | Initialise and store a new legacy Icarus wallet. These wallets are
--   intrinsically sequential, but, in the incentivized testnet, we only
--   have access to the a snapshot of the MainNet.
--   
--   To work-around this, we scan the genesis block with an arbitrary big
--   gap and resort to a default gap afterwards.
createIcarusWallet :: forall ctx s k n. (HasGenesisData ctx, HasDBLayer IO s k ctx, PaymentAddress n k, k ~ IcarusKey, s ~ SeqState n k, Typeable n) => ctx -> WalletId -> WalletName -> (k 'RootK XPrv, Passphrase "encryption") -> ExceptT ErrWalletAlreadyExists IO WalletId
attachPrivateKeyFromPwd :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> (k 'RootK XPrv, Passphrase "user") -> ExceptT ErrNoSuchWallet IO ()

-- | The hash here is the output of Scrypt function with the following
--   parameters: - logN = 14 - r = 8 - p = 1 - bytesNumber = 64
attachPrivateKeyFromPwdHash :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> (k 'RootK XPrv, PassphraseHash) -> ExceptT ErrNoSuchWallet IO ()
getWalletUtxoSnapshot :: forall ctx s k. (HasDBLayer IO s k ctx, HasNetworkLayer IO ctx, HasTransactionLayer k ctx) => ctx -> WalletId -> ExceptT ErrNoSuchWallet IO [(TokenBundle, Coin)]

-- | List the wallet's UTxO statistics.
listUtxoStatistics :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> ExceptT ErrListUTxOStatistics IO UTxOStatistics

-- | Retrieve the wallet state for the wallet with the given ID.
readWallet :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> ExceptT ErrNoSuchWallet IO (Wallet s, WalletMetadata, Set Tx)

-- | Remove an existing wallet. Note that there's no particular work to be
--   done regarding the restoration worker as it will simply terminate on
--   the next tick when noticing that the corresponding wallet is gone.
deleteWallet :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> ExceptT ErrNoSuchWallet IO ()

-- | Restore a wallet from its current tip.
--   
--   After the wallet has been restored, this action will continue to fetch
--   newly created blocks and apply them, or roll back to a previous point
--   whenever the chain switches.
restoreWallet :: forall ctx s k. (HasNetworkLayer IO ctx, HasDBLayer IO s k ctx, HasLogger IO WalletWorkerLog ctx, IsOurs s Address, IsOurs s RewardAccount, AddressBookIso s, MaybeLight s) => ctx -> WalletId -> ExceptT ErrNoSuchWallet IO ()

-- | Update a wallet's metadata with the given update function.
updateWallet :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> (WalletMetadata -> WalletMetadata) -> ExceptT ErrNoSuchWallet IO ()

-- | Change a wallet's passphrase to the given passphrase.
updateWalletPassphraseWithOldPassphrase :: forall ctx s k. (HasDBLayer IO s k ctx, WalletKey k) => ctx -> WalletId -> (Passphrase "user", Passphrase "user") -> ExceptT ErrUpdatePassphrase IO ()
updateWalletPassphraseWithMnemonic :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> (k 'RootK XPrv, Passphrase "user") -> ExceptT ErrUpdatePassphrase IO ()
walletSyncProgress :: forall ctx s. HasNetworkLayer IO ctx => ctx -> Wallet s -> IO SyncProgress

-- | Fetch the cached reward balance of a given wallet from the database.
fetchRewardBalance :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> IO Coin
manageRewardBalance :: forall ctx s k (n :: NetworkDiscriminant). (HasLogger IO WalletWorkerLog ctx, HasNetworkLayer IO ctx, HasDBLayer IO s k ctx, Typeable s, Typeable n) => Proxy n -> ctx -> WalletId -> IO ()

-- | Rewind the UTxO snapshots, transaction history and other information
--   to a the earliest point in the past that is before or is the point of
--   rollback.
rollbackBlocks :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> Slot -> ExceptT ErrNoSuchWallet IO ChainPoint

-- | Check whether a wallet is in good shape when restarting a worker.
checkWalletIntegrity :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> GenesisParameters -> ExceptT ErrCheckWalletIntegrity IO ()

-- | Read the current withdrawal capacity of a wallet. Note that, this
--   simply returns 0 if:
--   
--   a) There's no reward account for this type of wallet. b) The current
--   reward value is too small to be considered (adding it would cost more
--   than its value).
readNextWithdrawal :: forall ctx k. (HasTransactionLayer k ctx, HasNetworkLayer IO ctx) => ctx -> AnyCardanoEra -> Coin -> IO Coin
readRewardAccount :: forall ctx s k (n :: NetworkDiscriminant) shelley. (HasDBLayer IO s k ctx, shelley ~ SeqState n ShelleyKey, Typeable n, Typeable s) => ctx -> WalletId -> ExceptT ErrReadRewardAccount IO (RewardAccount, XPub, NonEmpty DerivationIndex)
someRewardAccount :: ToRewardAccount k => SomeMnemonic -> (XPrv, RewardAccount, NonEmpty DerivationIndex)
readPolicyPublicKey :: forall ctx s k (n :: NetworkDiscriminant) shelley. (HasDBLayer IO s k ctx, shelley ~ SeqState n ShelleyKey, Typeable n, Typeable s) => ctx -> WalletId -> ExceptT ErrReadPolicyPublicKey IO (XPub, NonEmpty DerivationIndex)
writePolicyPublicKey :: forall ctx s (n :: NetworkDiscriminant). (HasDBLayer IO s ShelleyKey ctx, s ~ SeqState n ShelleyKey) => ctx -> WalletId -> Passphrase "user" -> ExceptT ErrWritePolicyPublicKey IO (ShelleyKey 'PolicyK XPub)

-- | Query the node for the reward balance of a given wallet.
--   
--   Rather than force all callers of <a>readWallet</a> to wait for
--   fetching the account balance (via the <a>NetworkLayer</a>), we expose
--   this function for it.
queryRewardBalance :: forall ctx. HasNetworkLayer IO ctx => ctx -> RewardAccount -> ExceptT ErrFetchRewards IO Coin

-- | Forbidden operation was executed on an already existing wallet
newtype ErrWalletAlreadyExists
ErrWalletAlreadyExists :: WalletId -> ErrWalletAlreadyExists

-- | Can't perform given operation because there's no wallet
newtype ErrNoSuchWallet
ErrNoSuchWallet :: WalletId -> ErrNoSuchWallet

-- | Errors that can occur when listing UTxO statistics.
newtype ErrListUTxOStatistics
ErrListUTxOStatisticsNoSuchWallet :: ErrNoSuchWallet -> ErrListUTxOStatistics

-- | Errors that can occur when trying to change a wallet's passphrase.
data ErrUpdatePassphrase
ErrUpdatePassphraseNoSuchWallet :: ErrNoSuchWallet -> ErrUpdatePassphrase
ErrUpdatePassphraseWithRootKey :: ErrWithRootKey -> ErrUpdatePassphrase

-- | Errors that can occur when fetching the reward balance of a wallet
newtype ErrFetchRewards
ErrFetchRewardsReadRewardAccount :: ErrReadRewardAccount -> ErrFetchRewards
data ErrCheckWalletIntegrity
ErrCheckWalletIntegrityNoSuchWallet :: ErrNoSuchWallet -> ErrCheckWalletIntegrity
ErrCheckIntegrityDifferentGenesis :: Hash "Genesis" -> Hash "Genesis" -> ErrCheckWalletIntegrity

-- | Can't perform given operation because the wallet died.
newtype ErrWalletNotResponding
ErrWalletNotResponding :: WalletId -> ErrWalletNotResponding
data ErrReadRewardAccount
ErrReadRewardAccountNotAShelleyWallet :: ErrReadRewardAccount
ErrReadRewardAccountNoSuchWallet :: ErrNoSuchWallet -> ErrReadRewardAccount
data ErrReadPolicyPublicKey
ErrReadPolicyPublicKeyNotAShelleyWallet :: ErrReadPolicyPublicKey
ErrReadPolicyPublicKeyNoSuchWallet :: ErrNoSuchWallet -> ErrReadPolicyPublicKey
ErrReadPolicyPublicKeyAbsent :: ErrReadPolicyPublicKey
data ErrWritePolicyPublicKey
ErrWritePolicyPublicKeyNoSuchWallet :: ErrNoSuchWallet -> ErrWritePolicyPublicKey
ErrWritePolicyPublicKeyWithRootKey :: ErrWithRootKey -> ErrWritePolicyPublicKey

-- | Errors that can occur when getting policy id.
data ErrGetPolicyId
ErrGetPolicyIdReadPolicyPubliKey :: ErrReadPolicyPublicKey -> ErrGetPolicyId
ErrGetPolicyIdWrongMintingBurningTemplate :: ErrGetPolicyId
updateCosigner :: forall ctx s k n. (s ~ SharedState n k, MkKeyFingerprint k Address, SoftDerivation k, Typeable n, WalletKey k, HasDBLayer IO s k ctx, k ~ SharedKey) => ctx -> WalletId -> k 'AccountK XPub -> Cosigner -> CredentialType -> ExceptT ErrAddCosignerKey IO ()
data ErrAddCosignerKey

-- | The shared wallet doesn't exist?
ErrAddCosignerKeyNoSuchWallet :: ErrNoSuchWallet -> ErrAddCosignerKey

-- | Error adding this co-signer to the shared wallet.
ErrAddCosignerKey :: ErrAddCosigner -> ErrAddCosignerKey
data ErrConstructSharedWallet

-- | The shared wallet' script template doesn't pass validation
ErrConstructSharedWalletWrongScriptTemplate :: ErrScriptTemplate -> ErrConstructSharedWallet

-- | User provided a derivation index outside of the <tt>Hard</tt> domain
ErrConstructSharedWalletInvalidIndex :: ErrInvalidDerivationIndex 'Hardened 'AccountK -> ErrConstructSharedWallet
normalizeSharedAddress :: forall n k. (SupportsDiscovery n k, k ~ SharedKey) => SharedState n k -> Address -> Maybe Address

-- | Construct an unsigned transaction from a given selection for a shared
--   wallet.
constructSharedTransaction :: forall ctx s k (n :: NetworkDiscriminant). (HasTransactionLayer k ctx, HasDBLayer IO s k ctx, HasNetworkLayer IO ctx, k ~ SharedKey, s ~ SharedState n k) => ctx -> WalletId -> AnyCardanoEra -> TransactionCtx -> SelectionOf TxOut -> ExceptT ErrConstructTx IO SealedTx
createRandomAddress :: forall ctx s k n. (HasDBLayer IO s k ctx, PaymentAddress n k, RndStateLike s, k ~ ByronKey, AddressBookIso s) => ctx -> WalletId -> Passphrase "user" -> Maybe (Index 'Hardened 'AddressK) -> ExceptT ErrCreateRandomAddress IO (Address, NonEmpty DerivationIndex)
importRandomAddresses :: forall ctx s k. (HasDBLayer IO s k ctx, RndStateLike s, k ~ ByronKey, AddressBookIso s) => ctx -> WalletId -> [Address] -> ExceptT ErrImportRandomAddress IO ()

-- | List all addresses of a wallet with their metadata. Addresses are
--   ordered from the most-recently-discovered to the oldest known.
listAddresses :: forall ctx s k. (HasDBLayer IO s k ctx, CompareDiscovery s, KnownAddresses s) => ctx -> WalletId -> (s -> Address -> Maybe Address) -> ExceptT ErrNoSuchWallet IO [(Address, AddressState, NonEmpty DerivationIndex)]
normalizeDelegationAddress :: forall s k n. (DelegationAddress n k, s ~ SeqState n k) => s -> Address -> Maybe Address
lookupTxIns :: forall ctx s k. (HasDBLayer IO s k ctx, IsOurs s Address) => ctx -> WalletId -> [TxIn] -> ExceptT ErrDecodeTx IO [(TxIn, Maybe (TxOut, NonEmpty DerivationIndex))]
lookupTxOuts :: forall ctx s k. (HasDBLayer IO s k ctx, IsOurs s Address) => ctx -> WalletId -> [TxOut] -> ExceptT ErrDecodeTx IO [(TxOut, Maybe (NonEmpty DerivationIndex))]
data ErrCreateRandomAddress
ErrIndexAlreadyExists :: Index 'Hardened 'AddressK -> ErrCreateRandomAddress
ErrCreateAddrNoSuchWallet :: ErrNoSuchWallet -> ErrCreateRandomAddress
ErrCreateAddrWithRootKey :: ErrWithRootKey -> ErrCreateRandomAddress
ErrCreateAddressNotAByronWallet :: ErrCreateRandomAddress
data ErrImportRandomAddress
ErrImportAddrNoSuchWallet :: ErrNoSuchWallet -> ErrImportRandomAddress
ErrImportAddr :: ErrImportAddress -> ErrImportRandomAddress
ErrImportAddressNotAByronWallet :: ErrImportRandomAddress
newtype ErrImportAddress
ErrAddrDoesNotBelong :: Address -> ErrImportAddress

-- | Errors that can occur when decoding a transaction.
newtype ErrDecodeTx
ErrDecodeTxNoSuchWallet :: ErrNoSuchWallet -> ErrDecodeTx

-- | Calculate the transaction expiry slot, given a <a>TimeInterpreter</a>,
--   and an optional TTL in seconds.
--   
--   If no TTL is provided, a default of 2 hours is used (note: there is no
--   particular reason why we chose that duration).
getTxExpiry :: TimeInterpreter (ExceptT PastHorizonException IO) -> Maybe NominalDiffTime -> IO SlotNo

-- | Parameters for the <a>selectAssets</a> function.
data SelectAssetsParams s result
SelectAssetsParams :: [TxOut] -> Set Tx -> Maybe StdGenSeed -> TransactionCtx -> Map WalletUTxO TokenBundle -> UTxOSelection WalletUTxO -> Wallet s -> SelectionStrategy -> SelectAssetsParams s result
[$sel:outputs:SelectAssetsParams] :: SelectAssetsParams s result -> [TxOut]
[$sel:pendingTxs:SelectAssetsParams] :: SelectAssetsParams s result -> Set Tx
[$sel:randomSeed:SelectAssetsParams] :: SelectAssetsParams s result -> Maybe StdGenSeed
[$sel:txContext:SelectAssetsParams] :: SelectAssetsParams s result -> TransactionCtx
[$sel:utxoAvailableForCollateral:SelectAssetsParams] :: SelectAssetsParams s result -> Map WalletUTxO TokenBundle
[$sel:utxoAvailableForInputs:SelectAssetsParams] :: SelectAssetsParams s result -> UTxOSelection WalletUTxO
[$sel:wallet:SelectAssetsParams] :: SelectAssetsParams s result -> Wallet s

-- | Specifies which selection strategy to use. See
--   <a>SelectionStrategy</a>.
[$sel:selectionStrategy:SelectAssetsParams] :: SelectAssetsParams s result -> SelectionStrategy

-- | Selects assets from a wallet.
--   
--   This function has the following responsibilities:
--   
--   <ul>
--   <li>selecting inputs from the UTxO set to pay for user-specified
--   outputs;</li>
--   <li>selecting inputs from the UTxO set to pay for collateral;</li>
--   <li>producing change outputs to return excess value to the
--   wallet;</li>
--   <li>balancing a selection to pay for the transaction fee.</li>
--   </ul>
--   
--   When selecting inputs to pay for user-specified outputs, inputs are
--   selected randomly.
--   
--   By default, the seed used for random selection is derived
--   automatically, from the given <a>MonadRandom</a> context.
--   
--   However, if a concrete value is specified for the optional
--   <a>$sel:randomSeed:SelectAssetsParams</a> parameter, then that value
--   will be used instead as the seed for random selection.
selectAssets :: forall ctx m s k result. (BoundedAddressLength k, HasTransactionLayer k ctx, HasLogger m WalletWorkerLog ctx, MonadRandom m) => ctx -> AnyCardanoEra -> ProtocolParameters -> SelectAssetsParams s result -> (s -> Selection -> result) -> ExceptT ErrSelectAssets m result

-- | Read a wallet checkpoint and index its UTxO, for <a>selectAssets</a>
--   and <tt>selectAssetsNoOutputs</tt>.
readWalletUTxOIndex :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> ExceptT ErrNoSuchWallet IO (UTxOIndex WalletUTxO, Wallet s, Set Tx)

-- | Augments the given outputs with new outputs. These new outputs
--   correspond to change outputs to which new addresses have been
--   assigned. This updates the wallet state as it needs to keep track of
--   new pending change addresses.
assignChangeAddresses :: forall s. GenChange s => ArgGenChange s -> Selection -> s -> (SelectionOf TxOut, s)
assignChangeAddressesAndUpdateDb :: forall ctx s k. (GenChange s, HasDBLayer IO s k ctx, AddressBookIso s) => ctx -> WalletId -> ArgGenChange s -> Selection -> ExceptT ErrSignPayment IO (SelectionOf TxOut)
assignChangeAddressesWithoutDbUpdate :: forall ctx s k. (GenChange s, HasDBLayer IO s k ctx) => ctx -> WalletId -> ArgGenChange s -> Selection -> ExceptT ErrConstructTx IO (SelectionOf TxOut)
selectionToUnsignedTx :: forall s input output change withdrawal. (IsOurs s Address, input ~ (TxIn, TxOut, NonEmpty DerivationIndex), output ~ TxOut, change ~ TxChange (NonEmpty DerivationIndex), withdrawal ~ (RewardAccount, Coin, NonEmpty DerivationIndex)) => Withdrawal -> SelectionOf TxOut -> s -> UnsignedTx input output change withdrawal

-- | Produce witnesses and construct a transaction from a given selection.
--   
--   Requires the encryption passphrase in order to decrypt the root
--   private key. Note that this doesn't broadcast the transaction to the
--   network. In order to do so, use <a>submitTx</a>.
buildAndSignTransaction :: forall ctx s k. (HasTransactionLayer k ctx, HasDBLayer IO s k ctx, HasNetworkLayer IO ctx, IsOwned s k) => ctx -> WalletId -> AnyCardanoEra -> ((k 'RootK XPrv, Passphrase "encryption") -> (XPrv, Passphrase "encryption")) -> Passphrase "user" -> TransactionCtx -> SelectionOf TxOut -> ExceptT ErrSignPayment IO (Tx, TxMeta, UTCTime, SealedTx)
signTransaction :: forall k. (WalletKey k, HardDerivation k, Bounded (Index (AddressIndexDerivationType k) 'AddressK)) => TransactionLayer k SealedTx -> AnyCardanoEra -> (Address -> Maybe (k 'AddressK XPrv, Passphrase "encryption")) -> (k 'RootK XPrv, Passphrase "encryption") -> UTxO -> SealedTx -> SealedTx

-- | Construct an unsigned transaction from a given selection.
constructTransaction :: forall ctx s k (n :: NetworkDiscriminant). (HasTransactionLayer k ctx, HasDBLayer IO s k ctx, HasNetworkLayer IO ctx, Typeable s, Typeable n) => ctx -> WalletId -> AnyCardanoEra -> TransactionCtx -> SelectionOf TxOut -> ExceptT ErrConstructTx IO SealedTx
constructTxMeta :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> TransactionCtx -> [(TxIn, Coin)] -> [TxOut] -> ExceptT ErrSubmitTransaction IO TxMeta
data ErrSelectAssets
ErrSelectAssetsPrepareOutputsError :: SelectionOutputError WalletSelectionContext -> ErrSelectAssets
ErrSelectAssetsNoSuchWallet :: ErrNoSuchWallet -> ErrSelectAssets
ErrSelectAssetsAlreadyWithdrawing :: Tx -> ErrSelectAssets
ErrSelectAssetsSelectionError :: SelectionError WalletSelectionContext -> ErrSelectAssets

-- | Errors that can occur when signing a transaction.
data ErrSignPayment
ErrSignPaymentMkTx :: ErrMkTransaction -> ErrSignPayment
ErrSignPaymentNoSuchWallet :: ErrNoSuchWallet -> ErrSignPayment
ErrSignPaymentWithRootKey :: ErrWithRootKey -> ErrSignPayment
ErrSignPaymentIncorrectTTL :: PastHorizonException -> ErrSignPayment
data ErrNotASequentialWallet
ErrNotASequentialWallet :: ErrNotASequentialWallet
data ErrWithdrawalNotWorth
ErrWithdrawalNotWorth :: ErrWithdrawalNotWorth

-- | Errors that can occur when constructing an unsigned transaction.
data ErrConstructTx
ErrConstructTxWrongPayload :: ErrConstructTx
ErrConstructTxBody :: ErrMkTransaction -> ErrConstructTx
ErrConstructTxNoSuchWallet :: ErrNoSuchWallet -> ErrConstructTx
ErrConstructTxReadRewardAccount :: ErrReadRewardAccount -> ErrConstructTx
ErrConstructTxIncorrectTTL :: PastHorizonException -> ErrConstructTx
ErrConstructTxMultidelegationNotSupported :: ErrConstructTx
ErrConstructTxMultiaccountNotSupported :: ErrConstructTx
ErrConstructTxWrongMintingBurningTemplate :: ErrConstructTx
ErrConstructTxAssetNameTooLong :: ErrConstructTx
ErrConstructTxMintOrBurnAssetQuantityOutOfBounds :: ErrConstructTx
ErrConstructTxWrongValidityBounds :: ErrConstructTx
ErrConstructTxValidityIntervalNotWithinScriptTimelock :: ErrConstructTx
ErrConstructTxSharedWalletPending :: ErrConstructTx

-- | Temporary error constructor.
ErrConstructTxNotImplemented :: String -> ErrConstructTx
newtype ErrMintBurnAssets

-- | Temporary error constructor.
ErrMintBurnNotImplemented :: Text -> ErrMintBurnAssets

-- | Errors that can occur when balancing transaction.
data ErrBalanceTx
ErrBalanceTxUpdateError :: ErrUpdateSealedTx -> ErrBalanceTx
ErrBalanceTxSelectAssets :: ErrSelectAssets -> ErrBalanceTx
ErrBalanceTxMaxSizeLimitExceeded :: ErrBalanceTx
ErrBalanceTxExistingCollateral :: ErrBalanceTx
ErrBalanceTxExistingTotalCollateral :: ErrBalanceTx
ErrBalanceTxExistingReturnCollateral :: ErrBalanceTx
ErrBalanceTxConflictingNetworks :: ErrBalanceTx
ErrBalanceTxAssignRedeemers :: ErrAssignRedeemers -> ErrBalanceTx
ErrBalanceTxInternalError :: ErrBalanceTxInternalError -> ErrBalanceTx
ErrBalanceTxZeroAdaOutput :: ErrBalanceTx
ErrByronTxNotSupported :: ErrBalanceTx
data ErrBalanceTxInternalError
ErrUnderestimatedFee :: Coin -> SealedTx -> ErrBalanceTxInternalError
ErrFailedBalancing :: Value -> ErrBalanceTxInternalError
newtype ErrUpdateSealedTx

-- | The <tt>SealedTx</tt> couldn't not be updated because the *n* existing
--   key-witnesses would have been rendered invalid.
ErrExistingKeyWitnesses :: Int -> ErrUpdateSealedTx
data ErrCannotJoin
ErrAlreadyDelegating :: PoolId -> ErrCannotJoin
ErrNoSuchPool :: PoolId -> ErrCannotJoin
data ErrCannotQuit
ErrNotDelegatingOrAboutTo :: ErrCannotQuit
ErrNonNullRewards :: Coin -> ErrCannotQuit

-- | Errors that can occur when submitting a transaction.
data ErrSubmitTransaction
ErrSubmitTransactionNoSuchWallet :: ErrNoSuchWallet -> ErrSubmitTransaction
ErrSubmitTransactionForeignWallet :: ErrSubmitTransaction
ErrSubmitTransactionPartiallySignedOrNoSignedTx :: Int -> Int -> ErrSubmitTransaction
ErrSubmitTransactionMultidelegationNotSupported :: ErrSubmitTransaction
createMigrationPlan :: forall ctx k s. (HasDBLayer IO s k ctx, HasNetworkLayer IO ctx, HasTransactionLayer k ctx) => ctx -> AnyCardanoEra -> WalletId -> Withdrawal -> ExceptT ErrCreateMigrationPlan IO MigrationPlan
migrationPlanToSelectionWithdrawals :: MigrationPlan -> Withdrawal -> NonEmpty Address -> Maybe (NonEmpty (SelectionWithoutChange, Withdrawal))
type SelectionWithoutChange = SelectionOf Void
data ErrCreateMigrationPlan
ErrCreateMigrationPlanEmpty :: ErrCreateMigrationPlan
ErrCreateMigrationPlanNoSuchWallet :: ErrNoSuchWallet -> ErrCreateMigrationPlan
data PoolRetirementEpochInfo
PoolRetirementEpochInfo :: EpochNo -> EpochNo -> PoolRetirementEpochInfo

-- | The current epoch.
[$sel:currentEpoch:PoolRetirementEpochInfo] :: PoolRetirementEpochInfo -> EpochNo

-- | The retirement epoch of a pool.
[$sel:retirementEpoch:PoolRetirementEpochInfo] :: PoolRetirementEpochInfo -> EpochNo
joinStakePool :: forall ctx s k. (HasDBLayer IO s k ctx, HasNetworkLayer IO ctx, HasLogger IO WalletWorkerLog ctx) => ctx -> EpochNo -> Set PoolId -> PoolId -> PoolLifeCycleStatus -> WalletId -> ExceptT ErrStakePoolDelegation IO (DelegationAction, Maybe Coin)

-- | Helper function to factor necessary logic for quitting a stake pool.
quitStakePool :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> Withdrawal -> ExceptT ErrStakePoolDelegation IO DelegationAction
guardJoin :: Set PoolId -> WalletDelegation -> PoolId -> Maybe PoolRetirementEpochInfo -> Either ErrCannotJoin ()
guardQuit :: WalletDelegation -> Withdrawal -> Coin -> Either ErrCannotQuit ()
data ErrStakePoolDelegation
ErrStakePoolDelegationNoSuchWallet :: ErrNoSuchWallet -> ErrStakePoolDelegation
ErrStakePoolJoin :: ErrCannotJoin -> ErrStakePoolDelegation
ErrStakePoolQuit :: ErrCannotQuit -> ErrStakePoolDelegation

-- | Result of a fee estimation process given a wallet and payment order.
data FeeEstimation
FeeEstimation :: Word64 -> Word64 -> FeeEstimation

-- | Most coin selections will result in a fee higher than this.
[$sel:estMinFee:FeeEstimation] :: FeeEstimation -> Word64

-- | Most coin selections will result in a fee lower than this.
[$sel:estMaxFee:FeeEstimation] :: FeeEstimation -> Word64

-- | Estimate the transaction fee for a given coin selection algorithm by
--   repeatedly running it (100 times) and collecting the results. In the
--   returned <a>FeeEstimation</a>, the minimum fee is that which 90% of
--   the sampled fees are greater than. The maximum fee is the highest fee
--   observed in the samples.
estimateFee :: forall m. Monad m => ExceptT ErrSelectAssets m Coin -> ExceptT ErrSelectAssets m FeeEstimation

-- | Calculate the minimum deposit necessary if a given wallet wanted to
--   delegate to a pool. Said differently, this return either 0, or the
--   value of the key deposit protocol parameters if the wallet has no
--   registered stake key.
calcMinimumDeposit :: forall ctx s k. (HasDBLayer IO s k ctx, HasNetworkLayer IO ctx) => ctx -> WalletId -> ExceptT ErrSelectAssets IO Coin

-- | Calculate the minimum coin values required for a bunch of specified
--   outputs.
calcMinimumCoinValues :: forall ctx k f. (HasTransactionLayer k ctx, HasNetworkLayer IO ctx, Applicative f) => ctx -> AnyCardanoEra -> f TxOut -> IO (f Coin)

-- | Remove a pending or expired transaction from the transaction history.
--   This happens at the request of the user. If the transaction is already
--   on chain, or is missing from the transaction history, an error will be
--   returned.
--   
--   If a <a>Pending</a> transaction is removed, but later appears in a
--   block, it will be added back to the transaction history.
forgetTx :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> Hash "Tx" -> ExceptT ErrRemoveTx IO ()

-- | List all transactions and metadata from history for a given wallet.
listTransactions :: forall ctx s k. (HasDBLayer IO s k ctx, HasNetworkLayer IO ctx) => ctx -> WalletId -> Maybe Coin -> Maybe UTCTime -> Maybe UTCTime -> SortOrder -> ExceptT ErrListTransactions IO [TransactionInfo]

-- | Extract assets associated with a given wallet from its transaction
--   history.
listAssets :: forall s k ctx. (HasDBLayer IO s k ctx, IsOurs s Address) => ctx -> WalletId -> ExceptT ErrNoSuchWallet IO (Set AssetId)

-- | Get transaction and metadata from history for a given wallet.
getTransaction :: forall ctx s k. HasDBLayer IO s k ctx => ctx -> WalletId -> Hash "Tx" -> ExceptT ErrGetTransaction IO TransactionInfo

-- | Broadcast an externally-signed transaction to the network.
--   
--   NOTE: external transactions will not be added to the LocalTxSubmission
--   pool, so the user must retry submission themselves.
submitExternalTx :: forall ctx k. (HasNetworkLayer IO ctx, HasTransactionLayer k ctx, HasLogger IO TxSubmitLog ctx) => ctx -> SealedTx -> ExceptT ErrPostTx IO Tx

-- | Broadcast a (signed) transaction to the network.
submitTx :: forall ctx s k. (HasNetworkLayer IO ctx, HasDBLayer IO s k ctx, HasLogger IO WalletWorkerLog ctx) => ctx -> WalletId -> (Tx, TxMeta, SealedTx) -> ExceptT ErrSubmitTx IO ()
balanceTransaction :: forall era m s k ctx. (HasTransactionLayer k ctx, GenChange s, MonadRandom m, HasLogger m WalletWorkerLog ctx, IsShelleyBasedEra era, BoundedAddressLength k) => ctx -> ArgGenChange s -> (ProtocolParameters, ProtocolParameters) -> TimeInterpreter (Either PastHorizonException) -> (UTxOIndex WalletUTxO, Wallet s, Set Tx) -> PartialTx era -> ExceptT ErrBalanceTx m (Tx era)

-- | A <a>PartialTx</a> is an an unbalanced <a>SealedTx</a> along with the
--   necessary information to balance it.
--   
--   The <a>$sel:inputs:PartialTx</a> and <a>$sel:redeemers:PartialTx</a>
--   must match the binary transaction contained in the <tt>sealedTx</tt>.
data PartialTx era
PartialTx :: Tx era -> [(TxIn, TxOut, Maybe (Hash "Datum"))] -> [Redeemer] -> PartialTx era
[$sel:tx:PartialTx] :: PartialTx era -> Tx era
[$sel:inputs:PartialTx] :: PartialTx era -> [(TxIn, TxOut, Maybe (Hash "Datum"))]
[$sel:redeemers:PartialTx] :: PartialTx era -> [Redeemer]

-- | Parameters for <a>runLocalTxSubmissionPool</a>
data LocalTxSubmissionConfig
LocalTxSubmissionConfig :: DiffTime -> Word64 -> LocalTxSubmissionConfig

-- | Minimum time between checks of pending transactions
[$sel:rateLimit:LocalTxSubmissionConfig] :: LocalTxSubmissionConfig -> DiffTime

-- | Resubmission interval, in terms of expected blocks.
[$sel:blockInterval:LocalTxSubmissionConfig] :: LocalTxSubmissionConfig -> Word64

-- | The current default is to resubmit any pending transaction about once
--   every 10 blocks.
--   
--   The default rate limit for checking the pending list is 1000ms.
defaultLocalTxSubmissionConfig :: LocalTxSubmissionConfig

-- | Continuous process which monitors the chain tip and retries submission
--   of pending transactions as the chain lengthens.
--   
--   Regardless of the frequency of chain updates, this function won't
--   re-query the database faster than the configured
--   <a>$sel:rateLimit:LocalTxSubmissionConfig</a>.
--   
--   This only exits if the network layer <a>watchNodeTip</a> function
--   exits.
runLocalTxSubmissionPool :: forall ctx s k m. (MonadUnliftIO m, MonadMonotonicTime m, HasLogger IO WalletWorkerLog ctx, HasNetworkLayer m ctx, HasDBLayer m s k ctx) => LocalTxSubmissionConfig -> ctx -> WalletId -> m ()
data ErrMkTransaction
ErrMkTransactionNoSuchWallet :: WalletId -> ErrMkTransaction

-- | We failed to construct a transaction for some reasons.
ErrMkTransactionTxBodyError :: Text -> ErrMkTransaction

-- | Should never happen, means that that we have programmatically provided
--   an invalid era.
ErrMkTransactionInvalidEra :: AnyCardanoEra -> ErrMkTransaction
ErrMkTransactionJoinStakePool :: ErrCannotJoin -> ErrMkTransaction
ErrMkTransactionQuitStakePool :: ErrCannotQuit -> ErrMkTransaction
ErrMkTransactionIncorrectTTL :: PastHorizonException -> ErrMkTransaction

-- | Errors that can occur when submitting a signed transaction to the
--   network.
data ErrSubmitTx
ErrSubmitTxNetwork :: ErrPostTx -> ErrSubmitTx
ErrSubmitTxNoSuchWallet :: ErrNoSuchWallet -> ErrSubmitTx
ErrSubmitTxImpossible :: ErrNoSuchTransaction -> ErrSubmitTx

-- | Can't remove pending or expired transaction.
data ErrRemoveTx
ErrRemoveTxNoSuchWallet :: ErrNoSuchWallet -> ErrRemoveTx
ErrRemoveTxNoSuchTransaction :: ErrNoSuchTransaction -> ErrRemoveTx
ErrRemoveTxAlreadyInLedger :: Hash "Tx" -> ErrRemoveTx

-- | Error while trying to send a transaction
newtype ErrPostTx
ErrPostTxValidationError :: Text -> ErrPostTx

-- | Errors that can occur when trying to list transactions.
data ErrListTransactions
ErrListTransactionsNoSuchWallet :: ErrNoSuchWallet -> ErrListTransactions
ErrListTransactionsStartTimeLaterThanEndTime :: ErrStartTimeLaterThanEndTime -> ErrListTransactions
ErrListTransactionsMinWithdrawalWrong :: ErrListTransactions
ErrListTransactionsPastHorizonException :: PastHorizonException -> ErrListTransactions

-- | Errors that can occur when trying to get transaction.
data ErrGetTransaction
ErrGetTransactionNoSuchWallet :: ErrNoSuchWallet -> ErrGetTransaction
ErrGetTransactionNoSuchTransaction :: ErrNoSuchTransaction -> ErrGetTransaction

-- | Indicates that the specified transaction hash is not found in the
--   transaction history of the given wallet.
data ErrNoSuchTransaction
ErrNoSuchTransaction :: WalletId -> Hash "Tx" -> ErrNoSuchTransaction

-- | Indicates that the specified start time is later than the specified
--   end time.
data ErrStartTimeLaterThanEndTime
ErrStartTimeLaterThanEndTime :: UTCTime -> UTCTime -> ErrStartTimeLaterThanEndTime
[$sel:errStartTime:ErrStartTimeLaterThanEndTime] :: ErrStartTimeLaterThanEndTime -> UTCTime
[$sel:errEndTime:ErrStartTimeLaterThanEndTime] :: ErrStartTimeLaterThanEndTime -> UTCTime

-- | Errors that can occur when signing a transaction.
data ErrWitnessTx
ErrWitnessTxSignTx :: ErrSignTx -> ErrWitnessTx
ErrWitnessTxNoSuchWallet :: ErrNoSuchWallet -> ErrWitnessTx
ErrWitnessTxWithRootKey :: ErrWithRootKey -> ErrWitnessTx
ErrWitnessTxIncorrectTTL :: PastHorizonException -> ErrWitnessTx

-- | Execute an action which requires holding a root XPrv.
--   
--   <a>withRootKey</a> takes a callback function with two arguments:
--   
--   <ul>
--   <li>The encrypted root private key itself</li>
--   <li>The underlying passphrase scheme (legacy or new)</li>
--   </ul>
--   
--   Caller are then expected to use <a>preparePassphrase</a> with the
--   given scheme in order to "prepare" the passphrase to be used by other
--   function. This does nothing for the new encryption, but for the legacy
--   encryption with Scrypt, passphrases needed to first be CBOR serialized
--   and blake2b_256 hashed.
--   
--   @@<tt> withRootKey </tt>ctx <tt>s </tt>k ctx wid pwd OnError $ xprv
--   scheme -&gt; changePassphrase (preparePassphrase scheme pwd) newPwd
--   xprv @@@
withRootKey :: forall ctx s k e a. HasDBLayer IO s k ctx => ctx -> WalletId -> Passphrase "user" -> (ErrWithRootKey -> e) -> (k 'RootK XPrv -> PassphraseScheme -> ExceptT e IO a) -> ExceptT e IO a
derivePublicKey :: forall ctx s k. (HasDBLayer IO s k ctx, SoftDerivation k, GetAccount s k) => ctx -> WalletId -> Role -> DerivationIndex -> ExceptT ErrDerivePublicKey IO (k 'AddressK XPub)

-- | Retrieve any public account key of a wallet.
getAccountPublicKeyAtIndex :: forall ctx s k. (HasDBLayer IO s k ctx, WalletKey k, GetPurpose k) => ctx -> WalletId -> Passphrase "user" -> DerivationIndex -> Maybe DerivationIndex -> ExceptT ErrReadAccountPublicKey IO (k 'AccountK XPub)

-- | Retrieve current public account key of a wallet.
readAccountPublicKey :: forall ctx s k. (HasDBLayer IO s k ctx, GetAccount s k) => ctx -> WalletId -> ExceptT ErrReadAccountPublicKey IO (k 'AccountK XPub)

-- | Sign an arbitrary transaction metadata object with a private key
--   belonging to the wallet's account.
--   
--   This is experimental, and will likely be replaced by a more robust to
--   arbitrary message signing using COSE, or a subset of it.
signMetadataWith :: forall ctx s k n. (HasDBLayer IO s k ctx, HardDerivation k, AddressIndexDerivationType k ~ 'Soft, WalletKey k, s ~ SeqState n k) => ctx -> WalletId -> Passphrase "user" -> (Role, DerivationIndex) -> TxMetadata -> ExceptT ErrSignMetadataWith IO (Signature TxMetadata)

-- | Errors that can occur when trying to perform an operation on a wallet
--   that requires a private key, but where none is attached to the wallet.
data ErrWithRootKey
ErrWithRootKeyNoRootKey :: WalletId -> ErrWithRootKey
ErrWithRootKeyWrongPassphrase :: WalletId -> ErrWrongPassphrase -> ErrWithRootKey
ErrWithRootKeyWrongMnemonic :: WalletId -> ErrWithRootKey

-- | Indicate a failure when checking for a given <a>Passphrase</a> match
data ErrWrongPassphrase
ErrWrongPassphrase :: ErrWrongPassphrase
ErrPassphraseSchemeUnsupported :: PassphraseScheme -> ErrWrongPassphrase
data ErrSignMetadataWith

-- | The wallet exists, but there's no root key attached to it
ErrSignMetadataWithRootKey :: ErrWithRootKey -> ErrSignMetadataWith

-- | The wallet doesn't exist?
ErrSignMetadataWithNoSuchWallet :: ErrNoSuchWallet -> ErrSignMetadataWith

-- | User provided a derivation index outside of the <a>Soft</a> domain
ErrSignMetadataWithInvalidIndex :: ErrInvalidDerivationIndex 'Soft 'AddressK -> ErrSignMetadataWith
data ErrDerivePublicKey

-- | The wallet doesn't exist?
ErrDerivePublicKeyNoSuchWallet :: ErrNoSuchWallet -> ErrDerivePublicKey

-- | User provided a derivation index outside of the <a>Soft</a> domain
ErrDerivePublicKeyInvalidIndex :: ErrInvalidDerivationIndex 'Soft 'AddressK -> ErrDerivePublicKey
data ErrReadAccountPublicKey

-- | The wallet doesn't exist?
ErrReadAccountPublicKeyNoSuchWallet :: ErrNoSuchWallet -> ErrReadAccountPublicKey

-- | User provided a derivation index for account outside of the
--   <tt>Hard</tt> domain
ErrReadAccountPublicKeyInvalidAccountIndex :: ErrInvalidDerivationIndex 'Hardened 'AccountK -> ErrReadAccountPublicKey

-- | User provided a derivation index for purpose outside of the
--   <tt>Hard</tt> domain
ErrReadAccountPublicKeyInvalidPurposeIndex :: ErrInvalidDerivationIndex 'Hardened 'PurposeK -> ErrReadAccountPublicKey

-- | The wallet exists, but there's no root key attached to it
ErrReadAccountPublicKeyRootKey :: ErrWithRootKey -> ErrReadAccountPublicKey
data ErrInvalidDerivationIndex derivation level
ErrIndexOutOfBound :: Index derivation level -> Index derivation level -> DerivationIndex -> ErrInvalidDerivationIndex derivation level

-- | Return a function to run an action at most once every _interval_.
throttle :: (MonadUnliftIO m, MonadMonotonicTime m) => DiffTime -> (Time -> a -> m ()) -> m (a -> m ())
guardHardIndex :: Monad m => DerivationIndex -> ExceptT (ErrInvalidDerivationIndex 'Hardened level) m (Index 'Hardened whatever)
withNoSuchWallet :: Monad m => WalletId -> m (Maybe a) -> ExceptT ErrNoSuchWallet m a

-- | Convert a <a>Value</a> into a positive and negative component. Useful
--   to convert the potentially negative balance of a partial tx into
--   TokenBundles.
posAndNegFromCardanoValue :: Value -> (TokenBundle, TokenBundle)

-- | Log messages for actions running within a wallet worker context.
data WalletWorkerLog
MsgWallet :: WalletLog -> WalletWorkerLog
MsgWalletFollow :: WalletFollowLog -> WalletWorkerLog
MsgChainFollow :: ChainFollowLog -> WalletWorkerLog

-- | Log messages arising from the restore and follow process.
data WalletFollowLog
MsgDiscoveredDelegationCert :: SlotNo -> DelegationCertificate -> WalletFollowLog
MsgCheckpoint :: BlockHeader -> WalletFollowLog
MsgDiscoveredTxs :: [(Tx, TxMeta)] -> WalletFollowLog
MsgDiscoveredTxsContent :: [(Tx, TxMeta)] -> WalletFollowLog

-- | Log messages from API server actions running in a wallet worker
--   context.
data WalletLog
MsgSelectionStart :: Int -> [TxOut] -> WalletLog
MsgSelectionForBalancingStart :: Int -> BuildableInAnyEra PartialTx -> WalletLog
MsgSelectionError :: SelectionError WalletSelectionContext -> WalletLog
MsgSelectionReportSummarized :: SelectionReportSummarized -> WalletLog
MsgSelectionReportDetailed :: SelectionReportDetailed -> WalletLog
MsgMigrationUTxOBefore :: UTxOStatistics -> WalletLog
MsgMigrationUTxOAfter :: UTxOStatistics -> WalletLog
MsgRewardBalanceQuery :: BlockHeader -> WalletLog
MsgRewardBalanceResult :: Either ErrFetchRewards Coin -> WalletLog
MsgRewardBalanceNoSuchWallet :: ErrNoSuchWallet -> WalletLog
MsgRewardBalanceExited :: WalletLog
MsgTxSubmit :: TxSubmitLog -> WalletLog
MsgIsStakeKeyRegistered :: Bool -> WalletLog
data TxSubmitLog
MsgSubmitTx :: Tx -> TxMeta -> SealedTx -> BracketLog' (Either ErrSubmitTx ()) -> TxSubmitLog
MsgSubmitExternalTx :: Hash "Tx" -> BracketLog' (Either ErrPostTx Tx) -> TxSubmitLog
MsgRetryPostTx :: Hash "Tx" -> BracketLog' (Either ErrPostTx ()) -> TxSubmitLog
MsgProcessPendingPool :: BracketLog -> TxSubmitLog
instance GHC.Show.Show Cardano.Wallet.UncheckErrNoSuchWallet
instance GHC.Classes.Eq Cardano.Wallet.UncheckErrNoSuchWallet
instance GHC.Classes.Eq (Cardano.Wallet.PartialTx era)
instance GHC.Generics.Generic (Cardano.Wallet.PartialTx era)
instance GHC.Show.Show (Cardano.Wallet.PartialTx era)
instance GHC.Generics.Generic (Cardano.Wallet.SelectAssetsParams s result)
instance GHC.Classes.Eq Cardano.Wallet.LocalTxSubmissionConfig
instance GHC.Show.Show Cardano.Wallet.LocalTxSubmissionConfig
instance GHC.Generics.Generic Cardano.Wallet.LocalTxSubmissionConfig
instance GHC.Generics.Generic Cardano.Wallet.FeeEstimation
instance GHC.Classes.Eq Cardano.Wallet.FeeEstimation
instance GHC.Show.Show Cardano.Wallet.FeeEstimation
instance GHC.Show.Show Cardano.Wallet.ErrAddCosignerKey
instance GHC.Classes.Eq Cardano.Wallet.ErrAddCosignerKey
instance GHC.Show.Show (Cardano.Wallet.ErrInvalidDerivationIndex derivation level)
instance GHC.Classes.Eq (Cardano.Wallet.ErrInvalidDerivationIndex derivation level)
instance GHC.Show.Show Cardano.Wallet.ErrConstructSharedWallet
instance GHC.Classes.Eq Cardano.Wallet.ErrConstructSharedWallet
instance GHC.Show.Show Cardano.Wallet.ErrDerivePublicKey
instance GHC.Classes.Eq Cardano.Wallet.ErrDerivePublicKey
instance GHC.Classes.Eq Cardano.Wallet.ErrListUTxOStatistics
instance GHC.Show.Show Cardano.Wallet.ErrListUTxOStatistics
instance GHC.Classes.Eq Cardano.Wallet.ErrBalanceTxInternalError
instance GHC.Show.Show Cardano.Wallet.ErrBalanceTxInternalError
instance GHC.Classes.Eq Cardano.Wallet.ErrSubmitTransaction
instance GHC.Show.Show Cardano.Wallet.ErrSubmitTransaction
instance GHC.Classes.Eq Cardano.Wallet.ErrMintBurnAssets
instance GHC.Show.Show Cardano.Wallet.ErrMintBurnAssets
instance GHC.Classes.Eq Cardano.Wallet.ErrDecodeTx
instance GHC.Show.Show Cardano.Wallet.ErrDecodeTx
instance GHC.Classes.Eq Cardano.Wallet.ErrSubmitTx
instance GHC.Show.Show Cardano.Wallet.ErrSubmitTx
instance GHC.Classes.Eq Cardano.Wallet.ErrWithRootKey
instance GHC.Show.Show Cardano.Wallet.ErrWithRootKey
instance GHC.Classes.Eq Cardano.Wallet.ErrUpdatePassphrase
instance GHC.Show.Show Cardano.Wallet.ErrUpdatePassphrase
instance GHC.Classes.Eq Cardano.Wallet.ErrWitnessTx
instance GHC.Show.Show Cardano.Wallet.ErrWitnessTx
instance GHC.Classes.Eq Cardano.Wallet.ErrSignPayment
instance GHC.Show.Show Cardano.Wallet.ErrSignPayment
instance GHC.Show.Show Cardano.Wallet.ErrReadAccountPublicKey
instance GHC.Classes.Eq Cardano.Wallet.ErrReadAccountPublicKey
instance GHC.Show.Show Cardano.Wallet.ErrSignMetadataWith
instance GHC.Classes.Eq Cardano.Wallet.ErrSignMetadataWith
instance GHC.Classes.Eq Cardano.Wallet.ErrGetTransaction
instance GHC.Show.Show Cardano.Wallet.ErrGetTransaction
instance GHC.Classes.Eq Cardano.Wallet.ErrStartTimeLaterThanEndTime
instance GHC.Show.Show Cardano.Wallet.ErrStartTimeLaterThanEndTime
instance GHC.Show.Show Cardano.Wallet.ErrListTransactions
instance GHC.Show.Show Cardano.Wallet.ErrCreateMigrationPlan
instance GHC.Classes.Eq Cardano.Wallet.ErrCreateMigrationPlan
instance GHC.Generics.Generic Cardano.Wallet.ErrCreateMigrationPlan
instance GHC.Show.Show Cardano.Wallet.ErrSelectAssets
instance GHC.Classes.Eq Cardano.Wallet.ErrSelectAssets
instance GHC.Generics.Generic Cardano.Wallet.ErrSelectAssets
instance GHC.Classes.Eq Cardano.Wallet.ErrBalanceTx
instance GHC.Show.Show Cardano.Wallet.ErrBalanceTx
instance GHC.Show.Show Cardano.Wallet.ErrCheckWalletIntegrity
instance GHC.Classes.Eq Cardano.Wallet.ErrCheckWalletIntegrity
instance GHC.Show.Show Cardano.Wallet.ErrWalletNotResponding
instance GHC.Classes.Eq Cardano.Wallet.ErrWalletNotResponding
instance GHC.Show.Show Cardano.Wallet.ErrCreateRandomAddress
instance GHC.Classes.Eq Cardano.Wallet.ErrCreateRandomAddress
instance GHC.Generics.Generic Cardano.Wallet.ErrCreateRandomAddress
instance GHC.Show.Show Cardano.Wallet.ErrImportRandomAddress
instance GHC.Classes.Eq Cardano.Wallet.ErrImportRandomAddress
instance GHC.Generics.Generic Cardano.Wallet.ErrImportRandomAddress
instance GHC.Show.Show Cardano.Wallet.ErrNotASequentialWallet
instance GHC.Classes.Eq Cardano.Wallet.ErrNotASequentialWallet
instance GHC.Generics.Generic Cardano.Wallet.ErrNotASequentialWallet
instance GHC.Show.Show Cardano.Wallet.ErrReadRewardAccount
instance GHC.Classes.Eq Cardano.Wallet.ErrReadRewardAccount
instance GHC.Generics.Generic Cardano.Wallet.ErrReadRewardAccount
instance GHC.Show.Show Cardano.Wallet.ErrFetchRewards
instance GHC.Classes.Eq Cardano.Wallet.ErrFetchRewards
instance GHC.Generics.Generic Cardano.Wallet.ErrFetchRewards
instance GHC.Classes.Eq Cardano.Wallet.ErrConstructTx
instance GHC.Show.Show Cardano.Wallet.ErrConstructTx
instance GHC.Show.Show Cardano.Wallet.ErrWithdrawalNotWorth
instance GHC.Classes.Eq Cardano.Wallet.ErrWithdrawalNotWorth
instance GHC.Generics.Generic Cardano.Wallet.ErrWithdrawalNotWorth
instance GHC.Show.Show Cardano.Wallet.ErrReadPolicyPublicKey
instance GHC.Classes.Eq Cardano.Wallet.ErrReadPolicyPublicKey
instance GHC.Generics.Generic Cardano.Wallet.ErrReadPolicyPublicKey
instance GHC.Classes.Eq Cardano.Wallet.ErrGetPolicyId
instance GHC.Show.Show Cardano.Wallet.ErrGetPolicyId
instance GHC.Show.Show Cardano.Wallet.ErrWritePolicyPublicKey
instance GHC.Classes.Eq Cardano.Wallet.ErrWritePolicyPublicKey
instance GHC.Generics.Generic Cardano.Wallet.ErrWritePolicyPublicKey
instance GHC.Show.Show Cardano.Wallet.PoolRetirementEpochInfo
instance GHC.Generics.Generic Cardano.Wallet.PoolRetirementEpochInfo
instance GHC.Classes.Eq Cardano.Wallet.PoolRetirementEpochInfo
instance GHC.Classes.Eq Cardano.Wallet.WalletFollowLog
instance GHC.Show.Show Cardano.Wallet.WalletFollowLog
instance GHC.Classes.Eq Cardano.Wallet.TxSubmitLog
instance GHC.Show.Show Cardano.Wallet.TxSubmitLog
instance GHC.Classes.Eq Cardano.Wallet.WalletLog
instance GHC.Show.Show Cardano.Wallet.WalletLog
instance GHC.Classes.Eq Cardano.Wallet.WalletWorkerLog
instance GHC.Show.Show Cardano.Wallet.WalletWorkerLog
instance GHC.Generics.Generic (Cardano.Wallet.WalletLayer m s k)
instance Data.Text.Class.ToText Cardano.Wallet.WalletWorkerLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.WalletWorkerLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.WalletWorkerLog
instance Data.Text.Class.ToText Cardano.Wallet.WalletLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.WalletLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.WalletLog
instance Data.Text.Class.ToText Cardano.Wallet.TxSubmitLog
instance Formatting.Buildable.Buildable Cardano.Wallet.TxSubmitLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.TxSubmitLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.TxSubmitLog
instance GHC.Show.Show (Cardano.Wallet.BuildableInAnyEra a)
instance GHC.Classes.Eq (Cardano.Wallet.BuildableInAnyEra a)
instance Formatting.Buildable.Buildable (Cardano.Wallet.BuildableInAnyEra a)
instance Data.Text.Class.ToText Cardano.Wallet.WalletFollowLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.WalletFollowLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.WalletFollowLog
instance GHC.Exception.Type.Exception Cardano.Wallet.ErrCheckWalletIntegrity
instance Control.DeepSeq.NFData Cardano.Wallet.FeeEstimation
instance Formatting.Buildable.Buildable (Cardano.Wallet.PartialTx era)
instance GHC.Exception.Type.Exception Cardano.Wallet.UncheckErrNoSuchWallet

module Cardano.Wallet.Registry

-- | A registry to keep track of worker threads and acquired resources.
data WorkerRegistry key resource

-- | Construct a new empty registry
empty :: Ord key => IO (WorkerRegistry key resource)

-- | Lookup the registry for a given worker
lookup :: (MonadIO m, Ord key) => WorkerRegistry key resource -> key -> m (Maybe (Worker key resource))

-- | Register a new worker for a given key.
--   
--   A worker maintains an acquired resource. It expects a task as an
--   argument and will terminate as soon as its task is over. In practice,
--   we provide a never-ending task that keeps the worker alive forever.
--   
--   Returns <a>Nothing</a> if the worker fails to acquire the necessary
--   resource or terminates unexpectedly before entering its <tt>main</tt>
--   action.
register :: forall resource ctx key msg. (Ord key, key ~ WorkerKey ctx, msg ~ WorkerMsg ctx, HasLogger IO (WorkerLog key msg) ctx, HasWorkerCtx resource ctx) => WorkerRegistry key resource -> ctx -> key -> MkWorker key resource msg ctx -> IO (Maybe (Worker key resource))

-- | Unregister a worker from the registry, terminating the running task.
unregister :: Ord key => WorkerRegistry key resource -> key -> IO ()

-- | A worker which holds and manipulate a particular acquired resource.
--   That resource can be, for example, a handle to a database connection.
data Worker key resource

-- | See <a>register</a>
data MkWorker key resource msg ctx
MkWorker :: (WorkerCtx ctx -> key -> IO ()) -> (WorkerCtx ctx -> key -> IO ()) -> (Tracer IO (WorkerLog key msg) -> Either SomeException () -> IO ()) -> ((resource -> IO ()) -> IO ()) -> MkWorker key resource msg ctx

-- | A task to execute before the main worker's task. When creating a
--   worker, this task is guaranteed to have terminated once
--   <a>register</a> returns.
[workerBefore] :: MkWorker key resource msg ctx -> WorkerCtx ctx -> key -> IO ()

-- | A task for the worker, possibly infinite
[workerMain] :: MkWorker key resource msg ctx -> WorkerCtx ctx -> key -> IO ()

-- | Action to run when the worker exits. It will be run * when the
--   <a>workerMain</a> action exits (successfully or not) * if
--   <a>workerAcquire</a> fails * or if the <a>workerBefore</a> action
--   throws an exception.
[workerAfter] :: MkWorker key resource msg ctx -> Tracer IO (WorkerLog key msg) -> Either SomeException () -> IO ()

-- | A bracket-style factory to acquire a resource
[workerAcquire] :: MkWorker key resource msg ctx -> (resource -> IO ()) -> IO ()
defaultWorkerAfter :: Tracer IO (WorkerLog key msg) -> Either SomeException a -> IO ()
workerThread :: Worker key resource -> ThreadId
workerId :: Worker key resource -> key
workerResource :: Worker key resource -> resource

-- | A class to link an existing context to a worker context.
class HasType resource (WorkerCtx ctx) => HasWorkerCtx resource ctx where {
    type family WorkerCtx ctx :: Type;
    type family WorkerMsg ctx :: Type;
    type family WorkerKey ctx :: Type;
}
hoistResource :: HasWorkerCtx resource ctx => resource -> (WorkerMsg ctx -> WorkerLog (WorkerKey ctx) (WorkerMsg ctx)) -> ctx -> WorkerCtx ctx

-- | Log messages relating to a registry worker thread.
data WorkerLog key msg
MsgThreadAfter :: AfterThreadLog -> WorkerLog key msg
MsgFromWorker :: key -> msg -> WorkerLog key msg

-- | Log messages describing how a worker thread exits.
data AfterThreadLog
MsgThreadFinished :: AfterThreadLog
MsgThreadCancelled :: AfterThreadLog
MsgUnhandledException :: LoggedException SomeException -> AfterThreadLog

-- | Trace an <a>AfterThreadLog</a> message from a caught exception.
traceAfterThread :: Tracer m AfterThreadLog -> Either SomeException a -> m ()
instance GHC.Generics.Generic (Cardano.Wallet.Registry.Worker key resource)
instance GHC.Classes.Eq Cardano.Wallet.Registry.AfterThreadLog
instance GHC.Show.Show Cardano.Wallet.Registry.AfterThreadLog
instance (GHC.Classes.Eq key, GHC.Classes.Eq msg) => GHC.Classes.Eq (Cardano.Wallet.Registry.WorkerLog key msg)
instance (GHC.Show.Show key, GHC.Show.Show msg) => GHC.Show.Show (Cardano.Wallet.Registry.WorkerLog key msg)
instance (Data.Text.Class.ToText key, Data.Text.Class.ToText msg) => Data.Text.Class.ToText (Cardano.Wallet.Registry.WorkerLog key msg)
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation (Cardano.Wallet.Registry.WorkerLog key msg)
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation msg => Cardano.BM.Data.Tracer.HasSeverityAnnotation (Cardano.Wallet.Registry.WorkerLog key msg)
instance Data.Text.Class.ToText Cardano.Wallet.Registry.AfterThreadLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.Registry.AfterThreadLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.Registry.AfterThreadLog


-- | This module provides a maximum likelhood estimator for pool
--   performance.
--   
--   Copy &amp; paste of the original implementation in
--   
--   <pre>
--   cardano-ledger<i>eras</i>shelley<i>impl</i>src<i>Cardano</i>Ledger<i>Shelley</i>PoolRank.hs
--   </pre>
--   
--   The copy was made in order to reduce (transitive) dependencies.
module Cardano.Pool.Rank.Likelihood

-- | Information about block production of a pool in one epoch.
data BlockProduction
BlockProduction :: !Natural -> !Rational -> BlockProduction

-- | Blocks produced in the given epoch.
[blocksProduced] :: BlockProduction -> !Natural

-- | Relative stake of the pool that was relevant for block production.
--   (i.e. from the "set" snapshot).
[stakeRelative] :: BlockProduction -> !Rational

-- | This is a estimate of the proportion of allowed blocks a pool will
--   make in the future. It is used for ranking pools in delegation.
newtype PerformanceEstimate
PerformanceEstimate :: Double -> PerformanceEstimate
[unPerformanceEstimate] :: PerformanceEstimate -> Double

-- | Estimate the performance of a pool from historical block production
--   data.
--   
--   Assumes that the <a>SlottingParameters</a> are constant through the
--   given history.
estimatePoolPerformance :: SlottingParameters -> DecentralizationLevel -> Seq BlockProduction -> PerformanceEstimate
newtype LogWeight
LogWeight :: Float -> LogWeight
[unLogWeight] :: LogWeight -> Float
newtype Likelihood
Likelihood :: StrictSeq LogWeight -> Likelihood
[unLikelihood] :: Likelihood -> StrictSeq LogWeight
likelihood :: Natural -> Double -> EpochSize -> Likelihood

-- | Decay previous likelihood
applyDecay :: Float -> Likelihood -> Likelihood
newtype Histogram
Histogram :: StrictSeq LogWeight -> Histogram
[unHistogram] :: Histogram -> StrictSeq LogWeight
percentile' :: Likelihood -> PerformanceEstimate
instance GHC.Show.Show Cardano.Pool.Rank.Likelihood.LogWeight
instance NoThunks.Class.NoThunks Cardano.Pool.Rank.Likelihood.LogWeight
instance Control.DeepSeq.NFData Cardano.Pool.Rank.Likelihood.LogWeight
instance GHC.Num.Num Cardano.Pool.Rank.Likelihood.LogWeight
instance GHC.Classes.Ord Cardano.Pool.Rank.Likelihood.LogWeight
instance GHC.Generics.Generic Cardano.Pool.Rank.Likelihood.LogWeight
instance GHC.Classes.Eq Cardano.Pool.Rank.Likelihood.LogWeight
instance GHC.Generics.Generic Cardano.Pool.Rank.Likelihood.Histogram
instance GHC.Show.Show Cardano.Pool.Rank.Likelihood.Histogram
instance GHC.Classes.Eq Cardano.Pool.Rank.Likelihood.Histogram
instance Control.DeepSeq.NFData Cardano.Pool.Rank.Likelihood.Likelihood
instance GHC.Generics.Generic Cardano.Pool.Rank.Likelihood.Likelihood
instance GHC.Classes.Ord Cardano.Pool.Rank.Likelihood.Likelihood
instance GHC.Show.Show Cardano.Pool.Rank.Likelihood.Likelihood
instance NoThunks.Class.NoThunks Cardano.Pool.Rank.Likelihood.PerformanceEstimate
instance GHC.Generics.Generic Cardano.Pool.Rank.Likelihood.PerformanceEstimate
instance GHC.Classes.Eq Cardano.Pool.Rank.Likelihood.PerformanceEstimate
instance GHC.Show.Show Cardano.Pool.Rank.Likelihood.PerformanceEstimate
instance NoThunks.Class.NoThunks Cardano.Pool.Rank.Likelihood.Likelihood
instance GHC.Classes.Eq Cardano.Pool.Rank.Likelihood.Likelihood
instance GHC.Base.Semigroup Cardano.Pool.Rank.Likelihood.Likelihood
instance GHC.Base.Monoid Cardano.Pool.Rank.Likelihood.Likelihood


-- | This module provides tools to estimate pool rewards for the purpose of
--   ranking pools.
module Cardano.Pool.Rank

-- | Information need for the computation of rewards, such as the stake
--   currently delegated to a pool, or the pool cost and margin.
data RewardInfoPool
RewardInfoPool :: Percentage -> Coin -> Coin -> Percentage -> Coin -> Percentage -> Double -> RewardInfoPool

-- | sigma = pool stake / total stake
[stakeRelative] :: RewardInfoPool -> Percentage

-- | pledge of pool owner(s)
[ownerPledge] :: RewardInfoPool -> Coin

-- | absolute stake delegated by pool owner(s)
[ownerStake] :: RewardInfoPool -> Coin

-- | s = owner stake / total stake
[ownerStakeRelative] :: RewardInfoPool -> Percentage
[cost] :: RewardInfoPool -> Coin
[margin] :: RewardInfoPool -> Percentage
[performanceEstimate] :: RewardInfoPool -> Double

-- | Global parameters used for computing rewards
data RewardParams
RewardParams :: Int -> Rational -> Coin -> Coin -> RewardParams

-- | desired number of stake pools
[nOpt] :: RewardParams -> Int

-- | influence of the pool owner's pledge on rewards
[a0] :: RewardParams -> Rational

-- | Total rewards available for the given epoch
[r] :: RewardParams -> Coin

-- | Maximum lovelace supply minus treasury
[totalStake] :: RewardParams -> Coin

-- | Summary of stake distribution and stake pools obtained from network.
data StakePoolsSummary
StakePoolsSummary :: RewardParams -> Map PoolId RewardInfoPool -> StakePoolsSummary
[rewardParams] :: StakePoolsSummary -> RewardParams
[pools] :: StakePoolsSummary -> Map PoolId RewardInfoPool

-- | The saturation of a pool is the ratio of the current pool stake to the
--   fully saturated stake.
poolSaturation :: RewardParams -> RewardInfoPool -> Double

-- | Optimal rewards for a stake pool according to Eq.(2) of Section 5.5.3
--   in SL-D1.
--   
--   <pre>
--   optimalRewards s sigma
--   </pre>
--   
--   NOTE: This computation uses <a>Double</a> internally and is only
--   suitable for the purpose of ranking, not for computing actual monetary
--   rewards.
optimalRewards :: RewardParams -> Percentage -> Rational -> Coin

-- | The yearly rate of return per unit of stake, assuming that the pool's
--   stake remains at the same level. Rewards compound every epoch.
currentROS :: RewardParams -> RewardInfoPool -> Coin -> Percentage

-- | The (yearly) return per unit of stake for a pool that has reached
--   saturation.
saturationROS :: RewardParams -> RewardInfoPool -> Percentage
data RedelegationWarning
AllGood :: RedelegationWarning
TooFewBlocks :: RedelegationWarning
OtherPoolsBetter :: RedelegationWarning

-- | Compute redelegation warning from current pool performance.
--   
--   Note: This function uses the <a>performanceEstimate</a> for the pool
--   that we delegate to, but ignores this fields for the argument
--   <a>StakePoolsSummary</a>.
redelegationWarning :: EpochNo -> (RewardInfoPool, Coin) -> StakePoolsSummary -> EpochNo -> RedelegationWarning

-- | Non-Myopic Pool Member Rewards according to Eq.(3) of Section 5.6.4 in
--   SL-D1.
nonMyopicMemberReward :: RewardParams -> RewardInfoPool -> Bool -> Coin -> Coin

-- | The desirabilty of a pool is equal to the total member rewards at
--   saturation IF the owner meets their pledge.
desirability :: RewardParams -> RewardInfoPool -> Coin
data PoolScore
PoolScore :: Coin -> Coin -> PoolScore
[_desirability] :: PoolScore -> Coin
[_nonMyopicMemberReward] :: PoolScore -> Coin

-- | Compute the desirability and non-myopic rewards for all pools.
--   
--   To compute the non-myopic rewards, we need to know all pools in order
--   to rank them by desirability, and we need to know the stake that the
--   user wants to delegate.
scorePools :: Ord poolId => RewardParams -> Map poolId (RewardInfoPool, a) -> Coin -> Map poolId (PoolScore, RewardInfoPool, a)
instance GHC.Classes.Eq Cardano.Pool.Rank.RewardInfoPool
instance GHC.Show.Show Cardano.Pool.Rank.RewardInfoPool
instance GHC.Classes.Eq Cardano.Pool.Rank.RewardParams
instance GHC.Show.Show Cardano.Pool.Rank.RewardParams
instance GHC.Classes.Eq Cardano.Pool.Rank.StakePoolsSummary
instance GHC.Show.Show Cardano.Pool.Rank.StakePoolsSummary
instance GHC.Show.Show Cardano.Pool.Rank.RedelegationWarning
instance GHC.Classes.Eq Cardano.Pool.Rank.RedelegationWarning
instance Formatting.Buildable.Buildable Cardano.Pool.Rank.RedelegationWarning
instance Formatting.Buildable.Buildable Cardano.Pool.Rank.StakePoolsSummary
instance Formatting.Buildable.Buildable Cardano.Pool.Rank.RewardParams
instance Formatting.Buildable.Buildable Cardano.Pool.Rank.RewardInfoPool


-- | Database / Persistence layer for the pool production.
module Cardano.Pool.DB

-- | A Database interface for storing pool production in DB.
--   
--   To use it, you will need the NamedFieldPuns extension and wrap
--   operations with <tt>atomically</tt>:
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XNamedFieldPuns
--   
--   &gt;&gt;&gt; DBLayer{atomically,putPoolProduction} = db
--   
--   &gt;&gt;&gt; atomically $ putPoolProduction blockHeader pool
--   </pre>
--   
--   This gives you the power to also run <i>multiple</i> operations
--   atomically.
--   
--   FIXME: Allowing <a>MonadIO</a> to enable logging also within db
--   transactions. Ideally, we should lower than constraint to only allow
--   logging effects and not any dragons in IO.
data DBLayer m
DBLayer :: (BlockHeader -> PoolId -> ExceptT ErrPointAlreadyExists stm ()) -> (EpochNo -> stm (Map PoolId [BlockHeader])) -> stm (Map PoolId (Quantity "block" Word64)) -> (EpochNo -> [(PoolId, Quantity "lovelace" Word64)] -> stm ()) -> (EpochNo -> stm [(PoolId, Quantity "lovelace" Word64)]) -> (Int -> stm [BlockHeader]) -> (PoolId -> stm PoolLifeCycleStatus) -> (CertificatePublicationTime -> PoolRegistrationCertificate -> stm ()) -> (PoolId -> stm (Maybe (CertificatePublicationTime, PoolRegistrationCertificate))) -> (CertificatePublicationTime -> PoolRetirementCertificate -> stm ()) -> (PoolId -> stm (Maybe (CertificatePublicationTime, PoolRetirementCertificate))) -> (Int -> stm [(PoolId, StakePoolMetadataUrl, StakePoolMetadataHash)]) -> ((StakePoolMetadataUrl, StakePoolMetadataHash) -> stm ()) -> stm [PoolId] -> (EpochNo -> stm [PoolRetirementCertificate]) -> (EpochNo -> stm [PoolLifeCycleStatus]) -> (StakePoolMetadataHash -> StakePoolMetadata -> stm ()) -> stm () -> stm (Map StakePoolMetadataHash StakePoolMetadata) -> stm StdGen -> (SlotNo -> stm ()) -> ([PoolId] -> stm ()) -> stm [PoolId] -> ([PoolId] -> stm ()) -> (EpochNo -> stm [PoolRetirementCertificate]) -> (BlockHeader -> stm ()) -> (Int -> stm [BlockHeader]) -> stm Settings -> (Settings -> stm ()) -> stm (Maybe POSIXTime) -> (POSIXTime -> stm ()) -> stm () -> (forall a. stm a -> m a) -> DBLayer m

-- | Write for a given slot id the id of stake pool that produced a a
--   corresponding block
[putPoolProduction] :: DBLayer m -> BlockHeader -> PoolId -> ExceptT ErrPointAlreadyExists stm ()

-- | Read the all stake pools together with corresponding slot ids for a
--   given epoch.
[readPoolProduction] :: DBLayer m -> EpochNo -> stm (Map PoolId [BlockHeader])

-- | Read the total pool production since the pool was first registered.
[readTotalProduction] :: DBLayer m -> stm (Map PoolId (Quantity "block" Word64))

-- | Replace an existing distribution for the given epoch by the one given
--   as argument.
--   
--   If there's no existing distribution, simply inserts it.
[putStakeDistribution] :: DBLayer m -> EpochNo -> [(PoolId, Quantity "lovelace" Word64)] -> stm ()
[readStakeDistribution] :: DBLayer m -> EpochNo -> stm [(PoolId, Quantity "lovelace" Word64)]

-- | Read the latest <tt>k</tt> blockheaders in ascending order. The tip
--   will be the last element in the list.
--   
--   This is useful for the <tt>NetworkLayer</tt> to know how far we have
--   synced. Returns all headers if limit is &lt;= 0.
[readPoolProductionCursor] :: DBLayer m -> Int -> stm [BlockHeader]

-- | Read the current life cycle status of the given pool.
[readPoolLifeCycleStatus] :: DBLayer m -> PoolId -> stm PoolLifeCycleStatus

-- | Add a mapping between stake pools and their corresponding certificate.
--   If the mapping already exists, data are replaced with the latest
--   version.
[putPoolRegistration] :: DBLayer m -> CertificatePublicationTime -> PoolRegistrationCertificate -> stm ()

-- | Find the <i>latest</i> registration certificate for the given pool,
--   together with the point in time that the certificate was added.
--   
--   Note that a pool may also have other certificates associated with it
--   that affect its current lifecycle status.
--   
--   See <a>readPoolLifeCycleStatus</a> for a complete picture.
[readPoolRegistration] :: DBLayer m -> PoolId -> stm (Maybe (CertificatePublicationTime, PoolRegistrationCertificate))

-- | Add a retirement certificate for a particular pool.
[putPoolRetirement] :: DBLayer m -> CertificatePublicationTime -> PoolRetirementCertificate -> stm ()

-- | Find the <i>latest</i> retirement certificate for the given pool,
--   together with the point in time that the certificate was added.
--   
--   Note that a pool may also have other certificates associated with it
--   that affect its current lifecycle status.
--   
--   See <a>readPoolLifeCycleStatus</a> for a complete picture.
[readPoolRetirement] :: DBLayer m -> PoolId -> stm (Maybe (CertificatePublicationTime, PoolRetirementCertificate))

-- | Read the list of metadata remaining to fetch from remote server,
--   possibly empty if every pool already has an associated metadata
--   cached.
--   
--   It returns at most <tt>n</tt> results, where <tt>n</tt> is the first
--   argument.
[unfetchedPoolMetadataRefs] :: DBLayer m -> Int -> stm [(PoolId, StakePoolMetadataUrl, StakePoolMetadataHash)]

-- | Store a fetch attempt for a given hash, so that it isn't retried too
--   often.
[putFetchAttempt] :: DBLayer m -> (StakePoolMetadataUrl, StakePoolMetadataHash) -> stm ()

-- | List the list of known pools, based on their registration certificate.
--   This list doesn't necessarily match the keys of the map we would get
--   from <a>readPoolProduction</a> because not all registered pools have
--   necessarily produced any block yet!
[listRegisteredPools] :: DBLayer m -> stm [PoolId]

-- | List all pools with an active retirement epoch that is earlier than or
--   equal to the specified epoch.
[listRetiredPools] :: DBLayer m -> EpochNo -> stm [PoolRetirementCertificate]

-- | List the lifecycle data of all non-retired pools: pools that either
--   don't have an active retirement epoch or pools that have an active
--   retirement epoch that is later than the given epoch.
[listPoolLifeCycleData] :: DBLayer m -> EpochNo -> stm [PoolLifeCycleStatus]

-- | Store metadata fetched from a remote server.
[putPoolMetadata] :: DBLayer m -> StakePoolMetadataHash -> StakePoolMetadata -> stm ()

-- | Delete all pool metadata.
[removePoolMetadata] :: DBLayer m -> stm ()
[readPoolMetadata] :: DBLayer m -> stm (Map StakePoolMetadataHash StakePoolMetadata)

-- | Read the seed assigned to this particular database. The seed is
--   created with the database and is "unique" for each database. This
--   however allow to have a seed that can be used to produce consistent
--   results across requests.
[readSystemSeed] :: DBLayer m -> stm StdGen

-- | Remove all entries of slot ids newer than the argument
[rollbackTo] :: DBLayer m -> SlotNo -> stm ()

-- | Overwrite the set of delisted pools with a completely new set. Pools
--   may be delisted for reasons such as non-compliance.
[putDelistedPools] :: DBLayer m -> [PoolId] -> stm ()

-- | Fetch the set of delisted pools.
[readDelistedPools] :: DBLayer m -> stm [PoolId]

-- | Remove all data relating to the specified pools.
[removePools] :: DBLayer m -> [PoolId] -> stm ()

-- | Remove all pools with an active retirement epoch that is earlier than
--   or equal to the specified epoch.
--   
--   Returns the retirement certificates of the pools that were removed.
--   
--   See also:
--   
--   <ul>
--   <li><a>listRetiredPools</a>.</li>
--   <li><a>removePools</a>.</li>
--   </ul>
[removeRetiredPools] :: DBLayer m -> EpochNo -> stm [PoolRetirementCertificate]

-- | Add a block header
[putHeader] :: DBLayer m -> BlockHeader -> stm ()

-- | List headers, usually stored during syncing. Returns all headers if
--   limit is &lt;= 0.
[listHeaders] :: DBLayer m -> Int -> stm [BlockHeader]

-- | Get the settings.
[readSettings] :: DBLayer m -> stm Settings

-- | Modify the settings.
[putSettings] :: DBLayer m -> Settings -> stm ()

-- | Get the last metadata GC time.
[readLastMetadataGC] :: DBLayer m -> stm (Maybe POSIXTime)

-- | Set the last metadata GC time.
[putLastMetadataGC] :: DBLayer m -> POSIXTime -> stm ()

-- | Clean a database
[cleanDB] :: DBLayer m -> stm ()

-- | Run an operation.
--   
--   For a Sqlite DB, this would be "run a query inside a transaction".
[atomically] :: DBLayer m -> forall a. stm a -> m a

-- | Given the <i>latest</i> registration and retirement certificates for a
--   pool, determine the pool's current life cycle status, based on the
--   relative order in which the certificates were published.
--   
--   If two certificates are supplied, then:
--   
--   <ul>
--   <li>the certificates must be from the same pool.</li>
--   <li>the publication times must be non-equal.</li>
--   </ul>
--   
--   Violating either of the above pre-conditions is a programming error.
--   
--   This function determines order of precedence according to the "pool
--   inference rule", as described in "A Formal Specification of the
--   Cardano Ledger":
--   
--   <a>https://hydra.iohk.io/build/3202141/download/1/ledger-spec.pdf</a>
determinePoolLifeCycleStatus :: (Ord publicationTime, Show publicationTime) => Maybe (publicationTime, PoolRegistrationCertificate) -> Maybe (publicationTime, PoolRetirementCertificate) -> PoolLifeCycleStatus

-- | Forbidden operation was executed on an already existing slot
newtype ErrPointAlreadyExists
ErrPointAlreadyExists :: BlockHeader -> ErrPointAlreadyExists
instance GHC.Show.Show Cardano.Pool.DB.ErrPointAlreadyExists
instance GHC.Classes.Eq Cardano.Pool.DB.ErrPointAlreadyExists


-- | An implementation of the production pool database using only pure
--   functions.
--   
--   These functions and types model the behaviour of the SQLite database
--   backend, and are used for QuickCheck state machine testing, and the
--   MVar database backend.
module Cardano.Pool.DB.Model
data PoolDatabase
PoolDatabase :: !Map PoolId [BlockHeader] -> !Map EpochNo [(PoolId, Quantity "lovelace" Word64)] -> !Map PoolId [PoolOwner] -> !Map (CertificatePublicationTime, PoolId) PoolRegistrationCertificate -> !Map (CertificatePublicationTime, PoolId) PoolRetirementCertificate -> !Set PoolId -> !Map StakePoolMetadataHash StakePoolMetadata -> !Map (StakePoolMetadataUrl, StakePoolMetadataHash) Int -> !SystemSeed -> [BlockHeader] -> Settings -> InternalState -> PoolDatabase

-- | Information of what blocks were produced by which stake pools
[$sel:pools:PoolDatabase] :: PoolDatabase -> !Map PoolId [BlockHeader]

-- | Store known stake distributions for epochs
[$sel:distributions:PoolDatabase] :: PoolDatabase -> !Map EpochNo [(PoolId, Quantity "lovelace" Word64)]

-- | Mapping between pool ids and owners
[$sel:owners:PoolDatabase] :: PoolDatabase -> !Map PoolId [PoolOwner]

-- | On-chain registrations associated with pools
[$sel:registrations:PoolDatabase] :: PoolDatabase -> !Map (CertificatePublicationTime, PoolId) PoolRegistrationCertificate

-- | On-chain retirements associated with pools
[$sel:retirements:PoolDatabase] :: PoolDatabase -> !Map (CertificatePublicationTime, PoolId) PoolRetirementCertificate
[$sel:delisted:PoolDatabase] :: PoolDatabase -> !Set PoolId

-- | Off-chain metadata cached in database
[$sel:metadata:PoolDatabase] :: PoolDatabase -> !Map StakePoolMetadataHash StakePoolMetadata

-- | Metadata (failed) fetch attempts
[$sel:fetchAttempts:PoolDatabase] :: PoolDatabase -> !Map (StakePoolMetadataUrl, StakePoolMetadataHash) Int

-- | Store an arbitrary random generator seed
[$sel:seed:PoolDatabase] :: PoolDatabase -> !SystemSeed

-- | Store headers during syncing
[$sel:blockHeaders:PoolDatabase] :: PoolDatabase -> [BlockHeader]
[$sel:settings:PoolDatabase] :: PoolDatabase -> Settings

-- | Various internal states that need to persist across wallet restarts.
[$sel:internalState:PoolDatabase] :: PoolDatabase -> InternalState

-- | Produces an empty model pool production database.
emptyPoolDatabase :: PoolDatabase
type ModelOp a = StateT PoolDatabase (Either PoolErr) a
newtype PoolErr
PointAlreadyExists :: BlockHeader -> PoolErr
mCleanDatabase :: ModelOp ()
mCleanPoolMetadata :: ModelOp ()
mPutPoolProduction :: BlockHeader -> PoolId -> ModelOp ()
mPutHeader :: BlockHeader -> ModelOp ()
mListHeaders :: Int -> ModelOp [BlockHeader]
mReadPoolProduction :: TimeInterpreter Identity -> EpochNo -> ModelOp (Map PoolId [BlockHeader])
mReadTotalProduction :: ModelOp (Map PoolId (Quantity "block" Word64))
mPutStakeDistribution :: EpochNo -> [(PoolId, Quantity "lovelace" Word64)] -> ModelOp ()
mReadStakeDistribution :: EpochNo -> ModelOp [(PoolId, Quantity "lovelace" Word64)]
mReadPoolMetadata :: ModelOp (Map StakePoolMetadataHash StakePoolMetadata)
mPutPoolRegistration :: CertificatePublicationTime -> PoolRegistrationCertificate -> ModelOp ()
mReadPoolRegistration :: PoolId -> ModelOp (Maybe (CertificatePublicationTime, PoolRegistrationCertificate))
mPutPoolRetirement :: CertificatePublicationTime -> PoolRetirementCertificate -> ModelOp ()
mReadPoolRetirement :: PoolId -> ModelOp (Maybe (CertificatePublicationTime, PoolRetirementCertificate))
mUnfetchedPoolMetadataRefs :: Int -> ModelOp [(PoolId, StakePoolMetadataUrl, StakePoolMetadataHash)]
mPutDelistedPools :: [PoolId] -> ModelOp ()
mPutFetchAttempt :: (StakePoolMetadataUrl, StakePoolMetadataHash) -> ModelOp ()
mPutPoolMetadata :: StakePoolMetadataHash -> StakePoolMetadata -> ModelOp ()
mListPoolLifeCycleData :: EpochNo -> ModelOp [PoolLifeCycleStatus]
mListRegisteredPools :: ModelOp [PoolId]
mListRetiredPools :: EpochNo -> ModelOp [PoolRetirementCertificate]
mReadPoolLifeCycleStatus :: PoolId -> ModelOp PoolLifeCycleStatus
mReadSystemSeed :: PoolDatabase -> IO (StdGen, PoolDatabase)
mRollbackTo :: TimeInterpreter Identity -> SlotNo -> ModelOp ()
mReadCursor :: Int -> ModelOp [BlockHeader]
mRemovePools :: [PoolId] -> ModelOp ()
mReadDelistedPools :: ModelOp [PoolId]
mRemoveRetiredPools :: EpochNo -> ModelOp [PoolRetirementCertificate]
mReadSettings :: ModelOp Settings
mPutSettings :: Settings -> ModelOp ()
mPutLastMetadataGC :: POSIXTime -> ModelOp ()
mReadLastMetadataGC :: ModelOp (Maybe POSIXTime)
instance GHC.Show.Show Cardano.Pool.DB.Model.SystemSeed
instance GHC.Generics.Generic Cardano.Pool.DB.Model.SystemSeed
instance GHC.Classes.Eq Cardano.Pool.DB.Model.PoolDatabase
instance GHC.Show.Show Cardano.Pool.DB.Model.PoolDatabase
instance GHC.Generics.Generic Cardano.Pool.DB.Model.PoolDatabase
instance GHC.Classes.Eq Cardano.Pool.DB.Model.PoolErr
instance GHC.Show.Show Cardano.Pool.DB.Model.PoolErr
instance GHC.Classes.Eq Cardano.Pool.DB.Model.SystemSeed


-- | Dummy implementation of the database-layer, using <a>MVar</a>. This
--   may be good for testing to compare with an implementation on a real
--   data store, or to use when compiling the wallet for targets which
--   don't have SQLite.
module Cardano.Pool.DB.MVar

-- | Instantiate a new in-memory "database" layer that simply stores data
--   in a local MVar. Data vanishes if the software is shut down.
newDBLayer :: TimeInterpreter Identity -> IO (DBLayer IO)
instance GHC.Show.Show Cardano.Pool.DB.MVar.MVarPoolDBError
instance GHC.Exception.Type.Exception Cardano.Pool.DB.MVar.MVarPoolDBError


-- | Utility functions for converting time values to and from text.
module Data.Time.Text

-- | Convert the specified time value to text, using the specified time
--   format.
utcTimeToText :: TimeFormat -> UTCTime -> Text

-- | Attempt to use each of the specified time formats to parse the given
--   text. Returns a time value that corresponds to the first matching
--   format, or <a>Nothing</a> if none of the formats matched.
utcTimeFromText :: [TimeFormat] -> Text -> Maybe UTCTime

-- | Represents a particular way of representing a moment in time in text.
data TimeFormat
TimeFormat :: String -> String -> TimeFormat
[timeFormatName] :: TimeFormat -> String
[timeFormatPattern] :: TimeFormat -> String

-- | Represents the ISO 8601 basic format (UTC).
iso8601BasicUtc :: TimeFormat

-- | Represents the ISO 8601 basic format (with local timezone).
iso8601BasicLocal :: TimeFormat

-- | Represents the ISO 8601 extended format (UTC).
iso8601ExtendedUtc :: TimeFormat

-- | Represents the ISO 8601 extended format (with local timezone).
iso8601ExtendedLocal :: TimeFormat

-- | Represents the ISO 8601 family of formats.
iso8601 :: [TimeFormat]

-- | Represents the ISO 8601 basic family of formats.
iso8601Basic :: [TimeFormat]

-- | Represents the ISO 8601 extended family of formats.
iso8601Extended :: [TimeFormat]
instance GHC.Classes.Eq Data.Time.Text.TimeFormat


-- | API type representations of various types. We define here pretty much
--   all our user-facing types that are mostly composed with internal /
--   primitive types.
--   
--   This module also define required API instances (JSON, HttpApiData...)
--   for all those types, making sure to match the specification document:
--   
--   <a>Wallet API Specification</a>
module Cardano.Wallet.Api.Types
data WalletStyle
Shelley :: WalletStyle
Byron :: WalletStyle
Shared :: WalletStyle
data ByronWalletStyle
Random :: ByronWalletStyle
Icarus :: ByronWalletStyle
Trezor :: ByronWalletStyle
Ledger :: ByronWalletStyle
type family StyleSymbol (style :: ByronWalletStyle) :: Symbol
type family AllowedMnemonics (style :: k) :: [Nat]
fmtAllowedWords :: ByronWalletStyle -> String
data ApiAsset
ApiAsset :: ApiT TokenPolicyId -> ApiT TokenName -> ApiT TokenFingerprint -> Maybe ApiAssetMetadata -> Maybe ApiMetadataError -> ApiAsset
[$sel:policyId:ApiAsset] :: ApiAsset -> ApiT TokenPolicyId
[$sel:assetName:ApiAsset] :: ApiAsset -> ApiT TokenName
[$sel:fingerprint:ApiAsset] :: ApiAsset -> ApiT TokenFingerprint
[$sel:metadata:ApiAsset] :: ApiAsset -> Maybe ApiAssetMetadata
[$sel:metadataError:ApiAsset] :: ApiAsset -> Maybe ApiMetadataError
toApiAsset :: Either TokenMetadataError (Maybe AssetMetadata) -> AssetId -> ApiAsset
data ApiAssetMetadata
ApiAssetMetadata :: Text -> Text -> Maybe Text -> Maybe (ApiT AssetURL) -> Maybe (ApiT AssetLogo) -> Maybe (ApiT AssetDecimals) -> ApiAssetMetadata
[$sel:name:ApiAssetMetadata] :: ApiAssetMetadata -> Text
[$sel:description:ApiAssetMetadata] :: ApiAssetMetadata -> Text
[$sel:ticker:ApiAssetMetadata] :: ApiAssetMetadata -> Maybe Text
[$sel:url:ApiAssetMetadata] :: ApiAssetMetadata -> Maybe (ApiT AssetURL)
[$sel:logo:ApiAssetMetadata] :: ApiAssetMetadata -> Maybe (ApiT AssetLogo)
[$sel:decimals:ApiAssetMetadata] :: ApiAssetMetadata -> Maybe (ApiT AssetDecimals)
toApiAssetMetadata :: AssetMetadata -> ApiAssetMetadata
data ApiAddress (n :: NetworkDiscriminant)
ApiAddress :: !(ApiT Address, Proxy n) -> !ApiT AddressState -> NonEmpty (ApiT DerivationIndex) -> ApiAddress (n :: NetworkDiscriminant)
[$sel:id:ApiAddress] :: ApiAddress (n :: NetworkDiscriminant) -> !(ApiT Address, Proxy n)
[$sel:state:ApiAddress] :: ApiAddress (n :: NetworkDiscriminant) -> !ApiT AddressState
[$sel:derivationPath:ApiAddress] :: ApiAddress (n :: NetworkDiscriminant) -> NonEmpty (ApiT DerivationIndex)
data ApiCredential
CredentialExtendedPubKey :: ByteString -> ApiCredential
CredentialPubKey :: ByteString -> ApiCredential
CredentialKeyHash :: ByteString -> ApiCredential
CredentialScript :: Script KeyHash -> ApiCredential
data ApiAddressData
ApiAddressData :: !ApiAddressDataPayload -> !Maybe (ApiT ValidationLevel) -> ApiAddressData
[$sel:address:ApiAddressData] :: ApiAddressData -> !ApiAddressDataPayload
[$sel:validationLevel:ApiAddressData] :: ApiAddressData -> !Maybe (ApiT ValidationLevel)
data ApiAddressDataPayload
AddrEnterprise :: ApiCredential -> ApiAddressDataPayload
AddrRewardAccount :: ApiCredential -> ApiAddressDataPayload
AddrBase :: ApiCredential -> ApiCredential -> ApiAddressDataPayload
data AnyAddress
AnyAddress :: ByteString -> AnyAddressType -> Int -> AnyAddress
[$sel:payload:AnyAddress] :: AnyAddress -> ByteString
[$sel:flavour:AnyAddress] :: AnyAddress -> AnyAddressType
[$sel:network:AnyAddress] :: AnyAddress -> Int
data AnyAddressType
EnterpriseDelegating :: AnyAddressType
RewardAccount :: AnyAddressType
data ApiCertificate
RegisterRewardAccount :: NonEmpty (ApiT DerivationIndex) -> ApiCertificate
[$sel:rewardAccountPath:RegisterRewardAccount] :: ApiCertificate -> NonEmpty (ApiT DerivationIndex)
JoinPool :: NonEmpty (ApiT DerivationIndex) -> ApiT PoolId -> ApiCertificate
[$sel:rewardAccountPath:RegisterRewardAccount] :: ApiCertificate -> NonEmpty (ApiT DerivationIndex)
[$sel:pool:RegisterRewardAccount] :: ApiCertificate -> ApiT PoolId
QuitPool :: NonEmpty (ApiT DerivationIndex) -> ApiCertificate
[$sel:rewardAccountPath:RegisterRewardAccount] :: ApiCertificate -> NonEmpty (ApiT DerivationIndex)
data ApiDelegationAction
Join :: ApiT PoolId -> ApiDelegationAction
Quit :: ApiDelegationAction
data ApiEpochInfo
ApiEpochInfo :: !ApiT EpochNo -> !UTCTime -> ApiEpochInfo
[$sel:epochNumber:ApiEpochInfo] :: ApiEpochInfo -> !ApiT EpochNo
[$sel:epochStartTime:ApiEpochInfo] :: ApiEpochInfo -> !UTCTime
toApiEpochInfo :: EpochNo -> Qry ApiEpochInfo
data ApiSelectCoinsData (n :: NetworkDiscriminant)
ApiSelectForPayment :: ApiSelectCoinsPayments n -> ApiSelectCoinsData (n :: NetworkDiscriminant)
ApiSelectForDelegation :: ApiSelectCoinsAction -> ApiSelectCoinsData (n :: NetworkDiscriminant)
data ApiSelectCoinsPayments (n :: NetworkDiscriminant)
ApiSelectCoinsPayments :: NonEmpty (ApiTxOutput n) -> !Maybe ApiWithdrawalPostData -> !Maybe (ApiT TxMetadata) -> ApiSelectCoinsPayments (n :: NetworkDiscriminant)
[$sel:payments:ApiSelectCoinsPayments] :: ApiSelectCoinsPayments (n :: NetworkDiscriminant) -> NonEmpty (ApiTxOutput n)
[$sel:withdrawal:ApiSelectCoinsPayments] :: ApiSelectCoinsPayments (n :: NetworkDiscriminant) -> !Maybe ApiWithdrawalPostData
[$sel:metadata:ApiSelectCoinsPayments] :: ApiSelectCoinsPayments (n :: NetworkDiscriminant) -> !Maybe (ApiT TxMetadata)
newtype ApiSelectCoinsAction
ApiSelectCoinsAction :: ApiDelegationAction -> ApiSelectCoinsAction
[$sel:delegationAction:ApiSelectCoinsAction] :: ApiSelectCoinsAction -> ApiDelegationAction

-- | A user may choose to either mint tokens or burn tokens with each
--   operation.
data ApiMintBurnOperation (n :: NetworkDiscriminant)

-- | Mint tokens.
ApiMint :: ApiMintData n -> ApiMintBurnOperation (n :: NetworkDiscriminant)

-- | Burn tokens.
ApiBurn :: ApiBurnData -> ApiMintBurnOperation (n :: NetworkDiscriminant)

-- | The format of a minting request: mint "amount" and send it to the
--   "address".
data ApiMintData (n :: NetworkDiscriminant)
ApiMintData :: Maybe (ApiT Address, Proxy n) -> Natural -> ApiMintData (n :: NetworkDiscriminant)

-- | An optional address to which minted assets should be paid.
--   
--   If no address is specified, then minted assets will be returned to the
--   wallet as change, and change output addresses will be assigned
--   automatically.
[$sel:receivingAddress:ApiMintData] :: ApiMintData (n :: NetworkDiscriminant) -> Maybe (ApiT Address, Proxy n)

-- | Amount of assets to mint.
[$sel:quantity:ApiMintData] :: ApiMintData (n :: NetworkDiscriminant) -> Natural

-- | The format of a burn request: burn "amount". The user can only specify
--   the type of tokens to burn (policyId, assetName), and the amount, the
--   exact tokens selected are up to the implementation.
newtype ApiBurnData
ApiBurnData :: Natural -> ApiBurnData
[$sel:quantity:ApiBurnData] :: ApiBurnData -> Natural
data ApiCoinSelection (n :: NetworkDiscriminant)
ApiCoinSelection :: ![ApiWalletInput n] -> ![ApiCoinSelectionOutput n] -> ![ApiCoinSelectionChange n] -> ![ApiCoinSelectionCollateral n] -> ![ApiCoinSelectionWithdrawal n] -> Maybe (NonEmpty ApiCertificate) -> ![Quantity "lovelace" Natural] -> ![Quantity "lovelace" Natural] -> !Maybe ApiBase64 -> ApiCoinSelection (n :: NetworkDiscriminant)
[$sel:inputs:ApiCoinSelection] :: ApiCoinSelection (n :: NetworkDiscriminant) -> ![ApiWalletInput n]
[$sel:outputs:ApiCoinSelection] :: ApiCoinSelection (n :: NetworkDiscriminant) -> ![ApiCoinSelectionOutput n]
[$sel:change:ApiCoinSelection] :: ApiCoinSelection (n :: NetworkDiscriminant) -> ![ApiCoinSelectionChange n]
[$sel:collateral:ApiCoinSelection] :: ApiCoinSelection (n :: NetworkDiscriminant) -> ![ApiCoinSelectionCollateral n]
[$sel:withdrawals:ApiCoinSelection] :: ApiCoinSelection (n :: NetworkDiscriminant) -> ![ApiCoinSelectionWithdrawal n]
[$sel:certificates:ApiCoinSelection] :: ApiCoinSelection (n :: NetworkDiscriminant) -> Maybe (NonEmpty ApiCertificate)
[$sel:depositsTaken:ApiCoinSelection] :: ApiCoinSelection (n :: NetworkDiscriminant) -> ![Quantity "lovelace" Natural]
[$sel:depositsReturned:ApiCoinSelection] :: ApiCoinSelection (n :: NetworkDiscriminant) -> ![Quantity "lovelace" Natural]
[$sel:metadata:ApiCoinSelection] :: ApiCoinSelection (n :: NetworkDiscriminant) -> !Maybe ApiBase64
data ApiCoinSelectionChange (n :: NetworkDiscriminant)
ApiCoinSelectionChange :: !(ApiT Address, Proxy n) -> !Quantity "lovelace" Natural -> !ApiT TokenMap -> NonEmpty (ApiT DerivationIndex) -> ApiCoinSelectionChange (n :: NetworkDiscriminant)
[$sel:address:ApiCoinSelectionChange] :: ApiCoinSelectionChange (n :: NetworkDiscriminant) -> !(ApiT Address, Proxy n)
[$sel:amount:ApiCoinSelectionChange] :: ApiCoinSelectionChange (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:assets:ApiCoinSelectionChange] :: ApiCoinSelectionChange (n :: NetworkDiscriminant) -> !ApiT TokenMap
[$sel:derivationPath:ApiCoinSelectionChange] :: ApiCoinSelectionChange (n :: NetworkDiscriminant) -> NonEmpty (ApiT DerivationIndex)
data ApiCoinSelectionCollateral (n :: NetworkDiscriminant)
ApiCoinSelectionCollateral :: !ApiT (Hash "Tx") -> !Word32 -> !(ApiT Address, Proxy n) -> NonEmpty (ApiT DerivationIndex) -> !Quantity "lovelace" Natural -> ApiCoinSelectionCollateral (n :: NetworkDiscriminant)
[$sel:id:ApiCoinSelectionCollateral] :: ApiCoinSelectionCollateral (n :: NetworkDiscriminant) -> !ApiT (Hash "Tx")
[$sel:index:ApiCoinSelectionCollateral] :: ApiCoinSelectionCollateral (n :: NetworkDiscriminant) -> !Word32
[$sel:address:ApiCoinSelectionCollateral] :: ApiCoinSelectionCollateral (n :: NetworkDiscriminant) -> !(ApiT Address, Proxy n)
[$sel:derivationPath:ApiCoinSelectionCollateral] :: ApiCoinSelectionCollateral (n :: NetworkDiscriminant) -> NonEmpty (ApiT DerivationIndex)
[$sel:amount:ApiCoinSelectionCollateral] :: ApiCoinSelectionCollateral (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
data ApiCoinSelectionOutput (n :: NetworkDiscriminant)
ApiCoinSelectionOutput :: !(ApiT Address, Proxy n) -> !Quantity "lovelace" Natural -> !ApiT TokenMap -> ApiCoinSelectionOutput (n :: NetworkDiscriminant)
[$sel:address:ApiCoinSelectionOutput] :: ApiCoinSelectionOutput (n :: NetworkDiscriminant) -> !(ApiT Address, Proxy n)
[$sel:amount:ApiCoinSelectionOutput] :: ApiCoinSelectionOutput (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:assets:ApiCoinSelectionOutput] :: ApiCoinSelectionOutput (n :: NetworkDiscriminant) -> !ApiT TokenMap
data ApiCoinSelectionWithdrawal n
ApiCoinSelectionWithdrawal :: !(ApiT RewardAccount, Proxy n) -> !NonEmpty (ApiT DerivationIndex) -> !Quantity "lovelace" Natural -> ApiCoinSelectionWithdrawal n
[$sel:stakeAddress:ApiCoinSelectionWithdrawal] :: ApiCoinSelectionWithdrawal n -> !(ApiT RewardAccount, Proxy n)
[$sel:derivationPath:ApiCoinSelectionWithdrawal] :: ApiCoinSelectionWithdrawal n -> !NonEmpty (ApiT DerivationIndex)
[$sel:amount:ApiCoinSelectionWithdrawal] :: ApiCoinSelectionWithdrawal n -> !Quantity "lovelace" Natural
type ApiBase64 = ApiBytesT 'Base64 ByteString

-- | Core minting and burning request information.
--   
--   Assets are minted and burned under a "policy". The policy defines
--   under what circumstances a token may be minted and burned. The policy
--   is the hash of a serialized script that contains verification keys and
--   timelocks combined in conditions, possibly nested, to accommodate
--   non-trivial time conditions. In the non-multisig case the script
--   regulating minting/burning will contain a verification key via
--   cosigner#0 of the wallet with optional time predicates. In the
--   multisig case the script regulating minting/burning will contain
--   verification keys of signers (via cosigner#N) with optional time
--   predicates. The used key derivation index is the same for all engaged
--   derivation keys and ix=0 is assumed to be used. The verification key
--   derivation is performed according to CIP 1855.
data ApiMintBurnData (n :: NetworkDiscriminant)
ApiMintBurnData :: !ApiT (Script Cosigner) -> !Maybe (ApiT TokenName) -> !ApiMintBurnOperation n -> ApiMintBurnData (n :: NetworkDiscriminant)

-- | A script regulating minting/burning policy. <tt>self</tt> is expected
--   in place of verification key.
[$sel:policyScriptTemplate:ApiMintBurnData] :: ApiMintBurnData (n :: NetworkDiscriminant) -> !ApiT (Script Cosigner)

-- | The name of the asset to mint/burn.
[$sel:assetName:ApiMintBurnData] :: ApiMintBurnData (n :: NetworkDiscriminant) -> !Maybe (ApiT TokenName)

-- | The minting or burning operation to perform.
[$sel:operation:ApiMintBurnData] :: ApiMintBurnData (n :: NetworkDiscriminant) -> !ApiMintBurnOperation n
data ApiStakePool
ApiStakePool :: !ApiT PoolId -> !ApiStakePoolMetrics -> !Maybe (ApiT StakePoolMetadata) -> !Quantity "lovelace" Natural -> !Quantity "percent" Percentage -> !Quantity "lovelace" Natural -> !Maybe ApiEpochInfo -> ![ApiStakePoolFlag] -> ApiStakePool
[$sel:id:ApiStakePool] :: ApiStakePool -> !ApiT PoolId
[$sel:metrics:ApiStakePool] :: ApiStakePool -> !ApiStakePoolMetrics
[$sel:metadata:ApiStakePool] :: ApiStakePool -> !Maybe (ApiT StakePoolMetadata)
[$sel:cost:ApiStakePool] :: ApiStakePool -> !Quantity "lovelace" Natural
[$sel:margin:ApiStakePool] :: ApiStakePool -> !Quantity "percent" Percentage
[$sel:pledge:ApiStakePool] :: ApiStakePool -> !Quantity "lovelace" Natural
[$sel:retirement:ApiStakePool] :: ApiStakePool -> !Maybe ApiEpochInfo
[$sel:flags:ApiStakePool] :: ApiStakePool -> ![ApiStakePoolFlag]
data ApiStakePoolMetrics
ApiStakePoolMetrics :: !Quantity "lovelace" Natural -> !Quantity "percent" Percentage -> !Double -> !Quantity "block" Natural -> ApiStakePoolMetrics
[$sel:nonMyopicMemberRewards:ApiStakePoolMetrics] :: ApiStakePoolMetrics -> !Quantity "lovelace" Natural
[$sel:relativeStake:ApiStakePoolMetrics] :: ApiStakePoolMetrics -> !Quantity "percent" Percentage
[$sel:saturation:ApiStakePoolMetrics] :: ApiStakePoolMetrics -> !Double
[$sel:producedBlocks:ApiStakePoolMetrics] :: ApiStakePoolMetrics -> !Quantity "block" Natural
data ApiStakePoolFlag
Delisted :: ApiStakePoolFlag
data ApiWallet
ApiWallet :: !ApiT WalletId -> !ApiT AddressPoolGap -> !ApiWalletBalance -> !ApiWalletAssetsBalance -> !ApiWalletDelegation -> !ApiT WalletName -> !Maybe ApiWalletPassphraseInfo -> !ApiT SyncProgress -> !ApiBlockReference -> ApiWallet
[$sel:id:ApiWallet] :: ApiWallet -> !ApiT WalletId
[$sel:addressPoolGap:ApiWallet] :: ApiWallet -> !ApiT AddressPoolGap
[$sel:balance:ApiWallet] :: ApiWallet -> !ApiWalletBalance
[$sel:assets:ApiWallet] :: ApiWallet -> !ApiWalletAssetsBalance
[$sel:delegation:ApiWallet] :: ApiWallet -> !ApiWalletDelegation
[$sel:name:ApiWallet] :: ApiWallet -> !ApiT WalletName
[$sel:passphrase:ApiWallet] :: ApiWallet -> !Maybe ApiWalletPassphraseInfo
[$sel:state:ApiWallet] :: ApiWallet -> !ApiT SyncProgress
[$sel:tip:ApiWallet] :: ApiWallet -> !ApiBlockReference
data ApiWalletBalance
ApiWalletBalance :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> ApiWalletBalance
[$sel:available:ApiWalletBalance] :: ApiWalletBalance -> !Quantity "lovelace" Natural
[$sel:total:ApiWalletBalance] :: ApiWalletBalance -> !Quantity "lovelace" Natural
[$sel:reward:ApiWalletBalance] :: ApiWalletBalance -> !Quantity "lovelace" Natural
data ApiWalletAssetsBalance
ApiWalletAssetsBalance :: !ApiT TokenMap -> !ApiT TokenMap -> ApiWalletAssetsBalance
[$sel:available:ApiWalletAssetsBalance] :: ApiWalletAssetsBalance -> !ApiT TokenMap
[$sel:total:ApiWalletAssetsBalance] :: ApiWalletAssetsBalance -> !ApiT TokenMap
data ApiWalletMode
Light :: ApiWalletMode
Node :: ApiWalletMode
newtype ApiWalletPassphrase
ApiWalletPassphrase :: ApiT (Passphrase "lenient") -> ApiWalletPassphrase
[$sel:passphrase:ApiWalletPassphrase] :: ApiWalletPassphrase -> ApiT (Passphrase "lenient")
newtype ApiWalletPassphraseInfo
ApiWalletPassphraseInfo :: UTCTime -> ApiWalletPassphraseInfo
[$sel:lastUpdatedAt:ApiWalletPassphraseInfo] :: ApiWalletPassphraseInfo -> UTCTime
newtype ApiWalletUtxoSnapshot
ApiWalletUtxoSnapshot :: [ApiWalletUtxoSnapshotEntry] -> ApiWalletUtxoSnapshot
[$sel:entries:ApiWalletUtxoSnapshot] :: ApiWalletUtxoSnapshot -> [ApiWalletUtxoSnapshotEntry]
data ApiWalletUtxoSnapshotEntry
ApiWalletUtxoSnapshotEntry :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> !ApiT TokenMap -> ApiWalletUtxoSnapshotEntry
[$sel:ada:ApiWalletUtxoSnapshotEntry] :: ApiWalletUtxoSnapshotEntry -> !Quantity "lovelace" Natural
[$sel:adaMinimum:ApiWalletUtxoSnapshotEntry] :: ApiWalletUtxoSnapshotEntry -> !Quantity "lovelace" Natural
[$sel:assets:ApiWalletUtxoSnapshotEntry] :: ApiWalletUtxoSnapshotEntry -> !ApiT TokenMap
data ApiUtxoStatistics
ApiUtxoStatistics :: !Quantity "lovelace" Natural -> !ApiT BoundType -> !Map Word64 Word64 -> ApiUtxoStatistics
[$sel:total:ApiUtxoStatistics] :: ApiUtxoStatistics -> !Quantity "lovelace" Natural
[$sel:scale:ApiUtxoStatistics] :: ApiUtxoStatistics -> !ApiT BoundType
[$sel:distribution:ApiUtxoStatistics] :: ApiUtxoStatistics -> !Map Word64 Word64
toApiUtxoStatistics :: UTxOStatistics -> ApiUtxoStatistics
data WalletPostData
WalletPostData :: !Maybe (ApiT AddressPoolGap) -> !ApiMnemonicT (AllowedMnemonics 'Shelley) -> !Maybe (ApiMnemonicT (AllowedMnemonics 'SndFactor)) -> !ApiT WalletName -> !ApiT (Passphrase "user") -> WalletPostData
[$sel:addressPoolGap:WalletPostData] :: WalletPostData -> !Maybe (ApiT AddressPoolGap)
[$sel:mnemonicSentence:WalletPostData] :: WalletPostData -> !ApiMnemonicT (AllowedMnemonics 'Shelley)
[$sel:mnemonicSecondFactor:WalletPostData] :: WalletPostData -> !Maybe (ApiMnemonicT (AllowedMnemonics 'SndFactor))
[$sel:name:WalletPostData] :: WalletPostData -> !ApiT WalletName
[$sel:passphrase:WalletPostData] :: WalletPostData -> !ApiT (Passphrase "user")
newtype WalletPutData
WalletPutData :: Maybe (ApiT WalletName) -> WalletPutData
[$sel:name:WalletPutData] :: WalletPutData -> Maybe (ApiT WalletName)
newtype SettingsPutData
SettingsPutData :: ApiT Settings -> SettingsPutData
[$sel:settings:SettingsPutData] :: SettingsPutData -> ApiT Settings
newtype WalletPutPassphraseData
WalletPutPassphraseData :: Either WalletPutPassphraseOldPassphraseData WalletPutPassphraseMnemonicData -> WalletPutPassphraseData
data WalletPutPassphraseOldPassphraseData
WalletPutPassphraseOldPassphraseData :: !ApiT (Passphrase "user") -> !ApiT (Passphrase "user") -> WalletPutPassphraseOldPassphraseData
[$sel:oldPassphrase:WalletPutPassphraseOldPassphraseData] :: WalletPutPassphraseOldPassphraseData -> !ApiT (Passphrase "user")
[$sel:newPassphrase:WalletPutPassphraseOldPassphraseData] :: WalletPutPassphraseOldPassphraseData -> !ApiT (Passphrase "user")
data WalletPutPassphraseMnemonicData
WalletPutPassphraseMnemonicData :: !ApiMnemonicT (AllowedMnemonics 'Shelley) -> !Maybe (ApiMnemonicT (AllowedMnemonics 'SndFactor)) -> !ApiT (Passphrase "user") -> WalletPutPassphraseMnemonicData
[$sel:mnemonicSentence:WalletPutPassphraseMnemonicData] :: WalletPutPassphraseMnemonicData -> !ApiMnemonicT (AllowedMnemonics 'Shelley)
[$sel:mnemonicSecondFactor:WalletPutPassphraseMnemonicData] :: WalletPutPassphraseMnemonicData -> !Maybe (ApiMnemonicT (AllowedMnemonics 'SndFactor))
[$sel:newPassphrase:WalletPutPassphraseMnemonicData] :: WalletPutPassphraseMnemonicData -> !ApiT (Passphrase "user")
data ApiSignTransactionPostData
ApiSignTransactionPostData :: !ApiT SealedTx -> !ApiT (Passphrase "lenient") -> ApiSignTransactionPostData
[$sel:transaction:ApiSignTransactionPostData] :: ApiSignTransactionPostData -> !ApiT SealedTx
[$sel:passphrase:ApiSignTransactionPostData] :: ApiSignTransactionPostData -> !ApiT (Passphrase "lenient")

-- | Legacy transaction API.
data PostTransactionOldData (n :: NetworkDiscriminant)
PostTransactionOldData :: !NonEmpty (ApiTxOutput n) -> !ApiT (Passphrase "lenient") -> !Maybe ApiWithdrawalPostData -> !Maybe TxMetadataWithSchema -> !Maybe (Quantity "second" NominalDiffTime) -> PostTransactionOldData (n :: NetworkDiscriminant)
[$sel:payments:PostTransactionOldData] :: PostTransactionOldData (n :: NetworkDiscriminant) -> !NonEmpty (ApiTxOutput n)
[$sel:passphrase:PostTransactionOldData] :: PostTransactionOldData (n :: NetworkDiscriminant) -> !ApiT (Passphrase "lenient")
[$sel:withdrawal:PostTransactionOldData] :: PostTransactionOldData (n :: NetworkDiscriminant) -> !Maybe ApiWithdrawalPostData
[$sel:metadata:PostTransactionOldData] :: PostTransactionOldData (n :: NetworkDiscriminant) -> !Maybe TxMetadataWithSchema
[$sel:timeToLive:PostTransactionOldData] :: PostTransactionOldData (n :: NetworkDiscriminant) -> !Maybe (Quantity "second" NominalDiffTime)

-- | Legacy transaction API.
data PostTransactionFeeOldData (n :: NetworkDiscriminant)
PostTransactionFeeOldData :: !NonEmpty (ApiTxOutput n) -> !Maybe ApiWithdrawalPostData -> !Maybe TxMetadataWithSchema -> !Maybe (Quantity "second" NominalDiffTime) -> PostTransactionFeeOldData (n :: NetworkDiscriminant)
[$sel:payments:PostTransactionFeeOldData] :: PostTransactionFeeOldData (n :: NetworkDiscriminant) -> !NonEmpty (ApiTxOutput n)
[$sel:withdrawal:PostTransactionFeeOldData] :: PostTransactionFeeOldData (n :: NetworkDiscriminant) -> !Maybe ApiWithdrawalPostData
[$sel:metadata:PostTransactionFeeOldData] :: PostTransactionFeeOldData (n :: NetworkDiscriminant) -> !Maybe TxMetadataWithSchema
[$sel:timeToLive:PostTransactionFeeOldData] :: PostTransactionFeeOldData (n :: NetworkDiscriminant) -> !Maybe (Quantity "second" NominalDiffTime)
newtype ApiSerialisedTransaction
ApiSerialisedTransaction :: ApiT SealedTx -> ApiSerialisedTransaction
[$sel:transaction:ApiSerialisedTransaction] :: ApiSerialisedTransaction -> ApiT SealedTx
data ApiTransaction (n :: NetworkDiscriminant)
ApiTransaction :: !ApiT (Hash "Tx") -> !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> !Maybe ApiBlockReference -> !Maybe ApiBlockReference -> !Maybe ApiSlotReference -> !Maybe (Quantity "block" Natural) -> !ApiT Direction -> ![ApiTxInput n] -> ![ApiTxOutput n] -> ![ApiTxCollateral n] -> !ApiAsArray "collateral_outputs" (Maybe (ApiTxOutput n)) -> ![ApiWithdrawal n] -> !ApiT TxStatus -> !Maybe TxMetadataWithSchema -> !Maybe (ApiT TxScriptValidity) -> ApiTransaction (n :: NetworkDiscriminant)
[$sel:id:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !ApiT (Hash "Tx")
[$sel:amount:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:fee:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:depositTaken:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:depositReturned:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:insertedAt:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !Maybe ApiBlockReference
[$sel:pendingSince:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !Maybe ApiBlockReference
[$sel:expiresAt:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !Maybe ApiSlotReference
[$sel:depth:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !Maybe (Quantity "block" Natural)
[$sel:direction:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !ApiT Direction
[$sel:inputs:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> ![ApiTxInput n]
[$sel:outputs:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> ![ApiTxOutput n]
[$sel:collateral:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> ![ApiTxCollateral n]
[$sel:collateralOutputs:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !ApiAsArray "collateral_outputs" (Maybe (ApiTxOutput n))
[$sel:withdrawals:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> ![ApiWithdrawal n]
[$sel:status:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !ApiT TxStatus
[$sel:metadata:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !Maybe TxMetadataWithSchema
[$sel:scriptValidity:ApiTransaction] :: ApiTransaction (n :: NetworkDiscriminant) -> !Maybe (ApiT TxScriptValidity)
data ApiWithdrawalPostData
SelfWithdrawal :: ApiWithdrawalPostData
ExternalWithdrawal :: ApiMnemonicT '[15, 18, 21, 24] -> ApiWithdrawalPostData
newtype ApiMaintenanceAction
ApiMaintenanceAction :: ApiT PoolMetadataGCStatus -> ApiMaintenanceAction
[$sel:gcStakePools:ApiMaintenanceAction] :: ApiMaintenanceAction -> ApiT PoolMetadataGCStatus
newtype ApiMaintenanceActionPostData
ApiMaintenanceActionPostData :: MaintenanceAction -> ApiMaintenanceActionPostData
[$sel:maintenanceAction:ApiMaintenanceActionPostData] :: ApiMaintenanceActionPostData -> MaintenanceAction
data MaintenanceAction
GcStakePools :: MaintenanceAction
data ApiFee
ApiFee :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> ![Quantity "lovelace" Natural] -> !Quantity "lovelace" Natural -> ApiFee
[$sel:estimatedMin:ApiFee] :: ApiFee -> !Quantity "lovelace" Natural
[$sel:estimatedMax:ApiFee] :: ApiFee -> !Quantity "lovelace" Natural
[$sel:minimumCoins:ApiFee] :: ApiFee -> ![Quantity "lovelace" Natural]
[$sel:deposit:ApiFee] :: ApiFee -> !Quantity "lovelace" Natural
data ApiTxCollateral (n :: NetworkDiscriminant)
ApiTxCollateral :: !Maybe (AddressAmountNoAssets (ApiT Address, Proxy n)) -> !ApiT TxIn -> ApiTxCollateral (n :: NetworkDiscriminant)
[$sel:source:ApiTxCollateral] :: ApiTxCollateral (n :: NetworkDiscriminant) -> !Maybe (AddressAmountNoAssets (ApiT Address, Proxy n))
[$sel:input:ApiTxCollateral] :: ApiTxCollateral (n :: NetworkDiscriminant) -> !ApiT TxIn
newtype ApiTxId
ApiTxId :: ApiT (Hash "Tx") -> ApiTxId
[$sel:id:ApiTxId] :: ApiTxId -> ApiT (Hash "Tx")
data ApiTxInput (n :: NetworkDiscriminant)
ApiTxInput :: !Maybe (ApiTxOutput n) -> !ApiT TxIn -> ApiTxInput (n :: NetworkDiscriminant)
[$sel:source:ApiTxInput] :: ApiTxInput (n :: NetworkDiscriminant) -> !Maybe (ApiTxOutput n)
[$sel:input:ApiTxInput] :: ApiTxInput (n :: NetworkDiscriminant) -> !ApiT TxIn
newtype ApiTxMetadata
ApiTxMetadata :: Maybe (ApiT TxMetadata) -> ApiTxMetadata
[$sel:getApiTxMetadata:ApiTxMetadata] :: ApiTxMetadata -> Maybe (ApiT TxMetadata)
data AddressAmount addr
AddressAmount :: !addr -> !Quantity "lovelace" Natural -> !ApiT TokenMap -> AddressAmount addr
[$sel:address:AddressAmount] :: AddressAmount addr -> !addr
[$sel:amount:AddressAmount] :: AddressAmount addr -> !Quantity "lovelace" Natural
[$sel:assets:AddressAmount] :: AddressAmount addr -> !ApiT TokenMap
data AddressAmountNoAssets addr
AddressAmountNoAssets :: !addr -> !Quantity "lovelace" Natural -> AddressAmountNoAssets addr
[$sel:address:AddressAmountNoAssets] :: AddressAmountNoAssets addr -> !addr
[$sel:amount:AddressAmountNoAssets] :: AddressAmountNoAssets addr -> !Quantity "lovelace" Natural
newtype ApiAddressInspect
ApiAddressInspect :: Value -> ApiAddressInspect
[$sel:unApiAddressInspect:ApiAddressInspect] :: ApiAddressInspect -> Value
newtype ApiAddressInspectData
ApiAddressInspectData :: Text -> ApiAddressInspectData
[$sel:unApiAddressInspectData:ApiAddressInspectData] :: ApiAddressInspectData -> Text

-- | Error codes returned by the API, in the form of snake_cased strings
data ApiErrorCode
AddressAlreadyExists :: ApiErrorCode
AlreadyWithdrawing :: ApiErrorCode
AssetNameTooLong :: ApiErrorCode
AssetNotPresent :: ApiErrorCode
BadRequest :: ApiErrorCode
BalanceTxByronNotSupported :: ApiErrorCode
BalanceTxConflictingNetworks :: ApiErrorCode
BalanceTxExistingCollateral :: ApiErrorCode
BalanceTxExistingKeyWitnesses :: ApiErrorCode
BalanceTxExistingReturnCollateral :: ApiErrorCode
BalanceTxExistingTotalCollateral :: ApiErrorCode
BalanceTxInternalError :: ApiErrorCode
BalanceTxMaxSizeLimitExceeded :: ApiErrorCode
BalanceTxUnderestimatedFee :: ApiErrorCode
BalanceTxZeroAdaOutput :: ApiErrorCode
CannotCoverFee :: ApiErrorCode
CreatedInvalidTransaction :: ApiErrorCode
CreatedMultiaccountTransaction :: ApiErrorCode
CreatedMultidelegationTransaction :: ApiErrorCode
CreatedWrongPolicyScriptTemplate :: ApiErrorCode
ExistingKeyWitnesses :: ApiErrorCode
ForeignTransaction :: ApiErrorCode
HardenedDerivationRequired :: ApiErrorCode
InputsDepleted :: ApiErrorCode
InsufficientCollateral :: ApiErrorCode
InvalidCoinSelection :: ApiErrorCode
InvalidWalletType :: ApiErrorCode
InvalidValidityBounds :: ApiErrorCode
KeyNotFoundForAddress :: ApiErrorCode
MalformedTxPayload :: ApiErrorCode
MethodNotAllowed :: ApiErrorCode
MinWithdrawalWrong :: ApiErrorCode
MintOrBurnAssetQuantityOutOfBounds :: ApiErrorCode
MissingPolicyPublicKey :: ApiErrorCode
MissingWitnessesInTransaction :: ApiErrorCode
NetworkMisconfigured :: ApiErrorCode
NetworkQueryFailed :: ApiErrorCode
NetworkUnreachable :: ApiErrorCode
NoRootKey :: ApiErrorCode
NoSuchPool :: ApiErrorCode
NoSuchTransaction :: ApiErrorCode
NoSuchWallet :: ApiErrorCode
NonNullRewards :: ApiErrorCode
NotAcceptable :: ApiErrorCode
NotDelegatingTo :: ApiErrorCode
NotEnoughMoney :: ApiErrorCode
NotFound :: ApiErrorCode
NotImplemented :: ApiErrorCode
NotSynced :: ApiErrorCode
NothingToMigrate :: ApiErrorCode
OutputTokenBundleSizeExceedsLimit :: ApiErrorCode
OutputTokenQuantityExceedsLimit :: ApiErrorCode
PastHorizon :: ApiErrorCode
PoolAlreadyJoined :: ApiErrorCode
QueryParamMissing :: ApiErrorCode
RedeemerInvalidData :: ApiErrorCode
RedeemerScriptFailure :: ApiErrorCode
RedeemerTargetNotFound :: ApiErrorCode
RejectedByCoreNode :: ApiErrorCode
SharedWalletCannotUpdateKey :: ApiErrorCode
SharedWalletKeyAlreadyExists :: ApiErrorCode
SharedWalletNoDelegationTemplate :: ApiErrorCode
SharedWalletNoSuchCosigner :: ApiErrorCode
SharedWalletNotPending :: ApiErrorCode
SharedWalletPending :: ApiErrorCode
SharedWalletScriptTemplateInvalid :: ApiErrorCode
SoftDerivationRequired :: ApiErrorCode
StartTimeLaterThanEndTime :: ApiErrorCode
TokensMintedButNotSpentOrBurned :: ApiErrorCode
TransactionAlreadyBalanced :: ApiErrorCode
TransactionAlreadyInLedger :: ApiErrorCode
TransactionIsTooBig :: ApiErrorCode
TranslationError :: ApiErrorCode
UnableToAssignInputOutput :: ApiErrorCode
UnableToDetermineCurrentEpoch :: ApiErrorCode
UnexpectedError :: ApiErrorCode
UnresolvedInputs :: ApiErrorCode
UnsupportedMediaType :: ApiErrorCode
UtxoTooSmall :: ApiErrorCode
WalletAlreadyExists :: ApiErrorCode
WalletNotResponding :: ApiErrorCode
WithdrawalNotWorth :: ApiErrorCode
WrongEncryptionPassphrase :: ApiErrorCode
WrongMnemonic :: ApiErrorCode
ValidityIntervalNotInsideScriptTimelock :: ApiErrorCode
data ApiNetworkInformation
ApiNetworkInformation :: !ApiT SyncProgress -> !Maybe ApiEpochInfo -> !ApiBlockReference -> !Maybe ApiSlotReference -> !ApiEra -> !ApiNetworkInfo -> !ApiWalletMode -> ApiNetworkInformation
[$sel:syncProgress:ApiNetworkInformation] :: ApiNetworkInformation -> !ApiT SyncProgress
[$sel:nextEpoch:ApiNetworkInformation] :: ApiNetworkInformation -> !Maybe ApiEpochInfo
[$sel:nodeTip:ApiNetworkInformation] :: ApiNetworkInformation -> !ApiBlockReference
[$sel:networkTip:ApiNetworkInformation] :: ApiNetworkInformation -> !Maybe ApiSlotReference
[$sel:nodeEra:ApiNetworkInformation] :: ApiNetworkInformation -> !ApiEra
[$sel:networkInfo:ApiNetworkInformation] :: ApiNetworkInformation -> !ApiNetworkInfo
[$sel:walletMode:ApiNetworkInformation] :: ApiNetworkInformation -> !ApiWalletMode
data ApiEra
ApiByron :: ApiEra
ApiShelley :: ApiEra
ApiAllegra :: ApiEra
ApiMary :: ApiEra
ApiAlonzo :: ApiEra
ApiBabbage :: ApiEra
toApiEra :: AnyCardanoEra -> ApiEra
fromApiEra :: ApiEra -> AnyCardanoEra
data ApiNtpStatus
ApiNtpStatus :: !NtpSyncingStatus -> !Maybe (Quantity "microsecond" Integer) -> ApiNtpStatus
[$sel:status:ApiNtpStatus] :: ApiNtpStatus -> !NtpSyncingStatus
[$sel:offset:ApiNtpStatus] :: ApiNtpStatus -> !Maybe (Quantity "microsecond" Integer)
data NtpSyncingStatus
NtpSyncingStatusUnavailable :: NtpSyncingStatus
NtpSyncingStatusPending :: NtpSyncingStatus
NtpSyncingStatusAvailable :: NtpSyncingStatus
newtype ApiNetworkClock
ApiNetworkClock :: ApiNtpStatus -> ApiNetworkClock
[$sel:ntpStatus:ApiNetworkClock] :: ApiNetworkClock -> ApiNtpStatus
data ApiSlotReference
ApiSlotReference :: !ApiT SlotNo -> !ApiSlotId -> !UTCTime -> ApiSlotReference
[$sel:absoluteSlotNumber:ApiSlotReference] :: ApiSlotReference -> !ApiT SlotNo
[$sel:slotId:ApiSlotReference] :: ApiSlotReference -> !ApiSlotId
[$sel:time:ApiSlotReference] :: ApiSlotReference -> !UTCTime
data ApiSlotId
ApiSlotId :: !ApiT EpochNo -> !ApiT SlotInEpoch -> ApiSlotId
[$sel:epochNumber:ApiSlotId] :: ApiSlotId -> !ApiT EpochNo
[$sel:slotNumber:ApiSlotId] :: ApiSlotId -> !ApiT SlotInEpoch
data ApiBlockReference
ApiBlockReference :: !ApiT SlotNo -> !ApiSlotId -> !UTCTime -> !ApiBlockInfo -> ApiBlockReference
[$sel:absoluteSlotNumber:ApiBlockReference] :: ApiBlockReference -> !ApiT SlotNo
[$sel:slotId:ApiBlockReference] :: ApiBlockReference -> !ApiSlotId
[$sel:time:ApiBlockReference] :: ApiBlockReference -> !UTCTime
[$sel:block:ApiBlockReference] :: ApiBlockReference -> !ApiBlockInfo
newtype ApiBlockInfo
ApiBlockInfo :: Quantity "block" Natural -> ApiBlockInfo
[$sel:height:ApiBlockInfo] :: ApiBlockInfo -> Quantity "block" Natural

-- | Collection of stake keys associated with a wallet.
data ApiStakeKeys (n :: NetworkDiscriminant)
ApiStakeKeys :: ![ApiOurStakeKey n] -> ![ApiForeignStakeKey n] -> !ApiNullStakeKey -> ApiStakeKeys (n :: NetworkDiscriminant)
[$sel:_ours:ApiStakeKeys] :: ApiStakeKeys (n :: NetworkDiscriminant) -> ![ApiOurStakeKey n]
[$sel:_foreign:ApiStakeKeys] :: ApiStakeKeys (n :: NetworkDiscriminant) -> ![ApiForeignStakeKey n]
[$sel:_none:ApiStakeKeys] :: ApiStakeKeys (n :: NetworkDiscriminant) -> !ApiNullStakeKey

-- | A stake key belonging to the current wallet.
data ApiOurStakeKey (n :: NetworkDiscriminant)
ApiOurStakeKey :: !Natural -> !(ApiT RewardAccount, Proxy n) -> !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> !ApiWalletDelegation -> ApiOurStakeKey (n :: NetworkDiscriminant)
[$sel:_index:ApiOurStakeKey] :: ApiOurStakeKey (n :: NetworkDiscriminant) -> !Natural
[$sel:_key:ApiOurStakeKey] :: ApiOurStakeKey (n :: NetworkDiscriminant) -> !(ApiT RewardAccount, Proxy n)

-- | The total ada this stake key controls / is associated with. This also
--   includes the reward balance.
[$sel:_stake:ApiOurStakeKey] :: ApiOurStakeKey (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural

-- | The current reward balance (not lifetime).
[$sel:_rewardBalance:ApiOurStakeKey] :: ApiOurStakeKey (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural

-- | The delegation of this stake key
[$sel:_delegation:ApiOurStakeKey] :: ApiOurStakeKey (n :: NetworkDiscriminant) -> !ApiWalletDelegation

-- | A stake key found in the wallet UTxO, but which isn't ours.
--   
--   We <i>could</i> provide the current delegation status for foreign
--   stake keys.
data ApiForeignStakeKey (n :: NetworkDiscriminant)
ApiForeignStakeKey :: !(ApiT RewardAccount, Proxy n) -> !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> ApiForeignStakeKey (n :: NetworkDiscriminant)
[$sel:_key:ApiForeignStakeKey] :: ApiForeignStakeKey (n :: NetworkDiscriminant) -> !(ApiT RewardAccount, Proxy n)

-- | The total ada this stake key controls / is associated with. This also
--   includes the reward balance.
[$sel:_stake:ApiForeignStakeKey] :: ApiForeignStakeKey (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural

-- | The current reward balance (not lifetime).
[$sel:_rewardBalance:ApiForeignStakeKey] :: ApiForeignStakeKey (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural

-- | For describing how much stake is associated with no stake key.
newtype ApiNullStakeKey
ApiNullStakeKey :: Quantity "lovelace" Natural -> ApiNullStakeKey

-- | The total stake of the wallet UTxO that is not associated with a stake
--   key, because it's part of an enterprise address.
[$sel:_stake:ApiNullStakeKey] :: ApiNullStakeKey -> Quantity "lovelace" Natural

-- | Defines a point in time that can be formatted as and parsed from an
--   ISO 8601-compliant string.
newtype Iso8601Time
Iso8601Time :: UTCTime -> Iso8601Time
[$sel:getIso8601Time:Iso8601Time] :: Iso8601Time -> UTCTime
newtype MinWithdrawal
MinWithdrawal :: Natural -> MinWithdrawal
[$sel:getMinWithdrawal:MinWithdrawal] :: MinWithdrawal -> Natural
data ApiNetworkParameters
ApiNetworkParameters :: !ApiT (Hash "Genesis") -> !ApiT StartTime -> !Quantity "second" NominalDiffTime -> !Quantity "slot" Word32 -> !Quantity "block" Word32 -> !Quantity "percent" Double -> !Quantity "percent" Percentage -> !Word16 -> !Quantity "lovelace" Natural -> !Quantity "byte" Natural -> !ApiEraInfo -> !Word16 -> !Natural -> !Maybe ExecutionUnitPrices -> ApiNetworkParameters
[$sel:genesisBlockHash:ApiNetworkParameters] :: ApiNetworkParameters -> !ApiT (Hash "Genesis")
[$sel:blockchainStartTime:ApiNetworkParameters] :: ApiNetworkParameters -> !ApiT StartTime
[$sel:slotLength:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "second" NominalDiffTime
[$sel:epochLength:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "slot" Word32
[$sel:securityParameter:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "block" Word32
[$sel:activeSlotCoefficient:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "percent" Double
[$sel:decentralizationLevel:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "percent" Percentage
[$sel:desiredPoolNumber:ApiNetworkParameters] :: ApiNetworkParameters -> !Word16
[$sel:minimumUtxoValue:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "lovelace" Natural
[$sel:maximumTokenBundleSize:ApiNetworkParameters] :: ApiNetworkParameters -> !Quantity "byte" Natural
[$sel:eras:ApiNetworkParameters] :: ApiNetworkParameters -> !ApiEraInfo
[$sel:maximumCollateralInputCount:ApiNetworkParameters] :: ApiNetworkParameters -> !Word16
[$sel:minimumCollateralPercentage:ApiNetworkParameters] :: ApiNetworkParameters -> !Natural
[$sel:executionUnitPrices:ApiNetworkParameters] :: ApiNetworkParameters -> !Maybe ExecutionUnitPrices
data ApiNetworkInfo
ApiNetworkInfo :: !Text -> !Integer -> ApiNetworkInfo
[$sel:networkId:ApiNetworkInfo] :: ApiNetworkInfo -> !Text
[$sel:protocolMagic:ApiNetworkInfo] :: ApiNetworkInfo -> !Integer
toApiNetworkParameters :: Monad m => NetworkParameters -> TxConstraints -> (EpochNo -> m ApiEpochInfo) -> m ApiNetworkParameters
data ApiEraInfo
ApiEraInfo :: !Maybe ApiEpochInfo -> !Maybe ApiEpochInfo -> !Maybe ApiEpochInfo -> !Maybe ApiEpochInfo -> !Maybe ApiEpochInfo -> !Maybe ApiEpochInfo -> ApiEraInfo
[$sel:byron:ApiEraInfo] :: ApiEraInfo -> !Maybe ApiEpochInfo
[$sel:shelley:ApiEraInfo] :: ApiEraInfo -> !Maybe ApiEpochInfo
[$sel:allegra:ApiEraInfo] :: ApiEraInfo -> !Maybe ApiEpochInfo
[$sel:mary:ApiEraInfo] :: ApiEraInfo -> !Maybe ApiEpochInfo
[$sel:alonzo:ApiEraInfo] :: ApiEraInfo -> !Maybe ApiEpochInfo
[$sel:babbage:ApiEraInfo] :: ApiEraInfo -> !Maybe ApiEpochInfo
data ApiWalletDelegation
ApiWalletDelegation :: !ApiWalletDelegationNext -> ![ApiWalletDelegationNext] -> ApiWalletDelegation
[$sel:active:ApiWalletDelegation] :: ApiWalletDelegation -> !ApiWalletDelegationNext
[$sel:next:ApiWalletDelegation] :: ApiWalletDelegation -> ![ApiWalletDelegationNext]
data ApiWalletDelegationStatus
NotDelegating :: ApiWalletDelegationStatus
Delegating :: ApiWalletDelegationStatus
data ApiWalletDelegationNext
ApiWalletDelegationNext :: !ApiWalletDelegationStatus -> !Maybe (ApiT PoolId) -> !Maybe ApiEpochInfo -> ApiWalletDelegationNext
[$sel:status:ApiWalletDelegationNext] :: ApiWalletDelegationNext -> !ApiWalletDelegationStatus
[$sel:target:ApiWalletDelegationNext] :: ApiWalletDelegationNext -> !Maybe (ApiT PoolId)
[$sel:changesAt:ApiWalletDelegationNext] :: ApiWalletDelegationNext -> !Maybe ApiEpochInfo
data ApiPoolId
ApiPoolIdPlaceholder :: ApiPoolId
ApiPoolId :: PoolId -> ApiPoolId
newtype ApiWalletMigrationPlanPostData (n :: NetworkDiscriminant)
ApiWalletMigrationPlanPostData :: NonEmpty (ApiT Address, Proxy n) -> ApiWalletMigrationPlanPostData (n :: NetworkDiscriminant)
[$sel:addresses:ApiWalletMigrationPlanPostData] :: ApiWalletMigrationPlanPostData (n :: NetworkDiscriminant) -> NonEmpty (ApiT Address, Proxy n)
data ApiWalletMigrationPostData (n :: NetworkDiscriminant) (s :: Symbol)
ApiWalletMigrationPostData :: !ApiT (Passphrase s) -> !NonEmpty (ApiT Address, Proxy n) -> ApiWalletMigrationPostData (n :: NetworkDiscriminant) (s :: Symbol)
[$sel:passphrase:ApiWalletMigrationPostData] :: ApiWalletMigrationPostData (n :: NetworkDiscriminant) (s :: Symbol) -> !ApiT (Passphrase s)
[$sel:addresses:ApiWalletMigrationPostData] :: ApiWalletMigrationPostData (n :: NetworkDiscriminant) (s :: Symbol) -> !NonEmpty (ApiT Address, Proxy n)
data ApiWalletMigrationBalance
ApiWalletMigrationBalance :: !Quantity "lovelace" Natural -> !ApiT TokenMap -> ApiWalletMigrationBalance
[$sel:ada:ApiWalletMigrationBalance] :: ApiWalletMigrationBalance -> !Quantity "lovelace" Natural
[$sel:assets:ApiWalletMigrationBalance] :: ApiWalletMigrationBalance -> !ApiT TokenMap
data ApiWalletMigrationPlan (n :: NetworkDiscriminant)
ApiWalletMigrationPlan :: !NonEmpty (ApiCoinSelection n) -> Quantity "lovelace" Natural -> ApiWalletMigrationBalance -> ApiWalletMigrationBalance -> ApiWalletMigrationPlan (n :: NetworkDiscriminant)
[$sel:selections:ApiWalletMigrationPlan] :: ApiWalletMigrationPlan (n :: NetworkDiscriminant) -> !NonEmpty (ApiCoinSelection n)
[$sel:totalFee:ApiWalletMigrationPlan] :: ApiWalletMigrationPlan (n :: NetworkDiscriminant) -> Quantity "lovelace" Natural
[$sel:balanceLeftover:ApiWalletMigrationPlan] :: ApiWalletMigrationPlan (n :: NetworkDiscriminant) -> ApiWalletMigrationBalance
[$sel:balanceSelected:ApiWalletMigrationPlan] :: ApiWalletMigrationPlan (n :: NetworkDiscriminant) -> ApiWalletMigrationBalance
data ApiWithdrawal n
ApiWithdrawal :: !(ApiT RewardAccount, Proxy n) -> !Quantity "lovelace" Natural -> ApiWithdrawal n
[$sel:stakeAddress:ApiWithdrawal] :: ApiWithdrawal n -> !(ApiT RewardAccount, Proxy n)
[$sel:amount:ApiWithdrawal] :: ApiWithdrawal n -> !Quantity "lovelace" Natural
data ApiWalletSignData
ApiWalletSignData :: ApiT TxMetadata -> ApiT (Passphrase "lenient") -> ApiWalletSignData
[$sel:metadata:ApiWalletSignData] :: ApiWalletSignData -> ApiT TxMetadata
[$sel:passphrase:ApiWalletSignData] :: ApiWalletSignData -> ApiT (Passphrase "lenient")
data ApiVerificationKeyShelley
ApiVerificationKeyShelley :: (ByteString, Role) -> VerificationKeyHashing -> ApiVerificationKeyShelley
[$sel:getApiVerificationKey:ApiVerificationKeyShelley] :: ApiVerificationKeyShelley -> (ByteString, Role)
[$sel:hashed:ApiVerificationKeyShelley] :: ApiVerificationKeyShelley -> VerificationKeyHashing
data ApiPolicyKey
ApiPolicyKey :: ByteString -> VerificationKeyHashing -> ApiPolicyKey
[$sel:getApiPolicyKey:ApiPolicyKey] :: ApiPolicyKey -> ByteString
[$sel:hashed:ApiPolicyKey] :: ApiPolicyKey -> VerificationKeyHashing
newtype ApiPolicyId
ApiPolicyId :: ApiT TokenPolicyId -> ApiPolicyId
[$sel:policyId:ApiPolicyId] :: ApiPolicyId -> ApiT TokenPolicyId
newtype ApiPostPolicyIdData
ApiPostPolicyIdData :: ApiT (Script Cosigner) -> ApiPostPolicyIdData
[$sel:policyScriptTemplate:ApiPostPolicyIdData] :: ApiPostPolicyIdData -> ApiT (Script Cosigner)
newtype ApiPostPolicyKeyData
ApiPostPolicyKeyData :: ApiT (Passphrase "user") -> ApiPostPolicyKeyData
[$sel:passphrase:ApiPostPolicyKeyData] :: ApiPostPolicyKeyData -> ApiT (Passphrase "user")
data ApiVerificationKeyShared
ApiVerificationKeyShared :: (ByteString, Role) -> VerificationKeyHashing -> ApiVerificationKeyShared
[$sel:getApiVerificationKey:ApiVerificationKeyShared] :: ApiVerificationKeyShared -> (ByteString, Role)
[$sel:hashed:ApiVerificationKeyShared] :: ApiVerificationKeyShared -> VerificationKeyHashing
data ApiScriptTemplateEntry
ApiScriptTemplateEntry :: Map Cosigner XPubOrSelf -> Script Cosigner -> ApiScriptTemplateEntry
[$sel:cosigners:ApiScriptTemplateEntry] :: ApiScriptTemplateEntry -> Map Cosigner XPubOrSelf
[$sel:template:ApiScriptTemplateEntry] :: ApiScriptTemplateEntry -> Script Cosigner
data XPubOrSelf
SomeAccountKey :: XPub -> XPubOrSelf
Self :: XPubOrSelf
data VerificationKeyHashing
WithHashing :: VerificationKeyHashing
WithoutHashing :: VerificationKeyHashing
data ApiAccountKey
ApiAccountKey :: ByteString -> KeyFormat -> Index 'Hardened 'PurposeK -> ApiAccountKey
[$sel:getApiAccountKey:ApiAccountKey] :: ApiAccountKey -> ByteString
[$sel:format:ApiAccountKey] :: ApiAccountKey -> KeyFormat
[$sel:purpose:ApiAccountKey] :: ApiAccountKey -> Index 'Hardened 'PurposeK
data ApiAccountKeyShared
ApiAccountKeyShared :: ByteString -> KeyFormat -> Index 'Hardened 'PurposeK -> ApiAccountKeyShared
[$sel:getApiAccountKey:ApiAccountKeyShared] :: ApiAccountKeyShared -> ByteString
[$sel:format:ApiAccountKeyShared] :: ApiAccountKeyShared -> KeyFormat
[$sel:purpose:ApiAccountKeyShared] :: ApiAccountKeyShared -> Index 'Hardened 'PurposeK
data KeyFormat
Extended :: KeyFormat
NonExtended :: KeyFormat
data ApiPostAccountKeyData
ApiPostAccountKeyData :: ApiT (Passphrase "user") -> KeyFormat -> ApiPostAccountKeyData
[$sel:passphrase:ApiPostAccountKeyData] :: ApiPostAccountKeyData -> ApiT (Passphrase "user")
[$sel:format:ApiPostAccountKeyData] :: ApiPostAccountKeyData -> KeyFormat
data ApiPostAccountKeyDataWithPurpose
ApiPostAccountKeyDataWithPurpose :: ApiT (Passphrase "user") -> KeyFormat -> Maybe (ApiT DerivationIndex) -> ApiPostAccountKeyDataWithPurpose
[$sel:passphrase:ApiPostAccountKeyDataWithPurpose] :: ApiPostAccountKeyDataWithPurpose -> ApiT (Passphrase "user")
[$sel:format:ApiPostAccountKeyDataWithPurpose] :: ApiPostAccountKeyDataWithPurpose -> KeyFormat
[$sel:purpose:ApiPostAccountKeyDataWithPurpose] :: ApiPostAccountKeyDataWithPurpose -> Maybe (ApiT DerivationIndex)
data ApiConstructTransaction (n :: NetworkDiscriminant)
ApiConstructTransaction :: !ApiT SealedTx -> !ApiCoinSelection n -> !Quantity "lovelace" Natural -> ApiConstructTransaction (n :: NetworkDiscriminant)
[$sel:transaction:ApiConstructTransaction] :: ApiConstructTransaction (n :: NetworkDiscriminant) -> !ApiT SealedTx
[$sel:coinSelection:ApiConstructTransaction] :: ApiConstructTransaction (n :: NetworkDiscriminant) -> !ApiCoinSelection n
[$sel:fee:ApiConstructTransaction] :: ApiConstructTransaction (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural

-- | Input parameters for transaction construction.
data ApiConstructTransactionData (n :: NetworkDiscriminant)
ApiConstructTransactionData :: !Maybe (ApiPaymentDestination n) -> !Maybe ApiWithdrawalPostData -> !Maybe TxMetadataWithSchema -> !Maybe (NonEmpty (ApiMintBurnData n)) -> !Maybe (NonEmpty ApiMultiDelegationAction) -> !Maybe ApiValidityInterval -> ApiConstructTransactionData (n :: NetworkDiscriminant)
[$sel:payments:ApiConstructTransactionData] :: ApiConstructTransactionData (n :: NetworkDiscriminant) -> !Maybe (ApiPaymentDestination n)
[$sel:withdrawal:ApiConstructTransactionData] :: ApiConstructTransactionData (n :: NetworkDiscriminant) -> !Maybe ApiWithdrawalPostData
[$sel:metadata:ApiConstructTransactionData] :: ApiConstructTransactionData (n :: NetworkDiscriminant) -> !Maybe TxMetadataWithSchema
[$sel:mintBurn:ApiConstructTransactionData] :: ApiConstructTransactionData (n :: NetworkDiscriminant) -> !Maybe (NonEmpty (ApiMintBurnData n))
[$sel:delegations:ApiConstructTransactionData] :: ApiConstructTransactionData (n :: NetworkDiscriminant) -> !Maybe (NonEmpty ApiMultiDelegationAction)
[$sel:validityInterval:ApiConstructTransactionData] :: ApiConstructTransactionData (n :: NetworkDiscriminant) -> !Maybe ApiValidityInterval

-- | Stake pool delegation certificates.
data ApiMultiDelegationAction

-- | Delegate given staking index to a pool, possibly registering the stake
--   key at the same time.
Joining :: !ApiT PoolId -> !ApiStakeKeyIndex -> ApiMultiDelegationAction

-- | Undelegate the given staking index from its pool.
Leaving :: !ApiStakeKeyIndex -> ApiMultiDelegationAction

-- | Index of the stake key.
newtype ApiStakeKeyIndex
ApiStakeKeyIndex :: ApiT DerivationIndex -> ApiStakeKeyIndex
data ApiPaymentDestination (n :: NetworkDiscriminant)

-- | Pay amounts to one or more addresses.
ApiPaymentAddresses :: !NonEmpty (AddressAmount (ApiAddressIdT n)) -> ApiPaymentDestination (n :: NetworkDiscriminant)

-- | Migrate all money to one or more addresses.
ApiPaymentAll :: !NonEmpty (ApiT Address, Proxy n) -> ApiPaymentDestination (n :: NetworkDiscriminant)

-- | Times where transactions are valid.
data ApiValidityInterval
ApiValidityInterval :: !Maybe ApiValidityBound -> !Maybe ApiValidityBound -> ApiValidityInterval

-- | Tx is not valid before this time. Defaults to genesis.
[$sel:invalidBefore:ApiValidityInterval] :: ApiValidityInterval -> !Maybe ApiValidityBound

-- | Tx is not valid at this time and after. Defaults to now + 2 hours.
[$sel:invalidHereafter:ApiValidityInterval] :: ApiValidityInterval -> !Maybe ApiValidityBound

-- | One side of the validity interval.
data ApiValidityBound

-- | Use the default.
ApiValidityBoundUnspecified :: ApiValidityBound

-- | Time from transaction construction (not submission).
ApiValidityBoundAsTimeFromNow :: !Quantity "second" NominalDiffTime -> ApiValidityBound

-- | Absolute slot number.
ApiValidityBoundAsSlot :: !Quantity "slot" Word64 -> ApiValidityBound
data ApiBalanceTransactionPostData (n :: NetworkDiscriminant)
ApiBalanceTransactionPostData :: !ApiT SealedTx -> ![ApiExternalInput n] -> ![ApiRedeemer n] -> ApiBalanceTransactionPostData (n :: NetworkDiscriminant)
[$sel:transaction:ApiBalanceTransactionPostData] :: ApiBalanceTransactionPostData (n :: NetworkDiscriminant) -> !ApiT SealedTx
[$sel:inputs:ApiBalanceTransactionPostData] :: ApiBalanceTransactionPostData (n :: NetworkDiscriminant) -> ![ApiExternalInput n]
[$sel:redeemers:ApiBalanceTransactionPostData] :: ApiBalanceTransactionPostData (n :: NetworkDiscriminant) -> ![ApiRedeemer n]
data ApiExternalInput (n :: NetworkDiscriminant)
ApiExternalInput :: !ApiT (Hash "Tx") -> !Word32 -> !(ApiT Address, Proxy n) -> !Quantity "lovelace" Natural -> !ApiT TokenMap -> !Maybe (ApiT (Hash "Datum")) -> ApiExternalInput (n :: NetworkDiscriminant)
[$sel:id:ApiExternalInput] :: ApiExternalInput (n :: NetworkDiscriminant) -> !ApiT (Hash "Tx")
[$sel:index:ApiExternalInput] :: ApiExternalInput (n :: NetworkDiscriminant) -> !Word32
[$sel:address:ApiExternalInput] :: ApiExternalInput (n :: NetworkDiscriminant) -> !(ApiT Address, Proxy n)
[$sel:amount:ApiExternalInput] :: ApiExternalInput (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:assets:ApiExternalInput] :: ApiExternalInput (n :: NetworkDiscriminant) -> !ApiT TokenMap
[$sel:datum:ApiExternalInput] :: ApiExternalInput (n :: NetworkDiscriminant) -> !Maybe (ApiT (Hash "Datum"))
data ApiRedeemer (n :: NetworkDiscriminant)
ApiRedeemerSpending :: ApiRedeemerData -> ApiT TxIn -> ApiRedeemer (n :: NetworkDiscriminant)
ApiRedeemerMinting :: ApiRedeemerData -> ApiT TokenPolicyId -> ApiRedeemer (n :: NetworkDiscriminant)
ApiRedeemerRewarding :: ApiRedeemerData -> StakeAddress -> ApiRedeemer (n :: NetworkDiscriminant)
data ApiDecodedTransaction (n :: NetworkDiscriminant)
ApiDecodedTransaction :: !ApiT (Hash "Tx") -> !Quantity "lovelace" Natural -> ![ApiTxInputGeneral n] -> ![ApiTxOutputGeneral n] -> ![ApiTxInputGeneral n] -> !ApiAsArray "collateral_outputs" (Maybe (ApiTxOutputGeneral n)) -> ![ApiWithdrawalGeneral n] -> !ApiAssetMintBurn -> !ApiAssetMintBurn -> ![ApiAnyCertificate n] -> ![Quantity "lovelace" Natural] -> ![Quantity "lovelace" Natural] -> !ApiTxMetadata -> !Maybe (ApiT TxScriptValidity) -> !Maybe ValidityIntervalExplicit -> ApiDecodedTransaction (n :: NetworkDiscriminant)
[$sel:id:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> !ApiT (Hash "Tx")
[$sel:fee:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:inputs:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> ![ApiTxInputGeneral n]
[$sel:outputs:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> ![ApiTxOutputGeneral n]
[$sel:collateral:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> ![ApiTxInputGeneral n]
[$sel:collateralOutputs:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> !ApiAsArray "collateral_outputs" (Maybe (ApiTxOutputGeneral n))
[$sel:withdrawals:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> ![ApiWithdrawalGeneral n]
[$sel:mint:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> !ApiAssetMintBurn
[$sel:burn:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> !ApiAssetMintBurn
[$sel:certificates:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> ![ApiAnyCertificate n]
[$sel:depositsTaken:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> ![Quantity "lovelace" Natural]
[$sel:depositsReturned:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> ![Quantity "lovelace" Natural]
[$sel:metadata:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> !ApiTxMetadata
[$sel:scriptValidity:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> !Maybe (ApiT TxScriptValidity)
[$sel:validityInterval:ApiDecodedTransaction] :: ApiDecodedTransaction (n :: NetworkDiscriminant) -> !Maybe ValidityIntervalExplicit
data ApiWalletInput (n :: NetworkDiscriminant)
ApiWalletInput :: !ApiT (Hash "Tx") -> !Word32 -> !(ApiT Address, Proxy n) -> NonEmpty (ApiT DerivationIndex) -> !Quantity "lovelace" Natural -> !ApiT TokenMap -> ApiWalletInput (n :: NetworkDiscriminant)
[$sel:id:ApiWalletInput] :: ApiWalletInput (n :: NetworkDiscriminant) -> !ApiT (Hash "Tx")
[$sel:index:ApiWalletInput] :: ApiWalletInput (n :: NetworkDiscriminant) -> !Word32
[$sel:address:ApiWalletInput] :: ApiWalletInput (n :: NetworkDiscriminant) -> !(ApiT Address, Proxy n)
[$sel:derivationPath:ApiWalletInput] :: ApiWalletInput (n :: NetworkDiscriminant) -> NonEmpty (ApiT DerivationIndex)
[$sel:amount:ApiWalletInput] :: ApiWalletInput (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:assets:ApiWalletInput] :: ApiWalletInput (n :: NetworkDiscriminant) -> !ApiT TokenMap
data ApiTxInputGeneral (n :: NetworkDiscriminant)
ExternalInput :: ApiT TxIn -> ApiTxInputGeneral (n :: NetworkDiscriminant)
WalletInput :: ApiWalletInput n -> ApiTxInputGeneral (n :: NetworkDiscriminant)
data ResourceContext
External :: ResourceContext
Our :: ResourceContext
data ApiWithdrawalGeneral (n :: NetworkDiscriminant)
ApiWithdrawalGeneral :: !(ApiT RewardAccount, Proxy n) -> !Quantity "lovelace" Natural -> !ResourceContext -> ApiWithdrawalGeneral (n :: NetworkDiscriminant)
[$sel:stakeAddress:ApiWithdrawalGeneral] :: ApiWithdrawalGeneral (n :: NetworkDiscriminant) -> !(ApiT RewardAccount, Proxy n)
[$sel:amount:ApiWithdrawalGeneral] :: ApiWithdrawalGeneral (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:context:ApiWithdrawalGeneral] :: ApiWithdrawalGeneral (n :: NetworkDiscriminant) -> !ResourceContext
data ApiWalletOutput (n :: NetworkDiscriminant)
ApiWalletOutput :: !(ApiT Address, Proxy n) -> !Quantity "lovelace" Natural -> !ApiT TokenMap -> NonEmpty (ApiT DerivationIndex) -> ApiWalletOutput (n :: NetworkDiscriminant)
[$sel:address:ApiWalletOutput] :: ApiWalletOutput (n :: NetworkDiscriminant) -> !(ApiT Address, Proxy n)
[$sel:amount:ApiWalletOutput] :: ApiWalletOutput (n :: NetworkDiscriminant) -> !Quantity "lovelace" Natural
[$sel:assets:ApiWalletOutput] :: ApiWalletOutput (n :: NetworkDiscriminant) -> !ApiT TokenMap
[$sel:derivationPath:ApiWalletOutput] :: ApiWalletOutput (n :: NetworkDiscriminant) -> NonEmpty (ApiT DerivationIndex)
data ApiTxOutputGeneral (n :: NetworkDiscriminant)
ExternalOutput :: ApiTxOutput n -> ApiTxOutputGeneral (n :: NetworkDiscriminant)
WalletOutput :: ApiWalletOutput n -> ApiTxOutputGeneral (n :: NetworkDiscriminant)
data ApiAnyCertificate n
WalletDelegationCertificate :: ApiCertificate -> ApiAnyCertificate n
DelegationCertificate :: ApiExternalCertificate n -> ApiAnyCertificate n
StakePoolRegister :: ApiRegisterPool -> ApiAnyCertificate n
StakePoolDeregister :: ApiDeregisterPool -> ApiAnyCertificate n
OtherCertificate :: ApiT NonWalletCertificate -> ApiAnyCertificate n
data ApiExternalCertificate (n :: NetworkDiscriminant)
RegisterRewardAccountExternal :: !(ApiT RewardAccount, Proxy n) -> ApiExternalCertificate (n :: NetworkDiscriminant)
[$sel:rewardAccount:RegisterRewardAccountExternal] :: ApiExternalCertificate (n :: NetworkDiscriminant) -> !(ApiT RewardAccount, Proxy n)
JoinPoolExternal :: !(ApiT RewardAccount, Proxy n) -> ApiT PoolId -> ApiExternalCertificate (n :: NetworkDiscriminant)
[$sel:rewardAccount:RegisterRewardAccountExternal] :: ApiExternalCertificate (n :: NetworkDiscriminant) -> !(ApiT RewardAccount, Proxy n)
[$sel:pool:RegisterRewardAccountExternal] :: ApiExternalCertificate (n :: NetworkDiscriminant) -> ApiT PoolId
QuitPoolExternal :: !(ApiT RewardAccount, Proxy n) -> ApiExternalCertificate (n :: NetworkDiscriminant)
[$sel:rewardAccount:RegisterRewardAccountExternal] :: ApiExternalCertificate (n :: NetworkDiscriminant) -> !(ApiT RewardAccount, Proxy n)
data ApiRegisterPool
ApiRegisterPool :: !ApiT PoolId -> ![ApiT PoolOwner] -> !Quantity "percent" Percentage -> !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> Maybe (ApiT StakePoolMetadataUrl, ApiT StakePoolMetadataHash) -> ApiRegisterPool
[$sel:poolId:ApiRegisterPool] :: ApiRegisterPool -> !ApiT PoolId
[$sel:poolOwners:ApiRegisterPool] :: ApiRegisterPool -> ![ApiT PoolOwner]
[$sel:poolMargin:ApiRegisterPool] :: ApiRegisterPool -> !Quantity "percent" Percentage
[$sel:poolCost:ApiRegisterPool] :: ApiRegisterPool -> !Quantity "lovelace" Natural
[$sel:poolPledge:ApiRegisterPool] :: ApiRegisterPool -> !Quantity "lovelace" Natural
[$sel:poolMetadata:ApiRegisterPool] :: ApiRegisterPool -> Maybe (ApiT StakePoolMetadataUrl, ApiT StakePoolMetadataHash)
data ApiDeregisterPool
ApiDeregisterPool :: !ApiT PoolId -> !ApiT EpochNo -> ApiDeregisterPool
[$sel:poolId:ApiDeregisterPool] :: ApiDeregisterPool -> !ApiT PoolId
[$sel:retirementEpoch:ApiDeregisterPool] :: ApiDeregisterPool -> !ApiT EpochNo
data ApiAssetMintBurn
ApiAssetMintBurn :: ![ApiTokens] -> !Maybe ApiPolicyKey -> !Maybe (ApiT DerivationIndex) -> ApiAssetMintBurn
[$sel:tokens:ApiAssetMintBurn] :: ApiAssetMintBurn -> ![ApiTokens]
[$sel:walletPolicyKeyHash:ApiAssetMintBurn] :: ApiAssetMintBurn -> !Maybe ApiPolicyKey
[$sel:walletPolicyKeyIndex:ApiAssetMintBurn] :: ApiAssetMintBurn -> !Maybe (ApiT DerivationIndex)
data ApiTokenAmountFingerprint
ApiTokenAmountFingerprint :: !ApiT TokenName -> !Natural -> !ApiT TokenFingerprint -> ApiTokenAmountFingerprint
[$sel:assetName:ApiTokenAmountFingerprint] :: ApiTokenAmountFingerprint -> !ApiT TokenName
[$sel:quantity:ApiTokenAmountFingerprint] :: ApiTokenAmountFingerprint -> !Natural
[$sel:fingerprint:ApiTokenAmountFingerprint] :: ApiTokenAmountFingerprint -> !ApiT TokenFingerprint
data ApiTokens
ApiTokens :: !ApiT TokenPolicyId -> !ApiT AnyScript -> !NonEmpty ApiTokenAmountFingerprint -> ApiTokens
[$sel:policyId:ApiTokens] :: ApiTokens -> !ApiT TokenPolicyId
[$sel:policyScript:ApiTokens] :: ApiTokens -> !ApiT AnyScript
[$sel:assets:ApiTokens] :: ApiTokens -> !NonEmpty ApiTokenAmountFingerprint
data ApiByronWallet
ApiByronWallet :: !ApiT WalletId -> !ApiByronWalletBalance -> !ApiWalletAssetsBalance -> !ApiWalletDiscovery -> !ApiT WalletName -> !Maybe ApiWalletPassphraseInfo -> !ApiT SyncProgress -> !ApiBlockReference -> ApiByronWallet
[$sel:id:ApiByronWallet] :: ApiByronWallet -> !ApiT WalletId
[$sel:balance:ApiByronWallet] :: ApiByronWallet -> !ApiByronWalletBalance
[$sel:assets:ApiByronWallet] :: ApiByronWallet -> !ApiWalletAssetsBalance
[$sel:discovery:ApiByronWallet] :: ApiByronWallet -> !ApiWalletDiscovery
[$sel:name:ApiByronWallet] :: ApiByronWallet -> !ApiT WalletName
[$sel:passphrase:ApiByronWallet] :: ApiByronWallet -> !Maybe ApiWalletPassphraseInfo
[$sel:state:ApiByronWallet] :: ApiByronWallet -> !ApiT SyncProgress
[$sel:tip:ApiByronWallet] :: ApiByronWallet -> !ApiBlockReference
data ApiByronWalletBalance
ApiByronWalletBalance :: !Quantity "lovelace" Natural -> !Quantity "lovelace" Natural -> ApiByronWalletBalance
[$sel:available:ApiByronWalletBalance] :: ApiByronWalletBalance -> !Quantity "lovelace" Natural
[$sel:total:ApiByronWalletBalance] :: ApiByronWalletBalance -> !Quantity "lovelace" Natural
data ByronWalletPostData mw
ByronWalletPostData :: !ApiMnemonicT mw -> !ApiT WalletName -> !ApiT (Passphrase "user") -> ByronWalletPostData mw
[$sel:mnemonicSentence:ByronWalletPostData] :: ByronWalletPostData mw -> !ApiMnemonicT mw
[$sel:name:ByronWalletPostData] :: ByronWalletPostData mw -> !ApiT WalletName
[$sel:passphrase:ByronWalletPostData] :: ByronWalletPostData mw -> !ApiT (Passphrase "user")
data SomeByronWalletPostData
RandomWalletFromMnemonic :: ByronWalletPostData (AllowedMnemonics 'Random) -> SomeByronWalletPostData
RandomWalletFromXPrv :: ByronWalletFromXPrvPostData -> SomeByronWalletPostData
SomeIcarusWallet :: ByronWalletPostData (AllowedMnemonics 'Icarus) -> SomeByronWalletPostData
SomeTrezorWallet :: ByronWalletPostData (AllowedMnemonics 'Trezor) -> SomeByronWalletPostData
SomeLedgerWallet :: ByronWalletPostData (AllowedMnemonics 'Ledger) -> SomeByronWalletPostData
SomeAccount :: AccountPostData -> SomeByronWalletPostData
data ByronWalletFromXPrvPostData
ByronWalletFromXPrvPostData :: !ApiT WalletName -> !ApiT XPrv -> !ApiT PassphraseHash -> ByronWalletFromXPrvPostData
[$sel:name:ByronWalletFromXPrvPostData] :: ByronWalletFromXPrvPostData -> !ApiT WalletName

-- | A root private key hex-encoded, encrypted using a given passphrase.
--   The underlying key should contain: private key, chain code, and public
--   key
[$sel:encryptedRootPrivateKey:ByronWalletFromXPrvPostData] :: ByronWalletFromXPrvPostData -> !ApiT XPrv

-- | A hash of master passphrase. The hash should be an output of a Scrypt
--   function with the following parameters: - logN = 14 - r = 8 - p = 1
[$sel:passphraseHash:ByronWalletFromXPrvPostData] :: ByronWalletFromXPrvPostData -> !ApiT PassphraseHash
data ByronWalletPutPassphraseData
ByronWalletPutPassphraseData :: !Maybe (ApiT (Passphrase "lenient")) -> !ApiT (Passphrase "user") -> ByronWalletPutPassphraseData
[$sel:oldPassphrase:ByronWalletPutPassphraseData] :: ByronWalletPutPassphraseData -> !Maybe (ApiT (Passphrase "lenient"))
[$sel:newPassphrase:ByronWalletPutPassphraseData] :: ByronWalletPutPassphraseData -> !ApiT (Passphrase "user")
data ApiPostRandomAddressData
ApiPostRandomAddressData :: !ApiT (Passphrase "lenient") -> !Maybe (ApiT (Index 'Hardened 'AddressK)) -> ApiPostRandomAddressData
[$sel:passphrase:ApiPostRandomAddressData] :: ApiPostRandomAddressData -> !ApiT (Passphrase "lenient")
[$sel:addressIndex:ApiPostRandomAddressData] :: ApiPostRandomAddressData -> !Maybe (ApiT (Index 'Hardened 'AddressK))
data ApiWalletDiscovery
DiscoveryRandom :: ApiWalletDiscovery
DiscoverySequential :: ApiWalletDiscovery
class KnownDiscovery s
knownDiscovery :: KnownDiscovery s => ApiWalletDiscovery
newtype ApiPutAddressesData (n :: NetworkDiscriminant)
ApiPutAddressesData :: [(ApiT Address, Proxy n)] -> ApiPutAddressesData (n :: NetworkDiscriminant)
[$sel:addresses:ApiPutAddressesData] :: ApiPutAddressesData (n :: NetworkDiscriminant) -> [(ApiT Address, Proxy n)]
data AccountPostData
AccountPostData :: !ApiT WalletName -> !ApiAccountPublicKey -> !Maybe (ApiT AddressPoolGap) -> AccountPostData
[$sel:name:AccountPostData] :: AccountPostData -> !ApiT WalletName
[$sel:accountPublicKey:AccountPostData] :: AccountPostData -> !ApiAccountPublicKey
[$sel:addressPoolGap:AccountPostData] :: AccountPostData -> !Maybe (ApiT AddressPoolGap)
newtype ApiAccountPublicKey
ApiAccountPublicKey :: ApiT XPub -> ApiAccountPublicKey
[$sel:key:ApiAccountPublicKey] :: ApiAccountPublicKey -> ApiT XPub
newtype WalletOrAccountPostData
WalletOrAccountPostData :: Either WalletPostData AccountPostData -> WalletOrAccountPostData
[$sel:postData:WalletOrAccountPostData] :: WalletOrAccountPostData -> Either WalletPostData AccountPostData

-- | An abstract class to allow encoding of addresses depending on the
--   target backend used.
class EncodeAddress (n :: NetworkDiscriminant)
encodeAddress :: EncodeAddress n => Address -> Text

-- | An abstract class to allow decoding of addresses depending on the
--   target backend used.
class DecodeAddress (n :: NetworkDiscriminant)
decodeAddress :: DecodeAddress n => Text -> Either TextDecodingError Address
class EncodeStakeAddress (n :: NetworkDiscriminant)
encodeStakeAddress :: EncodeStakeAddress n => RewardAccount -> Text
class DecodeStakeAddress (n :: NetworkDiscriminant)
decodeStakeAddress :: DecodeStakeAddress n => Text -> Either TextDecodingError RewardAccount
newtype ApiSharedWallet
ApiSharedWallet :: Either ApiPendingSharedWallet ApiActiveSharedWallet -> ApiSharedWallet
[$sel:wallet:ApiSharedWallet] :: ApiSharedWallet -> Either ApiPendingSharedWallet ApiActiveSharedWallet
data ApiPendingSharedWallet
ApiPendingSharedWallet :: !ApiT WalletId -> !ApiT WalletName -> !ApiT DerivationIndex -> !ApiT AddressPoolGap -> !ScriptTemplate -> !Maybe ScriptTemplate -> ApiPendingSharedWallet
[$sel:id:ApiPendingSharedWallet] :: ApiPendingSharedWallet -> !ApiT WalletId
[$sel:name:ApiPendingSharedWallet] :: ApiPendingSharedWallet -> !ApiT WalletName
[$sel:accountIndex:ApiPendingSharedWallet] :: ApiPendingSharedWallet -> !ApiT DerivationIndex
[$sel:addressPoolGap:ApiPendingSharedWallet] :: ApiPendingSharedWallet -> !ApiT AddressPoolGap
[$sel:paymentScriptTemplate:ApiPendingSharedWallet] :: ApiPendingSharedWallet -> !ScriptTemplate
[$sel:delegationScriptTemplate:ApiPendingSharedWallet] :: ApiPendingSharedWallet -> !Maybe ScriptTemplate
data ApiActiveSharedWallet
ApiActiveSharedWallet :: !ApiT WalletId -> !ApiT WalletName -> !ApiT DerivationIndex -> !ApiT AddressPoolGap -> !Maybe ApiWalletPassphraseInfo -> !ScriptTemplate -> !Maybe ScriptTemplate -> !ApiWalletDelegation -> !ApiWalletBalance -> !ApiWalletAssetsBalance -> !ApiT SyncProgress -> !ApiBlockReference -> ApiActiveSharedWallet
[$sel:id:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !ApiT WalletId
[$sel:name:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !ApiT WalletName
[$sel:accountIndex:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !ApiT DerivationIndex
[$sel:addressPoolGap:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !ApiT AddressPoolGap
[$sel:passphrase:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !Maybe ApiWalletPassphraseInfo
[$sel:paymentScriptTemplate:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !ScriptTemplate
[$sel:delegationScriptTemplate:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !Maybe ScriptTemplate
[$sel:delegation:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !ApiWalletDelegation
[$sel:balance:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !ApiWalletBalance
[$sel:assets:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !ApiWalletAssetsBalance
[$sel:state:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !ApiT SyncProgress
[$sel:tip:ApiActiveSharedWallet] :: ApiActiveSharedWallet -> !ApiBlockReference
newtype ApiSharedWalletPostData
ApiSharedWalletPostData :: Either ApiSharedWalletPostDataFromMnemonics ApiSharedWalletPostDataFromAccountPubX -> ApiSharedWalletPostData
[$sel:wallet:ApiSharedWalletPostData] :: ApiSharedWalletPostData -> Either ApiSharedWalletPostDataFromMnemonics ApiSharedWalletPostDataFromAccountPubX
data ApiSharedWalletPostDataFromMnemonics
ApiSharedWalletPostDataFromMnemonics :: !ApiT WalletName -> !ApiMnemonicT (AllowedMnemonics 'Shelley) -> !Maybe (ApiMnemonicT (AllowedMnemonics 'SndFactor)) -> !ApiT (Passphrase "user") -> !ApiT DerivationIndex -> !ApiScriptTemplateEntry -> !Maybe ApiScriptTemplateEntry -> !Maybe (ApiT ValidationLevel) -> ApiSharedWalletPostDataFromMnemonics
[$sel:name:ApiSharedWalletPostDataFromMnemonics] :: ApiSharedWalletPostDataFromMnemonics -> !ApiT WalletName
[$sel:mnemonicSentence:ApiSharedWalletPostDataFromMnemonics] :: ApiSharedWalletPostDataFromMnemonics -> !ApiMnemonicT (AllowedMnemonics 'Shelley)
[$sel:mnemonicSecondFactor:ApiSharedWalletPostDataFromMnemonics] :: ApiSharedWalletPostDataFromMnemonics -> !Maybe (ApiMnemonicT (AllowedMnemonics 'SndFactor))
[$sel:passphrase:ApiSharedWalletPostDataFromMnemonics] :: ApiSharedWalletPostDataFromMnemonics -> !ApiT (Passphrase "user")
[$sel:accountIndex:ApiSharedWalletPostDataFromMnemonics] :: ApiSharedWalletPostDataFromMnemonics -> !ApiT DerivationIndex
[$sel:paymentScriptTemplate:ApiSharedWalletPostDataFromMnemonics] :: ApiSharedWalletPostDataFromMnemonics -> !ApiScriptTemplateEntry
[$sel:delegationScriptTemplate:ApiSharedWalletPostDataFromMnemonics] :: ApiSharedWalletPostDataFromMnemonics -> !Maybe ApiScriptTemplateEntry
[$sel:scriptValidation:ApiSharedWalletPostDataFromMnemonics] :: ApiSharedWalletPostDataFromMnemonics -> !Maybe (ApiT ValidationLevel)
data ApiSharedWalletPostDataFromAccountPubX
ApiSharedWalletPostDataFromAccountPubX :: !ApiT WalletName -> !ApiAccountPublicKey -> !ApiT DerivationIndex -> !ApiScriptTemplateEntry -> !Maybe ApiScriptTemplateEntry -> !Maybe (ApiT ValidationLevel) -> ApiSharedWalletPostDataFromAccountPubX
[$sel:name:ApiSharedWalletPostDataFromAccountPubX] :: ApiSharedWalletPostDataFromAccountPubX -> !ApiT WalletName
[$sel:accountPublicKey:ApiSharedWalletPostDataFromAccountPubX] :: ApiSharedWalletPostDataFromAccountPubX -> !ApiAccountPublicKey
[$sel:accountIndex:ApiSharedWalletPostDataFromAccountPubX] :: ApiSharedWalletPostDataFromAccountPubX -> !ApiT DerivationIndex
[$sel:paymentScriptTemplate:ApiSharedWalletPostDataFromAccountPubX] :: ApiSharedWalletPostDataFromAccountPubX -> !ApiScriptTemplateEntry
[$sel:delegationScriptTemplate:ApiSharedWalletPostDataFromAccountPubX] :: ApiSharedWalletPostDataFromAccountPubX -> !Maybe ApiScriptTemplateEntry
[$sel:scriptValidation:ApiSharedWalletPostDataFromAccountPubX] :: ApiSharedWalletPostDataFromAccountPubX -> !Maybe (ApiT ValidationLevel)
data ApiSharedWalletPatchData
ApiSharedWalletPatchData :: !ApiT Cosigner -> !ApiAccountPublicKey -> ApiSharedWalletPatchData
[$sel:cosigner:ApiSharedWalletPatchData] :: ApiSharedWalletPatchData -> !ApiT Cosigner
[$sel:accountPublicKey:ApiSharedWalletPatchData] :: ApiSharedWalletPatchData -> !ApiAccountPublicKey

-- | Polymorphic wrapper type to put around primitive types and, 3rd party
--   lib types to avoid defining orphan instances and/or, undesirable
--   instances on primitive types. It helps to keep a nice separation of
--   concerns between the API layer and other modules.
newtype ApiT a
ApiT :: a -> ApiT a
[$sel:getApiT:ApiT] :: ApiT a -> a

-- | Representation of mnemonics at the API-level, using a polymorphic type
--   in the lengths of mnemonics that are supported (and an underlying
--   purpose). In practice, mnemonics correspond to passphrases or seeds,
--   and although they're nice to manipulate as mnemonics from a
--   user-perspective, carrying around a list of words doesn't really make
--   sense for the business logic, which prefers manipulating scrubbed
--   bytes directly.
--   
--   <pre>
--   data MyWallet
--       { mnemonic :: ApiMnemonicT '[15,18,21,24]
--       }
--   </pre>
--   
--   Note that the given <a>Nat</a>s **have** to be valid mnemonic sizes,
--   otherwise the underlying code won't even compile, with not-so-friendly
--   error messages.
--   
--   Also, the internal representation holds a <tt>[Text]</tt> which
--   contains the list of mnemonic words that was parsed. This is only to
--   be able to implement the <a>ToJSON</a> instances and roundtrip, which
--   is a very dubious argument. In practice, we'll NEVER peek at the
--   mnemonic, output them and whatnot.
newtype ApiMnemonicT (sizes :: [Nat])
ApiMnemonicT :: SomeMnemonic -> ApiMnemonicT (sizes :: [Nat])
[$sel:getApiMnemonicT:ApiMnemonicT] :: ApiMnemonicT (sizes :: [Nat]) -> SomeMnemonic

-- | Polymorphic wrapper for byte arrays, parameterised by the desired
--   string encoding.
newtype ApiBytesT (base :: Base) bs
ApiBytesT :: bs -> ApiBytesT (base :: Base) bs
[$sel:getApiBytesT:ApiBytesT] :: ApiBytesT (base :: Base) bs -> bs
type family ApiAddressT (n :: k) :: Type
type family ApiStakeKeysT (n :: k) :: Type
type family ApiPutAddressesDataT (n :: k) :: Type
type family ApiAddressIdT (n :: k) :: Type
type family ApiCoinSelectionT (n :: k) :: Type
type family ApiSelectCoinsDataT (n :: k) :: Type
type family ApiTransactionT (n :: k) :: Type
type family ApiConstructTransactionT (n :: k) :: Type
type family ApiConstructTransactionDataT (n :: k) :: Type
type family PostTransactionOldDataT (n :: k) :: Type
type family PostTransactionFeeOldDataT (n :: k) :: Type
type family ApiWalletMigrationPlanPostDataT (n :: k) :: Type
type family ApiWalletMigrationPostDataT (n :: k1) (s :: k2) :: Type
type family ApiBalanceTransactionPostDataT (n :: k) :: Type
type family ApiDecodedTransactionT (n :: k) :: Type
coinToQuantity :: Integral n => Coin -> Quantity "lovelace" n
coinFromQuantity :: Integral n => Quantity "lovelace" n -> Coin
defaultRecordTypeOptions :: Options
strictRecordTypeOptions :: Options

-- | Parses the SMASH HealthCheck type from the SMASH API.
data HealthStatusSMASH
HealthStatusSMASH :: Text -> Text -> HealthStatusSMASH
[$sel:status:HealthStatusSMASH] :: HealthStatusSMASH -> Text
[$sel:version:HealthStatusSMASH] :: HealthStatusSMASH -> Text

-- | Dscribes the health status of the SMASH server.
data HealthCheckSMASH
Available :: HealthCheckSMASH
Unavailable :: HealthCheckSMASH
Unreachable :: HealthCheckSMASH
NoSmashConfigured :: HealthCheckSMASH
newtype ApiHealthCheck
ApiHealthCheck :: HealthCheckSMASH -> ApiHealthCheck
[$sel:health:ApiHealthCheck] :: ApiHealthCheck -> HealthCheckSMASH

-- | A wrapper that allows any type to be serialized as a JSON array.
--   
--   The number of items permitted in the array is dependent on the wrapped
--   type.
newtype ApiAsArray (s :: Symbol) a
ApiAsArray :: a -> ApiAsArray (s :: Symbol) a

-- | The different bases that can be used.
--   
--   See <a>RFC4648</a> for details. In particular, Base64 can be standard
--   or <a>URL-safe</a>. URL-safe encoding is often used in other
--   specifications without <a>padding</a> characters.
--   
--   <a>RFC 2045</a> defines a separate Base64 encoding, which is not
--   supported. This format requires a newline at least every 76 encoded
--   characters, which works around limitations of older email programs
--   that could not handle long lines. Be aware that other languages, such
--   as Ruby, encode the RFC 2045 version by default. To decode their
--   output, remove all newlines before decoding.
--   
--   <h4>Examples</h4>
--   
--   A quick example to show the differences:
--   
--   <pre>
--   &gt;&gt;&gt; let input = "Is 3 &gt; 2?" :: ByteString
--   
--   &gt;&gt;&gt; let convertedTo base = convertToBase base input :: ByteString
--   
--   &gt;&gt;&gt; convertedTo Base16
--   "49732033203e20323f"
--   
--   &gt;&gt;&gt; convertedTo Base32
--   "JFZSAMZAHYQDEPY="
--   
--   &gt;&gt;&gt; convertedTo Base64
--   "SXMgMyA+IDI/"
--   
--   &gt;&gt;&gt; convertedTo Base64URLUnpadded
--   "SXMgMyA-IDI_"
--   
--   &gt;&gt;&gt; convertedTo Base64OpenBSD
--   "QVKeKw.8GBG9"
--   </pre>
data Base

-- | similar to hexadecimal
Base16 :: Base

-- | standard Base64
Base64 :: Base
instance GHC.Enum.Enum Cardano.Wallet.Api.Types.ByronWalletStyle
instance GHC.Enum.Bounded Cardano.Wallet.Api.Types.ByronWalletStyle
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ByronWalletStyle
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ByronWalletStyle
instance GHC.Show.Show Cardano.Wallet.Api.Types.ByronWalletStyle
instance GHC.Show.Show Cardano.Wallet.Api.Types.MaintenanceAction
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.MaintenanceAction
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.MaintenanceAction
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiMaintenanceActionPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiMaintenanceActionPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiMaintenanceActionPostData
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiMetadataError
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiMetadataError
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiMetadataError
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiMetadataError
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiCredential
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiCredential
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiCredential
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAddressDataPayload
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAddressDataPayload
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAddressDataPayload
instance GHC.Enum.Enum Cardano.Wallet.Api.Types.AnyAddressType
instance GHC.Enum.Bounded Cardano.Wallet.Api.Types.AnyAddressType
instance GHC.Show.Show Cardano.Wallet.Api.Types.AnyAddressType
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.AnyAddressType
instance GHC.Show.Show Cardano.Wallet.Api.Types.AnyAddress
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.AnyAddress
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.AnyAddress
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletBalance
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletBalance
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletBalance
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletBalance
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletPassphraseInfo
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletPassphraseInfo
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletPassphraseInfo
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletPassphraseInfo
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiStakePoolFlag
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiStakePoolFlag
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiStakePoolFlag
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiStakePoolFlag
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiValidityBound
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiValidityBound
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiValidityBound
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiValidityBound
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiValidityInterval
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiValidityInterval
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiValidityInterval
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiValidityInterval
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiFee
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiFee
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiFee
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ResourceContext
instance GHC.Show.Show Cardano.Wallet.Api.Types.ResourceContext
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ResourceContext
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ResourceContext
instance Control.DeepSeq.NFData addr => Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.AddressAmountNoAssets addr)
instance GHC.Show.Show addr => GHC.Show.Show (Cardano.Wallet.Api.Types.AddressAmountNoAssets addr)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.AddressAmountNoAssets addr)
instance GHC.Classes.Eq addr => GHC.Classes.Eq (Cardano.Wallet.Api.Types.AddressAmountNoAssets addr)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAddressInspect
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiAddressInspect
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAddressInspect
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAddressInspect
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAddressInspectData
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiAddressInspectData
instance Data.String.IsString Cardano.Wallet.Api.Types.ApiAddressInspectData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAddressInspectData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAddressInspectData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiBlockInfo
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiBlockInfo
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiBlockInfo
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiBlockInfo
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiEra
instance GHC.Enum.Bounded Cardano.Wallet.Api.Types.ApiEra
instance GHC.Classes.Ord Cardano.Wallet.Api.Types.ApiEra
instance GHC.Enum.Enum Cardano.Wallet.Api.Types.ApiEra
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiEra
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiEra
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiEra
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiNetworkInfo
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNetworkInfo
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNetworkInfo
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNetworkInfo
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletMode
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletMode
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletMode
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletMode
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.NtpSyncingStatus
instance GHC.Show.Show Cardano.Wallet.Api.Types.NtpSyncingStatus
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.NtpSyncingStatus
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.NtpSyncingStatus
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiNtpStatus
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNtpStatus
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNtpStatus
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNtpStatus
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNetworkClock
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiNetworkClock
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNetworkClock
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNetworkClock
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWithdrawRewards
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWithdrawRewards
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWithdrawRewards
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWithdrawRewards
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.VerificationKeyHashing
instance GHC.Show.Show Cardano.Wallet.Api.Types.VerificationKeyHashing
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.VerificationKeyHashing
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.VerificationKeyHashing
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiVerificationKeyShelley
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiVerificationKeyShelley
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiVerificationKeyShelley
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiVerificationKeyShelley
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiPolicyKey
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiPolicyKey
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiPolicyKey
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiPolicyKey
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiVerificationKeyShared
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiVerificationKeyShared
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiVerificationKeyShared
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiVerificationKeyShared
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.KeyFormat
instance GHC.Show.Show Cardano.Wallet.Api.Types.KeyFormat
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.KeyFormat
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.KeyFormat
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiAccountKey
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAccountKey
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAccountKey
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAccountKey
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiAccountKeyShared
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAccountKeyShared
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAccountKeyShared
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAccountKeyShared
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.XPubOrSelf
instance GHC.Show.Show Cardano.Wallet.Api.Types.XPubOrSelf
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.XPubOrSelf
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.XPubOrSelf
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiScriptTemplateEntry
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiScriptTemplateEntry
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiScriptTemplateEntry
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiScriptTemplateEntry
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiErrorCode
instance Data.Data.Data Cardano.Wallet.Api.Types.ApiErrorCode
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiErrorCode
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiErrorCode
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiErrorCode
instance GHC.Show.Show Cardano.Wallet.Api.Types.Iso8601Time
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.Iso8601Time
instance GHC.Classes.Ord Cardano.Wallet.Api.Types.Iso8601Time
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.Iso8601Time
instance GHC.Show.Show Cardano.Wallet.Api.Types.MinWithdrawal
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.MinWithdrawal
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiPoolId
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiPoolId
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiPoolId
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletDiscovery
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletDiscovery
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletDiscovery
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletDiscovery
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Api.Types.ApiT a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiT a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Base.Functor Cardano.Wallet.Api.Types.ApiT
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiT a)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiT a)
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiPendingSharedWallet
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiPendingSharedWallet
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiPendingSharedWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiPendingSharedWallet
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiPostAccountKeyDataWithPurpose
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiPostAccountKeyDataWithPurpose
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiPostAccountKeyDataWithPurpose
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiPostAccountKeyDataWithPurpose
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiPostAccountKeyData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiPostAccountKeyData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiPostAccountKeyData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiPostAccountKeyData
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletSignData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletSignData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletSignData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletSignData
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletMigrationBalance
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletMigrationBalance
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletMigrationBalance
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletMigrationBalance
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiPutAddressesData n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiPutAddressesData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiPutAddressesData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiPutAddressesData n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiWalletMigrationPostData n s)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiWalletMigrationPostData n s)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiWalletMigrationPostData n s)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiWalletMigrationPostData n s)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiWalletMigrationPlanPostData n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiWalletMigrationPlanPostData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiWalletMigrationPlanPostData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiWalletMigrationPlanPostData n)
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiPostRandomAddressData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiPostRandomAddressData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiPostRandomAddressData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiPostRandomAddressData
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiSlotId
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiSlotId
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiSlotId
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiSlotId
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiBlockReference
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiBlockReference
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiBlockReference
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiBlockReference
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiSlotReference
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiSlotReference
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiSlotReference
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiSlotReference
instance Control.DeepSeq.NFData addr => Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.AddressAmount addr)
instance GHC.Show.Show addr => GHC.Show.Show (Cardano.Wallet.Api.Types.AddressAmount addr)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.AddressAmount addr)
instance GHC.Classes.Eq addr => GHC.Classes.Eq (Cardano.Wallet.Api.Types.AddressAmount addr)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiTxCollateral n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiTxCollateral n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiTxCollateral n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiTxCollateral n)
instance forall k (n :: k). Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiCoinSelectionWithdrawal n)
instance forall k (n :: k). GHC.Show.Show (Cardano.Wallet.Api.Types.ApiCoinSelectionWithdrawal n)
instance forall k (n :: k). GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiCoinSelectionWithdrawal n)
instance forall k (n :: k). GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiCoinSelectionWithdrawal n)
instance forall k (n :: k). Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiWithdrawal n)
instance forall k (n :: k). GHC.Show.Show (Cardano.Wallet.Api.Types.ApiWithdrawal n)
instance forall k (n :: k). GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiWithdrawal n)
instance forall k (n :: k). GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiWithdrawal n)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiTxMetadata
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiTxMetadata
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiTxMetadata
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiTxMetadata
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiTokenAmountFingerprint
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiTokenAmountFingerprint
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiTokenAmountFingerprint
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiTokenAmountFingerprint
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiTokens
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiTokens
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiTokens
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiTokens
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiAssetMintBurn
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAssetMintBurn
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAssetMintBurn
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAssetMintBurn
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiPostPolicyKeyData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiPostPolicyKeyData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiPostPolicyKeyData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiPostPolicyKeyData
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiDeregisterPool
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiDeregisterPool
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiDeregisterPool
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiDeregisterPool
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiRegisterPool
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiRegisterPool
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiRegisterPool
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiRegisterPool
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiExternalCertificate n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiExternalCertificate n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiExternalCertificate n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiExternalCertificate n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiWalletOutput n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiWalletOutput n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiWalletOutput n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiWalletOutput n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiWithdrawalGeneral n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiWithdrawalGeneral n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiWithdrawalGeneral n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiWithdrawalGeneral n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiWalletInput n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiWalletInput n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiWalletInput n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiWalletInput n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiTxInputGeneral n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiTxInputGeneral n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiTxInputGeneral n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiTxInputGeneral n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiTxInput n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiTxInput n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiTxInput n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiTxInput n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiTxOutputGeneral n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiTxOutputGeneral n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiTxOutputGeneral n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiTxOutputGeneral n)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiTxId
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiTxId
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiTxId
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiTxId
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiExternalInput n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiExternalInput n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiExternalInput n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiExternalInput n)
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiSerialisedTransaction
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiSerialisedTransaction
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiSerialisedTransaction
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiSerialisedTransaction
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiSignTransactionPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiSignTransactionPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiSignTransactionPostData
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiStakeKeyIndex
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiStakeKeyIndex
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiStakeKeyIndex
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiStakeKeyIndex
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiMultiDelegationAction
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiMultiDelegationAction
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiMultiDelegationAction
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiMultiDelegationAction
instance GHC.Show.Show Cardano.Wallet.Api.Types.ByronWalletPutPassphraseData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ByronWalletPutPassphraseData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ByronWalletPutPassphraseData
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPutPassphraseOldPassphraseData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPutPassphraseOldPassphraseData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPutPassphraseOldPassphraseData
instance GHC.Show.Show Cardano.Wallet.Api.Types.SettingsPutData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.SettingsPutData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.SettingsPutData
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPutData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiSharedWalletPatchData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiSharedWalletPatchData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiSharedWalletPatchData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiSharedWalletPatchData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiSharedWalletPostDataFromAccountPubX
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiSharedWalletPostDataFromAccountPubX
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiSharedWalletPostDataFromAccountPubX
instance GHC.Show.Show Cardano.Wallet.Api.Types.AccountPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.AccountPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.AccountPostData
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ByronWalletFromXPrvPostData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ByronWalletFromXPrvPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ByronWalletFromXPrvPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ByronWalletFromXPrvPostData
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshotEntry
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshotEntry
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshotEntry
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshotEntry
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshot
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshot
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshot
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshot
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletAssetsBalance
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletAssetsBalance
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletAssetsBalance
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletAssetsBalance
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiCoinSelectionCollateral n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiCoinSelectionCollateral n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiCoinSelectionCollateral n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiCoinSelectionCollateral n)
instance Data.Hashable.Class.Hashable (Cardano.Wallet.Api.Types.ApiCoinSelectionOutput n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiCoinSelectionOutput n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiCoinSelectionOutput n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiCoinSelectionOutput n)
instance (TypeError ...) => GHC.Classes.Ord (Cardano.Wallet.Api.Types.ApiCoinSelectionOutput n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiCoinSelectionOutput n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiCoinSelectionChange n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiCoinSelectionChange n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiCoinSelectionChange n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiCoinSelectionChange n)
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiDelegationAction
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiDelegationAction
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiDelegationAction
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiDelegationAction
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiSelectCoinsAction
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiSelectCoinsAction
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiSelectCoinsAction
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiCertificate
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiCertificate
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiCertificate
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiCertificate
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiAnyCertificate n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiAnyCertificate n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiAnyCertificate n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiAnyCertificate n)
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiEpochInfo
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiEpochInfo
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiEpochInfo
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiEpochInfo
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiNetworkInformation
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNetworkInformation
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNetworkInformation
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNetworkInformation
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiEraInfo
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiEraInfo
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiEraInfo
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNetworkParameters
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNetworkParameters
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNetworkParameters
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiStakePool
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiStakePool
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiStakePool
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWalletDelegation
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWalletDelegation
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWalletDelegation
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWalletDelegation
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiActiveSharedWallet
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiActiveSharedWallet
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiActiveSharedWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiActiveSharedWallet
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiSharedWallet
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiSharedWallet
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiSharedWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiSharedWallet
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWallet
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAddressData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAddressData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAddressData
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiAddress n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiAddress n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiAddress n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiAddress n)
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiAssetMetadata
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAssetMetadata
instance GHC.Classes.Ord Cardano.Wallet.Api.Types.ApiAssetMetadata
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAssetMetadata
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAssetMetadata
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiAsset
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiAsset
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiAsset
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiAsset
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiPostPolicyIdData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiPostPolicyIdData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiPostPolicyIdData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiPolicyId
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiPolicyId
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiPolicyId
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiMaintenanceAction
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiMaintenanceAction
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiMaintenanceAction
instance GHC.Show.Show bs => GHC.Show.Show (Cardano.Wallet.Api.Types.ApiBytesT base bs)
instance Control.DeepSeq.NFData bs => Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiBytesT base bs)
instance Data.Hashable.Class.Hashable bs => Data.Hashable.Class.Hashable (Cardano.Wallet.Api.Types.ApiBytesT base bs)
instance GHC.Base.Monoid bs => GHC.Base.Monoid (Cardano.Wallet.Api.Types.ApiBytesT base bs)
instance GHC.Base.Semigroup bs => GHC.Base.Semigroup (Cardano.Wallet.Api.Types.ApiBytesT base bs)
instance GHC.Base.Functor (Cardano.Wallet.Api.Types.ApiBytesT base)
instance GHC.Classes.Eq bs => GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiBytesT base bs)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiBytesT base bs)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiRedeemer n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiRedeemer n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiRedeemer n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiBalanceTransactionPostData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiBalanceTransactionPostData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiBalanceTransactionPostData n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiWalletMigrationPlan n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiWalletMigrationPlan n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiWalletMigrationPlan n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiWalletMigrationPlan n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiConstructTransaction n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiConstructTransaction n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiConstructTransaction n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiConstructTransaction n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiSharedWalletPostDataFromMnemonics
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiSharedWalletPostDataFromMnemonics
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiSharedWalletPostDataFromMnemonics
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiSharedWalletPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiSharedWalletPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiSharedWalletPostData
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiWithdrawalPostData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiWithdrawalPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiWithdrawalPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiWithdrawalPostData
instance GHC.Show.Show (Cardano.Wallet.Api.Types.PostTransactionFeeOldData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.PostTransactionFeeOldData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.PostTransactionFeeOldData n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.PostTransactionOldData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.PostTransactionOldData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.PostTransactionOldData n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiSelectCoinsPayments n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiSelectCoinsPayments n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiSelectCoinsPayments n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiSelectCoinsData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiSelectCoinsData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiSelectCoinsData n)
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPutPassphraseMnemonicData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPutPassphraseMnemonicData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPutPassphraseMnemonicData
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ByronWalletPostData mw)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ByronWalletPostData mw)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ByronWalletPostData mw)
instance GHC.Show.Show Cardano.Wallet.Api.Types.SomeByronWalletPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.SomeByronWalletPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.SomeByronWalletPostData
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletPostData
instance GHC.Show.Show Cardano.Wallet.Api.Types.WalletOrAccountPostData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.WalletOrAccountPostData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.WalletOrAccountPostData
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiOurStakeKey n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiOurStakeKey n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiOurStakeKey n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiForeignStakeKey n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiForeignStakeKey n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiForeignStakeKey n)
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiNullStakeKey
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiNullStakeKey
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiNullStakeKey
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiStakeKeys n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiStakeKeys n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiStakeKeys n)
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiByronWallet
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiByronWallet
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiByronWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiByronWallet
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiPaymentDestination n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiPaymentDestination n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiPaymentDestination n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiPaymentDestination n)
instance GHC.Classes.Ord Cardano.Wallet.Api.Types.HealthStatusSMASH
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.HealthStatusSMASH
instance GHC.Show.Show Cardano.Wallet.Api.Types.HealthStatusSMASH
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.HealthStatusSMASH
instance GHC.Classes.Ord Cardano.Wallet.Api.Types.HealthCheckSMASH
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.HealthCheckSMASH
instance GHC.Show.Show Cardano.Wallet.Api.Types.HealthCheckSMASH
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.HealthCheckSMASH
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiHealthCheck
instance GHC.Classes.Ord Cardano.Wallet.Api.Types.ApiHealthCheck
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiHealthCheck
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiHealthCheck
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiMintData n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiMintData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiMintData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiMintData n)
instance Control.DeepSeq.NFData Cardano.Wallet.Api.Types.ApiBurnData
instance GHC.Show.Show Cardano.Wallet.Api.Types.ApiBurnData
instance GHC.Generics.Generic Cardano.Wallet.Api.Types.ApiBurnData
instance GHC.Classes.Eq Cardano.Wallet.Api.Types.ApiBurnData
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiMintBurnOperation n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiMintBurnOperation n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiMintBurnOperation n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiMintBurnOperation n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiMintBurnData n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiMintBurnData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiMintBurnData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiMintBurnData n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiConstructTransactionData n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiConstructTransactionData n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiConstructTransactionData n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiConstructTransactionData n)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiAsArray s a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Cardano.Wallet.Api.Types.ApiAsArray s a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Cardano.Wallet.Api.Types.ApiAsArray s a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Wallet.Api.Types.ApiAsArray s a)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiAsArray s a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiAsArray s a)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiDecodedTransaction n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiDecodedTransaction n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiDecodedTransaction n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiDecodedTransaction n)
instance Control.DeepSeq.NFData (Cardano.Wallet.Api.Types.ApiTransaction n)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiTransaction n)
instance GHC.Generics.Generic (Cardano.Wallet.Api.Types.ApiTransaction n)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiTransaction n)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Api.Types.ApiT a)
instance (Cardano.Wallet.Api.Types.DecodeAddress n, Cardano.Wallet.Api.Types.DecodeStakeAddress n) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiTransaction n)
instance (Cardano.Wallet.Api.Types.EncodeAddress n, Cardano.Wallet.Api.Types.EncodeStakeAddress n) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiTransaction n)
instance (Cardano.Wallet.Api.Types.DecodeAddress n, Cardano.Wallet.Api.Types.DecodeStakeAddress n) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiDecodedTransaction n)
instance (Cardano.Wallet.Api.Types.EncodeAddress n, Cardano.Wallet.Api.Types.EncodeStakeAddress n) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiDecodedTransaction n)
instance (GHC.TypeLits.KnownSymbol s, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiAsArray s (GHC.Maybe.Maybe a))
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiAsArray s (GHC.Maybe.Maybe a))
instance Cardano.Wallet.Api.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiConstructTransactionData t)
instance Cardano.Wallet.Api.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiConstructTransactionData t)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiMintBurnData n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiMintBurnData n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiMintBurnOperation n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiMintBurnOperation n)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiBurnData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiBurnData
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiMintData n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiMintData n)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiHealthCheck
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiHealthCheck
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.HealthCheckSMASH
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.HealthCheckSMASH
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.HealthStatusSMASH
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.HealthStatusSMASH
instance Cardano.Wallet.Api.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiPaymentDestination t)
instance Cardano.Wallet.Api.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiPaymentDestination t)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiOurStakeKey n)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiForeignStakeKey n)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiStakeKeys n)
instance (Cardano.Wallet.Api.Types.DecodeStakeAddress n, Cardano.Wallet.Api.Types.DecodeAddress n) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiCoinSelectionWithdrawal n)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiRedeemer n)
instance (Cardano.Wallet.Api.Types.DecodeStakeAddress n, Cardano.Wallet.Api.Types.DecodeAddress n) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiBalanceTransactionPostData n)
instance (Cardano.Wallet.Api.Types.DecodeAddress t, Cardano.Wallet.Api.Types.DecodeStakeAddress t) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiConstructTransaction t)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiExternalCertificate n)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiAnyCertificate n)
instance (Cardano.Wallet.Api.Types.DecodeAddress n, Cardano.Wallet.Api.Types.DecodeStakeAddress n) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiTxOutputGeneral n)
instance (Cardano.Wallet.Api.Types.DecodeAddress n, Cardano.Wallet.Api.Types.DecodeStakeAddress n) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiTxInputGeneral n)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiWithdrawal n)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiWithdrawalGeneral n)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount, Data.Proxy.Proxy n)
instance (Cardano.Wallet.Api.Types.DecodeStakeAddress n, Cardano.Wallet.Api.Types.DecodeAddress n) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiWalletMigrationPlan n)
instance Cardano.Wallet.Api.Types.DecodeStakeAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet => Cardano.Wallet.Api.Types.DecodeStakeAddress ('Cardano.Wallet.Primitive.AddressDerivation.Staging pm)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiOurStakeKey n)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiForeignStakeKey n)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiStakeKeys n)
instance (Cardano.Wallet.Api.Types.EncodeStakeAddress n, Cardano.Wallet.Api.Types.EncodeAddress n) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiCoinSelection n)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiCoinSelectionWithdrawal n)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiRedeemer n)
instance (Cardano.Wallet.Api.Types.EncodeStakeAddress n, Cardano.Wallet.Api.Types.EncodeAddress n) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiBalanceTransactionPostData n)
instance (Cardano.Wallet.Api.Types.EncodeAddress t, Cardano.Wallet.Api.Types.EncodeStakeAddress t) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiConstructTransaction t)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiExternalCertificate n)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiAnyCertificate n)
instance (Cardano.Wallet.Api.Types.EncodeAddress n, Cardano.Wallet.Api.Types.EncodeStakeAddress n) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiTxOutputGeneral n)
instance (Cardano.Wallet.Api.Types.EncodeAddress n, Cardano.Wallet.Api.Types.EncodeStakeAddress n) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiTxInputGeneral n)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiWithdrawal n)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiWithdrawalGeneral n)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.RewardAccount.RewardAccount, Data.Proxy.Proxy n)
instance (Cardano.Wallet.Api.Types.EncodeStakeAddress n, Cardano.Wallet.Api.Types.EncodeAddress n) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiWalletMigrationPlan n)
instance Cardano.Wallet.Api.Types.EncodeStakeAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet => Cardano.Wallet.Api.Types.EncodeStakeAddress ('Cardano.Wallet.Primitive.AddressDerivation.Staging pm)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Web.Internal.HttpApiData.FromHttpApiData (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address.Address, Data.Proxy.Proxy n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiAddress n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiSelectCoinsPayments n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiSelectCoinsData n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiCoinSelectionChange n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiCoinSelectionCollateral n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiCoinSelectionOutput n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address.Address, Data.Proxy.Proxy n)
instance Cardano.Wallet.Api.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.PostTransactionOldData t)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiExternalInput n)
instance Cardano.Wallet.Api.Types.DecodeAddress t => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.PostTransactionFeeOldData t)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiWalletInput n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiWalletOutput n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiWalletMigrationPlanPostData n)
instance (Cardano.Wallet.Api.Types.DecodeAddress n, Cardano.Wallet.Primitive.Passphrase.Types.PassphraseMaxLength s, Cardano.Wallet.Primitive.Passphrase.Types.PassphraseMinLength s) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiWalletMigrationPostData n s)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiPutAddressesData n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiTxInput n)
instance Cardano.Wallet.Api.Types.DecodeAddress n => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiTxCollateral n)
instance Cardano.Wallet.Api.Types.DecodeAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet => Cardano.Wallet.Api.Types.DecodeAddress ('Cardano.Wallet.Primitive.AddressDerivation.Staging pm)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Web.Internal.HttpApiData.ToHttpApiData (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address.Address, Data.Proxy.Proxy n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiAddress n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiSelectCoinsPayments n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiSelectCoinsData n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiCoinSelectionChange n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiCoinSelectionCollateral n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiCoinSelectionOutput n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address.Address, Data.Proxy.Proxy n)
instance Cardano.Wallet.Api.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.PostTransactionOldData t)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiExternalInput n)
instance Cardano.Wallet.Api.Types.EncodeAddress t => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.PostTransactionFeeOldData t)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiWalletInput n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiWalletOutput n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiWalletMigrationPlanPostData n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiWalletMigrationPostData n s)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiPutAddressesData n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiTxInput n)
instance Cardano.Wallet.Api.Types.EncodeAddress n => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiTxCollateral n)
instance Cardano.Wallet.Api.Types.EncodeAddress 'Cardano.Wallet.Primitive.AddressDerivation.Mainnet => Cardano.Wallet.Api.Types.EncodeAddress ('Cardano.Wallet.Primitive.AddressDerivation.Staging pm)
instance (Cardano.Wallet.Api.Types.HasBase base, Data.ByteArray.Types.ByteArray bs) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiBytesT base bs)
instance (Cardano.Wallet.Api.Types.HasBase base, Data.ByteArray.Types.ByteArrayAccess bs) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiBytesT base bs)
instance (Cardano.Wallet.Api.Types.HasBase b, Data.ByteArray.Types.ByteArray bs) => Data.Text.Class.FromText (Cardano.Wallet.Api.Types.ApiBytesT b bs)
instance (Cardano.Wallet.Api.Types.HasBase b, Data.ByteArray.Types.ByteArrayAccess bs) => Data.Text.Class.ToText (Cardano.Wallet.Api.Types.ApiBytesT b bs)
instance Cardano.Wallet.Api.Types.HasBase 'Data.ByteArray.Encoding.Base16
instance Cardano.Wallet.Api.Types.HasBase 'Data.ByteArray.Encoding.Base64
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiByronWallet
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiByronWallet
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiByronWalletBalance
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNullStakeKey
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNullStakeKey
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletOrAccountPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletOrAccountPostData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.SomeByronWalletPostData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.SomeByronWalletPostData
instance Cardano.Mnemonic.MkSomeMnemonic mw => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ByronWalletPostData mw)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ByronWalletPostData mw)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPutPassphraseData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPutPassphraseMnemonicData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPutPassphraseMnemonicData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWithdrawalPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWithdrawalPostData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiSharedWalletPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiSharedWalletPostData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiSharedWalletPostDataFromMnemonics
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiSharedWalletPostDataFromMnemonics
instance Cardano.Mnemonic.MkSomeMnemonic sizes => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiMnemonicT sizes)
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.OctetStream (Cardano.Wallet.Api.Types.ApiBytesT base Data.ByteString.Internal.ByteString)
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream (Cardano.Wallet.Api.Types.ApiBytesT base Data.ByteString.Internal.ByteString)
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.OctetStream (Cardano.Wallet.Api.Types.ApiBytesT base Cardano.Wallet.Primitive.Types.Tx.SerialisedTx)
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream (Cardano.Wallet.Api.Types.ApiBytesT base Cardano.Wallet.Primitive.Types.Tx.SerialisedTx)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiMaintenanceAction
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiMaintenanceAction
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiPolicyId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiPolicyId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiPostPolicyIdData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiPostPolicyIdData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiAsset
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiAsset
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiAssetMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiAssetMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiAddressData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiAddressData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWallet
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWallet
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiSharedWallet
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiSharedWallet
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiActiveSharedWallet
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiActiveSharedWallet
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletDelegation
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletDelegation
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletDelegationNext
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiStakePool
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiStakePool
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNetworkParameters
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNetworkParameters
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiEraInfo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiEraInfo
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNetworkInformation
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNetworkInformation
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiEpochInfo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiEpochInfo
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiCertificate
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiCertificate
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiSelectCoinsAction
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiSelectCoinsAction
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiDelegationAction
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiDelegationAction
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletAssetsBalance
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletAssetsBalance
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletPassphrase
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshot
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshot
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshotEntry
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletUtxoSnapshotEntry
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiUtxoStatistics
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ByronWalletFromXPrvPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ByronWalletFromXPrvPostData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.AccountPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.AccountPostData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiSharedWalletPostDataFromAccountPubX
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiSharedWalletPostDataFromAccountPubX
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiSharedWalletPatchData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiSharedWalletPatchData
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiAccountPublicKey
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPutData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPutData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.SettingsPutData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.SettingsPutData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.WalletPutPassphraseOldPassphraseData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.WalletPutPassphraseOldPassphraseData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ByronWalletPutPassphraseData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ByronWalletPutPassphraseData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiMultiDelegationAction
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiMultiDelegationAction
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiStakeKeyIndex
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiStakeKeyIndex
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiSignTransactionPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiSignTransactionPostData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiSerialisedTransaction
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiSerialisedTransaction
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream Cardano.Wallet.Api.Types.ApiSerialisedTransaction
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiTxId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiTxId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.ApiTxId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.ApiTxId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiRegisterPool
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiRegisterPool
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiDeregisterPool
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiDeregisterPool
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiPostPolicyKeyData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiPostPolicyKeyData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiAssetMintBurn
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiAssetMintBurn
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiTokens
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiTokens
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiTokenAmountFingerprint
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiTokenAmountFingerprint
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiTxMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiTxMetadata
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.AddressAmount a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.AddressAmount a)
instance Data.Text.Class.FromText (Cardano.Wallet.Api.Types.AddressAmount Data.Text.Internal.Text)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiSlotReference
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiSlotReference
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiBlockReference
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiBlockReference
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiSlotId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiSlotId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiPostRandomAddressData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiPostRandomAddressData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletMigrationBalance
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletMigrationBalance
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletSignData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletSignData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiPostAccountKeyData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiPostAccountKeyData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiPostAccountKeyDataWithPurpose
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiPostAccountKeyDataWithPurpose
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiPendingSharedWallet
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiPendingSharedWallet
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Api.Types.Iso8601Time)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Api.Types.Iso8601Time)
instance Data.Text.Class.ToText (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Script.ValidationLevel)
instance Data.Text.Class.FromText (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Script.ValidationLevel)
instance Data.Text.Class.FromText (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Derivation.XPrv)
instance GHC.Show.Show (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Derivation.XPrv)
instance GHC.Classes.Eq (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Derivation.XPrv)
instance Data.Text.Class.ToText (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Derivation.XPrv)
instance Data.Text.Class.FromText (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.TokenPolicyId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.TokenName)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.TokenFingerprint)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.AssetLogo)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.AssetLogo)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.AddressDerivation.DerivationIndex)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.AddressDerivation.DerivationIndex)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Transaction.AnyScript)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Transaction.AnyScript)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address.AddressState)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Address.AddressState)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Passphrase.Types.PassphraseHash)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Derivation.XPrv)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Derivation.XPrv)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash.Hash "VerificationKey"))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash.Hash "VerificationKey"))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash.Hash "TokenPolicy"))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash.Hash "TokenPolicy"))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolMetadataGCStatus)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolMetadataGCStatus)
instance (Cardano.Wallet.Primitive.Passphrase.Types.PassphraseMaxLength purpose, Cardano.Wallet.Primitive.Passphrase.Types.PassphraseMinLength purpose) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase purpose))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Passphrase.Types.Passphrase purpose))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Script.ValidationLevel)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Script.ValidationLevel)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.AddressDiscovery.Sequential.AddressPoolGap)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenMap.TokenMap)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenMap.TokenMap)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolId)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletName)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.WalletName)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Settings)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Settings)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.SyncProgress.SyncProgress)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.SyncProgress.SyncProgress)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.UTxO.BoundType)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.UTxO.BoundType)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.SealedTx)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.SealedTx)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.EpochNo)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.EpochNo)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotInEpoch)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotInEpoch)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Slotting.Slot.SlotNo)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Slotting.Slot.SlotNo)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.TokenBundle.TokenBundle)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolOwner)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.PoolOwner)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.StakePoolMetadataUrl)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.StakePoolMetadataHash)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.StakePoolMetadataHash)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.NonWalletCertificate)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.NonWalletCertificate)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Api.TxMetadata.TxMetadata)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Api.TxMetadata.TxMetadata)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.TxIn)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.TxIn)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash.Hash "Tx"))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash.Hash "Tx"))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash.Hash "Datum"))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash.Hash "Datum"))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.Direction)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.Direction)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.TxStatus)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.TxStatus)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.StakePoolMetadata)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.StakePoolMetadata)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.StartTime)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.StartTime)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotLength)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SlotLength)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.EpochLength)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.EpochLength)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.ActiveSlotCoefficient)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash.Hash "Genesis"))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.Types.Hash.Hash "Genesis"))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Script.Cosigner)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Script.Cosigner)
instance (GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index derivation level), GHC.Enum.Bounded (Cardano.Wallet.Primitive.AddressDerivation.Index derivation level)) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.AddressDerivation.Index derivation level))
instance GHC.Enum.Enum (Cardano.Wallet.Primitive.AddressDerivation.Index derivation level) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Wallet.Primitive.AddressDerivation.Index derivation level))
instance Data.Text.Class.ToText (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Script.Cosigner)
instance Data.Text.Class.FromText (Cardano.Wallet.Api.Types.ApiT Cardano.Address.Script.Cosigner)
instance Servant.API.ContentTypes.MimeUnrender Servant.API.ContentTypes.OctetStream (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.SealedTx)
instance Servant.API.ContentTypes.MimeRender Servant.API.ContentTypes.OctetStream (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.SealedTx)
instance Data.Text.Class.FromText a => Web.Internal.HttpApiData.FromHttpApiData (Cardano.Wallet.Api.Types.ApiT a)
instance Data.Text.Class.ToText a => Web.Internal.HttpApiData.ToHttpApiData (Cardano.Wallet.Api.Types.ApiT a)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SmashServer)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.SmashServer)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Address.Script.Script Cardano.Address.Script.KeyHash))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Address.Script.Script Cardano.Address.Script.KeyHash))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Address.Script.Script Cardano.Address.Script.Cosigner))
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT (Cardano.Address.Script.Script Cardano.Address.Script.Cosigner))
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.TxScriptValidity)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.ApiT Cardano.Wallet.Primitive.Types.Tx.TxScriptValidity)
instance Cardano.Wallet.Api.Types.KnownDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState network)
instance Cardano.Wallet.Api.Types.KnownDiscovery (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState network key)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletDiscovery
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletDiscovery
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.ApiPoolId
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.ApiPoolId
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.MinWithdrawal
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.MinWithdrawal
instance Data.Text.Class.ToText Cardano.Wallet.Api.Types.Iso8601Time
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.Iso8601Time
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.Iso8601Time
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.Iso8601Time
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiErrorCode
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiScriptTemplateEntry
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiScriptTemplateEntry
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.XPubOrSelf
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.XPubOrSelf
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiAccountKeyShared
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiAccountKeyShared
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiAccountKey
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiAccountKey
instance Data.Text.Class.ToText Cardano.Wallet.Api.Types.KeyFormat
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.KeyFormat
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.KeyFormat
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.KeyFormat
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.KeyFormat
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.KeyFormat
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiVerificationKeyShared
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiVerificationKeyShared
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiPolicyKey
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiPolicyKey
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiVerificationKeyShelley
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiVerificationKeyShelley
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNetworkClock
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNetworkClock
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNtpStatus
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNtpStatus
instance Data.Text.Class.ToText Cardano.Wallet.Api.Types.NtpSyncingStatus
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.NtpSyncingStatus
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.NtpSyncingStatus
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.NtpSyncingStatus
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletMode
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletMode
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiNetworkInfo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiNetworkInfo
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiEra
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiEra
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiBlockInfo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiBlockInfo
instance Web.Internal.HttpApiData.FromHttpApiData Cardano.Wallet.Api.Types.ApiAddressInspectData
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.Wallet.Api.Types.ApiAddressInspectData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiAddressInspect
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiAddressInspect
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Wallet.Api.Types.AddressAmountNoAssets a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.Api.Types.AddressAmountNoAssets a)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiFee
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiFee
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiValidityInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiValidityInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiValidityBound
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiValidityBound
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiStakePoolMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiStakePoolFlag
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiStakePoolFlag
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletDelegationStatus
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletPassphraseInfo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletPassphraseInfo
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiWalletBalance
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiWalletBalance
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.AnyAddress
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.AnyAddress
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.AnyAddress
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiCredential
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiCredential
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiMetadataError
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiMetadataError
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.ApiMaintenanceActionPostData
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.ApiMaintenanceActionPostData
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.Api.Types.MaintenanceAction
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Api.Types.MaintenanceAction
instance Data.Text.Class.FromText Cardano.Wallet.Api.Types.ByronWalletStyle
instance Data.Text.Class.ToText Cardano.Wallet.Api.Types.ByronWalletStyle


-- | Conversion functions which don't have error handling. These are quite
--   convenient to use for jobs like testing, debugging, etc.
--   
--   But these "unsafe" functions should not be used in application code,
--   unless it's certain that the error case will never happen.
module Cardano.Wallet.Unsafe

-- | Take the right side of an <a>Either</a> value. Crash badly if it was a
--   left.
unsafeRight :: (Buildable e, HasCallStack) => Either e a -> a

-- | Decode an hex-encoded <a>ByteString</a> into raw bytes, or fail.
unsafeFromHex :: forall b. (HasCallStack, ByteArray b) => ByteString -> b

-- | Decode hex-encoded <a>Text</a> into a <a>ByteString</a>, or fail. This
--   variant of <a>unsafeFromHex</a> may be easier to use because it's not
--   polymorphic.
unsafeFromHexText :: HasCallStack => Text -> ByteString

-- | Decode a base64-encoded <a>ByteString</a> into raw bytes, or fail.
unsafeFromBase64 :: HasCallStack => ByteString -> ByteString

-- | Load a hex string from file. Any non-hexadecimal characters are
--   ignored.
unsafeFromHexFile :: HasCallStack => FilePath -> IO ByteString

-- | Decode a bech32-encoded <a>Text</a> into an <a>Address</a>, or fail.
unsafeDecodeAddress :: forall n. (HasCallStack, DecodeAddress n) => Text -> Address

-- | Run a decoder on a hex-encoded <a>ByteString</a>, or fail.
unsafeDecodeHex :: HasCallStack => Get a -> ByteString -> a

-- | Decode the given data-type from a textual representation, or fail.
unsafeFromText :: (FromText a, HasCallStack) => Text -> a

-- | Run an <a>ExceptT</a> and throws the error if any. This makes sense
--   only if called after checking for an invariant or, after ensuring that
--   preconditions for meeting the underlying error have been discarded.
unsafeRunExceptT :: (MonadFail m, Show e) => ExceptT e m a -> m a

-- | Build a <a>XPrv</a> from a bytestring
unsafeXPrv :: HasCallStack => ByteString -> XPrv

-- | Build a <a>XPub</a> from a bytestring
unsafeXPub :: HasCallStack => ByteString -> XPub

-- | CBOR deserialise without error handling - handy for prototypes or
--   testing.
unsafeDeserialiseCbor :: HasCallStack => (forall s. Decoder s a) -> ByteString -> a

-- | Load the data part of a bech32-encoded string from file. These files
--   often come from <tt>jcli</tt>. Only the first line of the file is
--   read.
unsafeBech32DecodeFile :: HasCallStack => FilePath -> IO ByteString

-- | Get the data part of a bech32-encoded string, ignoring the
--   human-readable part.
unsafeBech32Decode :: HasCallStack => Text -> ByteString
unsafeMkPercentage :: HasCallStack => Rational -> Percentage

-- | Convert an integer type of any range to a machine word.
--   
--   Only use it for values which have come from the ledger, and should fit
--   in the given type, according to the spec.
--   
--   If this conversion would under/overflow, there is not much we can do
--   except to hastily exit.
unsafeIntToWord :: forall from to. (HasCallStack, Integral from, Bounded to, Integral to, Typeable from, Typeable to, Show from) => from -> to

-- | A dummy <tt>SomeMnemonic</tt> for testing.
--   
--   Could have been named <tt>dummySomeMnemonic</tt>, but this way it
--   sounds more like valid english.
someDummyMnemonic :: forall mw ent csz. (HasCallStack, ValidEntropySize ent, ValidChecksumSize ent csz, ValidMnemonicSentence mw, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Proxy mw -> SomeMnemonic

-- | Build <a>Mnemonic</a> from literals
unsafeMkMnemonic :: forall mw n csz. (ConsistentEntropy n mw csz, EntropySize mw ~ n, HasCallStack) => [Text] -> Mnemonic mw
unsafeMkEntropy :: forall ent csz. (HasCallStack, ValidEntropySize ent, ValidChecksumSize ent csz) => ByteString -> Entropy ent
unsafeMkSomeMnemonicFromEntropy :: forall mw ent csz. (HasCallStack, ValidEntropySize ent, ValidChecksumSize ent csz, ValidMnemonicSentence mw, ent ~ EntropySize mw, mw ~ MnemonicWords ent) => Proxy mw -> ByteString -> SomeMnemonic


-- | A mock metadata-server for testing, metadata requests. Created using
--   the metadata-server Haskell source code as a reference.
module Cardano.Wallet.TokenMetadata.MockServer

-- | Start a metadata server on any random port. See
--   <a>withMetadataServerOptions</a> for running a server with middleware
--   and predefined port.
--   
--   To be used with <tt>queryServerStatic</tt>.
withMetadataServer :: IO (Server MetadataQueryApi) -> (TokenMetadataServer -> IO a) -> IO a

-- | Start a metadata server.
withMetadataServerOptions :: Middleware -> Maybe Port -> IO (Server MetadataQueryApi) -> (TokenMetadataServer -> IO a) -> IO a

-- | Serve a json file.
--   
--   Will filter the json and only serve metadata for the requested
--   subjects.
queryServerStatic :: FilePath -> IO (BatchRequest -> Handler BatchResponse)

-- | Like <a>queryServerStatic</a>, except that the JSON file will be
--   reloaded before every request.
queryServerReloading :: FilePath -> BatchRequest -> Handler BatchResponse

-- | The reverse of subjectToAssetId
assetIdFromSubject :: Subject -> AssetId
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Wallet.TokenMetadata.BatchRequest
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.TokenMetadata.SubjectProperties
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.TokenMetadata.PropertyValue name) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Wallet.TokenMetadata.Property name)
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.TokenMetadata.Signature
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.TokenMetadata.BatchResponse
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.TokenPolicy.AssetLogo
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.TokenPolicy.AssetURL
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Wallet.Primitive.Types.TokenPolicy.AssetDecimals


-- | Shared QuickCheck generators for wallet types.
--   
--   Our convention is to let each test module define its own
--   <tt>Arbitrary</tt> orphans. This module allows for code-reuse where
--   desired, by providing generators.
module Cardano.Wallet.Gen

-- | Generates an arbitrary mnemonic of a size according to the type
--   parameter.
--   
--   E.g: &gt;&gt;&gt; arbitrary = SomeMnemonic <a>$</a> genMnemonic @12
genMnemonic :: forall mw ent csz. (ConsistentEntropy ent mw csz, EntropySize mw ~ ent) => Gen (Mnemonic mw)
genPercentage :: Gen Percentage
shrinkPercentage :: Percentage -> [Percentage]
genLegacyAddress :: Maybe ProtocolMagic -> Gen Address
genBlockHeader :: SlotNo -> Gen BlockHeader
genChainPoint :: Gen ChainPoint
genSlot :: Gen Slot
genActiveSlotCoefficient :: Gen ActiveSlotCoefficient
shrinkActiveSlotCoefficient :: ActiveSlotCoefficient -> [ActiveSlotCoefficient]

-- | Don't generate <i>too</i> large slots
genSlotNo :: Gen SlotNo
shrinkSlotNo :: SlotNo -> [SlotNo]

-- | Generates a <a>TxMetadata</a> with arbitrary levels of nesting.
genNestedTxMetadata :: Gen TxMetadata

-- | Generates a <a>TxMetadata</a> containing only simple values, without
--   nesting.
genSimpleTxMetadata :: Gen TxMetadata
shrinkTxMetadata :: TxMetadata -> [TxMetadata]
genScript :: [a] -> Gen (Script a)
genScriptCosigners :: Gen (Script Cosigner)
genScriptTemplate :: Gen ScriptTemplate
genScriptTemplateEntry :: Gen ApiScriptTemplateEntry
genMockXPub :: Gen XPub
genNatural :: Gen Natural

module Cardano.Wallet.Primitive.Types.Tx.Gen
coarbitraryTxIn :: TxIn -> Gen a -> Gen a
genTx :: Gen Tx
genTxHash :: Gen (Hash "Tx")
genTxIndex :: Gen Word32
genTxIn :: Gen TxIn
genTxInFunction :: Gen a -> Gen (TxIn -> a)
genTxInLargeRange :: Gen TxIn
genTxOut :: Gen TxOut

-- | Generates coins across the full range allowed in a transaction output.
--   
--   This generator has a slight bias towards the limits of the range, but
--   otherwise generates values uniformly across the whole range.
--   
--   This can be useful when testing roundtrip conversions between
--   different types.
genTxOutCoin :: Gen Coin
genTxOutTokenBundle :: Int -> Gen TokenBundle
genTxScriptValidity :: Gen TxScriptValidity
shrinkTx :: Tx -> [Tx]
shrinkTxHash :: Hash "Tx" -> [Hash "Tx"]
shrinkTxIndex :: Word32 -> [Word32]
shrinkTxIn :: TxIn -> [TxIn]
shrinkTxOut :: TxOut -> [TxOut]
shrinkTxOutCoin :: Coin -> [Coin]
shrinkTxScriptValidity :: TxScriptValidity -> [TxScriptValidity]
instance GHC.Show.Show Cardano.Wallet.Primitive.Types.Tx.Gen.TxWithoutId
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Types.Tx.Gen.TxWithoutId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Types.Tx.Gen.TxWithoutId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Types.Tx.Gen.TxWithoutId

module Cardano.Wallet.Primitive.Types.UTxO.Gen
genUTxO :: Gen UTxO
genUTxOLarge :: Gen UTxO
genUTxOLargeN :: Int -> Gen UTxO

-- | Selects up to a given number of entries at random from the given UTxO
--   set.
--   
--   Returns the selected entries and the remaining UTxO set with the
--   entries removed.
selectUTxOEntries :: UTxO -> Int -> Gen ([(TxIn, TxOut)], UTxO)
shrinkUTxO :: UTxO -> [UTxO]

module Cardano.Wallet.CoinSelection.Gen
coarbitraryWalletUTxO :: WalletUTxO -> Gen a -> Gen a
genWalletUTxO :: Gen WalletUTxO
genWalletUTxOFunction :: Gen a -> Gen (WalletUTxO -> a)
genWalletUTxOLargeRange :: Gen WalletUTxO
shrinkWalletUTxO :: WalletUTxO -> [WalletUTxO]

module Cardano.Wallet.Api

-- | The full cardano-wallet API.
type Api n apiPool = Wallets :<|> WalletKeys :<|> Assets :<|> Addresses n :<|> CoinSelections n :<|> ShelleyTransactions n :<|> ShelleyMigrations n :<|> StakePools n apiPool :<|> ByronWallets :<|> ByronAssets :<|> ByronAddresses n :<|> ByronCoinSelections n :<|> ByronTransactions n :<|> ByronMigrations n :<|> Network :<|> Proxy_ :<|> Settings :<|> SMASH :<|> SharedWallets :<|> SharedWalletKeys :<|> SharedAddresses n :<|> SharedTransactions n
type ApiV2 n apiPool = "v2" :> Api n apiPool
type family PostData wallet :: Type
type Wallets = DeleteWallet :<|> GetWallet :<|> ListWallets :<|> PostWallet :<|> PutWallet :<|> PutWalletPassphrase :<|> GetWalletUtxoSnapshot :<|> GetUTxOsStatistics

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteWallet</a>
type DeleteWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> DeleteNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getWallet</a>
type GetWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> Get '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listWallets</a>
type ListWallets = "wallets" :> Get '[JSON] [ApiWallet]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postWallet</a>
type PostWallet = "wallets" :> ReqBody '[JSON] (PostData ApiWallet) :> PostCreated '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/putWallet</a>
type PutWallet = "wallets" :> Capture "walletId" (ApiT WalletId) :> ReqBody '[JSON] WalletPutData :> Put '[JSON] ApiWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/putWalletPassphrase</a>
type PutWalletPassphrase = "wallets" :> Capture "walletId" (ApiT WalletId) :> "passphrase" :> ReqBody '[JSON] WalletPutPassphraseData :> PutNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getUTxOsStatistics</a>
type GetUTxOsStatistics = "wallets" :> Capture "walletId" (ApiT WalletId) :> "statistics" :> "utxos" :> Get '[JSON] ApiUtxoStatistics

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getWalletUtxoSnapshot</a>
type GetWalletUtxoSnapshot = "wallets" :> Capture "walletId" (ApiT WalletId) :> "utxo" :> Get '[JSON] ApiWalletUtxoSnapshot
type WalletKeys = GetWalletKey :<|> SignMetadata :<|> PostAccountKey :<|> GetAccountKey :<|> GetPolicyKey :<|> PostPolicyKey :<|> PostPolicyId

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getWalletKey</a>
type GetWalletKey = "wallets" :> Capture "walletId" (ApiT WalletId) :> "keys" :> Capture "role" (ApiT Role) :> Capture "index" (ApiT DerivationIndex) :> QueryParam "hash" Bool :> Get '[JSON] ApiVerificationKeyShelley

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/signMetadata</a>
type SignMetadata = "wallets" :> Capture "walletId" (ApiT WalletId) :> "signatures" :> Capture "role" (ApiT Role) :> Capture "index" (ApiT DerivationIndex) :> ReqBody '[JSON] ApiWalletSignData :> Post '[OctetStream] ByteString

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postAccountKey</a>
type PostAccountKey = "wallets" :> Capture "walletId" (ApiT WalletId) :> "keys" :> Capture "index" (ApiT DerivationIndex) :> ReqBody '[JSON] ApiPostAccountKeyDataWithPurpose :> PostAccepted '[JSON] ApiAccountKey

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getAccountKey</a>
type GetAccountKey = "wallets" :> Capture "walletId" (ApiT WalletId) :> "keys" :> QueryParam "format" KeyFormat :> Get '[JSON] ApiAccountKey

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getPolicyKey</a>
type GetPolicyKey = "wallets" :> Capture "walletId" (ApiT WalletId) :> "policy-key" :> QueryParam "hash" Bool :> Get '[JSON] ApiPolicyKey

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postPolicyKey</a>
type PostPolicyKey = "wallets" :> Capture "walletId" (ApiT WalletId) :> "policy-key" :> QueryParam "hash" Bool :> ReqBody '[JSON] ApiPostPolicyKeyData :> PostAccepted '[JSON] ApiPolicyKey

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postPolicyId</a>
type PostPolicyId = "wallets" :> Capture "walletId" (ApiT WalletId) :> "policy-id" :> ReqBody '[JSON] ApiPostPolicyIdData :> PostAccepted '[JSON] ApiPolicyId
type Assets = ListAssets :<|> GetAsset :<|> GetAssetDefault

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listAssets</a>
type ListAssets = "wallets" :> Capture "walletId" (ApiT WalletId) :> "assets" :> Get '[JSON] [ApiAsset]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getAsset</a>
type GetAsset = "wallets" :> Capture "walletId" (ApiT WalletId) :> "assets" :> Capture "policyId" (ApiT TokenPolicyId) :> Capture "assetName" (ApiT TokenName) :> Get '[JSON] ApiAsset

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getAssetDefault</a>
type GetAssetDefault = "wallets" :> Capture "walletId" (ApiT WalletId) :> "assets" :> Capture "policyId" (ApiT TokenPolicyId) :> Get '[JSON] ApiAsset
type Addresses n = ListAddresses n :<|> InspectAddress :<|> PostAnyAddress n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listAddresses</a>
type ListAddresses n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "addresses" :> QueryParam "state" (ApiT AddressState) :> Get '[JSON] [ApiAddressT n]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/inspectAddress</a>
type InspectAddress = "addresses" :> Capture "addressId" ApiAddressInspectData :> Get '[JSON] ApiAddressInspect

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postAnyAddress</a>
type PostAnyAddress n = "addresses" :> ReqBody '[JSON] ApiAddressData :> PostAccepted '[JSON] AnyAddress
type CoinSelections n = SelectCoins n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/selectCoins</a>
type SelectCoins n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "coin-selections" :> "random" :> ReqBody '[JSON] (ApiSelectCoinsDataT n) :> Post '[JSON] (ApiCoinSelectionT n)
type ShelleyTransactions n = ConstructTransaction n :<|> SignTransaction n :<|> ListTransactions n :<|> GetTransaction n :<|> DeleteTransaction :<|> CreateTransactionOld n :<|> PostTransactionFeeOld n :<|> BalanceTransaction n :<|> DecodeTransaction n :<|> SubmitTransaction

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/constructTransaction</a>
type ConstructTransaction n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions-construct" :> ReqBody '[JSON] (ApiConstructTransactionDataT n) :> PostAccepted '[JSON] (ApiConstructTransactionT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/signTransaction</a>
type SignTransaction n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions-sign" :> ReqBody '[JSON] ApiSignTransactionPostData :> PostAccepted '[JSON] ApiSerialisedTransaction

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listTransactions</a>
type ListTransactions n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> QueryParam "minWithdrawal" MinWithdrawal :> QueryParam "start" Iso8601Time :> QueryParam "end" Iso8601Time :> QueryParam "order" (ApiT SortOrder) :> QueryFlag "simple-metadata" :> Get '[JSON] [ApiTransactionT n]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getTransaction</a>
type GetTransaction n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> Capture "transactionId" ApiTxId :> QueryFlag "simple-metadata" :> Get '[JSON] (ApiTransactionT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteTransaction</a>
type DeleteTransaction = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> Capture "transactionId" ApiTxId :> DeleteNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postTransaction</a>
type CreateTransactionOld n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> ReqBody '[JSON] (PostTransactionOldDataT n) :> PostAccepted '[JSON] (ApiTransactionT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postTransactionFee</a>
type PostTransactionFeeOld n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "payment-fees" :> ReqBody '[JSON] (PostTransactionFeeOldDataT n) :> PostAccepted '[JSON] ApiFee

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/balanceTransaction</a>
type BalanceTransaction n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions-balance" :> ReqBody '[JSON] (ApiBalanceTransactionPostDataT n) :> PostAccepted '[JSON] ApiSerialisedTransaction

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/decodeTransaction</a>
type DecodeTransaction n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions-decode" :> ReqBody '[JSON] ApiSerialisedTransaction :> PostAccepted '[JSON] (ApiDecodedTransactionT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/submitTransaction</a>
type SubmitTransaction = "wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions-submit" :> ReqBody '[JSON] ApiSerialisedTransaction :> PostAccepted '[JSON] ApiTxId
type StakePools n apiPool = ListStakePools apiPool :<|> JoinStakePool n :<|> QuitStakePool n :<|> DelegationFee :<|> ListStakeKeys n :<|> PostPoolMaintenance :<|> GetPoolMaintenance

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/edge/#operation/listStakePools</a>
type ListStakePools apiPool = "stake-pools" :> QueryParam "stake" (ApiT Coin) :> Get '[JSON] [apiPool]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/joinStakePool</a>
type JoinStakePool n = "stake-pools" :> Capture "stakePoolId" ApiPoolId :> "wallets" :> Capture "walletId" (ApiT WalletId) :> ReqBody '[JSON] ApiWalletPassphrase :> PutAccepted '[JSON] (ApiTransactionT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/quitStakePool</a>
type QuitStakePool n = "stake-pools" :> "*" :> "wallets" :> Capture "walletId" (ApiT WalletId) :> ReqBody '[JSON] ApiWalletPassphrase :> DeleteAccepted '[JSON] (ApiTransactionT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getDelegationFee</a>
type DelegationFee = "wallets" :> Capture "walletId" (ApiT WalletId) :> "delegation-fees" :> Get '[JSON] ApiFee
type ListStakeKeys n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "stake-keys" :> Get '[JSON] (ApiStakeKeysT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postPoolMaintenance</a>
type PostPoolMaintenance = "stake-pools" :> "maintenance-actions" :> ReqBody '[JSON] ApiMaintenanceActionPostData :> PostNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getPoolMaintenance</a>
type GetPoolMaintenance = "stake-pools" :> "maintenance-actions" :> Get '[JSON] ApiMaintenanceAction
type ShelleyMigrations n = CreateShelleyWalletMigrationPlan n :<|> MigrateShelleyWallet n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/migrateShelleyWallet</a>
type MigrateShelleyWallet n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "migrations" :> ReqBody '[JSON] (ApiWalletMigrationPostDataT n "user") :> PostAccepted '[JSON] (NonEmpty (ApiTransactionT n))

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/createShelleyWalletMigrationPlan</a>
type CreateShelleyWalletMigrationPlan n = "wallets" :> Capture "walletId" (ApiT WalletId) :> "migrations" :> "plan" :> ReqBody '[JSON] (ApiWalletMigrationPlanPostDataT n) :> PostAccepted '[JSON] (ApiWalletMigrationPlan n)
type Settings = PutSettings :<|> GetSettings
type PutSettings = "settings" :> ReqBody '[JSON] SettingsPutData :> PutNoContent
type GetSettings = "settings" :> Get '[JSON] (ApiT Settings)
type ByronWallets = PostByronWallet :<|> DeleteByronWallet :<|> GetByronWallet :<|> ListByronWallets :<|> PutByronWallet :<|> GetByronWalletUtxoSnapshot :<|> GetByronUTxOsStatistics :<|> PutByronWalletPassphrase

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteByronWallet</a>
type DeleteByronWallet = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> DeleteNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getByronWallet</a>
type GetByronWallet = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> Get '[JSON] ApiByronWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listByronWallets</a>
type ListByronWallets = "byron-wallets" :> Get '[JSON] [ApiByronWallet]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postByronWallet</a>
type PostByronWallet = "byron-wallets" :> ReqBody '[JSON] (PostData ApiByronWallet) :> PostCreated '[JSON] ApiByronWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/putByronWallet</a>
type PutByronWallet = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> ReqBody '[JSON] WalletPutData :> Put '[JSON] ApiByronWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getByronUTxOsStatistics</a>
type GetByronUTxOsStatistics = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "statistics" :> "utxos" :> Get '[JSON] ApiUtxoStatistics

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getByronWalletUtxoSnapshot</a>
type GetByronWalletUtxoSnapshot = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "utxo" :> Get '[JSON] ApiWalletUtxoSnapshot

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/putByronWalletPassphrase</a>
type PutByronWalletPassphrase = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "passphrase" :> ReqBody '[JSON] ByronWalletPutPassphraseData :> PutNoContent
type ByronAssets = ListByronAssets :<|> GetByronAsset :<|> GetByronAssetDefault

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listByronAssets</a>
type ListByronAssets = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "assets" :> Get '[JSON] [ApiAsset]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getByronAsset</a>
type GetByronAsset = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "assets" :> Capture "policyId" (ApiT TokenPolicyId) :> Capture "assetName" (ApiT TokenName) :> Get '[JSON] ApiAsset

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getByronAssetDefault</a>
type GetByronAssetDefault = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "assets" :> Capture "policyId" (ApiT TokenPolicyId) :> Get '[JSON] ApiAsset
type ByronAddresses n = PostByronAddress n :<|> PutByronAddress n :<|> PutByronAddresses n :<|> ListByronAddresses n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/createAddress</a>
type PostByronAddress n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "addresses" :> ReqBody '[JSON] ApiPostRandomAddressData :> PostCreated '[JSON] (ApiAddressT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/restoreAddress</a>
type PutByronAddress n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "addresses" :> Capture "addressId" (ApiAddressIdT n) :> PutNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/importAddresses</a>
type PutByronAddresses n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "addresses" :> ReqBody '[JSON] (ApiPutAddressesDataT n) :> PutNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listByronAddresses</a>
type ListByronAddresses n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "addresses" :> QueryParam "state" (ApiT AddressState) :> Get '[JSON] [ApiAddressT n]
type ByronCoinSelections n = ByronSelectCoins n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/byronSelectCoins</a>
type ByronSelectCoins n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "coin-selections" :> "random" :> ReqBody '[JSON] (ApiSelectCoinsDataT n) :> Post '[JSON] (ApiCoinSelectionT n)
type ByronTransactions n = ConstructByronTransaction n :<|> SignByronTransaction n :<|> ListByronTransactions n :<|> GetByronTransaction n :<|> DeleteByronTransaction :<|> CreateByronTransactionOld n :<|> PostByronTransactionFeeOld n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/constructByronTransaction</a>
type ConstructByronTransaction n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions-construct" :> ReqBody '[JSON] (ApiConstructTransactionDataT n) :> PostAccepted '[JSON] (ApiConstructTransactionT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/signByronTransaction</a>
type SignByronTransaction n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions-sign" :> ReqBody '[JSON] ApiSignTransactionPostData :> PostAccepted '[JSON] ApiSerialisedTransaction

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listByronTransactions</a>
type ListByronTransactions n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> QueryParam "start" Iso8601Time :> QueryParam "end" Iso8601Time :> QueryParam "order" (ApiT SortOrder) :> Get '[JSON] [ApiTransactionT n]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getByronTransaction</a>
type GetByronTransaction n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> Capture "transactionId" ApiTxId :> Get '[JSON] (ApiTransactionT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteByronTransaction</a>
type DeleteByronTransaction = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> Capture "transactionId" ApiTxId :> DeleteNoContent

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postByronTransaction</a>
type CreateByronTransactionOld n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions" :> ReqBody '[JSON] (PostTransactionOldDataT n) :> PostAccepted '[JSON] (ApiTransactionT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postByronTransactionFee</a>
type PostByronTransactionFeeOld n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "payment-fees" :> ReqBody '[JSON] (PostTransactionFeeOldDataT n) :> PostAccepted '[JSON] ApiFee
type ByronMigrations n = CreateByronWalletMigrationPlan n :<|> MigrateByronWallet n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/migrateByronWallet</a>
type MigrateByronWallet n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "migrations" :> ReqBody '[JSON] (ApiWalletMigrationPostDataT n "lenient") :> PostAccepted '[JSON] (NonEmpty (ApiTransactionT n))

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/createByronWalletMigrationPlan</a>
type CreateByronWalletMigrationPlan n = "byron-wallets" :> Capture "walletId" (ApiT WalletId) :> "migrations" :> "plan" :> ReqBody '[JSON] (ApiWalletMigrationPlanPostDataT n) :> PostAccepted '[JSON] (ApiWalletMigrationPlan n)
type Network = GetNetworkInformation :<|> GetNetworkParameters :<|> GetNetworkClock
type GetNetworkInformation = "network" :> "information" :> Get '[JSON] ApiNetworkInformation
type GetNetworkParameters = "network" :> "parameters" :> Get '[JSON] ApiNetworkParameters
type GetNetworkClock = "network" :> "clock" :> QueryFlag "forceNtpCheck" :> Get '[JSON] ApiNetworkClock
type SMASH = GetCurrentSMASHHealth
type GetCurrentSMASHHealth = "smash" :> "health" :> QueryParam "url" (ApiT SmashServer) :> Get '[JSON] ApiHealthCheck
type SharedWallets = PostSharedWallet :<|> GetSharedWallet :<|> ListSharedWallets :<|> PatchSharedWalletInPayment :<|> PatchSharedWalletInDelegation :<|> DeleteSharedWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postSharedWallet</a>
type PostSharedWallet = "shared-wallets" :> ReqBody '[JSON] ApiSharedWalletPostData :> PostCreated '[JSON] ApiSharedWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getSharedWallet</a>
type GetSharedWallet = "shared-wallets" :> Capture "walletId" (ApiT WalletId) :> Get '[JSON] ApiSharedWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listSharedWallets</a>
type ListSharedWallets = "shared-wallets" :> Get '[JSON] [ApiSharedWallet]

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/patchSharedWalletInPayment</a>
type PatchSharedWalletInPayment = "shared-wallets" :> Capture "walletId" (ApiT WalletId) :> "payment-script-template" :> ReqBody '[JSON] ApiSharedWalletPatchData :> Patch '[JSON] ApiSharedWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/patchSharedWalletInDelegation</a>
type PatchSharedWalletInDelegation = "shared-wallets" :> Capture "walletId" (ApiT WalletId) :> "delegation-script-template" :> ReqBody '[JSON] ApiSharedWalletPatchData :> Patch '[JSON] ApiSharedWallet

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/deleteSharedWallet</a>
type DeleteSharedWallet = "shared-wallets" :> Capture "walletId" (ApiT WalletId) :> DeleteNoContent
type SharedWalletKeys = GetSharedWalletKey :<|> PostAccountKeyShared :<|> GetAccountKeyShared

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getSharedWalletKey</a>
type GetSharedWalletKey = "shared-wallets" :> Capture "walletId" (ApiT WalletId) :> "keys" :> Capture "role" (ApiT Role) :> Capture "index" (ApiT DerivationIndex) :> QueryParam "hash" Bool :> Get '[JSON] ApiVerificationKeyShared

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postAccountKeyShared</a>
type PostAccountKeyShared = "shared-wallets" :> Capture "walletId" (ApiT WalletId) :> "keys" :> Capture "index" (ApiT DerivationIndex) :> ReqBody '[JSON] ApiPostAccountKeyData :> PostAccepted '[JSON] ApiAccountKeyShared

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/getAccountKeyShared</a>
type GetAccountKeyShared = "shared-wallets" :> Capture "walletId" (ApiT WalletId) :> "keys" :> QueryParam "format" KeyFormat :> Get '[JSON] ApiAccountKeyShared
type SharedAddresses n = ListSharedAddresses n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/listSharedAddresses</a>
type ListSharedAddresses n = "shared-wallets" :> Capture "walletId" (ApiT WalletId) :> "addresses" :> QueryParam "state" (ApiT AddressState) :> Get '[JSON] [ApiAddressT n]
type SharedTransactions n = ConstructSharedTransaction n :<|> DecodeSharedTransaction n

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/constructSharedTransaction</a>
type ConstructSharedTransaction n = "shared-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions-construct" :> ReqBody '[JSON] (ApiConstructTransactionDataT n) :> PostAccepted '[JSON] (ApiConstructTransactionT n)

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/decodeSharedTransaction</a>
type DecodeSharedTransaction n = "shared-wallets" :> Capture "walletId" (ApiT WalletId) :> "transactions-decode" :> ReqBody '[JSON] ApiSerialisedTransaction :> PostAccepted '[JSON] (ApiDecodedTransactionT n)
type Proxy_ = PostExternalTransaction

-- | 
--   <a>https://input-output-hk.github.io/cardano-wallet/api/#operation/postExternalTransaction</a>
type PostExternalTransaction = "proxy" :> "transactions" :> ReqBody '[OctetStream] (ApiT SealedTx) :> PostAccepted '[JSON] ApiTxId
data ApiLayer s (k :: Depth -> Type -> Type)
ApiLayer :: Tracer IO TxSubmitLog -> Tracer IO (WorkerLog WalletId WalletWorkerLog) -> (Block, NetworkParameters) -> NetworkLayer IO Block -> TransactionLayer k SealedTx -> DBFactory IO s k -> WorkerRegistry WalletId (DBLayer IO s k) -> Concierge IO WalletLock -> TokenMetadataClient IO -> ApiLayer s (k :: Depth -> Type -> Type)
type HasWorkerRegistry s k ctx = (HasType (WorkerRegistry WalletId (DBLayer IO s k)) ctx, HasWorkerCtx (DBLayer IO s k) ctx, WorkerKey ctx ~ WalletId, WorkerMsg ctx ~ WalletWorkerLog)
workerRegistry :: forall s k ctx. HasWorkerRegistry s k ctx => Lens' ctx (WorkerRegistry WalletId (DBLayer IO s k))

-- | Locks that are held by the wallet in order to enforce sequential
--   execution of some API actions. Used with
--   <a>Control.Concurrent.Concierge</a>.
data WalletLock
PostTransactionOld :: WalletId -> WalletLock
walletLocks :: forall ctx. HasType (Concierge IO WalletLock) ctx => Lens' ctx (Concierge IO WalletLock)
type HasDBFactory s k = HasType (DBFactory IO s k)
dbFactory :: forall s k ctx. HasDBFactory s k ctx => Lens' ctx (DBFactory IO s k)
tokenMetadataClient :: forall ctx. HasTokenMetadataClient ctx => Lens' ctx (TokenMetadataClient IO)
type HasTokenMetadataClient = HasType (TokenMetadataClient IO)
instance GHC.Show.Show Cardano.Wallet.Api.WalletLock
instance GHC.Classes.Ord Cardano.Wallet.Api.WalletLock
instance GHC.Classes.Eq Cardano.Wallet.Api.WalletLock
instance GHC.Generics.Generic (Cardano.Wallet.Api.ApiLayer s k)
instance Cardano.Wallet.Registry.HasWorkerCtx (Cardano.Wallet.DB.DBLayer GHC.Types.IO s k) (Cardano.Wallet.Api.ApiLayer s k)


-- | Type-safe endpoint accessors for the wallet API. Under normal
--   circumstances, one would prefer to use <tt>WalletClient</tt> from
--   <a>Client</a> and not to bother with endpoints at all.
--   
--   Yet, in some cases (like in black-box testing), one could want to
--   purposely send malformed requests to specific endpoints. Thus, this
--   module facilitates the construction of valid endpoints that'd be
--   accepted by the server, and for which, users are free to send all sort
--   of data as payload, valid or invalid.
--   
--   This module is meant to be used via qualified imports and with
--   type-applications since all exposed functions are type ambiguous in a
--   variable <tt>style</tt> of type <a>WalletStyle</a>.
--   
--   <pre>
--   import qualified Cardano.Wallet.Api.Link as Link
--   </pre>
--   
--   For examples:
--   
--   <pre>
--   &gt;&gt;&gt; Link.deleteWallet @'Shelley myWallet
--   ( "DELETE", "/v2/wallets/2512a00e9653fe49a44a5886202e24d77eeb998f" )
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Link.getWallet @('Byron 'Icarus) myWallet
--   ( "GET", "/v2/byron-wallets/2512a00e9653fe49a44a5886202e24d77eeb998f" )
--   </pre>
module Cardano.Wallet.Api.Link
deleteWallet :: forall (style :: WalletStyle) w. (Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
getWallet :: forall (style :: WalletStyle) w. (Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
listWallets :: forall (style :: WalletStyle). Discriminate style => (Method, Text)
postWallet :: PostWallet style => (Method, Text)
putWallet :: forall (style :: WalletStyle) w. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
putWalletPassphrase :: forall (style :: WalletStyle) w. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
getWalletUtxoSnapshot :: forall (style :: WalletStyle) w. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
getUTxOsStatistics :: forall (style :: WalletStyle) w. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
createMigrationPlan :: forall (style :: WalletStyle) w. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
migrateWallet :: forall (style :: WalletStyle) w. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
getWalletKey :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> Role -> DerivationIndex -> Maybe Bool -> (Method, Text)
signMetadata :: forall w. HasType (ApiT WalletId) w => w -> Role -> DerivationIndex -> (Method, Text)
postAccountKey :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> DerivationIndex -> (Method, Text)
getAccountKey :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> Maybe KeyFormat -> (Method, Text)
getPolicyKey :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> Maybe Bool -> (Method, Text)
postPolicyKey :: forall (style :: WalletStyle) w. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w) => w -> Maybe Bool -> (Method, Text)
postPolicyId :: forall (style :: WalletStyle) w. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
postRandomAddress :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
putRandomAddresses :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
listAddresses :: forall style w. (HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
listAddresses' :: forall style w. (HasType (ApiT WalletId) w, Discriminate style) => w -> Maybe AddressState -> (Method, Text)
inspectAddress :: ApiAddressInspectData -> (Method, Text)
postAnyAddress :: (Method, Text)
selectCoins :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
listAssets :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
getAsset :: forall w. HasType (ApiT WalletId) w => w -> TokenPolicyId -> TokenName -> (Method, Text)
listByronAssets :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
getByronAsset :: forall w. HasType (ApiT WalletId) w => w -> TokenPolicyId -> TokenName -> (Method, Text)
createTransactionOld :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
listTransactions :: forall (style :: WalletStyle) w. (Discriminate style, HasType (ApiT WalletId) w) => w -> (Method, Text)
listTransactions' :: forall (style :: WalletStyle) w. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w) => w -> Maybe Natural -> Maybe Iso8601Time -> Maybe Iso8601Time -> Maybe SortOrder -> (Method, Text)
getTransactionFeeOld :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
deleteTransaction :: forall (style :: WalletStyle) w t. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w, HasType (ApiT (Hash "Tx")) t) => w -> t -> (Method, Text)
getTransaction :: forall (style :: WalletStyle) w t. (HasCallStack, Discriminate style, HasType (ApiT WalletId) w, HasType (ApiT (Hash "Tx")) t) => w -> t -> (Method, Text)
createUnsignedTransaction :: forall style w. (HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
signTransaction :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
balanceTransaction :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
decodeTransaction :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
submitTransaction :: forall style w. (HasCallStack, HasType (ApiT WalletId) w, Discriminate style) => w -> (Method, Text)
listStakePools :: Maybe Coin -> (Method, Text)
listStakeKeys :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
joinStakePool :: forall s w. (HasType (ApiT PoolId) s, HasType (ApiT WalletId) w) => s -> w -> (Method, Text)
quitStakePool :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
getDelegationFee :: forall w. HasType (ApiT WalletId) w => w -> (Method, Text)
postPoolMaintenance :: (Method, Text)
getPoolMaintenance :: (Method, Text)
getNetworkInfo :: (Method, Text)
getNetworkParams :: (Method, Text)
getNetworkClock :: (Method, Text)
getNetworkClock' :: Bool -> (Method, Text)
postExternalTransaction :: (Method, Text)
putSettings :: (Method, Text)
getSettings :: (Method, Text)
getCurrentSMASHHealth :: (Method, Text)
patchSharedWallet :: forall w. HasType (ApiT WalletId) w => w -> CredentialType -> (Method, Text)
class PostWallet (style :: WalletStyle)
class Discriminate (style :: WalletStyle)
instance forall k1 (m :: k1). Servant.API.Verbs.ReflectMethod m => Cardano.Wallet.Api.Link.HasVerb (Servant.API.Verbs.NoContentVerb m)
instance forall k1 (m :: k1) (s :: GHC.Types.Nat) (ct :: [*]) a. Servant.API.Verbs.ReflectMethod m => Cardano.Wallet.Api.Link.HasVerb (Servant.API.Verbs.Verb m s ct a)
instance Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (path Servant.API.Sub.:> sub)
instance Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (Servant.API.Capture.Capture param t Servant.API.Sub.:> sub)
instance Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (Servant.API.ReqBody.ReqBody a b Servant.API.Sub.:> sub)
instance Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (Servant.API.QueryParam.QueryParam a b Servant.API.Sub.:> sub)
instance Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> sub)
instance Cardano.Wallet.Api.Link.HasVerb sub => Cardano.Wallet.Api.Link.HasVerb (Servant.API.Header.Header' opts name ty Servant.API.Sub.:> sub)
instance Cardano.Wallet.Api.Link.Discriminate 'Cardano.Wallet.Api.Types.Shelley
instance Cardano.Wallet.Api.Link.Discriminate 'Cardano.Wallet.Api.Types.Byron
instance Cardano.Wallet.Api.Link.Discriminate 'Cardano.Wallet.Api.Types.Shared
instance Cardano.Wallet.Api.Link.PostWallet 'Cardano.Wallet.Api.Types.Shelley
instance Cardano.Wallet.Api.Link.PostWallet 'Cardano.Wallet.Api.Types.Byron
instance Cardano.Wallet.Api.Link.PostWallet 'Cardano.Wallet.Api.Types.Shared


-- | This module provides a half-typed Servant client for the
--   cardano-wallet V2 API.
--   
--   The functions in this module can be run with
--   "Servant.Client.runClientM".
module Cardano.Wallet.Api.Client

-- | This data type encapsulates the client functions for all endpoints of
--   the cardano-wallet V2 API.
data WalletClient wallet
WalletClient :: (ApiT WalletId -> ClientM ()) -> (ApiT WalletId -> ClientM wallet) -> (ApiT WalletId -> ClientM ApiUtxoStatistics) -> (ApiT WalletId -> ClientM ApiWalletUtxoSnapshot) -> ClientM [wallet] -> (PostData wallet -> ClientM wallet) -> (ApiT WalletId -> WalletPutData -> ClientM wallet) -> (ApiT WalletId -> WalletPutPassphraseFormat wallet -> ClientM NoContent) -> WalletClient wallet
[$sel:deleteWallet:WalletClient] :: WalletClient wallet -> ApiT WalletId -> ClientM ()
[$sel:getWallet:WalletClient] :: WalletClient wallet -> ApiT WalletId -> ClientM wallet
[$sel:getWalletUtxoStatistics:WalletClient] :: WalletClient wallet -> ApiT WalletId -> ClientM ApiUtxoStatistics
[$sel:getWalletUtxoSnapshot:WalletClient] :: WalletClient wallet -> ApiT WalletId -> ClientM ApiWalletUtxoSnapshot
[$sel:listWallets:WalletClient] :: WalletClient wallet -> ClientM [wallet]
[$sel:postWallet:WalletClient] :: WalletClient wallet -> PostData wallet -> ClientM wallet
[$sel:putWallet:WalletClient] :: WalletClient wallet -> ApiT WalletId -> WalletPutData -> ClientM wallet
[$sel:putWalletPassphrase:WalletClient] :: WalletClient wallet -> ApiT WalletId -> WalletPutPassphraseFormat wallet -> ClientM NoContent

-- | Produces a <a>WalletClient</a> working against the /wallets API.
walletClient :: WalletClient ApiWallet

-- | Produces a <a>WalletClient</a> working against the /wallets API.
byronWalletClient :: WalletClient ApiByronWallet
data TransactionClient
TransactionClient :: (ApiT WalletId -> Maybe Iso8601Time -> Maybe Iso8601Time -> Maybe (ApiT SortOrder) -> Bool -> ClientM [ApiTransactionT Value]) -> (ApiT WalletId -> ApiSignTransactionPostData -> ClientM ApiSerialisedTransaction) -> (ApiT WalletId -> PostTransactionOldDataT Value -> ClientM (ApiTransactionT Value)) -> (ApiT WalletId -> PostTransactionFeeOldDataT Value -> ClientM ApiFee) -> (ApiBytesT 'Base64 SerialisedTx -> ClientM ApiTxId) -> (ApiT WalletId -> ApiTxId -> ClientM NoContent) -> (ApiT WalletId -> ApiTxId -> TxMetadataSchema -> ClientM (ApiTransactionT Value)) -> (ApiT WalletId -> ApiConstructTransactionDataT Value -> ClientM (ApiConstructTransactionT Value)) -> (ApiT WalletId -> ApiBalanceTransactionPostDataT Value -> ClientM ApiSerialisedTransaction) -> (ApiT WalletId -> ApiSerialisedTransaction -> ClientM (ApiDecodedTransactionT Value)) -> (ApiT WalletId -> ApiSerialisedTransaction -> ClientM ApiTxId) -> TransactionClient
[$sel:listTransactions:TransactionClient] :: TransactionClient -> ApiT WalletId -> Maybe Iso8601Time -> Maybe Iso8601Time -> Maybe (ApiT SortOrder) -> Bool -> ClientM [ApiTransactionT Value]
[$sel:signTransaction:TransactionClient] :: TransactionClient -> ApiT WalletId -> ApiSignTransactionPostData -> ClientM ApiSerialisedTransaction
[$sel:postTransaction:TransactionClient] :: TransactionClient -> ApiT WalletId -> PostTransactionOldDataT Value -> ClientM (ApiTransactionT Value)
[$sel:postTransactionFee:TransactionClient] :: TransactionClient -> ApiT WalletId -> PostTransactionFeeOldDataT Value -> ClientM ApiFee
[$sel:postExternalTransaction:TransactionClient] :: TransactionClient -> ApiBytesT 'Base64 SerialisedTx -> ClientM ApiTxId
[$sel:deleteTransaction:TransactionClient] :: TransactionClient -> ApiT WalletId -> ApiTxId -> ClientM NoContent
[$sel:getTransaction:TransactionClient] :: TransactionClient -> ApiT WalletId -> ApiTxId -> TxMetadataSchema -> ClientM (ApiTransactionT Value)
[$sel:constructTransaction:TransactionClient] :: TransactionClient -> ApiT WalletId -> ApiConstructTransactionDataT Value -> ClientM (ApiConstructTransactionT Value)
[$sel:balanceTransaction:TransactionClient] :: TransactionClient -> ApiT WalletId -> ApiBalanceTransactionPostDataT Value -> ClientM ApiSerialisedTransaction
[$sel:decodeTransaction:TransactionClient] :: TransactionClient -> ApiT WalletId -> ApiSerialisedTransaction -> ClientM (ApiDecodedTransactionT Value)
[$sel:submitTransaction:TransactionClient] :: TransactionClient -> ApiT WalletId -> ApiSerialisedTransaction -> ClientM ApiTxId

-- | Produces a 'TransactionClient t' working against the /wallets API.
transactionClient :: TransactionClient

-- | Produces a 'TransactionClient n' working against the /byron-wallets
--   API.
byronTransactionClient :: TransactionClient
data AddressClient
AddressClient :: (ApiT WalletId -> Maybe (ApiT AddressState) -> ClientM [Value]) -> (Text -> ClientM Value) -> (ApiT WalletId -> ApiPostRandomAddressData -> ClientM (ApiAddressT Value)) -> (ApiT WalletId -> ApiAddressIdT Value -> ClientM NoContent) -> (ApiT WalletId -> ApiPutAddressesDataT Value -> ClientM NoContent) -> AddressClient
[$sel:listAddresses:AddressClient] :: AddressClient -> ApiT WalletId -> Maybe (ApiT AddressState) -> ClientM [Value]
[$sel:inspectAddress:AddressClient] :: AddressClient -> Text -> ClientM Value
[$sel:postRandomAddress:AddressClient] :: AddressClient -> ApiT WalletId -> ApiPostRandomAddressData -> ClientM (ApiAddressT Value)
[$sel:putRandomAddress:AddressClient] :: AddressClient -> ApiT WalletId -> ApiAddressIdT Value -> ClientM NoContent
[$sel:putRandomAddresses:AddressClient] :: AddressClient -> ApiT WalletId -> ApiPutAddressesDataT Value -> ClientM NoContent

-- | Produces an 'AddressClient n' working against the /wallets API
addressClient :: AddressClient

-- | Produces an 'AddressClient n' working against the /wallets API
byronAddressClient :: AddressClient
data StakePoolClient apiPool
StakePoolClient :: (Maybe (ApiT Coin) -> ClientM [apiPool]) -> (ApiPoolId -> ApiT WalletId -> ApiWalletPassphrase -> ClientM (ApiTransactionT Value)) -> (ApiT WalletId -> ApiWalletPassphrase -> ClientM (ApiTransactionT Value)) -> StakePoolClient apiPool
[$sel:listPools:StakePoolClient] :: StakePoolClient apiPool -> Maybe (ApiT Coin) -> ClientM [apiPool]
[$sel:joinStakePool:StakePoolClient] :: StakePoolClient apiPool -> ApiPoolId -> ApiT WalletId -> ApiWalletPassphrase -> ClientM (ApiTransactionT Value)
[$sel:quitStakePool:StakePoolClient] :: StakePoolClient apiPool -> ApiT WalletId -> ApiWalletPassphrase -> ClientM (ApiTransactionT Value)

-- | Produces an 'StakePoolsClient n' working against the /stake-pools API
stakePoolClient :: forall apiPool. FromJSON apiPool => StakePoolClient apiPool
data NetworkClient
NetworkClient :: ClientM ApiNetworkInformation -> ClientM ApiNetworkParameters -> (Bool -> ClientM ApiNetworkClock) -> NetworkClient
[$sel:networkInformation:NetworkClient] :: NetworkClient -> ClientM ApiNetworkInformation
[$sel:networkParameters:NetworkClient] :: NetworkClient -> ClientM ApiNetworkParameters
[$sel:networkClock:NetworkClient] :: NetworkClient -> Bool -> ClientM ApiNetworkClock

-- | Produces a <a>NetworkClient</a>
networkClient :: NetworkClient


-- | HTTP-client(s) for fetching stake pool metadata from remote servers
--   (directly from pool operators, or from smash).
module Cardano.Pool.Metadata
fetchFromRemote :: Tracer IO StakePoolMetadataFetchLog -> [UrlBuilder] -> Manager -> PoolId -> StakePoolMetadataUrl -> StakePoolMetadataHash -> IO (Maybe StakePoolMetadata)
data StakePoolMetadataFetchLog
MsgFetchPoolMetadata :: StakePoolMetadataHash -> URI -> StakePoolMetadataFetchLog
MsgFetchPoolMetadataSuccess :: StakePoolMetadataHash -> StakePoolMetadata -> StakePoolMetadataFetchLog
MsgFetchPoolMetadataFailure :: StakePoolMetadataHash -> String -> StakePoolMetadataFetchLog
MsgFetchPoolMetadataFallback :: URI -> Bool -> StakePoolMetadataFetchLog
MsgFetchSMASH :: URI -> StakePoolMetadataFetchLog
MsgFetchDelistedPoolsFailure :: String -> StakePoolMetadataFetchLog
MsgFetchDelistedPoolsSuccess :: [PoolId] -> StakePoolMetadataFetchLog
MsgFetchHealthCheckFailure :: String -> StakePoolMetadataFetchLog
MsgFetchHealthCheckSuccess :: HealthStatusSMASH -> StakePoolMetadataFetchLog
fetchDelistedPools :: Tracer IO StakePoolMetadataFetchLog -> URI -> Manager -> IO (Maybe [PoolId])

-- | Gets the health status from the SMASH server. Returns <tt>Nothing</tt>
--   if the server is unreachable.
healthCheck :: Tracer IO StakePoolMetadataFetchLog -> URI -> Manager -> IO (Maybe HealthStatusSMASH)
isHealthyStatus :: HealthStatusSMASH -> Bool

-- | Convert the result of <tt>healthCheck</tt>, which represents the
--   server response to our own <tt>HealthCheckSMASH</tt> type, which is a
--   superset of it.
toHealthCheckSMASH :: Maybe HealthStatusSMASH -> HealthCheckSMASH

-- | Parses the SMASH HealthCheck type from the SMASH API.
data HealthStatusSMASH
HealthStatusSMASH :: Text -> Text -> HealthStatusSMASH
[$sel:status:HealthStatusSMASH] :: HealthStatusSMASH -> Text
[$sel:version:HealthStatusSMASH] :: HealthStatusSMASH -> Text

-- | A type-alias to ease signatures
type UrlBuilder = PoolId -> StakePoolMetadataUrl -> StakePoolMetadataHash -> Either HttpException URI

-- | Simply return a pool metadata url, unchanged
identityUrlBuilder :: UrlBuilder

-- | Build a URL from a metadata hash compatible with an aggregation
--   registry
registryUrlBuilder :: URI -> UrlBuilder

-- | Keeps track of open connections for keep-alive.
--   
--   If possible, you should share a single <a>Manager</a> between multiple
--   threads and requests.
--   
--   Since 0.1.0
data Manager

-- | Create a connection manager that supports TLS connections.
newManager :: MonadIO m => ManagerSettings -> m Manager

-- | Some default settings, overriding some of the library's default with
--   stricter values.
defaultManagerSettings :: ManagerSettings

-- | TODO: import SMASH types
newtype SMASHPoolId
SMASHPoolId :: Text -> SMASHPoolId
[poolId] :: SMASHPoolId -> Text
instance GHC.Generics.Generic Cardano.Pool.Metadata.SMASHPoolId
instance GHC.Classes.Ord Cardano.Pool.Metadata.SMASHPoolId
instance GHC.Show.Show Cardano.Pool.Metadata.SMASHPoolId
instance GHC.Classes.Eq Cardano.Pool.Metadata.SMASHPoolId
instance GHC.Classes.Eq Cardano.Pool.Metadata.StakePoolMetadataFetchLog
instance GHC.Show.Show Cardano.Pool.Metadata.StakePoolMetadataFetchLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Pool.Metadata.StakePoolMetadataFetchLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Pool.Metadata.StakePoolMetadataFetchLog
instance Data.Text.Class.ToText Cardano.Pool.Metadata.StakePoolMetadataFetchLog
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Pool.Metadata.SMASHPoolId
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Pool.Metadata.SMASHPoolId


-- | Utility functions for manipulating time values.
module Data.Time.Utils

-- | For a given time <tt>t0</tt>, get the closest representable time
--   <tt>t1</tt> to <tt>t0</tt> for which 't1 &lt; t0'.
utcTimePred :: UTCTime -> UTCTime

-- | For a given time <tt>t0</tt>, get the closest representable time
--   <tt>t1</tt> to <tt>t0</tt> for which 't0 &lt; t1'.
utcTimeSucc :: UTCTime -> UTCTime

module Data.Vector.Shuffle

-- | Shuffles a list of elements.
--   
--   <pre>
--   &gt;&gt;&gt; shuffle (outputs coinSel)
--   [...]
--   </pre>
shuffle :: [a] -> IO [a]

-- | Generate a random generator seed from a text string
mkSeed :: Text -> Int

-- | Like <a>shuffle</a>, but from a given seed. <a>shuffle</a> will use a
--   randomly generate seed using <a>newStdGen</a> from
--   <tt>System.Random</tt>.
--   
--   <b>Properties:</b>
--   
--   <ul>
--   <li><pre>shuffleWith g es == shuffleWith g es</pre></li>
--   <li><pre>âˆƒÎ”&gt; 1. g â‰ g', length es &gt; Î”â‡’ shuffleWith g es
--   â‰ shuffleWith g' es</pre></li>
--   </ul>
shuffleWith :: RandomGen g => g -> [a] -> IO [a]


-- | This module provides the Ntp client related settings, types and
--   re-exports used in a number of places throughout codebase.
module Network.Ntp

-- | Set up a <a>NtpClient</a> and pass it to the given action. The
--   <a>NtpClient</a> is terminated when the callback returns.
withWalletNtpClient :: IOManager -> Tracer IO NtpTrace -> (NtpClient -> IO a) -> IO a
getNtpStatus :: NtpClient -> Bool -> IO ApiNetworkClock
data NtpTrace
NtpTraceStartNtpClient :: NtpTrace
NtpTraceRestartDelay :: Int -> NtpTrace
NtpTraceRestartingClient :: NtpTrace
NtpTraceIOError :: IOError -> NtpTrace
NtpTraceLookupsFails :: NtpTrace
NtpTraceClientStartQuery :: NtpTrace
NtpTraceNoLocalAddr :: NtpTrace
NtpTraceResult :: NtpStatus -> NtpTrace
NtpTraceRunProtocolResults :: ResultOrFailure [NtpOffset] -> NtpTrace
NtpTracePacketSent :: SockAddr -> NtpPacket -> NtpTrace
NtpTracePacketSendError :: SockAddr -> IOException -> NtpTrace
NtpTracePacketDecodeError :: SockAddr -> String -> NtpTrace
NtpTracePacketReceived :: SockAddr -> NtpPacket -> NtpTrace
NtpTraceWaitingForRepliesTimeout :: IPVersion -> NtpTrace

-- | <a>NtpClient</a> which recieves updates of the wall clcok drift every
--   <a>ntpPollDelay</a>. It also allows to force engaging in ntp protocol.
data NtpClient
NtpClient :: STM NtpStatus -> IO NtpStatus -> Async Void -> NtpClient

-- | Query the current NTP status.
[ntpGetStatus] :: NtpClient -> STM NtpStatus

-- | Force to update the ntp state, unless an ntp query is already running.
--   This is a blocking operation.
[ntpQueryBlocking] :: NtpClient -> IO NtpStatus

-- | Ntp client thread
[ntpThread] :: NtpClient -> Async Void
instance Data.Text.Class.ToText Network.NTP.Client.Query.IPVersion
instance Data.Text.Class.ToText Network.NTP.Client.Query.NtpTrace
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Network.NTP.Client.Query.NtpTrace
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Network.NTP.Client.Query.NtpTrace

module Network.Wai.Middleware.Logging

-- | Installs a request &amp; response logger on a Wai application.
--   
--   The logger logs requests' and responses' bodies along with a few other
--   useful piece of information.
withApiLogger :: Tracer IO ApiLog -> ApiLoggerSettings -> Middleware

-- | Create a new opaque <a>ApiLoggerSettings</a>
newApiLoggerSettings :: IO ApiLoggerSettings

-- | API logger settings
data ApiLoggerSettings

-- | Define a set of top-level object keys that should be obfuscated for a
--   given request in a JSON format.
obfuscateKeys :: (Request -> [Text]) -> ApiLoggerSettings -> ApiLoggerSettings

-- | Tracer events related to the handling of a single request.
data HandlerLog
LogRequestStart :: HandlerLog
LogRequest :: Request -> HandlerLog

-- | Request content, with list of sensitive json keys.
LogRequestBody :: [Text] -> ByteString -> HandlerLog
LogResponse :: NominalDiffTime -> Request -> Maybe Status -> HandlerLog
LogResponseBody :: ByteString -> HandlerLog
LogRequestFinish :: HandlerLog

-- | API handler trace events are associated with a unique request ID.
data ApiLog
ApiLog :: RequestId -> HandlerLog -> ApiLog

-- | Unique integer associated with the request, for the purpose of
--   tracing.
[requestId] :: ApiLog -> RequestId

-- | Event trace for the handler.
[logMsg] :: ApiLog -> HandlerLog

-- | Just a wrapper for readability
newtype RequestId
RequestId :: Integer -> RequestId
instance Data.Aeson.Types.ToJSON.ToJSON Network.Wai.Middleware.Logging.RequestId
instance GHC.Classes.Eq Network.Wai.Middleware.Logging.RequestId
instance GHC.Show.Show Network.Wai.Middleware.Logging.RequestId
instance GHC.Generics.Generic Network.Wai.Middleware.Logging.RequestId
instance GHC.Show.Show Network.Wai.Middleware.Logging.HandlerLog
instance GHC.Generics.Generic Network.Wai.Middleware.Logging.HandlerLog
instance Data.Aeson.Types.ToJSON.ToJSON Network.Wai.Middleware.Logging.ApiLog
instance GHC.Show.Show Network.Wai.Middleware.Logging.ApiLog
instance GHC.Generics.Generic Network.Wai.Middleware.Logging.ApiLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Network.Wai.Middleware.Logging.ApiLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Network.Wai.Middleware.Logging.ApiLog
instance Data.Text.Class.ToText Network.Wai.Middleware.Logging.ApiLog
instance Cardano.BM.Data.Tracer.ToObject Network.Wai.Middleware.Logging.ApiLog
instance Data.Aeson.Types.FromJSON.FromJSON Network.Wai.Middleware.Logging.ApiLog
instance Data.Text.Class.ToText Network.Wai.Middleware.Logging.HandlerLog
instance Data.Aeson.Types.ToJSON.ToJSON Network.Wai.Middleware.Logging.HandlerLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Network.Wai.Middleware.Logging.HandlerLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Network.Wai.Middleware.Logging.HandlerLog


-- | Middleware between Wai <a>-</a> Servant to accommodate raw error
--   responses returned by servant. See also <a>handleRawError</a>.
module Network.Wai.Middleware.ServerError

-- | Make sure every error is converted to a suitable application-level
--   error.
--   
--   There are many cases where Servant will handle errors itself and reply
--   to a client without even disturbing the application. This is both
--   handy and clunky since our application return errors in a specific
--   format (e.g. JSON, XML ...).
--   
--   This is the case for instance if the client hits a non-exiting
--   endpoint of the API, or if the client requests an invalid
--   content-type, etc ...
--   
--   Ideally, we would like clients to be able to expect one and only one
--   format, so this middleware allows for manipulating the response
--   returned by a Wai application (what servant boils down to) and adjust
--   the response when necessary. So, any response with or without payload
--   but no content-type will trigger the <tt>convert</tt> function and
--   offer the caller to adjust the response as needed.
handleRawError :: (Request -> ServerError -> ServerError) -> Middleware


-- | API handlers and server using the underlying wallet layer to provide
--   endpoints reachable through HTTP.
module Cardano.Wallet.Api.Server

-- | How the server should listen for incoming requests.
data Listen

-- | Listen on given TCP port
ListenOnPort :: Port -> Listen

-- | Listen on an unused TCP port, selected at random
ListenOnRandomPort :: Listen
data ListenError
ListenErrorAddressAlreadyInUse :: Maybe Port -> ListenError
ListenErrorOperationNotPermitted :: ListenError
ListenErrorHostDoesNotExist :: HostPreference -> ListenError
ListenErrorInvalidAddress :: HostPreference -> ListenError

-- | Which host to bind.
--   
--   Note: The <tt>IsString</tt> instance recognizes the following special
--   values:
--   
--   <ul>
--   <li><tt>*</tt> means <tt>HostAny</tt> - "any IPv4 or IPv6
--   hostname"</li>
--   <li><tt>*4</tt> means <tt>HostIPv4</tt> - "any IPv4 or IPv6 hostname,
--   IPv4 preferred"</li>
--   <li><tt>!4</tt> means <tt>HostIPv4Only</tt> - "any IPv4 hostname"</li>
--   <li><tt>*6</tt> means <tt>HostIPv6</tt>@ - "any IPv4 or IPv6 hostname,
--   IPv6 preferred"</li>
--   <li><tt>!6</tt> means <tt>HostIPv6Only</tt> - "any IPv6 hostname"</li>
--   </ul>
--   
--   Note that the permissive <tt>*</tt> values allow binding to an IPv4 or
--   an IPv6 hostname, which means you might be able to successfully bind
--   to a port more times than you expect (eg once on the IPv4 localhost
--   127.0.0.1 and again on the IPv6 localhost 0:0:0:0:0:0:0:1).
--   
--   Any other value is treated as a hostname. As an example, to bind to
--   the IPv4 local host only, use "127.0.0.1".
data HostPreference

-- | Path to a x.509 PKI for mutual client-server authentication.
data TlsConfiguration
TlsConfiguration :: !FilePath -> !FilePath -> !FilePath -> TlsConfiguration
[tlsCaCert] :: TlsConfiguration -> !FilePath
[tlsSvCert] :: TlsConfiguration -> !FilePath
[tlsSvKey] :: TlsConfiguration -> !FilePath

-- | Start the application server, using the given settings and a bound
--   socket.
start :: Settings -> Tracer IO ApiLog -> Maybe TlsConfiguration -> Socket -> Application -> IO ()

-- | <a>serve</a> allows you to implement an API and produce a wai
--   <a>Application</a>.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book -- POST /books
--   
--   server :: Server MyApi
--   server = listAllBooks :&lt;|&gt; postBook
--     where listAllBooks = ...
--           postBook book = ...
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   app :: Application
--   app = serve myApi server
--   
--   main :: IO ()
--   main = Network.Wai.Handler.Warp.run 8080 app
--   </pre>
serve :: HasServer api ('[] :: [Type]) => Proxy api -> Server api -> Application

-- | Run an action with a TCP socket bound to a port specified by the
--   <a>Listen</a> parameter.
withListeningSocket :: HostPreference -> Listen -> (Either ListenError (Port, Socket) -> IO a) -> IO a

-- | Create a new instance of the wallet layer.
newApiLayer :: forall ctx s k. (ctx ~ ApiLayer s k, IsOurs s RewardAccount, IsOurs s Address, AddressBookIso s, MaybeLight s) => Tracer IO WalletEngineLog -> (Block, NetworkParameters) -> NetworkLayer IO Block -> TransactionLayer k SealedTx -> DBFactory IO s k -> TokenMetadataClient IO -> (WorkerCtx ctx -> WalletId -> IO ()) -> IO ctx
delegationFee :: forall ctx s n k. (s ~ SeqState n k, ctx ~ ApiLayer s k, BoundedAddressLength k) => ctx -> ApiT WalletId -> Handler ApiFee
deleteTransaction :: forall ctx s k. ctx ~ ApiLayer s k => ctx -> ApiT WalletId -> ApiTxId -> Handler NoContent
deleteWallet :: forall ctx s k. ctx ~ ApiLayer s k => ctx -> ApiT WalletId -> Handler NoContent
derivePublicKey :: forall ctx s k ver. (ctx ~ ApiLayer s k, SoftDerivation k, WalletKey k, GetAccount s k) => ctx -> ((ByteString, Role) -> VerificationKeyHashing -> ver) -> ApiT WalletId -> ApiT Role -> ApiT DerivationIndex -> Maybe Bool -> Handler ver
getNetworkClock :: NtpClient -> Bool -> Handler ApiNetworkClock
getNetworkInformation :: HasCallStack => NetworkId -> NetworkLayer IO Block -> ApiWalletMode -> Handler ApiNetworkInformation
getNetworkParameters :: (Block, NetworkParameters) -> NetworkLayer IO Block -> TransactionLayer k SealedTx -> Handler ApiNetworkParameters
getUTxOsStatistics :: forall ctx s k. ctx ~ ApiLayer s k => ctx -> ApiT WalletId -> Handler ApiUtxoStatistics
getWalletUtxoSnapshot :: forall ctx s k. ctx ~ ApiLayer s k => ctx -> ApiT WalletId -> Handler ApiWalletUtxoSnapshot
getWallet :: forall ctx s k apiWallet. (ctx ~ ApiLayer s k, HasWorkerRegistry s k ctx, HasDBFactory s k ctx) => ctx -> MkApiWallet ctx s apiWallet -> ApiT WalletId -> Handler (apiWallet, UTCTime)
joinStakePool :: forall ctx s n k. (ctx ~ ApiLayer s k, s ~ SeqState n k, AddressIndexDerivationType k ~ 'Soft, DelegationAddress n k, GenChange s, IsOwned s k, SoftDerivation k, Typeable n, Typeable s, WalletKey k, AddressBookIso s, BoundedAddressLength k) => ctx -> IO (Set PoolId) -> (PoolId -> IO PoolLifeCycleStatus) -> ApiPoolId -> ApiT WalletId -> ApiWalletPassphrase -> Handler (ApiTransaction n)

-- | All assets associated with this wallet, and their metadata (if
--   metadata is available). This list may include assets which have
--   already been spent.
listAssets :: forall ctx s k. (ctx ~ ApiLayer s k, IsOurs s Address, HasTokenMetadataClient ctx) => ctx -> ApiT WalletId -> Handler [ApiAsset]

-- | Look up a single asset and its metadata.
--   
--   NOTE: This is slightly inefficient because it greps through the
--   transaction history to check if the asset is associated with this
--   wallet.
getAsset :: forall ctx s k. (ctx ~ ApiLayer s k, IsOurs s Address, HasTokenMetadataClient ctx) => ctx -> ApiT WalletId -> ApiT TokenPolicyId -> ApiT TokenName -> Handler ApiAsset

-- | The handler for <a>getAsset</a> when <a>TokenName</a> is empty.
getAssetDefault :: forall ctx s k. (ctx ~ ApiLayer s k, IsOurs s Address, HasTokenMetadataClient ctx) => ctx -> ApiT WalletId -> ApiT TokenPolicyId -> Handler ApiAsset
listAddresses :: forall ctx s k n. (ctx ~ ApiLayer s k, CompareDiscovery s, KnownAddresses s) => ctx -> (s -> Address -> Maybe Address) -> ApiT WalletId -> Maybe (ApiT AddressState) -> Handler [ApiAddress n]
listTransactions :: forall ctx s k n. ctx ~ ApiLayer s k => ctx -> ApiT WalletId -> Maybe MinWithdrawal -> Maybe Iso8601Time -> Maybe Iso8601Time -> Maybe (ApiT SortOrder) -> TxMetadataSchema -> Handler [ApiTransaction n]
getTransaction :: forall ctx s k n. ctx ~ ApiLayer s k => ctx -> ApiT WalletId -> ApiTxId -> TxMetadataSchema -> Handler (ApiTransaction n)
constructTransaction :: forall ctx s k n. (ctx ~ ApiLayer s k, Bounded (Index (AddressIndexDerivationType k) 'AddressK), GenChange s, HardDerivation k, HasNetworkLayer IO ctx, IsOurs s Address, Typeable n, Typeable s, WalletKey k, BoundedAddressLength k) => ctx -> ArgGenChange s -> IO (Set PoolId) -> (PoolId -> IO PoolLifeCycleStatus) -> ApiT WalletId -> ApiConstructTransactionData n -> Handler (ApiConstructTransaction n)
listWallets :: forall ctx s k apiWallet. (ctx ~ ApiLayer s k, NFData apiWallet) => ctx -> MkApiWallet ctx s apiWallet -> Handler [(apiWallet, UTCTime)]
listStakeKeys :: forall ctx s n k. (ctx ~ ApiLayer s k, s ~ SeqState n k, HasNetworkLayer IO ctx, Typeable n, Typeable s) => (Address -> Maybe RewardAccount) -> ctx -> ApiT WalletId -> Handler (ApiStakeKeys n)
createMigrationPlan :: forall ctx n s k. (ctx ~ ApiLayer s k, Bounded (Index (AddressIndexDerivationType k) 'AddressK), HardDerivation k, IsOwned s k, Typeable n, Typeable s, WalletKey k) => ctx -> Maybe ApiWithdrawalPostData -> ApiT WalletId -> ApiWalletMigrationPlanPostData n -> Handler (ApiWalletMigrationPlan n)
migrateWallet :: forall ctx s k n p. (ctx ~ ApiLayer s k, Bounded (Index (AddressIndexDerivationType k) 'AddressK), HardDerivation k, HasNetworkLayer IO ctx, IsOwned s k, Typeable n, Typeable s, WalletKey k) => ctx -> Maybe ApiWithdrawalPostData -> ApiT WalletId -> ApiWalletMigrationPostData n p -> Handler (NonEmpty (ApiTransaction n))
postExternalTransaction :: forall ctx s k. ctx ~ ApiLayer s k => ctx -> ApiT SealedTx -> Handler ApiTxId
postIcarusWallet :: forall ctx s k n. (ctx ~ ApiLayer s k, s ~ SeqState n k, k ~ IcarusKey, HasWorkerRegistry s k ctx, PaymentAddress n IcarusKey, Typeable n) => ctx -> ByronWalletPostData '[12, 15, 18, 21, 24] -> Handler ApiByronWallet
postLedgerWallet :: forall ctx s k n. (ctx ~ ApiLayer s k, s ~ SeqState n k, k ~ IcarusKey, HasWorkerRegistry s k ctx, PaymentAddress n IcarusKey, Typeable n) => ctx -> ByronWalletPostData '[12, 15, 18, 21, 24] -> Handler ApiByronWallet
postRandomAddress :: forall ctx s k n. (s ~ RndState n, k ~ ByronKey, ctx ~ ApiLayer s k, PaymentAddress n ByronKey) => ctx -> ApiT WalletId -> ApiPostRandomAddressData -> Handler (ApiAddress n)
postRandomWallet :: forall ctx s k n. (ctx ~ ApiLayer s k, s ~ RndState n, k ~ ByronKey) => ctx -> ByronWalletPostData '[12, 15, 18, 21, 24] -> Handler ApiByronWallet
postRandomWalletFromXPrv :: forall ctx s k n. (ctx ~ ApiLayer s k, s ~ RndState n, k ~ ByronKey, HasNetworkLayer IO ctx) => ctx -> ByronWalletFromXPrvPostData -> Handler ApiByronWallet
signTransaction :: forall ctx s k. (ctx ~ ApiLayer s k, Bounded (Index (AddressIndexDerivationType k) 'AddressK), WalletKey k, IsOwned s k, HardDerivation k) => ctx -> ApiT WalletId -> ApiSignTransactionPostData -> Handler ApiSerialisedTransaction
postTransactionOld :: forall ctx s k n. (ctx ~ ApiLayer s k, Bounded (Index (AddressIndexDerivationType k) 'AddressK), GenChange s, HardDerivation k, HasNetworkLayer IO ctx, IsOwned s k, Typeable n, Typeable s, WalletKey k, AddressBookIso s, BoundedAddressLength k) => ctx -> ArgGenChange s -> ApiT WalletId -> PostTransactionOldData n -> Handler (ApiTransaction n)
postTransactionFeeOld :: forall ctx s k n. (ctx ~ ApiLayer s k, Bounded (Index (AddressIndexDerivationType k) 'AddressK), HardDerivation k, Typeable n, Typeable s, WalletKey k, BoundedAddressLength k) => ctx -> ApiT WalletId -> PostTransactionFeeOldData n -> Handler ApiFee
postTrezorWallet :: forall ctx s k n. (ctx ~ ApiLayer s k, s ~ SeqState n k, k ~ IcarusKey, HasWorkerRegistry s k ctx, PaymentAddress n IcarusKey, Typeable n) => ctx -> ByronWalletPostData '[12, 15, 18, 21, 24] -> Handler ApiByronWallet
postWallet :: forall ctx s k n. (s ~ SeqState n k, ctx ~ ApiLayer s k, SoftDerivation k, MkKeyFingerprint k (Proxy n, k 'AddressK XPub), MkKeyFingerprint k Address, WalletKey k, HasDBFactory s k ctx, HasWorkerRegistry s k ctx, IsOurs s RewardAccount, Typeable s, Typeable n, (k == SharedKey) ~ 'False, AddressBookIso s, MaybeLight s) => ctx -> ((SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> k 'RootK XPrv) -> (XPub -> k 'AccountK XPub) -> WalletOrAccountPostData -> Handler ApiWallet
postShelleyWallet :: forall ctx s k n. (s ~ SeqState n k, ctx ~ ApiLayer s k, SoftDerivation k, MkKeyFingerprint k (Proxy n, k 'AddressK XPub), MkKeyFingerprint k Address, WalletKey k, HasDBFactory s k ctx, HasWorkerRegistry s k ctx, IsOurs s RewardAccount, MaybeLight s, Typeable s, Typeable n, (k == SharedKey) ~ 'False, AddressBookIso s) => ctx -> ((SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> k 'RootK XPrv) -> WalletPostData -> Handler ApiWallet
postAccountWallet :: forall ctx s k n w. (s ~ SeqState n k, ctx ~ ApiLayer s k, SoftDerivation k, MkKeyFingerprint k (Proxy n, k 'AddressK XPub), MkKeyFingerprint k Address, WalletKey k, HasWorkerRegistry s k ctx, IsOurs s RewardAccount, MaybeLight s, (k == SharedKey) ~ 'False, Typeable n, AddressBookIso s) => ctx -> MkApiWallet ctx s w -> (XPub -> k 'AccountK XPub) -> (WorkerCtx ctx -> WalletId -> IO ()) -> AccountPostData -> Handler w
putByronWalletPassphrase :: forall ctx s k. (WalletKey k, ctx ~ ApiLayer s k) => ctx -> ApiT WalletId -> ByronWalletPutPassphraseData -> Handler NoContent
putRandomAddress :: forall ctx s k n. (s ~ RndState n, k ~ ByronKey, ctx ~ ApiLayer s k) => ctx -> ApiT WalletId -> (ApiT Address, Proxy n) -> Handler NoContent
putRandomAddresses :: forall ctx s k n. (s ~ RndState n, k ~ ByronKey, ctx ~ ApiLayer s k) => ctx -> ApiT WalletId -> ApiPutAddressesData n -> Handler NoContent
putWallet :: forall ctx s k apiWallet. ctx ~ ApiLayer s k => ctx -> MkApiWallet ctx s apiWallet -> ApiT WalletId -> WalletPutData -> Handler apiWallet
putWalletPassphrase :: forall ctx s k. (WalletKey k, ctx ~ ApiLayer s k, GetAccount s k, HardDerivation k) => ctx -> ((SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> k 'RootK XPrv) -> (k 'AccountK XPub -> XPub) -> ApiT WalletId -> WalletPutPassphraseData -> Handler NoContent
quitStakePool :: forall ctx s n k. (ctx ~ ApiLayer s k, s ~ SeqState n k, AddressIndexDerivationType k ~ 'Soft, DelegationAddress n k, GenChange s, HasNetworkLayer IO ctx, IsOwned s k, SoftDerivation k, Typeable n, Typeable s, WalletKey k, AddressBookIso s, BoundedAddressLength k) => ctx -> ApiT WalletId -> ApiWalletPassphrase -> Handler (ApiTransaction n)
selectCoins :: forall ctx s k n. (ctx ~ ApiLayer s k, SoftDerivation k, IsOurs s Address, GenChange s, Bounded (Index (AddressIndexDerivationType k) 'AddressK), Typeable n, Typeable s, WalletKey k, BoundedAddressLength k) => ctx -> ArgGenChange s -> ApiT WalletId -> ApiSelectCoinsPayments n -> Handler (ApiCoinSelection n)
selectCoinsForJoin :: forall ctx s n k. (s ~ SeqState n k, ctx ~ ApiLayer s k, DelegationAddress n k, MkKeyFingerprint k (Proxy n, k 'AddressK XPub), SoftDerivation k, Typeable n, Typeable s, BoundedAddressLength k) => ctx -> IO (Set PoolId) -> (PoolId -> IO PoolLifeCycleStatus) -> PoolId -> WalletId -> Handler (ApiCoinSelection n)
selectCoinsForQuit :: forall ctx s n k. (s ~ SeqState n k, ctx ~ ApiLayer s k, DelegationAddress n k, MkKeyFingerprint k (Proxy n, k 'AddressK XPub), Bounded (Index (AddressIndexDerivationType k) 'AddressK), SoftDerivation k, Typeable n, Typeable s, WalletKey k, BoundedAddressLength k) => ctx -> ApiT WalletId -> Handler (ApiCoinSelection n)
signMetadata :: forall ctx s k n. (ctx ~ ApiLayer s k, s ~ SeqState n k, HardDerivation k, AddressIndexDerivationType k ~ 'Soft, WalletKey k) => ctx -> ApiT WalletId -> ApiT Role -> ApiT DerivationIndex -> ApiWalletSignData -> Handler ByteString
postAccountPublicKey :: forall ctx s k account. (ctx ~ ApiLayer s k, WalletKey k, GetPurpose k) => ctx -> (ByteString -> KeyFormat -> Index 'Hardened 'PurposeK -> account) -> ApiT WalletId -> ApiT DerivationIndex -> ApiPostAccountKeyDataWithPurpose -> Handler account
getAccountPublicKey :: forall ctx s k account. (ctx ~ ApiLayer s k, GetAccount s k, WalletKey k, GetPurpose k) => ctx -> (ByteString -> KeyFormat -> Index 'Hardened 'PurposeK -> account) -> ApiT WalletId -> Maybe KeyFormat -> Handler account
postSharedWallet :: forall ctx s k n. (s ~ SharedState n k, ctx ~ ApiLayer s k, SoftDerivation k, MkKeyFingerprint k (Proxy n, k 'AddressK XPub), MkKeyFingerprint k Address, WalletKey k, HasDBFactory s k ctx, HasWorkerRegistry s k ctx, Typeable n, k ~ SharedKey) => ctx -> ((SomeMnemonic, Maybe SomeMnemonic) -> Passphrase "encryption" -> k 'RootK XPrv) -> (XPub -> k 'AccountK XPub) -> ApiSharedWalletPostData -> Handler ApiSharedWallet
patchSharedWallet :: forall ctx s k n. (s ~ SharedState n k, ctx ~ ApiLayer s k, SoftDerivation k, MkKeyFingerprint k (Proxy n, k 'AddressK XPub), MkKeyFingerprint k Address, WalletKey k, HasDBFactory s k ctx, Typeable n, k ~ SharedKey) => ctx -> (XPub -> k 'AccountK XPub) -> CredentialType -> ApiT WalletId -> ApiSharedWalletPatchData -> Handler ApiSharedWallet
mkSharedWallet :: forall ctx s k n. (ctx ~ ApiLayer s k, s ~ SharedState n k, HasWorkerRegistry s k ctx, SupportsDiscovery n k) => MkApiWallet ctx s ApiSharedWallet
balanceTransaction :: forall ctx s k (n :: NetworkDiscriminant). (ctx ~ ApiLayer s k, HasNetworkLayer IO ctx, GenChange s, BoundedAddressLength k) => ctx -> ArgGenChange s -> ApiT WalletId -> ApiBalanceTransactionPostData n -> Handler ApiSerialisedTransaction
decodeTransaction :: forall ctx s k n. (ctx ~ ApiLayer s k, IsOurs s Address, Typeable s, Typeable n, HasNetworkLayer IO ctx) => ctx -> ApiT WalletId -> ApiSerialisedTransaction -> Handler (ApiDecodedTransaction n)
submitTransaction :: forall ctx s k (n :: NetworkDiscriminant). (ctx ~ ApiLayer s k, HasNetworkLayer IO ctx, IsOwned s k, Typeable s, Typeable n) => ctx -> ApiT WalletId -> ApiSerialisedTransaction -> Handler ApiTxId
getPolicyKey :: forall ctx s k (n :: NetworkDiscriminant). (ctx ~ ApiLayer s k, Typeable s, Typeable n) => ctx -> ApiT WalletId -> Maybe Bool -> Handler ApiPolicyKey
postPolicyKey :: forall ctx s (n :: NetworkDiscriminant). (ctx ~ ApiLayer s ShelleyKey, s ~ SeqState n ShelleyKey) => ctx -> ApiT WalletId -> Maybe Bool -> ApiPostPolicyKeyData -> Handler ApiPolicyKey
postPolicyId :: forall ctx s k (n :: NetworkDiscriminant). (ctx ~ ApiLayer s k, WalletKey k, Typeable s, Typeable n) => ctx -> ApiT WalletId -> ApiPostPolicyIdData -> Handler ApiPolicyId
constructSharedTransaction :: forall ctx s k n. (k ~ SharedKey, s ~ SharedState n k, ctx ~ ApiLayer s k, GenChange s, HasNetworkLayer IO ctx, IsOurs s Address, BoundedAddressLength k) => ctx -> ArgGenChange s -> IO (Set PoolId) -> (PoolId -> IO PoolLifeCycleStatus) -> ApiT WalletId -> ApiConstructTransactionData n -> Handler (ApiConstructTransaction n)
decodeSharedTransaction :: forall ctx s k n. (ctx ~ ApiLayer s k, IsOurs s Address, HasNetworkLayer IO ctx) => ctx -> ApiT WalletId -> ApiSerialisedTransaction -> Handler (ApiDecodedTransaction n)

-- | Maps types to servant error responses.
class IsServerError e

-- | A structured human-readable error code to return to API clients.
toServerError :: IsServerError e => e -> ServerError

-- | Lift our wallet layer into servant <a>Handler</a>, by mapping each
--   error to a corresponding servant error.
liftHandler :: IsServerError e => ExceptT e IO a -> Handler a
apiError :: ServerError -> ApiErrorCode -> Text -> ServerError
mkShelleyWallet :: forall ctx s k n. (ctx ~ ApiLayer s k, s ~ SeqState n k, IsOurs s Address, IsOurs s RewardAccount, HasWorkerRegistry s k ctx) => MkApiWallet ctx s ApiWallet
mkLegacyWallet :: forall ctx s k. (HasWorkerRegistry s k ctx, HasDBFactory s k ctx, KnownDiscovery s, HasNetworkLayer IO ctx, IsOurs s Address, IsOurs s RewardAccount) => ctx -> WalletId -> Wallet s -> WalletMetadata -> Set Tx -> SyncProgress -> Handler ApiByronWallet
withLegacyLayer :: forall byron icarus n a. (byron ~ ApiLayer (RndState n) ByronKey, icarus ~ ApiLayer (SeqState n IcarusKey) IcarusKey) => ApiT WalletId -> (byron, Handler a) -> (icarus, Handler a) -> Handler a

-- | Like <a>withLegacyLayer</a> but allow passing a custom handler for
--   handling dead workers.
withLegacyLayer' :: forall byron icarus n a. (byron ~ ApiLayer (RndState n) ByronKey, icarus ~ ApiLayer (SeqState n IcarusKey) IcarusKey) => ApiT WalletId -> (byron, Handler a, ErrWalletNotResponding -> Handler a) -> (icarus, Handler a, ErrWalletNotResponding -> Handler a) -> Handler a

-- | Handler for fetching the <a>ArgGenChange</a> for the <a>RndState</a>
--   (i.e. the root XPrv), necessary to derive new change addresses.
rndStateChange :: forall ctx s k n. (ctx ~ ApiLayer s k, s ~ RndState n, k ~ ByronKey) => ctx -> ApiT WalletId -> Passphrase "user" -> Handler (ArgGenChange s)

-- | Run an action in a particular worker context. Fails if there's no
--   worker for a given id.
withWorkerCtx :: forall ctx s k m a. (HasWorkerRegistry s k ctx, HasDBFactory s k ctx, MonadIO m) => ctx -> WalletId -> (ErrNoSuchWallet -> m a) -> (ErrWalletNotResponding -> m a) -> (WorkerCtx ctx -> m a) -> m a
getCurrentEpoch :: forall ctx s k. ctx ~ ApiLayer s k => ctx -> Handler EpochNo
manageRewardBalance :: forall ctx s k (n :: NetworkDiscriminant). (HasLogger IO WalletWorkerLog ctx, HasNetworkLayer IO ctx, HasDBLayer IO s k ctx, Typeable s, Typeable n) => Proxy n -> ctx -> WalletId -> IO ()

-- | Something to pass as the coworker action to <a>newApiLayer</a>, which
--   does nothing, and never exits.
idleWorker :: ctx -> wid -> IO a

-- | The type of log messages coming from the server <a>ApiLayer</a>, which
--   may or may not be associated with a particular worker thread.
data WalletEngineLog
MsgWalletWorker :: WorkerLog WalletId WalletWorkerLog -> WalletEngineLog
MsgSubmitSealedTx :: TxSubmitLog -> WalletEngineLog
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.Listen
instance GHC.Show.Show Cardano.Wallet.Api.Server.Listen
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ListenError
instance GHC.Show.Show Cardano.Wallet.Api.Server.ListenError
instance GHC.Show.Show Cardano.Wallet.Api.Server.ErrGetAsset
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ErrGetAsset
instance GHC.Show.Show Cardano.Wallet.Api.Server.ErrListAssets
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ErrListAssets
instance GHC.Show.Show Cardano.Wallet.Api.Server.MkApiTransactionParams
instance GHC.Generics.Generic Cardano.Wallet.Api.Server.MkApiTransactionParams
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.MkApiTransactionParams
instance GHC.Show.Show Cardano.Wallet.Api.Server.ErrUnexpectedPoolIdPlaceholder
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ErrUnexpectedPoolIdPlaceholder
instance GHC.Show.Show Cardano.Wallet.Api.Server.ErrCreateWallet
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ErrCreateWallet
instance GHC.Show.Show Cardano.Wallet.Api.Server.ErrTemporarilyDisabled
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.ErrTemporarilyDisabled
instance GHC.Classes.Eq Cardano.Wallet.Api.Server.WalletEngineLog
instance GHC.Show.Show Cardano.Wallet.Api.Server.WalletEngineLog
instance Data.Text.Class.ToText Cardano.Wallet.Api.Server.WalletEngineLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.Api.Server.WalletEngineLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.Api.Server.WalletEngineLog
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Api.Server.ErrCreateWallet
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Api.Server.ErrUnexpectedPoolIdPlaceholder
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Api.Server.ErrCurrentEpoch
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.DB.WalletState.ErrNoSuchWallet
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrWalletNotResponding
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.DB.ErrWalletAlreadyExists
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrWithRootKey
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Api.Server.ErrListAssets
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Api.Server.ErrGetAsset
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrListUTxOStatistics
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrSignPayment
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrWitnessTx
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Transaction.ErrSignTx
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Transaction.ErrMkTransaction
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrConstructTx
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrGetPolicyId
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrDecodeTx
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrBalanceTx
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.DB.ErrRemoveTx
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Network.ErrPostTx
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrSubmitTransaction
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrSubmitTx
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrUpdatePassphrase
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrListTransactions
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrStartTimeLaterThanEndTime
instance Cardano.Wallet.Api.Server.IsServerError Ouroboros.Consensus.HardFork.History.Qry.PastHorizonException
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrGetTransaction
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.DB.ErrNoSuchTransaction
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrStakePoolDelegation
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Transaction.ErrCannotJoin
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Transaction.ErrCannotQuit
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrFetchRewards
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrReadRewardAccount
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrReadPolicyPublicKey
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrWritePolicyPublicKey
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrCreateRandomAddress
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrImportRandomAddress
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrNotASequentialWallet
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrWithdrawalNotWorth
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrSignMetadataWith
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrReadAccountPublicKey
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrDerivePublicKey
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrAddCosignerKey
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrConstructSharedWallet
instance Cardano.Wallet.Api.Server.IsServerError (Cardano.Wallet.ErrInvalidDerivationIndex 'Cardano.Wallet.Primitive.AddressDerivation.Soft level)
instance Cardano.Wallet.Api.Server.IsServerError (Cardano.Wallet.CoinSelection.Internal.SelectionOutputError Cardano.Wallet.CoinSelection.WalletSelectionContext)
instance Cardano.Wallet.Api.Server.IsServerError (Cardano.Wallet.CoinSelection.Internal.SelectionOutputCoinInsufficientError Cardano.Wallet.CoinSelection.WalletSelectionContext)
instance Cardano.Wallet.Api.Server.IsServerError (Cardano.Wallet.CoinSelection.Internal.SelectionOutputSizeExceedsLimitError Cardano.Wallet.CoinSelection.WalletSelectionContext)
instance Cardano.Wallet.Api.Server.IsServerError (Cardano.Wallet.CoinSelection.Internal.SelectionOutputTokenQuantityExceedsLimitError Cardano.Wallet.CoinSelection.WalletSelectionContext)
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrCreateMigrationPlan
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.ErrSelectAssets
instance Cardano.Wallet.Api.Server.IsServerError (Cardano.Wallet.CoinSelection.Internal.Balance.SelectionBalanceError Cardano.Wallet.CoinSelection.WalletSelectionContext)
instance Cardano.Wallet.Api.Server.IsServerError (Cardano.Wallet.CoinSelection.Internal.SelectionCollateralError Cardano.Wallet.CoinSelection.WalletSelectionContext)
instance Cardano.Wallet.Api.Server.IsServerError (Cardano.Wallet.ErrInvalidDerivationIndex 'Cardano.Wallet.Primitive.AddressDerivation.Hardened level)
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Transaction.ErrUpdateSealedTx
instance Cardano.Wallet.Api.Server.IsServerError Cardano.Wallet.Transaction.ErrAssignRedeemers
instance Cardano.Wallet.Api.Server.IsServerError (Network.Wai.Internal.Request, Servant.Server.Internal.ServerError.ServerError)


-- | Ouroboros mini-protocols clients for implementing cardano-wallet.
--   These clients implement the logic and lift away concerns related to
--   concrete data-type representation so that the code can be re-used /
--   shared between Byron and Shelley.
module Ouroboros.Network.Client.Wallet

-- | Client for the 'Chain Sync' mini-protocol, which provides
--   notifications when the node tip changes.
--   
--   This is used in the same way as <a>chainSyncWithBlocks</a>, except
--   that only one of these clients is necessary, rather than one client
--   per wallet.
chainSyncFollowTip :: forall m block era. Monad m => (block -> era) -> (Maybe era -> Tip block -> m ()) -> ChainSyncClient block (Point block) (Tip block) m Void

-- | Client for the 'Chain Sync' mini-protocol.
--   
--   Once started, the client simply runs ad-infinitum but one may interact
--   with it via a <a>TQueue</a> of commands / messages used to move inside
--   the state-machine.
--   
--   In a typical usage, <a>chainSyncWithBlocks</a> would be executed in a
--   forked thread and given a <a>TQueue</a> over which the parent thread
--   as control.
--   
--   <pre>
--   &gt;&gt;&gt; forkIO $ void $ chainSyncWithBlocks tr queue channel
--   ()
--   
--   &gt;&gt;&gt; writeTQueue queue ...
--   </pre>
--   
--   Agency
--   -------------------------------------------------------------------------
--   Client has agency* | Idle Server has agency* | Intersect, Next
--   
--   <ul>
--   <li>A peer has agency if it is expected to send the next message.</li>
--   <li>-----------* | Intersect |â—€â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</li>
--   <li>-----------* FindIntersect â•‘ â”‚ â•‘ â”‚ *---------* *------* â”‚
--   Intersect.{Found,NotFound} | |â•â•â•â•â•â•â•â•â•â•â•â•â•â–¶| Done |
--   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¼| | MsgDone *------* | Idle |
--   â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•| | â•‘ RequestNext | |â‡¦ START â•‘
--   *---------* â–¼ â•¿</li>
--   <li>------* Roll.{Backward,Forward} â”‚ | Next
--   |â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</li>
--   <li>------*</li>
--   </ul>
chainSyncWithBlocks :: forall m block. (Monad m, MonadSTM m, MonadThrow m, HasHeader block) => Tracer m (ChainSyncLog block (Point block)) -> PipeliningStrategy block -> ChainFollower m (Point block) (Tip block) (NonEmpty block) -> ChainSyncClientPipelined block (Point block) (Tip block) m Void

-- | How to drive pipelining size from the block height
data PipeliningStrategy block
PipeliningStrategy :: (block -> Natural) -> Text -> PipeliningStrategy block
[$sel:getPipeliningSize:PipeliningStrategy] :: PipeliningStrategy block -> block -> Natural
[$sel:pipeliningStrategyName:PipeliningStrategy] :: PipeliningStrategy block -> Text
thousandPipeliningStrategy :: PipeliningStrategy block
tunedForMainnetPipeliningStrategy :: HasHeader block => PipeliningStrategy block

-- | Type of commands that are stored in a queue for localTxSubmission.
data LocalTxSubmissionCmd tx err (m :: Type -> Type)
CmdSubmitTx :: tx -> (SubmitResult err -> m ()) -> LocalTxSubmissionCmd tx err (m :: Type -> Type)

-- | Client for the 'Local Tx Submission' mini-protocol.
--   
--   Agency
--   -------------------------------------------------------------------------
--   Client has agency* | Idle Server has agency* | Busy * A peer has
--   agency if it is expected to send the next message.
--   
--   <ul>
--   <li>-----------* | Busy |â—€â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—</li>
--   <li>-----------* SubmitTx â•‘ â”‚ â”‚ â•‘ â”‚ â”‚ *---------* *------* â”‚ â”‚
--   AcceptTx | |â•â•â•â•â•â•â•â•â•â•â•â•â•â–¶| Done | â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¼| |
--   MsgDone *------* â”‚ RejectTx | Idle |
--   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¼| | | |â‡¦ START</li>
--   <li>---------*</li>
--   </ul>
localTxSubmission :: forall m tx err. (MonadThrow m, MonadSTM m) => TQueue m (LocalTxSubmissionCmd tx err m) -> LocalTxSubmissionClient tx err m ()

-- | Monad for composing local state queries for the node <i>tip</i>.
--   
--   <i>Warning</i>: Partial functions inside the <tt>LSQ</tt> monad may
--   cause the entire wallet to crash when interpreted by
--   <tt>localStateQuery</tt>.
data LSQ block (m :: Type -> Type) a
[LSQPure] :: a -> LSQ block m a
[LSQBind] :: LSQ block m a -> (a -> LSQ block m b) -> LSQ block m b

-- | A local state query.
[LSQry] :: BlockQuery block res -> LSQ block m res

-- | Type of commands that are stored in a queue for local state queries.
data LocalStateQueryCmd block m
SomeLSQ :: LSQ block m a -> (a -> m ()) -> LocalStateQueryCmd block m

-- | Client for the 'Local State Query' mini-protocol.
--   
--   Agency
--   -------------------------------------------------------------------------
--   Client has agency* | Idle, Acquired Server has agency* | Acquiring,
--   Querying * A peer has agency if it is expected to send the next
--   message.
--   
--   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” Done â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â–¶â”‚ Idle â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚
--   Done â”‚ â”‚ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â–² â”‚ Acquire â”‚ â”‚ â”‚ â”‚ â”‚
--   Failure â”‚ â–¼ â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â” â”‚ â”‚ Acquiring â”‚ â”‚ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--   Releaseâ”‚ â”‚ â–² â”‚ â”‚ â”‚ â”‚ Acquired â”‚ â”‚ ReAcquire â”‚ â”‚ â”‚ â”‚ â–¼ â”‚ â”‚
--   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â” Query â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â””â”€â”€â”€â”€â”€â”€â”€â”¤ Acquired
--   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Querying â”‚ â”‚ â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
--   Result â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
localStateQuery :: forall m block. (MonadIO m, MonadSTM m) => TQueue m (LocalStateQueryCmd block m) -> LocalStateQueryClient block (Point block) (Query block) m Void

-- | Helper function to send commands to the node via a <a>TQueue</a> and
--   receive results.
--   
--   One of the main purposes of this functions is to handle an
--   existentially quantified type. In typical use, the <tt>cmd m</tt>
--   involves existential quantification over the type <tt>a</tt>, so that
--   the <a>TQueue</a> has elements with a monomorphic type. However, the
--   type signature of <a>send</a> allows us to retrieve this particular
--   type <tt>a</tt> for later use again.
send :: MonadSTM m => TQueue m (cmd m) -> ((a -> m ()) -> cmd m) -> m a
instance GHC.Show.Show Ouroboros.Network.Client.Wallet.ErrChainSync
instance GHC.Classes.Eq Ouroboros.Network.Client.Wallet.ErrChainSync
instance GHC.Exception.Type.Exception Ouroboros.Network.Client.Wallet.ErrChainSync
instance GHC.Base.Functor (Ouroboros.Network.Client.Wallet.LSQ block m)
instance GHC.Base.Applicative (Ouroboros.Network.Client.Wallet.LSQ block m)
instance GHC.Base.Monad (Ouroboros.Network.Client.Wallet.LSQ block m)
instance GHC.Show.Show (Ouroboros.Network.Client.Wallet.PipeliningStrategy block)


-- | Provides the package version and git revision which this was compiled
--   from.
--   
--   It is assumed that all cardano-wallet packages have the same version,
--   that of the core package.
--   
--   Stack builds will have the <tt>git</tt> command available to run
--   during compilation.
--   
--   Nix builds will inject the git revision into the executables after
--   compiling. If the git revision has changed but the sources have not,
--   then no haskell packages will be rebuilt, but the embedded git
--   revision will be updated.
module Cardano.Wallet.Version
version :: Version

-- | The Git revision ID (40 character hex string) of this build.
--   
--   This requires <tt>git</tt> to be available when building.
--   Alternatively, the git revision of the <tt>cardano-wallet</tt> binary
--   can be updated post-build using "Data.FileEmbed.injectWith".
gitRevision :: GitRevision
data GitRevision

-- | A <a>Version</a> represents the version of a software entity.
--   
--   An instance of <a>Eq</a> is provided, which implements exact equality
--   modulo reordering of the tags in the <a>versionTags</a> field.
--   
--   An instance of <a>Ord</a> is also provided, which gives lexicographic
--   ordering on the <a>versionBranch</a> fields (i.e. 2.1 &gt; 2.0, 1.2.3
--   &gt; 1.2.2, etc.). This is expected to be sufficient for many uses,
--   but note that you may need to use a more specific ordering for your
--   versioning scheme. For example, some versioning schemes may include
--   pre-releases which have tags <tt>"pre1"</tt>, <tt>"pre2"</tt>, and so
--   on, and these would need to be taken into account when determining
--   ordering. In some cases, date ordering may be more appropriate, so the
--   application would have to look for <tt>date</tt> tags in the
--   <a>versionTags</a> field and compare those. The bottom line is, don't
--   always assume that <a>compare</a> and other <a>Ord</a> operations are
--   the right thing for every <a>Version</a>.
--   
--   Similarly, concrete representations of versions may differ. One
--   possible concrete representation is provided (see <a>showVersion</a>
--   and <a>parseVersion</a>), but depending on the application a different
--   concrete representation may be more appropriate.
data Version

-- | Format the Cabal version in the vYYYY-MM-DD style that we use for git
--   tags.
showVersionAsDate :: Version -> String

-- | Like <a>showVersionAsDate</a>, but also show the git revision.
showFullVersion :: Version -> GitRevision -> String
instance GHC.Classes.Eq Cardano.Wallet.Version.GitRevision
instance GHC.Show.Show Cardano.Wallet.Version.GitRevision


-- | Extra glue functions to work with <a>MonadUnliftIO</a> exception
--   types. We need this because the <tt>retry</tt> package uses the
--   generalized exception handler type from <a>Handler</a>. But the
--   <a>Exceptions</a> module has its own definition of exactly the same
--   type.
module UnliftIO.Compat

-- | Convert the generalized handler from <a>Exception</a> type to
--   <a>Catch</a> type
coerceHandler :: Handler IO b -> Handler IO b

-- | Convert a list of handler factories from the <a>Exception</a> type to
--   <a>Catch</a> type. Such handlers are used in <a>Recovering</a> for
--   example.
coerceHandlers :: [a -> Handler IO b] -> [a -> Handler IO b]

-- | Shortcut for creating a single <a>Retry</a> handler, which doesn't use
--   the <a>RetryStatus</a> info.
mkRetryHandler :: Exception e => (e -> m Bool) -> [a -> Handler m Bool]

-- | A <a>MonadUnliftIO</a> version of <a>handleIf</a>.
handleIf :: (MonadUnliftIO m, Exception e) => (e -> Bool) -> (e -> m a) -> m a -> m a

-- | The exception thrown by <a>cancel</a> to terminate a thread.
data AsyncCancelled
AsyncCancelled :: AsyncCancelled


-- | An implementation of the DBLayer which uses Persistent and SQLite.
module Cardano.DB.Sqlite

-- | <a>SqliteContext</a> is a function to execute queries.
newtype SqliteContext
SqliteContext :: (forall a. SqlPersistT IO a -> IO a) -> SqliteContext

-- | Run a query with a connection from the pool.
[$sel:runQuery:SqliteContext] :: SqliteContext -> forall a. SqlPersistT IO a -> IO a

-- | Sets up query logging and timing, runs schema migrations if necessary
--   and provide a safe <a>SqliteContext</a> for interacting with the
--   database.
newSqliteContext :: Tracer IO DBLog -> ConnectionPool -> [ManualMigration] -> Migration -> IO (Either MigrationError SqliteContext)
newInMemorySqliteContext :: Tracer IO DBLog -> [ManualMigration] -> Migration -> ForeignKeysSetting -> IO (IO (), SqliteContext)

-- | Specifies whether or not foreign key constraints are enabled,
--   equivalent to the Sqlite <tt>foreign_keys</tt> setting.
--   
--   When foreign key constraints are <i>enabled</i>, the database will
--   enforce referential integrity, and cascading deletes are enabled.
--   
--   When foreign keys constraints are <i>disabled</i>, the database will
--   not enforce referential integrity, and cascading deletes are disabled.
--   
--   See the following resource for more information:
--   <a>https://www.sqlite.org/foreignkeys.html#fk_enable</a>
data ForeignKeysSetting

-- | Foreign key constraints are <i>enabled</i>.
ForeignKeysEnabled :: ForeignKeysSetting

-- | Foreign key constraints are <i>disabled</i>.
ForeignKeysDisabled :: ForeignKeysSetting
type ConnectionPool = Pool (SqlBackend, Connection)
withConnectionPool :: Tracer IO DBLog -> FilePath -> (ConnectionPool -> IO a) -> IO a

-- | Maximum number of variables allowed in a single SQL statement
--   
--   See also <a>dbChunked</a>.
chunkSize :: Int

-- | Convert a single DB "updateMany" (or similar) query into multiple
--   updateMany queries with smaller lists of values.
--   
--   This is to prevent too many variables appearing in the SQL statement.
--   SQLITE_MAX_VARIABLE_NUMBER is 999 by default, and we will get a "too
--   many SQL variables" exception if that is exceeded.
--   
--   We choose a conservative value <a>chunkSize</a> &lt;&lt; 999 because
--   there can be multiple variables per row updated.
dbChunked :: forall record b. PersistEntity record => ([record] -> SqlPersistT IO b) -> [record] -> SqlPersistT IO ()

-- | Like <a>dbChunked</a>, but generalized for the case where the input
--   list is not the same type as the record.
dbChunkedFor :: forall record a b. PersistEntity record => ([a] -> SqlPersistT IO b) -> [a] -> SqlPersistT IO ()

-- | Like <a>dbChunked</a>, but allows bundling elements with a <a>Key</a>.
--   Useful when used with <tt>repsertMany</tt>.
dbChunked' :: forall record b. PersistEntity record => ([(Key record, record)] -> SqlPersistT IO b) -> [(Key record, record)] -> SqlPersistT IO ()

-- | Run an action, and convert any Sqlite constraints exception into the
--   given error result. No other exceptions are handled.
handleConstraint :: MonadUnliftIO m => e -> m a -> m (Either e a)

-- | Encapsulates a manual migration action (or sequence of actions) to be
--   performed immediately after an SQL connection is initiated.
newtype ManualMigration
ManualMigration :: (Connection -> IO ()) -> ManualMigration
[$sel:executeManualMigration:ManualMigration] :: ManualMigration -> Connection -> IO ()

-- | Error type for when migrations go wrong after opening a database.
newtype MigrationError
MigrationError :: Text -> MigrationError
[$sel:getMigrationErrorMessage:MigrationError] :: MigrationError -> Text
data DBField
[DBField] :: forall record typ. PersistEntity record => EntityField record typ -> DBField
tableName :: DBField -> Text
fieldName :: DBField -> Text
fieldType :: DBField -> Text
data DBLog
MsgMigrations :: Either MigrationError Int -> DBLog
MsgQuery :: Text -> Severity -> DBLog
MsgRun :: BracketLog -> DBLog
MsgCloseSingleConnection :: FilePath -> DBLog
MsgStartConnectionPool :: FilePath -> DBLog
MsgStopConnectionPool :: FilePath -> DBLog
MsgDatabaseReset :: DBLog
MsgIsAlreadyClosed :: Text -> DBLog
MsgStatementAlreadyFinalized :: Text -> DBLog
MsgManualMigrationNeeded :: DBField -> Text -> DBLog
MsgExpectedMigration :: DBLog -> DBLog
MsgManualMigrationNotNeeded :: DBField -> DBLog
MsgUpdatingForeignKeysSetting :: ForeignKeysSetting -> DBLog
MsgRetryOnBusy :: Int -> RetryLog -> DBLog
instance GHC.Show.Show Cardano.DB.Sqlite.ForeignKeysSetting
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.DB.Sqlite.ForeignKeysSetting
instance GHC.Generics.Generic Cardano.DB.Sqlite.ForeignKeysSetting
instance GHC.Classes.Eq Cardano.DB.Sqlite.ForeignKeysSetting
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.DB.Sqlite.MigrationError
instance GHC.Generics.Generic Cardano.DB.Sqlite.MigrationError
instance GHC.Classes.Eq Cardano.DB.Sqlite.MigrationError
instance GHC.Show.Show Cardano.DB.Sqlite.MigrationError
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.DB.Sqlite.RetryLog
instance GHC.Classes.Eq Cardano.DB.Sqlite.RetryLog
instance GHC.Show.Show Cardano.DB.Sqlite.RetryLog
instance GHC.Generics.Generic Cardano.DB.Sqlite.RetryLog
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.DB.Sqlite.DBLog
instance GHC.Classes.Eq Cardano.DB.Sqlite.DBLog
instance GHC.Show.Show Cardano.DB.Sqlite.DBLog
instance GHC.Generics.Generic Cardano.DB.Sqlite.DBLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.DB.Sqlite.DBLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.DB.Sqlite.DBLog
instance Data.Text.Class.ToText Cardano.DB.Sqlite.DBLog
instance GHC.Show.Show Cardano.DB.Sqlite.DBField
instance GHC.Classes.Eq Cardano.DB.Sqlite.DBField
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.DB.Sqlite.DBField
instance Cardano.DB.Sqlite.MatchMigrationError Database.Persist.Types.Base.PersistException
instance Cardano.DB.Sqlite.MatchMigrationError Database.Sqlite.SqliteException
instance GHC.Exception.Type.Exception Cardano.DB.Sqlite.MigrationError


-- | <a>Store</a> implementations that can store various wallet types in an
--   SQLite database using <tt>persistent</tt>.
--   
--   FIXME LATER during ADP-1043:
--   
--   <ul>
--   <li>Inline the contents of this module into its new name
--   <a>Cardano.Wallet.DB.Sqlite.Stores</a></li>
--   </ul>
module Cardano.Wallet.DB.Store.Checkpoints

-- | Store for <a>WalletState</a> of multiple different wallets.
mkStoreWallets :: forall s key. (PersistAddressBook s, key ~ WalletId) => Store (SqlPersistT IO) (DeltaMap key (DeltaWalletState s))

-- | Functions for saving <i> loading the wallet's address book to </i>
--   from SQLite
class AddressBookIso s => PersistAddressBook s
insertPrologue :: PersistAddressBook s => WalletId -> Prologue s -> SqlPersistT IO ()
insertDiscoveries :: PersistAddressBook s => WalletId -> SlotNo -> Discoveries s -> SqlPersistT IO ()
loadPrologue :: PersistAddressBook s => WalletId -> SqlPersistT IO (Maybe (Prologue s))
loadDiscoveries :: PersistAddressBook s => WalletId -> SlotNo -> SqlPersistT IO (Discoveries s)
blockHeaderFromEntity :: Checkpoint -> BlockHeader

-- | Store for <a>WalletState</a> of a single wallet.
mkStoreWallet :: forall s. PersistAddressBook s => WalletId -> Store (SqlPersistT IO) (DeltaWalletState s)
instance (GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k), (k Data.Type.Equality.== Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey) GHC.Types.~ 'GHC.Types.False, Cardano.Wallet.DB.Store.Checkpoints.PersistAddressBook (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n k)) => Cardano.Wallet.DB.Store.Checkpoints.PersistAddressBook (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqAnyState n k p)
instance (Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (key 'Cardano.Wallet.Primitive.AddressDerivation.AccountK), Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (key 'Cardano.Wallet.Primitive.AddressDerivation.AddressK), Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (key 'Cardano.Wallet.Primitive.AddressDerivation.PolicyK), Cardano.Wallet.Primitive.AddressDerivation.MkKeyFingerprint key (Data.Proxy.Proxy n, key 'Cardano.Wallet.Primitive.AddressDerivation.AddressK Cardano.Address.Derivation.XPub), Cardano.Wallet.Primitive.AddressDerivation.PaymentAddress n key, Cardano.Wallet.Primitive.AddressDerivation.SoftDerivation key, Data.Typeable.Internal.Typeable n, (key Data.Type.Equality.== Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey) GHC.Types.~ 'GHC.Types.False, GHC.Classes.Eq (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n key)) => Cardano.Wallet.DB.Store.Checkpoints.PersistAddressBook (Cardano.Wallet.Primitive.AddressDiscovery.Sequential.SeqState n key)
instance (Cardano.Wallet.Primitive.AddressDerivation.PersistPublicKey (key 'Cardano.Wallet.Primitive.AddressDerivation.AccountK), Cardano.Wallet.Primitive.AddressDiscovery.Shared.SupportsDiscovery n key, Cardano.Wallet.Primitive.AddressDerivation.WalletKey key, key GHC.Types.~ Cardano.Wallet.Primitive.AddressDerivation.SharedKey.SharedKey) => Cardano.Wallet.DB.Store.Checkpoints.PersistAddressBook (Cardano.Wallet.Primitive.AddressDiscovery.Shared.SharedState n key)
instance Cardano.Wallet.DB.Store.Checkpoints.PersistAddressBook (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndAnyState n p)
instance Cardano.Wallet.DB.Store.Checkpoints.PersistAddressBook (Cardano.Wallet.Primitive.AddressDiscovery.Random.RndState n)


-- | <tt>Store</tt> implementations that can store various wallet types in
--   an SQLite database using <tt>persistent</tt>.
--   
--   FIXME LATER during ADP-1043:
--   
--   <ul>
--   <li>Inline the contents of
--   <a>Cardano.Wallet.DB.Sqlite.CheckpointsOld</a> into this module</li>
--   <li>Use <tt>Table</tt> and <tt>Embedding</tt> to construct the
--   relevant <tt>Store</tt> rather than implementing <tt>loadS</tt>,
--   <tt>writeS</tt>, <tt>updateS</tt> in a monadic fashion. Hide the new
--   implementation behind a feature flag, i.e.
--   <a>Cardano.Wallet.DB.Sqlite.StoresNew</a>.</li>
--   </ul>
module Cardano.Wallet.DB.Sqlite.Stores

-- | Store for <a>WalletState</a> of multiple different wallets.
mkStoreWallets :: forall s key. (PersistAddressBook s, key ~ WalletId) => Store (SqlPersistT IO) (DeltaMap key (DeltaWalletState s))

-- | Functions for saving <i> loading the wallet's address book to </i>
--   from SQLite
class AddressBookIso s => PersistAddressBook s
insertPrologue :: PersistAddressBook s => WalletId -> Prologue s -> SqlPersistT IO ()
insertDiscoveries :: PersistAddressBook s => WalletId -> SlotNo -> Discoveries s -> SqlPersistT IO ()
loadPrologue :: PersistAddressBook s => WalletId -> SqlPersistT IO (Maybe (Prologue s))
loadDiscoveries :: PersistAddressBook s => WalletId -> SlotNo -> SqlPersistT IO (Discoveries s)
blockHeaderFromEntity :: Checkpoint -> BlockHeader

-- | Store for <a>WalletState</a> of a single wallet.
mkStoreWallet :: forall s. PersistAddressBook s => WalletId -> Store (SqlPersistT IO) (DeltaWalletState s)


-- | Old-style manual migrations of the SQLlite database. These migrations
--   are soon to be removed in favor of a file format with version number.
module Cardano.Wallet.DB.Sqlite.Migration

-- | A set of default field values that can be consulted when performing a
--   database migration.
data DefaultFieldValues
DefaultFieldValues :: ActiveSlotCoefficient -> Word16 -> Coin -> Maybe EpochNo -> Coin -> DefaultFieldValues
[defaultActiveSlotCoefficient] :: DefaultFieldValues -> ActiveSlotCoefficient
[defaultDesiredNumberOfPool] :: DefaultFieldValues -> Word16
[defaultMinimumUTxOValue] :: DefaultFieldValues -> Coin
[defaultHardforkEpoch] :: DefaultFieldValues -> Maybe EpochNo
[defaultKeyDeposit] :: DefaultFieldValues -> Coin

-- | Executes any manual database migration steps that may be required on
--   startup.
migrateManually :: WalletKey k => Tracer IO DBLog -> Proxy k -> DefaultFieldValues -> [ManualMigration]
newtype SchemaVersion
SchemaVersion :: Natural -> SchemaVersion
currentSchemaVersion :: SchemaVersion
data InvalidDatabaseSchemaVersion
InvalidDatabaseSchemaVersion :: SchemaVersion -> SchemaVersion -> InvalidDatabaseSchemaVersion
[expectedVersion] :: InvalidDatabaseSchemaVersion -> SchemaVersion
[actualVersion] :: InvalidDatabaseSchemaVersion -> SchemaVersion
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Migration.SqlColumnStatus
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Migration.SchemaVersion
instance GHC.Read.Read Cardano.Wallet.DB.Sqlite.Migration.SchemaVersion
instance GHC.Classes.Ord Cardano.Wallet.DB.Sqlite.Migration.SchemaVersion
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Migration.SchemaVersion
instance GHC.Exception.Type.Exception Cardano.Wallet.DB.Sqlite.Migration.InvalidDatabaseSchemaVersion
instance GHC.Classes.Eq Cardano.Wallet.DB.Sqlite.Migration.InvalidDatabaseSchemaVersion
instance GHC.Show.Show Cardano.Wallet.DB.Sqlite.Migration.InvalidDatabaseSchemaVersion


-- | An implementation of the DBLayer which uses Persistent and SQLite.
module Cardano.Wallet.DB.Layer

-- | Instantiate a <a>DBFactory</a> from a given directory, or in-memory
--   for testing.
newDBFactory :: forall s k. (PersistAddressBook s, PersistPrivateKey (k 'RootK), WalletKey k) => Tracer IO DBFactoryLog -> DefaultFieldValues -> TimeInterpreter IO -> Maybe FilePath -> IO (DBFactory IO s k)

-- | Return all wallet databases that match the specified key type within
--   the specified directory.
findDatabases :: forall k. WalletKey k => Tracer IO DBFactoryLog -> FilePath -> IO [WalletId]
data DBFactoryLog
MsgFoundDatabase :: FilePath -> Text -> DBFactoryLog
MsgUnknownDBFile :: FilePath -> DBFactoryLog
MsgRemoving :: Text -> DBFactoryLog
MsgRemovingInUse :: Text -> Int -> DBFactoryLog
MsgRemovingDatabaseFile :: Text -> DeleteSqliteDatabaseLog -> DBFactoryLog
MsgWaitingForDatabase :: Text -> Maybe Int -> DBFactoryLog
MsgWalletDB :: FilePath -> WalletDBLog -> DBFactoryLog

-- | Runs an action with a connection to the SQLite database.
--   
--   Database migrations are run to create tables if necessary.
--   
--   If the given file path does not exist, it will be created by the
--   sqlite library.
withDBLayer :: forall s k a. (PersistAddressBook s, PersistPrivateKey (k 'RootK), WalletKey k) => Tracer IO WalletDBLog -> DefaultFieldValues -> FilePath -> TimeInterpreter IO -> (DBLayer IO s k -> IO a) -> IO a

-- | Runs an IO action with a new <a>DBLayer</a> backed by a sqlite
--   in-memory database.
withDBLayerInMemory :: forall s k a. (PersistAddressBook s, PersistPrivateKey (k 'RootK)) => Tracer IO WalletDBLog -> TimeInterpreter IO -> (DBLayer IO s k -> IO a) -> IO a
newtype WalletDBLog
MsgDB :: DBLog -> WalletDBLog

-- | What to do with regards to caching. This is useful to disable caching
--   in database benchmarks.
data CacheBehavior
NoCache :: CacheBehavior
CacheLatestCheckpoint :: CacheBehavior

-- | Like <a>newDBLayer</a>, but allows to explicitly specify the caching
--   behavior.
newDBLayerWith :: forall s k. (PersistAddressBook s, PersistPrivateKey (k 'RootK)) => CacheBehavior -> Tracer IO WalletDBLog -> TimeInterpreter IO -> SqliteContext -> IO (DBLayer IO s k)

-- | Creates a <a>DBLayer</a> backed by a sqlite in-memory database.
--   
--   Returns a cleanup function which you should always use exactly once
--   when finished with the <a>DBLayer</a>.
newDBLayerInMemory :: forall s k. (PersistAddressBook s, PersistPrivateKey (k 'RootK)) => Tracer IO WalletDBLog -> TimeInterpreter IO -> IO (IO (), DBLayer IO s k)

-- | Functions for saving <i> loading the wallet's address book to </i>
--   from SQLite
class AddressBookIso s => PersistAddressBook s
insertPrologue :: PersistAddressBook s => WalletId -> Prologue s -> SqlPersistT IO ()
insertDiscoveries :: PersistAddressBook s => WalletId -> SlotNo -> Discoveries s -> SqlPersistT IO ()
loadPrologue :: PersistAddressBook s => WalletId -> SqlPersistT IO (Maybe (Prologue s))
loadDiscoveries :: PersistAddressBook s => WalletId -> SlotNo -> SqlPersistT IO (Discoveries s)

-- | A set of default field values that can be consulted when performing a
--   database migration.
data DefaultFieldValues
DefaultFieldValues :: ActiveSlotCoefficient -> Word16 -> Coin -> Maybe EpochNo -> Coin -> DefaultFieldValues
[defaultActiveSlotCoefficient] :: DefaultFieldValues -> ActiveSlotCoefficient
[defaultDesiredNumberOfPool] :: DefaultFieldValues -> Word16
[defaultMinimumUTxOValue] :: DefaultFieldValues -> Coin
[defaultHardforkEpoch] :: DefaultFieldValues -> Maybe EpochNo
[defaultKeyDeposit] :: DefaultFieldValues -> Coin
instance GHC.Classes.Eq Cardano.Wallet.DB.Layer.WalletDBLog
instance GHC.Show.Show Cardano.Wallet.DB.Layer.WalletDBLog
instance GHC.Generics.Generic Cardano.Wallet.DB.Layer.WalletDBLog
instance GHC.Classes.Eq Cardano.Wallet.DB.Layer.DBFactoryLog
instance GHC.Show.Show Cardano.Wallet.DB.Layer.DBFactoryLog
instance GHC.Generics.Generic Cardano.Wallet.DB.Layer.DBFactoryLog
instance GHC.Show.Show Cardano.Wallet.DB.Layer.CacheBehavior
instance GHC.Classes.Eq Cardano.Wallet.DB.Layer.CacheBehavior
instance GHC.Show.Show Cardano.Wallet.DB.Layer.ErrRollbackTo
instance GHC.Show.Show Cardano.Wallet.DB.Layer.ErrInitializeGenesisAbsent
instance GHC.Classes.Eq Cardano.Wallet.DB.Layer.ErrInitializeGenesisAbsent
instance GHC.Exception.Type.Exception Cardano.Wallet.DB.Layer.ErrInitializeGenesisAbsent
instance GHC.Exception.Type.Exception Cardano.Wallet.DB.Layer.ErrRollbackTo
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.DB.Layer.DBFactoryLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.DB.Layer.DBFactoryLog
instance Data.Text.Class.ToText Cardano.Wallet.DB.Layer.DBFactoryLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Wallet.DB.Layer.WalletDBLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Wallet.DB.Layer.WalletDBLog
instance Data.Text.Class.ToText Cardano.Wallet.DB.Layer.WalletDBLog


-- | Logging types specific to the pool database.
module Cardano.Pool.DB.Log
data PoolDbLog
MsgGeneric :: DBLog -> PoolDbLog
MsgParseFailure :: ParseFailure -> PoolDbLog
MsgRemovingPool :: PoolId -> PoolDbLog
MsgRemovingRetiredPools :: [PoolRetirementCertificate] -> PoolDbLog
MsgRemovingRetiredPoolsForEpoch :: EpochNo -> BracketLog -> PoolDbLog
data ParseFailure
ParseFailure :: Text -> Text -> ParseFailure

-- | The name of the operation in which the parse failure occurred.
[parseFailureOperationName] :: ParseFailure -> Text

-- | A description of the parse failure.
[parseFailure] :: ParseFailure -> Text
instance GHC.Show.Show Cardano.Pool.DB.Log.ParseFailure
instance GHC.Classes.Eq Cardano.Pool.DB.Log.ParseFailure
instance GHC.Show.Show Cardano.Pool.DB.Log.PoolDbLog
instance GHC.Classes.Eq Cardano.Pool.DB.Log.PoolDbLog
instance Cardano.BM.Data.Tracer.HasPrivacyAnnotation Cardano.Pool.DB.Log.PoolDbLog
instance Cardano.BM.Data.Tracer.HasSeverityAnnotation Cardano.Pool.DB.Log.PoolDbLog
instance Data.Text.Class.ToText Cardano.Pool.DB.Log.PoolDbLog


-- | An implementation of the DBLayer which uses Persistent and SQLite.
module Cardano.Pool.DB.Sqlite

-- | Sets up a connection to the SQLite database.
--   
--   Database migrations are run to create tables if necessary.
--   
--   If the given file path does not exist, it will be created by the
--   sqlite library.
--   
--   <tt>getDBLayer</tt> will provide the actual <a>DBLayer</a>
--   implementation. The database should be closed with
--   <tt>destroyDBLayer</tt>. If you use <a>withDBLayer</a> then both of
--   these things will be handled for you.
newDBLayer :: Tracer IO PoolDbLog -> TimeInterpreter IO -> SqliteContext -> DBLayer IO

-- | Runs an action with a connection to the SQLite database.
--   
--   Database migrations are run to create tables if necessary.
--   
--   If the given file path does not exist, it will be created by the
--   sqlite library.
withDBLayer :: Tracer IO PoolDbLog -> Maybe FilePath -> TimeInterpreter IO -> (DBLayer IO -> IO a) -> IO a

-- | Runs an action with a connection to the SQLite database.
--   
--   This function has the same behaviour as <a>withDBLayer</a>, but
--   provides a way to decorate the created <a>DBLayer</a> object with a
--   <a>DBDecorator</a>, useful for instrumenting or monitoring calls to
--   database operations.
withDecoratedDBLayer :: DBDecorator IO -> Tracer IO PoolDbLog -> Maybe FilePath -> TimeInterpreter IO -> (DBLayer IO -> IO a) -> IO a

-- | A decorator for the database layer, useful for instrumenting or
--   monitoring calls to database operations.
newtype DBDecorator a
DBDecorator :: (DBLayer a -> DBLayer a) -> DBDecorator a
[$sel:decorateDBLayer:DBDecorator] :: DBDecorator a -> DBLayer a -> DBLayer a

-- | The identity decorator.
--   
--   Equivalent to an undecorated database.
undecoratedDB :: DBDecorator a

-- | Return the preferred <tt>FilePath</tt> for the stake pool .sqlite
--   file, given a parent directory.
defaultFilePath :: FilePath -> FilePath

-- | Represents a database view.
data DatabaseView
DatabaseView :: Text -> Text -> DatabaseView

-- | A name for the view.
[$sel:databaseViewName:DatabaseView] :: DatabaseView -> Text

-- | A select query to generate the view.
[$sel:databaseViewDefinition:DatabaseView] :: DatabaseView -> Text
createViews :: [ManualMigration]
