-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Executable specification of Cardano ledger
--   
--   Executable specification of Cardano ledger
@package byron-spec-ledger
@version 0.1.0.0

module Byron.Spec.Ledger.Core

-- | An encoded hash of part of the system.
--   
--   <a>Nothing</a> is used to signal to the elaborators (i.e. the
--   algorithms that translate abstract data into data concrete) that they
--   should produce an invalid concrete hash.
newtype Hash
Hash :: Maybe Int -> Hash
[unHash] :: Hash -> Maybe Int
isValid :: Hash -> Bool

-- | Hash part of the ledger payload
class HasHash a
hash :: HasHash a => a -> Hash

-- | Representation of the owner of key pair.
newtype Owner
Owner :: Natural -> Owner
[unOwner] :: Owner -> Natural
class HasOwner a
owner :: HasOwner a => a -> Owner

-- | Signing Key.
newtype SKey
SKey :: Owner -> SKey

-- | Verification Key.
newtype VKey
VKey :: Owner -> VKey

-- | A genesis key is a specialisation of a generic VKey.
newtype VKeyGenesis
VKeyGenesis :: VKey -> VKeyGenesis
[unVKeyGenesis] :: VKeyGenesis -> VKey
mkVKeyGenesis :: Natural -> VKeyGenesis

-- | Make a set of genesis keys. The genesis keys are continuously numbered
--   from 0 to the given number of genesis keys minus 1.
mkVkGenesisSet :: Word8 -> Set VKeyGenesis

-- | Key Pair.
data KeyPair
KeyPair :: SKey -> VKey -> KeyPair
[sKey] :: KeyPair -> SKey
[vKey] :: KeyPair -> VKey

-- | Return a key pair for a given owner.
keyPair :: Owner -> KeyPair

-- | A digital signature.
data Sig a
Sig :: a -> Owner -> Sig a

-- | Produce a digital signature
sign :: SKey -> a -> Sig a

-- | Verify a digital signature
verify :: Eq a => VKey -> a -> Sig a -> Bool
newtype Epoch
Epoch :: Word64 -> Epoch
[unEpoch] :: Epoch -> Word64
newtype Slot
Slot :: Word64 -> Slot
[unSlot] :: Slot -> Word64

-- | A number of slots.
--   
--   We use this newtype to distinguish between a cardinal slot and a
--   relative period of slots, and also to distinguish between number of
--   slots and number of blocks.
newtype SlotCount
SlotCount :: Word64 -> SlotCount
[unSlotCount] :: SlotCount -> Word64

-- | Add a slot count to a slot.
addSlot :: Slot -> SlotCount -> Slot

-- | An alias for <a>addSlot</a>
(+.) :: Slot -> SlotCount -> Slot
infixl 6 +.

-- | Subtract a slot count from a slot.
--   
--   This is bounded below by 0.
minusSlot :: Slot -> SlotCount -> Slot

-- | An alias for <a>minusSlot</a>
(-.) :: Slot -> SlotCount -> Slot
infixl 6 -.

-- | Multiply the block count by the given constant. This function does not
--   check for overflow.
(*.) :: Word64 -> BlockCount -> SlotCount
infixl 7 *.

-- | Subtract a slot count from a slot.
--   
--   In case the slot count is greater than the slot's index, it returns
--   Nothing.
minusSlotMaybe :: Slot -> SlotCount -> Maybe Slot
newtype BlockCount
BlockCount :: Word64 -> BlockCount
[unBlockCount] :: BlockCount -> Word64

-- | The address of a transaction output, used to identify the owner.
newtype Addr
Addr :: VKey -> Addr

-- | Create an address from a number.
mkAddr :: Natural -> Addr

-- | A unit of value held by a UTxO.
newtype Lovelace
Lovelace :: Integer -> Lovelace
[unLovelace] :: Lovelace -> Integer

-- | Constant amount of Lovelace in the system.
lovelaceCap :: Lovelace
class Relation m where {
    type family Domain m :: Type;
    type family Range m :: Type;
}
singleton :: Relation m => Domain m -> Range m -> m

-- | Domain
dom :: (Relation m, Ord (Domain m)) => m -> Set (Domain m)

-- | Range
range :: (Relation m, Ord (Range m)) => m -> Set (Range m)

-- | Domain restriction
--   
--   Unicode: 25c1
(◁) :: (Relation m, Ord (Domain m), Foldable f) => f (Domain m) -> m -> m

-- | Domain restriction
--   
--   Unicode: 25c1
(<|) :: (Relation m, Ord (Domain m), Foldable f) => f (Domain m) -> m -> m

-- | Domain exclusion
--   
--   Unicode: 22ea
(⋪) :: (Relation m, Ord (Domain m), Foldable f) => f (Domain m) -> m -> m

-- | Domain exclusion
--   
--   Unicode: 22ea
(</|) :: (Relation m, Ord (Domain m), Foldable f) => f (Domain m) -> m -> m

-- | Range restriction
--   
--   Unicode: 25b7
(▷) :: (Relation m, Ord (Range m)) => m -> Set (Range m) -> m

-- | Range restriction
--   
--   Unicode: 25b7
(|>) :: (Relation m, Ord (Range m)) => m -> Set (Range m) -> m

-- | Range exclusion
--   
--   Unicode: 22eb
(⋫) :: (Relation m, Ord (Range m)) => m -> Set (Range m) -> m

-- | Range exclusion
--   
--   Unicode: 22eb
(|/>) :: (Relation m, Ord (Range m)) => m -> Set (Range m) -> m

-- | Union
(∪) :: (Relation m, Ord (Domain m), Ord (Range m)) => m -> m -> m

-- | Union Override Right
(⨃) :: (Relation m, Ord (Domain m), Ord (Range m), Foldable f) => m -> f (Domain m, Range m) -> m

-- | Restrict domain to values less or equal than the given value.
--   
--   Unicode: 25c1
(<=◁) :: (Relation m, Ord (Domain m)) => Domain m -> m -> m

-- | Restrict range to values less or equal than the given value
--   
--   Unicode: 25b7
(▷<=) :: (Relation m, Ord (Range m)) => m -> Range m -> m

-- | Restrict range to values greater or equal than the given value
--   
--   Unicode: 25b7
(▷>=) :: (Relation m, Ord (Range m)) => m -> Range m -> m

-- | Size of the relation
size :: (Relation m, Integral n) => m -> n
infixl 5 <=◁
infixl 5 ▷>=
infixl 5 ▷<=

-- | Alias for <a>elem</a>.
--   
--   Unicode: 2208
(∈) :: (Eq a, Foldable f) => a -> f a -> Bool

-- | Alias for not <a>elem</a>.
--   
--   Unicode: 2209
(∉) :: (Eq a, Foldable f) => a -> f a -> Bool
infixl 4 ∉

-- | Union override plus is (AB)∪(BA)∪{k|-&gt;v1+v2 | k|-&gt;v1 : A /
--   k|-&gt;v2 : B}
(∪+) :: (Ord a, Ord b, Num b) => Map a b -> Map a b -> Map a b

-- | Inclusion among foldables.
--   
--   Unicode: 2286
(⊆) :: (Foldable f, Foldable g, Ord a) => f a -> g a -> Bool
toSet :: (Foldable f, Ord a) => f a -> Set a
(∩) :: Ord a => Set a -> Set a -> Set a
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Core.VKeyGenesis
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Core.VKey
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Core.SlotCount
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Core.Slot
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Core.Owner
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Core.Lovelace
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Core.Hash
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Core.Epoch
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Core.BlockCount
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Core.Addr
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Core.VKeyGenesis
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Core.VKey
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Core.SlotCount
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Core.Slot
instance Test.Goblin.Core.AddShrinks arg => Test.Goblin.Core.AddShrinks (Byron.Spec.Ledger.Core.Sig arg)
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Core.Owner
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Core.Lovelace
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Core.Hash
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Core.Epoch
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Core.BlockCount
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Core.Addr
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Core.VKeyGenesis
instance Test.Goblin.Core.GeneOps g => Test.Goblin.Core.Goblin g Byron.Spec.Ledger.Core.Hash
instance Test.Goblin.Core.GeneOps g => Test.Goblin.Core.Goblin g Byron.Spec.Ledger.Core.Lovelace
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Core.VKey
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Core.SlotCount
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Core.Slot
instance (Test.Goblin.Core.Goblin genome arg, Test.Goblin.Core.AddShrinks arg) => Test.Goblin.Core.Goblin genome (Byron.Spec.Ledger.Core.Sig arg)
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Core.Owner
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Core.Epoch
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Core.BlockCount
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Core.Addr
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.Hash
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.Hash
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.Hash
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Core.Hash
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.Hash
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.Hash
instance Data.Data.Data Byron.Spec.Ledger.Core.Hash
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.Hash
instance GHC.Show.Show Byron.Spec.Ledger.Core.Hash
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.Owner
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.Owner
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.Owner
instance Cardano.Binary.FromCBOR.FromCBOR Byron.Spec.Ledger.Core.Owner
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Core.Owner
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.Owner
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.Owner
instance Data.Data.Data Byron.Spec.Ledger.Core.Owner
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.Owner
instance GHC.Show.Show Byron.Spec.Ledger.Core.Owner
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.SKey
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.SKey
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.SKey
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.SKey
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.SKey
instance Data.Data.Data Byron.Spec.Ledger.Core.SKey
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.SKey
instance GHC.Show.Show Byron.Spec.Ledger.Core.SKey
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.VKey
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.VKey
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.VKey
instance Cardano.Binary.FromCBOR.FromCBOR Byron.Spec.Ledger.Core.VKey
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Core.VKey
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.VKey
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.VKey
instance Data.Data.Data Byron.Spec.Ledger.Core.VKey
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.VKey
instance GHC.Show.Show Byron.Spec.Ledger.Core.VKey
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.VKeyGenesis
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.VKeyGenesis
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.VKeyGenesis
instance Cardano.Binary.FromCBOR.FromCBOR Byron.Spec.Ledger.Core.VKeyGenesis
instance Byron.Spec.Ledger.Core.HasHash Byron.Spec.Ledger.Core.VKeyGenesis
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Core.VKeyGenesis
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.VKeyGenesis
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.VKeyGenesis
instance Data.Data.Data Byron.Spec.Ledger.Core.VKeyGenesis
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.VKeyGenesis
instance GHC.Show.Show Byron.Spec.Ledger.Core.VKeyGenesis
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.KeyPair
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.KeyPair
instance GHC.Show.Show Byron.Spec.Ledger.Core.KeyPair
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.KeyPair
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.KeyPair
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Byron.Spec.Ledger.Core.Sig a)
instance Data.Data.Data a => Data.Data.Data (Byron.Spec.Ledger.Core.Sig a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Byron.Spec.Ledger.Core.Sig a)
instance GHC.Generics.Generic (Byron.Spec.Ledger.Core.Sig a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Byron.Spec.Ledger.Core.Sig a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Byron.Spec.Ledger.Core.Sig a)
instance GHC.Show.Show a => GHC.Show.Show (Byron.Spec.Ledger.Core.Sig a)
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.Epoch
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.Epoch
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.Epoch
instance GHC.Num.Num Byron.Spec.Ledger.Core.Epoch
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Core.Epoch
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.Epoch
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.Epoch
instance Data.Data.Data Byron.Spec.Ledger.Core.Epoch
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.Epoch
instance GHC.Show.Show Byron.Spec.Ledger.Core.Epoch
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.Slot
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.Slot
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.Slot
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Core.Slot
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.Slot
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.Slot
instance Data.Data.Data Byron.Spec.Ledger.Core.Slot
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.Slot
instance GHC.Show.Show Byron.Spec.Ledger.Core.Slot
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.SlotCount
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.SlotCount
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Core.SlotCount
instance GHC.Num.Num Byron.Spec.Ledger.Core.SlotCount
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.SlotCount
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.SlotCount
instance Data.Data.Data Byron.Spec.Ledger.Core.SlotCount
instance GHC.Show.Show Byron.Spec.Ledger.Core.SlotCount
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.SlotCount
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.BlockCount
instance Cardano.Binary.FromCBOR.FromCBOR Byron.Spec.Ledger.Core.BlockCount
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.BlockCount
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Core.BlockCount
instance GHC.Num.Num Byron.Spec.Ledger.Core.BlockCount
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.BlockCount
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.BlockCount
instance GHC.Show.Show Byron.Spec.Ledger.Core.BlockCount
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.BlockCount
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.Addr
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.Addr
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.Addr
instance Byron.Spec.Ledger.Core.HasOwner Byron.Spec.Ledger.Core.Addr
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Core.Addr
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.Addr
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.Addr
instance Data.Data.Data Byron.Spec.Ledger.Core.Addr
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.Addr
instance GHC.Show.Show Byron.Spec.Ledger.Core.Addr
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.Lovelace
instance GHC.Base.Monoid Byron.Spec.Ledger.Core.Lovelace
instance GHC.Base.Semigroup Byron.Spec.Ledger.Core.Lovelace
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Core.Lovelace
instance Cardano.Binary.ToCBOR.ToCBOR Byron.Spec.Ledger.Core.Lovelace
instance GHC.Real.Integral Byron.Spec.Ledger.Core.Lovelace
instance GHC.Real.Real Byron.Spec.Ledger.Core.Lovelace
instance GHC.Enum.Enum Byron.Spec.Ledger.Core.Lovelace
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Core.Lovelace
instance GHC.Num.Num Byron.Spec.Ledger.Core.Lovelace
instance GHC.Classes.Ord Byron.Spec.Ledger.Core.Lovelace
instance GHC.Classes.Eq Byron.Spec.Ledger.Core.Lovelace
instance Data.Data.Data Byron.Spec.Ledger.Core.Lovelace
instance GHC.Generics.Generic Byron.Spec.Ledger.Core.Lovelace
instance GHC.Show.Show Byron.Spec.Ledger.Core.Lovelace
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => Byron.Spec.Ledger.Core.Relation (Data.Bimap.Bimap k v)
instance Byron.Spec.Ledger.Core.Relation (Data.Map.Internal.Map k v)
instance Byron.Spec.Ledger.Core.Relation (Data.Set.Internal.Set (a, b))
instance Byron.Spec.Ledger.Core.Relation [(a, b)]
instance Byron.Spec.Ledger.Core.HasHash Byron.Spec.Ledger.Core.Addr
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.BlockCount
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.SlotCount
instance Data.Typeable.Internal.Typeable a => Data.AbstractSize.HasTypeReps (Byron.Spec.Ledger.Core.Sig a)
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Core.KeyPair
instance Byron.Spec.Ledger.Core.HasOwner Byron.Spec.Ledger.Core.VKeyGenesis
instance Byron.Spec.Ledger.Core.HasHash Byron.Spec.Ledger.Core.VKey
instance Byron.Spec.Ledger.Core.HasOwner Byron.Spec.Ledger.Core.VKey
instance Byron.Spec.Ledger.Core.HasOwner Byron.Spec.Ledger.Core.SKey


-- | Functions that are intended to be used in tests, but not in the
--   executable specifications. These functions are not possible in
--   practice (like recovering the signed data from the signature only),
--   but are possible for the abstract data we use in the specifications.
module Byron.Spec.Ledger.Core.Omniscient

-- | Extract the verifying key of a signature. This is useful when
--   elaborating an abstract signature into a concrete one.
signatureVKey :: Sig a -> VKey

-- | Extract the signature data.
signatureData :: Sig a -> a

-- | Get the signing key from the verification key. We use this in the
--   generators, where we need to generate signed data for a given
--   verification key (e.g. one that appears in the delegation map) for
--   which we don't have the signing key.
skey :: VKey -> SKey

-- | Sign using a genesis verifying key.
--   
--   See <a>skey</a> for details about situations where this function is
--   used.
signWithGenesisKey :: VKeyGenesis -> a -> Sig a


-- | Ledger global parameters.
module Byron.Spec.Ledger.GlobalParams

-- | Given the chain stability parameter, calculate the first slot in a
--   given epoch.
epochFirstSlot :: BlockCount -> Epoch -> Slot

-- | Constant amount of Lovelace in the system.
lovelaceCap :: Lovelace

-- | Given the chain stability parameter, often referred to as <tt>k</tt>,
--   which is expressed in an amount of blocks, return the number of slots
--   contained in an epoch.
slotsPerEpoch :: Integral n => BlockCount -> n

-- | The inverse of <a>slotsPerEpoch</a>: given a number of slots
--   per-epoch, return the chain stability parameter <tt>k</tt>.
slotsPerEpochToK :: Integral n => n -> BlockCount

-- | Factor used to bound the concrete size by the abstract size.
--   
--   This constant should satisfy that given an elaboration function
--   <tt>elaborate</tt> which elaborates abstract values intro concrete
--   ones, for each abstract data value <tt>a</tt> we have:
--   
--   <pre>
--   size (elaborate a) &lt;= c * abstractSize a
--   </pre>
--   
--   TODO: we need to investigate what this factor is, and probably use
--   different factors for different data types (update, UTxO transactions,
--   etc).
c :: Word64


-- | Generators for the <a>Core</a> values.
module Byron.Spec.Ledger.Core.Generators
vkGen :: Gen VKey
vkgenesisGen :: Gen VKeyGenesis
addrGen :: Gen Addr

-- | Generates a slot within the given bound
slotGen :: Word64 -> Word64 -> Gen Slot

-- | Generates an epoch within the given bound
epochGen :: Word64 -> Word64 -> Gen Epoch

-- | Generates a block count within the given bound
blockCountGen :: Word64 -> Word64 -> Gen BlockCount

-- | Generate a chain stability parameter value (<tt>k</tt>) using the
--   given chain length and desired number of epochs.
k :: Word64 -> Word64 -> Gen BlockCount

-- | Given a chain length, determine the <tt>k</tt> value that will split
--   the chain length into the desired number of epochs.
--   
--   We have that:
--   
--   <pre>
--   chainLength = slotsPerEpoch k * numberOfEpochs
--   = { algebra }
--   chainLength / numberOfEpochs = slotsPerEpoch k
--   = { 'slotsPerEpochtoK' is the inverse of 'slotsPerEpoch'; algebra }
--   slotsPerEpochToK (chainLength / numberOfEpochs) = k
--   </pre>
--   
--   So the resulting <tt>k</tt> value will be directly proportional to the
--   <tt>chainLength</tt> and inversely proportional to the chosen
--   <tt>numberOfEpochs</tt>.
--   
--   The minimum value for <tt>k</tt> will be 1. In particular, this will
--   be the value returned when the number of epochs is greater or equal
--   than <tt>chainLength</tt>.
kForNumberOfEpochs :: Word64 -> Word64 -> BlockCount

module Byron.Spec.Ledger.Util

-- | Take a name (e.g. <a>DELEG</a>) and a list of
--   <tt>PredicateFailure</tt>s in <tt>renderPF</tt> form (see repo
--   goblins-sts-breeder; STSExtra typeclass) (e.g.
--   [<a>UTXOW_InsufficientWitnesses</a>]) and returns `n+1` declarations,
--   where n is the length of the <tt>pfNames</tt> list. There will be 1
--   decl per element of <tt>pfNames</tt>, which wraps a goblin mutation
--   around the valid <tt>SignalGenerator</tt>. The final decl is a
--   toplevel list of the previously defined <tt>SignalGenerator</tt>s.
mkGoblinGens :: String -> [String] -> Q [Dec]

module Byron.Spec.Ledger.Update

-- | Protocol parameters.
data PParams
PParams :: !Natural -> !Natural -> !Natural -> !Natural -> !BkSgnCntT -> !SlotCount -> !SlotCount -> !Natural -> !UpAdptThd -> !FactorA -> !FactorB -> PParams

-- | Maximum (abstract) block size in words
[_maxBkSz] :: PParams -> !Natural

-- | Maximum (abstract) block header size in words
[_maxHdrSz] :: PParams -> !Natural

-- | Maximum (abstract) transaction size in words
[_maxTxSz] :: PParams -> !Natural

-- | Maximum (abstract) update proposal size in words
[_maxPropSz] :: PParams -> !Natural

-- | Fraction [0, 1] of the blocks that can be signed by any given key in a
--   window of lenght <tt>_bkSgnCntW</tt>. This value will be typically
--   between 1/5 and 1/4
[_bkSgnCntT] :: PParams -> !BkSgnCntT

-- | Number of slots in an epoch. TODO: this should be removed since the
--   number of slots per epoch should remain constant.
[_bkSlotsPerEpoch] :: PParams -> !SlotCount

-- | Update proposal TTL in slots
[_upTtl] :: PParams -> !SlotCount

-- | Script version
[_scriptVersion] :: PParams -> !Natural

-- | Update adoption threshold: a proportion of block issuers that have to
--   endorse a given version to become candidate for adoption
[_upAdptThd] :: PParams -> !UpAdptThd

-- | Minimum fees per transaction
[_factorA] :: PParams -> !FactorA

-- | Additional fees per transaction size
[_factorB] :: PParams -> !FactorB
newtype BkSgnCntT
BkSgnCntT :: Double -> BkSgnCntT
newtype UpAdptThd
UpAdptThd :: Double -> UpAdptThd
newtype FactorB
FactorB :: Int -> FactorB
newtype FactorA
FactorA :: Int -> FactorA

-- | Protocol version
data ProtVer
ProtVer :: Natural -> Natural -> Natural -> ProtVer
[_pvMaj] :: ProtVer -> Natural
[_pvMin] :: ProtVer -> Natural
[_pvAlt] :: ProtVer -> Natural
newtype UpId
UpId :: Int -> UpId
bkSgnCntT :: Lens' PParams BkSgnCntT
bkSlotsPerEpoch :: Lens' PParams SlotCount
factorA :: Lens' PParams FactorA
factorB :: Lens' PParams FactorB
maxBkSz :: Lens' PParams Natural
maxHdrSz :: Lens' PParams Natural
maxPropSz :: Lens' PParams Natural
maxTxSz :: Lens' PParams Natural
scriptVersion :: Lens' PParams Natural
upAdptThd :: Lens' PParams UpAdptThd
upTtl :: Lens' PParams SlotCount
data SwVer
SwVer :: ApName -> ApVer -> SwVer
[_svName] :: SwVer -> ApName
[_svVer] :: SwVer -> ApVer

-- | Application version
newtype ApVer
ApVer :: Natural -> ApVer
newtype ApName
ApName :: String -> ApName
pvAlt :: Lens' ProtVer Natural
pvMaj :: Lens' ProtVer Natural
pvMin :: Lens' ProtVer Natural

-- | Update proposal
data UProp
UProp :: UpId -> VKey -> PParams -> ProtVer -> SwVer -> Sig UpSD -> Set STag -> Metadata -> UProp
[_upId] :: UProp -> UpId
[_upIssuer] :: UProp -> VKey
[_upParams] :: UProp -> PParams
[_upPV] :: UProp -> ProtVer
[_upSwVer] :: UProp -> SwVer
[_upSig] :: UProp -> Sig UpSD

-- | System tags involved in the update proposal.
[_upSTags] :: UProp -> Set STag

-- | Metadata required for performing software updates.
[_upMdt] :: UProp -> Metadata

-- | For now we do not have any requirements on metadata.
data Metadata
Metadata :: Metadata

-- | System tag, this represents a target operating system for the update
--   (e.g. <tt>linux</tt>, <tt>win64</tt>, or <tt>mac32</tt>).
type STag = String

-- | Part of the update proposal which must be signed
type UpSD = (ProtVer, PParams, SwVer, Set STag, Metadata)
svName :: Lens' SwVer ApName
svVer :: Lens' SwVer ApVer
data Vote
Vote :: VKey -> UpId -> Sig UpId -> Vote
[_vCaster] :: Vote -> VKey
[_vPropId] :: Vote -> UpId
[_vSig] :: Vote -> Sig UpId

-- | These <a>PredicateFailure</a>s are all throwable.
data UpregPredicateFailure
UPVFailure :: PredicateFailure UPV -> UpregPredicateFailure
NotGenesisDelegate :: UpregPredicateFailure
DoesNotVerify :: UpregPredicateFailure
data UPREG

-- | These <a>PredicateFailure</a>s are all throwable.
data UpvPredicateFailure
UPPVVFailure :: PredicateFailure UPPVV -> UpvPredicateFailure
UPSVVFailure :: PredicateFailure UPSVV -> UpvPredicateFailure
AVChangedInPVUpdate :: ApName -> ApVer -> Maybe (ApVer, Slot, Metadata) -> UpvPredicateFailure
ParamsChangedInSVUpdate :: UpvPredicateFailure
PVChangedInSVUpdate :: UpvPredicateFailure

-- | Update proposal validity
data UPV

-- | These <a>PredicateFailure</a>s are all "throwable". The disjunction of
--   the rules' preconditions is not <a>True</a> - the
--   <a>PredicateFailure</a>s represent <a>False</a> cases.
data UppvvPredicateFailure
CannotFollowPv :: UppvvPredicateFailure
CannotUpdatePv :: [UpdateConstraintViolation] -> UppvvPredicateFailure
AlreadyProposedPv :: UppvvPredicateFailure
data UPPVV

-- | These <a>PredicateFailure</a>s are all "throwable". The disjunction of
--   the rules' preconditions is not <a>True</a> - the
--   <a>PredicateFailure</a>s represent <a>False</a> cases.
data UpsvvPredicateFailure
AlreadyProposedSv :: UpsvvPredicateFailure
CannotFollowSv :: UpsvvPredicateFailure
InvalidApplicationName :: UpsvvPredicateFailure
InvalidSystemTags :: UpsvvPredicateFailure

-- | Update Proposal Software Version Validation
data UPSVV

-- | Violations on the constraints of the allowed values for new protocol
--   parameters.
data UpdateConstraintViolation
BlockSizeTooLarge :: Natural -> Threshold Natural -> UpdateConstraintViolation
TransactionSizeTooLarge :: Natural -> Threshold Natural -> UpdateConstraintViolation
ScriptVersionTooLarge :: Natural -> Threshold Natural -> UpdateConstraintViolation
ScriptVersionTooSmall :: Natural -> Threshold Natural -> UpdateConstraintViolation
upId :: Lens' UProp UpId
upIssuer :: Lens' UProp VKey
upMdt :: Lens' UProp Metadata
upPV :: Lens' UProp ProtVer
upParams :: Lens' UProp PParams
upSTags :: Lens' UProp (Set STag)
upSig :: Lens' UProp (Sig UpSD)
upSwVer :: Lens' UProp SwVer
upSigData :: Lens' UProp UpSD
getUpSigData :: UProp -> UpSD
mkUProp :: UpId -> VKey -> ProtVer -> PParams -> SwVer -> Set STag -> Metadata -> UProp

-- | Test if a pair is present in a map.
inMap :: (Ord key, Eq v) => key -> v -> Map key v -> Bool

-- | Invert a map
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Map.Strict as Map
--   
--   &gt;&gt;&gt; import Byron.Spec.Ledger.Update (invertMap)
--   
--   &gt;&gt;&gt; invertMap (Map.fromList [('a', 1 :: Int), ('b', 2), ('c', 3), ('d', 1)])
--   fromList [(1,fromList "ad"),(2,fromList "b"),(3,fromList "c")]
--   </pre>
invertMap :: (Ord k, Ord v) => Map k v -> Map v (Set k)

-- | Invert a map which we assert to be a bijection. If this map is not a
--   bijection, the behaviour is not guaranteed.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Map.Strict as Map
--   
--   &gt;&gt;&gt; invertBijection (Map.fromList [('a', 1 :: Int), ('b', 2), ('c', 3)])
--   fromList [(1,'a'),(2,'b'),(3,'c')]
--   </pre>
invertBijection :: Ord v => Map k v -> Map v k
(==>) :: Bool -> Bool -> Bool
infix 1 ==>

-- | Check whether a protocol version can follow the current protocol
--   version.
pvCanFollow :: ProtVer -> ProtVer -> Bool

-- | Check whether an update proposal marks a valid update
checkUpdateConstraints :: PParams -> UProp -> [UpdateConstraintViolation]
(<=?) :: Ord a => a -> a -> Maybe (a, Threshold a)
infix 4 <=?
orError :: Maybe (a, b) -> (a -> b -> e) -> Maybe e
canUpdate :: PParams -> UProp -> Rule UPPVV ctx ()
svCanFollow :: Map ApName (ApVer, Slot, Metadata) -> (ApName, ApVer) -> Bool
data UpiecPredicateFailure
PVBUMPFailure :: PredicateFailure PVBUMP -> UpiecPredicateFailure
data UPIEC
data PvbumpPredicateFailure
NoPVBUMPFailure :: PvbumpPredicateFailure
data PVBUMP
data UpiendPredicateFailure
UPENDFailure :: PredicateFailure UPEND -> UpiendPredicateFailure
data UPIEND
data UpivotesPredicateFailure
ApplyVotesFailure :: PredicateFailure APPLYVOTES -> UpivotesPredicateFailure
data UPIVOTES
data ApplyVotesPredicateFailure
UpivoteFailure :: PredicateFailure UPIVOTE -> ApplyVotesPredicateFailure
data APPLYVOTES
data UpivotePredicateFailure
UPVOTEFailure :: PredicateFailure UPVOTE -> UpivotePredicateFailure
data UPIVOTE
data UpiregPredicateFailure
UPREGFailure :: PredicateFailure UPREG -> UpiregPredicateFailure
data UPIREG

-- | The update interface state is shared amongst various rules, so we
--   define it as an alias here.
type UPIState = ((ProtVer, PParams), [(Slot, (ProtVer, PParams))], Map ApName (ApVer, Slot, Metadata), Map UpId (ProtVer, PParams), Map UpId (ApName, ApVer, Metadata), Map UpId Slot, Set (UpId, VKeyGenesis), Set (ProtVer, VKeyGenesis), Map UpId Slot)

-- | The update interface environment is shared amongst various rules, so
--   we define it as an alias here.
type UPIEnv = (Slot, Bimap VKeyGenesis VKey, BlockCount, Word8)

-- | <a>S_TryNextRule</a> is a structural <a>PredicateFailure</a>, used to
--   fail from one transition rule to the other. The other
--   <a>PredicateFailure</a>s are all throwable.
data UpendPredicateFailure
ProtVerUnknown :: ProtVer -> UpendPredicateFailure
S_TryNextRule :: UpendPredicateFailure
CanAdopt :: ProtVer -> UpendPredicateFailure
CannotAdopt :: ProtVer -> UpendPredicateFailure
NotADelegate :: VKey -> UpendPredicateFailure
UnconfirmedProposal :: UpId -> UpendPredicateFailure
data UPEND
data FadsPredicateFailure
data FADS

-- | The 3 non-embedded <a>PredicateFailure</a>s here are all structural.
--   The disjuntion of the preconditions is <a>True</a> - one rule either
--   fires or the other does.
data UpvotePredicateFailure
ADDVOTEFailure :: PredicateFailure ADDVOTE -> UpvotePredicateFailure
S_HigherThanThdAndNotAlreadyConfirmed :: UpvotePredicateFailure
S_CfmThdNotReached :: UpvotePredicateFailure
S_AlreadyConfirmed :: UpvotePredicateFailure
data UPVOTE

-- | These <a>PredicateFailure</a>s are all throwable.
data AddvotePredicateFailure
AVSigDoesNotVerify :: AddvotePredicateFailure
NoUpdateProposal :: UpId -> AddvotePredicateFailure
VoteByNonGenesisDelegate :: VKey -> AddvotePredicateFailure
RepeatVoteByGenesisDelegate :: VKey -> AddvotePredicateFailure
data ADDVOTE
vCaster :: Lens' Vote VKey
vPropId :: Lens' Vote UpId
vSig :: Lens' Vote (Sig UpId)
mkVote :: VKey -> UpId -> Vote

-- | Find the key that corresponds to the value satisfying the given
--   predicate. In case zero or more than one key is found this function
--   returns Nothing.
findKey :: (v -> Bool) -> Map k v -> Maybe (k, v)
delegationMap :: UPIEnv -> Bimap VKeyGenesis VKey
emptyUPIState :: UPIState
initialPParams :: PParams
protocolVersion :: UPIState -> ProtVer
protocolParameters :: UPIState -> PParams
applicationVersions :: UPIState -> Map ApName (ApVer, Slot, Metadata)
confirmedProposals :: UPIState -> Map UpId Slot
futureAdoptions :: UPIState -> [(Slot, (ProtVer, PParams))]
endorsements :: UPIState -> Set (ProtVer, VKeyGenesis)
registeredProtocolUpdateProposals :: UPIState -> Map UpId (ProtVer, PParams)
upiEnvGen :: Gen UPIEnv
dmapGen :: Word8 -> Gen (Bimap VKeyGenesis VKey)

-- | Generate a protocol parameter update from a given set of current
--   protocol-parameters, ensuring the consistency of the new protocol
--   parameters w.r.t. the current ones, according to the
--   <tt>canUpdate</tt> predicate in the formal specification.
--   
--   TODO: we can move this into a Generator's module, but first we need to
--   disentangle the dependencies. Moving this to
--   <tt>Byron.Spec.Ledger.Update.Generators</tt> will cause a circular
--   dependency. I think the rules need to be moved into their own modules.
ppsUpdateFrom :: PParams -> Gen PParams

-- | Generate values the given distribution in 90% of the cases, and values
--   at the bounds of the range in 10% of the cases.
--   
--   This can be used to generate enough extreme values. The exponential
--   and linear distributions provided by <tt>hedgehog</tt> will generate a
--   small percentage of these (0-1%).
increasingProbabilityAt :: Gen a -> (a, a) -> Gen a

-- | Generate a random update proposal id, by picking a large number so
--   that the probability of having an update proposal with that id is
--   nearly zero.
randomUpId :: Gen UpId

-- | Update the signature of the update proposal.
reSign :: UProp -> UProp

-- | Given a list of protocol versions and keys endorsing those versions,
--   generate a protocol-version endorsement, or <a>Nothing</a> if the list
--   of endorsements is empty. The version to be endorsed will be selected
--   from those versions that have the most endorsements.
pickHighlyEndorsedProtocolVersion :: [(ProtVer, Set VKeyGenesis)] -> Gen (Maybe ProtVer)

-- | Generate an optional update-proposal and a list of votes, given an
--   update environment and state.
--   
--   The update proposal and votes need to be generated at the same time,
--   since this allow us to generate update votes for update proposals
--   issued in the same block as the votes.
updateProposalAndVotesGen :: UPIEnv -> UPIState -> Gen (Maybe UProp, [Vote])

-- | Generate an endorsement given an update environment and state.
protocolVersionEndorsementGen :: UPIEnv -> UPIState -> Gen ProtVer
goblinData_UPIREG_UPREGFailure_DoesNotVerify :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_DoesNotVerify :: SignalGenerator UPIREG
goblinData_UPIREG_UPREGFailure_NotGenesisDelegate :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_NotGenesisDelegate :: SignalGenerator UPIREG
goblinData_UPIREG_UPREGFailure_UPVFailure_AVChangedInPVUpdate :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_UPVFailure_AVChangedInPVUpdate :: SignalGenerator UPIREG
goblinData_UPIREG_UPREGFailure_UPVFailure_PVChangedInSVUpdate :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_UPVFailure_PVChangedInSVUpdate :: SignalGenerator UPIREG
goblinData_UPIREG_UPREGFailure_UPVFailure_ParamsChangedInSVUpdate :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_UPVFailure_ParamsChangedInSVUpdate :: SignalGenerator UPIREG
goblinData_UPIREG_UPREGFailure_UPVFailure_UPPVVFailure_CannotFollowPv :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_UPVFailure_UPPVVFailure_CannotFollowPv :: SignalGenerator UPIREG
goblinData_UPIREG_UPREGFailure_UPVFailure_UPPVVFailure_CannotUpdatePv :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_UPVFailure_UPPVVFailure_CannotUpdatePv :: SignalGenerator UPIREG
goblinData_UPIREG_UPREGFailure_UPVFailure_UPSVVFailure_AlreadyProposedSv :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_UPVFailure_UPSVVFailure_AlreadyProposedSv :: SignalGenerator UPIREG
goblinData_UPIREG_UPREGFailure_UPVFailure_UPSVVFailure_CannotFollowSv :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_UPVFailure_UPSVVFailure_CannotFollowSv :: SignalGenerator UPIREG
goblinData_UPIREG_UPREGFailure_UPVFailure_UPSVVFailure_InvalidApplicationName :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_UPVFailure_UPSVVFailure_InvalidApplicationName :: SignalGenerator UPIREG
goblinData_UPIREG_UPREGFailure_UPVFailure_UPSVVFailure_InvalidSystemTags :: GoblinData Bool
goblinGen_UPIREG_UPREGFailure_UPVFailure_UPSVVFailure_InvalidSystemTags :: SignalGenerator UPIREG
goblinGensUPIREG :: [SignalGenerator UPIREG]
goblinData_UPIVOTES_ApplyVotesFailure_UpivoteFailure_UPVOTEFailure_ADDVOTEFailure_AVSigDoesNotVerify :: GoblinData Bool
goblinGen_UPIVOTES_ApplyVotesFailure_UpivoteFailure_UPVOTEFailure_ADDVOTEFailure_AVSigDoesNotVerify :: SignalGenerator UPIVOTES
goblinData_UPIVOTES_ApplyVotesFailure_UpivoteFailure_UPVOTEFailure_ADDVOTEFailure_NoUpdateProposal :: GoblinData Bool
goblinGen_UPIVOTES_ApplyVotesFailure_UpivoteFailure_UPVOTEFailure_ADDVOTEFailure_NoUpdateProposal :: SignalGenerator UPIVOTES
goblinGensUPIVOTES :: [SignalGenerator UPIVOTES]

-- | Tamper with the update proposal in such a way that the following
--   predicate failures are triggered with equal probability:
--   
--   <ul>
--   <li>UPREGFailure</li>
--   <li>UPVFailure</li>
--   <li>UPVFailure</li>
--   <li>UPPVVFailure</li>
--   <li>CannotFollowPv</li>
--   <li>CannotUpdatePv</li>
--   <li>AlreadyProposedPv</li>
--   <li>UPSVVFailure</li>
--   <li>AlreadyProposedSv</li>
--   <li>CannotFollowSv</li>
--   <li>InvalidApplicationName</li>
--   <li>InvalidSystemTags</li>
--   <li>AVChangedInPVUpdate</li>
--   <li>ParamsChangedInSVUpdate</li>
--   <li>PVChangedInSVUpdate</li>
--   <li>NotGenesisDelegate</li>
--   <li>DoesNotVerify</li>
--   </ul>
tamperWithUpdateProposal :: UPIEnv -> UPIState -> UProp -> Gen UProp

-- | Tamper with some of the votes provided as parameter in such a way that
--   the following predicate failures are triggered with equal probability:
--   
--   <ul>
--   <li>AVSigDoesNotVerify</li>
--   <li>NoUpdateProposal</li>
--   </ul>
tamperWithVotes :: UPIEnv -> UPIState -> [Vote] -> Gen [Vote]
tamperWithVote :: Vote -> Gen Vote

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
instance Lens.Micro.Internal.Field1 (a, b, c, d, e, f, g, h, i) (a', b, c, d, e, f, g, h, i) a a'
instance Lens.Micro.Internal.Field2 (a, b, c, d, e, f, g, h, i) (a, b', c, d, e, f, g, h, i) b b'
instance Lens.Micro.Internal.Field3 (a, b, c, d, e, f, g, h, i) (a, b, c', d, e, f, g, h, i) c c'
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.UpId
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.UpAdptThd
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.Metadata
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.ProtVer
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.PParams
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.SwVer
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.FactorB
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.FactorA
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.BkSgnCntT
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.ApVer
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Update.ApName
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.Vote
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.UProp
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.UpId
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.UpAdptThd
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.SwVer
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.ProtVer
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.PParams
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.Metadata
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.FactorB
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.FactorA
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.BkSgnCntT
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.ApVer
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Update.ApName
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Update.Vote
instance Test.Goblin.Core.GeneOps g => Test.Goblin.Core.Goblin g Byron.Spec.Ledger.Update.FactorA
instance Test.Goblin.Core.GeneOps g => Test.Goblin.Core.Goblin g Byron.Spec.Ledger.Update.FactorB
instance Test.Goblin.Core.GeneOps g => Test.Goblin.Core.Goblin g Byron.Spec.Ledger.Update.BkSgnCntT
instance Test.Goblin.Core.GeneOps g => Test.Goblin.Core.Goblin g Byron.Spec.Ledger.Update.UpAdptThd
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Update.UProp
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Update.UpId
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Update.SwVer
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Update.PParams
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Update.ProtVer
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Update.Metadata
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Update.ApName
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Update.ApVer
instance Data.Data.Data Byron.Spec.Ledger.Update.ADDVOTE
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.ADDVOTE
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.AddvotePredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.AddvotePredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.AddvotePredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.AddvotePredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.AddvotePredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UPVOTE
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPVOTE
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpvotePredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpvotePredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UpvotePredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpvotePredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpvotePredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.FADS
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.FADS
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.FadsPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.FadsPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.FadsPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.FadsPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UPEND
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPEND
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpendPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpendPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UpendPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpendPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpendPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UPIREG
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPIREG
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpiregPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpiregPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UpiregPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpiregPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpiregPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UPIVOTE
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPIVOTE
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpivotePredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpivotePredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UpivotePredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpivotePredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpivotePredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.APPLYVOTES
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.APPLYVOTES
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.ApplyVotesPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.ApplyVotesPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.ApplyVotesPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.ApplyVotesPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.ApplyVotesPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UPIVOTES
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPIVOTES
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpivotesPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpivotesPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UpivotesPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpivotesPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpivotesPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UPIEND
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPIEND
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpiendPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpiendPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UpiendPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpiendPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpiendPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.PVBUMP
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.PVBUMP
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.PvbumpPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.PvbumpPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.PvbumpPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.PvbumpPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.PvbumpPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UPIEC
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPIEC
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpiecPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpiecPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UpiecPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpiecPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpiecPredicateFailure
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPIEC
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.PVBUMP Byron.Spec.Ledger.Update.UPIEC
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.PVBUMP
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPIEND
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPEND Byron.Spec.Ledger.Update.UPIEND
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPIVOTES
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.APPLYVOTES Byron.Spec.Ledger.Update.UPIVOTES
instance Control.State.Transition.Generator.HasTrace Byron.Spec.Ledger.Update.UPIVOTES
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.APPLYVOTES
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPIVOTE Byron.Spec.Ledger.Update.APPLYVOTES
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPIVOTE
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPVOTE Byron.Spec.Ledger.Update.UPIVOTE
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPIREG
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPREG Byron.Spec.Ledger.Update.UPIREG
instance Control.State.Transition.Generator.HasTrace Byron.Spec.Ledger.Update.UPIREG
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPEND
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.FADS Byron.Spec.Ledger.Update.UPEND
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.FADS
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPVOTE
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.ADDVOTE Byron.Spec.Ledger.Update.UPVOTE
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.ADDVOTE
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.Vote
instance Byron.Spec.Ledger.Core.HasHash (GHC.Maybe.Maybe Byron.Spec.Ledger.Update.UProp, [Byron.Spec.Ledger.Update.Vote])
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpdateConstraintViolation
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpdateConstraintViolation
instance Data.Data.Data Byron.Spec.Ledger.Update.UpdateConstraintViolation
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpdateConstraintViolation
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.UpdateConstraintViolation
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpdateConstraintViolation
instance Data.Data.Data Byron.Spec.Ledger.Update.UPSVV
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPSVV
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpsvvPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpsvvPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UpsvvPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpsvvPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpsvvPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UPPVV
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPPVV
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UppvvPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UppvvPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UppvvPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UppvvPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UppvvPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UPV
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPV
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpvPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpvPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UpvPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpvPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpvPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UPREG
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UPREG
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpregPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpregPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Update.UpregPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpregPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpregPredicateFailure
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.Vote
instance Data.Data.Data Byron.Spec.Ledger.Update.Vote
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.Vote
instance GHC.Show.Show Byron.Spec.Ledger.Update.Vote
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.Vote
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.Vote
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPREG
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPV Byron.Spec.Ledger.Update.UPREG
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPV
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPPVV Byron.Spec.Ledger.Update.UPV
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Update.UPSVV Byron.Spec.Ledger.Update.UPV
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPPVV
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Update.UPSVV
instance Data.AbstractSize.HasTypeReps (Byron.Spec.Ledger.Update.ProtVer, Byron.Spec.Ledger.Update.PParams, Byron.Spec.Ledger.Update.SwVer, Data.Set.Internal.Set Byron.Spec.Ledger.Update.STag, Byron.Spec.Ledger.Update.Metadata)
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.Metadata
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.UProp
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.Metadata
instance Data.Data.Data Byron.Spec.Ledger.Update.Metadata
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.Metadata
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.Metadata
instance GHC.Show.Show Byron.Spec.Ledger.Update.Metadata
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.Metadata
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.Metadata
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UProp
instance Data.Data.Data Byron.Spec.Ledger.Update.UProp
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.UProp
instance GHC.Show.Show Byron.Spec.Ledger.Update.UProp
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UProp
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UProp
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.SwVer
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.ApName
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.ApName
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.ApName
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.ApName
instance Data.Data.Data Byron.Spec.Ledger.Update.ApName
instance GHC.Show.Show Byron.Spec.Ledger.Update.ApName
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.ApName
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.ApVer
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.ApVer
instance GHC.Num.Num Byron.Spec.Ledger.Update.ApVer
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.ApVer
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.ApVer
instance Data.Data.Data Byron.Spec.Ledger.Update.ApVer
instance GHC.Show.Show Byron.Spec.Ledger.Update.ApVer
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.ApVer
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.SwVer
instance Data.Data.Data Byron.Spec.Ledger.Update.SwVer
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.SwVer
instance GHC.Show.Show Byron.Spec.Ledger.Update.SwVer
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.SwVer
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.SwVer
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.ApVer
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.ApName
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.ProtVer
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.UpId
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpId
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.UpId
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.UpId
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpId
instance Data.Data.Data Byron.Spec.Ledger.Update.UpId
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpId
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpId
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.ProtVer
instance Data.Data.Data Byron.Spec.Ledger.Update.ProtVer
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.ProtVer
instance GHC.Show.Show Byron.Spec.Ledger.Update.ProtVer
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.ProtVer
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.ProtVer
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.ProtVer
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.PParams
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.FactorA
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.FactorA
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.FactorA
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.FactorA
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.FactorA
instance Data.Data.Data Byron.Spec.Ledger.Update.FactorA
instance GHC.Show.Show Byron.Spec.Ledger.Update.FactorA
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.FactorA
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.FactorB
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.FactorB
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.FactorB
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.FactorB
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.FactorB
instance Data.Data.Data Byron.Spec.Ledger.Update.FactorB
instance GHC.Show.Show Byron.Spec.Ledger.Update.FactorB
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.FactorB
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.UpAdptThd
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.UpAdptThd
instance GHC.Real.RealFrac Byron.Spec.Ledger.Update.UpAdptThd
instance GHC.Real.Fractional Byron.Spec.Ledger.Update.UpAdptThd
instance GHC.Real.Real Byron.Spec.Ledger.Update.UpAdptThd
instance GHC.Num.Num Byron.Spec.Ledger.Update.UpAdptThd
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.UpAdptThd
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.UpAdptThd
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.UpAdptThd
instance Data.Data.Data Byron.Spec.Ledger.Update.UpAdptThd
instance GHC.Show.Show Byron.Spec.Ledger.Update.UpAdptThd
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.UpAdptThd
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Update.BkSgnCntT
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.BkSgnCntT
instance GHC.Real.Fractional Byron.Spec.Ledger.Update.BkSgnCntT
instance GHC.Num.Num Byron.Spec.Ledger.Update.BkSgnCntT
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.BkSgnCntT
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.BkSgnCntT
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.BkSgnCntT
instance Data.Data.Data Byron.Spec.Ledger.Update.BkSgnCntT
instance GHC.Show.Show Byron.Spec.Ledger.Update.BkSgnCntT
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.BkSgnCntT
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Update.PParams
instance Data.Data.Data Byron.Spec.Ledger.Update.PParams
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Update.PParams
instance GHC.Show.Show Byron.Spec.Ledger.Update.PParams
instance GHC.Classes.Ord Byron.Spec.Ledger.Update.PParams
instance GHC.Generics.Generic Byron.Spec.Ledger.Update.PParams
instance GHC.Classes.Eq Byron.Spec.Ledger.Update.PParams

module Byron.Spec.Ledger.Update.Test

-- | Check that all the relevant predicate failures are covered.
coverUpiregFailures :: forall m a. (MonadTest m, HasCallStack, Data a) => CoverPercentage -> a -> m ()

-- | See <a>coverUpiregFailures</a>.
coverUpivoteFailures :: forall m a. (MonadTest m, HasCallStack, Data a) => CoverPercentage -> a -> m ()

module Byron.Spec.Ledger.UTxO

-- | A unique ID of a transaction, which is computable from the
--   transaction.
newtype TxId
TxId :: Hash -> TxId
[getTxId] :: TxId -> Hash

-- | The input of a UTxO.
--   
--   <ul>
--   <li><b>TODO</b> - is it okay to use list indices instead of
--   implementing the Ix Type?</li>
--   </ul>
data TxIn
TxIn :: TxId -> Natural -> TxIn

-- | The output of a UTxO.
data TxOut
TxOut :: Addr -> Lovelace -> TxOut
[addr] :: TxOut -> Addr
[value] :: TxOut -> Lovelace

-- | The unspent transaction outputs.
newtype UTxO
UTxO :: Map TxIn TxOut -> UTxO
[unUTxO] :: UTxO -> Map TxIn TxOut

-- | Apply function uniformly across all outputs
mapUTxOValues :: (Lovelace -> Lovelace) -> UTxO -> UTxO
addValue :: TxOut -> Lovelace -> TxOut

-- | Construct a UTxO from initial TxOuts
fromTxOuts :: [TxOut] -> UTxO

-- | A raw transaction
data TxBody
TxBody :: [TxIn] -> [TxOut] -> TxBody
[inputs] :: TxBody -> [TxIn]
[outputs] :: TxBody -> [TxOut]
txid :: TxBody -> TxId

-- | Total value of a transaction.
txValue :: TxBody -> Lovelace

-- | Compute the UTxO inputs of a transaction.
txins :: TxBody -> [TxIn]

-- | Compute the UTxO outputs of a transaction.
txouts :: TxBody -> UTxO

-- | Determine the total balance contained in the UTxO.
balance :: UTxO -> Lovelace
pcMinFee :: PParams -> Tx -> Lovelace
txsize :: Tx -> Int

-- | Proof/Witness that a transaction is authorized by the given key
--   holder.
data Wit
Wit :: VKey -> Sig TxBody -> Wit

-- | A fully formed transaction.
data Tx
Tx :: TxBody -> [Wit] -> Tx
[body] :: Tx -> TxBody
[witnesses] :: Tx -> [Wit]

-- | Create a witness for transaction
makeWitness :: KeyPair -> TxBody -> Wit
makeTxWits :: UTxO -> TxBody -> Tx
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.UTxO.TxOut
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.UTxO.TxIn
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.UTxO.TxId
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.UTxO.UTxO
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.UTxO.Wit
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.UTxO.Tx
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.UTxO.TxOut
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.UTxO.TxIn
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.UTxO.TxId
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.UTxO.TxBody
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.UTxO.TxId
instance Test.Goblin.Core.GeneOps g => Test.Goblin.Core.Goblin g Byron.Spec.Ledger.UTxO.TxBody
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.UTxO.Wit
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.UTxO.Tx
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.UTxO.TxOut
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.UTxO.TxIn
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.UTxO.TxId
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.UTxO.TxId
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.UTxO.TxId
instance GHC.Classes.Ord Byron.Spec.Ledger.UTxO.TxId
instance GHC.Classes.Eq Byron.Spec.Ledger.UTxO.TxId
instance Data.Data.Data Byron.Spec.Ledger.UTxO.TxId
instance GHC.Generics.Generic Byron.Spec.Ledger.UTxO.TxId
instance GHC.Show.Show Byron.Spec.Ledger.UTxO.TxId
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.UTxO.TxIn
instance Data.Data.Data Byron.Spec.Ledger.UTxO.TxIn
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.UTxO.TxIn
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.UTxO.TxIn
instance GHC.Generics.Generic Byron.Spec.Ledger.UTxO.TxIn
instance GHC.Classes.Ord Byron.Spec.Ledger.UTxO.TxIn
instance GHC.Classes.Eq Byron.Spec.Ledger.UTxO.TxIn
instance GHC.Show.Show Byron.Spec.Ledger.UTxO.TxIn
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.UTxO.TxOut
instance Data.Data.Data Byron.Spec.Ledger.UTxO.TxOut
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.UTxO.TxOut
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.UTxO.TxOut
instance GHC.Generics.Generic Byron.Spec.Ledger.UTxO.TxOut
instance GHC.Classes.Ord Byron.Spec.Ledger.UTxO.TxOut
instance GHC.Classes.Eq Byron.Spec.Ledger.UTxO.TxOut
instance GHC.Show.Show Byron.Spec.Ledger.UTxO.TxOut
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.UTxO.UTxO
instance GHC.Base.Monoid Byron.Spec.Ledger.UTxO.UTxO
instance GHC.Base.Semigroup Byron.Spec.Ledger.UTxO.UTxO
instance Byron.Spec.Ledger.Core.Relation Byron.Spec.Ledger.UTxO.UTxO
instance GHC.Classes.Eq Byron.Spec.Ledger.UTxO.UTxO
instance Data.Data.Data Byron.Spec.Ledger.UTxO.UTxO
instance GHC.Show.Show Byron.Spec.Ledger.UTxO.UTxO
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.UTxO.TxBody
instance Data.Data.Data Byron.Spec.Ledger.UTxO.TxBody
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.UTxO.TxBody
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.UTxO.TxBody
instance GHC.Generics.Generic Byron.Spec.Ledger.UTxO.TxBody
instance GHC.Classes.Ord Byron.Spec.Ledger.UTxO.TxBody
instance GHC.Show.Show Byron.Spec.Ledger.UTxO.TxBody
instance GHC.Classes.Eq Byron.Spec.Ledger.UTxO.TxBody
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.UTxO.Wit
instance Data.Data.Data Byron.Spec.Ledger.UTxO.Wit
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.UTxO.Wit
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.UTxO.Wit
instance GHC.Generics.Generic Byron.Spec.Ledger.UTxO.Wit
instance GHC.Classes.Ord Byron.Spec.Ledger.UTxO.Wit
instance GHC.Classes.Eq Byron.Spec.Ledger.UTxO.Wit
instance GHC.Show.Show Byron.Spec.Ledger.UTxO.Wit
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.UTxO.Tx
instance Data.Data.Data Byron.Spec.Ledger.UTxO.Tx
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.UTxO.Tx
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.UTxO.Tx
instance GHC.Generics.Generic Byron.Spec.Ledger.UTxO.Tx
instance GHC.Classes.Eq Byron.Spec.Ledger.UTxO.Tx
instance GHC.Show.Show Byron.Spec.Ledger.UTxO.Tx
instance Byron.Spec.Ledger.Core.HasHash [Byron.Spec.Ledger.UTxO.Tx]
instance Byron.Spec.Ledger.Core.HasHash Byron.Spec.Ledger.UTxO.TxBody

module Byron.Spec.Ledger.UTxO.Generators

-- | Generate a set of initial <a>TxOut</a>s from a set of <a>Addr</a>s
genInitialTxOuts :: [Addr] -> Gen [TxOut]
genLovelace :: Gen Lovelace

-- | Generate a subsequence of a list of values and traverse the
--   subsequence with a generator producer
genTraverseSubsequence :: (a -> Gen b) -> [a] -> Gen [b]

-- | Generate a list using <a>genTraverseSubsequence</a>
genList :: Range Int -> Gen a -> Gen [a]

-- | Temporarily defined here until hedgehog exposes this function
interleaveTreeT :: Monad m => [TreeT m a] -> m (NodeT m [a])

-- | Generate a valid transaction from a given <a>UTxO</a>
genTxFromUTxO :: [Addr] -> (Tx -> Lovelace) -> UTxO -> Gen Tx

-- | A property to test that the entire shrink tree generated by
--   <a>genInputOutput</a> maintains the invariant that the inputs and
--   outputs have equal sums
--   
--   NB: This uses small values for the list and values, because we force
--   the entire shrink tree, which can grow very large
propGenInputOutput :: Property

-- | Generate a subsequence of the inputs and split the value into a number
--   of outputs
--   
--   The shrink tree maintains the invariant that the sum of the inputs is
--   equal to the sum of the outputs. This is generalised to any type of
--   input where we can view the contained value, and type of output where
--   we can generate the type from a value, and view and modify the
--   contained value
genInputOutput :: [input] -> (input -> Integer) -> Gen (Integer -> output) -> (output -> Integer) -> ((Integer -> Integer) -> output -> output) -> Gen ([input], [output])

-- | Used as part of <a>genInputOutput</a>, so see there for details of the
--   arguments
interleaveInputOutputTreeT :: Monad m => (input -> Integer) -> (output -> Integer) -> ((Integer -> Integer) -> output -> output) -> (TreeT m [input], TreeT m [output]) -> m (NodeT m ([input], [output]))

-- | Used as part of <a>genInputOutput</a>, so see there for details of the
--   arguments
interleaveInputOutput :: Monad m => (input -> Integer) -> (output -> Integer) -> ((Integer -> Integer) -> output -> output) -> (NodeT m [input], NodeT m [output]) -> NodeT m ([input], [output])

-- | Used as part of <a>genInputOutput</a>, so see there for details of the
--   arguments
shrinkRight :: Monad m => (input -> Integer) -> (output -> Integer) -> ((Integer -> Integer) -> output -> output) -> (NodeT m [input], NodeT m [output]) -> [TreeT m ([input], [output])]

-- | Shrink the left value of a tuple, preserving the total value stored in
--   the right value
--   
--   Used as part of <a>genInputOutput</a>, so see there for details of the
--   arguments
shrinkLeftPreserving :: Monad m => (input -> Integer) -> (output -> Integer) -> ((Integer -> Integer) -> output -> output) -> (NodeT m [input], NodeT m [output]) -> [TreeT m ([input], [output])]

-- | Remove total value from a list, removing from the front
subFromList :: (Num n, Ord n) => n -> (a -> n) -> ((n -> n) -> a -> a) -> [a] -> [a]

-- | A property to check that <a>genSplitValue</a> does indeed preserve the
--   input
propGenSplitValue :: Property

-- | Given an input value and functions to generate, view, and update some
--   type <tt>a</tt> based on that value, split the input into a number of
--   <tt>a</tt>s, preserving the value throughout the shrink tree
genSplitValue :: Integer -> Gen (Integer -> a) -> (a -> Integer) -> ((Integer -> Integer) -> a -> a) -> Gen [a]

-- | Used as part of <a>genSplitValue</a>, so see there for details of the
--   arguments
interleaveTreeTPreserving :: Monad m => (a -> Integer) -> ((Integer -> Integer) -> a -> a) -> [TreeT m a] -> m (NodeT m [a])

-- | Used as part of <a>genSplitValue</a>, so see there for details of the
--   arguments
interleavePreserving :: Monad m => (a -> Integer) -> ((Integer -> Integer) -> a -> a) -> [NodeT m a] -> NodeT m [a]

-- | Drop one of the outputs, preserving the invariant by moving its value
--   to the left
--   
--   Used as part of <a>genSplitValue</a>, so see there for details of the
--   arguments
dropOnePreserving :: Monad m => (a -> Integer) -> ((Integer -> Integer) -> a -> a) -> [NodeT m a] -> [TreeT m [a]]

-- | Shrink a value in a list, preserving the total value by moving the
--   lost value to the left
--   
--   Used as part of <a>genSplitValue</a>, so see there for details of the
--   arguments
shrinkOnePreserving :: Monad m => (a -> Integer) -> ((Integer -> Integer) -> a -> a) -> [NodeT m a] -> [TreeT m [a]]

-- | All the ways of choosing two consecutive values from a list
viewTwo :: [a] -> [([a], a, a, [a])]


-- | UTXO transition system
module Byron.Spec.Ledger.STS.UTXO
data UTXO
data UTxOEnv
UTxOEnv :: UTxO -> PParams -> UTxOEnv
data UTxOState
UTxOState :: UTxO -> Lovelace -> UTxOState

-- | These <a>PredicateFailure</a>s are all "throwable". The disjunction of
--   the rules' preconditions is not <a>True</a> - the
--   <a>PredicateFailure</a>s represent <a>False</a> cases.
data UtxoPredicateFailure
EmptyTxInputs :: UtxoPredicateFailure
EmptyTxOutputs :: UtxoPredicateFailure
FeeTooLow :: UtxoPredicateFailure
IncreasedTotalBalance :: UtxoPredicateFailure
InputsNotInUTxO :: UtxoPredicateFailure
NonPositiveOutputs :: UtxoPredicateFailure

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
utxo :: UTxOState -> UTxO
utxo0 :: UTxOEnv -> UTxO
pps :: UTxOEnv -> PParams
reserves :: UTxOState -> Lovelace
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.STS.UTXO.UTxOState
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.STS.UTXO.UTxOEnv
instance Data.Data.Data Byron.Spec.Ledger.STS.UTXO.UTXO
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.STS.UTXO.UTxOEnv
instance GHC.Generics.Generic Byron.Spec.Ledger.STS.UTXO.UTxOEnv
instance GHC.Show.Show Byron.Spec.Ledger.STS.UTXO.UTxOEnv
instance GHC.Classes.Eq Byron.Spec.Ledger.STS.UTXO.UTxOEnv
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.STS.UTXO.UTxOState
instance GHC.Generics.Generic Byron.Spec.Ledger.STS.UTXO.UTxOState
instance GHC.Show.Show Byron.Spec.Ledger.STS.UTXO.UTxOState
instance GHC.Classes.Eq Byron.Spec.Ledger.STS.UTXO.UTxOState
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.STS.UTXO.UtxoPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.STS.UTXO.UtxoPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.STS.UTXO.UtxoPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.STS.UTXO.UtxoPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.STS.UTXO.UtxoPredicateFailure
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.STS.UTXO.UTXO

module Byron.Spec.Ledger.Delegation

-- | Delegation scheduling rules
data SDELEG

-- | Delegation scheduling sequencing
data SDELEGS

-- | Delegation scheduling state
data DSState
DSState :: [(Slot, (VKeyGenesis, VKey))] -> Set (Epoch, VKeyGenesis) -> DSState
_dSStateScheduledDelegations :: DSState -> [(Slot, (VKeyGenesis, VKey))]
_dSStateKeyEpochDelegations :: DSState -> Set (Epoch, VKeyGenesis)

-- | A delegation certificate.
data DCert
DCert :: VKeyGenesis -> VKey -> Epoch -> Sig (VKey, Epoch) -> DCert

-- | Key that delegates
delegator :: DCert -> VKeyGenesis

-- | Key that the delegator is delegating to
delegate :: DCert -> VKey

-- | Certificate epoch
depoch :: DCert -> Epoch

-- | Who is delegating to whom.
dwho :: DCert -> (VKeyGenesis, VKey)
mkDCert :: VKeyGenesis -> Sig (VKey, Epoch) -> VKey -> Epoch -> DCert

-- | Witness for the delegation certificate
signature :: DCert -> Sig (VKey, Epoch)

-- | Delegation rules
data ADELEG

-- | Delegation rules sequencing
data ADELEGS

-- | Delegation scheduling environment
data DSEnv
DSEnv :: Set VKeyGenesis -> Epoch -> Slot -> BlockCount -> DSEnv

-- | Set of allowed delegators
[_dSEnvAllowedDelegators] :: DSEnv -> Set VKeyGenesis

-- | Current epoch
[_dSEnvEpoch] :: DSEnv -> Epoch

-- | Current slot
[_dSEnvSlot] :: DSEnv -> Slot

-- | Chain stability parameter
[_dSEnvK] :: DSEnv -> BlockCount
allowedDelegators :: HasAllowedDelegators s a => Lens' s a

-- | Delegation state
data DState
DState :: Bimap VKeyGenesis VKey -> Map VKeyGenesis Slot -> DState
[_dStateDelegationMap] :: DState -> Bimap VKeyGenesis VKey

-- | When was the last time each genesis key delegated.
[_dStateLastDelegation] :: DState -> Map VKeyGenesis Slot

-- | Delegation interface
data DELEG

-- | Interface environment is the same as scheduling environment.
type DIEnv = DSEnv
data DIState
DIState :: Bimap VKeyGenesis VKey -> Map VKeyGenesis Slot -> [(Slot, (VKeyGenesis, VKey))] -> Set (Epoch, VKeyGenesis) -> DIState
_dIStateDelegationMap :: DIState -> Bimap VKeyGenesis VKey
_dIStateLastDelegation :: DIState -> Map VKeyGenesis Slot
_dIStateScheduledDelegations :: DIState -> [(Slot, (VKeyGenesis, VKey))]
_dIStateKeyEpochDelegations :: DIState -> Set (Epoch, VKeyGenesis)

-- | Compute after which slot the delegation certificate will become live,
--   using the chain stability parameter.
liveAfter :: BlockCount -> SlotCount
data EpochDiff
EpochDiff :: Epoch -> Epoch -> EpochDiff
[currentEpoch] :: EpochDiff -> Epoch
[certEpoch] :: EpochDiff -> Epoch
slot :: HasSlot s a => Lens' s a
epoch :: HasEpoch s a => Lens' s a
delegationMap :: HasDelegationMap s a => Lens' s a
class HasScheduledDelegations s a | s -> a
scheduledDelegations :: HasScheduledDelegations s a => Lens' s a
dmsL :: HasDelegationMap a (Bimap VKeyGenesis VKey) => Lens' a (Bimap VKeyGenesis VKey)
dcertGen :: DSEnv -> Set (Epoch, VKeyGenesis) -> Gen (Maybe DCert)
dcertsGen :: DSEnv -> DIState -> Gen [DCert]

-- | Generate an initial <a>DELEG</a> environment from the given number of
--   genesis keys.
initialEnvFromGenesisKeys :: Word8 -> Word64 -> Gen DSEnv

-- | Generate a random delegation certificate, which has a high probability
--   of failing since we do not consider the current delegation state. So
--   for instance, we could generate a delegation certificate for a genesis
--   key that already delegated in this epoch.
randomDCertGen :: Environment DELEG -> Gen DCert
goblinGensDELEG :: [SignalGenerator DELEG]
delegatorOf :: Bimap VKeyGenesis VKey -> VKey -> Maybe VKeyGenesis
delegatorDelegate :: DCert -> (VKeyGenesis, VKey)

-- | Ratio of certificate groups that are empty
emptyDelegationPayloadRatio :: [[DCert]] -> Double

-- | Ratio of certificates that delegate to _this_ epoch, where each
--   certificate is represented by (current epoch,cert epoch)
thisEpochDelegationsRatio :: [(Epoch, Epoch)] -> Double

-- | Ratio of certificates that delegate to the _next_ epoch, where each
--   certificate is represented by (current epoch,cert epoch)
nextEpochDelegationsRatio :: [(Epoch, Epoch)] -> Double

-- | Ratio of certificates that "delegate to self", that is, where the
--   delegator and delegate are the same
selfDelegationsRatio :: [DCert] -> Double

-- | Ratio of delegates that have multiple delegators that are delegating
--   to them
multipleDelegationsRatio :: [DCert] -> Double

-- | The maximum number of delegators to any particular delegate
maxDelegationsTo :: [DCert] -> Int

-- | Ratio of delegators that have changed their delegations
changedDelegationsRatio :: [DCert] -> Double

-- | The maximum number of change-of-delegate for any particular delegator
maxChangedDelegations :: [DCert] -> Int

-- | Ratio of repeated delegations to all delegations
repeatedDelegationsRatio :: [DCert] -> Double

-- | The maximum number of repeated delegations in the given certificates
maxRepeatedDelegations :: [DCert] -> Int
maxCertsPerBlock :: [[DCert]] -> Int

-- | None of these <a>PredicateFailure</a>s are actually "throwable". The
--   disjuction of the rules' preconditions is <a>True</a>, which means
--   that one of them will pass. The <a>PredicateFailure</a> just act as
--   switches to direct control flow to the successful one.
data AdelegPredicateFailure
S_BeforeExistingDelegation :: AdelegPredicateFailure
S_NoLastDelegation :: AdelegPredicateFailure
S_AfterExistingDelegation :: AdelegPredicateFailure
S_AlreadyADelegateOf :: VKey -> VKeyGenesis -> AdelegPredicateFailure
data AdelegsPredicateFailure
ADelegFailure :: PredicateFailure ADELEG -> AdelegsPredicateFailure

-- | These <a>PredicateFailure</a>s are all "throwable". The disjunction of
--   the rules' preconditions is not <a>True</a> - the
--   <a>PredicateFailure</a>s represent <a>False</a> cases.
data SdelegPredicateFailure
IsNotGenesisKey :: SdelegPredicateFailure
EpochInThePast :: EpochDiff -> SdelegPredicateFailure
EpochPastNextEpoch :: EpochDiff -> SdelegPredicateFailure
HasAlreadyDelegated :: SdelegPredicateFailure
IsAlreadyScheduled :: SdelegPredicateFailure
DoesNotVerify :: SdelegPredicateFailure
data SdelegsPredicateFailure
SDelegFailure :: PredicateFailure SDELEG -> SdelegsPredicateFailure
data MsdelegPredicateFailure
SDELEGFailure :: PredicateFailure SDELEG -> MsdelegPredicateFailure
data DelegPredicateFailure
SDelegSFailure :: PredicateFailure SDELEGS -> DelegPredicateFailure
ADelegSFailure :: PredicateFailure ADELEGS -> DelegPredicateFailure
tamperedDcerts :: DIEnv -> DIState -> Gen [DCert]
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Delegation.DIState
instance Test.Goblin.Core.SeedGoblin Byron.Spec.Ledger.Delegation.DSEnv
instance Test.Goblin.Core.AddShrinks Byron.Spec.Ledger.Delegation.DCert
instance Test.Goblin.Core.GeneOps genome => Test.Goblin.Core.Goblin genome Byron.Spec.Ledger.Delegation.DCert
instance Data.Data.Data Byron.Spec.Ledger.Delegation.SDELEG
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.EpochDiff
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.EpochDiff
instance Data.Data.Data Byron.Spec.Ledger.Delegation.EpochDiff
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.EpochDiff
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.EpochDiff
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.SdelegPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.SdelegPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Delegation.SdelegPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.SdelegPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.SdelegPredicateFailure
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.AdelegPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.AdelegPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Delegation.AdelegPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.AdelegPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.AdelegPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Delegation.ADELEG
instance Data.Data.Data Byron.Spec.Ledger.Delegation.SDELEGS
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.SdelegsPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.SdelegsPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Delegation.SdelegsPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.SdelegsPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.SdelegsPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Delegation.ADELEGS
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.AdelegsPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.AdelegsPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Delegation.AdelegsPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.AdelegsPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.AdelegsPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Delegation.DELEG
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.DelegPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.DelegPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Delegation.DelegPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.DelegPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.DelegPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Delegation.MSDELEG
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.MsdelegPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.MsdelegPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.Delegation.MsdelegPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.MsdelegPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.MsdelegPredicateFailure
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Delegation.MSDELEG
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Delegation.SDELEG Byron.Spec.Ledger.Delegation.MSDELEG
instance Control.State.Transition.Generator.HasTrace Byron.Spec.Ledger.Delegation.MSDELEG
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Delegation.DELEG
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Delegation.SDELEGS Byron.Spec.Ledger.Delegation.DELEG
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Delegation.ADELEGS Byron.Spec.Ledger.Delegation.DELEG
instance Control.State.Transition.Generator.HasTrace Byron.Spec.Ledger.Delegation.DELEG
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Delegation.ADELEGS
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Delegation.ADELEG Byron.Spec.Ledger.Delegation.ADELEGS
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Delegation.SDELEGS
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.Delegation.SDELEG Byron.Spec.Ledger.Delegation.SDELEGS
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Delegation.ADELEG
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.Delegation.SDELEG
instance Byron.Spec.Ledger.Delegation.HasDelegationMap Byron.Spec.Ledger.Delegation.DIState (Data.Bimap.Bimap Byron.Spec.Ledger.Core.VKeyGenesis Byron.Spec.Ledger.Core.VKey)
instance Byron.Spec.Ledger.Delegation.HasKeyEpochDelegations Byron.Spec.Ledger.Delegation.DIState (Data.Set.Internal.Set (Byron.Spec.Ledger.Core.Epoch, Byron.Spec.Ledger.Core.VKeyGenesis))
instance Byron.Spec.Ledger.Delegation.HasLastDelegation Byron.Spec.Ledger.Delegation.DIState (Data.Map.Internal.Map Byron.Spec.Ledger.Core.VKeyGenesis Byron.Spec.Ledger.Core.Slot)
instance Byron.Spec.Ledger.Delegation.HasScheduledDelegations Byron.Spec.Ledger.Delegation.DIState [(Byron.Spec.Ledger.Core.Slot, (Byron.Spec.Ledger.Core.VKeyGenesis, Byron.Spec.Ledger.Core.VKey))]
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.DIState
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.DIState
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.DIState
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.DIState
instance Byron.Spec.Ledger.Delegation.HasLastDelegation Byron.Spec.Ledger.Delegation.DState (Data.Map.Internal.Map Byron.Spec.Ledger.Core.VKeyGenesis Byron.Spec.Ledger.Core.Slot)
instance Byron.Spec.Ledger.Delegation.HasDelegationMap Byron.Spec.Ledger.Delegation.DState (Data.Bimap.Bimap Byron.Spec.Ledger.Core.VKeyGenesis Byron.Spec.Ledger.Core.VKey)
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.DState
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.DState
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.DState
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.DState
instance Byron.Spec.Ledger.Delegation.HasScheduledDelegations Byron.Spec.Ledger.Delegation.DSState [(Byron.Spec.Ledger.Core.Slot, (Byron.Spec.Ledger.Core.VKeyGenesis, Byron.Spec.Ledger.Core.VKey))]
instance Byron.Spec.Ledger.Delegation.HasKeyEpochDelegations Byron.Spec.Ledger.Delegation.DSState (Data.Set.Internal.Set (Byron.Spec.Ledger.Core.Epoch, Byron.Spec.Ledger.Core.VKeyGenesis))
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.DSState
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.DSState
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.DSState
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.DSState
instance Byron.Spec.Ledger.Delegation.HasSlot Byron.Spec.Ledger.Delegation.DSEnv Byron.Spec.Ledger.Core.Slot
instance Byron.Spec.Ledger.Delegation.HasK Byron.Spec.Ledger.Delegation.DSEnv Byron.Spec.Ledger.Core.BlockCount
instance Byron.Spec.Ledger.Delegation.HasEpoch Byron.Spec.Ledger.Delegation.DSEnv Byron.Spec.Ledger.Core.Epoch
instance Byron.Spec.Ledger.Delegation.HasAllowedDelegators Byron.Spec.Ledger.Delegation.DSEnv (Data.Set.Internal.Set Byron.Spec.Ledger.Core.VKeyGenesis)
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.DCert
instance Data.Data.Data Byron.Spec.Ledger.Delegation.DCert
instance Data.Hashable.Class.Hashable Byron.Spec.Ledger.Delegation.DCert
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.DCert
instance GHC.Classes.Ord Byron.Spec.Ledger.Delegation.DCert
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.DCert
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.DCert
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.Delegation.DSEnv
instance GHC.Generics.Generic Byron.Spec.Ledger.Delegation.DSEnv
instance GHC.Classes.Eq Byron.Spec.Ledger.Delegation.DSEnv
instance GHC.Show.Show Byron.Spec.Ledger.Delegation.DSEnv
instance Data.AbstractSize.HasTypeReps Byron.Spec.Ledger.Delegation.DCert
instance Byron.Spec.Ledger.Core.HasHash [Byron.Spec.Ledger.Delegation.DCert]

module Byron.Spec.Ledger.Delegation.Test
coverDelegFailures :: forall m a. (MonadTest m, HasCallStack, Data a) => CoverPercentage -> a -> m ()


-- | Generally useful generators not present in the upstream release of
--   Hedgehog
module Hedgehog.Gen.Double

-- | Generates a Double in the inclusive range [0, 1]
doubleInc :: Gen Double


-- | Generators for the <a>Update</a> values.
module Byron.Spec.Ledger.Update.Generators

-- | Generates valid protocol parameters
--   
--   TODO: The protocol parameters still need to be aligned with the formal
--   spec.
pparamsGen :: Gen PParams


-- | UTXO transition system with witnessing
module Byron.Spec.Ledger.STS.UTXOW
data UTXOW

-- | These <a>PredicateFailure</a>s are all throwable.
data UtxowPredicateFailure
UtxoFailure :: PredicateFailure UTXO -> UtxowPredicateFailure
InsufficientWitnesses :: UtxowPredicateFailure

-- | Determine if a UTxO input is authorized by a given key.
authTxin :: VKey -> TxIn -> UTxO -> Bool

-- | Given a ledger state, determine if the UTxO witnesses in a given
--   transaction are sufficient. TODO - should we only check for one
--   witness for each unique input address?
witnessed :: Tx -> UTxO -> Bool

-- | Constant list of addresses intended to be used in the generators.
traceAddrs :: [Addr]
goblinGensUTXOW :: [SignalGenerator UTXOW]
goblinGen_UTXOW_UtxoFailure_NonPositiveOutputs :: SignalGenerator UTXOW
goblinData_UTXOW_UtxoFailure_NonPositiveOutputs :: GoblinData Bool
goblinGen_UTXOW_UtxoFailure_InputsNotInUTxO :: SignalGenerator UTXOW
goblinData_UTXOW_UtxoFailure_InputsNotInUTxO :: GoblinData Bool
goblinGen_UTXOW_UtxoFailure_FeeTooLow :: SignalGenerator UTXOW
goblinData_UTXOW_UtxoFailure_FeeTooLow :: GoblinData Bool
goblinGen_UTXOW_UtxoFailure_EmptyTxOutputs :: SignalGenerator UTXOW
goblinData_UTXOW_UtxoFailure_EmptyTxOutputs :: GoblinData Bool
goblinGen_UTXOW_UtxoFailure_EmptyTxInputs :: SignalGenerator UTXOW
goblinData_UTXOW_UtxoFailure_EmptyTxInputs :: GoblinData Bool
goblinGen_UTXOW_InsufficientWitnesses :: SignalGenerator UTXOW
goblinData_UTXOW_InsufficientWitnesses :: GoblinData Bool
tamperedTxList :: UTxOEnv -> UTxOState -> Gen [Tx]

-- | Check that all the relevant predicate failures are covered.
coverUtxoFailure :: forall m a. (MonadTest m, HasCallStack, Data a) => CoverPercentage -> a -> m ()
instance Data.Data.Data Byron.Spec.Ledger.STS.UTXOW.UTXOW
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.STS.UTXOW.UtxowPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.STS.UTXOW.UtxowPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.STS.UTXOW.UtxowPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.STS.UTXOW.UtxowPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.STS.UTXOW.UtxowPredicateFailure
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.STS.UTXOW.UTXOW
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.STS.UTXO.UTXO Byron.Spec.Ledger.STS.UTXOW.UTXOW
instance Control.State.Transition.Generator.HasTrace Byron.Spec.Ledger.STS.UTXOW.UTXOW


-- | Transition system that models the application of multiple transactions
--   to the UTxO part of the ledger state.
module Byron.Spec.Ledger.STS.UTXOWS
data UTXOWS
data UtxowsPredicateFailure
UtxowFailure :: PredicateFailure UTXOW -> UtxowsPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.STS.UTXOWS.UTXOWS
instance NoThunks.Class.NoThunks Byron.Spec.Ledger.STS.UTXOWS.UtxowsPredicateFailure
instance GHC.Generics.Generic Byron.Spec.Ledger.STS.UTXOWS.UtxowsPredicateFailure
instance Data.Data.Data Byron.Spec.Ledger.STS.UTXOWS.UtxowsPredicateFailure
instance GHC.Show.Show Byron.Spec.Ledger.STS.UTXOWS.UtxowsPredicateFailure
instance GHC.Classes.Eq Byron.Spec.Ledger.STS.UTXOWS.UtxowsPredicateFailure
instance Control.State.Transition.Extended.STS Byron.Spec.Ledger.STS.UTXOWS.UTXOWS
instance Control.State.Transition.Extended.Embed Byron.Spec.Ledger.STS.UTXOW.UTXOW Byron.Spec.Ledger.STS.UTXOWS.UTXOWS
instance Control.State.Transition.Generator.HasTrace Byron.Spec.Ledger.STS.UTXOWS.UTXOWS
