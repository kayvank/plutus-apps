-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cardano ledger introducing Plutus Core
--   
--   This package builds upon the Mary ledger with support for extended
--   UTxO via Plutus Core.
@package cardano-ledger-alonzo
@version 0.1.0.0


-- | This module provides data structures and operations for talking about
--   Non-native Script languages. It is expected that new languages (or new
--   versions of old languages) will be added here.
module Cardano.Ledger.Alonzo.Language

-- | Non-Native Script language. This is an Enumerated type. This is
--   expected to be an open type. We will add new Constuctors to this type
--   as additional Non-Native scripting language as are added. We use an
--   enumerated type for two reasons. 1) We can write total functions by
--   case analysis over the constructors 2) We will use DataKinds to make
--   some datatypes indexed by Language For now, the only Non-Native
--   Scriting language is Plutus We might add new languages in the futures.
--   
--   Note that the the serialization of <a>Language</a> depends on the
--   ordering.
data Language
PlutusV1 :: Language
PlutusV2 :: Language
nonNativeLanguages :: [Language]
instance GHC.Ix.Ix Cardano.Ledger.Alonzo.Language.Language
instance GHC.Enum.Bounded Cardano.Ledger.Alonzo.Language.Language
instance GHC.Enum.Enum Cardano.Ledger.Alonzo.Language.Language
instance GHC.Classes.Ord Cardano.Ledger.Alonzo.Language.Language
instance GHC.Show.Show Cardano.Ledger.Alonzo.Language.Language
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.Language.Language
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.Language.Language
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.Language.Language
instance Control.DeepSeq.NFData Cardano.Ledger.Alonzo.Language.Language
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.Language.Language
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.Language.Language

module Cardano.Ledger.Alonzo.Scripts

-- | Marker indicating the part of a transaction for which this script is
--   acting as a validator.
data Tag

-- | Validates spending a script-locked UTxO
Spend :: Tag

-- | Validates minting new tokens
Mint :: Tag

-- | Validates certificate transactions
Cert :: Tag

-- | Validates withdrawl from a reward account
Rewrd :: Tag

-- | Scripts in the Alonzo Era, Either a Timelock script or a Plutus
--   script.
data Script era
TimelockScript :: Timelock (Crypto era) -> Script era
PlutusScript :: Language -> ShortByteString -> Script era

-- | Compute the cost of a script based upon prices and the number of
--   execution units.
txscriptfee :: Prices -> ExUnits -> Coin
isPlutusScript :: Script era -> Bool

-- | It is deliberate that there is no <a>Ord</a> instance for
--   <a>ExUnits</a>. Use this function to compare if one <tt>ExUnit</tt> is
--   pointwise compareable to another.
pointWiseExUnits :: (Natural -> Natural -> Bool) -> ExUnits -> ExUnits -> Bool

-- | A language dependent cost model for the Plutus evaluator. Note that
--   the <a>EvaluationContext</a> is entirely dependent on the cost model
--   parameters (ie the <a>Map</a> <a>Text</a> <a>Integer</a>) and that
--   this type uses the smart constructor <a>mkCostModel</a> to hide the
--   evaluation context.
data CostModel

-- | Convert cost model parameters to a cost model, making use of the
--   conversion function mkEvaluationContext from the Plutus API.
mkCostModel :: Language -> Map Text Integer -> Either CostModelApplyError CostModel
getCostModelLanguage :: CostModel -> Language
getCostModelParams :: CostModel -> Map Text Integer
getEvaluationContext :: CostModel -> EvaluationContext

-- | This newtype wrapper of ExUnits' is used to hide an implementation
--   detail inside the ExUnits pattern.
newtype ExUnits
WrapExUnits :: ExUnits' Natural -> ExUnits
[unWrapExUnits] :: ExUnits -> ExUnits' Natural

-- | Arbitrary execution unit in which we measure the cost of scripts in
--   terms of space in memory and execution time.
--   
--   This pattern hides the fact that ExUnits' is parametric in the
--   underlying type. The ledger itself uses <a>ExUnits</a> Natural'
--   exclusively.
--   
--   We would have preferred to use a type alias for <a>ExUnits</a>
--   Natural', but this is not possible:
--   <a>https://gitlab.haskell.org/ghc/ghc/-/issues/19507</a>.
pattern ExUnits :: Natural -> Natural -> ExUnits

-- | Arbitrary execution unit in which we measure the cost of scripts in
--   terms of space in memory and execution time.
--   
--   The ledger itself uses <a>ExUnits</a> Natural' exclusively, but the
--   flexibility here alows the consensus layer to translate the execution
--   units into something equivalent to 'ExUnits (Inf Natural)'. This is
--   needed in order to provide a <a>BoundedMeasure</a> instance, which
--   itself is needed for the alonzo instance of <tt>TxLimits</tt> (in
--   consensus).
data ExUnits' a

-- | Prices per execution unit
data Prices
Prices :: !NonNegativeInterval -> !NonNegativeInterval -> Prices
[prMem] :: Prices -> !NonNegativeInterval
[prSteps] :: Prices -> !NonNegativeInterval
hashCostModel :: forall e. Era e => Proxy e -> CostModel -> SafeHash (Crypto e) CostModel

-- | Comparably expensive to <a>mkEvaluationContext</a>, so it should only
--   be used sparingly.
assertWellFormedCostModelParams :: MonadError CostModelApplyError m => CostModelParams -> m ()
decodeCostModelMap :: Decoder s (Map Language CostModel)
decodeCostModel :: Language -> Decoder s CostModel
newtype CostModels
CostModels :: Map Language CostModel -> CostModels
[unCostModels] :: CostModels -> Map Language CostModel

-- | The type of errors that <a>applyParams</a> can throw.
data CostModelApplyError

-- | a costmodel parameter with the give name does not exist in the
--   costmodel to be applied upon
CMUnknownParamError :: Text -> CostModelApplyError

-- | internal error when we are transforming the applyParams' input to json
--   (should not happen)
CMInternalReadError :: CostModelApplyError

-- | internal error when we are transforming the applied params from json
--   with given jsonstring error (should not happen)
CMInternalWriteError :: String -> CostModelApplyError
instance GHC.Enum.Bounded Cardano.Ledger.Alonzo.Scripts.Tag
instance GHC.Enum.Enum Cardano.Ledger.Alonzo.Scripts.Tag
instance GHC.Show.Show Cardano.Ledger.Alonzo.Scripts.Tag
instance GHC.Classes.Ord Cardano.Ledger.Alonzo.Scripts.Tag
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.Scripts.Tag
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.Scripts.Tag
instance GHC.Classes.Ord (Cardano.Ledger.Alonzo.Scripts.Script era)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Scripts.Script era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.Scripts.Script era)
instance Data.Measure.Class.Measure a => GHC.Base.Semigroup (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance Data.Measure.Class.Measure a => GHC.Base.Monoid (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance Data.Measure.Class.BoundedMeasure a => Data.Measure.Class.BoundedMeasure (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance Data.Measure.Class.Measure a => Data.Measure.Class.Measure (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance GHC.Base.Functor Cardano.Ledger.Alonzo.Scripts.ExUnits'
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance GHC.Base.Semigroup Cardano.Ledger.Alonzo.Scripts.ExUnits
instance GHC.Base.Monoid Cardano.Ledger.Alonzo.Scripts.ExUnits
instance GHC.Show.Show Cardano.Ledger.Alonzo.Scripts.ExUnits
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.Scripts.ExUnits
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.Scripts.ExUnits
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.Scripts.CostModel
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.Scripts.CostModels
instance Control.DeepSeq.NFData Cardano.Ledger.Alonzo.Scripts.CostModels
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.Scripts.CostModels
instance GHC.Classes.Ord Cardano.Ledger.Alonzo.Scripts.CostModels
instance GHC.Show.Show Cardano.Ledger.Alonzo.Scripts.CostModels
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.Scripts.CostModels
instance GHC.Classes.Ord Cardano.Ledger.Alonzo.Scripts.Prices
instance GHC.Show.Show Cardano.Ledger.Alonzo.Scripts.Prices
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.Scripts.Prices
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.Scripts.Prices
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Scripts.Script era)
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.Scripts.Prices
instance Control.DeepSeq.NFData Cardano.Ledger.Alonzo.Scripts.Prices
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.Scripts.Prices
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.Scripts.Prices
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.Scripts.CostModels
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.Scripts.CostModels
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.Scripts.CostModel
instance GHC.Show.Show Cardano.Ledger.Alonzo.Scripts.CostModel
instance GHC.Classes.Ord Cardano.Ledger.Alonzo.Scripts.CostModel
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.Scripts.CostModel
instance Cardano.Ledger.SafeHash.SafeToHash Cardano.Ledger.Alonzo.Scripts.CostModel
instance Cardano.Ledger.SafeHash.HashWithCrypto Cardano.Ledger.Alonzo.Scripts.CostModel Cardano.Ledger.Alonzo.Scripts.CostModel
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.Scripts.CostModel
instance Control.DeepSeq.NFData Cardano.Ledger.Alonzo.Scripts.CostModel
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.Scripts.ExUnits
instance Control.DeepSeq.NFData Cardano.Ledger.Alonzo.Scripts.ExUnits
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.Scripts.ExUnits
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.Scripts.ExUnits
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance (Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era) => GHC.Show.Show (Cardano.Ledger.Alonzo.Scripts.Script era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.Scripts.Script era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Alonzo.Scripts.Script era)
instance (Data.Typeable.Internal.Typeable (Cardano.Ledger.Era.Crypto era), Data.Typeable.Internal.Typeable era) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Scripts.Script era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Era.Crypto era), Data.Typeable.Internal.Typeable era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.Scripts.Script era))
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.Scripts.Tag
instance Control.DeepSeq.NFData Cardano.Ledger.Alonzo.Scripts.Tag
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.Scripts.Tag
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.Scripts.Tag


-- | This module contains just the type of protocol parameters.
module Cardano.Ledger.Alonzo.PParams

-- | Protocol parameters. Shelley parameters + additional ones
data PParams' f era
PParams :: !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Coin -> !HKD f Coin -> !HKD f EpochNo -> !HKD f Natural -> !HKD f NonNegativeInterval -> !HKD f UnitInterval -> !HKD f UnitInterval -> !HKD f UnitInterval -> !HKD f Nonce -> !HKD f ProtVer -> !HKD f Coin -> !HKD f Coin -> !HKD f CostModels -> !HKD f Prices -> !HKD f ExUnits -> !HKD f ExUnits -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> PParams' f era

-- | The linear factor for the minimum fee calculation
[_minfeeA] :: PParams' f era -> !HKD f Natural

-- | The constant factor for the minimum fee calculation
[_minfeeB] :: PParams' f era -> !HKD f Natural

-- | Maximal block body size
[_maxBBSize] :: PParams' f era -> !HKD f Natural

-- | Maximal transaction size
[_maxTxSize] :: PParams' f era -> !HKD f Natural

-- | Maximal block header size
[_maxBHSize] :: PParams' f era -> !HKD f Natural

-- | The amount of a key registration deposit
[_keyDeposit] :: PParams' f era -> !HKD f Coin

-- | The amount of a pool registration deposit
[_poolDeposit] :: PParams' f era -> !HKD f Coin

-- | Maximum number of epochs in the future a pool retirement is allowed to
--   be scheduled for.
[_eMax] :: PParams' f era -> !HKD f EpochNo

-- | Desired number of pools
[_nOpt] :: PParams' f era -> !HKD f Natural

-- | Pool influence
[_a0] :: PParams' f era -> !HKD f NonNegativeInterval

-- | Monetary expansion
[_rho] :: PParams' f era -> !HKD f UnitInterval

-- | Treasury expansion
[_tau] :: PParams' f era -> !HKD f UnitInterval

-- | Decentralization parameter. Note that the scale is inverted here - a
--   value of 0 indicates full decentralisation, where 1 indicates full
--   federalisation.
[_d] :: PParams' f era -> !HKD f UnitInterval

-- | Extra entropy
[_extraEntropy] :: PParams' f era -> !HKD f Nonce

-- | Protocol version
[_protocolVersion] :: PParams' f era -> !HKD f ProtVer

-- | Minimum Stake Pool Cost
[_minPoolCost] :: PParams' f era -> !HKD f Coin

-- | Cost in lovelace per word (8 bytes) of UTxO storage (instead of
--   _minUTxOValue)
[_coinsPerUTxOWord] :: PParams' f era -> !HKD f Coin

-- | Cost models for non-native script languages
[_costmdls] :: PParams' f era -> !HKD f CostModels

-- | Prices of execution units (for non-native script languages)
[_prices] :: PParams' f era -> !HKD f Prices

-- | Max total script execution resources units allowed per tx
[_maxTxExUnits] :: PParams' f era -> !HKD f ExUnits

-- | Max total script execution resources units allowed per block
[_maxBlockExUnits] :: PParams' f era -> !HKD f ExUnits

-- | Max size of a Value in an output
[_maxValSize] :: PParams' f era -> !HKD f Natural

-- | Percentage of the txfee which must be provided as collateral when
--   including non-native scripts.
[_collateralPercentage] :: PParams' f era -> !HKD f Natural

-- | Maximum number of collateral inputs allowed in a transaction
[_maxCollateralInputs] :: PParams' f era -> !HKD f Natural
type PParams era = PParams' Identity era

-- | Returns a basic "empty" <a>PParams</a> structure with all zero values.
emptyPParams :: PParams era
type PParamsUpdate era = PParams' StrictMaybe era
emptyPParamsUpdate :: PParamsUpdate era

-- | Update operation for protocol parameters structure @PParams
updatePParams :: PParams era -> PParamsUpdate era -> PParams era
getLanguageView :: forall era. HasField "_costmdls" (PParams era) CostModels => PParams era -> Language -> LangDepView
data LangDepView
LangDepView :: ByteString -> ByteString -> LangDepView
[tag] :: LangDepView -> ByteString
[params] :: LangDepView -> ByteString
encodeLangViews :: Set LangDepView -> Encoding

-- | Turn an PParams' into a Shelley.Params'
retractPP :: HKD f Coin -> PParams' f era2 -> PParams' f era1

-- | Given the missing pieces Turn a Shelley.PParams' into an Params'
extendPP :: PParams' f era1 -> HKD f Coin -> HKD f CostModels -> HKD f Prices -> HKD f ExUnits -> HKD f ExUnits -> HKD f Natural -> HKD f Natural -> HKD f Natural -> PParams' f era2
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.PParams.PParams' f era)
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.PParams.LangDepView
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.PParams.LangDepView
instance GHC.Classes.Ord Cardano.Ledger.Alonzo.PParams.LangDepView
instance GHC.Show.Show Cardano.Ledger.Alonzo.PParams.LangDepView
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.PParams.LangDepView
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.PParams.PParams' Data.Functor.Identity.Identity era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.PParams.PParams' Data.Functor.Identity.Identity era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.PParams.PParams' Data.Functor.Identity.Identity era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.PParams.PParams era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.PParams.PParams era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.PParams.PParams era)
instance Data.Default.Class.Default (Cardano.Ledger.Alonzo.PParams.PParams era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.PParams.PParamsUpdate era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.PParams.PParamsUpdate era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.PParams.PParamsUpdate era)
instance GHC.Classes.Ord (Cardano.Ledger.Alonzo.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)

module Cardano.Ledger.Alonzo.Data
data Data era
pattern Data :: Data -> Data era
type DataHash crypto = SafeHash crypto EraIndependentData
hashData :: Era era => Data era -> DataHash (Crypto era)
getPlutusData :: Data era -> Data
dataHashSize :: StrictMaybe (DataHash c) -> Integer

-- | Inlined data must be stored in the most compact form because it
--   contributes to the memory overhead of the ledger state. Constructor is
--   intentionally not exported, in order to prevent invalid creation of
--   data from arbitrary binary data. Use <a>makeBinaryData</a> for smart
--   construction.
data BinaryData era
hashBinaryData :: Era era => BinaryData era -> DataHash (Crypto era)
makeBinaryData :: ShortByteString -> Either String (BinaryData era)

-- | It is safe to convert <a>BinaryData</a> to <a>Data</a> because the
--   only way to construct <a>BinaryData</a> is thorugh smart constructor
--   <a>makeBinaryData</a> that takes care of verification.
binaryDataToData :: BinaryData era -> Data era
dataToBinaryData :: Data era -> BinaryData era
decodeBinaryData :: BinaryData era -> Either DecoderError (Data era)

-- | Datum can be described by a either a data hash or binary data, but not
--   both. It can also be neither one of them.
data Datum era
NoDatum :: Datum era
DatumHash :: !DataHash (Crypto era) -> Datum era
Datum :: !BinaryData era -> Datum era

-- | Get the Hash of the datum.
datumDataHash :: Era era => Datum era -> StrictMaybe (DataHash (Crypto era))
data AuxiliaryData era
pattern AuxiliaryData :: (Era era, ToCBOR (Script era), Script era ~ Script era, Ord (Script era)) => Map Word64 Metadatum -> StrictSeq (Script era) -> AuxiliaryData era
pattern AuxiliaryData' :: Map Word64 Metadatum -> StrictSeq (Script era) -> AuxiliaryData era
newtype AuxiliaryDataHash crypto
AuxiliaryDataHash :: SafeHash crypto EraIndependentAuxiliaryData -> AuxiliaryDataHash crypto
[unsafeAuxiliaryDataHash] :: AuxiliaryDataHash crypto -> SafeHash crypto EraIndependentAuxiliaryData
instance Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.Data.Data era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Data.Data era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Alonzo.Data.Data era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.Data.Data era)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Data.Data era)
instance GHC.Classes.Ord (Cardano.Ledger.Alonzo.Data.Data era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.Data.Data era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Alonzo.Data.BinaryData era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.Data.BinaryData era)
instance GHC.Classes.Ord (Cardano.Ledger.Alonzo.Data.BinaryData era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.Data.BinaryData era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.Data.Datum era)
instance GHC.Classes.Ord (Cardano.Ledger.Alonzo.Data.Datum era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.Data.Datum era)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Data.AuxiliaryDataRaw era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Alonzo.Data.AuxiliaryData era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Data.AuxiliaryData era)
instance NoThunks.Class.NoThunks PlutusCore.Data.Data
instance GHC.Classes.Eq (Cardano.Ledger.Core.Script era) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.Data.AuxiliaryDataRaw era)
instance GHC.Show.Show (Cardano.Ledger.Core.Script era) => GHC.Show.Show (Cardano.Ledger.Alonzo.Data.AuxiliaryDataRaw era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Data.AuxiliaryDataRaw era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Core.Script era) => Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.Data.AuxiliaryData era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.Data.AuxiliaryData era)
instance GHC.Show.Show (Cardano.Ledger.Core.Script era) => GHC.Show.Show (Cardano.Ledger.Alonzo.Data.AuxiliaryData era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Data.AuxiliaryData era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Ord (Cardano.Ledger.Core.Script era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Ledger.Alonzo.Scripts.Script era GHC.Types.~ Cardano.Ledger.Core.Script era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.Data.AuxiliaryData era))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Alonzo.Data.AuxiliaryData era) Cardano.Ledger.Hashes.EraIndependentAuxiliaryData c
instance Control.DeepSeq.NFData (Cardano.Ledger.Core.Script era) => Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.Data.AuxiliaryDataRaw era)
instance (Data.Typeable.Internal.Typeable era, GHC.Classes.Ord (Cardano.Ledger.Core.Script era), Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Era.Crypto era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Data.AuxiliaryDataRaw era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Ord (Cardano.Ledger.Core.Script era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.Data.AuxiliaryDataRaw era))
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Data.Datum era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.Data.Datum era)
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Alonzo.Data.BinaryData era) Cardano.Ledger.Hashes.EraIndependentData c
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Data.BinaryData era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.Data.BinaryData era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.Data.Data era))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Alonzo.Data.Data era) Cardano.Ledger.Hashes.EraIndependentData c
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Data.Data era)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator PlutusCore.Data.Data)
instance Cardano.Binary.ToCBOR.ToCBOR PlutusCore.Data.Data
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Prelude.HeapWords.HeapWords (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Hashes.DataHash c))

module Cardano.Ledger.Alonzo.TxBody
data TxOut era
TxOutCompact' :: {-# UNPACK #-} !CompactAddr (Crypto era) -> !CompactForm (Value era) -> TxOut era
TxOutCompactDH' :: {-# UNPACK #-} !CompactAddr (Crypto era) -> !CompactForm (Value era) -> !DataHash (Crypto era) -> TxOut era
TxOut_AddrHash28_AdaOnly :: !Credential 'Staking (Crypto era) -> {-# UNPACK #-} !Addr28Extra -> {-# UNPACK #-} !CompactForm Coin -> TxOut era
TxOut_AddrHash28_AdaOnly_DataHash32 :: !Credential 'Staking (Crypto era) -> {-# UNPACK #-} !Addr28Extra -> {-# UNPACK #-} !CompactForm Coin -> {-# UNPACK #-} !DataHash32 -> TxOut era
pattern TxOut :: forall era. (Era era, Compactible (Value era), Val (Value era), HasCallStack) => Addr (Crypto era) -> Value era -> StrictMaybe (DataHash (Crypto era)) -> TxOut era
pattern TxOutCompact :: (Era era, Val (Value era), HasCallStack) => CompactAddr (Crypto era) -> CompactForm (Value era) -> TxOut era
pattern TxOutCompactDH :: forall era. (Era era, HasCallStack) => CompactAddr (Crypto era) -> CompactForm (Value era) -> DataHash (Crypto era) -> TxOut era
data Addr28Extra
data DataHash32
data TxBody era
pattern TxBody :: AlonzoBody era => Set (TxIn (Crypto era)) -> Set (TxIn (Crypto era)) -> StrictSeq (TxOut era) -> StrictSeq (DCert (Crypto era)) -> Wdrl (Crypto era) -> Coin -> ValidityInterval -> StrictMaybe (Update era) -> Set (KeyHash 'Witness (Crypto era)) -> Value (Crypto era) -> StrictMaybe (ScriptIntegrityHash (Crypto era)) -> StrictMaybe (AuxiliaryDataHash (Crypto era)) -> StrictMaybe Network -> TxBody era
inputs' :: TxBody era -> Set (TxIn (Crypto era))
collateral' :: TxBody era -> Set (TxIn (Crypto era))
outputs' :: TxBody era -> StrictSeq (TxOut era)
certs' :: TxBody era -> StrictSeq (DCert (Crypto era))
wdrls' :: TxBody era -> Wdrl (Crypto era)
txfee' :: TxBody era -> Coin
vldt' :: TxBody era -> ValidityInterval
update' :: TxBody era -> StrictMaybe (Update era)
reqSignerHashes' :: TxBody era -> Set (KeyHash 'Witness (Crypto era))
mint' :: TxBody era -> Value (Crypto era)
scriptIntegrityHash' :: TxBody era -> StrictMaybe (ScriptIntegrityHash (Crypto era))
adHash' :: TxBody era -> StrictMaybe (AuxiliaryDataHash (Crypto era))
txnetworkid' :: TxBody era -> StrictMaybe Network
getAdaOnly :: forall era. Val (Value era) => Proxy era -> Value era -> Maybe (CompactForm Coin)
decodeDataHash32 :: forall crypto. HashAlgorithm (HASH crypto) => DataHash32 -> Maybe (DataHash crypto)
encodeDataHash32 :: forall crypto. HashAlgorithm (HASH crypto) => DataHash crypto -> Maybe (SizeHash (HASH crypto) :~: 32, DataHash32)
encodeAddress28 :: forall crypto. HashAlgorithm (ADDRHASH crypto) => Network -> PaymentCredential crypto -> Maybe (SizeHash (ADDRHASH crypto) :~: 28, Addr28Extra)
decodeAddress28 :: forall crypto. HashAlgorithm (ADDRHASH crypto) => Credential 'Staking crypto -> Addr28Extra -> Maybe (Addr crypto)
viewCompactTxOut :: forall era. Era era => TxOut era -> (CompactAddr (Crypto era), CompactForm (Value era), StrictMaybe (DataHash (Crypto era)))
viewTxOut :: forall era. Era era => TxOut era -> (Addr (Crypto era), Value era, StrictMaybe (DataHash (Crypto era)))
type AlonzoBody era = (Era era, Compactible (Value era), ToCBOR (Script era), SerialisableData (PParamsDelta era))
data EraIndependentScriptIntegrity
type ScriptIntegrityHash crypto = SafeHash crypto EraIndependentScriptIntegrity
getAlonzoTxOutEitherAddr :: HashAlgorithm (ADDRHASH (Crypto era)) => TxOut era -> Either (Addr (Crypto era)) (CompactAddr (Crypto era))
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.TxBody.Addr28Extra
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.TxBody.DataHash32
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.TxBody.TxBodyRaw era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Alonzo.TxBody.TxBody era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.TxBody.TxBody era)
instance (GHC.Classes.Eq (Cardano.Ledger.Core.Value era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era)) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxBody.TxOut era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxBody.TxOut era)
instance (GHC.Classes.Eq (Cardano.Ledger.Core.Value era), Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Classes.Eq (Cardano.Ledger.Core.PParamsDelta era)) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era)) => GHC.Show.Show (Cardano.Ledger.Alonzo.TxBody.TxBodyRaw era)
instance Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxBody.TxBody era)
instance (Data.Typeable.Internal.Typeable era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParamsDelta era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxBody.TxBody era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Data.Typeable.Internal.Typeable era, Control.DeepSeq.NFData (Cardano.Ledger.Core.Value era), Control.DeepSeq.NFData (Cardano.Ledger.Core.PParamsDelta era)) => Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxBody.TxBody era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era)) => GHC.Show.Show (Cardano.Ledger.Alonzo.TxBody.TxBody era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Ledger.Core.SerialisableData (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.TxBody.TxBody era))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Alonzo.TxBody.TxBody era) Cardano.Ledger.Hashes.EraIndependentTxBody c
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "inputs" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn c))
instance GHC.Records.HasField "outputs" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Alonzo.TxBody.TxOut era))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "certs" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Shelley.TxBody.DCert crypto))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "wdrls" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance GHC.Records.HasField "txfee" (Cardano.Ledger.Alonzo.TxBody.TxBody era) Cardano.Ledger.Coin.Coin
instance GHC.Records.HasField "update" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Shelley.PParams.Update era))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "referenceInputs" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn crypto))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "reqSignerHashes" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.Keys.KeyHash 'Cardano.Ledger.Keys.Witness c))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "mint" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Cardano.Ledger.Mary.Value.Value c)
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "collateral" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn c))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ c) => GHC.Records.HasField "minted" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.Hashes.ScriptHash c))
instance GHC.Records.HasField "vldt" (Cardano.Ledger.Alonzo.TxBody.TxBody era) Cardano.Ledger.ShelleyMA.Timelocks.ValidityInterval
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "adHash" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash c))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "scriptIntegrityHash" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Alonzo.TxBody.ScriptIntegrityHash c))
instance GHC.Records.HasField "txnetworkid" (Cardano.Ledger.Alonzo.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe Cardano.Ledger.BaseTypes.Network)
instance (Data.Typeable.Internal.Typeable era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParamsDelta era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Data.Typeable.Internal.Typeable era, Control.DeepSeq.NFData (Cardano.Ledger.Core.Value era), Control.DeepSeq.NFData (Cardano.Ledger.Core.PParamsDelta era)) => Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParamsDelta era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParamsDelta era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.TxBody.TxBodyRaw era))
instance Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Core.Value era))) => GHC.Show.Show (Cardano.Ledger.Alonzo.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era)) => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Alonzo.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.Value era GHC.Types.~ val, Cardano.Ledger.Compactible.Compactible val) => GHC.Records.HasField "value" (Cardano.Ledger.Alonzo.TxBody.TxOut era) val
instance (Cardano.Ledger.Era.Era era, c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "datahash" (Cardano.Ledger.Alonzo.TxBody.TxOut era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Hashes.DataHash c))
instance GHC.Records.HasField "referenceScript" (Cardano.Ledger.Alonzo.TxBody.TxOut era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Alonzo.Scripts.Script era))

module Cardano.Ledger.Alonzo.Genesis
data AlonzoGenesis
AlonzoGenesis :: !Coin -> !CostModels -> !Prices -> !ExUnits -> !ExUnits -> !Natural -> !Natural -> !Natural -> AlonzoGenesis
[coinsPerUTxOWord] :: AlonzoGenesis -> !Coin
[costmdls] :: AlonzoGenesis -> !CostModels
[prices] :: AlonzoGenesis -> !Prices
[maxTxExUnits] :: AlonzoGenesis -> !ExUnits
[maxBlockExUnits] :: AlonzoGenesis -> !ExUnits
[maxValSize] :: AlonzoGenesis -> !Natural
[collateralPercentage] :: AlonzoGenesis -> !Natural
[maxCollateralInputs] :: AlonzoGenesis -> !Natural

-- | Given the missing pieces turn a Shelley.PParams' into an Params'
extendPPWithGenesis :: PParams' Identity era1 -> AlonzoGenesis -> PParams' Identity era2
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.Genesis.AlonzoGenesis
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.Genesis.AlonzoGenesis
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.Genesis.AlonzoGenesis
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Alonzo.Scripts.ExUnits' a)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.PParams.PParamsUpdate era)
instance GHC.Show.Show Cardano.Ledger.Alonzo.Genesis.AlonzoGenesis
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.Genesis.AlonzoGenesis
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.Genesis.AlonzoGenesis
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Alonzo.Genesis.AlonzoGenesis
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Alonzo.Genesis.AlonzoGenesis
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Alonzo.Scripts.ExUnits
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Alonzo.Scripts.ExUnits
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Alonzo.Scripts.Prices
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Alonzo.Scripts.Prices
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Alonzo.Scripts.CostModel
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Alonzo.Scripts.CostModels
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Alonzo.Language.Language
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Alonzo.Language.Language
instance Data.Aeson.Types.ToJSON.ToJSONKey Cardano.Ledger.Alonzo.Language.Language
instance Data.Aeson.Types.FromJSON.FromJSONKey Cardano.Ledger.Alonzo.Language.Language
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Alonzo.Scripts.CostModels
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.PParams.PParams era)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Alonzo.PParams.PParams era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Value era), Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Core.Value era)) => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Alonzo.TxBody.TxOut era)

module Cardano.Ledger.Alonzo.TxWitness
data RdmrPtr
RdmrPtr :: !Tag -> {-# UNPACK #-} !Word64 -> RdmrPtr
data Redeemers era
pattern Redeemers :: Era era => Map RdmrPtr (Data era, ExUnits) -> Redeemers era
pattern Redeemers' :: Map RdmrPtr (Data era, ExUnits) -> Redeemers era
unRedeemers :: Redeemers era -> Map RdmrPtr (Data era, ExUnits)
nullRedeemers :: Redeemers era -> Bool
data TxDats era
pattern TxDats :: Typeable era => Map (DataHash (Crypto era)) (Data era) -> TxDats era
pattern TxDats' :: Map (DataHash (Crypto era)) (Data era) -> TxDats era
data TxWitness era
pattern TxWitness :: (Era era, Script era ~ Script era) => Set (WitVKey 'Witness (Crypto era)) -> Set (BootstrapWitness (Crypto era)) -> Map (ScriptHash (Crypto era)) (Script era) -> TxDats era -> Redeemers era -> TxWitness era
pattern TxWitness' :: Set (WitVKey 'Witness (Crypto era)) -> Set (BootstrapWitness (Crypto era)) -> Map (ScriptHash (Crypto era)) (Script era) -> TxDats era -> Redeemers era -> TxWitness era
unTxDats :: TxDats era -> Map (DataHash (Crypto era)) (Data era)
nullDats :: TxDats era -> Bool
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.TxWitness.RdmrPtr
instance GHC.Show.Show Cardano.Ledger.Alonzo.TxWitness.RdmrPtr
instance GHC.Classes.Ord Cardano.Ledger.Alonzo.TxWitness.RdmrPtr
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.TxWitness.RdmrPtr
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxWitness.RedeemersRaw era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.RedeemersRaw era)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.TxWitness.RedeemersRaw era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.TxWitness.RedeemersRaw era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxWitness.RedeemersRaw era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.Redeemers era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Alonzo.TxWitness.Redeemers era)
instance Data.Typeable.Internal.Typeable era => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxWitness.Redeemers era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.TxWitness.Redeemers era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.TxWitness.Redeemers era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxWitness.Redeemers era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.TxDatsRaw era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxWitness.TxDatsRaw era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.TxWitness.TxDatsRaw era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxWitness.TxDatsRaw era)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.TxWitness.TxDatsRaw era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.TxDats era)
instance Data.Typeable.Internal.Typeable era => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxWitness.TxDats era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.TxWitness.TxDats era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxWitness.TxDats era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.TxWitness.TxDats era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Alonzo.TxWitness.TxDats era)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.TxWitness.TxWitnessRaw era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.TxWitness.TxWitness era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Alonzo.TxWitness.TxWitness era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era, crypto GHC.Types.~ Cardano.Ledger.Era.Crypto era, Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.TxDats era), Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.Redeemers era), Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN (Cardano.Ledger.Crypto.DSIGN crypto)), Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN (Cardano.Ledger.Crypto.DSIGN crypto))) => Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.TxWitness era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.TxWitness.TxDats era))
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.Script era)) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxWitness.TxWitnessRaw era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Script era)) => GHC.Show.Show (Cardano.Ledger.Alonzo.TxWitness.TxWitnessRaw era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxWitness.TxWitness era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Script era)) => GHC.Show.Show (Cardano.Ledger.Alonzo.TxWitness.TxWitness era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.Script era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxWitness.TxWitness era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.TxWitness.Redeemers era))
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.TxWitness.TxWitness era))
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era) => GHC.Base.Semigroup (Cardano.Ledger.Alonzo.TxWitness.TxWitness era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era) => GHC.Base.Monoid (Cardano.Ledger.Alonzo.TxWitness.TxWitness era)
instance (Cardano.Ledger.Core.Script era GHC.Types.~ script, Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "txscripts" (Cardano.Ledger.Alonzo.TxWitness.TxWitness era) (Data.Map.Internal.Map (Cardano.Ledger.Hashes.ScriptHash crypto) script)
instance GHC.Records.HasField "txdats" (Cardano.Ledger.Alonzo.TxWitness.TxWitness era) (Cardano.Ledger.Alonzo.TxWitness.TxDats era)
instance GHC.Records.HasField "txrdmrs" (Cardano.Ledger.Alonzo.TxWitness.TxWitness era) (Cardano.Ledger.Alonzo.TxWitness.Redeemers era)
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "addrWits" (Cardano.Ledger.Alonzo.TxWitness.TxWitness era) (Data.Set.Internal.Set (Cardano.Ledger.Shelley.TxBody.WitVKey 'Cardano.Ledger.Keys.Witness crypto))
instance (Cardano.Ledger.Core.Script era GHC.Types.~ script, Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "scriptWits" (Cardano.Ledger.Alonzo.TxWitness.TxWitness era) (Data.Map.Internal.Map (Cardano.Ledger.Hashes.ScriptHash crypto) script)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era, crypto GHC.Types.~ Cardano.Ledger.Era.Crypto era, Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.TxDats era), Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.Redeemers era), Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN (Cardano.Ledger.Crypto.DSIGN crypto)), Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN (Cardano.Ledger.Crypto.DSIGN crypto))) => Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.TxWitnessRaw era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.Script era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxWitness.TxWitnessRaw era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Data.Data era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.TxWitness.TxWitnessRaw era))
instance Data.Typeable.Internal.Typeable era => GHC.Base.Semigroup (Cardano.Ledger.Alonzo.TxWitness.TxDats era)
instance Data.Typeable.Internal.Typeable era => GHC.Base.Monoid (Cardano.Ledger.Alonzo.TxWitness.TxDats era)
instance (Data.Typeable.Internal.Typeable era, Cardano.Ledger.Era.Era era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.TxWitness.TxDatsRaw era))
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.TxWitness.RedeemersRaw era))
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.TxWitness.RdmrPtr
instance Control.DeepSeq.NFData Cardano.Ledger.Alonzo.TxWitness.RdmrPtr
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.TxWitness.RdmrPtr
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.TxWitness.RdmrPtr
instance Cardano.Ledger.Serialization.ToCBORGroup Cardano.Ledger.Alonzo.TxWitness.RdmrPtr
instance Cardano.Ledger.Serialization.FromCBORGroup Cardano.Ledger.Alonzo.TxWitness.RdmrPtr


-- | This module exports implementations of many of the functions outlined
--   in the Alonzo specification. The link to source of the specification
--   <a>https://github.com/input-output-hk/cardano-ledger/tree/master/eras/alonzo/formal-spec</a>
--   The most recent version of the document can be found here:
--   <a>https://hydra.iohk.io/job/Cardano/cardano-ledger/specs.alonzo-ledger/latest/download-by-type/doc-pdf/alonzo-changes</a>
--   The functions can be found in Figures in that document, and sections
--   of this code refer to those figures.
module Cardano.Ledger.Alonzo.Tx

-- | A language dependent cost model for the Plutus evaluator. Note that
--   the <a>EvaluationContext</a> is entirely dependent on the cost model
--   parameters (ie the <a>Map</a> <a>Text</a> <a>Integer</a>) and that
--   this type uses the smart constructor <a>mkCostModel</a> to hide the
--   evaluation context.
data CostModel
getLanguageView :: forall era. HasField "_costmdls" (PParams era) CostModels => PParams era -> Language -> LangDepView
data Data era
type DataHash crypto = SafeHash crypto EraIndependentData

-- | Tag indicating whether non-native scripts in this transaction are
--   expected to validate. This is added by the block creator when
--   constructing the block.
newtype IsValid
IsValid :: Bool -> IsValid
hashData :: Era era => Data era -> DataHash (Crypto era)
nonNativeLanguages :: [Language]
hashScriptIntegrity :: forall era. Era era => Set LangDepView -> Redeemers era -> TxDats era -> StrictMaybe (ScriptIntegrityHash (Crypto era))
getCoin :: Era era => TxOut era -> Coin
data EraIndependentScriptIntegrity

-- | A ScriptIntegrityHash is the hash of three things. The first two come
--   from the witnesses and the last comes from the Protocol Parameters.
data ScriptIntegrity era
ScriptIntegrity :: !Redeemers era -> !TxDats era -> !Set LangDepView -> ScriptIntegrity era
type ScriptIntegrityHash crypto = SafeHash crypto EraIndependentScriptIntegrity
data ValidatedTx era
ValidatedTx :: !TxBody era -> !TxWitness era -> !IsValid -> !StrictMaybe (AuxiliaryData era) -> ValidatedTx era
[body] :: ValidatedTx era -> !TxBody era
[wits] :: ValidatedTx era -> !TxWitness era
[isValid] :: ValidatedTx era -> !IsValid
[auxiliaryData] :: ValidatedTx era -> !StrictMaybe (AuxiliaryData era)
txdats' :: TxWitness era -> TxDats era
txscripts' :: TxWitness era -> Map (ScriptHash (Crypto era)) (Script era)
txrdmrs :: TxWitness era -> (Era era, Script era ~ Script era) => Redeemers era
data TxBody era
pattern TxBody :: AlonzoBody era => Set (TxIn (Crypto era)) -> Set (TxIn (Crypto era)) -> StrictSeq (TxOut era) -> StrictSeq (DCert (Crypto era)) -> Wdrl (Crypto era) -> Coin -> ValidityInterval -> StrictMaybe (Update era) -> Set (KeyHash 'Witness (Crypto era)) -> Value (Crypto era) -> StrictMaybe (ScriptIntegrityHash (Crypto era)) -> StrictMaybe (AuxiliaryDataHash (Crypto era)) -> StrictMaybe Network -> TxBody era
totExUnits :: (HasField "wits" (Tx era) (Witnesses era), HasField "txrdmrs" (Witnesses era) (Redeemers era)) => Tx era -> ExUnits
isTwoPhaseScriptAddress :: forall era. ValidateScript era => ValidatedTx era -> Addr (Crypto era) -> Bool
minfee :: (HasField "_minfeeA" (PParams era) Natural, HasField "_minfeeB" (PParams era) Natural, HasField "_prices" (PParams era) Prices, HasField "wits" (Tx era) (Witnesses era), HasField "txrdmrs" (Witnesses era) (Redeemers era), HasField "txsize" (Tx era) Integer) => PParams era -> Tx era -> Coin
class Indexable elem container
indexOf :: Indexable elem container => elem -> container -> StrictMaybe Word64
fromIndex :: Indexable elem container => Word64 -> container -> StrictMaybe elem
data ScriptPurpose crypto
Minting :: !PolicyID crypto -> ScriptPurpose crypto
Spending :: !TxIn crypto -> ScriptPurpose crypto
Rewarding :: !RewardAcnt crypto -> ScriptPurpose crypto
Certifying :: !DCert crypto -> ScriptPurpose crypto

-- | Compute if an Addr has the hash of a TwoPhaseScript, we can tell what
--   kind of Script from the Hash, by looking it up in the Map
isTwoPhaseScriptAddressFromMap :: forall era. ValidateScript era => Map (ScriptHash (Crypto era)) (Script era) -> Addr (Crypto era) -> Bool
alonzoInputHashes :: forall era. (HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), ValidateScript era, TxOut era ~ TxOut era) => Map (ScriptHash (Crypto era)) (Script era) -> ValidatedTx era -> UTxO era -> (Set (DataHash (Crypto era)), Set (TxIn (Crypto era)))

-- | Compute the transaction outputs of a transaction.
txouts :: Era era => TxBody era -> UTxO era

-- | Find the Data and ExUnits assigned to a script.
indexedRdmrs :: forall era tx. (Era era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wits" tx (TxWitness era), HasField "body" tx (TxBody era)) => tx -> ScriptPurpose (Crypto era) -> Maybe (Data era, ExUnits)
rdptr :: forall era. (HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "minted" (TxBody era) (Set (ScriptHash (Crypto era)))) => TxBody era -> ScriptPurpose (Crypto era) -> StrictMaybe RdmrPtr
rdptrInv :: forall era. (HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "minted" (TxBody era) (Set (ScriptHash (Crypto era)))) => TxBody era -> RdmrPtr -> StrictMaybe (ScriptPurpose (Crypto era))
getMapFromValue :: Value crypto -> Map (PolicyID crypto) (Map AssetName Integer)
segwitTx :: Annotator (TxBody era) -> Annotator (TxWitness era) -> IsValid -> Maybe (Annotator (AuxiliaryData era)) -> Annotator (ValidatedTx era)

-- | This ensures that the size of transactions from Mary is unchanged. The
--   individual components all store their bytes; the only work we do in
--   this function is concatenating
toCBORForSizeComputation :: (Typeable era, ToCBOR (TxBody era), ToCBOR (AuxiliaryData era)) => ValidatedTx era -> Encoding

-- | Encode to CBOR for the purposes of transmission from node to node, or
--   from wallet to node.
--   
--   Note that this serialisation is neither the serialisation used
--   on-chain (where Txs are deconstructed using segwit), nor the
--   serialisation used for computing the transaction size (which omits the
--   <a>IsValid</a> field for compatibility with Mary - see
--   <a>toCBORForSizeComputation</a>).
toCBORForMempoolSubmission :: (Typeable era, ToCBOR (TxBody era), ToCBOR (AuxiliaryData era)) => ValidatedTx era -> Encoding
instance Control.DeepSeq.NFData Cardano.Ledger.Alonzo.Tx.IsValid
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.Tx.IsValid
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.Tx.IsValid
instance GHC.Show.Show Cardano.Ledger.Alonzo.Tx.IsValid
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.Tx.IsValid
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Tx.ValidatedTx era)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Tx.ScriptIntegrity era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.Tx.ScriptIntegrity era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.Tx.ScriptIntegrity era)
instance Cardano.Ledger.Crypto.Crypto crypto => Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.Tx.ScriptPurpose crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Tx.ScriptPurpose crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Tx.ScriptPurpose crypto)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.Tx.ScriptPurpose crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.Tx.ScriptPurpose crypto)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.AuxiliaryData era), GHC.Classes.Eq (Cardano.Ledger.Core.Script era), GHC.Classes.Eq (Cardano.Ledger.Core.TxBody era), GHC.Classes.Eq (Cardano.Ledger.Core.Value era), GHC.Classes.Eq (Cardano.Ledger.Core.PParamsDelta era), Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era)) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.Tx.ValidatedTx era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Compactible.Compactible (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.AuxiliaryData era), GHC.Show.Show (Cardano.Ledger.Core.Script era), GHC.Show.Show (Cardano.Ledger.Core.TxBody era), GHC.Show.Show (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era)) => GHC.Show.Show (Cardano.Ledger.Alonzo.Tx.ValidatedTx era)
instance Data.Typeable.Internal.Typeable era => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Tx.ScriptIntegrity era)
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.Tx.IsValid
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.Tx.IsValid
instance GHC.Classes.Ord k => Cardano.Ledger.Alonzo.Tx.Indexable k (Data.Set.Internal.Set k)
instance GHC.Classes.Eq k => Cardano.Ledger.Alonzo.Tx.Indexable k (Data.Sequence.Strict.StrictSeq k)
instance GHC.Classes.Ord k => Cardano.Ledger.Alonzo.Tx.Indexable k (Data.Map.Internal.Map k v)
instance (Data.Typeable.Internal.Typeable c, Cardano.Ledger.Crypto.Crypto c) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Tx.ScriptPurpose c)
instance (Data.Typeable.Internal.Typeable c, Cardano.Ledger.Crypto.Crypto c) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.Tx.ScriptPurpose c)
instance Cardano.Ledger.Era.Era era => Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Alonzo.Tx.ScriptIntegrity era)
instance (Cardano.Ledger.Era.Era era, c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Alonzo.Tx.ScriptIntegrity era) Cardano.Ledger.Hashes.EraIndependentScriptIntegrity c
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.AuxiliaryData era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.Script era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxBody era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParamsDelta era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Tx.ValidatedTx era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era, crypto GHC.Types.~ Cardano.Ledger.Era.Crypto era, Control.DeepSeq.NFData (Cardano.Ledger.Core.AuxiliaryData era), Control.DeepSeq.NFData (Cardano.Ledger.Core.Script era), Control.DeepSeq.NFData (Cardano.Ledger.Core.TxBody era), Control.DeepSeq.NFData (Cardano.Ledger.Core.Value era), Control.DeepSeq.NFData (Cardano.Ledger.Core.PParamsDelta era), Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.TxDats era), Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.TxWitness.Redeemers era), Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN (Cardano.Ledger.Crypto.DSIGN crypto)), Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN (Cardano.Ledger.Crypto.DSIGN crypto))) => Control.DeepSeq.NFData (Cardano.Ledger.Alonzo.Tx.ValidatedTx era)
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "addrWits" (Cardano.Ledger.Alonzo.Tx.ValidatedTx era) (Data.Set.Internal.Set (Cardano.Ledger.Shelley.TxBody.WitVKey 'Cardano.Ledger.Keys.Witness c))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era, script GHC.Types.~ Cardano.Ledger.Core.Script era) => GHC.Records.HasField "scriptWits" (Cardano.Ledger.Alonzo.Tx.ValidatedTx era) (Data.Map.Internal.Map (Cardano.Ledger.Hashes.ScriptHash c) script)
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "bootWits" (Cardano.Ledger.Alonzo.Tx.ValidatedTx era) (Data.Set.Internal.Set (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness c))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "txdatahash" (Cardano.Ledger.Alonzo.Tx.ValidatedTx era) (Data.Map.Internal.Map (Cardano.Ledger.Hashes.DataHash c) (Cardano.Ledger.Alonzo.Data.Data era))
instance (Data.Typeable.Internal.Typeable era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxBody era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.AuxiliaryData era)) => GHC.Records.HasField "txsize" (Cardano.Ledger.Alonzo.Tx.ValidatedTx era) GHC.Integer.Type.Integer
instance (Data.Typeable.Internal.Typeable era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxBody era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.AuxiliaryData era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Tx.ValidatedTx era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.TxBody era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.AuxiliaryData era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Witnesses era)), Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.Tx.ValidatedTx era))


-- | TxSeq. This is effectively the block body, which consists of a
--   sequence of transactions with segregated witness and metadata
--   information.
module Cardano.Ledger.Alonzo.TxSeq
data TxSeq era
pattern TxSeq :: forall era. (Era era, SafeToHash (TxWitness era)) => StrictSeq (ValidatedTx era) -> TxSeq era

-- | Hash a given block body
hashTxSeq :: forall era. Era era => TxSeq era -> Hash (Crypto era) EraIndependentBlockBody
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.TxSeq.TxSeq era)
instance (Data.Typeable.Internal.Typeable era, NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Tx.ValidatedTx era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxSeq.TxSeq era)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.Tx.ValidatedTx era) => GHC.Show.Show (Cardano.Ledger.Alonzo.TxSeq.TxSeq era)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.Tx.ValidatedTx era) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxSeq.TxSeq era)
instance Cardano.Ledger.Era.Era era => Cardano.Ledger.Serialization.ToCBORGroup (Cardano.Ledger.Alonzo.TxSeq.TxSeq era)
instance (Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.AuxiliaryData era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.TxBody era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Witnesses era)), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.AuxiliaryData era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Script era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxBody era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Witnesses era), Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Core.Script era GHC.Types.~ Cardano.Ledger.Alonzo.Scripts.Script era, Cardano.Ledger.Era.Era era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Alonzo.TxSeq.TxSeq era))

module Cardano.Ledger.Alonzo.TxInfo

-- | A transaction output can be translated because it is a newly created
--   output, or because it is the output which is connected to a
--   transaction input being spent.
data TxOutSource crypto
TxOutFromInput :: !TxIn crypto -> TxOutSource crypto
TxOutFromOutput :: !TxIx -> TxOutSource crypto
data TranslationError crypto
ByronTxOutInContext :: !TxOutSource crypto -> TranslationError crypto
TranslationLogicMissingInput :: !TxIn crypto -> TranslationError crypto
RdmrPtrPointsToNothing :: !RdmrPtr -> TranslationError crypto
LanguageNotSupported :: !Language -> TranslationError crypto
InlineDatumsNotSupported :: !TxOutSource crypto -> TranslationError crypto
ReferenceScriptsNotSupported :: !TxOutSource crypto -> TranslationError crypto
ReferenceInputsNotSupported :: !Set (TxIn crypto) -> TranslationError crypto
TimeTranslationPastHorizon :: !Text -> TranslationError crypto
transDataHash :: StrictMaybe (DataHash c) -> Maybe DatumHash
transDataHash' :: DataHash c -> DatumHash
transKeyHash :: KeyHash d c -> PubKeyHash
transScriptHash :: ScriptHash c -> ValidatorHash
transSafeHash :: SafeHash c i -> BuiltinByteString
transHash :: Hash h a -> ByteString
txInfoId :: TxId crypto -> TxId
transStakeCred :: Credential keyrole crypto -> Credential
transStakeReference :: StakeReference crypto -> Maybe StakingCredential
transCred :: Credential keyrole crypto -> Credential
transAddr :: Addr crypto -> Maybe Address
transTxOutAddr :: Era era => TxOut era -> Maybe Address
slotToPOSIXTime :: HasField "_protocolVersion" (PParams era) ProtVer => PParams era -> EpochInfo (Either Text) -> SystemStart -> SlotNo -> Either Text POSIXTime

-- | translate a validity interval to POSIX time
transVITime :: HasField "_protocolVersion" (PParams era) ProtVer => PParams era -> EpochInfo (Either Text) -> SystemStart -> ValidityInterval -> Either Text POSIXTimeRange
txInfoIn' :: TxIn c -> TxOutRef

-- | Given a TxIn, look it up in the UTxO. If it exists, translate it and
--   return (Just translation). If does not exist in the UTxO, return
--   Nothing.
txInfoIn :: forall era c i. (Era era, Value era ~ Value (Crypto era), HasField "datahash" (TxOut era) (StrictMaybe (SafeHash c i))) => TxIn (Crypto era) -> TxOut era -> Maybe TxInInfo

-- | Given a TxOut, translate it and return (Just transalation). It is
--   possible the address part is a Bootstrap Address, in that case return
--   Nothing I.e. don't include Bootstrap Addresses in the answer.
txInfoOut :: forall era c. (Era era, Value era ~ Value (Crypto era), HasField "datahash" (TxOut era) (StrictMaybe (DataHash c))) => TxOut era -> Maybe TxOut
transPolicyID :: PolicyID crypto -> CurrencySymbol
transAssetName :: AssetName -> TokenName
transValue :: Value c -> Value
transDCert :: DCert c -> DCert
transWdrl :: Wdrl crypto -> Map StakingCredential Integer
getWitVKeyHash :: (Crypto crypto, Typeable kr) => WitVKey kr crypto -> PubKeyHash
transDataPair :: (DataHash c, Data era) -> (DatumHash, Datum)
transExUnits :: ExUnits -> ExBudget
exBudgetToExUnits :: ExBudget -> Maybe ExUnits
transScriptPurpose :: ScriptPurpose crypto -> ScriptPurpose
data VersionedTxInfo
TxInfoPV1 :: TxInfo -> VersionedTxInfo
TxInfoPV2 :: TxInfo -> VersionedTxInfo

-- | Where we keep functions that differ from Era to Era but which deal
--   with the extra things in the TxOut (Scripts, DataHash, Datum, etc)
class ExtendedUTxO era
txInfo :: ExtendedUTxO era => PParams era -> Language -> EpochInfo (Either Text) -> SystemStart -> UTxO era -> Tx era -> Either (TranslationError (Crypto era)) VersionedTxInfo
inputDataHashes :: ExtendedUTxO era => Map (ScriptHash (Crypto era)) (Script era) -> ValidatedTx era -> UTxO era -> (Set (DataHash (Crypto era)), Set (TxIn (Crypto era)))
txscripts :: ExtendedUTxO era => UTxO era -> Tx era -> Map (ScriptHash (Crypto era)) (Script era)
getAllowedSupplimentalDataHashes :: ExtendedUTxO era => TxBody era -> UTxO era -> Set (DataHash (Crypto era))
getDatum :: ExtendedUTxO era => Tx era -> UTxO era -> ScriptPurpose (Crypto era) -> Maybe (Data era)
getTxOutDatum :: ExtendedUTxO era => TxOut era -> Datum era
allOuts :: ExtendedUTxO era => TxBody era -> [TxOut era]
allSizedOuts :: ExtendedUTxO era => TxBody era -> [Sized (TxOut era)]
alonzoTxInfo :: forall era. (Era era, Value era ~ Value (Crypto era), HasField "wits" (Tx era) (TxWitness era), HasField "datahash" (TxOut era) (StrictMaybe (SafeHash (Crypto era) EraIndependentData)), HasField "_protocolVersion" (PParams era) ProtVer, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "reqSignerHashes" (TxBody era) (Set (KeyHash 'Witness (Crypto era))), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "mint" (TxBody era) (Value (Crypto era)), HasField "vldt" (TxBody era) ValidityInterval) => PParams era -> Language -> EpochInfo (Either Text) -> SystemStart -> UTxO era -> Tx era -> Either (TranslationError (Crypto era)) VersionedTxInfo

-- | valContext pairs transaction data with a script purpose. See figure 22
--   of the Alonzo specification.
valContext :: VersionedTxInfo -> ScriptPurpose (Crypto era) -> Data era
data ScriptFailure
PlutusSF :: Text -> PlutusDebug -> ScriptFailure
data ScriptResult
Passes :: [PlutusDebug] -> ScriptResult
Fails :: [PlutusDebug] -> NonEmpty ScriptFailure -> ScriptResult
scriptPass :: PlutusDebug -> ScriptResult
scriptFail :: ScriptFailure -> ScriptResult
data PlutusDebug
PlutusDebugV1 :: CostModel -> ExUnits -> ShortByteString -> [Data] -> ProtVer -> PlutusDebug
PlutusDebugV2 :: CostModel -> ExUnits -> ShortByteString -> [Data] -> ProtVer -> PlutusDebug
data PlutusError
PlutusErrorV1 :: EvaluationError -> PlutusError
PlutusErrorV2 :: EvaluationError -> PlutusError
data PlutusDebugInfo
DebugSuccess :: ExBudget -> PlutusDebugInfo
DebugCannotDecode :: String -> PlutusDebugInfo
DebugInfo :: [Text] -> PlutusError -> PlutusDebug -> PlutusDebugInfo
DebugBadHex :: String -> PlutusDebugInfo
debugPlutus :: String -> PlutusDebugInfo

-- | Run a Plutus Script, given the script and the bounds on resources it
--   is allocated.
runPLCScript :: forall era. Show (Script era) => Proxy era -> ProtVer -> Language -> CostModel -> ShortByteString -> ExUnits -> [Data] -> ScriptResult

-- | Explain why a script might fail. Scripts come in two flavors:
--   
--   <ol>
--   <li>with 3 data arguments [data,redeemer,context]</li>
--   <li>with 2 data arguments [redeemer,context].</li>
--   </ol>
--   
--   It pays to decode the context data into a real context because that
--   provides way more information. But there is no guarantee the context
--   data really can be decoded.
explainPlutusFailure :: forall era. Show (Script era) => Proxy era -> ProtVer -> Language -> ShortByteString -> EvaluationError -> [Data] -> CostModel -> ExUnits -> ScriptResult
validPlutusdata :: Data -> Bool

-- | Test that every Alonzo script represents a real Script. Run deepseq to
--   see that there are no infinite computations and that every Plutus
--   Script unflattens into a real PV1.Script
validScript :: ProtVer -> Script era -> Bool
transProtocolVersion :: ProtVer -> ProtocolVersion

-- | Compute the Set of Languages in an era, where Alonzo.Scripts are used
languages :: forall era. (ExtendedUTxO era, Script era ~ Script era) => Tx era -> UTxO era -> Set (ScriptHash (Crypto era)) -> Set Language
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxInfo.TxOutSource crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.TxInfo.TxOutSource crypto)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.TxInfo.TxOutSource crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxInfo.TxOutSource crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.TxInfo.TranslationError crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.TxInfo.TranslationError crypto)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.TxInfo.TranslationError crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.TxInfo.TranslationError crypto)
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.TxInfo.VersionedTxInfo
instance GHC.Show.Show Cardano.Ledger.Alonzo.TxInfo.VersionedTxInfo
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.TxInfo.PlutusDebug
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.TxInfo.PlutusDebug
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.TxInfo.PlutusDebug
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.TxInfo.ScriptFailure
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.TxInfo.ScriptFailure
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.TxInfo.ScriptFailure
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.TxInfo.ScriptResult
instance GHC.Show.Show Cardano.Ledger.Alonzo.TxInfo.PlutusError
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.TxInfo.ScriptResult
instance GHC.Base.Semigroup Cardano.Ledger.Alonzo.TxInfo.ScriptResult
instance GHC.Base.Monoid Cardano.Ledger.Alonzo.TxInfo.ScriptResult
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.TxInfo.PlutusDebug
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.TxInfo.PlutusDebug
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.TxInfo.TranslationError crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.TxInfo.TranslationError crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.TxInfo.TxOutSource crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.TxInfo.TxOutSource crypto)

module Cardano.Ledger.Alonzo.Rules.Bbody

-- | The uninhabited type that marks the STS Alonzo Era instance.
data AlonzoBBODY era
data AlonzoBbodyPredFail era
ShelleyInAlonzoPredFail :: BbodyPredicateFailure era -> AlonzoBbodyPredFail era
TooManyExUnits :: !ExUnits -> !ExUnits -> AlonzoBbodyPredFail era
newtype AlonzoBbodyEvent era
ShelleyInAlonzoEvent :: BbodyEvent era -> AlonzoBbodyEvent era
bbodyTransition :: forall (someBBODY :: Type -> Type) era. (STS (someBBODY era), Signal (someBBODY era) ~ Block (BHeaderView (Crypto era)) era, PredicateFailure (someBBODY era) ~ AlonzoBbodyPredFail era, BaseM (someBBODY era) ~ ShelleyBase, State (someBBODY era) ~ BbodyState era, Environment (someBBODY era) ~ BbodyEnv era, Embed (EraRule "LEDGERS" era) (someBBODY era), Environment (EraRule "LEDGERS" era) ~ LedgersEnv era, State (EraRule "LEDGERS" era) ~ LedgerState era, Signal (EraRule "LEDGERS" era) ~ Seq (Tx era), HasField "_d" (PParams era) UnitInterval, HasField "_maxBlockExUnits" (PParams era) ExUnits, Era era, TxSeq era ~ TxSeq era, Tx era ~ ValidatedTx era, Witnesses era ~ TxWitness era) => TransitionRule (someBBODY era)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Rules.Bbody.AlonzoBbodyPredFail era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGERS" era))) => GHC.Show.Show (Cardano.Ledger.Alonzo.Rules.Bbody.AlonzoBbodyPredFail era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGERS" era))) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.Rules.Bbody.AlonzoBbodyPredFail era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGERS" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Rules.Bbody.AlonzoBbodyPredFail era)
instance (Cardano.Ledger.Keys.DSignable (Cardano.Ledger.Era.Crypto era) (Cardano.Ledger.Keys.Hash (Cardano.Ledger.Era.Crypto era) Cardano.Ledger.Hashes.EraIndependentTxBody), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "LEDGERS" era) (Cardano.Ledger.Alonzo.Rules.Bbody.AlonzoBBODY era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "LEDGERS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ledgers.LedgersEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "LEDGERS" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.LedgerState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "LEDGERS" era) GHC.Types.~ Data.Sequence.Internal.Seq (Cardano.Ledger.Alonzo.Tx.ValidatedTx era), Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, GHC.Records.HasField "_d" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.UnitInterval, GHC.Records.HasField "_maxBlockExUnits" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Alonzo.Scripts.ExUnits, Cardano.Ledger.Era.TxSeq era GHC.Types.~ Cardano.Ledger.Alonzo.TxSeq.TxSeq era, Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, Cardano.Ledger.Core.Witnesses era GHC.Types.~ Cardano.Ledger.Alonzo.TxWitness.TxWitness era, Cardano.Ledger.Era.SupportsSegWit era) => Control.State.Transition.Extended.STS (Cardano.Ledger.Alonzo.Rules.Bbody.AlonzoBBODY era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.BaseM ledgers GHC.Types.~ Cardano.Ledger.BaseTypes.ShelleyBase, ledgers GHC.Types.~ Cardano.Ledger.Core.EraRule "LEDGERS" era, Control.State.Transition.Extended.STS ledgers, Cardano.Ledger.Keys.DSignable (Cardano.Ledger.Era.Crypto era) (Cardano.Ledger.Keys.Hash (Cardano.Ledger.Era.Crypto era) Cardano.Ledger.Hashes.EraIndependentTxBody), Cardano.Ledger.Era.Era era) => Control.State.Transition.Extended.Embed ledgers (Cardano.Ledger.Alonzo.Rules.Bbody.AlonzoBBODY era)
instance (Data.Typeable.Internal.Typeable era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rules.Bbody.BbodyPredicateFailure era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Rules.Bbody.AlonzoBbodyPredFail era)
instance (Data.Typeable.Internal.Typeable era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rules.Bbody.BbodyPredicateFailure era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.Rules.Bbody.AlonzoBbodyPredFail era)

module Cardano.Ledger.Alonzo.PlutusScriptApi

-- | Only the Spending ScriptPurpose contains TxIn
getSpendingTxIn :: ScriptPurpose crypto -> Maybe (TxIn crypto)

-- | Get the Data associated with a ScriptPurpose. Only the Spending
--   ScriptPurpose contains Data. The null list is returned for the other
--   kinds.
getDatumAlonzo :: forall era tx. (HasField "datahash" (TxOut era) (StrictMaybe (DataHash (Crypto era))), HasField "wits" tx (TxWitness era)) => tx -> UTxO era -> ScriptPurpose (Crypto era) -> Maybe (Data era)

-- | evaluate a list of scripts, All scripts in the list must be True.
--   There are two kinds of scripts, evaluate each kind using the
--   appropriate mechanism.
evalScripts :: forall era tx. (Era era, Show (Script era), HasField "body" tx (TxBody era), HasField "wits" tx (TxWitness era), HasField "vldt" (TxBody era) ValidityInterval) => ProtVer -> tx -> [(ShortByteString, Language, [Data era], ExUnits, CostModel)] -> ScriptResult
scriptsNeeded :: forall era tx. (Era era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "body" tx (TxBody era)) => UTxO era -> tx -> [(ScriptPurpose (Crypto era), ScriptHash (Crypto era))]

-- | Uses of inputs in txscripts and neededScripts There are currently
--   3 sets of inputs (spending, collateral, reference). A particular
--   TxInput can appear in more than one of the sets. Even in all three at
--   the same, but that may not be a really useful case. Inputs are where
--   you find scripts with the <a>Spending</a> purpose.
--   
--   1) Collateral inputs are only spent if phase two fails. Their
--   corresponding TxOut can only have Key (not Script) Pay credentials, so
--   neededScripts does not look there. 2) Reference inputs are not spent
--   in the current Tx, unless that same input also appears in one of the
--   other sets. If that is not the case, their credentials are never
--   needed, so anyone can access the inline datums and scripts in their
--   corresponding TxOut, without needing any authorizing credentials. So
--   neededScripts does not look there. 3) Spending inputs are always
--   spent. So their Pay credentials are always needed.
--   
--   Collect information (purpose and ScriptHash) about all the Credentials
--   that refer to scripts that will be needed to run in a TxBody in the
--   Utxow rule. Note there may be credentials that cannot be run, so are
--   not collected. In Babbage, reference inputs, fit that description.
--   Purposes include 1) Spending (payment script credentials, but NOT
--   staking scripts) in the Addr of a TxOut, pointed to by some input that
--   needs authorization. Be sure (getField @"inputs" txb) gets all such
--   inputs. In some Eras there may be multiple sets of inputs, which ones
--   should be included? Currently that is only the spending inputs.
--   Because collateral inputs can only have key-locked credentials, and
--   reference inputs are never authorized. That might not always be the
--   case. 2) Rewarding (Withdrawals), 3) Minting (minted field), and 4)
--   Certifying (Delegating) scripts.
--   
--   <a>scriptsNeeded</a> is an aggregation of the needed Credentials
--   referring to Scripts used in Utxow rule. The flip side of
--   <a>scriptsNeeded</a> (which collects script hashes) is
--   <a>txscripts</a> which finds the actual scripts. We maintain an
--   invariant that every script credential refers to some actual script.
--   This is tested in the test function <tt>validateMissingScripts</tt> in
--   the Utxow rule.
scriptsNeededFromBody :: forall era. (Era era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era)))) => UTxO era -> TxBody era -> [(ScriptPurpose (Crypto era), ScriptHash (Crypto era))]
language :: Script era -> Maybe Language

-- | When collecting inputs for twophase scripts, 3 things can go wrong.
data CollectError crypto
NoRedeemer :: !ScriptPurpose crypto -> CollectError crypto
NoWitness :: !ScriptHash crypto -> CollectError crypto
NoCostModel :: !Language -> CollectError crypto
BadTranslation :: !TranslationError crypto -> CollectError crypto

-- | Collect the inputs for twophase scripts. If any script can't find ist
--   data return a list of CollectError, if all goes well return a list of
--   quadruples with the inputs. Previous PredicateFailure tests should
--   ensure we find Data for every script, BUT the consequences of not
--   finding Data means scripts can get dropped, so things might validate
--   that shouldn't. So we double check that every Script has its Data, and
--   if that is not the case, a PredicateFailure is raised in the Utxos
--   rule.
collectTwoPhaseScriptInputs :: forall era. (Era era, ExtendedUTxO era, Script era ~ Script era, HasField "_costmdls" (PParams era) CostModels, HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wits" (Tx era) (TxWitness era)) => EpochInfo (Either Text) -> SystemStart -> PParams era -> Tx era -> UTxO era -> Either [CollectError (Crypto era)] [(ShortByteString, Language, [Data era], ExUnits, CostModel)]
knownToNotBe1Phase :: Map (ScriptHash (Crypto era)) (Script era) -> (ScriptPurpose (Crypto era), ScriptHash (Crypto era)) -> Maybe (ScriptPurpose (Crypto era), Language, ShortByteString)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.PlutusScriptApi.CollectError crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.PlutusScriptApi.CollectError crypto)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.PlutusScriptApi.CollectError crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.PlutusScriptApi.CollectError crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.PlutusScriptApi.CollectError crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.PlutusScriptApi.CollectError crypto)

module Cardano.Ledger.Alonzo.Tools

-- | Evaluate the execution budgets needed for all the redeemers in a given
--   transaction. If a redeemer is invalid, a failure is returned instead.
--   
--   The execution budgets in the supplied transaction are completely
--   ignored. The results of <a>evaluateTransactionExecutionUnits</a> are
--   intended to replace them.
evaluateTransactionExecutionUnits :: forall era. (Era era, ExtendedUTxO era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "txdats" (Witnesses era) (TxDats era), HasField "txrdmrs" (Witnesses era) (Redeemers era), HasField "_maxTxExUnits" (PParams era) ExUnits, HasField "_protocolVersion" (PParams era) ProtVer, Script era ~ Script era) => PParams era -> Tx era -> UTxO era -> EpochInfo (Either Text) -> SystemStart -> Array Language CostModel -> Either (TranslationError (Crypto era)) (RedeemerReport (Crypto era))

-- | Evaluate the execution budgets needed for all the redeemers in a given
--   transaction. If a redeemer is invalid, a failure is returned instead.
--   
--   The execution budgets in the supplied transaction are completely
--   ignored. The results of
--   <a>evaluateTransactionExecutionUnitsWithLogs</a> are intended to
--   replace them.
evaluateTransactionExecutionUnitsWithLogs :: forall era. (Era era, ExtendedUTxO era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "txdats" (Witnesses era) (TxDats era), HasField "txrdmrs" (Witnesses era) (Redeemers era), HasField "_maxTxExUnits" (PParams era) ExUnits, HasField "_protocolVersion" (PParams era) ProtVer, Script era ~ Script era) => PParams era -> Tx era -> UTxO era -> EpochInfo (Either Text) -> SystemStart -> Array Language CostModel -> Either (TranslationError (Crypto era)) (RedeemerReportWithLogs (Crypto era))

-- | Script failures that can be returned by
--   <a>evaluateTransactionExecutionUnits</a>.
data TransactionScriptFailure c

-- | A redeemer was supplied that does not point to a valid plutus
--   evaluation site in the given transaction.
RedeemerNotNeeded :: !RdmrPtr -> !ScriptHash c -> TransactionScriptFailure c

-- | A redeemer was supplied which points to a script hash which we cannot
--   connect to a Plutus script.
RedeemerPointsToUnknownScriptHash :: !RdmrPtr -> TransactionScriptFailure c

-- | Missing redeemer. The first parameter is the redeemer pointer which
--   cannot be resolved, and the second parameter is the map of pointers
--   which can be resolved.
MissingScript :: !RdmrPtr -> !Map RdmrPtr (ScriptPurpose c, Maybe (ShortByteString, Language), ScriptHash c) -> TransactionScriptFailure c

-- | Missing datum.
MissingDatum :: !DataHash c -> TransactionScriptFailure c

-- | Plutus V1 evaluation error.
ValidationFailedV1 :: !EvaluationError -> ![Text] -> TransactionScriptFailure c

-- | Plutus V2 evaluation error.
ValidationFailedV2 :: !EvaluationError -> ![Text] -> TransactionScriptFailure c

-- | A redeemer points to a transaction input which is not present in the
--   current UTxO.
UnknownTxIn :: !TxIn c -> TransactionScriptFailure c

-- | A redeemer points to a transaction input which is not plutus locked.
InvalidTxIn :: !TxIn c -> TransactionScriptFailure c

-- | The execution budget that was calculated by the Plutus evaluator is
--   out of bounds.
IncompatibleBudget :: !ExBudget -> TransactionScriptFailure c

-- | There was no cost model for a given version of Plutus in the ledger
--   state
NoCostModelInLedgerState :: !Language -> TransactionScriptFailure c
instance GHC.Classes.Eq (Cardano.Ledger.Alonzo.Tools.TransactionScriptFailure c)
instance GHC.Show.Show (Cardano.Ledger.Alonzo.Tools.TransactionScriptFailure c)

module Cardano.Ledger.Alonzo.Rules.Utxos
data UTXOS era
data UtxosPredicateFailure era

-- | The <a>isValid</a> tag on the transaction is incorrect. The tag given
--   here is that provided on the transaction (whereas evaluation of the
--   scripts gives the opposite.). The Text tries to explain why it failed.
ValidationTagMismatch :: IsValid -> TagMismatchDescription -> UtxosPredicateFailure era

-- | We could not find all the necessary inputs for a Plutus Script.
--   Previous PredicateFailure tests should make this impossible, but the
--   consequences of not detecting this means scripts get dropped, so
--   things might validate that shouldn't. So we double check in the
--   function collectTwoPhaseScriptInputs, it should find data for every
--   Script.
CollectErrors :: [CollectError (Crypto era)] -> UtxosPredicateFailure era
UpdateFailure :: PredicateFailure (EraRule "PPUP" era) -> UtxosPredicateFailure era

-- | Indicates that this check depends only upon the signal to the
--   transition, not the state or environment.
lbl2Phase :: Label
data TagMismatchDescription
PassedUnexpectedly :: TagMismatchDescription
FailedUnexpectedly :: NonEmpty FailureDescription -> TagMismatchDescription
validBegin :: String
validEnd :: String
invalidBegin :: String
invalidEnd :: String
data UtxosEvent era
AlonzoPpupToUtxosEvent :: Event (EraRule "PPUP" era) -> UtxosEvent era
SuccessfulPlutusScriptsEvent :: NonEmpty PlutusDebug -> UtxosEvent era
FailedPlutusScriptsEvent :: NonEmpty PlutusDebug -> UtxosEvent era

-- | Construct a 2-phase predicate check.
--   
--   Note that 2-phase predicate checks are by definition static.
when2Phase :: Rule sts ctx () -> Rule sts ctx ()
type ConcreteAlonzo era = (Script era ~ Script era, Value era ~ Value (Crypto era), TxBody era ~ TxBody era, PParams era ~ PParams era, PParamsDelta era ~ PParamsUpdate era, TxOut era ~ TxOut era, Witnesses era ~ TxWitness era, Tx era ~ ValidatedTx era)
data FailureDescription
PlutusFailure :: Text -> ByteString -> FailureDescription
scriptFailuresToPredicateFailure :: NonEmpty ScriptFailure -> NonEmpty FailureDescription
scriptFailuresToPlutusDebug :: NonEmpty ScriptFailure -> NonEmpty PlutusDebug
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.Rules.Utxos.FailureDescription
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.Rules.Utxos.FailureDescription
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.Rules.Utxos.FailureDescription
instance GHC.Show.Show Cardano.Ledger.Alonzo.Rules.Utxos.FailureDescription
instance NoThunks.Class.NoThunks Cardano.Ledger.Alonzo.Rules.Utxos.TagMismatchDescription
instance GHC.Generics.Generic Cardano.Ledger.Alonzo.Rules.Utxos.TagMismatchDescription
instance GHC.Classes.Eq Cardano.Ledger.Alonzo.Rules.Utxos.TagMismatchDescription
instance GHC.Show.Show Cardano.Ledger.Alonzo.Rules.Utxos.TagMismatchDescription
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era)
instance (GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.UTxOState era), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Show.Show (Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Alonzo.Rules.Utxos.ConcreteAlonzo era, Cardano.Ledger.Alonzo.TxInfo.ExtendedUTxO era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "PPUP" era) (Cardano.Ledger.Alonzo.Rules.Utxos.UTXOS era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PPUPEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.PPUPState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ GHC.Maybe.Maybe (Cardano.Ledger.Shelley.PParams.Update era), Cardano.Ledger.Era.ValidateScript era, Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => Control.State.Transition.Extended.STS (Cardano.Ledger.Alonzo.Rules.Utxos.UTXOS era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Control.State.Transition.Extended.Event (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era) (Cardano.Ledger.Alonzo.Rules.Utxos.UTXOS era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era)), GHC.Show.Show (Cardano.Ledger.Core.TxOut era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era)
instance (GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.UTxOState era), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era)
instance (NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.UTxOState era), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era)
instance (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era) => Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era) (Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era) (Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era)
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.Rules.Utxos.TagMismatchDescription
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.Rules.Utxos.TagMismatchDescription
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Alonzo.Rules.Utxos.FailureDescription
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Alonzo.Rules.Utxos.FailureDescription

module Cardano.Ledger.Alonzo.Rules.Utxo

-- | Compute an estimate of the size of storing one UTxO entry. This
--   function implements the UTxO entry size estimate done by
--   scaledMinDeposit in the ShelleyMA era
utxoEntrySize :: (Era era, HasField "datahash" (TxOut era) (StrictMaybe (DataHash c))) => TxOut era -> Integer

-- | The uninhabited type that marks the Alonzo UTxO rule
data AlonzoUTXO era
data UtxoPredicateFailure era

-- | The bad transaction inputs
BadInputsUTxO :: !Set (TxIn (Crypto era)) -> UtxoPredicateFailure era
OutsideValidityIntervalUTxO :: !ValidityInterval -> !SlotNo -> UtxoPredicateFailure era
MaxTxSizeUTxO :: !Integer -> !Integer -> UtxoPredicateFailure era
InputSetEmptyUTxO :: UtxoPredicateFailure era
FeeTooSmallUTxO :: !Coin -> !Coin -> UtxoPredicateFailure era
ValueNotConservedUTxO :: !Value era -> !Value era -> UtxoPredicateFailure era

-- | the set of addresses with incorrect network IDs
WrongNetwork :: !Network -> !Set (Addr (Crypto era)) -> UtxoPredicateFailure era
WrongNetworkWithdrawal :: !Network -> !Set (RewardAcnt (Crypto era)) -> UtxoPredicateFailure era

-- | list of supplied transaction outputs that are too small
OutputTooSmallUTxO :: ![TxOut era] -> UtxoPredicateFailure era

-- | Subtransition Failures
UtxosFailure :: PredicateFailure (EraRule "UTXOS" era) -> UtxoPredicateFailure era

-- | list of supplied bad transaction outputs
OutputBootAddrAttrsTooBig :: ![TxOut era] -> UtxoPredicateFailure era
TriesToForgeADA :: UtxoPredicateFailure era

-- | list of supplied bad transaction output triples
--   (actualSize,PParameterMaxValue,TxOut)
OutputTooBigUTxO :: ![(Integer, Integer, TxOut era)] -> UtxoPredicateFailure era
InsufficientCollateral :: !Coin -> !Coin -> UtxoPredicateFailure era

-- | The UTxO entries which have the wrong kind of script
ScriptsNotPaidUTxO :: !UTxO era -> UtxoPredicateFailure era
ExUnitsTooBigUTxO :: !ExUnits -> !ExUnits -> UtxoPredicateFailure era

-- | The inputs marked for use as fees contain non-ADA tokens
CollateralContainsNonADA :: !Value era -> UtxoPredicateFailure era

-- | Wrong Network ID in body
WrongNetworkInTxBody :: !Network -> !Network -> UtxoPredicateFailure era

-- | slot number outside consensus forecast range
OutsideForecast :: !SlotNo -> UtxoPredicateFailure era

-- | There are too many collateral inputs
TooManyCollateralInputs :: !Natural -> !Natural -> UtxoPredicateFailure era
NoCollateralInputs :: UtxoPredicateFailure era
newtype UtxoEvent era
UtxosEvent :: Event (EraRule "UTXOS" era) -> UtxoEvent era

-- | Returns true for VKey locked addresses, and false for any kind of
--   script-locked address.
isKeyHashAddr :: Addr crypto -> Bool

-- | This is equivalent to <a>isKeyHashAddr</a>, but for compacted version
--   of an address.
isKeyHashCompactAddr :: CompactAddr crypto -> Bool
vKeyLocked :: Era era => TxOut era -> Bool

-- | feesOK is a predicate with several parts. Some parts only apply in
--   special circumstances. 1) The fee paid is &gt;= the minimum fee 2) If
--   the total ExUnits are 0 in both Memory and Steps, no further part
--   needs to be checked. 3) The collateral consists only of VKey addresses
--   4) The collateral is sufficient to cover the appropriate percentage of
--   the fee marked in the transaction 5) The collateral inputs do not
--   contain any non-ADA part 6) There is at least one collateral input As
--   a TransitionRule it will return (), and produce a validation failure
--   (rather than return) if any of the required parts are False.
feesOK :: forall era. (Era era, Tx era ~ ValidatedTx era, HasField "collateral" (TxBody era) (Set (TxIn (Crypto era))), HasField "txrdmrs" (Witnesses era) (Redeemers era), HasField "_minfeeA" (PParams era) Natural, HasField "_minfeeB" (PParams era) Natural, HasField "_prices" (PParams era) Prices, HasField "_collateralPercentage" (PParams era) Natural) => PParams era -> Tx era -> UTxO era -> Test (UtxoPredicateFailure era)
validateCollateral :: (Era era, HasField "_collateralPercentage" (PParams era) Natural) => PParams era -> TxBody era -> Map (TxIn (Crypto era)) (TxOut era) -> Value era -> Test (UtxoPredicateFailure era)
validateScriptsNotPaidUTxO :: Era era => Map (TxIn (Crypto era)) (TxOut era) -> Test (UtxoPredicateFailure era)
validateInsufficientCollateral :: (HasField "_collateralPercentage" (PParams era) Natural, HasField "txfee" (TxBody era) Coin, Val (Value era)) => PParams era -> TxBody era -> Value era -> Test (UtxoPredicateFailure era)
validateCollateralContainsNonADA :: Val (Value era) => Value era -> Test (UtxoPredicateFailure era)

-- | If tx has non-native scripts, end of validity interval must translate
--   to time
--   
--   <pre>
--   (_,i_f) := txvldt tx
--     { txrdmrs tx, i_f }  epochInfoSlotToUTCTime epochInfo systemTime i_f  
--   </pre>
validateOutsideForecast :: (HasField "vldt" (TxBody era) ValidityInterval, HasField "_protocolVersion" (PParams era) ProtVer) => PParams era -> EpochInfo (Either a) -> SlotNo -> SystemStart -> ValidatedTx era -> Test (UtxoPredicateFailure era)

-- | Ensure that there are no <a>TxOut</a>s that have value less than the
--   sized <tt>coinsPerUTxOWord</tt>
--   
--   <pre>
--    txout  txouts txb, getValue txout  inject (utxoEntrySize txout  coinsPerUTxOWord pp)
--   </pre>
validateOutputTooSmallUTxO :: (HasField "_coinsPerUTxOWord" (PParams era) Coin, HasField "datahash" (TxOut era) (StrictMaybe (DataHash c)), Era era) => PParams era -> UTxO era -> Test (UtxoPredicateFailure era)

-- | Ensure that there are no <a>TxOut</a>s that have <tt>Value</tt> of
--   size larger than <tt>MaxValSize</tt>. We use serialized length of
--   <a>Value</a> because this Value size is being limited inside a
--   serialized <a>Tx</a>.
--   
--   <pre>
--    txout  txouts txb, serSize (getValue txout)  maxValSize pp
--   </pre>
validateOutputTooBigUTxO :: (HasField "_maxValSize" (PParams era) Natural, HasField "value" (TxOut era) (Value era), ToCBOR (Value era)) => PParams era -> UTxO era -> Test (UtxoPredicateFailure era)

-- | Ensure if NetworkId is present in the txbody it matches the global
--   NetworkId
--   
--   <pre>
--   (txnetworkid txb = NetworkId)  (txnetworkid txb = )
--   </pre>
validateWrongNetworkInTxBody :: HasField "txnetworkid" (TxBody era) (StrictMaybe Network) => Network -> TxBody era -> Test (UtxoPredicateFailure era)

-- | Ensure that execution units to not exceed the maximum allowed
--   <tt>maxTxExUnits</tt> parameter.
--   
--   <pre>
--   totExunits tx  maxTxExUnits pp
--   </pre>
validateExUnitsTooBigUTxO :: (HasField "_maxTxExUnits" (PParams era) ExUnits, HasField "txrdmrs" (Witnesses era) (Redeemers era), HasField "wits" (Tx era) (Witnesses era)) => PParams era -> Tx era -> Test (UtxoPredicateFailure era)

-- | Ensure that number of collaterals does not exceed the allowed
--   <tt>maxCollInputs</tt> parameter.
--   
--   <pre>
--   collateral tx    maxCollInputs pp
--   </pre>
validateTooManyCollateralInputs :: (HasField "_maxCollateralInputs" (PParams era) Natural, HasField "collateral" (TxBody era) (Set a)) => PParams era -> TxBody era -> Test (UtxoPredicateFailure era)

-- | The UTxO transition rule for the Alonzo eras.
utxoTransition :: forall era. (Era era, ValidateScript era, ConcreteAlonzo era, Tx era ~ ValidatedTx era, Witnesses era ~ TxWitness era, STS (AlonzoUTXO era), Embed (EraRule "UTXOS" era) (AlonzoUTXO era), Environment (EraRule "UTXOS" era) ~ UtxoEnv era, State (EraRule "UTXOS" era) ~ UTxOState era, Signal (EraRule "UTXOS" era) ~ Tx era, Inject (PredicateFailure (EraRule "PPUP" era)) (PredicateFailure (EraRule "UTXOS" era))) => TransitionRule (AlonzoUTXO era)
encFail :: forall era. (Era era, ToCBOR (TxOut era), ToCBOR (Value era), ToCBOR (PredicateFailure (EraRule "UTXOS" era))) => UtxoPredicateFailure era -> Encode 'Open (UtxoPredicateFailure era)
decFail :: (Era era, FromCBOR (TxOut era), FromCBOR (Value era), FromCBOR (PredicateFailure (EraRule "UTXOS" era))) => Word -> Decode 'Open (UtxoPredicateFailure era)
fromShelleyFailure :: UtxoPredicateFailure era -> Maybe (UtxoPredicateFailure era)
fromShelleyMAFailure :: UtxoPredicateFailure era -> Maybe (UtxoPredicateFailure era)
utxoPredFailMaToAlonzo :: Inject (PredicateFailure (EraRule "PPUP" era)) (PredicateFailure (EraRule "UTXOS" era)) => UtxoPredicateFailure era -> UtxoPredicateFailure era
utxoPredFailShelleyToAlonzo :: Inject (PredicateFailure (EraRule "PPUP" era)) (PredicateFailure (EraRule "UTXOS" era)) => UtxoPredicateFailure era -> UtxoPredicateFailure era
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Cardano.Ledger.Core.TxBody era), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era))) => GHC.Show.Show (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), GHC.Classes.Eq (Cardano.Ledger.Core.Value era), GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era))) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance (Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Alonzo.Rules.Utxos.ConcreteAlonzo era, Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, Cardano.Ledger.Core.Witnesses era GHC.Types.~ Cardano.Ledger.Alonzo.TxWitness.TxWitness era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UTXOS" era) (Cardano.Ledger.Alonzo.Rules.Utxo.AlonzoUTXO era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UTxOState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, Cardano.Ledger.Rules.ValidationMode.Inject (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era)) (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)), Cardano.Ledger.Era.TxSeq era GHC.Types.~ Cardano.Ledger.Alonzo.TxSeq.TxSeq era) => Control.State.Transition.Extended.STS (Cardano.Ledger.Alonzo.Rules.Utxo.AlonzoUTXO era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Alonzo.Rules.Utxos.UTXOS era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Control.State.Transition.Extended.Event (Cardano.Ledger.Alonzo.Rules.Utxos.UTXOS era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Alonzo.Rules.Utxos.UTXOS era) (Cardano.Ledger.Alonzo.Rules.Utxo.AlonzoUTXO era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxBody era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxOut era), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance (Data.Typeable.Internal.Typeable era, Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era))) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era) => Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Alonzo.Rules.Utxos.UtxosPredicateFailure era) (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era)) (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)) => Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era)) (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOS" era)) => Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.InjectMaybe (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.InjectMaybe (Cardano.Ledger.ShelleyMA.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era)

module Cardano.Ledger.Alonzo.Rules.Utxow

-- | The Predicate failure type in the Alonzo Era. It embeds the Predicate
--   failure type of the Shelley Era, as they share some failure modes.
data UtxowPredicateFail era
WrappedShelleyEraFailure :: !UtxowPredicateFailure era -> UtxowPredicateFail era

-- | List of scripts for which no redeemers were supplied
MissingRedeemers :: ![(ScriptPurpose (Crypto era), ScriptHash (Crypto era))] -> UtxowPredicateFail era
MissingRequiredDatums :: !Set (DataHash (Crypto era)) -> !Set (DataHash (Crypto era)) -> UtxowPredicateFail era
NonOutputSupplimentaryDatums :: !Set (DataHash (Crypto era)) -> !Set (DataHash (Crypto era)) -> UtxowPredicateFail era
PPViewHashesDontMatch :: !StrictMaybe (ScriptIntegrityHash (Crypto era)) -> !StrictMaybe (ScriptIntegrityHash (Crypto era)) -> UtxowPredicateFail era

-- | Set of witnesses which were needed and not supplied
MissingRequiredSigners :: Set (KeyHash 'Witness (Crypto era)) -> UtxowPredicateFail era

-- | Set of transaction inputs that are TwoPhase scripts, and should have a
--   DataHash but don't
UnspendableUTxONoDatumHash :: Set (TxIn (Crypto era)) -> UtxowPredicateFail era

-- | List of redeemers not needed
ExtraRedeemers :: ![RdmrPtr] -> UtxowPredicateFail era
newtype AlonzoEvent era
WrappedShelleyEraEvent :: UtxowEvent era -> AlonzoEvent era
encodePredFail :: (Era era, ToCBOR (PredicateFailure (EraRule "UTXO" era)), Typeable (Script era), Typeable (AuxiliaryData era)) => UtxowPredicateFail era -> Encode 'Open (UtxowPredicateFail era)
decodePredFail :: (Era era, FromCBOR (PredicateFailure (EraRule "UTXO" era)), Typeable (Script era), Typeable (AuxiliaryData era)) => Word -> Decode 'Open (UtxowPredicateFail era)

-- | given the "txscripts" field of the Witnesses, compute the set of
--   languages used in a transaction
langsUsed :: forall era. (Script era ~ Script era, ValidateScript era) => Map (ScriptHash (Crypto era)) (Script era) -> Set Language
missingRequiredDatums :: forall era. (ValidateScript era, Script era ~ Script era, ExtendedUTxO era) => Map (ScriptHash (Crypto era)) (Script era) -> UTxO era -> ValidatedTx era -> TxBody era -> Test (UtxowPredicateFail era)
hasExactSetOfRedeemers :: forall era. (Era era, ValidateScript era, ExtendedUTxO era, Script era ~ Script era, Tx era ~ ValidatedTx era, HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era))) => UTxO era -> Tx era -> TxBody era -> Test (UtxowPredicateFail era)
requiredSignersAreWitnessed :: forall era. HasField "reqSignerHashes" (TxBody era) (Set (KeyHash 'Witness (Crypto era))) => TxBody era -> WitHashes (Crypto era) -> Test (UtxowPredicateFail era)
ppViewHashesMatch :: forall era. (ValidateScript era, ExtendedUTxO era, Script era ~ Script era, Tx era ~ ValidatedTx era, HasField "scriptIntegrityHash" (TxBody era) (StrictMaybe (ScriptIntegrityHash (Crypto era))), HasField "_costmdls" (PParams era) CostModels) => Tx era -> TxBody era -> PParams era -> UTxO era -> Set (ScriptHash (Crypto era)) -> Test (UtxowPredicateFail era)

-- | A very specialized transitionRule function for the Alonzo Era.
alonzoStyleWitness :: forall era. (ValidateScript era, ValidateAuxiliaryData era (Crypto era), ExtendedUTxO era, ConcreteAlonzo era, Tx era ~ ValidatedTx era, Witnesses era ~ TxWitness era, Signable (DSIGN (Crypto era)) (Hash (HASH (Crypto era)) EraIndependentTxBody), Embed (EraRule "UTXO" era) (AlonzoUTXOW era), Environment (EraRule "UTXO" era) ~ UtxoEnv era, State (EraRule "UTXO" era) ~ UTxOState era, Signal (EraRule "UTXO" era) ~ ValidatedTx era) => TransitionRule (AlonzoUTXOW era)

-- | Collect the set of hashes of keys that needs to sign a given
--   transaction. This set consists of the txin owners, certificate
--   authors, and withdrawal reward accounts.
--   
--   Compared to pre-Alonzo eras, we additionally gather the certificates
--   required to authenticate collateral witnesses.
witsVKeyNeeded :: forall era tx. (Era era, HasField "body" tx (TxBody era), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "collateral" (TxBody era) (Set (TxIn (Crypto era))), HasField "update" (TxBody era) (StrictMaybe (Update era))) => UTxO era -> tx -> GenDelegs (Crypto era) -> WitHashes (Crypto era)
extSymmetricDifference :: Ord k => [a] -> (a -> k) -> [b] -> (b -> k) -> ([a], [b])
data AlonzoUTXOW era
instance GHC.Generics.Generic (Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), GHC.Show.Show (Cardano.Ledger.Core.Script era)) => GHC.Show.Show (Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), GHC.Classes.Eq (Cardano.Ledger.Core.Script era)) => GHC.Classes.Eq (Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era)
instance (Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.AuxiliaryData.ValidateAuxiliaryData era (Cardano.Ledger.Era.Crypto era), Cardano.Ledger.Alonzo.TxInfo.ExtendedUTxO era, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN (Cardano.Ledger.Era.Crypto era)) (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH (Cardano.Ledger.Era.Crypto era)) Cardano.Ledger.Hashes.EraIndependentTxBody), Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, Cardano.Ledger.Core.Witnesses era GHC.Types.~ Cardano.Ledger.Alonzo.TxWitness.TxWitness era, Cardano.Ledger.Alonzo.Rules.Utxos.ConcreteAlonzo era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UTXO" era) (Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoUTXOW era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UTxOState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era) => Control.State.Transition.Extended.STS (Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoUTXOW era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Alonzo.Rules.Utxo.AlonzoUTXO era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxo.UtxoPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxo.UtxoEvent era, Control.State.Transition.Extended.BaseM (Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoUTXOW era) GHC.Types.~ Cardano.Ledger.BaseTypes.ShelleyBase, Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoUTXOW era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era, Control.State.Transition.Extended.Event (Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoUTXOW era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Alonzo.Rules.Utxo.AlonzoUTXO era) (Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoUTXOW era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.Script era), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Script era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era) (Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era) (Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era)

module Cardano.Ledger.Alonzo.Rules.Ledger

-- | The uninhabited type that marks the (STS Ledger) instance in the
--   Alonzo Era.
data AlonzoLEDGER era

-- | An abstract Alonzo Era, Ledger transition. Fix <tt>someLedger</tt> at
--   a concrete type to make it concrete. Depends only on the "certs" and
--   "isValid" HasField instances.
ledgerTransition :: forall (someLEDGER :: Type -> Type) era. (Signal (someLEDGER era) ~ Tx era, State (someLEDGER era) ~ LedgerState era, Environment (someLEDGER era) ~ LedgerEnv era, Embed (EraRule "UTXOW" era) (someLEDGER era), Embed (EraRule "DELEGS" era) (someLEDGER era), Environment (EraRule "DELEGS" era) ~ DelegsEnv era, State (EraRule "DELEGS" era) ~ DPState (Crypto era), Signal (EraRule "DELEGS" era) ~ Seq (DCert (Crypto era)), Environment (EraRule "UTXOW" era) ~ UtxoEnv era, State (EraRule "UTXOW" era) ~ UTxOState era, Signal (EraRule "UTXOW" era) ~ Tx era, HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "isValid" (Tx era) IsValid, Era era) => TransitionRule (someLEDGER era)
instance (GHC.Show.Show (Cardano.Ledger.Core.Script era), GHC.Show.Show (Cardano.Ledger.Core.TxBody era), GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), GHC.Show.Show (Cardano.Ledger.Core.AuxiliaryData era), GHC.Show.Show (Cardano.Ledger.Core.PParams era), GHC.Show.Show (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era), Cardano.Ledger.Keys.DSignable (Cardano.Ledger.Era.Crypto era) (Cardano.Ledger.Keys.Hash (Cardano.Ledger.Era.Crypto era) Cardano.Ledger.Hashes.EraIndependentTxBody), Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELEGS" era) (Cardano.Ledger.Alonzo.Rules.Ledger.AlonzoLEDGER era), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UTXOW" era) (Cardano.Ledger.Alonzo.Rules.Ledger.AlonzoLEDGER era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UTxOState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx era, Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delegs.DelegsEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.DPState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Data.Sequence.Internal.Seq (Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era)), GHC.Records.HasField "certs" (Cardano.Ledger.Core.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era))), GHC.Records.HasField "_keyDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin, GHC.Records.HasField "_poolDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin) => Control.State.Transition.Extended.STS (Cardano.Ledger.Alonzo.Rules.Ledger.AlonzoLEDGER era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Delegs.DELEGS era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delegs.DelegsPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delegs.DelegsEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Delegs.DELEGS era) (Cardano.Ledger.Alonzo.Rules.Ledger.AlonzoLEDGER era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoUTXOW era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxow.UtxowPredicateFail era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Alonzo.Rules.Utxow.AlonzoUTXOW era) (Cardano.Ledger.Alonzo.Rules.Ledger.AlonzoLEDGER era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Alonzo.Rules.Ledger.AlonzoLEDGER era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ledger.LedgerPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "LEDGER" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ledger.LedgerEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Alonzo.Rules.Ledger.AlonzoLEDGER era) (Cardano.Ledger.Shelley.Rules.Ledgers.LEDGERS era)

module Cardano.Ledger.Alonzo

-- | The Alonzo era
data AlonzoEra c
type Self c = AlonzoEra c
data TxOut era
type Value era = Value (Crypto era)
data TxBody era

-- | Scripts in the Alonzo Era, Either a Timelock script or a Plutus
--   script.
data Script era
data AuxiliaryData era
type PParams era = PParams' Identity era
type PParamsDelta era = PParamsUpdate era
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.Era (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.Mempool.ApplyTx (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.Validation.ApplyBlock (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.ValidateScript (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.API.Genesis.CanStartFromGenesis (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesTxOut (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.API.Wallet.CLI (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesValue (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesPParams (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.AuxiliaryData.ValidateAuxiliaryData (Cardano.Ledger.Alonzo.AlonzoEra c) c
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.SupportsSegWit (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.ShelleyBasedEra (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Alonzo.TxInfo.ExtendedUTxO (Cardano.Ledger.Alonzo.AlonzoEra c)

module Cardano.Ledger.Alonzo.Translation
newtype Tx era
Tx :: Tx era -> Tx era
[unTx] :: Tx era -> Tx era
translateTxOut :: Crypto c => TxOut (MaryEra c) -> TxOut (AlonzoEra c)
translatePParams :: AlonzoGenesis -> PParams (MaryEra c) -> PParams (AlonzoEra c)
translatePParamsUpdate :: PParamsUpdate (MaryEra c) -> PParamsUpdate (AlonzoEra c)
instance (Cardano.Ledger.Crypto.Crypto c, Cardano.Ledger.Core.Tx (Cardano.Ledger.Alonzo.AlonzoEra c) GHC.Types.~ Cardano.Ledger.Alonzo.Tx.ValidatedTx (Cardano.Ledger.Alonzo.AlonzoEra c)) => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) Cardano.Ledger.Alonzo.Translation.Tx
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) Cardano.Ledger.Shelley.LedgerState.NewEpochState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) Cardano.Ledger.Shelley.Genesis.ShelleyGenesis
instance (Cardano.Ledger.Crypto.Crypto c, GHC.Base.Functor f) => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) (Cardano.Ledger.Shelley.PParams.PParams' f)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) Cardano.Ledger.Shelley.LedgerState.EpochState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) Cardano.Ledger.Shelley.LedgerState.LedgerState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) Cardano.Ledger.Shelley.LedgerState.UTxOState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) Cardano.Ledger.Shelley.UTxO.UTxO
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) Cardano.Ledger.Shelley.LedgerState.PPUPState
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) Cardano.Ledger.Shelley.PParams.ProposedPPUpdates

module Cardano.Ledger.DescribeEras

-- | Witness of a valid (predefined) era
data Witness era
[Shelley] :: Witness (ShelleyEra StandardCrypto)
[Mary] :: Witness (MaryEra StandardCrypto)
[Allegra] :: Witness (AllegraEra StandardCrypto)
[Alonzo] :: Witness (AlonzoEra StandardCrypto)

-- | If an instance for this class compiles, then era meets whatever
--   superclass its given.
class Checks era
checks :: Checks era => Witness era -> Bool
type DescribesShelley era = (WellFormed era, Value era ~ Value era, TxBody era ~ TxBody era, TxOut era ~ TxOut era, Script era ~ Script era, AuxiliaryData era ~ AuxiliaryData era, PParams era ~ PParams era, PParamsDelta era ~ PParamsDelta era)
type DescribesAllegra era = (WellFormed era, Value era ~ Value era, TxBody era ~ TxBody era, TxOut era ~ TxOut era, Script era ~ Script era, AuxiliaryData era ~ AuxiliaryData era, PParams era ~ PParams era, PParamsDelta era ~ PParamsDelta era)
type DescribesMary era = (WellFormed era, Value era ~ Value era, TxBody era ~ TxBody era, TxOut era ~ TxOut era, Script era ~ Script era, AuxiliaryData era ~ AuxiliaryData era, PParams era ~ PParams era, PParamsDelta era ~ PParamsDelta era)
type DescribesAlonzo era = (WellFormed era, Value era ~ Value era, TxBody era ~ TxBody era, TxOut era ~ TxOut era, Script era ~ Script era, AuxiliaryData era ~ AuxiliaryData era, PParams era ~ PParams era, PParamsDelta era ~ PParamsDelta era)

-- | The same crypto used on the net
data StandardCrypto
instance Cardano.Ledger.DescribeEras.DescribesShelley (Cardano.Ledger.Shelley.Self c) => Cardano.Ledger.DescribeEras.Checks (Cardano.Ledger.Shelley.Self c)
instance Cardano.Ledger.DescribeEras.DescribesAllegra (Cardano.Ledger.Allegra.Self c) => Cardano.Ledger.DescribeEras.Checks (Cardano.Ledger.Allegra.Self c)
instance Cardano.Ledger.DescribeEras.DescribesMary (Cardano.Ledger.Mary.Self c) => Cardano.Ledger.DescribeEras.Checks (Cardano.Ledger.Mary.Self c)
instance Cardano.Ledger.DescribeEras.DescribesAlonzo (Cardano.Ledger.Alonzo.Self c) => Cardano.Ledger.DescribeEras.Checks (Cardano.Ledger.Alonzo.Self c)
instance GHC.Show.Show (Cardano.Ledger.DescribeEras.Witness e)
