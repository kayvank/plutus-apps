-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utility types and functions for testing Cardano
--   
--   Utility types and functions for testing Cardano
@package cardano-prelude-test
@version 0.1.0.1

module Test.Cardano.Prelude
runTests :: [IO Bool] -> IO ()
discoverPropArg :: TExpQ (a -> Group)
discoverRoundTrip :: TExpQ Group
discoverRoundTripArg :: TExpQ (a -> Group)
roundTripsAesonShow :: (Eq a, MonadTest m, ToJSON a, FromJSON a, Show a) => a -> m ()

-- | Round trip any <tt>a</tt> with both <a>ToJSON</a> and <a>FromJSON</a>
--   instances.
roundTripsAesonBuildable :: (Eq a, MonadTest m, ToJSON a, FromJSON a, Buildable a) => a -> m ()

-- | Pretty round trip any <tt>a</tt> with both <a>ToJSON</a> and
--   <a>FromJSON</a> canonical instances.
roundTripsCanonicalJsonPretty :: (Eq a, Show a, MonadTest m, ToJSON Identity a, FromJSON (Either SchemaError) a) => a -> m ()

-- | Round trip using given encode and decode functions for types with a
--   <a>Buildable</a> instance
trippingBuildable :: forall f a b m. (HasCallStack, Buildable (f a), Eq (f a), Show b, Applicative f, MonadTest m) => a -> (a -> b) -> (b -> f a) -> m ()
qcIsJust :: Maybe a -> Property
qcIsNothing :: Show a => Maybe a -> Property
qcIsLeft :: Show b => Either a b -> Property
qcIsRight :: Show a => Either a b -> Property
qcElem :: (Show a, Eq a, Show (t a), Foldable t) => a -> t a -> Property
qcNotElem :: (Show a, Eq a, Show (t a), Foldable t) => a -> t a -> Property

-- | A property that is always false
qcFail :: Text -> Property

-- | Call stopProperty if boolean value is false.
assertProperty :: Monad m => Bool -> Text -> PropertyM m ()

-- | Stop <a>PropertyM</a> execution with given reason. The property will
--   fail.
stopProperty :: Monad m => Text -> PropertyM m a

-- | Use <a>stopProperty</a> if the value is <a>Nothing</a> or return
--   something it the value is <a>Just</a>.
maybeStopProperty :: Monad m => Text -> Maybe a -> PropertyM m a

-- | Split given list into chunks with size up to given value. TODO:
--   consider using `sumEquals maxSize (length items)`
splitIntoChunks :: Monad m => Word -> [a] -> PropertyM m [NonEmpty a]
expectedOne :: Monad m => Text -> [a] -> PropertyM m a
expectationError :: Text -> Expectation

-- | Split given integer <tt>total</tt> into <tt>parts</tt> parts TODO:
--   improve naming!
splitWord :: Word64 -> Word64 -> Gen [Word64]

-- | Generate list of arbitrary positive integers which sum equals given
--   sum. All elements in the list will be smaller or equal then first
--   parameter
sumEquals :: Word64 -> Word64 -> Gen [Word64]

-- | Extensional equality combinator. Useful to express function properties
--   as functional equations.
(.=.) :: (Eq b, Show b) => (a -> b) -> (a -> b) -> a -> Property
infixr 5 .=.

-- | Monadic extensional equality combinator.
(>=.) :: (Show (m b), Eq (m b)) => (a -> m b) -> (a -> m b) -> a -> Property
infixr 5 >=.
shouldThrowException :: Exception e => (a -> b) -> Selector e -> a -> Expectation
formsSemigroup :: (Show m, Eq m, Semigroup m) => m -> m -> m -> Property
formsMonoid :: (Show m, Eq m, Semigroup m, Monoid m) => m -> m -> m -> Property
formsCommutativeMonoid :: (Show m, Eq m, Semigroup m, Monoid m) => m -> m -> m -> Property

-- | Type for generating list of unique (nonrepeating) elemets.
class Nonrepeating a
nonrepeating :: Nonrepeating a => Int -> Gen [a]

-- | ArbitraryUnsafe class ~~~~~~~~~~~~~~~~~~~~~~~~
--   
--   This class is the same as <a>Arbitrary</a>, except instances of this
--   class for stuff like public/secret keys, VSS shares, commitments etc.
--   are designed not to mimic real data as presisely as possible (using
--   OpenSSL random), but rather to be simple and efficient.
--   
--   This is especially useful for benchmarking.
--   
--   Note: we don't need <a>Generic</a> to derive instances of
--   <a>ArbitraryUnsafe</a>. We can either use one-line instance
--   declaration, or <tt>-XStandaloneDeriving</tt> or
--   <tt>-XDeriveAnyClass</tt> to write something like <tt>deriving
--   (Arbitrary, ArbitraryUnsafe)</tt>.
class ArbitraryUnsafe a
arbitraryUnsafe :: ArbitraryUnsafe a => Gen a
arbitraryUnsafe :: (ArbitraryUnsafe a, Arbitrary a) => Gen a
newtype SmallGenerator a
SmallGenerator :: a -> SmallGenerator a
[getSmallGenerator] :: SmallGenerator a -> a
makeSmall :: Gen a -> Gen a

-- | Choose a random (shuffled) subset of length n. Throws an error if
--   there's not enough elements.
sublistN :: Int -> [a] -> Gen [a]

-- | Make arbitrary <a>ByteString</a> of given length.
arbitrarySizedS :: Int -> Gen ByteString

-- | Make arbitrary <a>Lazy</a> of given length.
arbitrarySizedSL :: Int -> Gen ByteString

-- | Get something out of a quickcheck <a>Gen</a> without having to do IO
runGen :: Gen a -> a
assertIsLeftConstr :: (Buildable b, Data a, HasCallStack, MonadTest m) => Constr -> Either a b -> m ()
assertIsRight :: (Buildable a, HasCallStack, MonadTest m) => Either a b -> m ()
assertIsJust :: (HasCallStack, MonadTest m) => Maybe a -> m ()
assertIsNothing :: (Buildable a, HasCallStack, MonadTest m) => Maybe a -> m ()
compareValueRight :: (Buildable a, Eq b, HasCallStack, MonadTest m, Show b) => b -> Either a b -> m ()
discoverGolden :: TExpQ Group

-- | Check that <tt>eachOf</tt> <tt>testLimit</tt> generated
--   <tt>things</tt> <tt>hasProperty</tt>
eachOf :: (Show a, HasCallStack) => TestLimit -> Gen a -> (a -> PropertyT IO ()) -> Property

-- | Check that Canonical JSON decodes to the datatype
goldenTestCanonicalJSONDec :: (Eq a, FromJSON (Either SchemaError) a, HasCallStack, Show a) => a -> FilePath -> Property

-- | Only check that the datatype equals the decoding of the file
goldenTestJSONDec :: (Eq a, FromJSON a, HasCallStack, Show a) => a -> FilePath -> Property
goldenTestJSON :: (Eq a, FromJSON a, HasCallStack, Show a, ToJSON a) => a -> FilePath -> Property
goldenTestJSONPretty :: (Eq a, FromJSON a, HasCallStack, Show a, ToJSON a) => a -> FilePath -> Property
getText :: Int -> Int -> Text
genBytes :: Int -> Gen ByteString
genUTF8Byte :: Gen ByteString
gen32Bytes :: Gen ByteString
genWord32 :: Gen Word32
genWord16 :: Gen Word16
genNatural :: Gen Natural
genNominalDiffTime :: Gen NominalDiffTime

-- | Decode a given ByteString which was originally encoded using
--   <tt>encode</tt> or <a>encodeWithIndex</a>.
decodeBase16 :: ByteString -> Maybe ByteString

-- | Encodes a given ByteString to base-16 and line wraps every 16 bytes.
encodeBase16 :: ByteString -> ByteString

-- | Encodes a given ByteString to base-16 and displays it alongside its
--   byte offset (line wrapped every 16 bytes).
encodeWithIndex :: ByteString -> ByteString
