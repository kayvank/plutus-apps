-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe and lossless encoding and manipulation of money, fiat
--   currencies, crypto currencies and precious metals.
--   
--   The Haskell <tt>safe-money</tt> library offers type-safe and lossless
--   encoding and operations for monetary values in all world currencies,
--   including fiat currencies, precious metals and crypto-currencies.
--   
--   Useful instances for the many types defined by <tt>safe-money</tt> can
--   be found in these other libraries:
--   
--   <ul>
--   <li><a>safe-money-aeson</a>: <tt>FromJSON</tt> and <tt>ToJSON</tt>
--   instances (from the <a>aeson</a> library).</li>
--   <li><a>safe-money-cereal</a>: <tt>Serialize</tt> instances (from the
--   <a>cereal</a> library).</li>
--   <li><a>safe-money-serialise</a>: <tt>Serialise</tt> instances (from
--   the <a>serialise</a> library).</li>
--   <li><a>safe-money-store</a>: <tt>Store</tt> instances (from the
--   <a>store</a> library).</li>
--   <li><a>safe-money-xmlbf</a>: <tt>FromXml</tt> and <tt>ToXml</tt>
--   instances (from the <a>xmlbf</a> library).</li>
--   </ul>
@package safe-money
@version 0.9.1


-- | Import this module qualified as follows:
--   
--   <pre>
--   import qualified Money
--   </pre>
--   
--   Note: This module exports support for many well-known currencies
--   out-of-the-box, but you are not limited to the currencies mentioned
--   here. You can simply create a new <a>UnitScale</a> instance, and
--   <i>voilà</i>. If you want to add a new currency to the out-of-the-box
--   offer, please request so in
--   <a>https://github.com/k0001/safe-money/issues</a> and the authors will
--   see to it.
--   
--   This module offers plenty of documentation, but for a deep explanation
--   of how all of the pieces fit together, please read
--   <a>https://ren.zone/articles/safe-money</a>. Notice, however, that
--   this library has changed a bit since that article was written. You can
--   always see the <a>change log</a> to understand what has changed.
--   
--   Also, keep in mind that useful instances for the many types defined by
--   <tt>safe-money</tt> can be found in these other libraries:
--   
--   <ul>
--   <li><a>safe-money-aeson</a>: <tt>FromJSON</tt> and <tt>ToJSON</tt>
--   instances (from the <a>aeson</a> library).</li>
--   <li><a>safe-money-cereal</a>: <tt>Serialize</tt> instances (from the
--   <a>cereal</a> library).</li>
--   <li><a>safe-money-serialise</a>: <tt>Serialise</tt> instances (from
--   the <a>serialise</a> library).</li>
--   <li><a>safe-money-store</a>: <tt>Store</tt> instances (from the
--   <a>store</a> library).</li>
--   <li><a>safe-money-xmlbf</a>: <tt>FromXml</tt> and <tt>ToXml</tt>
--   instances (from the <a>xmlbf</a> library).</li>
--   </ul>
module Money

-- | <a>Dense</a> represents a dense monetary value for <tt>currency</tt>
--   (usually a ISO-4217 currency code, but not necessarily) as a rational
--   number.
--   
--   While monetary values associated with a particular currency are
--   discrete (e.g., an exact number of coins and bills), you can still
--   treat monetary values as dense while operating on them. For example,
--   the half of <tt>USD 3.41</tt> is <tt>USD 1.705</tt>, which is not an
--   amount that can't be represented as a number of USD cents (the
--   smallest unit that can represent USD amounts). Nevertheless, if you do
--   manage to represent <tt>USD 1.705</tt> somehow, and you eventually
--   multiply <tt>USD 1.705</tt> by <tt>4</tt> for example, then you end up
--   with <tt>USD 6.82</tt>, which is again a value representable as USD
--   cents. In other words, <a>Dense</a> monetary values allow us to
--   perform precise calculations deferring the conversion to a
--   <a>Discrete</a> monetary values as much as posible. Once you are ready
--   to approximate a <a>Dense</a> value to a <a>Discrete</a> value you can
--   use one <a>discreteFromDense</a>. Otherwise, using <a>toRational</a>
--   you can obtain a precise <a>Rational</a> representation.
data Dense (currency :: Symbol)

-- | <a>Dense</a> currency identifier.
--   
--   <pre>
--   &gt; <a>denseCurrency</a> (<a>dense'</a> 4 :: <a>Dense</a> "USD")
--   "USD"
--   </pre>
denseCurrency :: KnownSymbol currency => Dense currency -> Text

-- | Build a <a>Dense</a> monetary value from a <a>Rational</a> value.
--   
--   For example, if you want to represent <tt>USD 12.52316</tt>, then you
--   can use:
--   
--   <pre>
--   <a>dense</a> (125316 <a>%</a> 10000)
--   </pre>
--   
--   Notice that <a>dense</a> returns <a>Nothing</a> in case the given
--   <tt>Rational'</tt>s denominator is zero, which although unlikely, it
--   is possible if the <a>Rational</a> was unsafely constructed. When
--   dealing with hardcoded or trusted <a>Rational</a> values, you can use
--   <a>dense'</a> instead of <a>dense</a> which unsafely constructs a
--   <a>Dense</a>.
dense :: Rational -> Maybe (Dense currency)

-- | Unsafely build a <a>Dense</a> monetary value from a <a>Rational</a>
--   value. Contrary to <a>dense</a>, this function *crashes* if the given
--   <a>Rational</a> has zero as a denominator, which is something very
--   unlikely to happen unless the given <a>Rational</a> was itself
--   unsafely constructed. Other than that, <a>dense</a> and <a>dense'</a>
--   behave the same.
--   
--   Prefer to use <a>dense</a> when dealing with <a>Rational</a> inputs
--   from untrusted sources.
--   
--   <pre>
--   <a>denominator</a> x /= 0
--     ⇒ <a>dense</a> x == <a>Just</a> (<a>dense'</a> x)
--   </pre>
--   
--   <pre>
--   <a>denominator</a> x == 0
--     ⇒ <a>undefined</a> == <a>dense'</a> x
--   </pre>
dense' :: Rational -> Dense currency

-- | Convert currency <a>Discrete</a> monetary value into a <a>Dense</a>
--   monetary value.
denseFromDiscrete :: GoodScale scale => Discrete' currency scale -> Dense currency

-- | Parses a decimal representation of a <a>Dense</a>.
denseFromDecimal :: DecimalConf -> Text -> Maybe (Dense currency)

-- | Render a <a>Dense</a> monetary amount as a decimal number in a
--   potentially lossy manner.
--   
--   <pre>
--   &gt; <a>denseToDecimal</a> <a>defaultDecimalConf</a> <a>Round</a>
--        (<a>dense'</a> (123456 <a>%</a> 100) :: <a>Dense</a> "USD")
--   "1234.56"
--   </pre>
denseToDecimal :: DecimalConf -> Approximation -> Dense currency -> Text

-- | <a>Discrete</a> represents a discrete monetary value for a
--   <tt>currency</tt> expresed as an integer amount of a particular
--   <tt>unit</tt>. For example, with <tt>currency ~ "USD"</tt> and
--   <tt>unit ~ "cent"</tt> you can represent United States Dollars to
--   their full extent.
--   
--   <tt>currency</tt> is usually a ISO-4217 currency code, but not
--   necessarily.
--   
--   Construct <a>Discrete</a> values using <a>discrete</a>,
--   <a>fromIntegral</a>, <a>fromInteger</a>, <a>discreteFromDense</a>,
--   <a>discreteFromDecimal</a>.
--   
--   For example, if you want to represent <tt>GBP 21.05</tt>, where the
--   smallest represetable unit for a GBP (United Kingdom Pound) is the
--   <i>penny</i>, and 100 <i>pennies</i> equal 1 GBP (i.e.,
--   <tt><a>UnitScale</a> "GBP" "penny" ~ '(100, 1)</tt>), then you can
--   use:
--   
--   <pre>
--   <a>discrete</a> 2105 :: <a>Discrete</a> "GBP" "penny"
--   </pre>
--   
--   Because <tt>2105 / 100 == 21.05</tt>.
type Discrete (currency :: Symbol) (unit :: Symbol) = Discrete' currency (UnitScale currency unit)

-- | <a>Discrete'</a> represents a discrete monetary value for a
--   <tt>currency</tt> expresed as amount of <tt>scale</tt>, which is a
--   rational number expressed as <tt>(numerator, denominator)</tt>.
--   
--   You'll be using <a>Discrete</a> instead of <a>Discrete'</a> most of
--   the time, which mentions the unit name (such as <i>cent</i> or
--   <i>centavo</i>) instead of explicitely mentioning the unit scale.
data Discrete' (currency :: Symbol) (scale :: (Nat, Nat))

-- | Construct a <a>Discrete</a> value.
discrete :: GoodScale scale => Integer -> Discrete' currency scale

-- | <a>Discrete</a> currency identifier.
--   
--   <pre>
--   &gt; <a>discreteCurrency</a> (<a>discrete</a> 4 :: <a>Discrete</a> "USD" "cent")
--   "USD"
--   </pre>
discreteCurrency :: (KnownSymbol currency, GoodScale scale) => Discrete' currency scale -> Text

-- | Approximate a <a>Dense</a> value <tt>x</tt> to the nearest value fully
--   representable a given <tt>scale</tt>.
--   
--   If the given <a>Dense</a> doesn't fit entirely in the <tt>scale</tt>,
--   then a non-zero <a>Dense</a> reminder is returned alongside the
--   <a>Discrete</a> approximation.
--   
--   Proof that <a>discreteFromDense</a> doesn't lose money:
--   
--   <pre>
--   x == case <a>discreteFromDense</a> a x of
--           (y, z) -&gt; <a>denseFromDiscrete</a> y + z
--   </pre>
discreteFromDense :: forall currency scale. GoodScale scale => Approximation -> Dense currency -> (Discrete' currency scale, Dense currency)

-- | Parses a decimal representation of a <a>Discrete</a>.
--   
--   Notice that parsing will fail unless the entire precision of the
--   decimal number can be represented in the desired <tt>scale</tt>.
discreteFromDecimal :: GoodScale scale => DecimalConf -> Text -> Maybe (Discrete' currency scale)

-- | Render a <a>Discrete'</a> monetary amount as a decimal number in a
--   potentially lossy manner.
--   
--   This is simply a convenient wrapper around <a>denseToDecimal</a>:
--   
--   <pre>
--   <a>discreteToDecimal</a> ds a (dis :: <a>Discrete'</a> currency scale)
--       == <a>denseToDecimal</a> ds a (<a>denseFromDiscrete</a> dis :: <a>Dense</a> currency)
--   </pre>
--   
--   In particular, the <tt>scale</tt> in <tt><a>Discrete'</a> currency
--   scale</tt> has no influence over the scale in which the decimal number
--   is rendered. Change the scale with <a>decimalConf_scale</a> in order
--   to modify that behavior.
--   
--   Please refer to <a>denseToDecimal</a> for further documentation.
discreteToDecimal :: GoodScale scale => DecimalConf -> Approximation -> Discrete' currency scale -> Text

-- | This is the term-level representation of the “scale” we represent as
--   <tt>(<a>Nat</a>, <a>Nat</a>)</tt> elsewhere in the type system (e.g.,
--   in <a>GoodScale</a> or <a>UnitScale</a>).
--   
--   See <a>UnitScale</a> for a detailed description.
data Scale

-- | Construct a <a>Scale</a> from a positive, non-zero rational number.
scaleFromRational :: Rational -> Maybe Scale

-- | Obtain the <a>Rational</a> representation of a <a>Scale</a>.
scaleToRational :: Scale -> Rational

-- | Term-level representation of a currrency <tt>scale</tt>.
--   
--   For example, the <a>Scale</a> for <tt>"USD"</tt> in <tt>"cent"</tt>s
--   is <tt>100/1</tt>. We can obtain a term-level representation for it
--   using any of the following:
--   
--   <pre>
--   &gt; <a>scale</a> (<a>Proxy</a> :: <a>Proxy</a> (<a>UnitScale</a> "USD" "cent"))
--   <a>Scale</a> (100 <a>%</a> 1)
--   </pre>
--   
--   <pre>
--   &gt; <a>scale</a> (<a>Proxy</a> :: <a>CurrencyScale</a> "USD")
--   <a>Scale</a> (100 <a>%</a> 1)
--   </pre>
--   
--   <pre>
--   &gt; <a>scale</a> (x :: <a>Discrete</a> "USD" "cent")
--   <a>Scale</a> (100 <a>%</a> 1)
--   </pre>
--   
--   The returned <a>Rational</a> is statically guaranteed to be a positive
--   number.
scale :: forall proxy scale. GoodScale scale => proxy scale -> Scale

-- | <tt><a>UnitScale</a> currency unit</tt> is an rational number
--   (expressed as <tt>'(numerator, denominator)</tt>) indicating how many
--   pieces of <tt>unit</tt> fit in <tt>currency</tt>.
--   
--   <tt>currency</tt> is usually a ISO-4217 currency code, but not
--   necessarily.
--   
--   The resulting <tt>(<a>Nat</a>, <a>Nat</a>)</tt>, which is the
--   type-level representation for what at the term-level we call
--   <a>Scale</a>, will determine how to convert a <a>Dense</a> value into
--   a <a>Discrete</a> value and vice-versa.
--   
--   For example, there are 100 USD cents in 1 USD, so the scale for this
--   relationship is:
--   
--   <pre>
--   type instance <a>UnitScale</a> "USD" "cent" = '(100, 1)
--   </pre>
--   
--   As another example, there is 1 dollar in USD, so the scale for this
--   relationship is:
--   
--   <pre>
--   type instance <a>UnitScale</a> "USD" "dollar" = '(1, 1)
--   </pre>
--   
--   When using <a>Discrete</a> values to represent money, it will be
--   impossible to represent an amount of <tt>currency</tt> smaller than
--   <tt>unit</tt>. So, if you decide to use <tt>UnitScale "USD"
--   "dollar"</tt> as your scale, you will not be able to represent values
--   such as USD 3.50 or USD 21.87 becacuse they are not exact multiples of
--   a dollar.
--   
--   For some monetary values, such as precious metals, there is no
--   smallest representable unit, since you can repeatedly split the
--   precious metal many times before it stops being a precious metal.
--   Nevertheless, for practical purposes we can make a sane arbitrary
--   choice of smallest unit. For example, the base unit for XAU (Gold) is
--   the <i>troy ounce</i>, which is too big to be considered the smallest
--   unit, but we can arbitrarily choose the <i>milligrain</i> as our
--   smallest unit, which is about as heavy as a single grain of table salt
--   and should be sufficiently precise for all monetary practical
--   purposes. A <i>troy ounce</i> equals 480000 <i>milligrains</i>.
--   
--   <pre>
--   type instance <a>UnitScale</a> "XAU" "milligrain" = '(480000, 1)
--   </pre>
--   
--   You can use other units such as <i>milligrams</i> for measuring XAU,
--   for example. However, since the amount of <i>milligrams</i> in a
--   <i>troy ounce</i> (31103.477) is not integral, we need to use rational
--   with a denominator different than 1 to express it.
--   
--   <pre>
--   type instance <a>UnitScale</a> "XAU" "milligram" = '(31103477, 1000)
--   </pre>
--   
--   If you try to obtain the <a>UnitScale</a> of a <tt>currency</tt>
--   without an obvious smallest representable <tt>unit</tt>, like XAU, you
--   will get a compile error.
type family UnitScale (currency :: Symbol) (unit :: Symbol) :: (Nat, Nat)

-- | If there exists a canonical smallest <a>Scale</a> that can fully
--   represent the <tt>currency</tt> in all its denominations, then
--   <tt><a>CurrencyScale</a> currency</tt> will return such <a>Scale</a>.
--   For example, <tt><a>CurrencyScale</a> "USD"</tt> evaluates to
--   <tt><a>UnitScale</a> "USD" "cent"</tt>.
--   
--   <pre>
--   type instance <a>CurrencyScale</a> "USD" = <a>UnitScale</a> "USD" "cent"
--   </pre>
--   
--   If the <tt>currency</tt> doesn't have a canonical smallest
--   <a>Scale</a>, then <tt><a>CurrencyScale</a> currency</tt> shall be
--   left undefined or fail to compile with a <a>TypeError</a>. For example
--   <tt><a>CurrencyScale</a> "XAU"</tt> fails with
--   <tt><a>ErrScaleNonCanonical</a> "XAU"</tt>.
type family CurrencyScale (currency :: Symbol) :: (Nat, Nat)

-- | Constraints to a scale (like the one returned by <tt><a>UnitScale</a>
--   currency unit</tt>) expected to always be satisfied. In particular,
--   the scale is always guaranteed to be a positive rational number
--   (<a>infinity</a> and <a>notANumber</a> are forbidden by
--   <a>GoodScale</a>).
type GoodScale (scale :: (Nat, Nat)) = (CmpNat 0 (Fst scale) ~ 'LT, CmpNat 0 (Snd scale) ~ 'LT, KnownNat (Fst scale), KnownNat (Snd scale))

-- | A friendly <a>TypeError</a> to use for a <tt>currency</tt> that
--   doesn't have a canonical small unit.
type family ErrScaleNonCanonical (currency :: Symbol) :: k

-- | Exchange rate for converting monetary values of currency <tt>src</tt>
--   into monetary values of currency <tt>dst</tt> by multiplying for it.
--   
--   For example, if in order to convert USD to GBP we have to multiply by
--   1.2345, then we can represent this situaion using:
--   
--   <pre>
--   <a>exchangeRate</a> (12345 <a>%</a> 10000) :: <a>Maybe</a> (<a>ExchangeRate</a> "USD" "GBP")
--   </pre>
data ExchangeRate (src :: Symbol) (dst :: Symbol)

-- | Safely construct an <a>ExchangeRate</a> from a *positive*
--   <a>Rational</a> number.
--   
--   If the given <a>Rational</a> is non-positive, returns <a>Nothing</a>.
exchangeRate :: Rational -> Maybe (ExchangeRate src dst)

-- | Unsafely build an <tt>ExchageRate</tt> monetary value from a
--   <a>Rational</a> value. Contrary to <a>exchangeRate</a>, this function
--   *crashes* if the given <a>Rational</a> a value has zero as a
--   denominator or when it is negative, with the former case being
--   something very unlikely to happen unless the given <a>Rational</a> was
--   itself unsafely constructed. Other than that, <a>exchangeRate</a> and
--   <a>exchangeRate'</a> behave the same.
--   
--   Prefer to use <a>exchangeRate</a> when dealing with <a>Rational</a>
--   inputs from untrusted sources.
--   
--   <pre>
--   <a>denominator</a> x /= 0 &amp;&amp; x &gt; 0
--     ⇒ <a>exchangeRate</a> x == <a>Just</a> (<a>exchangeRate'</a> x)
--   </pre>
--   
--   <pre>
--   <a>denominator</a> x == 0 || x &lt;= 0
--     ⇒ <a>undefined</a> == <a>exchangeRate'</a> x
--   </pre>
exchangeRate' :: Rational -> ExchangeRate src dst

-- | Apply the <a>ExchangeRate</a> to the given <tt><a>Dense</a> src</tt>
--   monetary value.
--   
--   Identity law:
--   
--   <pre>
--   <a>exchange</a> (<a>exchangeRateRecip</a> x) . <a>exchange</a> x  ==  <a>id</a>
--   </pre>
--   
--   Use the <i>Identity law</i> for reasoning about going back and forth
--   between <tt>src</tt> and <tt>dst</tt> in order to manage any leftovers
--   that might not be representable as a <a>Discrete</a> monetary value of
--   <tt>src</tt>.
exchange :: ExchangeRate src dst -> Dense src -> Dense dst

-- | Reciprocal <a>ExchangeRate</a>.
--   
--   This function retuns the reciprocal or multiplicative inverse of the
--   given <a>ExchangeRate</a>, leading to the following identity law:
--   
--   <pre>
--   <a>exchangeRateRecip</a> . <a>exchangeRateRecip</a>   ==  <a>id</a>
--   </pre>
--   
--   Note: If <a>ExchangeRate</a> had a <a>Fractional</a> instance, then
--   <a>exchangeRateRecip</a> would be the implementation of <a>recip</a>.
exchangeRateRecip :: ExchangeRate a b -> ExchangeRate b a

-- | Parses a decimal representation of an <a>ExchangeRate</a>.
exchangeRateFromDecimal :: DecimalConf -> Text -> Maybe (ExchangeRate src dst)

-- | Render a <a>ExchangeRate</a> as a decimal number in a potentially
--   lossy manner.
--   
--   <pre>
--   &gt; <a>exchangeRateToDecimal</a> <a>defaultDecimalConf</a> <a>Round</a>
--         <a>&lt;$&gt;</a> (<a>exchangeRate</a> (123456 <a>%</a> 100) :: <a>Maybe</a> (<a>ExchangeRate</a> "USD" "EUR"))
--   Just "1,234.56"
--   </pre>
exchangeRateToDecimal :: DecimalConf -> Approximation -> ExchangeRate src dst -> Text

-- | Obtain a <a>Rational</a> representation of the <a>ExchangeRate</a>.
--   
--   This <a>Rational</a> is guaranteed to be a positive number.
exchangeRateToRational :: ExchangeRate src dst -> Rational

-- | A monomorphic representation of <a>Dense</a> that is easier to
--   serialize and deserialize than <a>Dense</a> in case you don't know the
--   type indexes involved.
--   
--   If you are trying to construct a value of this type from some raw
--   input, then you will need to use the <a>mkSomeDense</a> function.
--   
--   In order to be able to effectively serialize a <a>SomeDense</a> value,
--   you need to serialize the following three values (which are the
--   eventual arguments to <a>mkSomeDense</a>):
--   
--   <ul>
--   <li><a>someDenseCurrency</a></li>
--   <li><a>someDenseAmount</a></li>
--   </ul>
data SomeDense

-- | Convert a <a>Dense</a> to a <a>SomeDense</a> for ease of
--   serialization.
toSomeDense :: KnownSymbol currency => Dense currency -> SomeDense

-- | Build a <a>SomeDense</a> from raw values.
--   
--   This function is intended for deserialization purposes. You need to
--   convert this <a>SomeDense</a> value to a <a>Dense</a> value in order
--   to do any arithmetic operation on the monetary value.
mkSomeDense :: Text -> Rational -> Maybe SomeDense

-- | Attempt to convert a <a>SomeDense</a> to a <a>Dense</a>, provided you
--   know the target <tt>currency</tt>.
fromSomeDense :: forall currency. KnownSymbol currency => SomeDense -> Maybe (Dense currency)

-- | Convert a <a>SomeDense</a> to a <a>Dense</a> without knowing the
--   target <tt>currency</tt>.
--   
--   Notice that <tt>currency</tt> here can't leave its intended scope
--   unless you can prove equality with some other type at the outer scope,
--   but in that case you would be better off using <a>fromSomeDense</a>
--   directly.
withSomeDense :: SomeDense -> (forall currency. KnownSymbol currency => Dense currency -> r) -> r

-- | Like <a>denseToDecimal</a>, but takes a <a>SomeDense</a> as input.
someDenseToDecimal :: DecimalConf -> Approximation -> SomeDense -> Text

-- | Currency name.
someDenseCurrency :: SomeDense -> Text

-- | Currency unit amount.
someDenseAmount :: SomeDense -> Rational

-- | A monomorphic representation of <a>Discrete</a> that is easier to
--   serialize and deserialize than <a>Discrete</a> in case you don't know
--   the type indexes involved.
--   
--   If you are trying to construct a value of this type from some raw
--   input, then you will need to use the <a>mkSomeDiscrete</a> function.
--   
--   In order to be able to effectively serialize a <a>SomeDiscrete</a>
--   value, you need to serialize the following four values (which are the
--   eventual arguments to <a>mkSomeDiscrete</a>):
--   
--   <ul>
--   <li><a>someDiscreteCurrency</a></li>
--   <li><a>someDiscreteScale</a></li>
--   <li><a>someDiscreteAmount</a></li>
--   </ul>
data SomeDiscrete

-- | Convert a <a>Discrete</a> to a <a>SomeDiscrete</a> for ease of
--   serialization.
toSomeDiscrete :: (KnownSymbol currency, GoodScale scale) => Discrete' currency scale -> SomeDiscrete

-- | Build a <a>SomeDiscrete</a> from raw values.
--   
--   This function is intended for deserialization purposes. You need to
--   convert this <a>SomeDiscrete</a> value to a <a>Discrete</a> vallue in
--   order to do any arithmetic operation on the monetary value.
mkSomeDiscrete :: Text -> Scale -> Integer -> SomeDiscrete

-- | Attempt to convert a <a>SomeDiscrete</a> to a <a>Discrete</a>,
--   provided you know the target <tt>currency</tt> and <tt>unit</tt>.
fromSomeDiscrete :: forall currency scale. (KnownSymbol currency, GoodScale scale) => SomeDiscrete -> Maybe (Discrete' currency scale)

-- | Convert a <a>SomeDiscrete</a> to a <a>Discrete</a> without knowing the
--   target <tt>currency</tt> and <tt>unit</tt>.
--   
--   Notice that <tt>currency</tt> and <tt>unit</tt> here can't leave its
--   intended scope unless you can prove equality with some other type at
--   the outer scope, but in that case you would be better off using
--   <a>fromSomeDiscrete</a> directly.
--   
--   Notice that you may need to add an explicit type to the result of this
--   function in order to keep the compiler happy.
withSomeDiscrete :: forall r. SomeDiscrete -> (forall currency scale. (KnownSymbol currency, GoodScale scale) => Discrete' currency scale -> r) -> r

-- | Like <a>discreteToDecimal</a>, but takes a <a>SomeDiscrete</a> as
--   input.
someDiscreteToDecimal :: DecimalConf -> Approximation -> SomeDiscrete -> Text

-- | Currency name.
someDiscreteCurrency :: SomeDiscrete -> Text

-- | Positive, non-zero.
someDiscreteScale :: SomeDiscrete -> Scale

-- | Amount of currency unit.
someDiscreteAmount :: SomeDiscrete -> Integer

-- | A monomorphic representation of <a>ExchangeRate</a> that is easier to
--   serialize and deserialize than <a>ExchangeRate</a> in case you don't
--   know the type indexes involved.
--   
--   If you are trying to construct a value of this type from some raw
--   input, then you will need to use the <a>mkSomeExchangeRate</a>
--   function.
--   
--   In order to be able to effectively serialize an
--   <a>SomeExchangeRate</a> value, you need to serialize the following
--   four values (which are the eventual arguments to
--   <a>mkSomeExchangeRate</a>):
--   
--   <ul>
--   <li><a>someExchangeRateSrcCurrency</a></li>
--   <li><a>someExchangeRateDstCurrency</a></li>
--   <li><a>someExchangeRateRate</a></li>
--   </ul>
data SomeExchangeRate

-- | Convert a <a>ExchangeRate</a> to a <a>SomeDiscrete</a> for ease of
--   serialization.
toSomeExchangeRate :: (KnownSymbol src, KnownSymbol dst) => ExchangeRate src dst -> SomeExchangeRate

-- | Build a <a>SomeExchangeRate</a> from raw values.
--   
--   This function is intended for deserialization purposes. You need to
--   convert this <a>SomeExchangeRate</a> value to a <a>ExchangeRate</a>
--   value in order to do any arithmetic operation with the exchange rate.
mkSomeExchangeRate :: Text -> Text -> Rational -> Maybe SomeExchangeRate

-- | Attempt to convert a <a>SomeExchangeRate</a> to a <a>ExchangeRate</a>,
--   provided you know the target <tt>src</tt> and <tt>dst</tt> types.
fromSomeExchangeRate :: forall src dst. (KnownSymbol src, KnownSymbol dst) => SomeExchangeRate -> Maybe (ExchangeRate src dst)

-- | Convert a <a>SomeExchangeRate</a> to a <a>ExchangeRate</a> without
--   knowing the target <tt>currency</tt> and <tt>unit</tt>.
--   
--   Notice that <tt>src</tt> and <tt>dst</tt> here can't leave its
--   intended scope unless you can prove equality with some other type at
--   the outer scope, but in that case you would be better off using
--   <a>fromSomeExchangeRate</a> directly.
withSomeExchangeRate :: SomeExchangeRate -> (forall src dst. (KnownSymbol src, KnownSymbol dst) => ExchangeRate src dst -> r) -> r

-- | Like <a>exchangeRateToDecimal</a>, but takes a <a>SomeExchangeRate</a>
--   as input.
someExchangeRateToDecimal :: DecimalConf -> Approximation -> SomeExchangeRate -> Text

-- | Source currency name.
someExchangeRateSrcCurrency :: SomeExchangeRate -> Text

-- | Destination currency name.
someExchangeRateDstCurrency :: SomeExchangeRate -> Text

-- | Exchange rate. Positive, non-zero.
someExchangeRateRate :: SomeExchangeRate -> Rational

-- | Method for approximating a fractional number to an integer number.
data Approximation

-- | Approximate <tt>x</tt> to the nearest integer, or to the nearest even
--   integer if <tt>x</tt> is equidistant between two integers.
Round :: Approximation

-- | Approximate <tt>x</tt> to the nearest integer less than or equal to
--   <tt>x</tt>.
Floor :: Approximation

-- | Approximate <tt>x</tt> to the nearest integer greater than or equal to
--   <tt>x</tt>.
Ceiling :: Approximation

-- | Approximate <tt>x</tt> to the nearest integer betwen <tt>0</tt> and
--   <tt>x</tt>, inclusive.
Truncate :: Approximation

-- | Approximate <tt>x</tt> to the nearest even integer, when equidistant
--   from the nearest two integers. This is also known as “Bankers
--   Rounding”.
HalfEven :: Approximation

-- | Approximate <tt>x</tt> to the nearest integer, or to the nearest
--   integer away from zero if <tt>x</tt> is equidistant between to
--   integers. This is known as “kaufmännisches Runden” in German speaking
--   countries.
HalfAwayFromZero :: Approximation

-- | Config to use when rendering or parsing decimal numbers.
--   
--   See <a>defaultDecimalConf</a>.
data DecimalConf
DecimalConf :: !Separators -> !Bool -> !Word8 -> !Scale -> DecimalConf

-- | Decimal and thousands separators to use when rendering the decimal
--   number. Construct one with <a>mkSeparators</a>, or pick a ready made
--   one like <a>separatorsDot</a> or <a>separatorsDotNarrownbsp</a>.
[decimalConf_separators] :: DecimalConf -> !Separators

-- | Whether to render a leading <tt>'+'</tt> sign in case the amount is
--   positive.
[decimalConf_leadingPlus] :: DecimalConf -> !Bool

-- | Number of decimal numbers to render, if any.
[decimalConf_digits] :: DecimalConf -> !Word8

-- | Scale used to when rendering the decimal number. This is useful if,
--   for example, you want to render a “number of cents” rather than a
--   “number of dollars” as the whole part of the decimal number when
--   rendering a USD amount. It's particularly useful when rendering
--   currencies such as XAU, where one might prefer to render amounts as a
--   number of grams, rather than as a number of troy-ounces.
--   
--   <i>Set this to <tt>1</tt> if you don't care.</i>
--   
--   For example, when rendering render <tt><a>dense'</a> (123 <a>%</a>
--   100) :: <a>Dense</a> "USD"</tt> as a decimal number with two decimal
--   places, a scale of <tt>1</tt> (analogous to <tt><a>UnitScale</a> "USD"
--   "dollar"</tt>) would render <tt>1</tt> as the integer part and
--   <tt>23</tt> as the fractional part, whereas a scale of <tt>100</tt>
--   (analogous <tt><a>UnitScale</a> "USD" "cent"</tt>) would render
--   <tt>123</tt> as the integer part and <tt>00</tt> as the fractional
--   part.
--   
--   You can easily obtain the scale for a particular currency and unit
--   combination using the <a>scale</a> function.
--   
--   <b>Important:</b> Generally, you will want this number to be
--   <tt>1</tt> or larger. This is because scales in the range <tt>(0,
--   1)</tt> can be particularly lossy unless the number of decimal digits
--   is sufficiently large.
[decimalConf_scale] :: DecimalConf -> !Scale

-- | Default <a>DecimalConf</a>.
--   
--   <ul>
--   <li>No leading <tt>'+'</tt> sign</li>
--   <li>No thousands separator</li>
--   <li>Decimal separator is <tt>'.'</tt></li>
--   <li><tt>2</tt> decimal digits</li>
--   <li>A scale of <tt>1</tt></li>
--   </ul>
--   
--   That is, something like <tt>1.23</tt> or <tt>-1234567.89</tt>.
defaultDecimalConf :: DecimalConf

-- | Decimal and thousands separators used when rendering or parsing a
--   decimal number.
--   
--   Use <a>mkSeparators</a> to construct.
data Separators

-- | Construct <a>Separators</a> to use with in <a>DecimalConf</a>.
--   
--   The separators can't be an ASCII digit nor control character, and they
--   must be different from each other.
mkSeparators :: Char -> Maybe Char -> Maybe Separators

-- | <pre>
--   1234567,89
--   </pre>
separatorsComma :: Separators

-- | <pre>
--   1.234.567,89
--   </pre>
separatorsCommaDot :: Separators

-- | <pre>
--   1 234 567,89
--   </pre>
--   
--   The whitespace is Unicode's <i>NARROW NO-BREAK SPACE</i> (U+202f,
--   8239, <tt>'8239'</tt>).
separatorsCommaNarrownbsp :: Separators

-- | <pre>
--   1 234 567,89
--   </pre>
--   
--   The whitespace is Unicode's <i>NO-BREAK SPACE</i> (U+00a0, 160,
--   <tt>'160'</tt>).
separatorsCommaNbsp :: Separators

-- | <pre>
--   1 234 567,89
--   </pre>
--   
--   The whitespace is Unicode's <i>THIN SPACE</i> (U+2009, 8201,
--   <tt>'8201'</tt>).
separatorsCommaThinsp :: Separators

-- | <pre>
--   1 234 567,89
--   </pre>
--   
--   The whitespace is ASCII's <i>SPC</i> (U+0020, 32, <tt>'32'</tt>).
separatorsCommaSpace :: Separators

-- | <pre>
--   1234567.89
--   </pre>
separatorsDot :: Separators

-- | <pre>
--   1,234,567.89
--   </pre>
separatorsDotComma :: Separators

-- | <pre>
--   1 234 567.89
--   </pre>
--   
--   The whitespace is Unicode's <i>NARROW NO-BREAK SPACE</i> (U+202f,
--   8239, <tt>'8239'</tt>).
separatorsDotNarrownbsp :: Separators

-- | <pre>
--   1 234 567.89
--   </pre>
--   
--   The whitespace is Unicode's <i>THIN SPACE</i> (U+2009, 8201,
--   <tt>'8201'</tt>).
separatorsDotThinsp :: Separators

-- | <pre>
--   1 234 567.89
--   </pre>
--   
--   The whitespace is Unicode's <i>NO-BREAK SPACE</i> (U+00a0, 160,
--   <tt>'160'</tt>).
separatorsDotNbsp :: Separators

-- | <pre>
--   1 234 567.89
--   </pre>
--   
--   The whitespace is ASCII's <i>SPACE</i> (U+0020, 32, <tt>'32'</tt>).
separatorsDotSpace :: Separators
