-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient implementation of a dependent map with types as keys
--   
--   A dependent map from type representations to values of these types.
--   
--   Here is an illustration of such a map:
--   
--   <pre>
--       TMap
--   ---------------
--    Int  -&gt; 5
--    Bool -&gt; True
--    Char -&gt; 'x'
--   </pre>
--   
--   In addition to <tt>TMap</tt>, we provide <tt>TypeRepMap</tt>
--   parametrized by a <tt>vinyl</tt>-style interpretation. This data
--   structure is equivalent to <tt>DMap TypeRep</tt>, but with
--   significantly more efficient lookups.
@package typerep-map
@version 0.6.0.0


-- | Internal API for <a>TypeRepMap</a> and operations on it. The functions
--   here do not have any stability guarantees and can change between minor
--   versions.
--   
--   If you need to use this module for purposes other than tests, create
--   an issue.
module Data.TypeRepMap.Internal

-- | <a>TypeRepMap</a> is a heterogeneous data structure similar in its
--   essence to <a>Map</a> with types as keys, where each value has the
--   type of its key. In addition to that, each value is wrapped in an
--   interpretation <tt>f</tt>.
--   
--   Here is an example of using <a>Maybe</a> as an interpretation, with a
--   comparison to <a>Map</a>:
--   
--   <pre>
--    <a>Map</a> <a>String</a> (<a>Maybe</a> <a>String</a>)          <a>TypeRepMap</a> <a>Maybe</a>
--   ---------------------------       ---------------------
--    "Int"  -&gt; Just "5"                 <a>Int</a>  -&gt; Just 5
--    "Bool" -&gt; Just "True"              <a>Bool</a> -&gt; Just <a>True</a>
--    "Char" -&gt; Nothing                  <a>Char</a> -&gt; Nothing
--   </pre>
--   
--   The runtime representation of <a>TypeRepMap</a> is an array, not a
--   tree. This makes <a>lookup</a> significantly more efficient.
data TypeRepMap (f :: k -> Type)

-- | an unsafe constructor for <a>TypeRepMap</a>
TypeRepMap :: {-# UNPACK #-} !PrimArray Word64 -> {-# UNPACK #-} !PrimArray Word64 -> {-# UNPACK #-} !Array Any -> {-# UNPACK #-} !Array Any -> TypeRepMap (f :: k -> Type)

-- | first components of key fingerprints
[fingerprintAs] :: TypeRepMap (f :: k -> Type) -> {-# UNPACK #-} !PrimArray Word64

-- | second components of key fingerprints
[fingerprintBs] :: TypeRepMap (f :: k -> Type) -> {-# UNPACK #-} !PrimArray Word64

-- | values stored in the map
[trAnys] :: TypeRepMap (f :: k -> Type) -> {-# UNPACK #-} !Array Any

-- | typerep keys
[trKeys] :: TypeRepMap (f :: k -> Type) -> {-# UNPACK #-} !Array Any

-- | Returns the list of <a>Fingerprint</a>s from <a>TypeRepMap</a>.
toFingerprints :: TypeRepMap f -> [Fingerprint]

-- | A <a>TypeRepMap</a> with no values stored in it.
--   
--   <pre>
--   size empty == 0
--   </pre>
--   
--   <pre>
--   member @a empty == False
--   </pre>
empty :: TypeRepMap f

-- | Construct a <a>TypeRepMap</a> with a single element.
--   
--   <pre>
--   size (one x) == 1
--   </pre>
--   
--   <pre>
--   member @a (one (x :: f a)) == True
--   </pre>
one :: forall a f. Typeable a => f a -> TypeRepMap f

-- | Insert a value into a <a>TypeRepMap</a>. TypeRepMap optimizes for fast
--   reads rather than inserts, as a trade-off inserts are <tt>O(n)</tt>.
--   
--   <pre>
--   size (insert v tm) &gt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (insert (x :: f a) tm) == True
--   </pre>
insert :: forall a f. Typeable a => f a -> TypeRepMap f -> TypeRepMap f
type KindOf (a :: k) = k
type ArgKindOf (f :: k -> l) = k

-- | Delete a value from a <a>TypeRepMap</a>.
--   
--   TypeRepMap optimizes for fast reads rather than modifications, as a
--   trade-off deletes are <tt>O(n)</tt>, with an <tt>O(log(n))</tt>
--   optimization for when the element is already missing.
--   
--   <pre>
--   size (delete @a tm) &lt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (delete @a tm) == False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tm = delete @Bool $ insert (Just True) $ one (Just 'a')
--   
--   &gt;&gt;&gt; size tm
--   1
--   
--   &gt;&gt;&gt; member @Bool tm
--   False
--   
--   &gt;&gt;&gt; member @Char tm
--   True
--   </pre>
delete :: forall a (f :: KindOf a -> Type). Typeable a => TypeRepMap f -> TypeRepMap f
deleteFirst :: (a -> Bool) -> [a] -> [a]

-- | Update a value at a specific key with the result of the provided
--   function. When the key is not a member of the map, the original map is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; trmap = fromList @(TypeRepMap Identity) [WrapTypeable $ Identity "a"]
--   
--   &gt;&gt;&gt; lookup @String $ adjust (fmap (++ "ww")) trmap
--   Just (Identity "aww")
--   </pre>
adjust :: forall a f. Typeable a => (f a -> f a) -> TypeRepMap f -> TypeRepMap f

-- | Updates a value at a specific key, whether or not it exists. This can
--   be used to insert, delete, or update a value of a given type in the
--   map.
--   
--   <pre>
--   &gt;&gt;&gt; func = (\case Nothing -&gt; Just (Identity "new"); Just (Identity s) -&gt; Just (Identity (reverse s)))
--   
--   &gt;&gt;&gt; lookup @String $ alter func empty
--   Just (Identity "new")
--   
--   &gt;&gt;&gt; trmap = fromList @(TypeRepMap Identity) [WrapTypeable $ Identity "helllo"]
--   
--   &gt;&gt;&gt; lookup @String $ alter func trmap
--   
--   &gt;&gt;&gt; Just (Identity "olleh")
--   </pre>
alter :: forall a f. Typeable a => (Maybe (f a) -> Maybe (f a)) -> TypeRepMap f -> TypeRepMap f

-- | Map over the elements of a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; tm = insert (Identity True) $ one (Identity 'a')
--   
--   &gt;&gt;&gt; lookup @Bool tm
--   Just (Identity True)
--   
--   &gt;&gt;&gt; lookup @Char tm
--   Just (Identity 'a')
--   
--   &gt;&gt;&gt; tm2 = hoist ((:[]) . runIdentity) tm
--   
--   &gt;&gt;&gt; lookup @Bool tm2
--   Just [True]
--   
--   &gt;&gt;&gt; lookup @Char tm2
--   Just "a"
--   </pre>
hoist :: (forall x. f x -> g x) -> TypeRepMap f -> TypeRepMap g
hoistA :: Applicative t => (forall x. f x -> t (g x)) -> TypeRepMap f -> t (TypeRepMap g)
hoistWithKey :: forall f g. (forall x. Typeable x => f x -> g x) -> TypeRepMap f -> TypeRepMap g

-- | The union of two <a>TypeRepMap</a>s using a combining function for
--   conflicting entries. <tt>O(n + m)</tt>
unionWith :: forall f. (forall x. Typeable x => f x -> f x -> f x) -> TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | The (left-biased) union of two <a>TypeRepMap</a>s in <tt>O(n +
--   m)</tt>. It prefers the first map when duplicate keys are encountered,
--   i.e. <tt><a>union</a> == <a>unionWith</a> const</tt>.
union :: TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | The <a>intersection</a> of two <a>TypeRepMap</a>s using a combining
--   function
--   
--   <pre>
--   O(n + m)
--   </pre>
intersectionWith :: forall f. (forall x. Typeable x => f x -> f x -> f x) -> TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | The intersection of two <a>TypeRepMap</a>s. It keeps all values from
--   the first map whose keys are present in the second.
--   
--   <pre>
--   O(n + m)
--   </pre>
intersection :: TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | Check if a value of the given type is present in a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; member @Char $ one (Identity 'a')
--   True
--   
--   &gt;&gt;&gt; member @Bool $ one (Identity 'a')
--   False
--   </pre>
member :: forall a (f :: KindOf a -> Type). Typeable a => TypeRepMap f -> Bool

-- | Lookup a value of the given type in a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; x = lookup $ insert (Identity (11 :: Int)) empty
--   
--   &gt;&gt;&gt; x :: Maybe (Identity Int)
--   Just (Identity 11)
--   
--   &gt;&gt;&gt; x :: Maybe (Identity ())
--   Nothing
--   </pre>
lookup :: forall a f. Typeable a => TypeRepMap f -> Maybe (f a)

-- | Get the amount of elements in a <a>TypeRepMap</a>.
size :: TypeRepMap f -> Int

-- | Return the list of <a>SomeTypeRep</a> from the keys.
keys :: TypeRepMap f -> [SomeTypeRep]

-- | Return the list of keys by wrapping them with a user-provided
--   function.
keysWith :: (forall (a :: ArgKindOf f). TypeRep a -> r) -> TypeRepMap f -> [r]

-- | Return the list of key-value pairs by wrapping them with a
--   user-provided function.
toListWith :: forall f r. (forall (a :: ArgKindOf f). Typeable a => f a -> r) -> TypeRepMap f -> [r]

-- | Binary searched based on this article
--   <a>http://bannalia.blogspot.com/2015/06/cache-friendly-binary-search.html</a>
--   with modification for our two-vector search case.
cachedBinarySearch :: Fingerprint -> PrimArray Word64 -> PrimArray Word64 -> Maybe Int
toAny :: f a -> Any
fromAny :: Any -> f a
anyToTypeRep :: Any -> TypeRep f
typeFp :: forall a. Typeable a => Fingerprint
toTriples :: TypeRepMap f -> [(Fingerprint, Any, Any)]

-- | Efficiently get sorted triples from a map in O(n) time
--   
--   We assume the incoming TypeRepMap is already sorted into
--   <a>cachedBinarySearch</a> order using fromSortedList. Then we can
--   construct the index mapping from the "cached" ordering into
--   monotonically increasing order using <a>generateOrderMapping</a> with
--   the length of the TRM. This takes <tt>O(n). We then pull those indexes
--   from the source TRM to get the sorted triples in a total of </tt>O(n).
toSortedTriples :: TypeRepMap f -> [(Fingerprint, Any, Any)]
nubByFst :: Eq a => [(a, b, c)] -> [(a, b, c)]
fst3 :: (a, b, c) -> a

-- | Existential wrapper around <a>Typeable</a> indexed by <tt>f</tt> type
--   parameter. Useful for <a>TypeRepMap</a> structure creation form list
--   of <a>WrapTypeable</a>s.
data WrapTypeable f
[WrapTypeable] :: Typeable a => f a -> WrapTypeable f
calcFp :: forall a. Typeable a => Fingerprint
fromTriples :: [(Fingerprint, Any, Any)] -> TypeRepMap f
fromSortedTriples :: [(Fingerprint, Any, Any)] -> TypeRepMap f
fromSortedList :: forall a. [a] -> [a]
generateOrderMapping :: Int -> [Int]

-- | Check that invariant of the structure holds. The structure maintains
--   the following invariant. For each element <tt>A</tt> at index
--   <tt>i</tt>:
--   
--   <ol>
--   <li>if there is an element <tt>B</tt> at index <tt>2*i+1</tt>, then
--   <tt>B &lt; A</tt>.</li>
--   <li>if there is an element <tt>C</tt> at index <tt>2*i+2</tt>, then
--   <tt>A &lt; C</tt>.</li>
--   </ol>
invariantCheck :: TypeRepMap f -> Bool
instance forall k (f :: k -> *). GHC.Show.Show (Data.TypeRepMap.Internal.WrapTypeable f)
instance forall k (f :: k -> *). GHC.Exts.IsList (Data.TypeRepMap.Internal.TypeRepMap f)
instance forall k (f :: k -> *). Control.DeepSeq.NFData (Data.TypeRepMap.Internal.TypeRepMap f)
instance forall k (f :: k -> *). GHC.Show.Show (Data.TypeRepMap.Internal.TypeRepMap f)
instance forall k (f :: k -> *). GHC.Base.Semigroup (Data.TypeRepMap.Internal.TypeRepMap f)
instance forall k (f :: k -> *). GHC.Base.Monoid (Data.TypeRepMap.Internal.TypeRepMap f)
instance forall k (f :: k -> *). (forall (a :: k). Data.Typeable.Internal.Typeable a => GHC.Classes.Eq (f a)) => GHC.Classes.Eq (Data.TypeRepMap.Internal.TypeRepMap f)


-- | A version of <a>TMap</a> parametrized by an interpretation <tt>f</tt>.
--   This sort of parametrization may be familiar to users of
--   <tt>vinyl</tt> records.
--   
--   <tt><a>TypeRepMap</a> f</tt> is a more efficient replacement for
--   <tt>DMap <a>TypeRep</a> f</tt> (where <tt>DMap</tt> is from the
--   <tt>dependent-map</tt> package).
--   
--   Here is an example of using <a>Maybe</a> as an interpretation, with a
--   comparison to <a>TMap</a>:
--   
--   <pre>
--        <a>TMap</a>              <a>TypeRepMap</a> <a>Maybe</a>
--   --------------       -------------------
--    Int  -&gt; 5             Int  -&gt; Just 5
--    Bool -&gt; True          Bool -&gt; Nothing
--    Char -&gt; 'x'           Char -&gt; Just 'x'
--   </pre>
--   
--   In fact, a <a>TMap</a> is defined as <a>TypeRepMap</a>
--   <a>Identity</a>.
--   
--   Since <a>TypeRep</a> is poly-kinded, the interpretation can use any
--   kind for the keys. For instance, we can use the <a>Symbol</a> kind to
--   use <a>TypeRepMap</a> as an extensible record:
--   
--   <pre>
--   newtype Field name = F (FType name)
--   
--   type family FType (name :: Symbol) :: Type
--   type instance FType "radius" = Double
--   type instance FType "border-color" = RGB
--   type instance FType "border-width" = Double
--   
--          <a>TypeRepMap</a> Field
--   --------------------------------------
--    "radius"       -&gt; F 5.7
--    "border-color" -&gt; F (rgb 148 0 211)
--    "border-width" -&gt; F 0.5
--   </pre>
module Data.TypeRepMap

-- | <a>TypeRepMap</a> is a heterogeneous data structure similar in its
--   essence to <a>Map</a> with types as keys, where each value has the
--   type of its key. In addition to that, each value is wrapped in an
--   interpretation <tt>f</tt>.
--   
--   Here is an example of using <a>Maybe</a> as an interpretation, with a
--   comparison to <a>Map</a>:
--   
--   <pre>
--    <a>Map</a> <a>String</a> (<a>Maybe</a> <a>String</a>)          <a>TypeRepMap</a> <a>Maybe</a>
--   ---------------------------       ---------------------
--    "Int"  -&gt; Just "5"                 <a>Int</a>  -&gt; Just 5
--    "Bool" -&gt; Just "True"              <a>Bool</a> -&gt; Just <a>True</a>
--    "Char" -&gt; Nothing                  <a>Char</a> -&gt; Nothing
--   </pre>
--   
--   The runtime representation of <a>TypeRepMap</a> is an array, not a
--   tree. This makes <a>lookup</a> significantly more efficient.
data TypeRepMap (f :: k -> Type)

-- | A <a>TypeRepMap</a> with no values stored in it.
--   
--   <pre>
--   size empty == 0
--   </pre>
--   
--   <pre>
--   member @a empty == False
--   </pre>
empty :: TypeRepMap f

-- | Construct a <a>TypeRepMap</a> with a single element.
--   
--   <pre>
--   size (one x) == 1
--   </pre>
--   
--   <pre>
--   member @a (one (x :: f a)) == True
--   </pre>
one :: forall a f. Typeable a => f a -> TypeRepMap f

-- | Insert a value into a <a>TypeRepMap</a>. TypeRepMap optimizes for fast
--   reads rather than inserts, as a trade-off inserts are <tt>O(n)</tt>.
--   
--   <pre>
--   size (insert v tm) &gt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (insert (x :: f a) tm) == True
--   </pre>
insert :: forall a f. Typeable a => f a -> TypeRepMap f -> TypeRepMap f

-- | Delete a value from a <a>TypeRepMap</a>.
--   
--   TypeRepMap optimizes for fast reads rather than modifications, as a
--   trade-off deletes are <tt>O(n)</tt>, with an <tt>O(log(n))</tt>
--   optimization for when the element is already missing.
--   
--   <pre>
--   size (delete @a tm) &lt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (delete @a tm) == False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tm = delete @Bool $ insert (Just True) $ one (Just 'a')
--   
--   &gt;&gt;&gt; size tm
--   1
--   
--   &gt;&gt;&gt; member @Bool tm
--   False
--   
--   &gt;&gt;&gt; member @Char tm
--   True
--   </pre>
delete :: forall a (f :: KindOf a -> Type). Typeable a => TypeRepMap f -> TypeRepMap f

-- | Update a value at a specific key with the result of the provided
--   function. When the key is not a member of the map, the original map is
--   returned.
--   
--   <pre>
--   &gt;&gt;&gt; trmap = fromList @(TypeRepMap Identity) [WrapTypeable $ Identity "a"]
--   
--   &gt;&gt;&gt; lookup @String $ adjust (fmap (++ "ww")) trmap
--   Just (Identity "aww")
--   </pre>
adjust :: forall a f. Typeable a => (f a -> f a) -> TypeRepMap f -> TypeRepMap f

-- | Updates a value at a specific key, whether or not it exists. This can
--   be used to insert, delete, or update a value of a given type in the
--   map.
--   
--   <pre>
--   &gt;&gt;&gt; func = (\case Nothing -&gt; Just (Identity "new"); Just (Identity s) -&gt; Just (Identity (reverse s)))
--   
--   &gt;&gt;&gt; lookup @String $ alter func empty
--   Just (Identity "new")
--   
--   &gt;&gt;&gt; trmap = fromList @(TypeRepMap Identity) [WrapTypeable $ Identity "helllo"]
--   
--   &gt;&gt;&gt; lookup @String $ alter func trmap
--   
--   &gt;&gt;&gt; Just (Identity "olleh")
--   </pre>
alter :: forall a f. Typeable a => (Maybe (f a) -> Maybe (f a)) -> TypeRepMap f -> TypeRepMap f

-- | Map over the elements of a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; tm = insert (Identity True) $ one (Identity 'a')
--   
--   &gt;&gt;&gt; lookup @Bool tm
--   Just (Identity True)
--   
--   &gt;&gt;&gt; lookup @Char tm
--   Just (Identity 'a')
--   
--   &gt;&gt;&gt; tm2 = hoist ((:[]) . runIdentity) tm
--   
--   &gt;&gt;&gt; lookup @Bool tm2
--   Just [True]
--   
--   &gt;&gt;&gt; lookup @Char tm2
--   Just "a"
--   </pre>
hoist :: (forall x. f x -> g x) -> TypeRepMap f -> TypeRepMap g
hoistA :: Applicative t => (forall x. f x -> t (g x)) -> TypeRepMap f -> t (TypeRepMap g)
hoistWithKey :: forall f g. (forall x. Typeable x => f x -> g x) -> TypeRepMap f -> TypeRepMap g

-- | The union of two <a>TypeRepMap</a>s using a combining function for
--   conflicting entries. <tt>O(n + m)</tt>
unionWith :: forall f. (forall x. Typeable x => f x -> f x -> f x) -> TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | The (left-biased) union of two <a>TypeRepMap</a>s in <tt>O(n +
--   m)</tt>. It prefers the first map when duplicate keys are encountered,
--   i.e. <tt><a>union</a> == <a>unionWith</a> const</tt>.
union :: TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | The <a>intersection</a> of two <a>TypeRepMap</a>s using a combining
--   function
--   
--   <pre>
--   O(n + m)
--   </pre>
intersectionWith :: forall f. (forall x. Typeable x => f x -> f x -> f x) -> TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | The intersection of two <a>TypeRepMap</a>s. It keeps all values from
--   the first map whose keys are present in the second.
--   
--   <pre>
--   O(n + m)
--   </pre>
intersection :: TypeRepMap f -> TypeRepMap f -> TypeRepMap f

-- | Lookup a value of the given type in a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; x = lookup $ insert (Identity (11 :: Int)) empty
--   
--   &gt;&gt;&gt; x :: Maybe (Identity Int)
--   Just (Identity 11)
--   
--   &gt;&gt;&gt; x :: Maybe (Identity ())
--   Nothing
--   </pre>
lookup :: forall a f. Typeable a => TypeRepMap f -> Maybe (f a)

-- | Check if a value of the given type is present in a <a>TypeRepMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; member @Char $ one (Identity 'a')
--   True
--   
--   &gt;&gt;&gt; member @Bool $ one (Identity 'a')
--   False
--   </pre>
member :: forall a (f :: KindOf a -> Type). Typeable a => TypeRepMap f -> Bool

-- | Get the amount of elements in a <a>TypeRepMap</a>.
size :: TypeRepMap f -> Int

-- | Return the list of <a>SomeTypeRep</a> from the keys.
keys :: TypeRepMap f -> [SomeTypeRep]

-- | Return the list of keys by wrapping them with a user-provided
--   function.
keysWith :: (forall (a :: ArgKindOf f). TypeRep a -> r) -> TypeRepMap f -> [r]

-- | Return the list of key-value pairs by wrapping them with a
--   user-provided function.
toListWith :: forall f r. (forall (a :: ArgKindOf f). Typeable a => f a -> r) -> TypeRepMap f -> [r]

-- | Existential wrapper around <a>Typeable</a> indexed by <tt>f</tt> type
--   parameter. Useful for <a>TypeRepMap</a> structure creation form list
--   of <a>WrapTypeable</a>s.
data WrapTypeable f
[WrapTypeable] :: Typeable a => f a -> WrapTypeable f


-- | <a>TMap</a> is a heterogeneous data structure similar in its essence
--   to <a>Map</a> with types as keys, where each value has the type of its
--   key.
--   
--   Here is an example of a <a>TMap</a> with a comparison to <a>Map</a>:
--   
--   <pre>
--    <a>Map</a> <a>String</a> <a>String</a>             <a>TMap</a>
--   --------------------     -----------------
--    "Int"  -&gt; "5"             <a>Int</a>  -&gt; 5
--    "Bool" -&gt; "True"          <a>Bool</a> -&gt; <a>True</a>
--    "Char" -&gt; "'x'"           <a>Char</a> -&gt; 'x'
--   </pre>
--   
--   The runtime representation of <a>TMap</a> is an array, not a tree.
--   This makes <a>lookup</a> significantly more efficient.
module Data.TMap

-- | <a>TMap</a> is a special case of <a>TypeRepMap</a> when the
--   interpretation is <a>Identity</a>.
type TMap = TypeRepMap Identity

-- | A <a>TMap</a> with no values stored in it.
--   
--   <pre>
--   size empty == 0
--   </pre>
--   
--   <pre>
--   member @a empty == False
--   </pre>
empty :: TMap

-- | Construct a <a>TMap</a> with a single element.
--   
--   <pre>
--   size (one x) == 1
--   </pre>
--   
--   <pre>
--   member @a (one (x :: a)) == True
--   </pre>
one :: forall a. Typeable a => a -> TMap

-- | Insert a value into a <a>TMap</a>. TMap optimizes for fast reads
--   rather than inserts, as a trade-off inserts are <tt>O(n)</tt>.
--   
--   <pre>
--   size (insert v tm) &gt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (insert (x :: a) tm) == True
--   </pre>
insert :: forall a. Typeable a => a -> TMap -> TMap

-- | Delete a value from a <a>TMap</a>.
--   
--   TMap optimizes for fast reads rather than modifications, as a
--   trade-off deletes are <tt>O(n)</tt>, with an <tt>O(log(n))</tt>
--   optimization for when the element is already missing.
--   
--   <pre>
--   size (delete @a tm) &lt;= size tm
--   </pre>
--   
--   <pre>
--   member @a (delete @a tm) == False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; tm = delete @Bool $ insert True $ one 'a'
--   
--   &gt;&gt;&gt; size tm
--   1
--   
--   &gt;&gt;&gt; member @Bool tm
--   False
--   
--   &gt;&gt;&gt; member @Char tm
--   True
--   </pre>
delete :: forall a. Typeable a => TMap -> TMap

-- | The union of two <a>TMap</a>s using a combining function.
unionWith :: (forall x. Typeable x => x -> x -> x) -> TMap -> TMap -> TMap

-- | The (left-biased) union of two <a>TMap</a>s. It prefers the first map
--   when duplicate keys are encountered, i.e. <tt><a>union</a> ==
--   <a>unionWith</a> const</tt>.
union :: TMap -> TMap -> TMap

-- | The intersection of two <a>TMap</a>s using a combining function.
--   
--   <pre>
--   O(n + m)
--   </pre>
intersectionWith :: (forall x. Typeable x => x -> x -> x) -> TMap -> TMap -> TMap

-- | The intersection of two <a>TMap</a>s. It keeps all values from the
--   first map whose keys are present in the second.
--   
--   <pre>
--   O(n + m)
--   </pre>
intersection :: TMap -> TMap -> TMap

-- | Map a function over the values.
map :: (forall a. Typeable a => a -> a) -> TMap -> TMap

-- | Update a value with the result of the provided function.
adjust :: Typeable a => (a -> a) -> TMap -> TMap

-- | Updates a value at a specific key, whether or not it exists. This can
--   be used to insert, delete, or update a value of a given type in the
--   map.
alter :: Typeable a => (Maybe a -> Maybe a) -> TMap -> TMap

-- | Lookup a value of the given type in a <a>TMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; x = lookup $ insert (11 :: Int) empty
--   
--   &gt;&gt;&gt; x :: Maybe Int
--   Just 11
--   
--   &gt;&gt;&gt; x :: Maybe ()
--   Nothing
--   </pre>
lookup :: forall a. Typeable a => TMap -> Maybe a

-- | Check if a value of the given type is present in a <a>TMap</a>.
--   
--   <pre>
--   &gt;&gt;&gt; member @Char $ one 'a'
--   True
--   
--   &gt;&gt;&gt; member @Bool $ one 'a'
--   False
--   </pre>
member :: forall a. Typeable a => TMap -> Bool

-- | Get the amount of elements in a <a>TMap</a>.
size :: TMap -> Int

-- | Returns the list of <a>SomeTypeRep</a>s from keys.
keys :: TMap -> [SomeTypeRep]

-- | Return the list of keys by wrapping them with a user-provided
--   function.
keysWith :: (forall a. TypeRep a -> r) -> TMap -> [r]

-- | Return the list of key-value pairs by wrapping them with a
--   user-provided function.
toListWith :: (forall a. Typeable a => a -> r) -> TMap -> [r]
