-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Shelley ledger integration in the Ouroboros consensus layer
--   
--   Shelley ledger integration in the Ouroboros consensus layer
@package ouroboros-consensus-shelley
@version 0.1.0.1


-- | Module defining the crypto primitives used throughout Shelley based
--   eras.
module Ouroboros.Consensus.Shelley.Crypto

-- | The same crypto used on the net
data StandardCrypto

module Ouroboros.Consensus.Shelley.Eras
type AllegraEra = ShelleyMAEra 'Allegra

-- | The Alonzo era
data AlonzoEra c

-- | The Babbage era
data BabbageEra c
type MaryEra c = ShelleyMAEra 'Mary c
data ShelleyEra c

-- | The Allegra era with standard crypto
type StandardAllegra = AllegraEra StandardCrypto

-- | The Alonzo era with standard crypto
type StandardAlonzo = AlonzoEra StandardCrypto

-- | The Babbage era with standard crypto
type StandardBabbage = BabbageEra StandardCrypto

-- | The Mary era with standard crypto
type StandardMary = MaryEra StandardCrypto

-- | The Shelley era with standard crypto
type StandardShelley = ShelleyEra StandardCrypto

-- | The ledger already defines <a>ShelleyBasedEra</a> as <i>the</i>
--   top-level constraint on an era, however, consensus often needs some
--   more functionality than the ledger currently provides.
--   
--   Either the functionality shouldn't or can't live in the ledger, in
--   which case it can be part and remain part of <a>ShelleyBasedEra</a>.
--   Or, the functionality <i>should</i> live in the ledger, but hasn't yet
--   been added to the ledger, or it hasn't yet been propagated to this
--   repository, in which case it can be added to this class until that is
--   the case.
--   
--   By having the same name as the class defined in ledger, we can, if
--   this class becomes redundant, switch to the ledger-defined one without
--   having to update all the code using it. We can just export the right
--   one from this module.
--   
--   TODO Currently we include some constraints on the update state which
--   are needed to determine the hard fork point. In the future this should
--   be replaced with an appropriate API - see
--   <a>https://github.com/input-output-hk/ouroboros-network/issues/2890</a>
class (ShelleyBasedEra era, GetLedgerView era, State (EraRule "PPUP" era) ~ PPUPState era, Default (State (EraRule "PPUP" era)), HasField "_maxBBSize" (PParams era) Natural, HasField "_maxBHSize" (PParams era) Natural, HasField "_maxTxSize" (PParams era) Natural, HasField "_a0" (PParams era) NonNegativeInterval, HasField "_nOpt" (PParams era) Natural, HasField "_rho" (PParams era) UnitInterval, HasField "_tau" (PParams era) UnitInterval, ValidateScript era, FromCBOR (PParams era), ToCBOR (PParams era), HasField "_protocolVersion" (PParamsDelta era) (StrictMaybe ProtVer), FromCBOR (PParamsDelta era), AdditionalGenesisConfig era ~ TranslationContext era, ToCBORGroup (TxSeq era), NoThunks (TranslationContext era), FromCBOR (Annotator (Witnesses era)), ToCBOR (Witnesses era), Eq (TxSeq era), Show (TxSeq era), FromCBOR (Annotator (TxSeq era))) => ShelleyBasedEra era

-- | Return the name of the Shelley-based era, e.g.,
--   <tt><a>Shelley</a></tt>, <tt><a>Allegra</a></tt>, etc.
shelleyBasedEraName :: ShelleyBasedEra era => proxy era -> Text
applyShelleyBasedTx :: ShelleyBasedEra era => Globals -> LedgerEnv era -> MempoolState era -> WhetherToIntervene -> Tx era -> Except (ApplyTxError era) (MempoolState era, Validated (Tx era))

-- | Wrapper for partially applying the <tt>Tx</tt> type family
--   
--   For generality, Consensus uses that type family as eg the index of
--   <a>TranslateEra</a>. We thus need to partially apply it.
--   
--   <tt>cardano-ledger-specs</tt> also declares such a newtype, but
--   currently it's only defined in the Alonzo translation module, which
--   seems somewhat inappropriate to use for previous eras. Also, we use a
--   <tt>Wrap</tt> prefix in Consensus. Hence this minor mediating
--   definition. TODO I'm not even fully persuading myself with this
--   justification.
newtype WrapTx era
WrapTx :: Tx era -> WrapTx era
[unwrapTx] :: WrapTx era -> Tx era

-- | The <a>Crypto</a> type family conflicts with the <a>Crypto</a> class.
--   To avoid having to import one or both of them qualified, define
--   <a>EraCrypto</a> as an alias of the former: /return the crypto used by
--   this era/.
type EraCrypto era = Crypto era

-- | The same crypto used on the net
data StandardCrypto

-- | The ledger responded with Alonzo errors we were not expecting
data UnexpectedAlonzoLedgerErrors
instance GHC.Exception.Type.Exception Ouroboros.Consensus.Shelley.Eras.UnexpectedAlonzoLedgerErrors
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Eras.UnexpectedAlonzoLedgerErrors
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Allegra.AllegraEra c) => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Allegra.AllegraEra c) Ouroboros.Consensus.Shelley.Eras.WrapTx
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Mary.MaryEra c) => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Mary.MaryEra c) Ouroboros.Consensus.Shelley.Eras.WrapTx
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Alonzo.AlonzoEra c) => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Alonzo.AlonzoEra c) Ouroboros.Consensus.Shelley.Eras.WrapTx
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Babbage.BabbageEra c) => Cardano.Ledger.Era.TranslateEra (Cardano.Ledger.Babbage.BabbageEra c) Ouroboros.Consensus.Shelley.Eras.WrapTx
instance Ouroboros.Consensus.Shelley.Eras.SupportsTwoPhaseValidation (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Ouroboros.Consensus.Shelley.Eras.SupportsTwoPhaseValidation (Cardano.Ledger.Babbage.BabbageEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Ledger.Keys.DSignable c (Cardano.Ledger.Keys.Hash c Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Shelley.ShelleyEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Ledger.Keys.DSignable c (Cardano.Ledger.Keys.Hash c Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Allegra.AllegraEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Ledger.Keys.DSignable c (Cardano.Ledger.Keys.Hash c Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Mary.MaryEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Ledger.Keys.DSignable c (Cardano.Ledger.Keys.Hash c Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Alonzo.AlonzoEra c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Babbage.BabbageEra c)


-- | Commonality between multiple protocols.
--   
--   Everything in this module is indexed on the protocol (or the crypto),
--   rather than on the block type. This allows it to be imported in
--   <tt>Ouroboros.Consensus.Shelley.Ledger.Block</tt>.
module Ouroboros.Consensus.Shelley.Protocol.Abstract
type family ProtoCrypto proto :: Type

-- | Indicates that the header (determined by the protocol) supports "
--   Envelope " functionality. Envelope functionality refers to the minimal
--   functionality required to construct a chain.
class (Eq (EnvelopeCheckError proto), NoThunks (EnvelopeCheckError proto), Show (EnvelopeCheckError proto)) => ProtocolHeaderSupportsEnvelope proto where {
    type family EnvelopeCheckError proto :: Type;
}
pHeaderHash :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> ShelleyHash (ProtoCrypto proto)
pHeaderPrevHash :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> PrevHash (ProtoCrypto proto)
pHeaderBodyHash :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> Hash (ProtoCrypto proto) EraIndependentBlockBody
pHeaderSlot :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> SlotNo
pHeaderBlock :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> BlockNo
pHeaderSize :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> Natural
pHeaderBlockSize :: ProtocolHeaderSupportsEnvelope proto => ShelleyProtocolHeader proto -> Natural

-- | Carry out any protocol-specific envelope checks. For example, this
--   might check things like maximum header size.
envelopeChecks :: ProtocolHeaderSupportsEnvelope proto => ConsensusConfig proto -> Ticked (LedgerView proto) -> ShelleyProtocolHeader proto -> Except (EnvelopeCheckError proto) ()

-- | <a>ProtocolHeaderSupportsKES</a> describes functionality common to
--   protocols using key evolving signature schemes. This includes
--   verifying the header integrity (e.g. validating the KES signature), as
--   well as constructing the header (made specific to KES-using protocols
--   through the need to handle the hot key).
class ProtocolHeaderSupportsKES proto

-- | Extract the "slots per KES period" value from the protocol config.
--   
--   Note that we do not require <a>ConsensusConfig</a> in
--   <a>verifyHeaderIntegrity</a> since that function is also invoked with
--   <tt>StorageConfig</tt>.
configSlotsPerKESPeriod :: ProtocolHeaderSupportsKES proto => ConsensusConfig proto -> Word64

-- | Verify that the signature on a header is correct and valid.
verifyHeaderIntegrity :: ProtocolHeaderSupportsKES proto => Word64 -> ShelleyProtocolHeader proto -> Bool
mkHeader :: forall crypto m. (ProtocolHeaderSupportsKES proto, Crypto crypto, Monad m, crypto ~ ProtoCrypto proto) => HotKey crypto m -> CanBeLeader proto -> IsLeader proto -> SlotNo -> BlockNo -> PrevHash crypto -> Hash crypto EraIndependentBlockBody -> Int -> ProtVer -> m (ShelleyProtocolHeader proto)

-- | Indicates that the protocol header supports the Shelley ledger. We may
--   need to generalise this if, in the future, the ledger requires
--   different things from the protocol.
class ProtocolHeaderSupportsLedger proto
mkHeaderView :: ProtocolHeaderSupportsLedger proto => ShelleyProtocolHeader proto -> BHeaderView (ProtoCrypto proto)

-- | ProtocolHeaderSupportsProtocol` provides support for the concrete
--   block header to support the <a>ConsensusProtocol</a> itself.
class ProtocolHeaderSupportsProtocol proto where {
    type family CannotForgeError proto :: Type;
}
protocolHeaderView :: ProtocolHeaderSupportsProtocol proto => ShelleyProtocolHeader proto -> ValidateView proto
pHeaderIssuer :: ProtocolHeaderSupportsProtocol proto => ShelleyProtocolHeader proto -> VKey 'BlockIssuer (ProtoCrypto proto)
pHeaderIssueNo :: ProtocolHeaderSupportsProtocol proto => ShelleyProtocolHeader proto -> Word64

-- | VRF value in the header, used to choose between otherwise equally
--   preferable chains.
pHeaderVRFValue :: ProtocolHeaderSupportsProtocol proto => ShelleyProtocolHeader proto -> OutputVRF (VRF (ProtoCrypto proto))
newtype ShelleyHash crypto
ShelleyHash :: Hash crypto EraIndependentBlockHeader -> ShelleyHash crypto
[unShelleyHash] :: ShelleyHash crypto -> Hash crypto EraIndependentBlockHeader
class (ConsensusProtocol proto, Typeable (ShelleyProtocolHeader proto), ProtocolHeaderSupportsEnvelope proto, ProtocolHeaderSupportsKES proto, ProtocolHeaderSupportsProtocol proto, ProtocolHeaderSupportsLedger proto, Serialise (ChainDepState proto), SignedHeader (ShelleyProtocolHeader proto)) => ShelleyProtocol proto

-- | Shelley header, determined by the associated protocol.
type family ShelleyProtocolHeader proto = (sh :: Type) | sh -> proto
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance GHC.Classes.Ord (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Codec.Serialise.Class.Serialise (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)
instance Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyHash crypto)

module Ouroboros.Consensus.Shelley.Ledger.Block
class HasHeader Header blk => GetHeader blk
getHeader :: GetHeader blk => blk -> Header blk

-- | Check whether the header is the header of the block.
--   
--   For example, by checking whether the hash of the body stored in the
--   header matches that of the block.
blockMatchesHeader :: GetHeader blk => Header blk -> blk -> Bool

-- | When the given header is the header of an Epoch Boundary Block,
--   returns its epoch number.
headerIsEBB :: GetHeader blk => Header blk -> Maybe EpochNo
data family Header blk

-- | Context identifying what kind of block we have
--   
--   In almost all places we will use <a>NestedCtxt</a> rather than
--   <a>NestedCtxt_</a>.
data family NestedCtxt_ blk :: Type -> Type -> Type -> Type

-- | The ledger already defines <a>ShelleyBasedEra</a> as <i>the</i>
--   top-level constraint on an era, however, consensus often needs some
--   more functionality than the ledger currently provides.
--   
--   Either the functionality shouldn't or can't live in the ledger, in
--   which case it can be part and remain part of <a>ShelleyBasedEra</a>.
--   Or, the functionality <i>should</i> live in the ledger, but hasn't yet
--   been added to the ledger, or it hasn't yet been propagated to this
--   repository, in which case it can be added to this class until that is
--   the case.
--   
--   By having the same name as the class defined in ledger, we can, if
--   this class becomes redundant, switch to the ledger-defined one without
--   having to update all the code using it. We can just export the right
--   one from this module.
--   
--   TODO Currently we include some constraints on the update state which
--   are needed to determine the hard fork point. In the future this should
--   be replaced with an appropriate API - see
--   <a>https://github.com/input-output-hk/ouroboros-network/issues/2890</a>
class (ShelleyBasedEra era, GetLedgerView era, State (EraRule "PPUP" era) ~ PPUPState era, Default (State (EraRule "PPUP" era)), HasField "_maxBBSize" (PParams era) Natural, HasField "_maxBHSize" (PParams era) Natural, HasField "_maxTxSize" (PParams era) Natural, HasField "_a0" (PParams era) NonNegativeInterval, HasField "_nOpt" (PParams era) Natural, HasField "_rho" (PParams era) UnitInterval, HasField "_tau" (PParams era) UnitInterval, ValidateScript era, FromCBOR (PParams era), ToCBOR (PParams era), HasField "_protocolVersion" (PParamsDelta era) (StrictMaybe ProtVer), FromCBOR (PParamsDelta era), AdditionalGenesisConfig era ~ TranslationContext era, ToCBORGroup (TxSeq era), NoThunks (TranslationContext era), FromCBOR (Annotator (Witnesses era)), ToCBOR (Witnesses era), Eq (TxSeq era), Show (TxSeq era), FromCBOR (Annotator (TxSeq era))) => ShelleyBasedEra era

-- | Shelley-based block type.
--   
--   This block is parametrised over both the (ledger) era and the
--   protocol.
data ShelleyBlock proto era
ShelleyBlock :: !Block (ShelleyProtocolHeader proto) era -> !ShelleyHash (ProtoCrypto proto) -> ShelleyBlock proto era
[shelleyBlockRaw] :: ShelleyBlock proto era -> !Block (ShelleyProtocolHeader proto) era
[shelleyBlockHeaderHash] :: ShelleyBlock proto era -> !ShelleyHash (ProtoCrypto proto)
newtype ShelleyHash crypto
ShelleyHash :: Hash crypto EraIndependentBlockHeader -> ShelleyHash crypto
[unShelleyHash] :: ShelleyHash crypto -> Hash crypto EraIndependentBlockHeader
class (ShelleyBasedEra era, ShelleyProtocol proto, Eq (ShelleyProtocolHeader proto), Show (ShelleyProtocolHeader proto), NoThunks (ShelleyProtocolHeader proto), ToCBOR (ShelleyProtocolHeader proto), FromCBOR (Annotator (ShelleyProtocolHeader proto)), Show (CannotForgeError proto), SelectView proto ~ PraosChainSelectView (EraCrypto era), SignedHeader (ShelleyProtocolHeader proto), DecodeDisk (ShelleyBlock proto era) (ChainDepState proto), EncodeDisk (ShelleyBlock proto era) (ChainDepState proto), EraCrypto era ~ ProtoCrypto proto, HasPartialConsensusConfig proto) => ShelleyCompatible proto era
mkShelleyBlock :: ShelleyCompatible proto era => Block (ShelleyProtocolHeader proto) era -> ShelleyBlock proto era
mkShelleyHeader :: ShelleyCompatible proto era => ShelleyProtocolHeader proto -> Header (ShelleyBlock proto era)
decodeShelleyBlock :: ShelleyCompatible proto era => Decoder s (ByteString -> ShelleyBlock proto era)
decodeShelleyHeader :: ShelleyCompatible proto era => Decoder s (ByteString -> Header (ShelleyBlock proto era))
encodeShelleyBlock :: ShelleyCompatible proto era => ShelleyBlock proto era -> Encoding
encodeShelleyHeader :: ShelleyCompatible proto era => Header (ShelleyBlock proto era) -> Encoding
shelleyBinaryBlockInfo :: ShelleyCompatible proto era => ShelleyBlock proto era -> BinaryBlockInfo

-- | From <tt>cardano-ledger-specs</tt> to <tt>ouroboros-consensus</tt>
fromShelleyPrevHash :: EraCrypto era ~ ProtoCrypto proto => PrevHash (EraCrypto era) -> ChainHash (ShelleyBlock proto era)

-- | From <tt>ouroboros-consensus</tt> to <tt>cardano-ledger-specs</tt>
toShelleyPrevHash :: EraCrypto era ~ ProtoCrypto proto => ChainHash (Header (ShelleyBlock proto era)) -> PrevHash (EraCrypto era)
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => GHC.Show.Show (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => GHC.Classes.Eq (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Show.Show (Ouroboros.Consensus.Block.NestedContent.NestedCtxt_ (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) f a)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Block.Abstract.ConvertRawHash (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Block.Abstract.GetHeader (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Network.Block.HasHeader (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Network.Block.HasHeader (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Block.Abstract.GetPrevHash (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Network.Block.StandardHash (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.HeaderValidation.HasAnnTip (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Util.DepPair.TrivialDependency (Ouroboros.Consensus.Block.NestedContent.NestedCtxt_ (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) f)
instance Ouroboros.Consensus.Util.DepPair.SameDepIndex (Ouroboros.Consensus.Block.NestedContent.NestedCtxt_ (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) f)
instance Ouroboros.Consensus.Block.NestedContent.HasNestedContent f (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion
data ShelleyNodeToClientVersion
ShelleyNodeToClientVersion1 :: ShelleyNodeToClientVersion

-- | New queries introduced
ShelleyNodeToClientVersion2 :: ShelleyNodeToClientVersion

-- | New query introduced
ShelleyNodeToClientVersion3 :: ShelleyNodeToClientVersion

-- | New queries introduced
ShelleyNodeToClientVersion4 :: ShelleyNodeToClientVersion

-- | New queries introduced: GetRewardInfoPools
ShelleyNodeToClientVersion5 :: ShelleyNodeToClientVersion
data ShelleyNodeToNodeVersion
ShelleyNodeToNodeVersion1 :: ShelleyNodeToNodeVersion
instance GHC.Enum.Bounded Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToNodeVersion
instance GHC.Enum.Enum Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToNodeVersion
instance GHC.Classes.Ord Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToNodeVersion
instance GHC.Classes.Eq Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToNodeVersion
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToNodeVersion
instance GHC.Enum.Bounded Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToClientVersion
instance GHC.Enum.Enum Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToClientVersion
instance GHC.Classes.Ord Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToClientVersion
instance GHC.Classes.Eq Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToClientVersion
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Ledger.NetworkProtocolVersion.ShelleyNodeToClientVersion
instance Ouroboros.Consensus.Node.NetworkProtocolVersion.HasNetworkProtocolVersion (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Node.NetworkProtocolVersion.SupportedNetworkProtocolVersion (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Ledger.Integrity

-- | Verifies whether the block is not corrupted by checking its signature
--   and witnesses.
verifyBlockIntegrity :: ShelleyCompatible proto era => Word64 -> ShelleyBlock proto era -> Bool

-- | Verify that the signature on a header is correct and valid.
verifyHeaderIntegrity :: ProtocolHeaderSupportsKES proto => Word64 -> ShelleyProtocolHeader proto -> Bool

module Ouroboros.Consensus.Shelley.Ledger.Config

-- | Static configuration required to work with this type of blocks
data family BlockConfig blk

-- | Static configuration required for serialisation and deserialisation of
--   types pertaining to this type of block.
--   
--   Data family instead of type family to get better type inference.
data family CodecConfig blk

-- | Config needed for the <a>NodeInitStorage</a> class. Defined here to
--   avoid circular dependencies.
data family StorageConfig blk

-- | Compacts the given <a>ShelleyGenesis</a>.
compactGenesis :: ShelleyGenesis era -> CompactGenesis era
getCompactGenesis :: CompactGenesis era -> ShelleyGenesis era
mkShelleyBlockConfig :: ShelleyBasedEra era => ProtVer -> ShelleyGenesis era -> [VKey 'BlockIssuer (EraCrypto era)] -> BlockConfig (ShelleyBlock proto era)

-- | Compact variant of <a>ShelleyGenesis</a> with some fields erased that
--   are only used on start-up and that should not be kept in memory
--   forever.
--   
--   Concretely:
--   
--   <ul>
--   <li>The <tt>sgInitialFunds</tt> field is erased. It is only used to
--   set up the initial UTxO in tests and testnets.</li>
--   <li>The <tt>sgStaking</tt> field is erased. It is only used to
--   register initial stake pools in tests and benchmarks.</li>
--   </ul>
data CompactGenesis era
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.BlockConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.CodecConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.CodecConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.StorageConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.StorageConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis era)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis era)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis era)
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Show.Show (Ouroboros.Consensus.Block.Abstract.BlockConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.BlockConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.Ledger.Config.CompactGenesis era)

module Ouroboros.Consensus.Shelley.Ledger.Protocol
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Block.SupportsProtocol.BlockSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Protocol.Signed.SignedHeader (Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyProtocolHeader proto) => Ouroboros.Consensus.Protocol.Signed.SignedHeader (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))

module Ouroboros.Consensus.Shelley.Ledger.Ledger

-- | Ledger state associated with a block
data family LedgerState blk

-- | The ledger already defines <a>ShelleyBasedEra</a> as <i>the</i>
--   top-level constraint on an era, however, consensus often needs some
--   more functionality than the ledger currently provides.
--   
--   Either the functionality shouldn't or can't live in the ledger, in
--   which case it can be part and remain part of <a>ShelleyBasedEra</a>.
--   Or, the functionality <i>should</i> live in the ledger, but hasn't yet
--   been added to the ledger, or it hasn't yet been propagated to this
--   repository, in which case it can be added to this class until that is
--   the case.
--   
--   By having the same name as the class defined in ledger, we can, if
--   this class becomes redundant, switch to the ledger-defined one without
--   having to update all the code using it. We can just export the right
--   one from this module.
--   
--   TODO Currently we include some constraints on the update state which
--   are needed to determine the hard fork point. In the future this should
--   be replaced with an appropriate API - see
--   <a>https://github.com/input-output-hk/ouroboros-network/issues/2890</a>
class (ShelleyBasedEra era, GetLedgerView era, State (EraRule "PPUP" era) ~ PPUPState era, Default (State (EraRule "PPUP" era)), HasField "_maxBBSize" (PParams era) Natural, HasField "_maxBHSize" (PParams era) Natural, HasField "_maxTxSize" (PParams era) Natural, HasField "_a0" (PParams era) NonNegativeInterval, HasField "_nOpt" (PParams era) Natural, HasField "_rho" (PParams era) UnitInterval, HasField "_tau" (PParams era) UnitInterval, ValidateScript era, FromCBOR (PParams era), ToCBOR (PParams era), HasField "_protocolVersion" (PParamsDelta era) (StrictMaybe ProtVer), FromCBOR (PParamsDelta era), AdditionalGenesisConfig era ~ TranslationContext era, ToCBORGroup (TxSeq era), NoThunks (TranslationContext era), FromCBOR (Annotator (Witnesses era)), ToCBOR (Witnesses era), Eq (TxSeq era), Show (TxSeq era), FromCBOR (Annotator (TxSeq era))) => ShelleyBasedEra era
newtype ShelleyLedgerError era
BBodyError :: BlockTransitionError era -> ShelleyLedgerError era
data ShelleyTip proto era
ShelleyTip :: !SlotNo -> !BlockNo -> !HeaderHash (ShelleyBlock proto era) -> ShelleyTip proto era
[shelleyTipSlotNo] :: ShelleyTip proto era -> !SlotNo
[shelleyTipBlockNo] :: ShelleyTip proto era -> !BlockNo
[shelleyTipHash] :: ShelleyTip proto era -> !HeaderHash (ShelleyBlock proto era)

-- | Information required to determine the hard fork point from Shelley to
--   the next ledger
newtype ShelleyTransition
ShelleyTransitionInfo :: Word32 -> ShelleyTransition

-- | The number of blocks in this epoch past the voting deadline
--   
--   We record this to make sure that we can tell the HFC about hard forks
--   if and only if we are certain:
--   
--   <ol>
--   <li>Blocks that came in within an epoch after the 4k/f voting deadline
--   are not relevant (10k<i>f - 2 * 3k</i>f).</li>
--   <li>Since there are slots between blocks, we are probably only sure
--   that there will be no more relevant block when we have seen the first
--   block after the deadline.</li>
--   <li>If we count how many blocks we have seen post deadline, and we
--   have reached k of them, we know that that last pre-deadline block
--   won't be rolled back anymore.</li>
--   <li>At this point we can look at the ledger state and see which
--   proposals we accepted in the voting period, if any, and notify the HFC
--   is one of them indicates a transition.</li>
--   </ol>
[shelleyAfterVoting] :: ShelleyTransition -> Word32

-- | " Ticked " piece of state (<tt>LedgerState</tt>, <tt>LedgerView</tt>,
--   <tt>ChainIndepState</tt>)
--   
--   Ticking refers to the passage of time (the ticking of the clock). When
--   a piece of state is marked as ticked, it means that time-related
--   changes have been applied to the state (or forecast).
--   
--   Some examples of time related changes:
--   
--   <ul>
--   <li>Scheduled delegations might have been applied in Byron</li>
--   <li>New leader schedule computed for Shelley</li>
--   <li>Transition from Byron to Shelley activated in the hard fork
--   combinator.</li>
--   <li>Nonces switched out at the start of a new epoch.</li>
--   </ul>
data family Ticked st
castShelleyTip :: HeaderHash (ShelleyBlock proto era) ~ HeaderHash (ShelleyBlock proto' era') => ShelleyTip proto era -> ShelleyTip proto' era'
shelleyLedgerTipPoint :: LedgerState (ShelleyBlock proto era) -> Point (ShelleyBlock proto era)
shelleyTipToPoint :: WithOrigin (ShelleyTip proto era) -> Point (ShelleyBlock proto era)
data ShelleyLedgerConfig era
ShelleyLedgerConfig :: !CompactGenesis era -> !Globals -> !TranslationContext era -> ShelleyLedgerConfig era
[shelleyLedgerCompactGenesis] :: ShelleyLedgerConfig era -> !CompactGenesis era

-- | Derived from <a>shelleyLedgerGenesis</a> but we store a cached version
--   because it used very often.
[shelleyLedgerGlobals] :: ShelleyLedgerConfig era -> !Globals
[shelleyLedgerTranslationContext] :: ShelleyLedgerConfig era -> !TranslationContext era
mkShelleyLedgerConfig :: ShelleyGenesis era -> TranslationContext era -> EpochInfo (Except PastHorizonException) -> MaxMajorProtVer -> ShelleyLedgerConfig era
shelleyEraParams :: ShelleyGenesis era -> EraParams

-- | Separate variant of <a>shelleyEraParams</a> to be used for a
--   Shelley-only chain.
shelleyEraParamsNeverHardForks :: ShelleyGenesis era -> EraParams
shelleyLedgerGenesis :: ShelleyLedgerConfig era -> ShelleyGenesis era

-- | All events emitted by the Shelley ledger API
data ShelleyLedgerEvent era

-- | An event emitted when (re)applying a block
ShelleyLedgerEventBBODY :: Event (EraRule "BBODY" era) -> ShelleyLedgerEvent era

-- | An event emitted during the chain tick
ShelleyLedgerEventTICK :: Event (EraRule "TICK" era) -> ShelleyLedgerEvent era
data ShelleyReapplyException
ShelleyReapplyException :: BlockTransitionError era -> ShelleyReapplyException
getPParams :: NewEpochState era -> PParams era
decodeShelleyAnnTip :: ShelleyCompatible proto era => Decoder s (AnnTip (ShelleyBlock proto era))
decodeShelleyLedgerState :: forall era proto s. ShelleyCompatible proto era => Decoder s (LedgerState (ShelleyBlock proto era))
encodeShelleyAnnTip :: ShelleyCompatible proto era => AnnTip (ShelleyBlock proto era) -> Encoding
encodeShelleyHeaderState :: ShelleyCompatible proto era => HeaderState (ShelleyBlock proto era) -> Encoding
encodeShelleyLedgerState :: ShelleyCompatible proto era => LedgerState (ShelleyBlock proto era) -> Encoding
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerError era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerConfig era)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerConfig era)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto era)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto era)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto era)
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto era)
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTransition
instance GHC.Generics.Generic Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTransition
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTransition
instance GHC.Classes.Eq Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTransition
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Generics.Generic (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerError era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerError era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Show.Show (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Ledger.Abstract.ApplyBlock (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyReapplyException
instance GHC.Exception.Type.Exception Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyReapplyException
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Ledger.Basics.IsLedger (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyLedgerError era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Ledger.Abstract.UpdateLedger (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Ledger.Basics.GetTip (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Ledger.Basics.GetTip (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.HardFork.Abstract.HasHardForkHistory (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Ledger.CommonProtocolParams.CommonProtocolParams (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.HeaderValidation.BasicEnvelopeValidation (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.HeaderValidation.ValidateEnvelope (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Ledger.Query

-- | Different queries supported by the ledger, indexed by the result type.
data family BlockQuery blk :: Type -> Type

-- | <i>Deprecated: Use <a>GetUTxOWhole</a></i>
pattern GetUTxO :: BlockQuery (ShelleyBlock proto era) (UTxO era)

-- | <i>Deprecated: Use <a>GetUTxOByAddress</a></i>
pattern GetFilteredUTxO :: Set (Addr (EraCrypto era)) -> BlockQuery (ShelleyBlock proto era) (UTxO era)
newtype NonMyopicMemberRewards c
NonMyopicMemberRewards :: Map (Either Coin (Credential 'Staking c)) (Map (KeyHash 'StakePool c) Coin) -> NonMyopicMemberRewards c
[unNonMyopicMemberRewards] :: NonMyopicMemberRewards c -> Map (Either Coin (Credential 'Staking c)) (Map (KeyHash 'StakePool c) Coin)

-- | Is the given query supported by the given
--   <a>ShelleyNodeToClientVersion</a>?
querySupportedVersion :: BlockQuery (ShelleyBlock proto era) result -> ShelleyNodeToClientVersion -> Bool
decodeShelleyQuery :: ShelleyBasedEra era => Decoder s (SomeSecond BlockQuery (ShelleyBlock proto era))
decodeShelleyResult :: ShelleyCompatible proto era => BlockQuery (ShelleyBlock proto era) result -> forall s. Decoder s result
encodeShelleyQuery :: ShelleyBasedEra era => BlockQuery (ShelleyBlock proto era) result -> Encoding
encodeShelleyResult :: ShelleyCompatible proto era => BlockQuery (ShelleyBlock proto era) result -> result -> Encoding
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Query.NonMyopicMemberRewards c)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Query.NonMyopicMemberRewards c)
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) result)
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) result)
instance Cardano.Ledger.Crypto.Crypto c => Codec.Serialise.Class.Serialise (Ouroboros.Consensus.Shelley.Ledger.Query.NonMyopicMemberRewards c)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Ledger.Query.QueryLedger (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Util.DepPair.SameDepIndex (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Network.Protocol.LocalStateQuery.Type.ShowQuery (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))

module Ouroboros.Consensus.Shelley.Ledger.PeerSelection
instance (c GHC.Types.~ Ouroboros.Consensus.Shelley.Eras.EraCrypto era) => Ouroboros.Consensus.Ledger.SupportsPeerSelection.LedgerSupportsPeerSelection (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)


-- | Shelley mempool integration
module Ouroboros.Consensus.Shelley.Ledger.Mempool

-- | Generalized transaction
--   
--   The mempool (and, accordingly, blocks) consist of "generalized
--   transactions"; this could be "proper" transactions (transferring
--   funds) but also other kinds of things such as update proposals,
--   delegations, etc.
data family GenTx blk
newtype ApplyTxError era
ApplyTxError :: [PredicateFailure (EraRule "LEDGER" era)] -> ApplyTxError era

-- | A generalized transaction, <a>GenTx</a>, identifier.
data family TxId tx

-- | " Validated " transaction or block
--   
--   The ledger defines how to validate transactions and blocks. It's
--   possible the type before and after validation may be distinct (eg
--   Alonzo transactions), which originally motivated this family.
--   
--   We also gain the related benefit that certain interface functions,
--   such as those that <i>reapply</i> blocks, can have a more precise type
--   now. TODO
--   
--   Similarly, the Node-to-Client mini protocols can explicitly indicate
--   that the client trusts the blocks from the local server, by having the
--   server send <a>Validated</a> blocks to the client. TODO
--   
--   Note that validation has different implications for a transaction than
--   for a block. In particular, a validated transaction can be " reapplied
--   " to different ledger states, whereas a validated block must only be "
--   reapplied " to the exact same ledger state (eg as part of rebuilding
--   from an on-disk ledger snapshot).
--   
--   Since the ledger defines validation, see the ledger details for
--   concrete examples of what determines the validity (wrt to a
--   <a>LedgerState</a>) of a transaction and/or block. Example properties
--   include: a transaction's claimed inputs exist and are still unspent, a
--   block carries a sufficient cryptographic signature, etc.
data family Validated x

-- | Add a unique top element to a lattice.
--   
--   TODO This should be relocated to `cardano-base:Data.Measure'.
data WithTop a
NotTop :: a -> WithTop a
Top :: WithTop a

-- | <a>txInBlockSize</a> is used to estimate how many transactions we can
--   grab from the Mempool to put into the block we are going to forge
--   without exceeding the maximum block body size according to the ledger.
--   If we exceed that limit, we will have forged a block that is invalid
--   according to the ledger. We ourselves won't even adopt it, causing us
--   to lose our slot, something we must try to avoid.
--   
--   For this reason it is better to overestimate the size of a transaction
--   than to underestimate. The only downside is that we maybe could have
--   put one (or more?) transactions extra in that block.
--   
--   As the sum of the serialised transaction sizes is not equal to the
--   size of the serialised block body (<a>TxSeq</a>) consisting of those
--   transactions (see cardano-node#1545 for an example), we account for
--   some extra overhead per transaction as a safety margin.
--   
--   Also see <a>perTxOverhead</a>.
fixedBlockBodyOverhead :: Num a => a
mkShelleyTx :: forall era proto. ShelleyBasedEra era => Tx era -> GenTx (ShelleyBlock proto era)
mkShelleyValidatedTx :: forall era proto. ShelleyBasedEra era => Validated (Tx era) -> Validated (GenTx (ShelleyBlock proto era))

-- | See <a>fixedBlockBodyOverhead</a>.
perTxOverhead :: Num a => a
data AlonzoMeasure
AlonzoMeasure :: !ByteSize -> !ExUnits' (WithTop Natural) -> AlonzoMeasure
[byteSize] :: AlonzoMeasure -> !ByteSize
[exUnits] :: AlonzoMeasure -> !ExUnits' (WithTop Natural)
fromExUnits :: ExUnits -> ExUnits' (WithTop Natural)
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance GHC.Classes.Ord (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance Data.Measure.Class.Measure Ouroboros.Consensus.Shelley.Ledger.Mempool.AlonzoMeasure
instance Data.Measure.Class.BoundedMeasure Ouroboros.Consensus.Shelley.Ledger.Mempool.AlonzoMeasure
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Ledger.Mempool.AlonzoMeasure
instance GHC.Generics.Generic Ouroboros.Consensus.Shelley.Ledger.Mempool.AlonzoMeasure
instance GHC.Classes.Eq Ouroboros.Consensus.Shelley.Ledger.Mempool.AlonzoMeasure
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Classes.Eq (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Show.Show (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance (Cardano.Ledger.Crypto.Crypto (Ouroboros.Consensus.Shelley.Eras.EraCrypto era), Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance (Cardano.Ledger.Crypto.Crypto (Ouroboros.Consensus.Shelley.Eras.EraCrypto era), Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Alonzo.AlonzoEra c) => Ouroboros.Consensus.Mempool.TxLimits.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Alonzo.AlonzoEra c))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Babbage.BabbageEra c) => Ouroboros.Consensus.Mempool.TxLimits.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Babbage.BabbageEra c))
instance GHC.Classes.Ord a => GHC.Classes.Ord (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance Data.Measure.Class.Measure a => Data.Measure.Class.Measure (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance Data.Measure.Class.Measure a => Data.Measure.Class.BoundedMeasure (Ouroboros.Consensus.Shelley.Ledger.Mempool.WithTop a)
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Data.Typeable.Internal.Typeable era => Ouroboros.Network.Util.ShowProxy.ShowProxy (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Ledger.SupportsMempool.LedgerSupportsMempool (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Ledger.SupportsMempool.HasTxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Ledger.SupportsMempool.HasTxs (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Binary.ToCBOR.ToCBOR (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Cardano.Binary.FromCBOR.FromCBOR (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => GHC.Show.Show (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Shelley.ShelleyEra c) => Ouroboros.Consensus.Mempool.TxLimits.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Shelley.ShelleyEra c))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Allegra.AllegraEra c) => Ouroboros.Consensus.Mempool.TxLimits.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Allegra.AllegraEra c))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible p (Cardano.Ledger.Mary.MaryEra c) => Ouroboros.Consensus.Mempool.TxLimits.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock p (Cardano.Ledger.Mary.MaryEra c))

module Ouroboros.Consensus.Shelley.Ledger.Inspect
data ProtocolUpdate era
ProtocolUpdate :: UpdateProposal era -> UpdateState (EraCrypto era) -> ProtocolUpdate era
[protocolUpdateProposal] :: ProtocolUpdate era -> UpdateProposal era
[protocolUpdateState] :: ProtocolUpdate era -> UpdateState (EraCrypto era)
data ShelleyLedgerUpdate era
ShelleyUpdatedProtocolUpdates :: [ProtocolUpdate era] -> ShelleyLedgerUpdate era

-- | Update proposal
--   
--   As in Byron, a proposal is a partial map from parameters to their
--   values.
data UpdateProposal era
UpdateProposal :: PParamsDelta era -> Maybe ProtVer -> EpochNo -> UpdateProposal era

-- | The protocol parameters changed by this update proposal
--   
--   An update is <i>identified</i> by how it updates the protocol
--   parameters.
[proposalParams] :: UpdateProposal era -> PParamsDelta era

-- | New version (if changed by this proposal)
--   
--   The protocol version itself is also considered to be just another
--   parameter, and parameters can change <i>without</i> changing the
--   protocol version, although a convention <i>could</i> be established
--   that the protocol version must change if any of the parameters do; but
--   the specification itself does not mandate this.
--   
--   We record the version separately for the convenience of the HFC.
[proposalVersion] :: UpdateProposal era -> Maybe ProtVer

-- | The <a>EpochNo</a> the proposal becomes active in, if it is adopted
[proposalEpoch] :: UpdateProposal era -> EpochNo

-- | Proposal state
--   
--   The update mechanism in Shelley is simpler than it is in Byron. There
--   is no distinction between votes and proposals: to "vote" for a
--   proposal one merely submits the exact same proposal. There is also no
--   separate endorsement step. The procedure is as follows:
--   
--   <ol>
--   <li>During each epoch, a genesis key can submit (via its delegates)
--   zero, one, or many proposals; each submission overrides the previous
--   one.</li>
--   <li>"Voting" (submitting of proposals) ends <tt>2 *
--   stabilityWindow</tt> slots (i.e. <tt>6k/f</tt>) before the end of the
--   epoch. In other words, proposals for the upcoming epoch must be
--   submitted within the first <tt>4k/f</tt> slots of this one.</li>
--   <li>At the end of an epoch, if the majority of nodes (as determined by
--   the <tt>Quorum</tt> specification constant, which must be greater than
--   half the nodes) have most recently submitted the same exact proposal,
--   then it is adopted.</li>
--   <li>The next epoch is always started with a clean slate, proposals
--   from the previous epoch that didn't make it are discarded (except for
--   "future proposals" that are explicitly marked for future epochs).</li>
--   </ol>
data UpdateState c
UpdateState :: [KeyHash 'Genesis c] -> Bool -> UpdateState c

-- | The genesis delegates that voted for this proposal
[proposalVotes] :: UpdateState c -> [KeyHash 'Genesis c]

-- | Has this proposal reached sufficient votes to be adopted?
[proposalReachedQuorum] :: UpdateState c -> Bool
protocolUpdates :: forall era proto. ShelleyBasedEra era => ShelleyGenesis era -> LedgerState (ShelleyBlock proto era) -> [ProtocolUpdate era]
instance GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Inspect.UpdateState c)
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Inspect.UpdateState c)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParamsDelta era) => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Inspect.ProtocolUpdate era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era) => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Inspect.ProtocolUpdate era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParamsDelta era) => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Inspect.UpdateProposal era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era) => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Inspect.UpdateProposal era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParamsDelta era) => GHC.Classes.Eq (Ouroboros.Consensus.Shelley.Ledger.Inspect.ShelleyLedgerUpdate era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era) => GHC.Show.Show (Ouroboros.Consensus.Shelley.Ledger.Inspect.ShelleyLedgerUpdate era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era) => Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Shelley.Ledger.Inspect.ShelleyLedgerUpdate era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Ledger.Inspect.InspectLedger (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Ledger.Forge
forgeShelleyBlock :: forall m era proto. (ShelleyCompatible proto era, TxLimits (ShelleyBlock proto era), Monad m) => HotKey (EraCrypto era) m -> CanBeLeader proto -> TopLevelConfig (ShelleyBlock proto era) -> Overrides (ShelleyBlock proto era) -> BlockNo -> SlotNo -> TickedLedgerState (ShelleyBlock proto era) -> [Validated (GenTx (ShelleyBlock proto era))] -> IsLeader proto -> m (ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Ledger
newtype ApplyTxError era
ApplyTxError :: [PredicateFailure (EraRule "LEDGER" era)] -> ApplyTxError era

-- | Different queries supported by the ledger, indexed by the result type.
data family BlockQuery blk :: Type -> Type

-- | <i>Deprecated: Use <a>GetUTxOWhole</a></i>
pattern GetUTxO :: BlockQuery (ShelleyBlock proto era) (UTxO era)

-- | <i>Deprecated: Use <a>GetUTxOByAddress</a></i>
pattern GetFilteredUTxO :: Set (Addr (EraCrypto era)) -> BlockQuery (ShelleyBlock proto era) (UTxO era)

-- | Generalized transaction
--   
--   The mempool (and, accordingly, blocks) consist of "generalized
--   transactions"; this could be "proper" transactions (transferring
--   funds) but also other kinds of things such as update proposals,
--   delegations, etc.
data family GenTx blk

-- | A generalized transaction, <a>GenTx</a>, identifier.
data family TxId tx

-- | " Validated " transaction or block
--   
--   The ledger defines how to validate transactions and blocks. It's
--   possible the type before and after validation may be distinct (eg
--   Alonzo transactions), which originally motivated this family.
--   
--   We also gain the related benefit that certain interface functions,
--   such as those that <i>reapply</i> blocks, can have a more precise type
--   now. TODO
--   
--   Similarly, the Node-to-Client mini protocols can explicitly indicate
--   that the client trusts the blocks from the local server, by having the
--   server send <a>Validated</a> blocks to the client. TODO
--   
--   Note that validation has different implications for a transaction than
--   for a block. In particular, a validated transaction can be " reapplied
--   " to different ledger states, whereas a validated block must only be "
--   reapplied " to the exact same ledger state (eg as part of rebuilding
--   from an on-disk ledger snapshot).
--   
--   Since the ledger defines validation, see the ledger details for
--   concrete examples of what determines the validity (wrt to a
--   <a>LedgerState</a>) of a transaction and/or block. Example properties
--   include: a transaction's claimed inputs exist and are still unspent, a
--   block carries a sufficient cryptographic signature, etc.
data family Validated x

-- | Ledger state associated with a block
data family LedgerState blk

-- | Static configuration required to work with this type of blocks
data family BlockConfig blk

-- | Static configuration required for serialisation and deserialisation of
--   types pertaining to this type of block.
--   
--   Data family instead of type family to get better type inference.
data family CodecConfig blk

-- | Config needed for the <a>NodeInitStorage</a> class. Defined here to
--   avoid circular dependencies.
data family StorageConfig blk
data family Header blk
class HasHeader Header blk => GetHeader blk
getHeader :: GetHeader blk => blk -> Header blk

-- | Check whether the header is the header of the block.
--   
--   For example, by checking whether the hash of the body stored in the
--   header matches that of the block.
blockMatchesHeader :: GetHeader blk => Header blk -> blk -> Bool

-- | When the given header is the header of an Epoch Boundary Block,
--   returns its epoch number.
headerIsEBB :: GetHeader blk => Header blk -> Maybe EpochNo

-- | Context identifying what kind of block we have
--   
--   In almost all places we will use <a>NestedCtxt</a> rather than
--   <a>NestedCtxt_</a>.
data family NestedCtxt_ blk :: Type -> Type -> Type -> Type

-- | " Ticked " piece of state (<tt>LedgerState</tt>, <tt>LedgerView</tt>,
--   <tt>ChainIndepState</tt>)
--   
--   Ticking refers to the passage of time (the ticking of the clock). When
--   a piece of state is marked as ticked, it means that time-related
--   changes have been applied to the state (or forecast).
--   
--   Some examples of time related changes:
--   
--   <ul>
--   <li>Scheduled delegations might have been applied in Byron</li>
--   <li>New leader schedule computed for Shelley</li>
--   <li>Transition from Byron to Shelley activated in the hard fork
--   combinator.</li>
--   <li>Nonces switched out at the start of a new epoch.</li>
--   </ul>
data family Ticked st

-- | The ledger already defines <a>ShelleyBasedEra</a> as <i>the</i>
--   top-level constraint on an era, however, consensus often needs some
--   more functionality than the ledger currently provides.
--   
--   Either the functionality shouldn't or can't live in the ledger, in
--   which case it can be part and remain part of <a>ShelleyBasedEra</a>.
--   Or, the functionality <i>should</i> live in the ledger, but hasn't yet
--   been added to the ledger, or it hasn't yet been propagated to this
--   repository, in which case it can be added to this class until that is
--   the case.
--   
--   By having the same name as the class defined in ledger, we can, if
--   this class becomes redundant, switch to the ledger-defined one without
--   having to update all the code using it. We can just export the right
--   one from this module.
--   
--   TODO Currently we include some constraints on the update state which
--   are needed to determine the hard fork point. In the future this should
--   be replaced with an appropriate API - see
--   <a>https://github.com/input-output-hk/ouroboros-network/issues/2890</a>
class (ShelleyBasedEra era, GetLedgerView era, State (EraRule "PPUP" era) ~ PPUPState era, Default (State (EraRule "PPUP" era)), HasField "_maxBBSize" (PParams era) Natural, HasField "_maxBHSize" (PParams era) Natural, HasField "_maxTxSize" (PParams era) Natural, HasField "_a0" (PParams era) NonNegativeInterval, HasField "_nOpt" (PParams era) Natural, HasField "_rho" (PParams era) UnitInterval, HasField "_tau" (PParams era) UnitInterval, ValidateScript era, FromCBOR (PParams era), ToCBOR (PParams era), HasField "_protocolVersion" (PParamsDelta era) (StrictMaybe ProtVer), FromCBOR (PParamsDelta era), AdditionalGenesisConfig era ~ TranslationContext era, ToCBORGroup (TxSeq era), NoThunks (TranslationContext era), FromCBOR (Annotator (Witnesses era)), ToCBOR (Witnesses era), Eq (TxSeq era), Show (TxSeq era), FromCBOR (Annotator (TxSeq era))) => ShelleyBasedEra era

-- | Verify that the signature on a header is correct and valid.
verifyHeaderIntegrity :: ProtocolHeaderSupportsKES proto => Word64 -> ShelleyProtocolHeader proto -> Bool
newtype ShelleyHash crypto
ShelleyHash :: Hash crypto EraIndependentBlockHeader -> ShelleyHash crypto
[unShelleyHash] :: ShelleyHash crypto -> Hash crypto EraIndependentBlockHeader

-- | Shelley-based block type.
--   
--   This block is parametrised over both the (ledger) era and the
--   protocol.
data ShelleyBlock proto era
ShelleyBlock :: !Block (ShelleyProtocolHeader proto) era -> !ShelleyHash (ProtoCrypto proto) -> ShelleyBlock proto era
[shelleyBlockRaw] :: ShelleyBlock proto era -> !Block (ShelleyProtocolHeader proto) era
[shelleyBlockHeaderHash] :: ShelleyBlock proto era -> !ShelleyHash (ProtoCrypto proto)
class (ShelleyBasedEra era, ShelleyProtocol proto, Eq (ShelleyProtocolHeader proto), Show (ShelleyProtocolHeader proto), NoThunks (ShelleyProtocolHeader proto), ToCBOR (ShelleyProtocolHeader proto), FromCBOR (Annotator (ShelleyProtocolHeader proto)), Show (CannotForgeError proto), SelectView proto ~ PraosChainSelectView (EraCrypto era), SignedHeader (ShelleyProtocolHeader proto), DecodeDisk (ShelleyBlock proto era) (ChainDepState proto), EncodeDisk (ShelleyBlock proto era) (ChainDepState proto), EraCrypto era ~ ProtoCrypto proto, HasPartialConsensusConfig proto) => ShelleyCompatible proto era
mkShelleyBlock :: ShelleyCompatible proto era => Block (ShelleyProtocolHeader proto) era -> ShelleyBlock proto era
mkShelleyHeader :: ShelleyCompatible proto era => ShelleyProtocolHeader proto -> Header (ShelleyBlock proto era)

-- | From <tt>cardano-ledger-specs</tt> to <tt>ouroboros-consensus</tt>
fromShelleyPrevHash :: EraCrypto era ~ ProtoCrypto proto => PrevHash (EraCrypto era) -> ChainHash (ShelleyBlock proto era)

-- | From <tt>ouroboros-consensus</tt> to <tt>cardano-ledger-specs</tt>
toShelleyPrevHash :: EraCrypto era ~ ProtoCrypto proto => ChainHash (Header (ShelleyBlock proto era)) -> PrevHash (EraCrypto era)
encodeShelleyBlock :: ShelleyCompatible proto era => ShelleyBlock proto era -> Encoding
decodeShelleyBlock :: ShelleyCompatible proto era => Decoder s (ByteString -> ShelleyBlock proto era)
shelleyBinaryBlockInfo :: ShelleyCompatible proto era => ShelleyBlock proto era -> BinaryBlockInfo
encodeShelleyHeader :: ShelleyCompatible proto era => Header (ShelleyBlock proto era) -> Encoding
decodeShelleyHeader :: ShelleyCompatible proto era => Decoder s (ByteString -> Header (ShelleyBlock proto era))
data ShelleyNodeToClientVersion
ShelleyNodeToClientVersion1 :: ShelleyNodeToClientVersion

-- | New queries introduced
ShelleyNodeToClientVersion2 :: ShelleyNodeToClientVersion

-- | New query introduced
ShelleyNodeToClientVersion3 :: ShelleyNodeToClientVersion

-- | New queries introduced
ShelleyNodeToClientVersion4 :: ShelleyNodeToClientVersion

-- | New queries introduced: GetRewardInfoPools
ShelleyNodeToClientVersion5 :: ShelleyNodeToClientVersion
data ShelleyNodeToNodeVersion
ShelleyNodeToNodeVersion1 :: ShelleyNodeToNodeVersion

-- | Verifies whether the block is not corrupted by checking its signature
--   and witnesses.
verifyBlockIntegrity :: ShelleyCompatible proto era => Word64 -> ShelleyBlock proto era -> Bool

-- | Compact variant of <a>ShelleyGenesis</a> with some fields erased that
--   are only used on start-up and that should not be kept in memory
--   forever.
--   
--   Concretely:
--   
--   <ul>
--   <li>The <tt>sgInitialFunds</tt> field is erased. It is only used to
--   set up the initial UTxO in tests and testnets.</li>
--   <li>The <tt>sgStaking</tt> field is erased. It is only used to
--   register initial stake pools in tests and benchmarks.</li>
--   </ul>
data CompactGenesis era
mkShelleyBlockConfig :: ShelleyBasedEra era => ProtVer -> ShelleyGenesis era -> [VKey 'BlockIssuer (EraCrypto era)] -> BlockConfig (ShelleyBlock proto era)

-- | Compacts the given <a>ShelleyGenesis</a>.
compactGenesis :: ShelleyGenesis era -> CompactGenesis era
data ShelleyReapplyException
ShelleyReapplyException :: BlockTransitionError era -> ShelleyReapplyException

-- | All events emitted by the Shelley ledger API
data ShelleyLedgerEvent era

-- | An event emitted when (re)applying a block
ShelleyLedgerEventBBODY :: Event (EraRule "BBODY" era) -> ShelleyLedgerEvent era

-- | An event emitted during the chain tick
ShelleyLedgerEventTICK :: Event (EraRule "TICK" era) -> ShelleyLedgerEvent era

-- | Information required to determine the hard fork point from Shelley to
--   the next ledger
newtype ShelleyTransition
ShelleyTransitionInfo :: Word32 -> ShelleyTransition

-- | The number of blocks in this epoch past the voting deadline
--   
--   We record this to make sure that we can tell the HFC about hard forks
--   if and only if we are certain:
--   
--   <ol>
--   <li>Blocks that came in within an epoch after the 4k/f voting deadline
--   are not relevant (10k<i>f - 2 * 3k</i>f).</li>
--   <li>Since there are slots between blocks, we are probably only sure
--   that there will be no more relevant block when we have seen the first
--   block after the deadline.</li>
--   <li>If we count how many blocks we have seen post deadline, and we
--   have reached k of them, we know that that last pre-deadline block
--   won't be rolled back anymore.</li>
--   <li>At this point we can look at the ledger state and see which
--   proposals we accepted in the voting period, if any, and notify the HFC
--   is one of them indicates a transition.</li>
--   </ol>
[shelleyAfterVoting] :: ShelleyTransition -> Word32
data ShelleyTip proto era
ShelleyTip :: !SlotNo -> !BlockNo -> !HeaderHash (ShelleyBlock proto era) -> ShelleyTip proto era
[shelleyTipSlotNo] :: ShelleyTip proto era -> !SlotNo
[shelleyTipBlockNo] :: ShelleyTip proto era -> !BlockNo
[shelleyTipHash] :: ShelleyTip proto era -> !HeaderHash (ShelleyBlock proto era)
data ShelleyLedgerConfig era
ShelleyLedgerConfig :: !CompactGenesis era -> !Globals -> !TranslationContext era -> ShelleyLedgerConfig era
[shelleyLedgerCompactGenesis] :: ShelleyLedgerConfig era -> !CompactGenesis era

-- | Derived from <a>shelleyLedgerGenesis</a> but we store a cached version
--   because it used very often.
[shelleyLedgerGlobals] :: ShelleyLedgerConfig era -> !Globals
[shelleyLedgerTranslationContext] :: ShelleyLedgerConfig era -> !TranslationContext era
newtype ShelleyLedgerError era
BBodyError :: BlockTransitionError era -> ShelleyLedgerError era
shelleyLedgerGenesis :: ShelleyLedgerConfig era -> ShelleyGenesis era
shelleyEraParams :: ShelleyGenesis era -> EraParams

-- | Separate variant of <a>shelleyEraParams</a> to be used for a
--   Shelley-only chain.
shelleyEraParamsNeverHardForks :: ShelleyGenesis era -> EraParams
mkShelleyLedgerConfig :: ShelleyGenesis era -> TranslationContext era -> EpochInfo (Except PastHorizonException) -> MaxMajorProtVer -> ShelleyLedgerConfig era
shelleyTipToPoint :: WithOrigin (ShelleyTip proto era) -> Point (ShelleyBlock proto era)
castShelleyTip :: HeaderHash (ShelleyBlock proto era) ~ HeaderHash (ShelleyBlock proto' era') => ShelleyTip proto era -> ShelleyTip proto' era'
shelleyLedgerTipPoint :: LedgerState (ShelleyBlock proto era) -> Point (ShelleyBlock proto era)
getPParams :: NewEpochState era -> PParams era
encodeShelleyAnnTip :: ShelleyCompatible proto era => AnnTip (ShelleyBlock proto era) -> Encoding
decodeShelleyAnnTip :: ShelleyCompatible proto era => Decoder s (AnnTip (ShelleyBlock proto era))
encodeShelleyHeaderState :: ShelleyCompatible proto era => HeaderState (ShelleyBlock proto era) -> Encoding
encodeShelleyLedgerState :: ShelleyCompatible proto era => LedgerState (ShelleyBlock proto era) -> Encoding
decodeShelleyLedgerState :: forall era proto s. ShelleyCompatible proto era => Decoder s (LedgerState (ShelleyBlock proto era))
newtype NonMyopicMemberRewards c
NonMyopicMemberRewards :: Map (Either Coin (Credential 'Staking c)) (Map (KeyHash 'StakePool c) Coin) -> NonMyopicMemberRewards c
[unNonMyopicMemberRewards] :: NonMyopicMemberRewards c -> Map (Either Coin (Credential 'Staking c)) (Map (KeyHash 'StakePool c) Coin)

-- | Is the given query supported by the given
--   <a>ShelleyNodeToClientVersion</a>?
querySupportedVersion :: BlockQuery (ShelleyBlock proto era) result -> ShelleyNodeToClientVersion -> Bool
encodeShelleyQuery :: ShelleyBasedEra era => BlockQuery (ShelleyBlock proto era) result -> Encoding
decodeShelleyQuery :: ShelleyBasedEra era => Decoder s (SomeSecond BlockQuery (ShelleyBlock proto era))
encodeShelleyResult :: ShelleyCompatible proto era => BlockQuery (ShelleyBlock proto era) result -> result -> Encoding
decodeShelleyResult :: ShelleyCompatible proto era => BlockQuery (ShelleyBlock proto era) result -> forall s. Decoder s result

-- | Add a unique top element to a lattice.
--   
--   TODO This should be relocated to `cardano-base:Data.Measure'.
data WithTop a
NotTop :: a -> WithTop a
Top :: WithTop a
data AlonzoMeasure
AlonzoMeasure :: !ByteSize -> !ExUnits' (WithTop Natural) -> AlonzoMeasure
[byteSize] :: AlonzoMeasure -> !ByteSize
[exUnits] :: AlonzoMeasure -> !ExUnits' (WithTop Natural)

-- | <a>txInBlockSize</a> is used to estimate how many transactions we can
--   grab from the Mempool to put into the block we are going to forge
--   without exceeding the maximum block body size according to the ledger.
--   If we exceed that limit, we will have forged a block that is invalid
--   according to the ledger. We ourselves won't even adopt it, causing us
--   to lose our slot, something we must try to avoid.
--   
--   For this reason it is better to overestimate the size of a transaction
--   than to underestimate. The only downside is that we maybe could have
--   put one (or more?) transactions extra in that block.
--   
--   As the sum of the serialised transaction sizes is not equal to the
--   size of the serialised block body (<a>TxSeq</a>) consisting of those
--   transactions (see cardano-node#1545 for an example), we account for
--   some extra overhead per transaction as a safety margin.
--   
--   Also see <a>perTxOverhead</a>.
fixedBlockBodyOverhead :: Num a => a

-- | See <a>fixedBlockBodyOverhead</a>.
perTxOverhead :: Num a => a
mkShelleyTx :: forall era proto. ShelleyBasedEra era => Tx era -> GenTx (ShelleyBlock proto era)
mkShelleyValidatedTx :: forall era proto. ShelleyBasedEra era => Validated (Tx era) -> Validated (GenTx (ShelleyBlock proto era))
fromExUnits :: ExUnits -> ExUnits' (WithTop Natural)
forgeShelleyBlock :: forall m era proto. (ShelleyCompatible proto era, TxLimits (ShelleyBlock proto era), Monad m) => HotKey (EraCrypto era) m -> CanBeLeader proto -> TopLevelConfig (ShelleyBlock proto era) -> Overrides (ShelleyBlock proto era) -> BlockNo -> SlotNo -> TickedLedgerState (ShelleyBlock proto era) -> [Validated (GenTx (ShelleyBlock proto era))] -> IsLeader proto -> m (ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Node.Serialisation
instance GHC.Show.Show (Ouroboros.Consensus.Shelley.Node.Serialisation.ShelleyEncoderException era proto)
instance (Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable proto) => GHC.Exception.Type.Exception (Ouroboros.Consensus.Shelley.Node.Serialisation.ShelleyEncoderException era proto)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Util.SomeSecond Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.HasBinaryBlockInfo (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.ChainDB.Impl.Types.SerialiseDiskConstraints (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Data.ByteString.Lazy.Internal.ByteString -> Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Data.ByteString.Lazy.Internal.ByteString -> Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.Basics.LedgerState (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Shelley.Eras.EraCrypto era GHC.Types.~ c, Cardano.Protocol.TPraos.API.PraosCrypto c) => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Shelley.Eras.EraCrypto era GHC.Types.~ c, Cardano.Protocol.TPraos.API.PraosCrypto c) => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Protocol.TPraos.TPraosState c)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Shelley.Eras.EraCrypto era GHC.Types.~ c, Ouroboros.Consensus.Protocol.Praos.PraosCrypto c) => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Shelley.Eras.EraCrypto era GHC.Types.~ c, Ouroboros.Consensus.Protocol.Praos.PraosCrypto c) => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Protocol.Praos.PraosState c)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.EncodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.HeaderValidation.AnnTip (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.DecodeDisk (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.HeaderValidation.AnnTip (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Run.SerialiseNodeToNodeConstraints (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Network.Block.Serialised (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Storage.Serialisation.SerialisedHeader (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Run.SerialiseNodeToClientConstraints (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Network.Block.Serialised (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseResult (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) (Ouroboros.Consensus.Ledger.Query.BlockQuery (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era))
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era) Cardano.Slotting.Slot.SlotNo
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Storage.Serialisation.ReconstructNestedCtxt Ouroboros.Consensus.Block.Abstract.Header (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Storage.Serialisation.EncodeDiskDepIx (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.EncodeDiskDep (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => Ouroboros.Consensus.Storage.Serialisation.DecodeDiskDepIx (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Storage.Serialisation.DecodeDiskDep (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)


-- | Node configuration common to all (era, protocol) combinations deriving
--   from Shelley.
module Ouroboros.Consensus.Shelley.Node.Common

-- | Parameters common to all Shelley-based ledgers.
--   
--   When running a chain with multiple Shelley-based eras, in addition to
--   the per-era protocol parameters, one value of
--   <a>ProtocolParamsShelleyBased</a> will be needed, which is shared
--   among all Shelley-based eras.
--   
--   The <tt>era</tt> parameter determines from which era the genesis
--   config will be used.
data ProtocolParamsShelleyBased era
ProtocolParamsShelleyBased :: ShelleyGenesis era -> Nonce -> [ShelleyLeaderCredentials (EraCrypto era)] -> ProtocolParamsShelleyBased era
[shelleyBasedGenesis] :: ProtocolParamsShelleyBased era -> ShelleyGenesis era

-- | The initial nonce, typically derived from the hash of Genesis config
--   JSON file.
--   
--   WARNING: chains using different values of this parameter will be
--   mutually incompatible.
[shelleyBasedInitialNonce] :: ProtocolParamsShelleyBased era -> Nonce
[shelleyBasedLeaderCredentials] :: ProtocolParamsShelleyBased era -> [ShelleyLeaderCredentials (EraCrypto era)]

-- | Needed in '*SharedBlockForging' because we can't partially apply
--   equality constraints.
class (ShelleyCompatible proto era, TxLimits (ShelleyBlock proto era), EraCrypto era ~ c) => ShelleyEraWithCrypto c proto era
data ShelleyLeaderCredentials c
ShelleyLeaderCredentials :: SignKeyKES c -> PraosCanBeLeader c -> Text -> ShelleyLeaderCredentials c

-- | The unevolved signing KES key (at evolution 0).
--   
--   Note that this is not inside <tt>ShelleyCanBeLeader</tt> since it gets
--   evolved automatically, whereas <tt>ShelleyCanBeLeader</tt> does not
--   change.
[shelleyLeaderCredentialsInitSignKey] :: ShelleyLeaderCredentials c -> SignKeyKES c
[shelleyLeaderCredentialsCanBeLeader] :: ShelleyLeaderCredentials c -> PraosCanBeLeader c

-- | Identifier for this set of credentials.
--   
--   Useful when the node is running with multiple sets of credentials.
[shelleyLeaderCredentialsLabel] :: ShelleyLeaderCredentials c -> Text
shelleyBlockIssuerVKey :: ShelleyLeaderCredentials c -> VKey 'BlockIssuer c
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Mempool.TxLimits.TxLimits (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era), Ouroboros.Consensus.Shelley.Eras.EraCrypto era GHC.Types.~ c) => Ouroboros.Consensus.Shelley.Node.Common.ShelleyEraWithCrypto c proto era
instance Ouroboros.Consensus.Config.SupportsNode.ConfigSupportsNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Node.InitStorage.NodeInitStorage (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Protocol.Praos
data PraosEnvelopeError
ObsoleteNode :: Natural -> Natural -> PraosEnvelopeError
HeaderSizeTooLarge :: Natural -> Natural -> PraosEnvelopeError
BlockSizeTooLarge :: Natural -> Natural -> PraosEnvelopeError
instance GHC.Show.Show Ouroboros.Consensus.Shelley.Protocol.Praos.PraosEnvelopeError
instance GHC.Generics.Generic Ouroboros.Consensus.Shelley.Protocol.Praos.PraosEnvelopeError
instance GHC.Classes.Eq Ouroboros.Consensus.Shelley.Protocol.Praos.PraosEnvelopeError
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Shelley.Protocol.Praos.PraosEnvelopeError
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsEnvelope (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsKES (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsProtocol (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsLedger (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Protocol.Signed.SignedHeader (Ouroboros.Consensus.Protocol.Praos.Header.Header c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyProtocol (Ouroboros.Consensus.Protocol.Praos.Praos c)

module Ouroboros.Consensus.Shelley.Protocol.TPraos
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsEnvelope (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsKES (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsProtocol (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ProtocolHeaderSupportsLedger (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Protocol.Signed.SignedHeader (Cardano.Protocol.TPraos.BHeader.BHeader c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.Shelley.Protocol.Abstract.ShelleyProtocol (Ouroboros.Consensus.Protocol.TPraos.TPraos c)

module Ouroboros.Consensus.Shelley.Node.TPraos

-- | The maximum major protocol version.
--   
--   Must be at least the current major protocol version. For Cardano
--   mainnet, the Shelley era has major protocol verison <b>2</b>.
newtype MaxMajorProtVer
MaxMajorProtVer :: Natural -> MaxMajorProtVer
[getMaxMajorProtVer] :: MaxMajorProtVer -> Natural

-- | Parameters needed to run Allegra
data ProtocolParamsAllegra c
ProtocolParamsAllegra :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (AllegraEra c)) -> ProtocolParamsAllegra c
[$sel:allegraProtVer:ProtocolParamsAllegra] :: ProtocolParamsAllegra c -> ProtVer
[$sel:allegraMaxTxCapacityOverrides:ProtocolParamsAllegra] :: ProtocolParamsAllegra c -> Overrides (ShelleyBlock (TPraos c) (AllegraEra c))

-- | Parameters needed to run Alonzo
data ProtocolParamsAlonzo c
ProtocolParamsAlonzo :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (AlonzoEra c)) -> ProtocolParamsAlonzo c
[$sel:alonzoProtVer:ProtocolParamsAlonzo] :: ProtocolParamsAlonzo c -> ProtVer
[$sel:alonzoMaxTxCapacityOverrides:ProtocolParamsAlonzo] :: ProtocolParamsAlonzo c -> Overrides (ShelleyBlock (TPraos c) (AlonzoEra c))

-- | Parameters needed to run Mary
data ProtocolParamsMary c
ProtocolParamsMary :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (MaryEra c)) -> ProtocolParamsMary c
[$sel:maryProtVer:ProtocolParamsMary] :: ProtocolParamsMary c -> ProtVer
[$sel:maryMaxTxCapacityOverrides:ProtocolParamsMary] :: ProtocolParamsMary c -> Overrides (ShelleyBlock (TPraos c) (MaryEra c))

-- | Parameters needed to run Shelley
data ProtocolParamsShelley c
ProtocolParamsShelley :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (ShelleyEra c)) -> ProtocolParamsShelley c
[$sel:shelleyProtVer:ProtocolParamsShelley] :: ProtocolParamsShelley c -> ProtVer
[$sel:shelleyMaxTxCapacityOverrides:ProtocolParamsShelley] :: ProtocolParamsShelley c -> Overrides (ShelleyBlock (TPraos c) (ShelleyEra c))

-- | Parameters common to all Shelley-based ledgers.
--   
--   When running a chain with multiple Shelley-based eras, in addition to
--   the per-era protocol parameters, one value of
--   <a>ProtocolParamsShelleyBased</a> will be needed, which is shared
--   among all Shelley-based eras.
--   
--   The <tt>era</tt> parameter determines from which era the genesis
--   config will be used.
data ProtocolParamsShelleyBased era
ProtocolParamsShelleyBased :: ShelleyGenesis era -> Nonce -> [ShelleyLeaderCredentials (EraCrypto era)] -> ProtocolParamsShelleyBased era
[shelleyBasedGenesis] :: ProtocolParamsShelleyBased era -> ShelleyGenesis era

-- | The initial nonce, typically derived from the hash of Genesis config
--   JSON file.
--   
--   WARNING: chains using different values of this parameter will be
--   mutually incompatible.
[shelleyBasedInitialNonce] :: ProtocolParamsShelleyBased era -> Nonce
[shelleyBasedLeaderCredentials] :: ProtocolParamsShelleyBased era -> [ShelleyLeaderCredentials (EraCrypto era)]

-- | Evolving nonce type.
data Nonce
Nonce :: !Hash Blake2b_256 Nonce -> Nonce

-- | Identity element
NeutralNonce :: Nonce
data ProtVer
ProtVer :: !Natural -> !Natural -> ProtVer
[pvMajor] :: ProtVer -> !Natural
[pvMinor] :: ProtVer -> !Natural

-- | Shelley genesis information
--   
--   Note that this is needed only for a pure Shelley network, hence it
--   being defined here rather than in its own module. In mainnet, Shelley
--   will transition naturally from Byron, and thus will never have its own
--   genesis information.
data ShelleyGenesis era
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTime -> !Word64 -> !Word64 -> !PParams era -> !Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era)) -> !Map (Addr (Crypto era)) Coin -> !ShelleyGenesisStaking (Crypto era) -> ShelleyGenesis era
[sgSystemStart] :: ShelleyGenesis era -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis era -> !Word32
[sgNetworkId] :: ShelleyGenesis era -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis era -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis era -> !Word64
[sgEpochLength] :: ShelleyGenesis era -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis era -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis era -> !Word64
[sgSlotLength] :: ShelleyGenesis era -> !NominalDiffTime
[sgUpdateQuorum] :: ShelleyGenesis era -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis era -> !Word64
[sgProtocolParams] :: ShelleyGenesis era -> !PParams era
[sgGenDelegs] :: ShelleyGenesis era -> !Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era))
[sgInitialFunds] :: ShelleyGenesis era -> !Map (Addr (Crypto era)) Coin
[sgStaking] :: ShelleyGenesis era -> !ShelleyGenesisStaking (Crypto era)

-- | Genesis Shelley staking configuration.
--   
--   This allows us to configure some initial stake pools and delegation to
--   them, in order to test Praos in a static configuration, without
--   requiring on-chain registration and delegation.
--   
--   For simplicity, pools defined in the genesis staking do not pay
--   deposits for their registration.
data ShelleyGenesisStaking crypto
ShelleyGenesisStaking :: !Map (KeyHash 'StakePool crypto) (PoolParams crypto) -> !Map (KeyHash 'Staking crypto) (KeyHash 'StakePool crypto) -> ShelleyGenesisStaking crypto

-- | Pools to register
--   
--   The key in this map is the hash of the public key of the _pool_. This
--   need not correspond to any payment or staking key, but must correspond
--   to the cold key held by <tt>TPraosIsCoreNode</tt>.
[sgsPools] :: ShelleyGenesisStaking crypto -> !Map (KeyHash 'StakePool crypto) (PoolParams crypto)

-- | Stake-holding key hash credentials and the pools to delegate that
--   stake to. We require the raw staking key hash in order to:
--   
--   <ul>
--   <li>Avoid pointer addresses, which would be tricky when there's no
--   slot or transaction to point to.</li>
--   <li>Avoid script credentials.</li>
--   </ul>
[sgsStake] :: ShelleyGenesisStaking crypto -> !Map (KeyHash 'Staking crypto) (KeyHash 'StakePool crypto)

-- | Empty genesis staking
emptyGenesisStaking :: ShelleyGenesisStaking crypto
data ShelleyLeaderCredentials c
ShelleyLeaderCredentials :: SignKeyKES c -> PraosCanBeLeader c -> Text -> ShelleyLeaderCredentials c

-- | The unevolved signing KES key (at evolution 0).
--   
--   Note that this is not inside <tt>ShelleyCanBeLeader</tt> since it gets
--   evolved automatically, whereas <tt>ShelleyCanBeLeader</tt> does not
--   change.
[shelleyLeaderCredentialsInitSignKey] :: ShelleyLeaderCredentials c -> SignKeyKES c
[shelleyLeaderCredentialsCanBeLeader] :: ShelleyLeaderCredentials c -> PraosCanBeLeader c

-- | Identifier for this set of credentials.
--   
--   Useful when the node is running with multiple sets of credentials.
[shelleyLeaderCredentialsLabel] :: ShelleyLeaderCredentials c -> Text
protocolInfoShelley :: forall m c. (IOLike m, PraosCrypto c, ShelleyCompatible (TPraos c) (ShelleyEra c), TxLimits (ShelleyBlock (TPraos c) (ShelleyEra c))) => ProtocolParamsShelleyBased (ShelleyEra c) -> ProtocolParamsShelley c -> ProtocolInfo m (ShelleyBlock (TPraos c) (ShelleyEra c))
protocolInfoTPraosShelleyBased :: forall m era c. (IOLike m, PraosCrypto c, ShelleyCompatible (TPraos c) era, TxLimits (ShelleyBlock (TPraos c) era), c ~ EraCrypto era) => ProtocolParamsShelleyBased era -> TranslationContext era -> ProtVer -> Overrides (ShelleyBlock (TPraos c) era) -> ProtocolInfo m (ShelleyBlock (TPraos c) era)

-- | Register the initial staking information in the <a>NewEpochState</a>.
--   
--   HERE BE DRAGONS! This function is intended to help in testing.
--   
--   In production, the genesis should <i>not</i> contain any initial
--   staking.
--   
--   Any existing staking information is overridden, but the UTxO is left
--   untouched.
--   
--   TODO adapt and reuse <tt>registerGenesisStaking</tt> from
--   <tt>cardano-ledger-specs</tt>.
registerGenesisStaking :: forall era. ShelleyBasedEra era => ShelleyGenesisStaking (EraCrypto era) -> NewEpochState era -> NewEpochState era

-- | Register the initial funds in the <a>NewEpochState</a>.
--   
--   HERE BE DRAGONS! This function is intended to help in testing.
--   
--   In production, the genesis should <i>not</i> contain any initial
--   funds.
--   
--   The given funds are <i>added</i> to the existing UTxO.
--   
--   PRECONDITION: the given funds must not be part of the existing UTxO.
--   &gt; forall (addr, _) in initialFunds. &gt; Map.notElem
--   (SL.initialFundsPseudoTxIn addr) existingUTxO
--   
--   PROPERTY: &gt; genesisUTxO genesis &gt; == <a>genesisUTxO'</a>
--   (sgInitialFunds genesis) &gt; == <a>extractUTxO</a>
--   (registerInitialFunds (sgInitialFunds genesis) &gt;
--   <a>NewEpochState</a>)
--   
--   TODO move to <tt>cardano-ledger-specs</tt>.
registerInitialFunds :: forall era. (ShelleyBasedEra era, HasCallStack) => Map (Addr (EraCrypto era)) Coin -> NewEpochState era -> NewEpochState era

-- | Create a <a>BlockForging</a> record for a single era.
--   
--   In case the same credentials should be shared across multiple
--   Shelley-based eras, use <a>shelleySharedBlockForging</a>.
shelleyBlockForging :: forall m era c. (ShelleyCompatible (TPraos c) era, PraosCrypto c, c ~ EraCrypto era, TxLimits (ShelleyBlock (TPraos c) era), IOLike m) => TPraosParams -> Overrides (ShelleyBlock (TPraos c) era) -> ShelleyLeaderCredentials (EraCrypto era) -> m (BlockForging m (ShelleyBlock (TPraos c) era))

-- | Create a <a>BlockForging</a> record safely using a given
--   <tt>Hotkey</tt>.
--   
--   The name of the era (separated by a <tt>_</tt>) will be appended to
--   each <a>forgeLabel</a>.
shelleySharedBlockForging :: forall m c era. (PraosCrypto c, ShelleyEraWithCrypto c (TPraos c) era, IOLike m) => HotKey c m -> (SlotNo -> KESPeriod) -> ShelleyLeaderCredentials c -> Overrides (ShelleyBlock (TPraos c) era) -> BlockForging m (ShelleyBlock (TPraos c) era)

-- | Check the validity of the genesis config. To be used in conjunction
--   with <a>assertWithMsg</a>.
validateGenesis :: ShelleyBasedEra era => ShelleyGenesis era -> Either String ()

module Ouroboros.Consensus.Shelley.Node

-- | The maximum major protocol version.
--   
--   Must be at least the current major protocol version. For Cardano
--   mainnet, the Shelley era has major protocol verison <b>2</b>.
newtype MaxMajorProtVer
MaxMajorProtVer :: Natural -> MaxMajorProtVer
[getMaxMajorProtVer] :: MaxMajorProtVer -> Natural

-- | Parameters needed to run Allegra
data ProtocolParamsAllegra c
ProtocolParamsAllegra :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (AllegraEra c)) -> ProtocolParamsAllegra c
[$sel:allegraProtVer:ProtocolParamsAllegra] :: ProtocolParamsAllegra c -> ProtVer
[$sel:allegraMaxTxCapacityOverrides:ProtocolParamsAllegra] :: ProtocolParamsAllegra c -> Overrides (ShelleyBlock (TPraos c) (AllegraEra c))

-- | Parameters needed to run Alonzo
data ProtocolParamsAlonzo c
ProtocolParamsAlonzo :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (AlonzoEra c)) -> ProtocolParamsAlonzo c
[$sel:alonzoProtVer:ProtocolParamsAlonzo] :: ProtocolParamsAlonzo c -> ProtVer
[$sel:alonzoMaxTxCapacityOverrides:ProtocolParamsAlonzo] :: ProtocolParamsAlonzo c -> Overrides (ShelleyBlock (TPraos c) (AlonzoEra c))

-- | Parameters needed to run Mary
data ProtocolParamsMary c
ProtocolParamsMary :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (MaryEra c)) -> ProtocolParamsMary c
[$sel:maryProtVer:ProtocolParamsMary] :: ProtocolParamsMary c -> ProtVer
[$sel:maryMaxTxCapacityOverrides:ProtocolParamsMary] :: ProtocolParamsMary c -> Overrides (ShelleyBlock (TPraos c) (MaryEra c))

-- | Parameters needed to run Shelley
data ProtocolParamsShelley c
ProtocolParamsShelley :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (ShelleyEra c)) -> ProtocolParamsShelley c
[$sel:shelleyProtVer:ProtocolParamsShelley] :: ProtocolParamsShelley c -> ProtVer
[$sel:shelleyMaxTxCapacityOverrides:ProtocolParamsShelley] :: ProtocolParamsShelley c -> Overrides (ShelleyBlock (TPraos c) (ShelleyEra c))

-- | Parameters common to all Shelley-based ledgers.
--   
--   When running a chain with multiple Shelley-based eras, in addition to
--   the per-era protocol parameters, one value of
--   <a>ProtocolParamsShelleyBased</a> will be needed, which is shared
--   among all Shelley-based eras.
--   
--   The <tt>era</tt> parameter determines from which era the genesis
--   config will be used.
data ProtocolParamsShelleyBased era
ProtocolParamsShelleyBased :: ShelleyGenesis era -> Nonce -> [ShelleyLeaderCredentials (EraCrypto era)] -> ProtocolParamsShelleyBased era
[shelleyBasedGenesis] :: ProtocolParamsShelleyBased era -> ShelleyGenesis era

-- | The initial nonce, typically derived from the hash of Genesis config
--   JSON file.
--   
--   WARNING: chains using different values of this parameter will be
--   mutually incompatible.
[shelleyBasedInitialNonce] :: ProtocolParamsShelleyBased era -> Nonce
[shelleyBasedLeaderCredentials] :: ProtocolParamsShelleyBased era -> [ShelleyLeaderCredentials (EraCrypto era)]

-- | Evolving nonce type.
data Nonce
Nonce :: !Hash Blake2b_256 Nonce -> Nonce

-- | Identity element
NeutralNonce :: Nonce
data ProtVer
ProtVer :: !Natural -> !Natural -> ProtVer
[pvMajor] :: ProtVer -> !Natural
[pvMinor] :: ProtVer -> !Natural

-- | Shelley genesis information
--   
--   Note that this is needed only for a pure Shelley network, hence it
--   being defined here rather than in its own module. In mainnet, Shelley
--   will transition naturally from Byron, and thus will never have its own
--   genesis information.
data ShelleyGenesis era
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTime -> !Word64 -> !Word64 -> !PParams era -> !Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era)) -> !Map (Addr (Crypto era)) Coin -> !ShelleyGenesisStaking (Crypto era) -> ShelleyGenesis era
[sgSystemStart] :: ShelleyGenesis era -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis era -> !Word32
[sgNetworkId] :: ShelleyGenesis era -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis era -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis era -> !Word64
[sgEpochLength] :: ShelleyGenesis era -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis era -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis era -> !Word64
[sgSlotLength] :: ShelleyGenesis era -> !NominalDiffTime
[sgUpdateQuorum] :: ShelleyGenesis era -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis era -> !Word64
[sgProtocolParams] :: ShelleyGenesis era -> !PParams era
[sgGenDelegs] :: ShelleyGenesis era -> !Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era))
[sgInitialFunds] :: ShelleyGenesis era -> !Map (Addr (Crypto era)) Coin
[sgStaking] :: ShelleyGenesis era -> !ShelleyGenesisStaking (Crypto era)

-- | Genesis Shelley staking configuration.
--   
--   This allows us to configure some initial stake pools and delegation to
--   them, in order to test Praos in a static configuration, without
--   requiring on-chain registration and delegation.
--   
--   For simplicity, pools defined in the genesis staking do not pay
--   deposits for their registration.
data ShelleyGenesisStaking crypto
ShelleyGenesisStaking :: !Map (KeyHash 'StakePool crypto) (PoolParams crypto) -> !Map (KeyHash 'Staking crypto) (KeyHash 'StakePool crypto) -> ShelleyGenesisStaking crypto

-- | Pools to register
--   
--   The key in this map is the hash of the public key of the _pool_. This
--   need not correspond to any payment or staking key, but must correspond
--   to the cold key held by <tt>TPraosIsCoreNode</tt>.
[sgsPools] :: ShelleyGenesisStaking crypto -> !Map (KeyHash 'StakePool crypto) (PoolParams crypto)

-- | Stake-holding key hash credentials and the pools to delegate that
--   stake to. We require the raw staking key hash in order to:
--   
--   <ul>
--   <li>Avoid pointer addresses, which would be tricky when there's no
--   slot or transaction to point to.</li>
--   <li>Avoid script credentials.</li>
--   </ul>
[sgsStake] :: ShelleyGenesisStaking crypto -> !Map (KeyHash 'Staking crypto) (KeyHash 'StakePool crypto)

-- | Empty genesis staking
emptyGenesisStaking :: ShelleyGenesisStaking crypto
data ShelleyLeaderCredentials c
ShelleyLeaderCredentials :: SignKeyKES c -> PraosCanBeLeader c -> Text -> ShelleyLeaderCredentials c

-- | The unevolved signing KES key (at evolution 0).
--   
--   Note that this is not inside <tt>ShelleyCanBeLeader</tt> since it gets
--   evolved automatically, whereas <tt>ShelleyCanBeLeader</tt> does not
--   change.
[shelleyLeaderCredentialsInitSignKey] :: ShelleyLeaderCredentials c -> SignKeyKES c
[shelleyLeaderCredentialsCanBeLeader] :: ShelleyLeaderCredentials c -> PraosCanBeLeader c

-- | Identifier for this set of credentials.
--   
--   Useful when the node is running with multiple sets of credentials.
[shelleyLeaderCredentialsLabel] :: ShelleyLeaderCredentials c -> Text
protocolClientInfoShelley :: ProtocolClientInfo (ShelleyBlock proto era)
protocolInfoShelley :: forall m c. (IOLike m, PraosCrypto c, ShelleyCompatible (TPraos c) (ShelleyEra c), TxLimits (ShelleyBlock (TPraos c) (ShelleyEra c))) => ProtocolParamsShelleyBased (ShelleyEra c) -> ProtocolParamsShelley c -> ProtocolInfo m (ShelleyBlock (TPraos c) (ShelleyEra c))
protocolInfoTPraosShelleyBased :: forall m era c. (IOLike m, PraosCrypto c, ShelleyCompatible (TPraos c) era, TxLimits (ShelleyBlock (TPraos c) era), c ~ EraCrypto era) => ProtocolParamsShelleyBased era -> TranslationContext era -> ProtVer -> Overrides (ShelleyBlock (TPraos c) era) -> ProtocolInfo m (ShelleyBlock (TPraos c) era)

-- | Register the initial staking information in the <a>NewEpochState</a>.
--   
--   HERE BE DRAGONS! This function is intended to help in testing.
--   
--   In production, the genesis should <i>not</i> contain any initial
--   staking.
--   
--   Any existing staking information is overridden, but the UTxO is left
--   untouched.
--   
--   TODO adapt and reuse <tt>registerGenesisStaking</tt> from
--   <tt>cardano-ledger-specs</tt>.
registerGenesisStaking :: forall era. ShelleyBasedEra era => ShelleyGenesisStaking (EraCrypto era) -> NewEpochState era -> NewEpochState era

-- | Register the initial funds in the <a>NewEpochState</a>.
--   
--   HERE BE DRAGONS! This function is intended to help in testing.
--   
--   In production, the genesis should <i>not</i> contain any initial
--   funds.
--   
--   The given funds are <i>added</i> to the existing UTxO.
--   
--   PRECONDITION: the given funds must not be part of the existing UTxO.
--   &gt; forall (addr, _) in initialFunds. &gt; Map.notElem
--   (SL.initialFundsPseudoTxIn addr) existingUTxO
--   
--   PROPERTY: &gt; genesisUTxO genesis &gt; == <a>genesisUTxO'</a>
--   (sgInitialFunds genesis) &gt; == <a>extractUTxO</a>
--   (registerInitialFunds (sgInitialFunds genesis) &gt;
--   <a>NewEpochState</a>)
--   
--   TODO move to <tt>cardano-ledger-specs</tt>.
registerInitialFunds :: forall era. (ShelleyBasedEra era, HasCallStack) => Map (Addr (EraCrypto era)) Coin -> NewEpochState era -> NewEpochState era

-- | Check the validity of the genesis config. To be used in conjunction
--   with <a>assertWithMsg</a>.
validateGenesis :: ShelleyBasedEra era => ShelleyGenesis era -> Either String ()
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.Block.SupportsMetrics.BlockSupportsMetrics (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.Node.Run.RunNode (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)

module Ouroboros.Consensus.Shelley.Node.Praos

-- | Parameters needed to run Babbage
data ProtocolParamsBabbage c
ProtocolParamsBabbage :: ProtVer -> Overrides (ShelleyBlock (Praos c) (BabbageEra c)) -> ProtocolParamsBabbage c
[babbageProtVer] :: ProtocolParamsBabbage c -> ProtVer
[babbageMaxTxCapacityOverrides] :: ProtocolParamsBabbage c -> Overrides (ShelleyBlock (Praos c) (BabbageEra c))

-- | Create a <a>BlockForging</a> record for a single era.
praosBlockForging :: forall m era c. (ShelleyCompatible (Praos c) era, c ~ EraCrypto era, TxLimits (ShelleyBlock (Praos c) era), IOLike m) => PraosParams -> Overrides (ShelleyBlock (Praos c) era) -> ShelleyLeaderCredentials (EraCrypto era) -> m (BlockForging m (ShelleyBlock (Praos c) era))

-- | Create a <a>BlockForging</a> record safely using the given
--   <tt>Hotkey</tt>.
--   
--   The name of the era (separated by a <tt>_</tt>) will be appended to
--   each <a>forgeLabel</a>.
praosSharedBlockForging :: forall m c era. (ShelleyEraWithCrypto c (Praos c) era, IOLike m) => HotKey c m -> (SlotNo -> KESPeriod) -> ShelleyLeaderCredentials c -> Overrides (ShelleyBlock (Praos c) era) -> BlockForging m (ShelleyBlock (Praos c) era)
protocolInfoPraosBabbage :: forall m c. (IOLike m, ShelleyCompatible (Praos c) (BabbageEra c), TxLimits (ShelleyBlock (Praos c) (BabbageEra c))) => ProtocolParamsShelleyBased (BabbageEra c) -> ProtocolParamsBabbage c -> ProtocolInfo m (ShelleyBlock (Praos c) (BabbageEra c))
protocolInfoPraosShelleyBased :: forall m era c. (IOLike m, ShelleyCompatible (Praos c) era, TxLimits (ShelleyBlock (Praos c) era), c ~ EraCrypto era) => ProtocolParamsShelleyBased era -> TranslationContext era -> ProtVer -> Overrides (ShelleyBlock (Praos c) era) -> ProtocolInfo m (ShelleyBlock (Praos c) era)


-- | This module contains <tt>SupportsProtocol</tt> instances tying the
--   ledger and protocol together. Since these instances reference both
--   ledger concerns and protocol concerns, it is the one class where we
--   cannot provide a generic instance for <a>ShelleyBlock</a>.
module Ouroboros.Consensus.Shelley.Ledger.SupportsProtocol
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos crypto) era, crypto GHC.Types.~ Ouroboros.Consensus.Shelley.Eras.EraCrypto era) => Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock (Ouroboros.Consensus.Protocol.TPraos.TPraos crypto) era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.Praos.Praos crypto) era, Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos crypto) era, crypto GHC.Types.~ Ouroboros.Consensus.Shelley.Eras.EraCrypto era, Ouroboros.Consensus.Protocol.Translate.TranslateProto (Ouroboros.Consensus.Protocol.TPraos.TPraos crypto) (Ouroboros.Consensus.Protocol.Praos.Praos crypto)) => Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock (Ouroboros.Consensus.Protocol.Praos.Praos crypto) era)


-- | This module is the Shelley Hard Fork Combinator
module Ouroboros.Consensus.Shelley.ShelleyHFC
type ProtocolShelley = HardForkProtocol '[ShelleyBlock (TPraos StandardCrypto) StandardShelley]

-- | Shelley as the single era in the hard fork combinator
type ShelleyBlockHFC proto era = HardForkBlock '[ShelleyBlock proto era]
data ShelleyPartialLedgerConfig era
ShelleyPartialLedgerConfig :: !ShelleyLedgerConfig era -> !TriggerHardFork -> ShelleyPartialLedgerConfig era

-- | We cache the non-partial ledger config containing a dummy
--   <a>EpochInfo</a> that needs to be replaced with the correct one.
--   
--   We do this to avoid recomputing the ledger config each time
--   <a>completeLedgerConfig</a> is called, as <a>mkShelleyLedgerConfig</a>
--   does some rather expensive computations that shouldn't be repeated too
--   often (e.g., <tt>sgActiveSlotCoeff</tt>).
[shelleyLedgerConfig] :: ShelleyPartialLedgerConfig era -> !ShelleyLedgerConfig era
[shelleyTriggerHardFork] :: ShelleyPartialLedgerConfig era -> !TriggerHardFork

-- | Forecast from a Shelley-based era to the next Shelley-based era.
forecastAcrossShelley :: forall protoFrom protoTo eraFrom eraTo. (TranslateProto protoFrom protoTo, LedgerSupportsProtocol (ShelleyBlock protoFrom eraFrom)) => ShelleyLedgerConfig eraFrom -> ShelleyLedgerConfig eraTo -> Bound -> SlotNo -> LedgerState (ShelleyBlock protoFrom eraFrom) -> Except OutsideForecastRange (Ticked (WrapLedgerView (ShelleyBlock protoTo eraTo)))
translateChainDepStateAcrossShelley :: forall eraFrom eraTo protoFrom protoTo. TranslateProto protoFrom protoTo => RequiringBoth WrapConsensusConfig (Translate WrapChainDepState) (ShelleyBlock protoFrom eraFrom) (ShelleyBlock protoTo eraTo)
translateLedgerViewAcrossShelley :: forall eraFrom eraTo protoFrom protoTo. (TranslateProto protoFrom protoTo, LedgerSupportsProtocol (ShelleyBlock protoFrom eraFrom)) => RequiringBoth WrapLedgerConfig (TranslateForecast LedgerState WrapLedgerView) (ShelleyBlock protoFrom eraFrom) (ShelleyBlock protoTo eraTo)
instance Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era => NoThunks.Class.NoThunks (Ouroboros.Consensus.Shelley.ShelleyHFC.ShelleyPartialLedgerConfig era)
instance GHC.Generics.Generic (Ouroboros.Consensus.Shelley.ShelleyHFC.ShelleyPartialLedgerConfig era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.HardFork.Combinator.Abstract.NoHardForks.NoHardForks (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.HardFork.Combinator.Abstract.SingleEraBlock.SingleEraBlock (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.HardFork.Combinator.PartialConfig.HasPartialLedgerConfig (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.Node.NetworkProtocolVersion.SupportedNetworkProtocolVersion (Ouroboros.Consensus.Shelley.ShelleyHFC.ShelleyBlockHFC proto era)
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.HardFork.Combinator.Serialisation.Common.SerialiseHFC '[Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era]
instance (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era, Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)) => Ouroboros.Consensus.HardFork.Combinator.Serialisation.Common.SerialiseConstraintsHFC (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.HardFork.Combinator.PartialConfig.HasPartialConsensusConfig (Ouroboros.Consensus.Protocol.Praos.Praos c)
instance Cardano.Protocol.TPraos.API.PraosCrypto c => Ouroboros.Consensus.HardFork.Combinator.PartialConfig.HasPartialConsensusConfig (Ouroboros.Consensus.Protocol.TPraos.TPraos c)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra (Cardano.Ledger.Era.PreviousEra era), Ouroboros.Consensus.Shelley.Eras.EraCrypto (Cardano.Ledger.Era.PreviousEra era) GHC.Types.~ Ouroboros.Consensus.Shelley.Eras.EraCrypto era) => Cardano.Ledger.Era.TranslateEra era (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Cardano.Ledger.Era.TranslateEra era (Ouroboros.Consensus.Shelley.Ledger.Ledger.ShelleyTip proto), Cardano.Ledger.Era.TranslateEra era Cardano.Ledger.Shelley.LedgerState.NewEpochState, Cardano.Ledger.Era.TranslationError era Cardano.Ledger.Shelley.LedgerState.NewEpochState GHC.Types.~ Data.Void.Void) => Cardano.Ledger.Era.TranslateEra era (Ouroboros.Consensus.Ledger.Basics.LedgerState Data.SOP.BasicFunctors.:.: Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Cardano.Ledger.Era.TranslateEra era Ouroboros.Consensus.Shelley.Eras.WrapTx) => Cardano.Ledger.Era.TranslateEra era (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Data.SOP.BasicFunctors.:.: Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto)
instance (Ouroboros.Consensus.Shelley.Eras.ShelleyBasedEra era, Cardano.Ledger.Era.TranslateEra era Ouroboros.Consensus.Shelley.Eras.WrapTx) => Cardano.Ledger.Era.TranslateEra era (Ouroboros.Consensus.TypeFamilyWrappers.WrapValidatedGenTx Data.SOP.BasicFunctors.:.: Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto)


-- | Hard fork eras.
--   
--   Compare this to <a>Eras</a>, which defines ledger eras. This module
--   defines hard fork eras, which are a combination of a ledger era and a
--   protocol.
module Ouroboros.Consensus.Shelley.HFEras
type StandardAllegraBlock = ShelleyBlock (TPraos StandardCrypto) StandardAllegra
type StandardAlonzoBlock = ShelleyBlock (TPraos StandardCrypto) StandardAlonzo
type StandardBabbageBlock = ShelleyBlock (Praos StandardCrypto) StandardBabbage
type StandardMaryBlock = ShelleyBlock (TPraos StandardCrypto) StandardMary
type StandardShelleyBlock = ShelleyBlock (TPraos StandardCrypto) StandardShelley
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN c) (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH c) Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Shelley.ShelleyEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN c) (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH c) Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Allegra.AllegraEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN c) (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH c) Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Mary.MaryEra c)
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN c) (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH c) Cardano.Ledger.Hashes.EraIndependentTxBody)) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Alonzo.AlonzoEra c)
instance (Ouroboros.Consensus.Protocol.Praos.PraosCrypto c, Cardano.Protocol.TPraos.API.PraosCrypto c) => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.TPraos.TPraos c) (Cardano.Ledger.Babbage.BabbageEra c)
instance Ouroboros.Consensus.Protocol.Praos.PraosCrypto c => Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible (Ouroboros.Consensus.Protocol.Praos.Praos c) (Cardano.Ledger.Babbage.BabbageEra c)
