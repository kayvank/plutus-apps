-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Genetic algorithm based randomised testing
--   
--   Genetic algorithm based randomised testing
@package goblins
@version 0.2.0.1


-- | Utilities for reading from / writing to the filesystem
module Test.Goblin.Persist

-- | Decode a `Population Bool` from a lazy ByteString.
decodePopulation :: ByteString -> Population Bool

-- | Encode a `Population Bool` to a lazy ByteString.
encodePopulation :: Population Bool -> ByteString

-- | Load a Population from a file and return the first (highest scoring)
--   genome.
readFirstGenomeFromFile :: FilePath -> IO [Bool]

-- | Read a Population from a file.
readPopulationFromFile :: FilePath -> IO (Population Bool)

-- | Write a Population to a file.
writePopulationToFile :: FilePath -> Population Bool -> IO ()

-- | Read a file at compile-time, and splice in the <a>show</a> of its
--   ByteString as a String in the source file.
loadBestPopToShownByteString :: FilePath -> Q Exp

-- | Splice in a genome as a <a>show</a>n ByteString, and decode it at
--   runtime. This is less safe than inlining the whole list of
--   <a>Bool</a>s into source code, but results in less source bloat.
loadGoblinDataFromFilePath :: FilePath -> Q Exp

-- | Convert an Integral into a little-endian binary representation.
integralToBits :: FiniteBits a => a -> [Bool]

-- | Convert from a little-endian binary representation to an Integral.
integralFromBits :: forall a. (Integral a, FiniteBits a) => [Bool] -> a

-- | Returns the padded list, plus the number of padding bits added.
padBits :: Int -> [Bool] -> ([Bool], Int)

-- | Split a list of <a>Word64</a>s, little-endian style, into their
--   requisite bits. The <a>Int</a> describes the amount of padding to
--   drop, since we must necessarily pad up to a 64-bit multiple.
splitter :: ([Word64], Int) -> [Bool]

-- | Group a list of <a>Bool</a>s into a list of <a>Word64</a>s,
--   little-endian style. The <a>Int</a> describes the amount of padding
--   added, since we must necessarily pad up to a 64-bit multiple.
grouper :: [Bool] -> ([Word64], Int)


-- | Utility functions
module Test.Goblin.Util

-- | <a>&lt;$&gt;</a> through nested functors.
(<$$>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)

-- | <a>&lt;*&gt;</a> through nested functors.
(<**>) :: (Applicative f, Applicative g) => f (g (a -> b)) -> f (g a) -> f (g b)


-- | The core typeclasses and associated methods of goblins.
module Test.Goblin.Core

-- | The state we carry as we perform goblins actions.
data GoblinData g
GoblinData :: !Genome g -> !TypeRepMap [] -> GoblinData g

-- | Remaining genes, controlling how a goblin operates.
[_genes] :: GoblinData g -> !Genome g

-- | A goblin's bag of tricks contains items of many differnt types. When
--   tinkering, a goblin (depending on its genome) might look in its bag of
--   tricks to see whether it has anything of the appropriate type to
--   replace what it's currently tinkering with (or, depending on the type,
--   do something different - for example, utilise a monoid instance to add
--   things together).
[_bagOfTricks] :: GoblinData g -> !TypeRepMap []

-- | Recur down a datatype, adding the sub-datatypes to the <a>TinkerM</a>
--   <a>TypeRepMap</a>
class SeedGoblin a

-- | Recur down a type, adding elements to the TypeRepMap
seeder :: SeedGoblin a => a -> TinkerM g ()

-- | Recur down a type, adding elements to the TypeRepMap
seeder :: (SeedGoblin a, Typeable a) => a -> TinkerM g ()

-- | Whereas <a>pure</a> creates a Hedgehog tree with no shrinks,
--   <a>addShrinks</a> creates a tree with shrinks.
class AddShrinks a
addShrinks :: AddShrinks a => a -> Gen a
addShrinks :: (AddShrinks a, Enum a) => a -> Gen a

-- | A typeclass for actions over genomes.
class GeneOps g

-- | Choose between two actions based on the value of a gene.
onGene :: GeneOps g => TinkerM g a -> TinkerM g a -> TinkerM g a

-- | Transcribe sufficient genes to get an integer in the range [0..n].
transcribeGenesAsInt :: GeneOps g => Int -> TinkerM g Int

-- | The interface to goblins. This class defines two actions -
--   <a>tinker</a>ing with an existing value - <a>conjure</a>ing a new
--   value
class (GeneOps g, Typeable a) => Goblin g a

-- | Tinker with an item of type <tt>a</tt>.
tinker :: Goblin g a => Gen a -> TinkerM g (Gen a)

-- | As well as tinkering, goblins can conjure fresh items into existence.
conjure :: Goblin g a => TinkerM g a

-- | Tinker monad.
type TinkerM g = State (GoblinData g)
bagOfTricks :: forall g_afc9. Lens' (GoblinData g_afc9) (TypeRepMap [])
genes :: forall g_afc9 g_afcJ. Lens (GoblinData g_afc9) (GoblinData g_afcJ) (Genome g_afc9) (Genome g_afcJ)

-- | Helper function to save a value in the bagOfTricks, and return it.
saveInBagOfTricks :: forall g a. Typeable a => a -> TinkerM g a

-- | Construct a tinker function given a set of possible things to do.
--   
--   Each <tt>toy</tt> is a function taking the original value and one
--   grabbed from the bag of tricks or conjured.
tinkerWithToys :: (AddShrinks a, Goblin g a) => [Gen a -> Gen a -> Gen a] -> Gen a -> TinkerM g (Gen a)

-- | Either tinker with a rummaged value, conjure a new value, or save the
--   argument in the bagOfTricks and return it.
tinkerRummagedOrConjureOrSave :: (Goblin g a, AddShrinks a) => TinkerM g (Gen a) -> TinkerM g (Gen a)

-- | Read (and consume) a gene from the genome.
transcribeGene :: TinkerM g g

-- | Fetch something from the bag of tricks if there's something there.
rummage :: forall a g. (GeneOps g, Typeable a) => TinkerM g (Maybe a)

-- | Fetch everything from the bag of tricks.
rummageAll :: forall a g. Typeable a => TinkerM g [a]

-- | Fetch something from the bag of tricks, or else conjure it up.
rummageOrConjure :: forall a g. Goblin g a => TinkerM g a

-- | Attempt to rummage. If a value is available, either tinker with it or
--   leave it intact. If no value is available, conjure a fresh one and add
--   shrinks to it.
tinkerRummagedOrConjure :: forall a g. (Goblin g a, AddShrinks a) => TinkerM g (Gen a)

-- | Use an Enum instance to create a shrink tree which shrinks towards
--   `toEnum 0`.
shrinkEnum :: Enum a => a -> [a]

-- | Spawn a goblin from a given genome and a bag of tricks.
mkGoblin :: Genome g -> TypeRepMap [] -> GoblinData g

-- | Spawn a goblin from a genome, with an empty TypeRepMap.
mkEmptyGoblin :: Genome g -> GoblinData g

-- | Use the genome to generate an index within the bounds of the provided
--   list.
geneListIndex :: GeneOps g => [a] -> TinkerM g Int

-- | Convenience Hedgehog generator.
genPopulation :: Gen (Population Bool)

-- | <a>&lt;$&gt;</a> through nested functors.
(<$$>) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)

-- | <a>&lt;*&gt;</a> through nested functors.
(<**>) :: (Applicative f, Applicative g) => f (g (a -> b)) -> f (g a) -> f (g b)


-- | Template Haskell derivation functions for the goblin-related
--   typeclasses.
module Test.Goblin.TH

-- | Derive a <a>Goblin</a> instance for datatypes which have <a>Goblin</a>
--   and <a>AddShrinks</a> instances for their enclosed fields.
--   <a>tinker</a>s recursively with fields of a datatype, then uses
--   <a>&lt;$$&gt;</a> and <a>&lt;**&gt;</a> to map the constructor over
--   the tinkered fields. <a>conjure</a>s by using <a>&lt;$&gt;</a> and
--   <a>&lt;*&gt;</a> over recursive calls to <a>conjure</a>.
--   
--   <pre>
--   deriveGoblin ''(,)
--   ======&gt;
--   instance (Goblin g a,
--             AddShrinks a,
--             Goblin g b,
--             AddShrinks b) =&gt;
--            Goblin g ((,) a b) where
--     tinker gen
--       = tinkerRummagedOrConjureOrSave
--           ((( a b -&gt; ((,) a) b)
--              <a>$$</a> tinker (( ((,) a _) -&gt; a) <a>$</a> gen))
--              <a>**</a> tinker (( ((,) _ b) -&gt; b) <a>$</a> gen))
--     conjure = (saveInBagOfTricks =<a>(((,) &lt;$</a> conjure) <a>*</a> conjure))
--   </pre>
deriveGoblin :: Name -> Q [Dec]

-- | Derive an <a>AddShrinks</a> instance for datatypes which have
--   <a>AddShrinks</a> instances for their enclosed fields. Simply performs
--   structural recursion on fields, then uses <a>&lt;$&gt;</a> and
--   <a>&lt;*&gt;</a> to apply the constructor over the <a>addShrinks</a>
--   of the fields.
--   
--   <pre>
--   deriveAddShrinks ''(,)
--   ======&gt;
--   instance (AddShrinks a, AddShrinks b) =&gt;
--            AddShrinks ((,) a b) where
--     addShrinks ((,) x y)
--       = ((( x y -&gt; ((,) x) y)
--            <a>$</a> addShrinks x)
--            <a>*</a> addShrinks y)
--   </pre>
deriveAddShrinks :: Name -> Q [Dec]

-- | Derive a <a>SeedGoblin</a> instance which calls
--   <a>saveInBagOfTricks</a> on the argument then recurs structurally on
--   fields.
--   
--   <pre>
--   deriveSeedGoblin ''(,)
--   ======&gt;
--   instance (SeedGoblin a,
--             Typeable a,
--             SeedGoblin b,
--             Typeable b) =&gt;
--            SeedGoblin ((,) a b) where
--     seeder p@((,) x y)
--       = do (() &lt;$ saveInBagOfTricks p)
--            seeder x
--            seeder y
--   </pre>
deriveSeedGoblin :: Name -> Q [Dec]

module Test.Goblin.Instances
instance (Test.Goblin.Core.SeedGoblin arg1, Data.Typeable.Internal.Typeable arg1, Test.Goblin.Core.SeedGoblin arg2, Data.Typeable.Internal.Typeable arg2, Test.Goblin.Core.SeedGoblin arg3, Data.Typeable.Internal.Typeable arg3, Test.Goblin.Core.SeedGoblin arg4, Data.Typeable.Internal.Typeable arg4, Test.Goblin.Core.SeedGoblin arg5, Data.Typeable.Internal.Typeable arg5, Test.Goblin.Core.SeedGoblin arg6, Data.Typeable.Internal.Typeable arg6, Test.Goblin.Core.SeedGoblin arg7, Data.Typeable.Internal.Typeable arg7, Test.Goblin.Core.SeedGoblin arg8, Data.Typeable.Internal.Typeable arg8, Test.Goblin.Core.SeedGoblin arg9, Data.Typeable.Internal.Typeable arg9, Test.Goblin.Core.SeedGoblin arg10, Data.Typeable.Internal.Typeable arg10, Test.Goblin.Core.SeedGoblin arg11, Data.Typeable.Internal.Typeable arg11) => Test.Goblin.Core.SeedGoblin (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
instance (Test.Goblin.Core.SeedGoblin a, Data.Typeable.Internal.Typeable a) => Test.Goblin.Core.SeedGoblin [a]
instance (Test.Goblin.Core.SeedGoblin a, Data.Typeable.Internal.Typeable a) => Test.Goblin.Core.SeedGoblin (Data.Sequence.Internal.Seq a)
instance (Test.Goblin.Core.SeedGoblin a, Data.Typeable.Internal.Typeable a, Test.Goblin.Core.SeedGoblin b, Data.Typeable.Internal.Typeable b) => Test.Goblin.Core.SeedGoblin (Data.Bimap.Bimap a b)
instance (Test.Goblin.Core.SeedGoblin a, Data.Typeable.Internal.Typeable a, Test.Goblin.Core.SeedGoblin b, Data.Typeable.Internal.Typeable b) => Test.Goblin.Core.SeedGoblin (Data.Map.Internal.Map a b)
instance (Test.Goblin.Core.SeedGoblin a, Data.Typeable.Internal.Typeable a) => Test.Goblin.Core.SeedGoblin (Data.Set.Internal.Set a)
instance (Test.Goblin.Core.SeedGoblin a, Data.Typeable.Internal.Typeable a) => Test.Goblin.Core.SeedGoblin (GHC.Maybe.Maybe a)
instance (Test.Goblin.Core.SeedGoblin arg1, Data.Typeable.Internal.Typeable arg1, Test.Goblin.Core.SeedGoblin arg2, Data.Typeable.Internal.Typeable arg2, Test.Goblin.Core.SeedGoblin arg3, Data.Typeable.Internal.Typeable arg3, Test.Goblin.Core.SeedGoblin arg4, Data.Typeable.Internal.Typeable arg4, Test.Goblin.Core.SeedGoblin arg5, Data.Typeable.Internal.Typeable arg5, Test.Goblin.Core.SeedGoblin arg6, Data.Typeable.Internal.Typeable arg6, Test.Goblin.Core.SeedGoblin arg7, Data.Typeable.Internal.Typeable arg7, Test.Goblin.Core.SeedGoblin arg8, Data.Typeable.Internal.Typeable arg8, Test.Goblin.Core.SeedGoblin arg9, Data.Typeable.Internal.Typeable arg9, Test.Goblin.Core.SeedGoblin arg10, Data.Typeable.Internal.Typeable arg10) => Test.Goblin.Core.SeedGoblin (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
instance (Test.Goblin.Core.SeedGoblin arg1, Data.Typeable.Internal.Typeable arg1, Test.Goblin.Core.SeedGoblin arg2, Data.Typeable.Internal.Typeable arg2, Test.Goblin.Core.SeedGoblin arg3, Data.Typeable.Internal.Typeable arg3, Test.Goblin.Core.SeedGoblin arg4, Data.Typeable.Internal.Typeable arg4, Test.Goblin.Core.SeedGoblin arg5, Data.Typeable.Internal.Typeable arg5, Test.Goblin.Core.SeedGoblin arg6, Data.Typeable.Internal.Typeable arg6, Test.Goblin.Core.SeedGoblin arg7, Data.Typeable.Internal.Typeable arg7, Test.Goblin.Core.SeedGoblin arg8, Data.Typeable.Internal.Typeable arg8, Test.Goblin.Core.SeedGoblin arg9, Data.Typeable.Internal.Typeable arg9) => Test.Goblin.Core.SeedGoblin (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
instance (Test.Goblin.Core.SeedGoblin arg1, Data.Typeable.Internal.Typeable arg1, Test.Goblin.Core.SeedGoblin arg2, Data.Typeable.Internal.Typeable arg2, Test.Goblin.Core.SeedGoblin arg3, Data.Typeable.Internal.Typeable arg3, Test.Goblin.Core.SeedGoblin arg4, Data.Typeable.Internal.Typeable arg4, Test.Goblin.Core.SeedGoblin arg5, Data.Typeable.Internal.Typeable arg5, Test.Goblin.Core.SeedGoblin arg6, Data.Typeable.Internal.Typeable arg6, Test.Goblin.Core.SeedGoblin arg7, Data.Typeable.Internal.Typeable arg7, Test.Goblin.Core.SeedGoblin arg8, Data.Typeable.Internal.Typeable arg8) => Test.Goblin.Core.SeedGoblin (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
instance (Test.Goblin.Core.SeedGoblin arg1, Data.Typeable.Internal.Typeable arg1, Test.Goblin.Core.SeedGoblin arg2, Data.Typeable.Internal.Typeable arg2, Test.Goblin.Core.SeedGoblin arg3, Data.Typeable.Internal.Typeable arg3, Test.Goblin.Core.SeedGoblin arg4, Data.Typeable.Internal.Typeable arg4, Test.Goblin.Core.SeedGoblin arg5, Data.Typeable.Internal.Typeable arg5, Test.Goblin.Core.SeedGoblin arg6, Data.Typeable.Internal.Typeable arg6, Test.Goblin.Core.SeedGoblin arg7, Data.Typeable.Internal.Typeable arg7) => Test.Goblin.Core.SeedGoblin (arg1, arg2, arg3, arg4, arg5, arg6, arg7)
instance (Test.Goblin.Core.SeedGoblin arg1, Data.Typeable.Internal.Typeable arg1, Test.Goblin.Core.SeedGoblin arg2, Data.Typeable.Internal.Typeable arg2, Test.Goblin.Core.SeedGoblin arg3, Data.Typeable.Internal.Typeable arg3, Test.Goblin.Core.SeedGoblin arg4, Data.Typeable.Internal.Typeable arg4, Test.Goblin.Core.SeedGoblin arg5, Data.Typeable.Internal.Typeable arg5, Test.Goblin.Core.SeedGoblin arg6, Data.Typeable.Internal.Typeable arg6) => Test.Goblin.Core.SeedGoblin (arg1, arg2, arg3, arg4, arg5, arg6)
instance (Test.Goblin.Core.SeedGoblin arg1, Data.Typeable.Internal.Typeable arg1, Test.Goblin.Core.SeedGoblin arg2, Data.Typeable.Internal.Typeable arg2, Test.Goblin.Core.SeedGoblin arg3, Data.Typeable.Internal.Typeable arg3, Test.Goblin.Core.SeedGoblin arg4, Data.Typeable.Internal.Typeable arg4, Test.Goblin.Core.SeedGoblin arg5, Data.Typeable.Internal.Typeable arg5) => Test.Goblin.Core.SeedGoblin (arg1, arg2, arg3, arg4, arg5)
instance (Test.Goblin.Core.SeedGoblin arg1, Data.Typeable.Internal.Typeable arg1, Test.Goblin.Core.SeedGoblin arg2, Data.Typeable.Internal.Typeable arg2, Test.Goblin.Core.SeedGoblin arg3, Data.Typeable.Internal.Typeable arg3, Test.Goblin.Core.SeedGoblin arg4, Data.Typeable.Internal.Typeable arg4) => Test.Goblin.Core.SeedGoblin (arg1, arg2, arg3, arg4)
instance (Test.Goblin.Core.SeedGoblin arg1, Data.Typeable.Internal.Typeable arg1, Test.Goblin.Core.SeedGoblin arg2, Data.Typeable.Internal.Typeable arg2, Test.Goblin.Core.SeedGoblin arg3, Data.Typeable.Internal.Typeable arg3) => Test.Goblin.Core.SeedGoblin (arg1, arg2, arg3)
instance (Test.Goblin.Core.SeedGoblin arg1, Data.Typeable.Internal.Typeable arg1, Test.Goblin.Core.SeedGoblin arg2, Data.Typeable.Internal.Typeable arg2) => Test.Goblin.Core.SeedGoblin (arg1, arg2)
instance (Test.Goblin.Core.Goblin genome arg, Test.Goblin.Core.AddShrinks arg) => Test.Goblin.Core.Goblin genome (GHC.Real.Ratio arg)
instance (Test.Goblin.Core.Goblin g a, Test.Goblin.Core.AddShrinks a) => Test.Goblin.Core.Goblin g (GHC.Maybe.Maybe a)
instance (Test.Goblin.Core.AddShrinks a, GHC.Classes.Eq a, Test.Goblin.Core.Goblin g a) => Test.Goblin.Core.Goblin g [a]
instance (Test.Goblin.Core.Goblin g a, GHC.Classes.Ord a, Test.Goblin.Core.AddShrinks a) => Test.Goblin.Core.Goblin g (Data.Set.Internal.Set a)
instance (Test.Goblin.Core.Goblin g k, Test.Goblin.Core.Goblin g v, GHC.Classes.Ord k, GHC.Classes.Eq v, Test.Goblin.Core.AddShrinks k, Test.Goblin.Core.AddShrinks v) => Test.Goblin.Core.Goblin g (Data.Map.Internal.Map k v)
instance Test.Goblin.Core.SeedGoblin ()
instance Test.Goblin.Core.SeedGoblin GHC.Types.Bool
instance Test.Goblin.Core.SeedGoblin GHC.Types.Char
instance Test.Goblin.Core.SeedGoblin GHC.Integer.Type.Integer
instance Test.Goblin.Core.SeedGoblin GHC.Natural.Natural
instance Test.Goblin.Core.SeedGoblin GHC.Types.Int
instance Test.Goblin.Core.SeedGoblin GHC.Word.Word8
instance Test.Goblin.Core.SeedGoblin GHC.Word.Word64
instance Test.Goblin.Core.SeedGoblin GHC.Types.Double
instance (Test.Goblin.Core.Goblin genome arg1, Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.Goblin genome arg2, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.Goblin genome arg3, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.Goblin genome arg4, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.Goblin genome arg5, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.Goblin genome arg6, Test.Goblin.Core.AddShrinks arg6, Test.Goblin.Core.Goblin genome arg7, Test.Goblin.Core.AddShrinks arg7, Test.Goblin.Core.Goblin genome arg8, Test.Goblin.Core.AddShrinks arg8, Test.Goblin.Core.Goblin genome arg9, Test.Goblin.Core.AddShrinks arg9, Test.Goblin.Core.Goblin genome arg10, Test.Goblin.Core.AddShrinks arg10, Test.Goblin.Core.Goblin genome arg11, Test.Goblin.Core.AddShrinks arg11) => Test.Goblin.Core.Goblin genome (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
instance (Test.Goblin.Core.Goblin genome arg1, Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.Goblin genome arg2, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.Goblin genome arg3, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.Goblin genome arg4, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.Goblin genome arg5, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.Goblin genome arg6, Test.Goblin.Core.AddShrinks arg6, Test.Goblin.Core.Goblin genome arg7, Test.Goblin.Core.AddShrinks arg7, Test.Goblin.Core.Goblin genome arg8, Test.Goblin.Core.AddShrinks arg8, Test.Goblin.Core.Goblin genome arg9, Test.Goblin.Core.AddShrinks arg9, Test.Goblin.Core.Goblin genome arg10, Test.Goblin.Core.AddShrinks arg10) => Test.Goblin.Core.Goblin genome (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
instance (Test.Goblin.Core.Goblin genome arg1, Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.Goblin genome arg2, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.Goblin genome arg3, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.Goblin genome arg4, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.Goblin genome arg5, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.Goblin genome arg6, Test.Goblin.Core.AddShrinks arg6, Test.Goblin.Core.Goblin genome arg7, Test.Goblin.Core.AddShrinks arg7, Test.Goblin.Core.Goblin genome arg8, Test.Goblin.Core.AddShrinks arg8, Test.Goblin.Core.Goblin genome arg9, Test.Goblin.Core.AddShrinks arg9) => Test.Goblin.Core.Goblin genome (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
instance (Test.Goblin.Core.Goblin genome arg1, Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.Goblin genome arg2, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.Goblin genome arg3, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.Goblin genome arg4, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.Goblin genome arg5, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.Goblin genome arg6, Test.Goblin.Core.AddShrinks arg6, Test.Goblin.Core.Goblin genome arg7, Test.Goblin.Core.AddShrinks arg7, Test.Goblin.Core.Goblin genome arg8, Test.Goblin.Core.AddShrinks arg8) => Test.Goblin.Core.Goblin genome (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
instance (Test.Goblin.Core.Goblin genome arg1, Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.Goblin genome arg2, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.Goblin genome arg3, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.Goblin genome arg4, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.Goblin genome arg5, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.Goblin genome arg6, Test.Goblin.Core.AddShrinks arg6, Test.Goblin.Core.Goblin genome arg7, Test.Goblin.Core.AddShrinks arg7) => Test.Goblin.Core.Goblin genome (arg1, arg2, arg3, arg4, arg5, arg6, arg7)
instance (Test.Goblin.Core.Goblin genome arg1, Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.Goblin genome arg2, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.Goblin genome arg3, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.Goblin genome arg4, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.Goblin genome arg5, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.Goblin genome arg6, Test.Goblin.Core.AddShrinks arg6) => Test.Goblin.Core.Goblin genome (arg1, arg2, arg3, arg4, arg5, arg6)
instance (Test.Goblin.Core.Goblin genome arg1, Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.Goblin genome arg2, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.Goblin genome arg3, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.Goblin genome arg4, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.Goblin genome arg5, Test.Goblin.Core.AddShrinks arg5) => Test.Goblin.Core.Goblin genome (arg1, arg2, arg3, arg4, arg5)
instance (Test.Goblin.Core.Goblin genome arg1, Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.Goblin genome arg2, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.Goblin genome arg3, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.Goblin genome arg4, Test.Goblin.Core.AddShrinks arg4) => Test.Goblin.Core.Goblin genome (arg1, arg2, arg3, arg4)
instance (Test.Goblin.Core.Goblin genome arg1, Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.Goblin genome arg2, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.Goblin genome arg3, Test.Goblin.Core.AddShrinks arg3) => Test.Goblin.Core.Goblin genome (arg1, arg2, arg3)
instance (Test.Goblin.Core.Goblin genome arg1, Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.Goblin genome arg2, Test.Goblin.Core.AddShrinks arg2) => Test.Goblin.Core.Goblin genome (arg1, arg2)
instance Test.Goblin.Core.AddShrinks arg => Test.Goblin.Core.AddShrinks (GHC.Real.Ratio arg)
instance (Test.Goblin.Core.AddShrinks k, GHC.Classes.Ord k, Test.Goblin.Core.AddShrinks v) => Test.Goblin.Core.AddShrinks (Data.Map.Internal.Map k v)
instance Test.Goblin.Core.AddShrinks a => Test.Goblin.Core.AddShrinks [a]
instance (Test.Goblin.Core.AddShrinks a, GHC.Classes.Ord a) => Test.Goblin.Core.AddShrinks (Data.Set.Internal.Set a)
instance Test.Goblin.Core.AddShrinks a => Test.Goblin.Core.AddShrinks (GHC.Maybe.Maybe a)
instance Test.Goblin.Core.GeneOps a => Test.Goblin.Core.Goblin a GHC.Types.Bool
instance Test.Goblin.Core.GeneOps a => Test.Goblin.Core.Goblin a GHC.Types.Char
instance Test.Goblin.Core.GeneOps a => Test.Goblin.Core.Goblin a GHC.Integer.Type.Integer
instance Test.Goblin.Core.GeneOps a => Test.Goblin.Core.Goblin a GHC.Natural.Natural
instance Test.Goblin.Core.GeneOps a => Test.Goblin.Core.Goblin a GHC.Types.Int
instance Test.Goblin.Core.GeneOps a => Test.Goblin.Core.Goblin a GHC.Word.Word64
instance Test.Goblin.Core.GeneOps a => Test.Goblin.Core.Goblin a GHC.Types.Double
instance (Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.AddShrinks arg6, Test.Goblin.Core.AddShrinks arg7, Test.Goblin.Core.AddShrinks arg8, Test.Goblin.Core.AddShrinks arg9, Test.Goblin.Core.AddShrinks arg10, Test.Goblin.Core.AddShrinks arg11) => Test.Goblin.Core.AddShrinks (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11)
instance (Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.AddShrinks arg6, Test.Goblin.Core.AddShrinks arg7, Test.Goblin.Core.AddShrinks arg8, Test.Goblin.Core.AddShrinks arg9, Test.Goblin.Core.AddShrinks arg10) => Test.Goblin.Core.AddShrinks (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
instance (Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.AddShrinks arg6, Test.Goblin.Core.AddShrinks arg7, Test.Goblin.Core.AddShrinks arg8, Test.Goblin.Core.AddShrinks arg9) => Test.Goblin.Core.AddShrinks (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)
instance (Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.AddShrinks arg6, Test.Goblin.Core.AddShrinks arg7, Test.Goblin.Core.AddShrinks arg8) => Test.Goblin.Core.AddShrinks (arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
instance (Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.AddShrinks arg6, Test.Goblin.Core.AddShrinks arg7) => Test.Goblin.Core.AddShrinks (arg1, arg2, arg3, arg4, arg5, arg6, arg7)
instance (Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.AddShrinks arg5, Test.Goblin.Core.AddShrinks arg6) => Test.Goblin.Core.AddShrinks (arg1, arg2, arg3, arg4, arg5, arg6)
instance (Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.AddShrinks arg4, Test.Goblin.Core.AddShrinks arg5) => Test.Goblin.Core.AddShrinks (arg1, arg2, arg3, arg4, arg5)
instance (Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.AddShrinks arg3, Test.Goblin.Core.AddShrinks arg4) => Test.Goblin.Core.AddShrinks (arg1, arg2, arg3, arg4)
instance (Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.AddShrinks arg2, Test.Goblin.Core.AddShrinks arg3) => Test.Goblin.Core.AddShrinks (arg1, arg2, arg3)
instance (Test.Goblin.Core.AddShrinks arg1, Test.Goblin.Core.AddShrinks arg2) => Test.Goblin.Core.AddShrinks (arg1, arg2)
instance Test.Goblin.Core.GeneOps GHC.Types.Bool
instance Test.Goblin.Core.AddShrinks ()
instance Test.Goblin.Core.AddShrinks GHC.Types.Bool
instance Test.Goblin.Core.AddShrinks GHC.Types.Char
instance Test.Goblin.Core.AddShrinks GHC.Types.Double
instance Test.Goblin.Core.AddShrinks GHC.Integer.Type.Integer
instance Test.Goblin.Core.AddShrinks GHC.Natural.Natural
instance Test.Goblin.Core.AddShrinks GHC.Types.Int
instance Test.Goblin.Core.AddShrinks GHC.Word.Word8
instance Test.Goblin.Core.AddShrinks GHC.Word.Word64

module Test.Goblin.Explainer
explainGoblin :: (Goblin Bool s, ToExpr s) => s -> GoblinData Bool -> Maybe (Edit EditExpr, GoblinData Bool)
explainGoblinGen :: (Goblin Bool s, ToExpr s) => Maybe Size -> Maybe Seed -> Gen s -> GoblinData Bool -> Maybe (s, s, Edit EditExpr, GoblinData Bool)
explainGoblinGenFromFile :: (Goblin Bool s, ToExpr s) => Maybe Size -> Maybe Seed -> Gen s -> FilePath -> IO (Maybe (s, s, Edit EditExpr, GoblinData Bool))


-- | The top-level module of Goblins, which re-exports the main
--   functionality.
module Test.Goblin
