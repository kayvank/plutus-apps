-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Convenience functions for Aeson
--   
--   Convenience functions for Aeson.
@package hw-aeson
@version 0.1.8.0

module HaskellWorks.Data.Aeson.Compat
type Key = Key
textToKey :: Text -> Key
keyToText :: Key -> Text
stringToKey :: String -> Key
keyToString :: Key -> String

module HaskellWorks.Data.Aeson
newtype JsonEndo a
JsonEndo :: ([a] -> [a]) -> JsonEndo a
[unJsonEndo] :: JsonEndo a -> [a] -> [a]

-- | For use with language extension DerivingVia. This derivation provides
--   a ToJSON instance that delegates to the ToJsonKeyValues instance.
--   
--   For example:
--   
--   <pre>
--   newtype MyType = MyType
--     { myField :: Text
--     } deriving J.ToJSON via WithJsonKeyValues MyType
--   </pre>
newtype WithJsonKeyValues a
WithJsonKeyValues :: a -> WithJsonKeyValues a
[unWithJsonKeyValues] :: WithJsonKeyValues a -> a

-- | Generate key values from a value of a type. This can be used in
--   conjunction with <a>WithJsonKeyValues</a> to define a <a>ToJSON</a>
--   instance without having to implement both <a>toJSON</a> and
--   <a>toEncoding</a>, thereby reducing boilerplate.
--   
--   For example:
--   
--   <pre>
--   instance ToJsonEncoding MyType where
--     toJsonEncoding sv =
--       [ "my_field" .!= sv ^. #myField
--       ]
--   </pre>
class ToJsonKeyValues a
toJsonKeyValues :: (ToJsonKeyValues a, KeyValue kv, Monoid kv) => a -> [kv]
objectWithoutNulls :: [Pair] -> Value
readJson :: Read a => String -> String -> Parser a

-- | Same as <a>object</a> except used in combination with <a>.?=</a> and
--   <a>.!=</a> instead of <a>.=</a>.
--   
--   For example:
--   
--   <pre>
--   <a>toJSON</a> o = <a>objectEndo</a>
--     [ "mandatory" <a>.!=</a> o <tt>^.</tt> the <tt>"mandatory"
--     , "optional"  <a>.?=</a> o <tt>^.</tt> the </tt>"optional"
--     ]
--   </pre>
objectEndo :: [JsonEndo Pair] -> Value

-- | Render optional fields as missing in JSON output.
(.?=) :: (KeyValue p, ToJSON v, Monoid p) => Key -> Maybe v -> p
infixr 7 .?=

-- | Same as <a>.=</a>, but with lower precedence to work well with lens.
(.!=) :: (KeyValue kv, ToJSON v) => Key -> v -> kv
infixr 7 .!=
instance GHC.Base.Monoid (HaskellWorks.Data.Aeson.JsonEndo a)
instance GHC.Base.Semigroup (HaskellWorks.Data.Aeson.JsonEndo a)
instance HaskellWorks.Data.Aeson.ToJsonKeyValues a => Data.Aeson.Types.ToJSON.ToJSON (HaskellWorks.Data.Aeson.WithJsonKeyValues a)
instance Data.Aeson.Types.ToJSON.KeyValue a => Data.Aeson.Types.ToJSON.KeyValue (HaskellWorks.Data.Aeson.JsonEndo a)

module HaskellWorks.Data.Aeson.Compat.Map.V1
type KeyMap v = HashMap Text v
type Key = Text
foldlWithKey :: (a -> Key -> b -> a) -> a -> KeyMap b -> a
foldlWithKey' :: (a -> Key -> b -> a) -> a -> KeyMap b -> a
null :: KeyMap v -> Bool
lookup :: Key -> KeyMap v -> Maybe v
size :: KeyMap v -> Int
member :: Key -> KeyMap v -> Bool
empty :: KeyMap v
singleton :: Key -> v -> KeyMap v
insert :: Key -> v -> KeyMap v -> KeyMap v
delete :: Key -> KeyMap v -> KeyMap v
alterF :: Functor f => (Maybe v -> f (Maybe v)) -> Key -> KeyMap v -> f (KeyMap v)
difference :: KeyMap v -> KeyMap v' -> KeyMap v
union :: KeyMap v -> KeyMap v -> KeyMap v
unionWith :: (v -> v -> v) -> KeyMap v -> KeyMap v -> KeyMap v
unionWithKey :: (Key -> v -> v -> v) -> KeyMap v -> KeyMap v -> KeyMap v
intersection :: KeyMap a -> KeyMap b -> KeyMap a
intersectionWith :: (a -> b -> c) -> KeyMap a -> KeyMap b -> KeyMap c
intersectionWithKey :: (Key -> a -> b -> c) -> KeyMap a -> KeyMap b -> KeyMap c
fromList :: [(Key, v)] -> KeyMap v
fromListWith :: (v -> v -> v) -> [(Key, v)] -> KeyMap v
toList :: KeyMap v -> [(Key, v)]
toAscList :: KeyMap v -> [(Key, v)]
elems :: KeyMap v -> [v]
fromHashMap :: HashMap Key v -> KeyMap v
toHashMap :: KeyMap v -> HashMap Key v
fromHashMapText :: HashMap Text v -> KeyMap v
toHashMapText :: KeyMap v -> HashMap Text v
fromMap :: Map Key v -> KeyMap v
toMap :: KeyMap v -> Map Key v
fromMapText :: Map Text v -> KeyMap v
toMapText :: KeyMap v -> Map Text v
map :: (a -> b) -> KeyMap a -> KeyMap b
mapWithKey :: (Key -> a -> b) -> KeyMap a -> KeyMap b
traverseWithKey :: Applicative f => (Key -> v1 -> f v2) -> KeyMap v1 -> f (KeyMap v2)
foldr :: (a -> b -> b) -> b -> KeyMap a -> b
foldr' :: (a -> b -> b) -> b -> KeyMap a -> b
foldl :: (b -> a -> b) -> b -> KeyMap a -> b
foldl' :: (b -> a -> b) -> b -> KeyMap a -> b
foldMapWithKey :: Monoid m => (Key -> a -> m) -> KeyMap a -> m
foldrWithKey :: (Key -> v -> a -> a) -> a -> KeyMap v -> a
keys :: KeyMap v -> [Key]
filter :: (v -> Bool) -> KeyMap v -> KeyMap v
filterWithKey :: (Key -> v -> Bool) -> KeyMap v -> KeyMap v
mapMaybe :: (a -> Maybe b) -> KeyMap a -> KeyMap b
mapMaybeWithKey :: (Key -> v -> Maybe u) -> KeyMap v -> KeyMap u

module HaskellWorks.Data.Aeson.Compat.Map.V2
type KeyMap v = KeyMap v
type Key = Key
foldlWithKey :: (a -> Key -> b -> a) -> a -> KeyMap b -> a
foldlWithKey' :: (a -> Key -> b -> a) -> a -> KeyMap b -> a
null :: KeyMap v -> Bool
lookup :: Key -> KeyMap v -> Maybe v
size :: KeyMap v -> Int
member :: Key -> KeyMap v -> Bool
empty :: KeyMap v
singleton :: Key -> v -> KeyMap v
insert :: Key -> v -> KeyMap v -> KeyMap v
delete :: Key -> KeyMap v -> KeyMap v
alterF :: Functor f => (Maybe v -> f (Maybe v)) -> Key -> KeyMap v -> f (KeyMap v)
difference :: KeyMap v -> KeyMap v' -> KeyMap v
union :: KeyMap v -> KeyMap v -> KeyMap v
unionWith :: (v -> v -> v) -> KeyMap v -> KeyMap v -> KeyMap v
unionWithKey :: (Key -> v -> v -> v) -> KeyMap v -> KeyMap v -> KeyMap v
intersection :: KeyMap a -> KeyMap b -> KeyMap a
intersectionWith :: (a -> b -> c) -> KeyMap a -> KeyMap b -> KeyMap c
intersectionWithKey :: (Key -> a -> b -> c) -> KeyMap a -> KeyMap b -> KeyMap c
fromList :: [(Key, v)] -> KeyMap v
fromListWith :: (v -> v -> v) -> [(Key, v)] -> KeyMap v
toList :: KeyMap v -> [(Key, v)]
toAscList :: KeyMap v -> [(Key, v)]
elems :: KeyMap v -> [v]
fromHashMap :: HashMap Key v -> KeyMap v
toHashMap :: KeyMap v -> HashMap Key v
fromHashMapText :: HashMap Text v -> KeyMap v
toHashMapText :: KeyMap v -> HashMap Text v
fromMap :: Map Key v -> KeyMap v
toMap :: KeyMap v -> Map Key v
fromMapText :: Map Text v -> KeyMap v
toMapText :: KeyMap v -> Map Text v
map :: (a -> b) -> KeyMap a -> KeyMap b
mapWithKey :: (Key -> a -> b) -> KeyMap a -> KeyMap b
traverseWithKey :: Applicative f => (Key -> v1 -> f v2) -> KeyMap v1 -> f (KeyMap v2)
foldr :: (a -> b -> b) -> b -> KeyMap a -> b
foldr' :: (a -> b -> b) -> b -> KeyMap a -> b
foldl :: (b -> a -> b) -> b -> KeyMap a -> b
foldl' :: (b -> a -> b) -> b -> KeyMap a -> b
foldMapWithKey :: Monoid m => (Key -> a -> m) -> KeyMap a -> m
foldrWithKey :: (Key -> v -> a -> a) -> a -> KeyMap v -> a
keys :: KeyMap v -> [Key]
filter :: (v -> Bool) -> KeyMap v -> KeyMap v
filterWithKey :: (Key -> v -> Bool) -> KeyMap v -> KeyMap v
mapMaybe :: (a -> Maybe b) -> KeyMap a -> KeyMap b
mapMaybeWithKey :: (Key -> v -> Maybe u) -> KeyMap v -> KeyMap u

module HaskellWorks.Data.Aeson.Compat.Map
