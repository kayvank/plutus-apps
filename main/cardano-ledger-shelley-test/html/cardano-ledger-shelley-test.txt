-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Test helpers from cardano-ledger-shelley exposed to other packages
@package cardano-ledger-shelley-test
@version 0.1.0.0


-- | Fake implementation of VRF, where the random value isn't random but
--   given by the creator.
module Test.Cardano.Crypto.VRF.Fake
data FakeVRF
data family VerKeyVRF v
data family SignKeyVRF v
data WithResult a
WithResult :: !a -> !Word64 -> WithResult a
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.CertVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.CertVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Classes.Ord (Cardano.Crypto.VRF.Class.CertVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.CertVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.CertVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.SignKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Classes.Ord (Cardano.Crypto.VRF.Class.SignKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.SignKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.SignKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.SignKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance NoThunks.Class.NoThunks (Cardano.Crypto.VRF.Class.VerKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Classes.Ord (Cardano.Crypto.VRF.Class.VerKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Classes.Eq (Cardano.Crypto.VRF.Class.VerKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Generics.Generic (Cardano.Crypto.VRF.Class.VerKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Show.Show (Cardano.Crypto.VRF.Class.VerKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance GHC.Show.Show a => GHC.Show.Show (Test.Cardano.Crypto.VRF.Fake.WithResult a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Test.Cardano.Crypto.VRF.Fake.WithResult a)
instance Cardano.Binary.ToCBOR.ToCBOR a => Test.Cardano.Crypto.VRF.Fake.SneakilyContainResult (Test.Cardano.Crypto.VRF.Fake.WithResult a)
instance Test.Cardano.Crypto.VRF.Fake.SneakilyContainResult Cardano.Ledger.BaseTypes.Seed
instance Cardano.Crypto.VRF.Class.VRFAlgorithm Test.Cardano.Crypto.VRF.Fake.FakeVRF
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.VerKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.VerKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.SignKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.SignKeyVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Crypto.VRF.Class.CertVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Crypto.VRF.Class.CertVRF Test.Cardano.Crypto.VRF.Fake.FakeVRF)

module Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes

-- | Mocking constraints used in generators
type Mock c = (PraosCrypto c, Signable (KES c) ~ SignableRepresentation, Signable (DSIGN c) ~ SignableRepresentation, Signable (VRF c) Seed)

-- | Additional mocking constraints used in examples.
type ExMock c = (Mock c, Num (SignKeyDSIGN (DSIGN c)), Num (VerKeyDSIGN (DSIGN c)), VRF c ~ FakeVRF)
data C_Crypto
type C = ShelleyEra C_Crypto
type TestCrypto = C_Crypto

-- | The same crypto used on the net
data StandardCrypto
instance Cardano.Ledger.Crypto.Crypto Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.C_Crypto
instance Cardano.Protocol.TPraos.API.PraosCrypto Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.C_Crypto

module Test.Cardano.Ledger.Shelley.ByronTranslation
testGroupByronTranslation :: TestTree
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Chain.UTxO.Compact.CompactTxOut

module Test.Cardano.Ledger.Shelley.Generator.Constants
data Constants
Constants :: Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Word64 -> Word64 -> Word64 -> Integer -> Integer -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Word64 -> Natural -> Natural -> Word64 -> Integer -> Integer -> Integer -> Integer -> Natural -> Int -> Int -> Constants

-- | minimal number of transaction inputs to select
[minNumGenInputs] :: Constants -> Int

-- | maximal number of transaction inputs to select
[maxNumGenInputs] :: Constants -> Int

-- | Relative frequency of generated credential registration certificates
[frequencyRegKeyCert] :: Constants -> Int

-- | Relative frequency of generated pool registration certificates
[frequencyRegPoolCert] :: Constants -> Int

-- | Relative frequency of generated delegation certificates
[frequencyDelegationCert] :: Constants -> Int

-- | Relative frequency of generated genesis delegation certificates
[frequencyGenesisDelegationCert] :: Constants -> Int

-- | Relative frequency of generated credential de-registration
--   certificates
[frequencyDeRegKeyCert] :: Constants -> Int

-- | Relative frequency of generated pool retirement certificates
[frequencyRetirePoolCert] :: Constants -> Int

-- | Relative frequency of generated MIR certificates
[frequencyMIRCert] :: Constants -> Int

-- | Relative frequency of script credentials in credential registration
--   certificates
[frequencyScriptCredReg] :: Constants -> Int

-- | Relative frequency of key credentials in credential registration
--   certificates
[frequencyKeyCredReg] :: Constants -> Int

-- | Relative frequency of script credentials in credential de-registration
--   certificates
[frequencyScriptCredDeReg] :: Constants -> Int

-- | Relative frequency of key credentials in credential de-registration
--   certificates
[frequencyKeyCredDeReg] :: Constants -> Int

-- | Relative frequency of script credentials in credential delegation
--   certificates
[frequencyScriptCredDelegation] :: Constants -> Int

-- | Relative frequency of key credentials in credential delegation
--   certificates
[frequencyKeyCredDelegation] :: Constants -> Int

-- | Relative frequency of Prototol/Application Updates in a transaction
[frequencyTxUpdates] :: Constants -> Int

-- | Relative frequency of Metadata in a transaction
[frequencyTxWithMetadata] :: Constants -> Int

-- | minimal number of genesis UTxO outputs
[minGenesisUTxOouts] :: Constants -> Int

-- | maximal number of genesis UTxO outputs
[maxGenesisUTxOouts] :: Constants -> Int

-- | maximal number of certificates per transaction
[maxCertsPerTx] :: Constants -> Word64

-- | maximal number of Txs per block
[maxTxsPerBlock] :: Constants -> Word64

-- | maximal numbers of generated keypairs
[maxNumKeyPairs] :: Constants -> Word64

-- | minimal coin value for generated genesis outputs
[minGenesisOutputVal] :: Constants -> Integer

-- | maximal coin value for generated genesis outputs
[maxGenesisOutputVal] :: Constants -> Integer

-- | Number of base scripts from which multi sig scripts are built.
[numBaseScripts] :: Constants -> Int

-- | Number of simple scripts which appear in the choices, the remainder
--   are compound (MofN, All, Any, etc.) scripts
[numSimpleScripts] :: Constants -> Int

-- | Relative frequency that a transaction does not include any reward
--   withdrawals
[frequencyNoWithdrawals] :: Constants -> Int

-- | Relative frequency that a transaction includes a small number of
--   reward withdrawals, bounded by <a>maxAFewWithdrawals</a>.
[frequencyAFewWithdrawals] :: Constants -> Int

-- | Maximum number of reward withdrawals that counts as a small number.
[maxAFewWithdrawals] :: Constants -> Int

-- | Relative frequency that a transaction includes any positive number of
--   reward withdrawals
[frequencyPotentiallyManyWithdrawals] :: Constants -> Int

-- | Minimal slot for CHAIN trace generation.
[minSlotTrace] :: Constants -> Int

-- | Maximal slot for CHAIN trace generation.
[maxSlotTrace] :: Constants -> Int

-- | Lower bound of the MaxEpoch protocol parameter
[frequencyLowMaxEpoch] :: Constants -> Word64
[maxMinFeeA] :: Constants -> Natural
[maxMinFeeB] :: Constants -> Natural
[numCoreNodes] :: Constants -> Word64
[minTreasury] :: Constants -> Integer
[maxTreasury] :: Constants -> Integer
[minReserves] :: Constants -> Integer
[maxReserves] :: Constants -> Integer
[minMajorPV] :: Constants -> Natural

-- | When generating Tx, we want the UTxO size to fluctuate around this
--   point. If it gets too small, we can't balance the fee, too large it
--   gets too complicated.
[genTxStableUtxoSize] :: Constants -> Int

-- | If we need to grow the Utxo when generating a Tx, how much should it
--   grow by.
[genTxUtxoIncrement] :: Constants -> Int
defaultConstants :: Constants
instance GHC.Show.Show Test.Cardano.Ledger.Shelley.Generator.Constants.Constants

module Test.Cardano.Ledger.Shelley.Generator.Metadata

-- | Generate Metadata (and compute hash) with frequency
--   <a>frequencyTxWithMetadata</a>
genMetadata :: Constants -> Gen (StrictMaybe (Metadata era))

-- | Generate Metadata (and compute hash) of size up to
--   <a>metadataMaxSize</a>
genMetadata' :: Gen (Metadata era)

module Test.Cardano.Ledger.Shelley.LaxBlock

-- | A block in which we do not validate the matched encoding of parts of
--   the segwit. This is only for testing.
newtype LaxBlock h era
LaxBlock :: Block h era -> LaxBlock h era
blockDecoder :: (BlockAnn era, TxSeq era ~ TxSeq era, FromCBOR (Annotator h)) => Bool -> forall s. Decoder s (Annotator (Block h era))
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Era.TxSeq era), GHC.Show.Show h) => GHC.Show.Show (Test.Cardano.Ledger.Shelley.LaxBlock.LaxBlock h era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable era, Data.Typeable.Internal.Typeable h) => Cardano.Binary.ToCBOR.ToCBOR (Test.Cardano.Ledger.Shelley.LaxBlock.LaxBlock h era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable h, Cardano.Ledger.Block.BlockAnn era, Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Era.TxSeq era GHC.Types.~ Cardano.Ledger.Shelley.BlockChain.TxSeq era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator h)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Test.Cardano.Ledger.Shelley.LaxBlock.LaxBlock h era))

module Test.Cardano.Ledger.Shelley.Rules.Chain
data CHAIN era
data ChainState era
ChainState :: NewEpochState era -> Map (KeyHash 'BlockIssuer (Crypto era)) Word64 -> Nonce -> Nonce -> Nonce -> Nonce -> WithOrigin (LastAppliedBlock (Crypto era)) -> ChainState era
[chainNes] :: ChainState era -> NewEpochState era
[chainOCertIssue] :: ChainState era -> Map (KeyHash 'BlockIssuer (Crypto era)) Word64
[chainEpochNonce] :: ChainState era -> Nonce
[chainEvolvingNonce] :: ChainState era -> Nonce
[chainCandidateNonce] :: ChainState era -> Nonce
[chainPrevEpochNonce] :: ChainState era -> Nonce
[chainLastAppliedBlock] :: ChainState era -> WithOrigin (LastAppliedBlock (Crypto era))
data TestChainPredicateFailure era
RealChainPredicateFailure :: !ChainPredicateFailure -> TestChainPredicateFailure era
BbodyFailure :: !PredicateFailure (EraRule "BBODY" era) -> TestChainPredicateFailure era
TickFailure :: !PredicateFailure (EraRule "TICK" era) -> TestChainPredicateFailure era
TicknFailure :: !PredicateFailure (EraRule "TICKN" era) -> TestChainPredicateFailure era
PrtclFailure :: !PredicateFailure (PRTCL (Crypto era)) -> TestChainPredicateFailure era
PrtclSeqFailure :: !PrtlSeqFailure (Crypto era) -> TestChainPredicateFailure era
data ChainEvent era
BbodyEvent :: !Event (EraRule "BBODY" era) -> ChainEvent era
TickEvent :: !Event (EraRule "TICK" era) -> ChainEvent era
TicknEvent :: !Event (EraRule "TICKN" era) -> ChainEvent era
PrtclEvent :: !Event (PRTCL (Crypto era)) -> ChainEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data AdaPots
AdaPots :: Coin -> Coin -> Coin -> Coin -> Coin -> Coin -> AdaPots
[treasuryAdaPot] :: AdaPots -> Coin
[reservesAdaPot] :: AdaPots -> Coin
[rewardsAdaPot] :: AdaPots -> Coin
[utxoAdaPot] :: AdaPots -> Coin
[depositsAdaPot] :: AdaPots -> Coin
[feesAdaPot] :: AdaPots -> Coin

-- | Creates a valid initial chain state
initialShelleyState :: (Era era, Default (State (EraRule "PPUP" era)), Default (StashedAVVMAddresses era)) => WithOrigin (LastAppliedBlock (Crypto era)) -> EpochNo -> UTxO era -> Coin -> Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era)) -> PParams era -> Nonce -> ChainState era

-- | Calculate the total ada in the chain state
totalAda :: UsesValue era => ChainState era -> Coin

-- | Calculate the total ada pots in the chain state
totalAdaPots :: UsesValue era => ChainState era -> AdaPots
instance GHC.Generics.Generic (Test.Cardano.Ledger.Shelley.Rules.Chain.ChainState era)
instance GHC.Generics.Generic (Test.Cardano.Ledger.Shelley.Rules.Chain.TestChainPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.NewEpochState era) => GHC.Show.Show (Test.Cardano.Ledger.Shelley.Rules.Chain.ChainState era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.NewEpochState era) => GHC.Classes.Eq (Test.Cardano.Ledger.Shelley.Rules.Chain.ChainState era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "BBODY" era)), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICK" era)), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICKN" era))) => GHC.Show.Show (Test.Cardano.Ledger.Shelley.Rules.Chain.TestChainPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "BBODY" era)), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICK" era)), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICKN" era))) => GHC.Classes.Eq (Test.Cardano.Ledger.Shelley.Rules.Chain.TestChainPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "BBODY" era) (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "BBODY" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Bbody.BbodyEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "BBODY" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Bbody.BbodyState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "BBODY" era) GHC.Types.~ Cardano.Ledger.Block.Block (Cardano.Ledger.BHeaderView.BHeaderView (Cardano.Ledger.Era.Crypto era)) era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "TICKN" era) (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "TICKN" era) GHC.Types.~ Cardano.Protocol.TPraos.Rules.Tickn.TicknEnv, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "TICKN" era) GHC.Types.~ Cardano.Protocol.TPraos.Rules.Tickn.TicknState, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "TICKN" era) GHC.Types.~ GHC.Types.Bool, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "TICK" era) (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "TICK" era) GHC.Types.~ (), Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "TICK" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.NewEpochState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "TICK" era) GHC.Types.~ Cardano.Slotting.Slot.SlotNo, Control.State.Transition.Extended.Embed (Cardano.Protocol.TPraos.Rules.Prtcl.PRTCL (Cardano.Ledger.Era.Crypto era)) (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era), GHC.Records.HasField "_maxBHSize" (Cardano.Ledger.Core.PParams era) GHC.Natural.Natural, GHC.Records.HasField "_maxBBSize" (Cardano.Ledger.Core.PParams era) GHC.Natural.Natural, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.ProtVer, GHC.Records.HasField "_extraEntropy" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.Nonce, GHC.Records.HasField "_d" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.UnitInterval, Cardano.Ledger.Serialization.ToCBORGroup (Cardano.Ledger.Era.TxSeq era)) => Control.State.Transition.Extended.STS (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Bbody.BBODY era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "BBODY" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Bbody.BbodyPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "BBODY" era) GHC.Types.~ Control.State.Transition.Extended.Event (Cardano.Ledger.Shelley.Rules.Bbody.BBODY era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Bbody.BBODY era) (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICKN" era) GHC.Types.~ Cardano.Protocol.TPraos.Rules.Tickn.TicknPredicateFailure, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "TICKN" era) GHC.Types.~ Data.Void.Void) => Control.State.Transition.Extended.Embed Cardano.Protocol.TPraos.Rules.Tickn.TICKN (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Tick.TICK era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICK" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Tick.TickPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "TICK" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Tick.TickEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Tick.TICK era) (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era)
instance (Cardano.Ledger.Era.Era era, c GHC.Types.~ Cardano.Ledger.Era.Crypto era, Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Protocol.TPraos.Rules.Prtcl.PRTCL c)) => Control.State.Transition.Extended.Embed (Cardano.Protocol.TPraos.Rules.Prtcl.PRTCL c) (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "BBODY" era)), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICK" era)), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICKN" era))) => NoThunks.Class.NoThunks (Test.Cardano.Ledger.Shelley.Rules.Chain.TestChainPredicateFailure era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.NewEpochState era) => Control.DeepSeq.NFData (Test.Cardano.Ledger.Shelley.Rules.Chain.ChainState era)
instance Cardano.Ledger.Pretty.CanPrettyPrintLedgerState era => Cardano.Ledger.Pretty.PrettyA (Test.Cardano.Ledger.Shelley.Rules.Chain.ChainState era)

module Test.Cardano.Ledger.Shelley.Rules.TestDeleg

-- | Check stake key registration
keyRegistration :: SourceSignalTarget (DELEG era) -> Property

-- | Check stake key de-registration
keyDeRegistration :: SourceSignalTarget (DELEG era) -> Property

-- | Check stake key delegation
keyDelegation :: SourceSignalTarget (DELEG era) -> Property

-- | Check that the sum of rewards does not change and that each element
--   that is either removed or added has a zero balance.
rewardsSumInvariant :: SourceSignalTarget (DELEG era) -> Property
checkInstantaneousRewards :: HasField "_protocolVersion" (PParams era) ProtVer => DelegEnv era -> SourceSignalTarget (DELEG era) -> Property

module Test.Cardano.Ledger.Shelley.Rules.TestPool
poolRegistration :: SourceSignalTarget (POOL era) -> Property
poolStateIsInternallyConsistent :: PState crypto -> Property
poolRetirement :: EpochNo -> EpochNo -> SourceSignalTarget (POOL era) -> Property

module Test.Cardano.Ledger.Shelley.Rules.TestPoolreap

-- | Check that after a POOLREAP certificate transition the pool is removed
--   from the stake pool and retiring maps.
removedAfterPoolreap :: forall crypto. PState crypto -> PState crypto -> EpochNo -> Property

module Test.Cardano.Ledger.Shelley.Serialisation.CDDLUtils
cddlTest :: forall a. (ToCBOR a, FromCBOR a, Show a, HasCallStack) => Int -> ByteString -> IO ByteString -> TestTree
cddlAnnotatorTest :: forall a. (ToCBOR a, FromCBOR (Annotator a), Show a, HasCallStack) => Int -> ByteString -> IO ByteString -> TestTree

-- | Round trip test for a type t with instances: ToCBORGroup t
--   FromCBORGRoup t
cddlGroupTest :: forall a. (ToCBORGroup a, FromCBORGroup a, Show a, HasCallStack) => Int -> ByteString -> IO ByteString -> TestTree
cddlTestCommon :: (Show a, HasCallStack) => (a -> ByteString) -> (ByteString -> Either DecoderError a) -> Int -> ByteString -> IO ()
instance GHC.Show.Show Test.Cardano.Ledger.Shelley.Serialisation.CDDLUtils.StdErr
instance GHC.Exception.Type.Exception Test.Cardano.Ledger.Shelley.Serialisation.CDDLUtils.StdErr

module Test.Cardano.Ledger.Shelley.Serialisation.Generators.Bootstrap
genBootstrapAddress :: Gen (BootstrapAddress crypto)
genSignature :: forall a b. DSIGNAlgorithm a => Gen (SignedDSIGN a b)

module Test.Cardano.Ledger.Shelley.Serialisation.GoldenUtils
checkEncoding :: (HasCallStack, Show a, Eq a) => (a -> Encoding) -> (ByteString -> Either DecoderError a) -> String -> a -> ToTokens -> TestTree
checkEncodingCBOR :: (HasCallStack, FromCBOR a, ToCBOR a, Show a, Eq a) => String -> a -> ToTokens -> TestTree
checkEncodingCBORAnnotated :: (HasCallStack, FromCBOR (Annotator a), ToCBOR a, Show a, Eq a) => String -> a -> ToTokens -> TestTree
data ToTokens
[T] :: (Tokens -> Tokens) -> ToTokens
[S] :: ToCBOR a => a -> ToTokens
[G] :: ToCBORGroup a => a -> ToTokens
[Plus] :: ToTokens -> ToTokens -> ToTokens
instance Cardano.Binary.ToCBOR.ToCBOR Test.Cardano.Ledger.Shelley.Serialisation.GoldenUtils.ToTokens
instance GHC.Base.Semigroup Test.Cardano.Ledger.Shelley.Serialisation.GoldenUtils.ToTokens
instance GHC.Base.Monoid Test.Cardano.Ledger.Shelley.Serialisation.GoldenUtils.ToTokens

module Test.Cardano.Ledger.Shelley.Utils

-- | Construct a seed from a bunch of Word64s
--   
--   We multiply these words by some extra stuff to make sure they contain
--   enough bits for our seed.
mkSeedFromWords :: RawSeed -> Seed

-- | For testing purposes, create a VRF value
mkCertifiedVRF :: (Signable v a, VRFAlgorithm v, ContextVRF v ~ (), Coercible b (CertifiedVRF v a)) => a -> SignKeyVRF v -> b
epochFromSlotNo :: SlotNo -> EpochNo

-- | Try to evolve KES key until specific KES period is reached, given the
--   current KES period.
evolveKESUntil :: (KESAlgorithm v, ContextKES v ~ ()) => SignKeyKES v -> KESPeriod -> KESPeriod -> Maybe (SignKeyKES v)
slotFromEpoch :: EpochNo -> SlotNo
epochSize :: EpochNo -> EpochSize
mkHash :: forall a h. HashAlgorithm h => Int -> Hash h a

-- | For testing purposes, generate a deterministic key pair given a seed.
mkKeyPair :: forall crypto kd. DSIGNAlgorithm (DSIGN crypto) => RawSeed -> (SignKeyDSIGN (DSIGN crypto), VKey kd crypto)

-- | For testing purposes, generate a deterministic key pair given a seed.
mkKeyPair' :: DSIGNAlgorithm (DSIGN crypto) => RawSeed -> KeyPair kd crypto

-- | For testing purposes, generate a deterministic genesis key pair given
--   a seed.
mkGenKey :: DSIGNAlgorithm (DSIGN crypto) => RawSeed -> (SignKeyDSIGN (DSIGN crypto), VKey kd crypto)

-- | For testing purposes, generate a deterministic KES key pair given a
--   seed.
mkKESKeyPair :: KESAlgorithm v => RawSeed -> (SignKeyKES v, VerKeyKES v)

-- | For testing purposes, generate a deterministic VRF key pair given a
--   seed.
mkVRFKeyPair :: VRFAlgorithm v => RawSeed -> (SignKeyVRF v, VerKeyVRF v)
mkAddr :: Crypto crypto => (KeyPair 'Payment crypto, KeyPair 'Staking crypto) -> Addr crypto
runShelleyBase :: ShelleyBase a -> a
testGlobals :: Globals
maxKESIterations :: Word64

-- | Convert to a bounded rational type why throwing an error on failure
unsafeBoundRational :: (HasCallStack, BoundedRational r) => Rational -> r
slotsPerKESIteration :: Word64
testSTS :: forall s. (BaseM s ~ ShelleyBase, STS s, Eq (State s), Show (State s)) => Environment s -> State s -> Signal s -> Either [PredicateFailure s] (State s) -> Assertion
maxLLSupply :: Coin

-- | Apply STS checking assertions.
applySTSTest :: forall s m (rtype :: RuleType). (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> m (Either [PredicateFailure s] (State s))
type GenesisKeyPair crypto = KeyPair 'Genesis crypto
getBlockNonce :: forall era. Era era => Block (BHeader (Crypto era)) era -> Nonce
type ShelleyTest era = (UsesTxBody era, UsesValue era, UsesTxOut era, UsesScript era, UsesAuxiliary era, UsesPParams era, Tx era ~ Tx era, TxSeq era ~ TxSeq era, TxOut era ~ TxOut era, PParams era ~ PParams era, PParamsDelta era ~ PParamsUpdate era, Witnesses era ~ WitnessSet era, Split (Value era), Default (State (EraRule "PPUP" era)), Default (StashedAVVMAddresses era), AnnotatedData (Witnesses era))
type ChainProperty era = (UsesTxOut era, UsesPParams era, UsesValue era, UsesTxBody era, UsesAuxiliary era, Mock (Crypto era), ApplyBlock era, GetLedgerView era, Show (Tx era), Eq (Tx era))
class Split v
vsplit :: Split v => v -> Integer -> ([v], Coin)
data RawSeed
RawSeed :: !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> RawSeed
instance GHC.Show.Show Test.Cardano.Ledger.Shelley.Utils.RawSeed
instance GHC.Classes.Eq Test.Cardano.Ledger.Shelley.Utils.RawSeed
instance Test.QuickCheck.Arbitrary.Arbitrary Test.Cardano.Ledger.Shelley.Utils.RawSeed
instance Cardano.Binary.ToCBOR.ToCBOR Test.Cardano.Ledger.Shelley.Utils.RawSeed
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm (Cardano.Ledger.Crypto.DSIGN crypto) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Keys.KeyPair kd crypto)

module Test.Cardano.Ledger.Shelley.Shrinkers
shrinkBlock :: Block h era -> [Block h era]
shrinkTx :: forall era. (ShelleyTest era, TxBody era ~ TxBody era) => Tx era -> [Tx era]
shrinkTxBody :: forall era. ShelleyTest era => TxBody era -> [TxBody era]
outputBalance :: ShelleyTest era => StrictSeq (TxOut era) -> Value era
shrinkTxIn :: TxIn crypto -> [TxIn crypto]
shrinkTxOut :: ShelleyTest era => TxOut era -> [TxOut era]
shrinkCoin :: Coin -> [Coin]
shrinkDCert :: DCert crypto -> [DCert crypto]
shrinkWdrl :: Wdrl crypto -> [Wdrl crypto]
shrinkRewardAcnt :: RewardAcnt crypto -> [RewardAcnt crypto]
shrinkSlotNo :: SlotNo -> [SlotNo]
shrinkUpdate :: Update era -> [Update era]
shrinkWitVKey :: WitVKey kr crypto -> [WitVKey kr crypto]
shrinkScriptHash :: ScriptHash crypto -> [ScriptHash crypto]
shrinkMultiSig :: MultiSig crypto -> [MultiSig crypto]
shrinkSet :: Ord a => (a -> [a]) -> Set a -> [Set a]
shrinkSeq :: (a -> [a]) -> Seq a -> [Seq a]
shrinkStrictSeq :: (a -> [a]) -> StrictSeq a -> [StrictSeq a]
shrinkMap :: Ord k => (k -> [k]) -> (v -> [v]) -> Map k v -> [Map k v]

module Test.Cardano.Ledger.Shelley.Serialisation.Generators.Genesis
genShelleyGenesis :: Era era => Gen (ShelleyGenesis era)
genStaking :: Crypto crypto => Gen (ShelleyGenesisStaking crypto)
genPools :: Crypto crypto => Gen [(KeyHash 'StakePool crypto, PoolParams crypto)]
genStake :: Crypto crypto => Gen [(KeyHash 'Staking crypto, KeyHash 'StakePool crypto)]
genPoolParams :: forall crypto. Crypto crypto => Gen (PoolParams crypto)
genStakePoolRelay :: Gen StakePoolRelay
genStrictMaybe :: Gen a -> Gen (StrictMaybe a)
genDnsName :: Gen DnsName
genPoolMetadata :: Gen PoolMetadata
genPort :: Gen Port
genUrl :: Gen Url
genRewardAcnt :: Crypto crypto => Gen (RewardAcnt crypto)
genCredential :: Crypto crypto => Gen (Credential 'Staking crypto)
genHash :: HashAlgorithm v => Gen (Hash v a)
genWords :: Natural -> Gen [Word8]
genPParams :: Gen (PParams era)
genNatural :: Range Natural -> Gen Natural
genRational :: Gen Rational
genEpochNo :: Gen EpochNo
genMinUTxOValue :: Gen Coin
genNonce :: Gen Nonce
genProtVer :: Gen ProtVer
genUnitInterval :: Gen UnitInterval
genPositiveUnitInterval :: Gen PositiveUnitInterval
genNonNegativeInterval :: Gen NonNegativeInterval

-- | Only numbers in Scientific format can roundtrip JSON, so we generate
--   numbers that can be represented in both decimal form and some bounded
--   type rational form.
genDecimalBoundedRational :: (Integral a, BoundedRational r) => (a -> Gen a) -> Gen r
genGenesisDelegationList :: Crypto crypto => Gen [(KeyHash 'Genesis crypto, GenDelegPair crypto)]
genGenesisDelegationPair :: forall crypto. Crypto crypto => Gen (KeyHash 'Genesis crypto, GenDelegPair crypto)
genVRFKeyHash :: forall crypto. Crypto crypto => Gen (Hash crypto (VerKeyVRF (VRF crypto)))
genVRFKeyPair :: forall crypto. Crypto crypto => Gen (SignKeyVRF (VRF crypto), VerKeyVRF (VRF crypto))
genFundsList :: Crypto crypto => Gen [(Addr crypto, Coin)]
genSeed :: Int -> Gen Seed
genKeyHash :: Crypto crypto => Gen (KeyHash disc crypto)

-- | Generate a deterministic key pair given a seed.
genKeyPair :: forall crypto krole. DSIGNAlgorithm (DSIGN crypto) => Gen (SignKeyDSIGN (DSIGN crypto), VKey krole crypto)
genGenesisFundPair :: Crypto crypto => Gen (Addr crypto, Coin)
genAddress :: Crypto crypto => Gen (Addr crypto)
genNetworkMagic :: Gen Word32
genCoin :: Gen Coin
genSecurityParam :: Gen Word64
genSlotLength :: Gen NominalDiffTime
genUTCTime :: Gen UTCTime
genIPv4 :: Gen IPv4
genIPv6 :: Gen IPv6

module Test.Cardano.Ledger.Shelley.Orphans
instance GHC.Num.Num (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN (Cardano.Ledger.Crypto.DSIGN crypto)) => GHC.Num.Num (Cardano.Ledger.Keys.VKey kd crypto)
instance Test.Cardano.Ledger.Shelley.Utils.Split Cardano.Ledger.Coin.Coin
instance Data.TreeDiff.Class.ToExpr Cardano.Ledger.Coin.Coin

module Test.Cardano.Ledger.Shelley.Generator.ScriptClass
class (UsesScript era, ValidateScript era, Crypto (Crypto era)) => ScriptClass era
basescript :: ScriptClass era => Proxy era -> KeyHash 'Witness (Crypto era) -> Script era
isKey :: ScriptClass era => Proxy era -> Script era -> Maybe (KeyHash 'Witness (Crypto era))
isOnePhase :: ScriptClass era => Proxy era -> Script era -> Bool
quantify :: ScriptClass era => Proxy era -> Script era -> Quantifier (Script era)
unQuantify :: ScriptClass era => Proxy era -> Quantifier (Script era) -> Script era
data Quantifier t
AllOf :: [t] -> Quantifier t
AnyOf :: [t] -> Quantifier t
MOf :: Int -> [t] -> Quantifier t
Leaf :: t -> Quantifier t
exponential :: Integer -> Integer -> Gen Integer
anyOf :: forall era. ScriptClass era => Proxy era -> [Script era] -> Script era
allOf :: forall era. ScriptClass era => Proxy era -> [Script era] -> Script era
mOf :: forall era. ScriptClass era => Proxy era -> Int -> [Script era] -> Script era

-- | Constant list of KeyPairs intended to be used in the generators.
keyPairs :: Crypto crypto => Constants -> KeyPairs crypto
mkPayScriptHashMap :: forall era. ScriptClass era => [(Script era, Script era)] -> Map (ScriptHash (Crypto era)) (Script era, Script era)

-- | Generate a mapping from stake script hash to script pair.
mkStakeScriptHashMap :: forall era. ScriptClass era => [(Script era, Script era)] -> Map (ScriptHash (Crypto era)) (Script era, Script era)
mkScriptsFromKeyPair :: forall era. ScriptClass era => (KeyPair 'Payment (Crypto era), KeyPair 'Staking (Crypto era)) -> (Script era, Script era)
mkKeyPairs :: DSIGNAlgorithm (DSIGN crypto) => Word64 -> (KeyPair kr crypto, KeyPair kr' crypto)

-- | make Scripts based on the given key pairs
mkScripts :: forall era. ScriptClass era => KeyPairs (Crypto era) -> [(Script era, Script era)]

-- | Combine a list of script pairs into hierarchically structured
--   multi-sig scripts, list must have at least length 3. Be careful not to
--   call with too many pairs in order not to create too many of the
--   possible combinations.
mkScriptCombinations :: forall era. ScriptClass era => [(Script era, Script era)] -> [(Script era, Script era)]

-- | Make a list of script pairs (payment,staking). Each of these are
--   combined scripts. I.e. All, Any, MofN, etc. These come from combining
--   the the first N (numBaseScripts) baseScripts When N==3, we get about
--   150 combined scripts.
combinedScripts :: forall era. ScriptClass era => Constants -> [(Script era, Script era)]

-- | Make list of script pairs (payment,staking). These are non-combined
--   scripts Ie NO quantifer like All, Any, MofN, etc.) scripts. In post
--   Shelley Eras, either Keylock or Require Start-Finish scripts.
baseScripts :: forall era. ScriptClass era => Constants -> [(Script era, Script era)]

-- | Return all valid lists of KeyHashes that appear in a Script used in
--   testing.
scriptKeyCombinations :: forall era. ScriptClass era => Proxy era -> Script era -> [[KeyHash 'Witness (Crypto era)]]

-- | Produce a valid list of key hashes that appear in a Script. Note: in
--   the case of AnyOf, we just take the first script in the expression.
--   This only works if we generate AnyOf scripts such that all script
--   options are valid scripts (that is, valid in the context of a
--   transaction, at generation time and execution/spend time).
scriptKeyCombination :: forall era. ScriptClass era => Proxy era -> Script era -> [KeyHash 'Witness (Crypto era)]
instance GHC.Base.Functor Test.Cardano.Ledger.Shelley.Generator.ScriptClass.Quantifier

module Test.Cardano.Ledger.Shelley.Generator.Core
data AllIssuerKeys v (r :: KeyRole)
AllIssuerKeys :: KeyPair r v -> (SignKeyVRF v, VerKeyVRF v) -> [(KESPeriod, (SignKeyKES v, VerKeyKES v))] -> KeyHash r v -> AllIssuerKeys v (r :: KeyRole)
[cold] :: AllIssuerKeys v (r :: KeyRole) -> KeyPair r v
[vrf] :: AllIssuerKeys v (r :: KeyRole) -> (SignKeyVRF v, VerKeyVRF v)
[hot] :: AllIssuerKeys v (r :: KeyRole) -> [(KESPeriod, (SignKeyKES v, VerKeyKES v))]
[hk] :: AllIssuerKeys v (r :: KeyRole) -> KeyHash r v

-- | Generator environment.
data GenEnv era
GenEnv :: KeySpace era -> ScriptSpace era -> Constants -> GenEnv era
[geKeySpace] :: GenEnv era -> KeySpace era
[geScriptSpapce] :: GenEnv era -> ScriptSpace era
[geConstants] :: GenEnv era -> Constants
data ScriptSpace era
ScriptSpace :: [TwoPhase3ArgInfo era] -> [TwoPhase2ArgInfo era] -> Map (ScriptHash (Crypto era)) (TwoPhase3ArgInfo era) -> Map (ScriptHash (Crypto era)) (TwoPhase2ArgInfo era) -> ScriptSpace era

-- | A list of Two Phase 3 Arg Scripts and their associated data we can
--   use.
[ssScripts3] :: ScriptSpace era -> [TwoPhase3ArgInfo era]

-- | A list of Two Phase 2 Arg Scripts and their associated data we can
--   use.
[ssScripts2] :: ScriptSpace era -> [TwoPhase2ArgInfo era]
[ssHash3] :: ScriptSpace era -> Map (ScriptHash (Crypto era)) (TwoPhase3ArgInfo era)
[ssHash2] :: ScriptSpace era -> Map (ScriptHash (Crypto era)) (TwoPhase2ArgInfo era)
data TwoPhase3ArgInfo era
TwoPhase3ArgInfo :: Script era -> ScriptHash (Crypto era) -> Data -> (Data, Natural, Natural) -> Bool -> TwoPhase3ArgInfo era

-- | A Plutus Script
[getScript3] :: TwoPhase3ArgInfo era -> Script era

-- | Its ScriptHash
[getHash3] :: TwoPhase3ArgInfo era -> ScriptHash (Crypto era)

-- | A Data that will make it succeed
[getData3] :: TwoPhase3ArgInfo era -> Data

-- | A Redeemer that will make it succeed
[getRedeemer3] :: TwoPhase3ArgInfo era -> (Data, Natural, Natural)
[getSucceeds3] :: TwoPhase3ArgInfo era -> Bool
data TwoPhase2ArgInfo era
TwoPhase2ArgInfo :: Script era -> ScriptHash (Crypto era) -> (Data, Natural, Natural) -> Bool -> TwoPhase2ArgInfo era

-- | A Plutus Script
[getScript2] :: TwoPhase2ArgInfo era -> Script era

-- | Its ScriptHash
[getHash2] :: TwoPhase2ArgInfo era -> ScriptHash (Crypto era)

-- | A Redeemer that will make it succeed
[getRedeemer2] :: TwoPhase2ArgInfo era -> (Data, Natural, Natural)
[getSucceeds2] :: TwoPhase2ArgInfo era -> Bool
type ScriptInfo era = (Map (ScriptHash (Crypto era)) (TwoPhase3ArgInfo era), Map (ScriptHash (Crypto era)) (TwoPhase2ArgInfo era))

-- | Collection of all keys which are required to generate a trace.
--   
--   These are the _only_ keys which should be involved in the trace.
data KeySpace era
KeySpace_ :: [(GenesisKeyPair (Crypto era), AllIssuerKeys (Crypto era) 'GenesisDelegate)] -> [AllIssuerKeys (Crypto era) 'GenesisDelegate] -> [AllIssuerKeys (Crypto era) 'StakePool] -> KeyPairs (Crypto era) -> [(Script era, Script era)] -> Map (KeyHash 'Payment (Crypto era)) (KeyPair 'Payment (Crypto era)) -> Map (KeyHash 'Staking (Crypto era)) (KeyPair 'Staking (Crypto era)) -> Map (KeyHash 'GenesisDelegate (Crypto era)) (AllIssuerKeys (Crypto era) 'GenesisDelegate) -> Map (ScriptHash (Crypto era)) (Script era, Script era) -> Map (ScriptHash (Crypto era)) (Script era, Script era) -> KeySpace era
[ksCoreNodes] :: KeySpace era -> [(GenesisKeyPair (Crypto era), AllIssuerKeys (Crypto era) 'GenesisDelegate)]

-- | Bag of keys to be used for future genesis delegates
[ksGenesisDelegates] :: KeySpace era -> [AllIssuerKeys (Crypto era) 'GenesisDelegate]

-- | Bag of keys to be used for future stake pools
[ksStakePools] :: KeySpace era -> [AllIssuerKeys (Crypto era) 'StakePool]

-- | Bag of keys to be used for future payment/staking addresses
[ksKeyPairs] :: KeySpace era -> KeyPairs (Crypto era)
[ksMSigScripts] :: KeySpace era -> [(Script era, Script era)]

-- | Index over the payment keys in <a>ksKeyPairs</a>
[ksIndexedPaymentKeys] :: KeySpace era -> Map (KeyHash 'Payment (Crypto era)) (KeyPair 'Payment (Crypto era))

-- | Index over the staking keys in <a>ksKeyPairs</a>
[ksIndexedStakingKeys] :: KeySpace era -> Map (KeyHash 'Staking (Crypto era)) (KeyPair 'Staking (Crypto era))

-- | Index over the cold key hashes in Genesis Delegates
[ksIndexedGenDelegates] :: KeySpace era -> Map (KeyHash 'GenesisDelegate (Crypto era)) (AllIssuerKeys (Crypto era) 'GenesisDelegate)

-- | Index over the pay script hashes in Script pairs
[ksIndexedPayScripts] :: KeySpace era -> Map (ScriptHash (Crypto era)) (Script era, Script era)

-- | Index over the stake script hashes in Script pairs
[ksIndexedStakeScripts] :: KeySpace era -> Map (ScriptHash (Crypto era)) (Script era, Script era)
pattern KeySpace :: forall era. ScriptClass era => [(GenesisKeyPair (Crypto era), AllIssuerKeys (Crypto era) 'GenesisDelegate)] -> [AllIssuerKeys (Crypto era) 'GenesisDelegate] -> [AllIssuerKeys (Crypto era) 'StakePool] -> KeyPairs (Crypto era) -> [(Script era, Script era)] -> KeySpace era

-- | We provide our own nonces to <a>mkBlock</a>, which we then wish to
--   recover as the output of the VRF functions. In general, however, we
--   just derive them from a natural. Since the nonce is a hash, we do not
--   want to recover it to find a preimage. In testing, therefore, we just
--   wrap the raw natural, which we then encode into the fake VRF
--   implementation.
newtype NatNonce
NatNonce :: Natural -> NatNonce

-- | Find first matching key pair for address. Returns the matching key
--   pair where the first element of the pair matched the hash in
--   <tt>addr</tt>.
findPayKeyPairAddr :: forall era. Addr (Crypto era) -> Map (KeyHash 'Payment (Crypto era)) (KeyPair 'Payment (Crypto era)) -> KeyPair 'Payment (Crypto era)

-- | Find first matching key pair for a credential. Returns the matching
--   key pair where the first element of the pair matched the hash in
--   <tt>addr</tt>.
findPayKeyPairCred :: forall era kr. Credential kr (Crypto era) -> Map (KeyHash kr (Crypto era)) (KeyPair kr (Crypto era)) -> KeyPair kr (Crypto era)

-- | Find matching multisig scripts for a credential.
findPayScriptFromCred :: forall era. Credential 'Witness (Crypto era) -> Map (ScriptHash (Crypto era)) (Script era, Script era) -> (Script era, Script era)

-- | Find first matching script for a credential.
findStakeScriptFromCred :: Credential 'Witness (Crypto era) -> Map (ScriptHash (Crypto era)) (Script era, Script era) -> (Script era, Script era)

-- | Find first matching multisig script for an address.
findPayScriptFromAddr :: forall era. Addr (Crypto era) -> Map (ScriptHash (Crypto era)) (Script era, Script era) -> (Script era, Script era)
genBool :: Gen Bool

-- | Generates a list of <a>Coin</a> values of length between
--   <tt>lower</tt> and <tt>upper</tt> and with values between
--   <tt>minCoin</tt> and <tt>maxCoin</tt>.
genCoinList :: Integer -> Integer -> Int -> Gen [Coin]
genInteger :: Integer -> Integer -> Gen Integer

-- | Generator for a natural number between <tt>lower</tt> and
--   <tt>upper</tt>
genNatural :: Natural -> Natural -> Gen Natural

-- | Generator for a Word64 between <tt>lower</tt> and <tt>upper</tt>
genWord64 :: Word64 -> Word64 -> Gen Word64

-- | Generates a list of coins for the given <a>Addr</a> and produced a
--   <tt>TxOut</tt> for each <a>Addr</a>
--   
--   Note: we need to keep the initial utxo coin sizes large enough so that
--   when we simulate sequences of transactions, we have enough funds
--   available to include certificates that require deposits.
genTxOut :: forall era. UsesTxOut era => Gen (Value era) -> [Addr (Crypto era)] -> Gen [TxOut era]

-- | Creates the UTxO for a new ledger with the specified genesis TxId and
--   transaction outputs.
genesisCoins :: TxId (Crypto era) -> [TxOut era] -> UTxO era

-- | Generate values the given distribution in 90% of the cases, and values
--   at the bounds of the range in 10% of the cases.
--   
--   This can be used to generate enough extreme values. The exponential
--   and linear distributions provided by <tt>hedgehog</tt> will generate a
--   small percentage of these (0-1%).
increasingProbabilityAt :: Gen a -> (a, a) -> Gen a

-- | Select one random verification staking key from list of pairs of
--   KeyPair.
pickStakeKey :: KeyPairs crypto -> Gen (VKey 'Staking crypto)
toAddr :: Crypto crypto => Network -> (KeyPair 'Payment crypto, KeyPair 'Staking crypto) -> Addr crypto
toCred :: forall crypto (kr :: KeyRole). Crypto crypto => KeyPair kr crypto -> Credential kr crypto

-- | Try to map the unit interval to a natural number. We don't care
--   whether this is surjective. But it should be right inverse to
--   <tt>fromNatural</tt> - that is, one should be able to recover the
--   <a>UnitInterval</a> value used here.
unitIntervalToNatural :: UnitInterval -> Natural
mkBlock :: forall era r. (UsesTxBody era, ToCBORGroup (TxSeq era), Mock (Crypto era)) => HashHeader (Crypto era) -> AllIssuerKeys (Crypto era) r -> [Tx era] -> SlotNo -> BlockNo -> Nonce -> Word -> Word -> OCert (Crypto era) -> Block (BHeader (Crypto era)) era
mkBlockHeader :: Mock crypto => HashHeader crypto -> AllIssuerKeys crypto r -> SlotNo -> BlockNo -> Nonce -> Word -> Word -> OCert crypto -> Natural -> Hash crypto EraIndependentBlockBody -> BHeader crypto

-- | Create a block with a faked VRF result.
mkBlockFakeVRF :: forall era r. (UsesTxBody era, ToCBORGroup (TxSeq era), ExMock (Crypto era)) => HashHeader (Crypto era) -> AllIssuerKeys (Crypto era) r -> [Tx era] -> SlotNo -> BlockNo -> Nonce -> NatNonce -> UnitInterval -> Word -> Word -> OCert (Crypto era) -> Block (BHeader (Crypto era)) era
mkOCert :: forall crypto r. (Crypto crypto, Signable (DSIGN crypto) (OCertSignable crypto)) => AllIssuerKeys crypto r -> Word64 -> KESPeriod -> OCert crypto

-- | Takes a set of KES hot keys and checks to see whether there is one
--   whose range contains the current KES period. If so, return its index
--   in the list of hot keys.
getKESPeriodRenewalNo :: AllIssuerKeys h r -> KESPeriod -> Integer

-- | True if the given slot is within the last `2 * stabilityWindow` slots
--   of the current epoch.
tooLateInEpoch :: SlotNo -> Bool
data RawSeed
RawSeed :: !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> RawSeed

-- | For testing purposes, generate a deterministic key pair given a seed.
mkKeyPair :: forall crypto kd. DSIGNAlgorithm (DSIGN crypto) => RawSeed -> (SignKeyDSIGN (DSIGN crypto), VKey kd crypto)
mkKeyPairs :: DSIGNAlgorithm (DSIGN crypto) => Word64 -> (KeyPair kr crypto, KeyPair kr' crypto)

-- | For testing purposes, generate a deterministic genesis key pair given
--   a seed.
mkGenKey :: DSIGNAlgorithm (DSIGN crypto) => RawSeed -> (SignKeyDSIGN (DSIGN crypto), VKey kd crypto)

-- | Account with empty treasury
genesisAccountState :: AccountState
genCoin :: Integer -> Integer -> Gen Coin

-- | For use in the Serialisation and Example Tests, which assume Shelley,
--   Allegra, or Mary Eras.
type PreAlonzo era = (Witnesses era ~ WitnessSet era, ToCBOR (AuxiliaryData era))
hashData :: forall era. Era era => Data -> DataHash (Crypto era)

-- | Find the preallocated Script from its Hash.
findPlutus :: forall era. Era era => GenEnv era -> ScriptHash (Crypto era) -> (Script era, StrictMaybe (DataHash (Crypto era)))
instance Cardano.Ledger.Crypto.Crypto v => GHC.Show.Show (Test.Cardano.Ledger.Shelley.Generator.Core.AllIssuerKeys v r)
instance GHC.Show.Show (Cardano.Ledger.Core.Script era) => GHC.Show.Show (Test.Cardano.Ledger.Shelley.Generator.Core.TwoPhase3ArgInfo era)
instance GHC.Show.Show (Cardano.Ledger.Core.Script era) => GHC.Show.Show (Test.Cardano.Ledger.Shelley.Generator.Core.TwoPhase2ArgInfo era)
instance GHC.Show.Show (Cardano.Ledger.Core.Script era) => GHC.Show.Show (Test.Cardano.Ledger.Shelley.Generator.Core.ScriptSpace era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Script era)) => GHC.Show.Show (Test.Cardano.Ledger.Shelley.Generator.Core.KeySpace era)


-- | Infrastructure for generating STS Traces over any Era
module Test.Cardano.Ledger.Shelley.Generator.EraGen
genUtxo0 :: forall era. EraGen era => GenEnv era -> Gen (UTxO era)

-- | We share this dummy TxId as genesis transaction id across eras
genesisId :: HashAlgorithm (HASH crypto) => TxId crypto
class (Era era, Split (Value era), ScriptClass era, MinGenPParams era, MinGenWitnesses era, MinGenAuxData era, MinGenTxBody era, HasField "body" (Tx era) (TxBody era), MinGenTxout era, PrettyA (Tx era), PrettyA (TxBody era), PrettyA (Witnesses era), PrettyA (Value era), Default (StashedAVVMAddresses era)) => EraGen era

-- | Generate a genesis value for the Era
genGenesisValue :: EraGen era => GenEnv era -> Gen (Value era)

-- | A list of three-phase scripts that can be chosen for payment when
--   building a transaction
genEraTwoPhase3Arg :: EraGen era => [TwoPhase3ArgInfo era]

-- | A list of two-phase scripts that can be chosen for Delegating,
--   Minting, or Rewarding when building a transaction
genEraTwoPhase2Arg :: EraGen era => [TwoPhase2ArgInfo era]

-- | Given some pre-generated data, generate an era-specific TxBody, and a
--   list of additional scripts for eras that sometimes require additional
--   script witnessing.
genEraTxBody :: EraGen era => GenEnv era -> UTxO era -> PParams era -> SlotNo -> Set (TxIn (Crypto era)) -> StrictSeq (TxOut era) -> StrictSeq (DCert (Crypto era)) -> Wdrl (Crypto era) -> Coin -> StrictMaybe (Update era) -> StrictMaybe (AuxiliaryDataHash (Crypto era)) -> Gen (TxBody era, [Script era])

-- | Generate era-specific auxiliary data
genEraAuxiliaryData :: EraGen era => Constants -> Gen (StrictMaybe (AuxiliaryData era))

-- | Update an era-specific TxBody
updateEraTxBody :: EraGen era => UTxO era -> PParams era -> Witnesses era -> TxBody era -> Coin -> Set (TxIn (Crypto era)) -> TxOut era -> TxBody era

-- | Union the TxIn with the existing TxIn in the TxBody
addInputs :: EraGen era => TxBody era -> Set (TxIn (Crypto era)) -> TxBody era
genEraPParamsDelta :: EraGen era => Constants -> PParams era -> Gen (PParamsDelta era)
genEraPParams :: EraGen era => Constants -> Gen (PParams era)
genEraWitnesses :: EraGen era => (UTxO era, TxBody era, ScriptInfo era) -> Set (WitVKey 'Witness (Crypto era)) -> Map (ScriptHash (Crypto era)) (Script era) -> Witnesses era
genEraGoodTxOut :: EraGen era => TxOut era -> Bool

-- | Construct a transaction given its constituent parts.
constructTx :: EraGen era => TxBody era -> Witnesses era -> StrictMaybe (AuxiliaryData era) -> Tx era

-- | compute the delta cost of an additional script on per Era basis.
genEraScriptCost :: EraGen era => PParams era -> Script era -> Coin

-- | A final opportunity to tweak things when the generator is done.
--   Possible uses 1) Add tracing when debugging on a per Era basis
genEraDone :: EraGen era => PParams era -> Tx era -> Gen (Tx era)

-- | A final opportunity to tweak things at the block level. Possible uses
--   2) Run a test that might decide to <tt>discard</tt> the test, because
--   we got unlucky, and a rare unfixible condition has occurred.
genEraTweakBlock :: EraGen era => PParams era -> Seq (Tx era) -> Gen (Seq (Tx era))
hasFailedScripts :: EraGen era => Tx era -> Bool
feeOrCollateral :: EraGen era => Tx era -> UTxO era -> Coin

-- | Minimal requirements on the LEDGER and LEDGERS instances
type MinLEDGER_STS era = (Environment (EraRule "LEDGERS" era) ~ LedgersEnv era, BaseM (EraRule "LEDGER" era) ~ ShelleyBase, Signal (EraRule "LEDGER" era) ~ Tx era, State (EraRule "LEDGER" era) ~ LedgerState era, Environment (EraRule "LEDGER" era) ~ LedgerEnv era, BaseM (EraRule "LEDGERS" era) ~ ShelleyBase, State (EraRule "LEDGERS" era) ~ LedgerState era, Signal (EraRule "LEDGERS" era) ~ Seq (Tx era), STS (EraRule "LEDGER" era))

-- | Minimal requirements on the CHAIN instances
type MinCHAIN_STS era = (STS (CHAIN era), BaseM (CHAIN era) ~ ShelleyBase, Environment (CHAIN era) ~ (), State (CHAIN era) ~ ChainState era, Signal (CHAIN era) ~ Block (BHeader (Crypto era)) era)

-- | Minimal requirements on the UTxO instances
type MinUTXO_STS era = (STS (EraRule "UTXOW" era), BaseM (EraRule "UTXOW" era) ~ ShelleyBase, State (EraRule "UTXOW" era) ~ UTxOState era, Environment (EraRule "UTXOW" era) ~ UtxoEnv era, Signal (EraRule "UTXOW" era) ~ Tx era, State (EraRule "UTXO" era) ~ UTxOState era, Environment (EraRule "UTXO" era) ~ UtxoEnv era, Signal (EraRule "UTXO" era) ~ Tx era)
type MinGenTxBody era = (Eq (TxBody era), ToCBOR (TxBody era), NoThunks (TxBody era), Show (TxBody era), FromCBOR (Annotator (TxBody era)), HasField "txfee" (TxBody era) Coin)
class Show (TxOut era) => MinGenTxout era
calcEraMinUTxO :: MinGenTxout era => TxOut era -> PParams era -> Coin
addValToTxOut :: MinGenTxout era => Value era -> TxOut era -> TxOut era
genEraTxOut :: MinGenTxout era => GenEnv era -> Gen (Value era) -> [Addr (Crypto era)] -> Gen [TxOut era]
data Label t
[Body'] :: Label (TxBody era)
[Wits'] :: Label (Witnesses era)
class Sets (x :: Label t) y
set :: Sets x y => Label t -> y -> y

-- | Select between _lower_ and _upper_ keys from <a>keyPairs</a>
someKeyPairs :: Crypto crypto => Constants -> Int -> Int -> Gen (KeyPairs crypto)

-- | A list of all possible kinds of scripts in the current Era. Might
--   include Keylocked scripts, Start-Finish Timelock scripts, Quantified
--   scripts (All, Any, MofN), Plutus Scripts Note that
--   <a>genEraTwoPhase3Arg</a> and <a>genEraTwoPhase2Arg</a> may be the
--   empty list ([]) in some Eras.
allScripts :: forall era. EraGen era => Constants -> [(Script era, Script era)]
randomByHash :: forall x. ToCBOR x => Int -> Int -> x -> Int

module Test.Cardano.Ledger.Shelley.Generator.Update
genPParams :: Constants -> Gen (PParams era)

-- | Occasionally generate an update and return with the witness keys
genUpdate :: EraGen era => Constants -> SlotNo -> [(GenesisKeyPair (Crypto era), AllIssuerKeys (Crypto era) 'GenesisDelegate)] -> Map (KeyHash 'GenesisDelegate (Crypto era)) (AllIssuerKeys (Crypto era) 'GenesisDelegate) -> PParams era -> (UTxOState era, DPState (Crypto era)) -> Gen (Maybe (Update era), [KeyPair 'Witness (Crypto era)])

-- | This is only good in the Shelley Era, used to define the
--   genEraPParamsDelta method for (EraGen (ShelleyEra c))
genShelleyPParamsDelta :: forall era. (PParams era ~ PParams era, PParamsDelta era ~ PParamsUpdate era) => Constants -> PParams era -> Gen (PParamsDelta era)
genM :: Gen a -> Gen (StrictMaybe a)

-- | ^ TODO jc - generating d=0 takes some care, if there are no registered
--   stake pools then d=0 deadlocks the system.
genDecentralisationParam :: HasCallStack => Gen UnitInterval


-- | Pre-generated items to use in traces.
--   
--   Functions in this module make specific assumptions about the sets of
--   keys involved, and thus cannot be used as generic generators.
module Test.Cardano.Ledger.Shelley.Generator.Presets
coreNodeKeys :: Crypto crypto => Constants -> [(KeyPair 'Genesis crypto, AllIssuerKeys crypto 'GenesisDelegate)]

-- | Example keyspace for use in generators
keySpace :: forall era. EraGen era => Constants -> KeySpace era

-- | Example generator environment, consisting of default constants and an
--   corresponding keyspace.
genEnv :: forall era. EraGen era => Proxy era -> GenEnv era
genesisDelegs0 :: Crypto crypto => Constants -> Map (KeyHash 'Genesis crypto) (GenDelegPair crypto)

-- | Select between _lower_ and _upper_ keys from <a>keyPairs</a>
someKeyPairs :: Crypto crypto => Constants -> Int -> Int -> Gen (KeyPairs crypto)

-- | Constant list of KeyPairs intended to be used in the generators.
keyPairs :: Crypto crypto => Constants -> KeyPairs crypto

-- | An Example Script space for use in Trace generators
scriptSpace :: forall era. ValidateScript era => [TwoPhase3ArgInfo era] -> [TwoPhase2ArgInfo era] -> ScriptSpace era

module Test.Cardano.Ledger.Shelley.Serialisation.EraIndepGenerators
mkDummyHash :: forall h a. HashAlgorithm h => Int -> Hash h a

-- | For some purposes, a totally random block generator may not be
--   suitable. There are tests in the ouroboros-network repository, for
--   instance, that perform some integrity checks on the generated blocks.
--   
--   For other purposes, such as the serialization tests in this
--   repository, <a>genBlock</a> is more appropriate.
--   
--   This generator uses <a>mkBlock</a> provide more coherent blocks.
genCoherentBlock :: forall era h. (ToCBORGroup (TxSeq era), Mock (Crypto era), UsesTxBody era, Arbitrary (Tx era), h ~ BHeader (Crypto era)) => Gen (Block h era)
genHash :: forall a h. HashAlgorithm h => Gen (Hash h a)
genShelleyAddress :: Crypto crypto => Gen (Addr crypto)
genByronAddress :: Gen (Addr crypto)
type MockGen era = (Mock (Crypto era), Arbitrary (VerKeyDSIGN (DSIGN (Crypto era))))
maxTxWits :: Int
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.TxOut era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Cardano.Ledger.SafeHash.HasAlgorithm c => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.SafeHash.SafeHash c i)
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Protocol.TPraos.BHeader.BHeader crypto)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Crypto.DSIGN.Class.SignedDSIGN crypto a)
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Protocol.TPraos.BHeader.HashHeader crypto)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto crypto) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.WitVKey kr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance (Cardano.Ledger.Era.Era era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance (Cardano.Ledger.Era.Era era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.PParams.Update era)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.Metadata.Metadatum
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Metadata.Metadata era)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.TxIn.TxId crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.TxIn.TxIn crypto)
instance (Cardano.Ledger.Shelley.Constraints.UsesValue era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.Value era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.TxOut era)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.Nonce
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.UnitInterval
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.PositiveInterval
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Keys.KeyHash a crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.WitHashes crypto)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.TxBody.MIRPot
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.MIRTarget crypto)
instance Test.QuickCheck.Arbitrary.Arbitrary GHC.Natural.Natural
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.Rules.Ppup.VotingPeriod
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Coin.Coin
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Coin.DeltaCoin
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Slotting.Slot.SlotNo
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Slotting.Slot.EpochNo
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Address.Addr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Credential.StakeReference crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Credential.Credential r crypto)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.TxIx
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.CertIx
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Credential.Ptr
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Address.RewardAcnt crypto)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.Network
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN (Cardano.Ledger.Crypto.DSIGN crypto)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Keys.VKey kd crypto)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.ProtVer
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Hashes.ScriptHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto)
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Crypto.Hash.Class.Hash h a)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Protocol.TPraos.Rules.Tickn.TicknState
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Protocol.TPraos.Rules.Prtcl.PrtclState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.PState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.InstantaneousRewards crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.FutureGenDeleg crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Keys.GenDelegs crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Keys.GenDelegPair crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.UnifiedMap.Triple crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.UnifiedMap.UnifiedMap crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.DState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.DelegCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.Delegation crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.PoolCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.GenesisDelegCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.MIRCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.DCert crypto)
instance (Cardano.Ledger.Era.Era era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.PPUPState era)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.DPState crypto)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.TxOut era), Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.UTxOState era)
instance Cardano.Ledger.Crypto.Crypto c => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.IncrementalStake c)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.TxOut era), Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.LedgerState era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.TxOut era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.Value era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.PParams era), Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.StashedAVVMAddresses era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.NewEpochState era)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.BaseTypes.BlocksMade crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.PoolDistr.PoolDistr crypto)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.TxOut era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.Value era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.PParams era), Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.LedgerState.EpochState era)
instance (Test.QuickCheck.Arbitrary.Arbitrary k, Test.QuickCheck.Arbitrary.Arbitrary v, GHC.Classes.Ord k, Data.Vector.Generic.Base.Vector kv k, Data.Vector.Generic.Base.Vector vv v) => Test.QuickCheck.Arbitrary.Arbitrary (Data.VMap.VMap kv vv k v)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.Rewards.RewardType
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate crypto)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Maybe.Strict.StrictMaybe a)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Protocol.TPraos.Rules.Overlay.OBftSlot crypto)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.PoolRank.Likelihood
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.PoolRank.LogWeight
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.EpochBoundary.SnapShot crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.EpochBoundary.SnapShots crypto)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.EpochBoundary.Stake crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.Url
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Data.Sequence.Strict.StrictSeq a)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.Port
instance Test.QuickCheck.Arbitrary.Arbitrary Data.IP.Addr.IPv4
instance Test.QuickCheck.Arbitrary.Arbitrary Data.IP.Addr.IPv6
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.BaseTypes.DnsName
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.LedgerState.AccountState
instance Cardano.Ledger.Crypto.Crypto crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Scripts.MultiSig crypto)
instance (Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.PParams.PParams era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis era)
instance (Cardano.Ledger.Shelley.Constraints.UsesScript era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Cardano.Ledger.Era.ValidateScript era, Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.Script era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Tx.WitnessSet era)
instance Cardano.Ledger.Era.Era era => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era)
instance Cardano.Ledger.Era.Era era => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rules.Pool.PoolPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOL" era)), Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEG" era))) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rules.Deleg.DelegPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era))) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rules.Delegs.DelegsPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rules.Ledgers.LedgersPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEGS" era)), Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOW" era))) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rules.Ledger.LedgerPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era))) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.TxBody era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.Value era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.AuxiliaryData era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.Script era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.Witnesses era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.AuxiliaryData era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxBody era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Witnesses era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Tx.Tx era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxBody era, Cardano.Ledger.Serialization.ToCBORGroup (Cardano.Ledger.Era.TxSeq era), Cardano.Ledger.Era.SupportsSegWit era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Core.Tx era), h GHC.Types.~ Cardano.Protocol.TPraos.BHeader.BHeader (Cardano.Ledger.Era.Crypto era)) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Era.Era era, Test.QuickCheck.Arbitrary.Arbitrary (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate crypto)
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot crypto)
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo crypto)
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.RewardUpdate.FreeVars crypto)
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock crypto => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.RewardUpdate.Pulser crypto)

module Test.Cardano.Ledger.Shelley.Serialisation.Generators
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock c => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.TxBody.TxBody (Cardano.Ledger.Shelley.ShelleyEra c))
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock c => Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure (Cardano.Ledger.Shelley.ShelleyEra c))
instance Test.QuickCheck.Arbitrary.Arbitrary (Cardano.Ledger.Shelley.PParams.PParams era)

module Test.Cardano.Ledger.Shelley.Address.CompactAddr
propValidateNewDecompact :: forall crypto. Crypto crypto => Addr crypto -> Property
propCompactAddrRoundTrip :: Crypto crypto => Addr crypto -> Bool
propCompactSerializationAgree :: Addr crypto -> Bool
propDecompactErrors :: forall crypto. Crypto crypto => Addr crypto -> Gen Property
propDeserializeRewardAcntErrors :: forall crypto. Crypto crypto => RewardAcnt crypto -> Gen Property

module Test.Cardano.Ledger.Shelley.Generator.Delegation

-- | Occasionally generate a valid certificate
--   
--   Returning <a>Nothing</a> indicates a failure to generate a value,
--   usually due to lack of available values from the pre-populated (e.g.
--   key) spaces. A <a>Just</a> represents a successfully generated value.
--   
--   Different generators return witnesses that are either genesis or
--   regular keys.
--   
--   Note: we register keys and pools more often than
--   deregistering/retiring them, and we generate more delegations than
--   registrations of keys/pools.
genDCert :: forall era. EraGen era => Constants -> KeySpace era -> PParams era -> AccountState -> DPState (Crypto era) -> SlotNo -> Gen (Maybe (DCert (Crypto era), CertCred era))
data CertCred era
CoreKeyCred :: [GenesisKeyPair (Crypto era)] -> CertCred era
StakeCred :: KeyPair 'Staking (Crypto era) -> CertCred era
PoolCred :: KeyPair 'StakePool (Crypto era) -> CertCred era
ScriptCred :: (Script era, Script era) -> CertCred era
DelegateCred :: [KeyPair 'GenesisDelegate (Crypto era)] -> CertCred era
NoCred :: CertCred era
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.Script era)) => GHC.Show.Show (Test.Cardano.Ledger.Shelley.Generator.Delegation.CertCred era)

module Test.Cardano.Ledger.Shelley.Generator.Trace.DCert

-- | This is a non-spec STS used to generate a sequence of certificates
--   with witnesses.
data CERTS era

-- | Generate certificates and also return the associated witnesses and
--   deposits and refunds required.
genDCerts :: forall era. (EraGen era, Embed (EraRule "DELPL" era) (CERTS era), Environment (EraRule "DELPL" era) ~ DelplEnv era, State (EraRule "DELPL" era) ~ DPState (Crypto era), Signal (EraRule "DELPL" era) ~ DCert (Crypto era)) => GenEnv era -> PParams era -> DPState (Crypto era) -> SlotNo -> TxIx -> AccountState -> Gen (StrictSeq (DCert (Crypto era)), Coin, Coin, DPState (Crypto era), ([KeyPair 'Witness (Crypto era)], [(Script era, Script era)]))
instance GHC.Generics.Generic (Test.Cardano.Ledger.Shelley.Generator.Trace.DCert.CertsPredicateFailure era)
instance GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era)) => GHC.Classes.Eq (Test.Cardano.Ledger.Shelley.Generator.Trace.DCert.CertsPredicateFailure era)
instance GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era)) => GHC.Show.Show (Test.Cardano.Ledger.Shelley.Generator.Trace.DCert.CertsPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELPL" era) (Test.Cardano.Ledger.Shelley.Generator.Trace.DCert.CERTS era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.DPState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era)) => Control.State.Transition.Extended.STS (Test.Cardano.Ledger.Shelley.Generator.Trace.DCert.CERTS era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Delpl.DELPL era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Delpl.DELPL era) (Test.Cardano.Ledger.Shelley.Generator.Trace.DCert.CERTS era)
instance (Test.Cardano.Ledger.Shelley.Generator.EraGen.EraGen era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELPL" era) (Test.Cardano.Ledger.Shelley.Generator.Trace.DCert.CERTS era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.DPState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era)) => Control.State.Transition.Trace.Generator.QuickCheck.HasTrace (Test.Cardano.Ledger.Shelley.Generator.Trace.DCert.CERTS era) (Test.Cardano.Ledger.Shelley.Generator.Core.GenEnv era)

module Test.Cardano.Ledger.Shelley.Generator.Utxo

-- | Generates a transaction in the context of the LEDGER STS environment
--   and state.
--   
--   A generated transaction may not have sufficient spending balance and
--   need to be discarded. In that case we try to compute a Delta, that
--   when added (applyDelta) to the transaction, repairs it. The repair is
--   made by adding additional inputs from which more Ada can flow into the
--   fee. If that doesn't fix it, we add more inputs to the Delta.
--   Experience shows that this converges quite quickly (in traces we never
--   saw more than 3 iterations).
genTx :: forall era. (EraGen era, UsesTxOut era, UsesValue era, Mock (Crypto era), Embed (EraRule "DELPL" era) (CERTS era), Environment (EraRule "DELPL" era) ~ DelplEnv era, State (EraRule "DELPL" era) ~ DPState (Crypto era), Signal (EraRule "DELPL" era) ~ DCert (Crypto era), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era)))) => GenEnv era -> LedgerEnv era -> LedgerState era -> Gen (Tx era)

-- | Collect additional inputs (and witnesses and keys and scripts) to make
--   the transaction balance.
data Delta era
Delta :: Coin -> Set (TxIn (Crypto era)) -> Witnesses era -> TxOut era -> [KeyPair 'Witness (Crypto era)] -> [(Script era, Script era)] -> Delta era
[dfees] :: Delta era -> Coin
[extraInputs] :: Delta era -> Set (TxIn (Crypto era))
[extraWitnesses] :: Delta era -> Witnesses era
[change] :: Delta era -> TxOut era
[deltaVKeys] :: Delta era -> [KeyPair 'Witness (Crypto era)]
[deltaScripts] :: Delta era -> [(Script era, Script era)]
showBalance :: forall era. (Era era, Show (Value era), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "_keyDeposit" (PParams era) Coin, HasField "_poolDeposit" (PParams era) Coin) => LedgerEnv era -> UTxOState era -> DPState (Crypto era) -> Tx era -> String
encodedLen :: ToCBOR t => t -> Integer
myDiscard :: [Char] -> a

-- | Select <tt>n</tt> random key value pairs from the supplied map. Order
--   of keys with respect to each other will also be random, i.e. not
--   sorted.
pickRandomFromMap :: Int -> Map k t -> Gen [(k, t)]
instance GHC.Show.Show (Test.Cardano.Ledger.Shelley.Generator.Utxo.Delta era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesScript era, Cardano.Ledger.Shelley.Constraints.TransValue GHC.Classes.Eq era, GHC.Classes.Eq (Cardano.Ledger.Core.Witnesses era)) => GHC.Classes.Eq (Test.Cardano.Ledger.Shelley.Generator.Utxo.Delta era)

module Test.Cardano.Ledger.Shelley.Generator.Trace.Ledger
genAccountState :: Constants -> Gen AccountState

-- | Generate initial state for the LEDGER STS using the STS environment.
--   
--   Note: this function must be usable in place of <a>applySTS</a> and
--   needs to align with the signature 'RuleContext sts -&gt; Gen (Either
--   [[PredicateFailure sts]] (State sts))'. To achieve this we (1) use
--   'IRC LEDGER' (the "initial rule context") instead of simply
--   <a>LedgerEnv</a> and (2) always return Right (since this function does
--   not raise predicate failures).
mkGenesisLedgerState :: forall a era ledger. (UsesValue era, EraGen era, Default (State (EraRule "PPUP" era))) => GenEnv era -> IRC ledger -> Gen (Either a (LedgerState era))
instance (Test.Cardano.Ledger.Shelley.Generator.EraGen.EraGen era, Cardano.Ledger.Shelley.Constraints.UsesTxBody era, Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Cardano.Ledger.Shelley.Constraints.UsesAuxiliary era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.Cardano.Ledger.Shelley.Generator.EraGen.MinLEDGER_STS era, Cardano.Ledger.Shelley.Constraints.TransValue Cardano.Binary.ToCBOR.ToCBOR era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELPL" era) (Test.Cardano.Ledger.Shelley.Generator.Trace.DCert.CERTS era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.DPState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELEGS" era) (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UTXOW" era) (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UTxOState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Core.Tx era, Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delegs.DelegsEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.DPState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Data.Sequence.Internal.Seq (Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era)), GHC.Records.HasField "inputs" (Cardano.Ledger.Core.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn (Cardano.Ledger.Era.Crypto era))), GHC.Records.HasField "outputs" (Cardano.Ledger.Core.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Core.TxOut era)), GHC.Records.HasField "certs" (Cardano.Ledger.Core.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era))), GHC.Show.Show (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), GHC.Show.Show (Cardano.Ledger.Core.Tx era)) => Control.State.Transition.Trace.Generator.QuickCheck.HasTrace (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era) (Test.Cardano.Ledger.Shelley.Generator.Core.GenEnv era)
instance (Test.Cardano.Ledger.Shelley.Generator.EraGen.EraGen era, Cardano.Ledger.Shelley.Constraints.UsesTxBody era, Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Cardano.Ledger.Shelley.Constraints.UsesAuxiliary era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Test.Cardano.Ledger.Shelley.Generator.EraGen.MinLEDGER_STS era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELPL" era) (Test.Cardano.Ledger.Shelley.Generator.Trace.DCert.CERTS era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.DPState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELEG" era) (Cardano.Ledger.Shelley.Rules.Delpl.DELPL era), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "LEDGER" era) (Cardano.Ledger.Shelley.Rules.Ledgers.LEDGERS era), GHC.Records.HasField "inputs" (Cardano.Ledger.Core.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn (Cardano.Ledger.Era.Crypto era))), GHC.Records.HasField "outputs" (Cardano.Ledger.Core.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Core.TxOut era)), Data.Default.Class.Default (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Control.State.Transition.Trace.Generator.QuickCheck.HasTrace (Cardano.Ledger.Shelley.Rules.Ledgers.LEDGERS era) (Test.Cardano.Ledger.Shelley.Generator.Core.GenEnv era)

module Test.Cardano.Ledger.Shelley.Generator.Block

-- | Generate a valid block.
genBlock :: forall era. (MinLEDGER_STS era, ApplyBlock era, Mock (Crypto era), GetLedgerView era, HasTrace (EraRule "LEDGERS" era) (GenEnv era), EraGen era) => GenEnv era -> ChainState era -> Gen (Block (BHeader (Crypto era)) era)
genBlockWithTxGen :: forall era. (Mock (Crypto era), GetLedgerView era, ApplyBlock era, EraGen era) => TxGen era -> GenEnv era -> ChainState era -> Gen (Block (BHeader (Crypto era)) era)

-- | The chain state is a composite of the new epoch state and the chain
--   dep state. We tick both.
tickChainState :: (GetLedgerView era, ApplyBlock era) => SlotNo -> ChainState era -> ChainState era

module Test.Cardano.Ledger.Shelley.Generator.Trace.Chain

-- | The first block of the Shelley era will point back to the last block
--   of the Byron era. For our purposes we can bootstrap the chain by just
--   coercing the value. When this transition actually occurs, the
--   consensus layer will do the work of making sure that the hash gets
--   translated across the fork
lastByronHeaderHash :: forall proxy era. Era era => proxy era -> HashHeader (Crypto era)
mkGenesisChainState :: forall era a. (Default (State (EraRule "PPUP" era)), EraGen era) => GenEnv era -> IRC (CHAIN era) -> Gen (Either a (ChainState era))
mkOCertIssueNos :: GenDelegs h -> Map (KeyHash 'BlockIssuer h) Natural
registerGenesisStaking :: forall era. ShelleyGenesisStaking (Crypto era) -> ChainState era -> ChainState era
instance (Cardano.Ledger.Era.Era era, Test.Cardano.Ledger.Shelley.Generator.EraGen.EraGen era, Cardano.Ledger.Shelley.Constraints.UsesTxBody era, Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Cardano.Ledger.Shelley.Constraints.UsesAuxiliary era, Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock (Cardano.Ledger.Era.Crypto era), Cardano.Ledger.Shelley.API.Validation.ApplyBlock era, Cardano.Protocol.TPraos.API.GetLedgerView era, Test.Cardano.Ledger.Shelley.Generator.EraGen.MinLEDGER_STS era, Test.Cardano.Ledger.Shelley.Generator.EraGen.MinCHAIN_STS era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "BBODY" era) (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "BBODY" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Bbody.BbodyEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "BBODY" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Bbody.BbodyState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "BBODY" era) GHC.Types.~ Cardano.Ledger.Block.Block (Cardano.Ledger.BHeaderView.BHeaderView (Cardano.Ledger.Era.Crypto era)) era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "TICKN" era) (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "TICKN" era) GHC.Types.~ Cardano.Protocol.TPraos.Rules.Tickn.TicknEnv, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "TICKN" era) GHC.Types.~ Cardano.Protocol.TPraos.Rules.Tickn.TicknState, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "TICKN" era) GHC.Types.~ GHC.Types.Bool, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "TICK" era) (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "TICK" era) GHC.Types.~ (), Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "TICK" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.NewEpochState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "TICK" era) GHC.Types.~ Cardano.Slotting.Slot.SlotNo, GHC.Records.HasField "inputs" (Cardano.Ledger.Core.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn (Cardano.Ledger.Era.Crypto era))), GHC.Records.HasField "outputs" (Cardano.Ledger.Core.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Core.TxOut era)), GHC.Records.HasField "_d" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.UnitInterval, Control.State.Transition.Trace.Generator.QuickCheck.HasTrace (Cardano.Ledger.Core.EraRule "LEDGERS" era) (Test.Cardano.Ledger.Shelley.Generator.Core.GenEnv era)) => Control.State.Transition.Trace.Generator.QuickCheck.HasTrace (Test.Cardano.Ledger.Shelley.Rules.Chain.CHAIN era) (Test.Cardano.Ledger.Shelley.Generator.Core.GenEnv era)

module Test.Cardano.Ledger.Shelley.Generator.ShelleyEraGen
genCoin :: Integer -> Integer -> Gen Coin
instance (Cardano.Protocol.TPraos.API.PraosCrypto c, Cardano.Crypto.DSIGN.Class.Signable (Cardano.Ledger.Crypto.DSIGN c) GHC.Types.~ Cardano.Crypto.Util.SignableRepresentation, Cardano.Crypto.KES.Class.Signable (Cardano.Ledger.Crypto.KES c) GHC.Types.~ Cardano.Crypto.Util.SignableRepresentation) => Test.Cardano.Ledger.Shelley.Generator.EraGen.EraGen (Cardano.Ledger.Shelley.ShelleyEra c)
instance Cardano.Ledger.Crypto.Crypto c => Test.Cardano.Ledger.Shelley.Generator.ScriptClass.ScriptClass (Cardano.Ledger.Shelley.ShelleyEra c)
instance Test.Cardano.Ledger.Shelley.ConcreteCryptoTypes.Mock c => Test.Cardano.Ledger.Shelley.Generator.EraGen.MinGenTxout (Cardano.Ledger.Shelley.ShelleyEra c)

module Test.Cardano.Ledger.Shelley.ShelleyTranslation
testGroupShelleyTranslation :: TestTree

module Test.Cardano.Ledger.Shelley.Rules.ClassifyTraces
onlyValidLedgerSignalsAreGenerated :: forall era ledger. (EraGen era, ChainProperty era, HasTrace ledger (GenEnv era), Default (State (EraRule "PPUP" era)), BaseEnv ledger ~ Globals, State ledger ~ LedgerState era, Show (Environment ledger), Show (Signal ledger)) => Property
onlyValidChainSignalsAreGenerated :: forall era. (EraGen era, Default (State (EraRule "PPUP" era)), HasTrace (CHAIN era) (GenEnv era), Show (TxSeq era)) => Property
relevantCasesAreCovered :: forall era. (EraGen era, Default (State (EraRule "PPUP" era)), ChainProperty era, HasTrace (CHAIN era) (GenEnv era), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "update" (TxBody era) (StrictMaybe (Update era))) => Property

-- | Check that the abstract transaction size function actually bounds the
--   number of bytes in the serialized transaction.
propAbstractSizeBoundsBytes :: forall era. (EraGen era, ChainProperty era, HasTrace (LEDGER era) (GenEnv era), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), ToCBOR (Tx era), Default (State (EraRule "PPUP" era))) => Property

-- | Check that the abstract transaction size function is not off by an
--   acceptable order of magnitude.
propAbstractSizeNotTooBig :: forall era. (EraGen era, ChainProperty era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), ToCBOR (Tx era), HasTrace (LEDGER era) (GenEnv era), Default (State (EraRule "PPUP" era))) => Property


-- | The genesis/core nodes for Shelley Ledger Examples.
module Test.Cardano.Ledger.Shelley.Examples.Federation

-- | Number of Core Node
numCoreNodes :: Word64
coreNodeSK :: forall crypto. Crypto crypto => Int -> SignKeyDSIGN crypto

-- | <h3>Verification (Public) Keys</h3>
--   
--   Retrieve the verification key for a core node by providing a number in
--   the range <tt>[0, ... (<a>numCoreNodes</a>-1)]</tt>.
coreNodeVK :: forall crypto. Crypto crypto => Int -> VKey 'Genesis crypto

-- | <h3>Block Issuer Keys</h3>
--   
--   Retrieve the block issuer keys (cold, VRF, and hot KES keys) for a
--   core node by providing a number in the range <tt>[0, ...
--   (<a>numCoreNodes</a>-1)]</tt>.
coreNodeIssuerKeys :: forall crypto. Crypto crypto => Int -> AllIssuerKeys crypto 'GenesisDelegate

-- | <h3>Keys by Overlay Schedule</h3>
--   
--   Retrieve all the keys associated with a core node for a given slot and
--   protocol parameters. It will return an error if there is not a core
--   node scheduled for the given slot.
coreNodeKeysBySchedule :: forall era. (HasCallStack, Era era) => PParams era -> Word64 -> AllIssuerKeys (Crypto era) 'GenesisDelegate

-- | <h3>Genesis Delegation Mapping</h3>
--   
--   The map from genesis/core node (verification) key hashes to their
--   delegate's (verification) key hash.
genDelegs :: forall crypto. Crypto crypto => Map (KeyHash 'Genesis crypto) (GenDelegPair crypto)

module Test.Cardano.Ledger.Shelley.Examples.Consensus
type KeyPairWits era = [KeyPair 'Witness (Crypto era)]
data ShelleyResultExamples era
ShelleyResultExamples :: PParams era -> ProposedPPUpdates era -> PoolDistr (Crypto era) -> Map (Either Coin (Credential 'Staking (Crypto era))) (Map (KeyHash 'StakePool (Crypto era)) Coin) -> ShelleyGenesis era -> ShelleyResultExamples era
[srePParams] :: ShelleyResultExamples era -> PParams era
[sreProposedPPUpdates] :: ShelleyResultExamples era -> ProposedPPUpdates era
[srePoolDistr] :: ShelleyResultExamples era -> PoolDistr (Crypto era)
[sreNonMyopicRewards] :: ShelleyResultExamples era -> Map (Either Coin (Credential 'Staking (Crypto era))) (Map (KeyHash 'StakePool (Crypto era)) Coin)
[sreShelleyGenesis] :: ShelleyResultExamples era -> ShelleyGenesis era
data ShelleyLedgerExamples era
ShelleyLedgerExamples :: Block (BHeader (Crypto era)) era -> HashHeader (Crypto era) -> Tx era -> ApplyTxError era -> Set (Either Coin (Credential 'Staking (Crypto era))) -> ShelleyResultExamples era -> NewEpochState era -> ChainDepState (Crypto era) -> TranslationContext era -> ShelleyLedgerExamples era
[sleBlock] :: ShelleyLedgerExamples era -> Block (BHeader (Crypto era)) era
[sleHashHeader] :: ShelleyLedgerExamples era -> HashHeader (Crypto era)
[sleTx] :: ShelleyLedgerExamples era -> Tx era
[sleApplyTxError] :: ShelleyLedgerExamples era -> ApplyTxError era
[sleRewardsCredentials] :: ShelleyLedgerExamples era -> Set (Either Coin (Credential 'Staking (Crypto era)))
[sleResultExamples] :: ShelleyLedgerExamples era -> ShelleyResultExamples era
[sleNewEpochState] :: ShelleyLedgerExamples era -> NewEpochState era
[sleChainDepState] :: ShelleyLedgerExamples era -> ChainDepState (Crypto era)
[sleTranslationContext] :: ShelleyLedgerExamples era -> TranslationContext era
type ShelleyBasedEra' era = (ShelleyBasedEra era, ToCBORGroup (TxSeq era), ToCBOR (Witnesses era), Default (State (EraRule "PPUP" era)), PraosCrypto (Crypto era))
defaultShelleyLedgerExamples :: forall era. (ShelleyBasedEra' era, PredicateFailure (EraRule "DELEGS" era) ~ DelegsPredicateFailure era, PParams era ~ PParams era, PParamsDelta era ~ PParams' StrictMaybe era, Default (StashedAVVMAddresses era)) => (TxBody era -> KeyPairWits era -> Witnesses era) -> (Tx era -> Tx era) -> Value era -> TxBody era -> AuxiliaryData era -> TranslationContext era -> ShelleyLedgerExamples era
exampleShelleyLedgerBlock :: forall era. ShelleyBasedEra' era => Tx era -> Block (BHeader (Crypto era)) era
exampleHashHeader :: forall era. ShelleyBasedEra' era => Proxy era -> HashHeader (Crypto era)
mkKeyHash :: forall c discriminator. Crypto c => Int -> KeyHash discriminator c
mkScriptHash :: forall c. Crypto c => Int -> ScriptHash c

-- | This is not a valid transaction. We don't care, we are only interested
--   in serialisation, not validation.
exampleTx :: forall era. ShelleyBasedEra' era => (TxBody era -> KeyPairWits era -> Witnesses era) -> TxBody era -> AuxiliaryData era -> Tx era
exampleProposedPParamsUpdates :: (ShelleyBasedEra' era, PParamsDelta era ~ PParams' StrictMaybe era) => ProposedPPUpdates era
examplePoolDistr :: forall c. PraosCrypto c => PoolDistr c
exampleNonMyopicRewards :: forall c. PraosCrypto c => Map (Either Coin (Credential 'Staking c)) (Map (KeyHash 'StakePool c) Coin)

-- | These are dummy values.
testShelleyGenesis :: ShelleyGenesis era

-- | This is probably not a valid ledger. We don't care, we are only
--   interested in serialisation, not validation.
exampleNewEpochState :: forall era. (ShelleyBasedEra' era, HasField "_a0" (PParams era) NonNegativeInterval, HasField "_d" (PParams era) UnitInterval, HasField "_protocolVersion" (PParams era) ProtVer, HasField "_nOpt" (PParams era) Natural, HasField "_rho" (PParams era) UnitInterval, HasField "_tau" (PParams era) UnitInterval, Default (StashedAVVMAddresses era)) => Value era -> PParams era -> PParams era -> NewEpochState era
exampleLedgerChainDepState :: forall c. PraosCrypto c => Word64 -> ChainDepState c
testEpochInfo :: EpochInfo Identity
mkDummyHash :: forall h a. HashAlgorithm h => Proxy h -> Int -> Hash h a
mkDummySafeHash :: forall c a. Crypto c => Proxy c -> Int -> SafeHash c a
type StandardShelley = ShelleyEra StandardCrypto

-- | ShelleyLedgerExamples for Shelley era
ledgerExamplesShelley :: ShelleyLedgerExamples StandardShelley
mkWitnessesPreAlonzo :: ShelleyBasedEra' era => Proxy era -> TxBody era -> KeyPairWits era -> WitnessSet era
exampleCoin :: Coin
exampleTxBodyShelley :: TxBody StandardShelley
exampleMetadataMap :: Map Word64 Metadatum
exampleAuxiliaryDataShelley :: AuxiliaryData StandardShelley
exampleTxIns :: Crypto c => Set (TxIn c)
exampleCerts :: Crypto c => StrictSeq (DCert c)
exampleWithdrawals :: Crypto c => Wdrl c
exampleProposedPPUpdates :: (PParamsDelta era ~ PParams' StrictMaybe era, ShelleyBasedEra' era) => ProposedPPUpdates era
examplePayKey :: Crypto c => KeyPair 'Payment c
exampleStakeKey :: Crypto c => KeyPair 'Staking c
exampleKeys :: forall c r. Crypto c => AllIssuerKeys c r
keyToCredential :: Crypto c => KeyPair r c -> Credential r c

-- | <tt>mkKeyPair'</tt> from <tt>Test.Cardano.Ledger.Shelley.Utils</tt>
--   doesn't work for real crypto:
--   <a>https://github.com/input-output-hk/cardano-ledger/issues/1770</a>
mkDSIGNKeyPair :: forall c kd. DSIGNAlgorithm (DSIGN c) => Word8 -> KeyPair kd c
mkVRFKeyPair :: forall c. VRFAlgorithm (VRF c) => Proxy c -> Word8 -> (SignKeyVRF c, VerKeyVRF c)
examplePoolParams :: forall c. Crypto c => PoolParams c


-- | The cast of Characters for Shelley Ledger Examples (excluding the
--   genesis/cord nodes, which are in
--   Test.Cardano.Ledger.Shelley.Examples.Federation).
module Test.Cardano.Ledger.Shelley.Examples.Cast

-- | Alice's payment key pair
alicePay :: Crypto crypto => KeyPair 'Payment crypto

-- | Alice's stake key pair
aliceStake :: Crypto crypto => KeyPair 'Staking crypto

-- | Alice's payment credential
alicePHK :: Crypto crypto => Credential 'Payment crypto

-- | Alice's stake credential
aliceSHK :: Crypto crypto => Credential 'Staking crypto

-- | Alice's base address
aliceAddr :: Crypto crypto => Addr crypto

-- | Alice's base address
alicePtrAddr :: Crypto crypto => Addr crypto

-- | Alice's stake pool keys (cold keys, VRF keys, hot KES keys)
alicePoolKeys :: Crypto crypto => AllIssuerKeys crypto 'StakePool

-- | Alice's stake pool parameters
alicePoolParams :: forall crypto. Crypto crypto => PoolParams crypto

-- | Alice's VRF key hash
aliceVRFKeyHash :: forall crypto. Crypto crypto => Hash crypto (VerKeyVRF crypto)

-- | Bob's payment key pair
bobPay :: Crypto crypto => KeyPair 'Payment crypto

-- | Bob's stake key pair
bobStake :: Crypto crypto => KeyPair 'Staking crypto

-- | Bob's stake credential
bobSHK :: Crypto crypto => Credential 'Staking crypto

-- | Bob's address
bobAddr :: Crypto crypto => Addr crypto

-- | Bob's stake pool keys (cold keys, VRF keys, hot KES keys)
bobPoolKeys :: Crypto crypto => AllIssuerKeys crypto 'StakePool

-- | Bob's stake pool parameters
bobPoolParams :: forall crypto. Crypto crypto => PoolParams crypto

-- | Bob's VRF key hash
bobVRFKeyHash :: forall crypto. Crypto crypto => Hash crypto (VerKeyVRF crypto)
carlPay :: Crypto crypto => KeyPair 'Payment crypto

-- | Carl's stake key pair
carlStake :: Crypto crypto => KeyPair 'Staking crypto

-- | Carl's stake credential
carlSHK :: Crypto crypto => Credential 'Staking crypto

-- | Carl's address
carlAddr :: Crypto crypto => Addr crypto

-- | Daria's payment key pair
dariaPay :: Crypto crypto => KeyPair 'Payment crypto

-- | Daria's stake key pair
dariaStake :: Crypto crypto => KeyPair 'Staking crypto

-- | Daria's stake credential
dariaSHK :: Crypto crypto => Credential 'Staking crypto

-- | Daria's address
dariaAddr :: Crypto crypto => Addr crypto

module Test.Cardano.Ledger.Shelley.BenchmarkFunctions
ledgerSpendOneUTxO :: Integer -> ()
ledgerSpendOneGivenUTxO :: UTxOState B -> ()
initUTxO :: Integer -> UTxOState B
ledgerEnv :: PParams era ~ PParams era => LedgerEnv era
ledgerRegisterStakeKeys :: Word64 -> Word64 -> LedgerState B -> ()
ledgerDeRegisterStakeKeys :: Word64 -> Word64 -> LedgerState B -> ()
ledgerRewardWithdrawals :: Word64 -> Word64 -> LedgerState B -> ()
ledgerStateWithNregisteredKeys :: Word64 -> Word64 -> LedgerState B
ledgerRegisterStakePools :: Word64 -> Word64 -> LedgerState B -> ()
ledgerReRegisterStakePools :: Word64 -> Word64 -> LedgerState B -> ()
ledgerRetireStakePools :: Word64 -> Word64 -> LedgerState B -> ()
ledgerStateWithNregisteredPools :: Word64 -> Word64 -> LedgerState B
ledgerDelegateManyKeysOnePool :: Word64 -> Word64 -> LedgerState B -> ()
ledgerStateWithNkeysMpools :: Word64 -> Word64 -> LedgerState B
type B = ShelleyEra B_Crypto
data B_Crypto
instance Cardano.Ledger.Crypto.Crypto Test.Cardano.Ledger.Shelley.BenchmarkFunctions.B_Crypto
instance Cardano.Protocol.TPraos.API.PraosCrypto Test.Cardano.Ledger.Shelley.BenchmarkFunctions.B_Crypto

module Test.Cardano.Ledger.Shelley.Address.Bootstrap
genBootstrapAddress :: Gen (BootstrapAddress crypto)
testBootstrapSpending :: Assertion
testBootstrapNotSpending :: Assertion
bootstrapHashTest :: TestTree
genSignature :: forall a b. DSIGNAlgorithm a => Gen (SignedDSIGN a b)
aliceByronAddr :: Address
instance Cardano.Ledger.Crypto.Crypto Test.Cardano.Ledger.Shelley.Address.Bootstrap.C_crypto


-- | This module suppies tools to tersely describe the differences between
--   2 values of the same type.
module Test.Cardano.Ledger.TerseTools
class Terse t
terse :: Terse t => t -> String
data Case a b
OnLeft :: !a -> !b -> Case a b
OnRight :: !a -> !b -> Case a b
SameKey :: !a -> !b -> !b -> Case a b
caseKey :: Case p b -> p

-- | we assume the lists are lexigraphically sorted
differences :: (Ord a, Eq b) => [(a, b)] -> [(a, b)] -> [Case a b]
mapdiffs :: (Ord a, Eq b) => Map a b -> Map a b -> [Case a b]
terselist :: Terse a => [Char] -> [a] -> [Char]
terselistfilter :: Terse a => [Char] -> (a -> Bool) -> [a] -> [Char]
tersemap :: (Terse k, Terse a) => [Char] -> Map k a -> [Char]
tersemapfilter :: (Terse k, Terse a) => [Char] -> (a -> Bool) -> Map k a -> [Char]
tersemapdiffs :: (Terse a, Terse b, Ord a, Eq b) => String -> Map a b -> Map a b -> [Char]
tersediffincremental :: String -> IncrementalStake crypto -> IncrementalStake crypto -> String
terseutxo :: (Era era, Terse (TxOut era)) => String -> UTxO era -> String
instance (Test.Cardano.Ledger.TerseTools.Terse a, Test.Cardano.Ledger.TerseTools.Terse b) => GHC.Show.Show (Test.Cardano.Ledger.TerseTools.Case a b)
instance (Test.Cardano.Ledger.TerseTools.Terse a, Test.Cardano.Ledger.TerseTools.Terse b) => Test.Cardano.Ledger.TerseTools.Terse (Test.Cardano.Ledger.TerseTools.Case a b)
instance (Test.Cardano.Ledger.TerseTools.Terse a, Test.Cardano.Ledger.TerseTools.Terse b) => Test.Cardano.Ledger.TerseTools.Terse (a, b)
instance (Test.Cardano.Ledger.TerseTools.Terse a, Test.Cardano.Ledger.TerseTools.Terse b, Test.Cardano.Ledger.TerseTools.Terse c) => Test.Cardano.Ledger.TerseTools.Terse (a, b, c)
instance Test.Cardano.Ledger.TerseTools.Terse (Cardano.Ledger.Address.Addr crypto)
instance Test.Cardano.Ledger.TerseTools.Terse (Cardano.Ledger.Credential.Credential keyrole c)
instance Test.Cardano.Ledger.TerseTools.Terse Cardano.Ledger.Credential.Ptr
instance Test.Cardano.Ledger.TerseTools.Terse (Cardano.Ledger.TxIn.TxId era)
instance Cardano.Ledger.Crypto.Crypto era => Test.Cardano.Ledger.TerseTools.Terse (Cardano.Ledger.TxIn.TxIn era)
instance Test.Cardano.Ledger.TerseTools.Terse Cardano.Ledger.Coin.Coin

module Test.Cardano.Ledger.Shelley.Rules.TestChain
removedAfterPoolreap :: forall era. (ChainProperty era, Default (State (EraRule "PPUP" era)), EraGen era, HasTrace (CHAIN era) (GenEnv era)) => Property

-- | Various preservation properties
adaPreservationChain :: forall era ledger. (EraGen era, TestingLedger era ledger, State (EraRule "PPUP" era) ~ PPUPState era, ChainProperty era, HasTrace (CHAIN era) (GenEnv era), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era))) => Property

-- | Tx inputs are eliminated, outputs added to utxo and TxIds are unique
collisionFreeComplete :: forall era ledger. (EraGen era, ChainProperty era, TestingLedger era ledger, Default (State (EraRule "PPUP" era)), HasTrace (CHAIN era) (GenEnv era), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "addrWits" (Witnesses era) (Set (WitVKey 'Witness (Crypto era))), HasField "scriptWits" (Witnesses era) (Map (ScriptHash (Crypto era)) (Script era))) => Property

-- | Various properties of the POOL STS Rule, tested on longer traces
--   (double the default length)
poolProperties :: forall era. (EraGen era, Default (State (EraRule "PPUP" era)), ChainProperty era, HasTrace (CHAIN era) (GenEnv era), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era)))) => Property

-- | Various properties of the POOL STS Rule, tested on longer traces
--   (double the default length)
delegProperties :: forall era. (EraGen era, Default (State (EraRule "PPUP" era)), HasTrace (CHAIN era) (GenEnv era), ChainProperty era, HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era)))) => Property
forAllChainTrace :: forall era prop. (Testable prop, Default (State (EraRule "PPUP" era)), EraGen era, HasTrace (CHAIN era) (GenEnv era)) => Word64 -> (Trace (CHAIN era) -> prop) -> Property

-- | Reconstruct a LEDGER trace from the transactions in a Block and
--   ChainState
ledgerTraceFromBlock :: forall era ledger. (ChainProperty era, TestingLedger era ledger) => ChainState era -> Block (BHeader (Crypto era)) era -> (ChainState era, Trace ledger)
type TestingLedger era ledger = (BaseM ledger ~ ReaderT Globals Identity, Environment ledger ~ LedgerEnv era, State ledger ~ LedgerState era, Signal ledger ~ Tx era, Embed (EraRule "DELEGS" era) ledger, Embed (EraRule "UTXOW" era) ledger, STS ledger)

-- | Compute the current Stake Distribution. This was called at the Epoch
--   boundary in the Snap Rule. Now it is called in the tests to see that
--   its incremental analog <a>incrementalStakeDistr</a> agrees.
stakeDistr :: forall era. Era era => UTxO era -> DState (Crypto era) -> PState (Crypto era) -> SnapShot (Crypto era)

-- | STAKE INCR
stakeIncrTest :: forall era ledger. (EraGen era, TestingLedger era ledger, State (EraRule "PPUP" era) ~ PPUPState era, ChainProperty era, HasTrace (CHAIN era) (GenEnv era)) => Property
incrementalStakeProp :: forall era. (EraGen era, HasTrace (CHAIN era) (GenEnv era), Default (State (EraRule "PPUP" era))) => Proxy era -> Property

-- | Sum up all the Coin for each staking Credential. This function has an
--   incremental analog. See
--   <tt>incrementalAggregateUtxoCoinByCredential</tt>
aggregateUtxoCoinByCredential :: forall era. Era era => Map Ptr (Credential 'Staking (Crypto era)) -> UTxO era -> Map (Credential 'Staking (Crypto era)) Coin -> Map (Credential 'Staking (Crypto era)) Coin

-- | Split a Trace into several shorter traces. The leftmost Trace (at the
--   front of the list) might be ill-formed, depending on what <tt>p</tt>
--   does.
splitTrace :: (State s -> State s -> Bool) -> Trace s -> [Trace s]

-- | Test a property on the first <tt>subtracecount</tt> sub-Traces that
--   end on an EpochBoundary
forEachEpochTrace :: forall era prop. (EraGen era, Testable prop, HasTrace (CHAIN era) (GenEnv era), Default (State (EraRule "PPUP" era))) => Int -> Word64 -> (Trace (CHAIN era) -> prop) -> Property

module Test.Cardano.Ledger.Shelley.PropertyTests

-- | <a>TestTree</a> of property-based testing properties.
propertyTests :: forall era ledger. (EraGen era, ChainProperty era, HasTrace (CHAIN era) (GenEnv era), HasTrace ledger (GenEnv era), Embed (EraRule "DELEGS" era) ledger, Embed (EraRule "UTXOW" era) ledger, State (EraRule "PPUP" era) ~ PPUPState era, Environment ledger ~ LedgerEnv era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "update" (TxBody era) (StrictMaybe (Update era)), HasField "addrWits" (Witnesses era) (Set (WitVKey 'Witness (Crypto era))), HasField "scriptWits" (Witnesses era) (Map (ScriptHash (Crypto era)) (Script era)), BaseEnv ledger ~ Globals, BaseM ledger ~ ReaderT Globals Identity, State ledger ~ LedgerState era, Signal ledger ~ Tx era, Show (TxSeq era)) => TestTree
minimalPropertyTests :: forall era ledger. (EraGen era, TestingLedger era ledger, ChainProperty era, HasTrace (CHAIN era) (GenEnv era), State (EraRule "PPUP" era) ~ PPUPState era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "update" (TxBody era) (StrictMaybe (Update era)), Show (TxSeq era)) => TestTree
relevantCasesAreCovered :: forall era. (EraGen era, Default (State (EraRule "PPUP" era)), ChainProperty era, HasTrace (CHAIN era) (GenEnv era), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "update" (TxBody era) (StrictMaybe (Update era))) => Property

-- | Various properties of the POOL STS Rule, tested on longer traces
--   (double the default length)
delegProperties :: forall era. (EraGen era, Default (State (EraRule "PPUP" era)), HasTrace (CHAIN era) (GenEnv era), ChainProperty era, HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era)))) => Property

-- | Various properties of the POOL STS Rule, tested on longer traces
--   (double the default length)
poolProperties :: forall era. (EraGen era, Default (State (EraRule "PPUP" era)), ChainProperty era, HasTrace (CHAIN era) (GenEnv era), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era)))) => Property
removedAfterPoolreap :: forall era. (ChainProperty era, Default (State (EraRule "PPUP" era)), EraGen era, HasTrace (CHAIN era) (GenEnv era)) => Property

-- | Various preservation properties
adaPreservationChain :: forall era ledger. (EraGen era, TestingLedger era ledger, State (EraRule "PPUP" era) ~ PPUPState era, ChainProperty era, HasTrace (CHAIN era) (GenEnv era), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era))) => Property

-- | Tx inputs are eliminated, outputs added to utxo and TxIds are unique
collisionFreeComplete :: forall era ledger. (EraGen era, ChainProperty era, TestingLedger era ledger, Default (State (EraRule "PPUP" era)), HasTrace (CHAIN era) (GenEnv era), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "addrWits" (Witnesses era) (Set (WitVKey 'Witness (Crypto era))), HasField "scriptWits" (Witnesses era) (Map (ScriptHash (Crypto era)) (Script era))) => Property
onlyValidLedgerSignalsAreGenerated :: forall era ledger. (EraGen era, ChainProperty era, HasTrace ledger (GenEnv era), Default (State (EraRule "PPUP" era)), BaseEnv ledger ~ Globals, State ledger ~ LedgerState era, Show (Environment ledger), Show (Signal ledger)) => Property
onlyValidChainSignalsAreGenerated :: forall era. (EraGen era, Default (State (EraRule "PPUP" era)), HasTrace (CHAIN era) (GenEnv era), Show (TxSeq era)) => Property
propCompactAddrRoundTrip :: Crypto crypto => Addr crypto -> Bool
propCompactSerializationAgree :: Addr crypto -> Bool


-- | Currently this uses the trace mechanism to check that computing
--   rewards has a required set of properties. It works only in the Shelley
--   Era. It could be generalized, and then moved to the
--   Generator<i>Trace</i> directory which computes property tests in all
--   eras.
module Test.Cardano.Ledger.Shelley.Rewards
rewardTests :: TestTree
type C = ShelleyEra C_Crypto

-- | Parse the command line arguments and run the tests.
--   
--   When the tests finish, this function calls <a>exitWith</a> with the
--   exit code that indicates whether any tests have failed. Most external
--   systems (stack, cabal, travis-ci, jenkins etc.) rely on the exit code
--   to detect whether the tests pass. If you want to do something else
--   after <a>defaultMain</a> returns, you need to catch the exception and
--   then re-throw it. Example:
--   
--   <pre>
--   import Test.Tasty
--   import Test.Tasty.HUnit
--   import System.Exit
--   import Control.Exception
--   
--   test = testCase "Test 1" (2 @?= 3)
--   
--   main = defaultMain test
--     `catch` (\e -&gt; do
--       if e == ExitSuccess
--         then putStrLn "Yea"
--         else putStrLn "Nay"
--       throwIO e)
--   </pre>
defaultMain :: TestTree -> IO ()

-- | Provide a legitimate NewEpochState to make an test Property
newEpochProp :: Word64 -> (NewEpochState C -> Property) -> Property

-- | Given a NewEpochState and [ChainEvent], test a Property at every Epoch
--   Boundary
newEpochEventsProp :: Word64 -> ([ChainEvent C] -> NewEpochState C -> Property) -> Property
ppAgg :: Map (Credential 'Staking (Crypto C)) (Set (Reward (Crypto C))) -> PDoc
data RewardUpdateOld crypto
RewardUpdateOld :: !DeltaCoin -> !DeltaCoin -> !Map (Credential 'Staking crypto) Coin -> !DeltaCoin -> !NonMyopic crypto -> RewardUpdateOld crypto
[deltaTOld] :: RewardUpdateOld crypto -> !DeltaCoin
[deltaROld] :: RewardUpdateOld crypto -> !DeltaCoin
[rsOld] :: RewardUpdateOld crypto -> !Map (Credential 'Staking crypto) Coin
[deltaFOld] :: RewardUpdateOld crypto -> !DeltaCoin
[nonMyopicOld] :: RewardUpdateOld crypto -> !NonMyopic crypto
createRUpdOld :: forall era. (HasField "_d" (PParams era) UnitInterval, HasField "_rho" (PParams era) UnitInterval, HasField "_tau" (PParams era) UnitInterval, HasField "_protocolVersion" (PParams era) ProtVer, HasField "_a0" (PParams era) NonNegativeInterval, HasField "_nOpt" (PParams era) Natural) => EpochSize -> BlocksMade (Crypto era) -> EpochState era -> Coin -> ShelleyBase (RewardUpdateOld (Crypto era))
createRUpdOld_ :: forall era. (HasField "_d" (PParams era) UnitInterval, HasField "_rho" (PParams era) UnitInterval, HasField "_tau" (PParams era) UnitInterval, HasField "_protocolVersion" (PParams era) ProtVer, HasField "_a0" (PParams era) NonNegativeInterval, HasField "_nOpt" (PParams era) Natural) => EpochSize -> BlocksMade (Crypto era) -> SnapShots (Crypto era) -> Coin -> PParams era -> Coin -> Set (Credential 'Staking (Crypto era)) -> NonMyopic (Crypto era) -> ShelleyBase (RewardUpdateOld (Crypto era))
instance GHC.Classes.Eq (Test.Cardano.Ledger.Shelley.Rewards.RewardUpdateOld crypto)
instance GHC.Show.Show (Test.Cardano.Ledger.Shelley.Rewards.RewardUpdateOld crypto)
instance Test.Cardano.Ledger.TerseTools.Terse (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance Cardano.Ledger.Pretty.PrettyA x => Test.Cardano.Ledger.TerseTools.Terse (Data.Set.Internal.Set x)
instance Cardano.Ledger.Pretty.PrettyA (Cardano.Ledger.Shelley.Rewards.Reward crypto)

module Test.TestScenario
data TestScenario
ContinuousIntegration :: TestScenario
Development :: TestScenario
Nightly :: TestScenario
Fast :: TestScenario
logScenario :: Ingredient
mainWithTestScenario :: TestTree -> IO ()
helpText :: [Char]
instance GHC.Show.Show Test.TestScenario.TestScenario
instance GHC.Read.Read Test.TestScenario.TestScenario
instance Test.Tasty.Options.IsOption Test.TestScenario.TestScenario
