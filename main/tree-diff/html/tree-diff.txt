-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Diffing of (expression) trees.
--   
--   Common diff algorithm works on list structures:
--   
--   <pre>
--   diff :: Eq a =&gt; [a] -&gt; [a] -&gt; [Edit a]
--   </pre>
--   
--   This package works on trees.
--   
--   <pre>
--   treeDiff :: Eq a =&gt; Tree a -&gt; Tree a -&gt; Edit (EditTree a)
--   </pre>
--   
--   This package also provides a way to diff arbitrary ADTs, using
--   <tt>Generics</tt>-derivable helpers.
--   
--   This package differs from <a>gdiff</a>, in a two ways:
--   <tt>tree-diff</tt> doesn't have patch function, and the "edit-script"
--   is a tree itself, which is useful for pretty-printing.
--   
--   <pre>
--   &gt;&gt;&gt; prettyEditExpr $ ediff (Foo 42 [True, False] "old") (Foo 42 [False, False, True] "new")
--   Foo
--     {fooBool = [-True, +False, False, +True],
--      fooInt = 42,
--      fooString = -"old" +"new"}
--   </pre>
@package tree-diff
@version 0.3


-- | A list diff.
module Data.TreeDiff.List

-- | List difference.
--   
--   <pre>
--   &gt;&gt;&gt; diffBy (==) "hello" "world"
--   [Swp 'h' 'w',Swp 'e' 'o',Swp 'l' 'r',Cpy 'l',Swp 'o' 'd']
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; diffBy (==) "kitten" "sitting"
--   [Swp 'k' 's',Cpy 'i',Cpy 't',Cpy 't',Swp 'e' 'i',Cpy 'n',Ins 'g']
--   </pre>
--   
--   <pre>
--   \xs ys -&gt; length (diffBy (==) xs ys) &gt;= max (length xs) (length (ys :: String))
--   </pre>
--   
--   <pre>
--   \xs ys -&gt; length (diffBy (==) xs ys) &lt;= length xs + length (ys :: String)
--   </pre>
diffBy :: forall a. Show a => (a -> a -> Bool) -> [a] -> [a] -> [Edit a]

-- | List edit operations
--   
--   The <a>Swp</a> constructor is redundant, but it let us spot a
--   recursion point when performing tree diffs.
data Edit a

-- | insert
Ins :: a -> Edit a

-- | delete
Del :: a -> Edit a

-- | copy unchanged
Cpy :: a -> Edit a

-- | swap, i.e. delete + insert
Swp :: a -> a -> Edit a
instance GHC.Show.Show a => GHC.Show.Show (Data.TreeDiff.List.Edit a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.TreeDiff.List.Edit a)
instance GHC.Show.Show a => GHC.Show.Show (Data.TreeDiff.List.Cell a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Data.TreeDiff.List.Edit a)


-- | Map which remembers the <a>fromList</a> order. This module is minimal
--   on purpose.
module Data.TreeDiff.OMap
data OMap k v

-- | <pre>
--   &gt;&gt;&gt; toAscList $ fromList [('a', "alpha"), ('b', "beta"), ('g', "gamma")]
--   [('a',"alpha"),('b',"beta"),('g',"gamma")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toAscList $ fromList [('g', "gamma"), ('b', "beta"), ('a', "alpha")]
--   [('a',"alpha"),('b',"beta"),('g',"gamma")]
--   </pre>
toAscList :: OMap k v -> [(k, v)]

-- | <i>O(n log n)</i>. List in creation order. Doesn't respect <a>Eq</a>
--   instance.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ fromList [('a', "alpha"), ('b', "beta"), ('g', "gamma")]
--   [('a',"alpha"),('b',"beta"),('g',"gamma")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toList $ fromList [('g', "gamma"), ('b', "beta"), ('a', "alpha")]
--   [('g',"gamma"),('b',"beta"),('a',"alpha")]
--   </pre>
toList :: OMap k v -> [(k, v)]

-- | <pre>
--   &gt;&gt;&gt; fromList [('g', "gamma"), ('b', "beta"), ('a', "alpha")]
--   fromList [('g',"gamma"),('b',"beta"),('a',"alpha")]
--   </pre>
fromList :: Ord k => [(k, v)] -> OMap k v

-- | <pre>
--   &gt;&gt;&gt; empty :: OMap String Integer
--   fromList []
--   </pre>
empty :: OMap k v

-- | Elements in key ascending order.
elems :: OMap k v -> [v]
instance GHC.Base.Functor Data.TreeDiff.OMap.Val
instance GHC.Base.Functor (Data.TreeDiff.OMap.OMap k)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Data.TreeDiff.OMap.OMap k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.TreeDiff.OMap.OMap k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (Data.TreeDiff.OMap.OMap k v)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Data.TreeDiff.OMap.OMap k v)
instance (GHC.Classes.Ord k, Test.QuickCheck.Arbitrary.Arbitrary k, Test.QuickCheck.Arbitrary.Arbitrary v) => Test.QuickCheck.Arbitrary.Arbitrary (Data.TreeDiff.OMap.OMap k v)
instance (GHC.Classes.Ord k, Test.QuickCheck.Arbitrary.Arbitrary k) => Test.QuickCheck.Arbitrary.Arbitrary1 (Data.TreeDiff.OMap.OMap k)
instance GHC.Classes.Ord k => Data.Semialign.Internal.Semialign (Data.TreeDiff.OMap.OMap k)
instance Control.DeepSeq.NFData v => Control.DeepSeq.NFData (Data.TreeDiff.OMap.Val v)


-- | This module uses <a>Expr</a> for richer diffs than based on
--   <tt>Tree</tt>.
module Data.TreeDiff.Expr

-- | A untyped Haskell-like expression.
--   
--   Having richer structure than just <tt>Tree</tt> allows to have richer
--   diffs.
data Expr

-- | application
App :: ConstructorName -> [Expr] -> Expr

-- | record constructor
Rec :: ConstructorName -> OMap FieldName Expr -> Expr

-- | list constructor
Lst :: [Expr] -> Expr

-- | Constructor name is a string
type ConstructorName = String

-- | Record field name is a string too.
type FieldName = String

-- | Type used in the result of <tt>ediff</tt>.
data EditExpr
EditApp :: ConstructorName -> [Edit EditExpr] -> EditExpr
EditRec :: ConstructorName -> OMap FieldName (Edit EditExpr) -> EditExpr
EditLst :: [Edit EditExpr] -> EditExpr

-- | unchanged tree
EditExp :: Expr -> EditExpr

-- | List edit operations
--   
--   The <a>Swp</a> constructor is redundant, but it let us spot a
--   recursion point when performing tree diffs.
data Edit a

-- | insert
Ins :: a -> Edit a

-- | delete
Del :: a -> Edit a

-- | copy unchanged
Cpy :: a -> Edit a

-- | swap, i.e. delete + insert
Swp :: a -> a -> Edit a

-- | Diff two <a>Expr</a>.
--   
--   For examples see <tt>ediff</tt> in <a>Data.TreeDiff.Class</a>.
exprDiff :: Expr -> Expr -> Edit EditExpr
instance GHC.Show.Show Data.TreeDiff.Expr.Expr
instance GHC.Classes.Ord Data.TreeDiff.Expr.Expr
instance GHC.Classes.Eq Data.TreeDiff.Expr.Expr
instance GHC.Show.Show Data.TreeDiff.Expr.EditExpr
instance Control.DeepSeq.NFData Data.TreeDiff.Expr.EditExpr
instance Control.DeepSeq.NFData Data.TreeDiff.Expr.Expr
instance Test.QuickCheck.Arbitrary.Arbitrary Data.TreeDiff.Expr.Expr


-- | A <a>ToExpr</a> class.
module Data.TreeDiff.Class

-- | Difference between two <a>ToExpr</a> values.
--   
--   <pre>
--   &gt;&gt;&gt; let x = (1, Just 2) :: (Int, Maybe Int)
--   
--   &gt;&gt;&gt; let y = (1, Nothing)
--   
--   &gt;&gt;&gt; prettyEditExpr (ediff x y)
--   _×_ 1 -(Just 2) +Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo { fooInt :: Either Char Int, fooBool :: [Maybe Bool], fooString :: String } deriving (Eq, Generic)
--   
--   &gt;&gt;&gt; instance ToExpr Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prettyEditExpr $ ediff (Foo (Right 2) [Just True] "fo") (Foo (Right 3) [Just True] "fo")
--   Foo {fooInt = Right -2 +3, fooBool = [Just True], fooString = "fo"}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prettyEditExpr $ ediff (Foo (Right 42) [Just True, Just False] "old") (Foo (Right 42) [Nothing, Just False, Just True] "new")
--   Foo {
--     fooInt = Right 42,
--     fooBool = [-Just True, +Nothing, Just False, +Just True],
--     fooString = -"old" +"new"}
--   </pre>
ediff :: ToExpr a => a -> a -> Edit EditExpr

-- | Compare different types.
--   
--   <i>Note:</i> Use with care as you can end up comparing apples with
--   oranges.
--   
--   <pre>
--   &gt;&gt;&gt; prettyEditExpr $ ediff' ["foo", "bar"] [Just "foo", Nothing]
--   [-"foo", +Just "foo", -"bar", +Nothing]
--   </pre>
ediff' :: (ToExpr a, ToExpr b) => a -> b -> Edit EditExpr

-- | <a>toExpr</a> converts a Haskell value into untyped Haskell-like
--   syntax tree, <a>Expr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toExpr ((1, Just 2) :: (Int, Maybe Int))
--   App "_\215_" [App "1" [],App "Just" [App "2" []]]
--   </pre>
class ToExpr a
toExpr :: ToExpr a => a -> Expr
toExpr :: (ToExpr a, Generic a, GToExpr (Rep a)) => a -> Expr
listToExpr :: ToExpr a => [a] -> Expr

-- | An alternative implementation for literal types. We use <a>show</a>
--   representation of them.
defaultExprViaShow :: Show a => a -> Expr

-- | Generic <a>toExpr</a>.
--   
--   <pre>
--   &gt;&gt;&gt; data Foo = Foo Int Char deriving Generic
--   
--   &gt;&gt;&gt; genericToExpr (Foo 42 'x')
--   App "Foo" [App "42" [],App "'x'" []]
--   </pre>
genericToExpr :: (Generic a, GToExpr (Rep a)) => a -> Expr
class GToExpr f
instance GHC.Show.Show Data.TreeDiff.Class.AppOrRec
instance (GHC.Generics.Constructor c, Data.TreeDiff.Class.GProductToExpr f) => Data.TreeDiff.Class.GSumToExpr (GHC.Generics.M1 i c f)
instance (Data.TreeDiff.Class.GProductToExpr f, Data.TreeDiff.Class.GProductToExpr g) => Data.TreeDiff.Class.GProductToExpr (f GHC.Generics.:*: g)
instance Data.TreeDiff.Class.GProductToExpr GHC.Generics.U1
instance (GHC.Generics.Selector s, Data.TreeDiff.Class.GLeafToExpr f) => Data.TreeDiff.Class.GProductToExpr (GHC.Generics.M1 i s f)
instance Data.TreeDiff.Class.ToExpr x => Data.TreeDiff.Class.GLeafToExpr (GHC.Generics.K1 i x)
instance Data.TreeDiff.Class.GSumToExpr f => Data.TreeDiff.Class.GToExpr (GHC.Generics.M1 i c f)
instance (Data.TreeDiff.Class.GSumToExpr f, Data.TreeDiff.Class.GSumToExpr g) => Data.TreeDiff.Class.GSumToExpr (f GHC.Generics.:+: g)
instance Data.TreeDiff.Class.GSumToExpr GHC.Generics.V1
instance Data.TreeDiff.Class.ToExpr Data.TreeDiff.Expr.Expr
instance Data.TreeDiff.Class.ToExpr ()
instance Data.TreeDiff.Class.ToExpr GHC.Types.Bool
instance Data.TreeDiff.Class.ToExpr GHC.Types.Ordering
instance Data.TreeDiff.Class.ToExpr GHC.Integer.Type.Integer
instance Data.TreeDiff.Class.ToExpr GHC.Natural.Natural
instance Data.TreeDiff.Class.ToExpr GHC.Types.Float
instance Data.TreeDiff.Class.ToExpr GHC.Types.Double
instance Data.TreeDiff.Class.ToExpr GHC.Types.Int
instance Data.TreeDiff.Class.ToExpr GHC.Int.Int8
instance Data.TreeDiff.Class.ToExpr GHC.Int.Int16
instance Data.TreeDiff.Class.ToExpr GHC.Int.Int32
instance Data.TreeDiff.Class.ToExpr GHC.Int.Int64
instance Data.TreeDiff.Class.ToExpr GHC.Types.Word
instance Data.TreeDiff.Class.ToExpr GHC.Word.Word8
instance Data.TreeDiff.Class.ToExpr GHC.Word.Word16
instance Data.TreeDiff.Class.ToExpr GHC.Word.Word32
instance Data.TreeDiff.Class.ToExpr GHC.Word.Word64
instance Data.TreeDiff.Class.ToExpr (Data.Proxy.Proxy a)
instance Data.TreeDiff.Class.ToExpr GHC.Types.Char
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (GHC.Maybe.Maybe a)
instance (Data.TreeDiff.Class.ToExpr a, Data.TreeDiff.Class.ToExpr b) => Data.TreeDiff.Class.ToExpr (Data.Either.Either a b)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr [a]
instance (Data.TreeDiff.Class.ToExpr a, Data.TreeDiff.Class.ToExpr b) => Data.TreeDiff.Class.ToExpr (a, b)
instance (Data.TreeDiff.Class.ToExpr a, Data.TreeDiff.Class.ToExpr b, Data.TreeDiff.Class.ToExpr c) => Data.TreeDiff.Class.ToExpr (a, b, c)
instance (Data.TreeDiff.Class.ToExpr a, Data.TreeDiff.Class.ToExpr b, Data.TreeDiff.Class.ToExpr c, Data.TreeDiff.Class.ToExpr d) => Data.TreeDiff.Class.ToExpr (a, b, c, d)
instance (Data.TreeDiff.Class.ToExpr a, Data.TreeDiff.Class.ToExpr b, Data.TreeDiff.Class.ToExpr c, Data.TreeDiff.Class.ToExpr d, Data.TreeDiff.Class.ToExpr e) => Data.TreeDiff.Class.ToExpr (a, b, c, d, e)
instance (Data.TreeDiff.Class.ToExpr a, GHC.Real.Integral a) => Data.TreeDiff.Class.ToExpr (GHC.Real.Ratio a)
instance Data.Fixed.HasResolution a => Data.TreeDiff.Class.ToExpr (Data.Fixed.Fixed a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Functor.Identity.Identity a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Functor.Const.Const a b)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Control.Applicative.ZipList a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (GHC.Base.NonEmpty a)
instance Data.TreeDiff.Class.ToExpr Data.Void.Void
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Semigroup.Internal.Dual a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Semigroup.Internal.Sum a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Semigroup.Internal.Product a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Monoid.First a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Monoid.Last a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Semigroup.Option a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Semigroup.Min a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Semigroup.Max a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Semigroup.First a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Semigroup.Last a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Tree.Tree a)
instance (Data.TreeDiff.Class.ToExpr k, Data.TreeDiff.Class.ToExpr v) => Data.TreeDiff.Class.ToExpr (Data.Map.Internal.Map k v)
instance Data.TreeDiff.Class.ToExpr k => Data.TreeDiff.Class.ToExpr (Data.Set.Internal.Set k)
instance Data.TreeDiff.Class.ToExpr v => Data.TreeDiff.Class.ToExpr (Data.IntMap.Internal.IntMap v)
instance Data.TreeDiff.Class.ToExpr Data.IntSet.Internal.IntSet
instance Data.TreeDiff.Class.ToExpr v => Data.TreeDiff.Class.ToExpr (Data.Sequence.Internal.Seq v)
instance Data.TreeDiff.Class.ToExpr Data.Text.Internal.Lazy.Text
instance Data.TreeDiff.Class.ToExpr Data.Text.Internal.Text
instance Data.TreeDiff.Class.ToExpr Data.Time.Calendar.Days.Day
instance Data.TreeDiff.Class.ToExpr Data.Time.Clock.Internal.UTCTime.UTCTime
instance Data.TreeDiff.Class.ToExpr Data.ByteString.Lazy.Internal.ByteString
instance Data.TreeDiff.Class.ToExpr Data.ByteString.Internal.ByteString
instance Data.TreeDiff.Class.ToExpr Data.ByteString.Short.Internal.ShortByteString
instance Data.TreeDiff.Class.ToExpr Data.Scientific.Scientific
instance Data.TreeDiff.Class.ToExpr Data.UUID.Types.Internal.UUID
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Vector.Vector a)
instance (Data.TreeDiff.Class.ToExpr a, Data.Vector.Unboxed.Base.Unbox a) => Data.TreeDiff.Class.ToExpr (Data.Vector.Unboxed.Base.Vector a)
instance (Data.TreeDiff.Class.ToExpr a, Foreign.Storable.Storable a) => Data.TreeDiff.Class.ToExpr (Data.Vector.Storable.Vector a)
instance (Data.TreeDiff.Class.ToExpr a, Data.Primitive.Types.Prim a) => Data.TreeDiff.Class.ToExpr (Data.Vector.Primitive.Vector a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Tagged.Tagged t a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Hashable.Class.Hashed a)
instance (Data.TreeDiff.Class.ToExpr k, Data.TreeDiff.Class.ToExpr v) => Data.TreeDiff.Class.ToExpr (Data.HashMap.Internal.HashMap k v)
instance Data.TreeDiff.Class.ToExpr k => Data.TreeDiff.Class.ToExpr (Data.HashSet.Internal.HashSet k)
instance Data.TreeDiff.Class.ToExpr Data.Aeson.Types.Internal.Value
instance Data.TreeDiff.Class.ToExpr Data.Aeson.Key.Key
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Aeson.KeyMap.KeyMap a)
instance Data.TreeDiff.Class.ToExpr a => Data.TreeDiff.Class.ToExpr (Data.Strict.Maybe.Maybe a)
instance (Data.TreeDiff.Class.ToExpr a, Data.TreeDiff.Class.ToExpr b) => Data.TreeDiff.Class.ToExpr (Data.Strict.Either.Either a b)
instance (Data.TreeDiff.Class.ToExpr a, Data.TreeDiff.Class.ToExpr b) => Data.TreeDiff.Class.ToExpr (Data.Strict.These.These a b)
instance (Data.TreeDiff.Class.ToExpr a, Data.TreeDiff.Class.ToExpr b) => Data.TreeDiff.Class.ToExpr (Data.Strict.Tuple.Pair a b)
instance (Data.TreeDiff.Class.ToExpr a, Data.TreeDiff.Class.ToExpr b) => Data.TreeDiff.Class.ToExpr (Data.These.These a b)
instance Data.TreeDiff.Class.ToExpr Data.Primitive.ByteArray.ByteArray
instance Data.TreeDiff.Class.ToExpr Data.Array.Byte.ByteArray


-- | Utilities to parse <a>Expr</a>.
--   
--   <i>Note:</i> we don't parse diffs.
module Data.TreeDiff.Parser

-- | Parsers for <a>Expr</a> using <tt>parsers</tt> type-classes.
--   
--   You can use this with your parser-combinator library of choice:
--   <tt>parsec</tt>, <tt>attoparsec</tt>, <tt>trifecta</tt>...
exprParser :: (Monad m, TokenParsing m) => m Expr


-- | Utilities to pretty print <a>Expr</a> and <a>EditExpr</a>
module Data.TreeDiff.Pretty

-- | Because we don't want to commit to single pretty printing library, we
--   use explicit dictionary.
data Pretty doc
Pretty :: (ConstructorName -> doc) -> (doc -> [doc] -> doc) -> (doc -> [(FieldName, doc)] -> doc) -> ([doc] -> doc) -> (doc -> doc) -> (doc -> doc) -> (doc -> doc) -> ([doc] -> doc) -> doc -> (doc -> doc) -> Pretty doc

-- | Display <a>ConstructorName</a>
[ppCon] :: Pretty doc -> ConstructorName -> doc

-- | Display <a>App</a>
[ppApp] :: Pretty doc -> doc -> [doc] -> doc

-- | Display <a>Rec</a>
[ppRec] :: Pretty doc -> doc -> [(FieldName, doc)] -> doc

-- | Display <a>Lst</a>
[ppLst] :: Pretty doc -> [doc] -> doc

-- | Display unchanged parts
[ppCpy] :: Pretty doc -> doc -> doc

-- | Display added parts
[ppIns] :: Pretty doc -> doc -> doc

-- | Display removed parts
[ppDel] :: Pretty doc -> doc -> doc

-- | Combined edits (usually some <tt>sep</tt> combinator)
[ppEdits] :: Pretty doc -> [doc] -> doc

-- | Ellipsis
[ppEllip] :: Pretty doc -> doc

-- | Parens an expression
[ppParens] :: Pretty doc -> doc -> doc

-- | Pretty print an <a>Expr</a> using explicit pretty-printing dictionary.
ppExpr :: Pretty doc -> Expr -> doc

-- | Pretty print an <tt><a>Edit</a> <a>EditExpr</a></tt> using explicit
--   pretty-printing dictionary.
ppEditExpr :: Pretty doc -> Edit EditExpr -> doc

-- | Like <a>ppEditExpr</a> but print unchanged parts only shallowly
ppEditExprCompact :: Pretty doc -> Edit EditExpr -> doc

-- | <a>Pretty</a> via <tt>pretty</tt> library.
prettyPretty :: Pretty Doc

-- | Pretty print <a>Expr</a> using <tt>pretty</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; prettyExpr $ Rec "ex" (OMap.fromList [("[]", App "bar" [])])
--   ex {`[]` = bar}
--   </pre>
prettyExpr :: Expr -> Doc

-- | Pretty print <tt><a>Edit</a> <a>EditExpr</a></tt> using
--   <tt>pretty</tt>.
prettyEditExpr :: Edit EditExpr -> Doc

-- | Compact <a>prettyEditExpr</a>.
prettyEditExprCompact :: Edit EditExpr -> Doc

-- | <a>Pretty</a> via <tt>ansi-wl-pprint</tt> library (with colors).
ansiWlPretty :: Pretty Doc

-- | Pretty print <a>Expr</a> using <tt>ansi-wl-pprint</tt>.
ansiWlExpr :: Expr -> Doc

-- | Pretty print <tt><a>Edit</a> <a>EditExpr</a></tt> using
--   <tt>ansi-wl-pprint</tt>.
ansiWlEditExpr :: Edit EditExpr -> Doc

-- | Compact <a>ansiWlEditExpr</a>
ansiWlEditExprCompact :: Edit EditExpr -> Doc

-- | Like <a>ansiWlPretty</a> but color the background.
ansiWlBgPretty :: Pretty Doc

-- | Pretty print <a>Expr</a> using <tt>ansi-wl-pprint</tt>.
ansiWlBgExpr :: Expr -> Doc

-- | Pretty print <tt><a>Edit</a> <a>EditExpr</a></tt> using
--   <tt>ansi-wl-pprint</tt>.
ansiWlBgEditExpr :: Edit EditExpr -> Doc

-- | Compact <a>ansiWlBgEditExpr</a>.
ansiWlBgEditExprCompact :: Edit EditExpr -> Doc

-- | Escape field or constructor name
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ escapeName "Foo"
--   Foo
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ escapeName "_×_"
--   _×_
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ escapeName "-3"
--   `-3`
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ escapeName "kebab-case"
--   kebab-case
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ escapeName "inner space"
--   `inner space`
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ escapeName $ show "looks like a string"
--   "looks like a string"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ escapeName $ show "tricky" ++ "   "
--   `"tricky"   `
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ escapeName "[]"
--   `[]`
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ escapeName "_,_"
--   `_,_`
--   </pre>
escapeName :: String -> String


-- | Diffing of (expression) trees.
--   
--   Diffing arbitrary Haskell data. First we convert values to untyped
--   haskell-like expression <a>Expr</a> using generically derivable
--   <a>ToExpr</a> class. Then we can diff two <a>Expr</a> values. The
--   conversion and diffing is done by <a>ediff</a> function. See type and
--   function haddocks for an examples.
--   
--   Interesting modules:
--   
--   <ul>
--   <li><a>Data.TreeDiff.Class</a> for a <a>ToExpr</a> class and
--   <a>ediff</a> utility.</li>
--   <li><a>Data.TreeDiff.Golden</a> for golden tests helper</li>
--   <li><a>Data.TreeDiff.QuickCheck</a> for QuickCheck helper</li>
--   </ul>
module Data.TreeDiff


-- | "Golden tests" using <a>ediff</a> comparison.
module Data.TreeDiff.Golden

-- | Make a golden tests.
--   
--   <a>ediffGolden</a> is testing framework agnostic, thus the type looks
--   intimidating.
--   
--   An example using <tt>tasty-golden</tt>, <tt>goldenTest</tt> is
--   imported from <a>Test.Tasty.Golden.Advanced</a>
--   
--   <pre>
--   exTest :: TestTree
--   exTest = <a>ediffGolden</a> goldenTest "golden test" "fixtures/ex.expr" $
--      action constructing actual value
--   </pre>
--   
--   The <a>ediffGolden</a> will read an <a>Expr</a> from provided path to
--   golden file, and compare it with a <a>toExpr</a> of a result. If
--   values differ, the (compact) diff of two will be printed.
--   
--   See
--   <a>https://github.com/phadej/tree-diff/blob/master/tests/Tests.hs</a>
--   for a proper example.
ediffGolden :: (Eq a, ToExpr a) => (testName -> IO Expr -> IO Expr -> (Expr -> Expr -> IO (Maybe String)) -> (Expr -> IO ()) -> testTree) -> testName -> FilePath -> IO a -> testTree


-- | <tt>QuickCheck</tt> related utilities.
module Data.TreeDiff.QuickCheck

-- | A variant of <tt>===</tt>, which outputs a diff when values are
--   inequal.
ediffEq :: (Eq a, ToExpr a) => a -> a -> Property


-- | Tree diffing working on <tt>containers</tt> <a>Tree</a>.
module Data.TreeDiff.Tree

-- | A breadth-traversal diff.
--   
--   It's different from <tt>gdiff</tt>, as it doesn't produce a flat edit
--   script, but edit script iself is a tree. This makes visualising the
--   diff much simpler.
--   
--   <h4>Examples</h4>
--   
--   Let's start from simple tree. We pretty print them as s-expressions.
--   
--   <pre>
--   &gt;&gt;&gt; let x = Node 'a' [Node 'b' [], Node 'c' [return 'd', return 'e'], Node 'f' []]
--   
--   &gt;&gt;&gt; ppTree PP.char x
--   (a b (c d e) f)
--   </pre>
--   
--   If we modify an argument in a tree, we'll notice it's changed:
--   
--   <pre>
--   &gt;&gt;&gt; let y = Node 'a' [Node 'b' [], Node 'c' [return 'x', return 'e'], Node 'f' []]
--   
--   &gt;&gt;&gt; ppTree PP.char y
--   (a b (c x e) f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ppEditTree PP.char (treeDiff x y)
--   (a b (c -d +x e) f)
--   </pre>
--   
--   If we modify a constructor, the whole sub-trees is replaced, though
--   there might be common subtrees.
--   
--   <pre>
--   &gt;&gt;&gt; let z = Node 'a' [Node 'b' [], Node 'd' [], Node 'f' []]
--   
--   &gt;&gt;&gt; ppTree PP.char z
--   (a b d f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ppEditTree PP.char (treeDiff x z)
--   (a b -(c d e) +d f)
--   </pre>
--   
--   If we add arguments, they are spotted too:
--   
--   <pre>
--   &gt;&gt;&gt; let w = Node 'a' [Node 'b' [], Node 'c' [return 'd', return 'x', return 'e'], Node 'f' []]
--   
--   &gt;&gt;&gt; ppTree PP.char w
--   (a b (c d x e) f)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ppEditTree PP.char (treeDiff x w)
--   (a b (c d +x e) f)
--   </pre>
treeDiff :: (Show a, Eq a) => Tree a -> Tree a -> Edit (EditTree a)

-- | Type used in the result of <a>treeDiff</a>.
--   
--   It's essentially a <a>Tree</a>, but the forest list is changed from
--   <tt>[tree a]</tt> to <tt>[<a>Edit</a> (tree a)]</tt>. This highlights
--   that <a>treeDiff</a> performs a list diff on each tree level.
data EditTree a
EditNode :: a -> [Edit (EditTree a)] -> EditTree a

-- | List edit operations
--   
--   The <a>Swp</a> constructor is redundant, but it let us spot a
--   recursion point when performing tree diffs.
data Edit a

-- | insert
Ins :: a -> Edit a

-- | delete
Del :: a -> Edit a

-- | copy unchanged
Cpy :: a -> Edit a

-- | swap, i.e. delete + insert
Swp :: a -> a -> Edit a
instance GHC.Show.Show a => GHC.Show.Show (Data.TreeDiff.Tree.EditTree a)
