-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Shelley Ledger Executable Model
@package cardano-ledger-shelley
@version 0.1.0.0

module Cardano.Ledger.Chain
data ChainChecksPParams
ChainChecksPParams :: Natural -> Natural -> ProtVer -> ChainChecksPParams
[ccMaxBHSize] :: ChainChecksPParams -> Natural
[ccMaxBBSize] :: ChainChecksPParams -> Natural
[ccProtocolVersion] :: ChainChecksPParams -> ProtVer
data ChainPredicateFailure
HeaderSizeTooLargeCHAIN :: !Natural -> !Natural -> ChainPredicateFailure
BlockSizeTooLargeCHAIN :: !Natural -> !Natural -> ChainPredicateFailure
ObsoleteNodeCHAIN :: !Natural -> !Natural -> ChainPredicateFailure
pparamsToChainChecksPParams :: (HasField "_maxBHSize" pp Natural, HasField "_maxBBSize" pp Natural, HasField "_protocolVersion" pp ProtVer) => pp -> ChainChecksPParams
chainChecks :: MonadError ChainPredicateFailure m => Natural -> ChainChecksPParams -> BHeaderView crypto -> m ()
instance NoThunks.Class.NoThunks Cardano.Ledger.Chain.ChainChecksPParams
instance GHC.Generics.Generic Cardano.Ledger.Chain.ChainChecksPParams
instance GHC.Classes.Eq Cardano.Ledger.Chain.ChainChecksPParams
instance GHC.Show.Show Cardano.Ledger.Chain.ChainChecksPParams
instance GHC.Classes.Ord Cardano.Ledger.Chain.ChainPredicateFailure
instance GHC.Classes.Eq Cardano.Ledger.Chain.ChainPredicateFailure
instance GHC.Show.Show Cardano.Ledger.Chain.ChainPredicateFailure
instance GHC.Generics.Generic Cardano.Ledger.Chain.ChainPredicateFailure
instance NoThunks.Class.NoThunks Cardano.Ledger.Chain.ChainPredicateFailure

module Cardano.Ledger.Shelley.Address.Bootstrap
data BootstrapWitness crypto
pattern BootstrapWitness :: Crypto crypto => VKey 'Witness crypto -> SignedDSIGN crypto (Hash crypto EraIndependentTxBody) -> ChainCode -> ByteString -> BootstrapWitness crypto
newtype ChainCode
ChainCode :: ByteString -> ChainCode
[unChainCode] :: ChainCode -> ByteString

-- | Rebuild the addrRoot of the corresponding address.
bootstrapWitKeyHash :: forall crypto. Crypto crypto => BootstrapWitness crypto -> KeyHash 'Witness crypto
unpackByronVKey :: forall crypto. DSIGN crypto ~ Ed25519DSIGN => VerificationKey -> (VKey 'Witness crypto, ChainCode)
makeBootstrapWitness :: forall crypto. (DSIGN crypto ~ Ed25519DSIGN, Crypto crypto) => Hash crypto EraIndependentTxBody -> SigningKey -> Attributes AddrAttributes -> BootstrapWitness crypto
verifyBootstrapWit :: forall crypto. (Crypto crypto, Signable (DSIGN crypto) (Hash crypto EraIndependentTxBody)) => Hash crypto EraIndependentTxBody -> BootstrapWitness crypto -> Bool
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.Address.Bootstrap.ChainCode
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.Address.Bootstrap.ChainCode
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.Address.Bootstrap.ChainCode
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.Address.Bootstrap.ChainCode
instance GHC.Show.Show Cardano.Ledger.Shelley.Address.Bootstrap.ChainCode
instance GHC.Generics.Generic Cardano.Ledger.Shelley.Address.Bootstrap.ChainCode
instance GHC.Classes.Eq Cardano.Ledger.Shelley.Address.Bootstrap.ChainCode
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness crypto)
instance (Cardano.Ledger.Crypto.Crypto era, Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN (Cardano.Ledger.Crypto.DSIGN era)), Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SigDSIGN (Cardano.Ledger.Crypto.DSIGN era))) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness era)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Ord (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness crypto))


-- | <i>Deprecated: Use 'import Cardano.Ledger.CompactAddress' instead</i>
module Cardano.Ledger.Shelley.CompactAddr

module Cardano.Ledger.Shelley.Constraints
type UsesTxBody era = (Era era, ChainData (TxBody era), AnnotatedData (TxBody era), HashAnnotated (TxBody era) EraIndependentTxBody (Crypto era))
class (Era era, Val (Value era), Compactible (Value era), ChainData (Value era), SerialisableData (Value era), DecodeNonNegative (Value era), EncodeMint (Value era), DecodeMint (Value era)) => UsesValue era
class (Era era, ChainData (TxOut era), ToCBOR (TxOut era), FromCBOR (TxOut era)) => UsesTxOut era
makeTxOut :: UsesTxOut era => Proxy era -> Addr (Crypto era) -> Value era -> TxOut era
type UsesScript era = (Era era, Eq (Script era), Show (Script era), AnnotatedData (Script era))
type UsesAuxiliary era = (Era era, Eq (AuxiliaryData era), Show (AuxiliaryData era), ValidateAuxiliaryData era (Crypto era), AnnotatedData (AuxiliaryData era))
class (Era era, Eq (PParams era), Show (PParams era), SerialisableData (PParams era), ChainData (PParamsDelta era), Ord (PParamsDelta era), SerialisableData (PParamsDelta era)) => UsesPParams era
mergePPUpdates :: UsesPParams era => proxy era -> PParams era -> PParamsDelta era -> PParams era

-- | Apply <tt>c</tt> to all the types transitively involved with Value
--   when (Core.Value era) is an instance of Compactible
type TransValue (c :: Type -> Constraint) era = (Era era, Compactible (Value era), c (Value era))

module Cardano.Ledger.Shelley.HardForks
aggregatedRewards :: HasField "_protocolVersion" pp ProtVer => pp -> Bool

-- | Starting with protocol version 5, the MIR certs will also be able to
--   transfer funds between the reserves and the treasury. Additionally,
--   the semantics for the pervious functionality will change a bit. Before
--   version 5 redundancies in the instantaneous reward mapping were
--   handled by overriding. Now they are handled by adding the values and
--   allowing for negatives updates, provided the sum for each key remains
--   positive.
allowMIRTransfer :: HasField "_protocolVersion" pp ProtVer => pp -> Bool

-- | Starting with protocol version 5, we will validate the network ID for
--   the reward account listed in stake pool registration certificates.
validatePoolRewardAccountNetID :: HasField "_protocolVersion" pp ProtVer => pp -> Bool

-- | Starting with protocol version 5, Stake Credentials bound by scripts
--   will be eligibile for staking rewards.
allowScriptStakeCredsToEarnRewards :: HasField "_protocolVersion" pp ProtVer => pp -> Bool

-- | Starting with protocol version 6, we translate slots to time correctly
--   for Plutus scripts.
translateTimeForPlutusScripts :: HasField "_protocolVersion" pp ProtVer => pp -> Bool

-- | Starting with protocol version 7, the UTXO rule predicate failure
--   MissingScriptWitnessesUTXOW will not be used for extraneous scripts
missingScriptsSymmetricDifference :: HasField "_protocolVersion" pp ProtVer => pp -> Bool

-- | Starting with protocol version 7, the reward calculation no longer
--   filters out unregistered stake addresses at the moment the calculation
--   begins. See the Shelley Ledger Errata 17.2.
forgoRewardPrefilter :: HasField "_protocolVersion" pp ProtVer => pp -> Bool

-- | In versions 5 and 6, we allow the ttl field to lie outside the
--   stability window.
allowOutsideForecastTTL :: HasField "_protocolVersion" pp ProtVer => pp -> Bool

module Cardano.Ledger.Shelley.Metadata

-- | A generic metadatum type.
data Metadatum
Map :: ![(Metadatum, Metadatum)] -> Metadatum
List :: ![Metadatum] -> Metadatum
I :: !Integer -> Metadatum
B :: !ByteString -> Metadatum
S :: !Text -> Metadatum
data Metadata era
pattern Metadata :: Map Word64 Metadatum -> Metadata era
hashMetadata :: Era era => Metadata era -> SafeHash (Crypto era) EraIndependentAuxiliaryData
validMetadatum :: Metadatum -> Bool
instance GHC.Generics.Generic Cardano.Ledger.Shelley.Metadata.Metadatum
instance GHC.Classes.Ord Cardano.Ledger.Shelley.Metadata.Metadatum
instance GHC.Classes.Eq Cardano.Ledger.Shelley.Metadata.Metadatum
instance GHC.Show.Show Cardano.Ledger.Shelley.Metadata.Metadatum
instance Data.Typeable.Internal.Typeable era => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Metadata.Metadata era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Metadata.Metadata era)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.Metadata.Metadata era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Metadata.Metadata era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Metadata.Metadata era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Metadata.Metadata era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Shelley.Metadata.Metadata era)
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Shelley.Metadata.Metadata era) Cardano.Ledger.Hashes.EraIndependentAuxiliaryData c
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Metadata.Metadata era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.Metadata.Metadata era))
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.Metadata.Metadatum
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.Metadata.Metadatum
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.Metadata.Metadatum
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.Metadata.Metadatum

module Cardano.Ledger.Shelley.Orphans
instance Data.Aeson.Types.FromJSON.FromJSON Data.IP.Addr.IPv4
instance Data.Aeson.Types.ToJSON.ToJSON Data.IP.Addr.IPv4
instance Data.Aeson.Types.FromJSON.FromJSON Data.IP.Addr.IPv6
instance Data.Aeson.Types.ToJSON.ToJSON Data.IP.Addr.IPv6
instance NoThunks.Class.NoThunks Data.IP.Addr.IPv4
instance NoThunks.Class.NoThunks Data.IP.Addr.IPv6
instance Control.DeepSeq.NFData Data.IP.Addr.IPv4
instance Control.DeepSeq.NFData Data.IP.Addr.IPv6
instance NoThunks.Class.NoThunks Cardano.Crypto.Wallet.XSignature
instance Cardano.Crypto.Util.SignableRepresentation (Cardano.Crypto.Hash.Class.Hash a b)
instance Data.Default.Class.Default Cardano.Ledger.BaseTypes.Network
instance Cardano.Ledger.Crypto.Crypto b => Data.Default.Class.Default (Cardano.Ledger.Keys.KeyHash a b)
instance Data.Default.Class.Default (Data.Sequence.Strict.StrictSeq t)
instance Data.Default.Class.Default Data.ByteString.Short.Internal.ShortByteString
instance Data.Default.Class.Default Data.ByteString.Internal.ByteString
instance Data.Default.Class.Default Data.ByteString.Lazy.Internal.ByteString
instance Cardano.Crypto.Hash.Class.HashAlgorithm h => Data.Default.Class.Default (Cardano.Crypto.Hash.Class.Hash h b)
instance Data.Default.Class.Default GHC.Types.Bool


-- | This module contains just the type of protocol parameters.
module Cardano.Ledger.Shelley.PParams

-- | Protocol parameters.
--   
--   We use the HKD type family so that the protocol parameters type and
--   the type for the updates to the protocol parameters can share records
--   fields. The protocol parameters will have type <a>PParams'</a>
--   <a>Identity</a>, and the updates will have type <a>PParams'</a>
--   <a>StrictMaybe</a>, though <a>Identity</a> will be hidden from use.
--   
--   For example:
--   
--   <pre>
--   myParameters =
--     PParams
--       { _minfeeA = 0,
--         _minfeeB = 0,
--         ...
--       }
--   
--   myUpdate =
--     PParamsUpdate
--       { _minfeeA = SNothing,
--         _minfeeB = SJust 42,
--         ...
--       }
--   </pre>
data PParams' f era
PParams :: !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Coin -> !HKD f Coin -> !HKD f EpochNo -> !HKD f Natural -> !HKD f NonNegativeInterval -> !HKD f UnitInterval -> !HKD f UnitInterval -> !HKD f UnitInterval -> !HKD f Nonce -> !HKD f ProtVer -> !HKD f Coin -> !HKD f Coin -> PParams' f era

-- | The linear factor for the minimum fee calculation
[_minfeeA] :: PParams' f era -> !HKD f Natural

-- | The constant factor for the minimum fee calculation
[_minfeeB] :: PParams' f era -> !HKD f Natural

-- | Maximal block body size
[_maxBBSize] :: PParams' f era -> !HKD f Natural

-- | Maximal transaction size
[_maxTxSize] :: PParams' f era -> !HKD f Natural

-- | Maximal block header size
[_maxBHSize] :: PParams' f era -> !HKD f Natural

-- | The amount of a key registration deposit
[_keyDeposit] :: PParams' f era -> !HKD f Coin

-- | The amount of a pool registration deposit
[_poolDeposit] :: PParams' f era -> !HKD f Coin

-- | epoch bound on pool retirement
[_eMax] :: PParams' f era -> !HKD f EpochNo

-- | Desired number of pools
[_nOpt] :: PParams' f era -> !HKD f Natural

-- | Pool influence
[_a0] :: PParams' f era -> !HKD f NonNegativeInterval

-- | Monetary expansion
[_rho] :: PParams' f era -> !HKD f UnitInterval

-- | Treasury expansion
[_tau] :: PParams' f era -> !HKD f UnitInterval

-- | Decentralization parameter
[_d] :: PParams' f era -> !HKD f UnitInterval

-- | Extra entropy
[_extraEntropy] :: PParams' f era -> !HKD f Nonce

-- | Protocol version
[_protocolVersion] :: PParams' f era -> !HKD f ProtVer

-- | Minimum UTxO value
[_minUTxOValue] :: PParams' f era -> !HKD f Coin

-- | Minimum Stake Pool Cost
[_minPoolCost] :: PParams' f era -> !HKD f Coin
type PParams era = PParams' Identity era

-- | Returns a basic "empty" <a>PParams</a> structure with all zero values.
emptyPParams :: PParams era

-- | Higher Kinded Data
type family HKD f a
class HKDFunctor f
hkdMap :: HKDFunctor f => Proxy f -> (a -> b) -> HKD f a -> HKD f b
data PPUpdateEnv era
PPUpdateEnv :: SlotNo -> GenDelegs era -> PPUpdateEnv era

-- | Update operation for protocol parameters structure @PParams
newtype ProposedPPUpdates era
ProposedPPUpdates :: Map (KeyHash 'Genesis (Crypto era)) (PParamsDelta era) -> ProposedPPUpdates era
emptyPPPUpdates :: ProposedPPUpdates era
type PParamsUpdate era = PParams' StrictMaybe era
emptyPParamsUpdate :: PParamsUpdate era

-- | Update Proposal
data Update era
Update :: !ProposedPPUpdates era -> !EpochNo -> Update era
updatePParams :: PParams era -> PParamsUpdate era -> PParams era
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.PParams.PParams' f era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.PParams.PPUpdateEnv era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.PParams.PPUpdateEnv era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.PParams.PPUpdateEnv era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.PParams.Update era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.PParams.PParams' Data.Functor.Identity.Identity era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.PParams.PParams' Data.Functor.Identity.Identity era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.PParams.PParams' Data.Functor.Identity.Identity era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParamsDelta era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.PParams.Update era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Core.PParamsDelta era) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.PParams.Update era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era) => GHC.Show.Show (Cardano.Ledger.Shelley.PParams.Update era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.PParams.PParams' Data.Maybe.Strict.StrictMaybe era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParamsDelta era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Core.PParamsDelta era) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era) => GHC.Show.Show (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParamsDelta era) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PParams.Update era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.PParams.Update era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.PParams.Update era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParamsDelta era) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.PParams.ProposedPPUpdates era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PParams.PParamsUpdate era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.PParams.PParamsUpdate era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.PParams.PParamsUpdate era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PParams.PPUpdateEnv era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PParams.PParams era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.PParams.PParams era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.PParams.PParams era)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.PParams.PParams era)
instance Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.PParams.PParams era)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.PParams.PParams era)
instance Cardano.Ledger.Shelley.PParams.HKDFunctor Data.Functor.Identity.Identity
instance Cardano.Ledger.Shelley.PParams.HKDFunctor GHC.Maybe.Maybe
instance Cardano.Ledger.Shelley.PParams.HKDFunctor Data.Maybe.Strict.StrictMaybe

module Cardano.Ledger.Shelley.Scripts
data MultiSig crypto
pattern RequireAllOf :: Crypto crypto => [MultiSig crypto] -> MultiSig crypto
pattern RequireAnyOf :: Crypto crypto => [MultiSig crypto] -> MultiSig crypto
pattern RequireSignature :: Crypto crypto => KeyHash 'Witness crypto -> MultiSig crypto
pattern RequireMOf :: Crypto crypto => Int -> [MultiSig crypto] -> MultiSig crypto
getMultiSigBytes :: MultiSig crypto -> ShortByteString
newtype ScriptHash crypto
ScriptHash :: Hash (ADDRHASH crypto) EraIndependentScript -> ScriptHash crypto
instance Data.Typeable.Internal.Typeable crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Scripts.MultiSigRaw crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Scripts.MultiSigRaw crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.Scripts.MultiSigRaw crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Scripts.MultiSigRaw crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Scripts.MultiSigRaw crypto)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Shelley.Scripts.MultiSig crypto)
instance Data.Typeable.Internal.Typeable crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Scripts.MultiSig crypto)
instance Data.Typeable.Internal.Typeable crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Scripts.MultiSig crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Scripts.MultiSig crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Scripts.MultiSig crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.Scripts.MultiSig crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Scripts.MultiSig crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Scripts.MultiSig era)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.Scripts.MultiSig crypto))
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Scripts.MultiSigRaw era)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.Scripts.MultiSigRaw crypto))

module Cardano.Ledger.Shelley.SoftForks
validMetadata :: HasField "_protocolVersion" pp ProtVer => pp -> Bool
restrictPoolMetadataHash :: HasField "_protocolVersion" pp ProtVer => pp -> Bool

module Cardano.Ledger.Shelley.StabilityWindow

-- | Calculate the stability window (e.g. the number of slots needed for a
--   block to become stable) from the security param and the active slot
--   coefficient.
--   
--   The value 3k/f is determined to be a suitabe value as per
--   <a>https://docs.google.com/document/d/1B8BNMx8jVWRjYiUBOaI3jfZ7dQNvNTSDODvT5iOuYCU/edit#heading=h.qh2zcajmu6hm</a>
computeStabilityWindow :: Word64 -> ActiveSlotCoeff -> Word64

-- | Calculate the randomness stabilisation window from the security param
--   and the active slot coefficient.
--   
--   The value 4k/f is determined to be a suitabe value as per
--   <a>https://docs.google.com/document/d/1B8BNMx8jVWRjYiUBOaI3jfZ7dQNvNTSDODvT5iOuYCU/edit#heading=h.qh2zcajmu6hm</a>
computeRandomnessStabilisationWindow :: Word64 -> ActiveSlotCoeff -> Word64

module Cardano.Ledger.Shelley.TxBody

-- | A heavyweight certificate.
data DCert crypto
DCertDeleg :: !DelegCert crypto -> DCert crypto
DCertPool :: !PoolCert crypto -> DCert crypto
DCertGenesis :: !GenesisDelegCert crypto -> DCert crypto
DCertMir :: !MIRCert crypto -> DCert crypto
data DelegCert crypto

-- | A stake key registration certificate.
RegKey :: !StakeCredential crypto -> DelegCert crypto

-- | A stake key deregistration certificate.
DeRegKey :: !StakeCredential crypto -> DelegCert crypto

-- | A stake delegation certificate.
Delegate :: !Delegation crypto -> DelegCert crypto

-- | The delegation of one stake key to another.
data Delegation crypto
Delegation :: !StakeCredential crypto -> !KeyHash 'StakePool crypto -> Delegation crypto
[_delegator] :: Delegation crypto -> !StakeCredential crypto
[_delegatee] :: Delegation crypto -> !KeyHash 'StakePool crypto

-- | Genesis key delegation certificate
data GenesisDelegCert crypto
GenesisDelegCert :: !KeyHash 'Genesis crypto -> !KeyHash 'GenesisDelegate crypto -> !Hash crypto (VerKeyVRF crypto) -> GenesisDelegCert crypto

-- | Move instantaneous rewards certificate
data MIRCert crypto
MIRCert :: MIRPot -> MIRTarget crypto -> MIRCert crypto
[mirPot] :: MIRCert crypto -> MIRPot
[mirRewards] :: MIRCert crypto -> MIRTarget crypto
data MIRPot
ReservesMIR :: MIRPot
TreasuryMIR :: MIRPot

-- | MIRTarget specifies if funds from either the reserves or the treasury
--   are to be handed out to a collection of reward accounts or instead
--   transfered to the opposite pot.
data MIRTarget crypto
StakeAddressesMIR :: Map (Credential 'Staking crypto) DeltaCoin -> MIRTarget crypto
SendToOppositePotMIR :: Coin -> MIRTarget crypto
data PoolCert crypto

-- | A stake pool registration certificate.
RegPool :: !PoolParams crypto -> PoolCert crypto

-- | A stake pool retirement certificate.
RetirePool :: !KeyHash 'StakePool crypto -> !EpochNo -> PoolCert crypto
data PoolMetadata
PoolMetadata :: !Url -> !ByteString -> PoolMetadata
[_poolMDUrl] :: PoolMetadata -> !Url
[_poolMDHash] :: PoolMetadata -> !ByteString

-- | A stake pool.
data PoolParams crypto
PoolParams :: !KeyHash 'StakePool crypto -> !Hash crypto (VerKeyVRF crypto) -> !Coin -> !Coin -> !UnitInterval -> !RewardAcnt crypto -> !Set (KeyHash 'Staking crypto) -> !StrictSeq StakePoolRelay -> !StrictMaybe PoolMetadata -> PoolParams crypto
[_poolId] :: PoolParams crypto -> !KeyHash 'StakePool crypto
[_poolVrf] :: PoolParams crypto -> !Hash crypto (VerKeyVRF crypto)
[_poolPledge] :: PoolParams crypto -> !Coin
[_poolCost] :: PoolParams crypto -> !Coin
[_poolMargin] :: PoolParams crypto -> !UnitInterval
[_poolRAcnt] :: PoolParams crypto -> !RewardAcnt crypto
[_poolOwners] :: PoolParams crypto -> !Set (KeyHash 'Staking crypto)
[_poolRelays] :: PoolParams crypto -> !StrictSeq StakePoolRelay
[_poolMD] :: PoolParams crypto -> !StrictMaybe PoolMetadata

-- | Pointer to a slot number, transaction index and an index in
--   certificate list.
data Ptr
Ptr :: !SlotNo -> !TxIx -> !CertIx -> Ptr

-- | An account based address for rewards
data RewardAcnt crypto
RewardAcnt :: !Network -> !Credential 'Staking crypto -> RewardAcnt crypto
[getRwdNetwork] :: RewardAcnt crypto -> !Network
[getRwdCred] :: RewardAcnt crypto -> !Credential 'Staking crypto
newtype StakeCreds crypto
StakeCreds :: Map (Credential 'Staking crypto) SlotNo -> StakeCreds crypto
[unStakeCreds] :: StakeCreds crypto -> Map (Credential 'Staking crypto) SlotNo
data StakePoolRelay

-- | One or both of IPv4 &amp; IPv6
SingleHostAddr :: !StrictMaybe Port -> !StrictMaybe IPv4 -> !StrictMaybe IPv6 -> StakePoolRelay

-- | An <tt>A</tt> or <tt>AAAA</tt> DNS record
SingleHostName :: !StrictMaybe Port -> !DnsName -> StakePoolRelay

-- | A <tt>SRV</tt> DNS record
MultiHostName :: !DnsName -> StakePoolRelay
newtype TxBody era
TxBodyConstr :: MemoBytes (TxBodyRaw era) -> TxBody era

-- | Pattern for use by external users
pattern TxBody :: (Era era, FromCBOR (PParamsDelta era), TransTxBody ToCBOR era) => Set (TxIn (Crypto era)) -> StrictSeq (TxOut era) -> StrictSeq (DCert (Crypto era)) -> Wdrl (Crypto era) -> Coin -> SlotNo -> StrictMaybe (Update era) -> StrictMaybe (AuxiliaryDataHash (Crypto era)) -> TxBody era
data TxBodyRaw era
TxBodyRaw :: !Set (TxIn (Crypto era)) -> !StrictSeq (TxOut era) -> !StrictSeq (DCert (Crypto era)) -> !Wdrl (Crypto era) -> !Coin -> !SlotNo -> !StrictMaybe (Update era) -> !StrictMaybe (AuxiliaryDataHash (Crypto era)) -> TxBodyRaw era
[_inputsX] :: TxBodyRaw era -> !Set (TxIn (Crypto era))
[_outputsX] :: TxBodyRaw era -> !StrictSeq (TxOut era)
[_certsX] :: TxBodyRaw era -> !StrictSeq (DCert (Crypto era))
[_wdrlsX] :: TxBodyRaw era -> !Wdrl (Crypto era)
[_txfeeX] :: TxBodyRaw era -> !Coin
[_ttlX] :: TxBodyRaw era -> !SlotNo
[_txUpdateX] :: TxBodyRaw era -> !StrictMaybe (Update era)
[_mdHashX] :: TxBodyRaw era -> !StrictMaybe (AuxiliaryDataHash (Crypto era))
data EraIndependentTxBody

-- | The output of a UTxO.
data TxOut era
TxOutCompact :: {-# UNPACK #-} !CompactAddr (Crypto era) -> !CompactForm (Value era) -> TxOut era
pattern TxOut :: (Era era, Show (Value era), Compactible (Value era)) => Addr (Crypto era) -> Value era -> TxOut era
data Url
newtype Wdrl crypto
Wdrl :: Map (RewardAcnt crypto) Coin -> Wdrl crypto
[unWdrl] :: Wdrl crypto -> Map (RewardAcnt crypto) Coin

-- | Proof/Witness that a transaction is authorized by the given key
--   holder.
data WitVKey kr crypto
pattern WitVKey :: (Typeable kr, Crypto crypto) => VKey kr crypto -> SignedDSIGN crypto (Hash crypto EraIndependentTxBody) -> WitVKey kr crypto
witKeyHash :: WitVKey kr crypto -> KeyHash 'Witness crypto

-- | The size of the <a>_poolOwners</a> <a>Set</a>. Only used to compute
--   size of encoded <a>PoolParams</a>.
data SizeOfPoolOwners
SizeOfPoolOwners :: SizeOfPoolOwners

-- | The size of the <a>_poolRelays</a> <a>Set</a>. Only used to compute
--   size of encoded <a>PoolParams</a>.
data SizeOfPoolRelays
SizeOfPoolRelays :: SizeOfPoolRelays
type TransTxId (c :: Type -> Constraint) era = (HashAnnotated (TxBody era) EraIndependentTxBody (Crypto era), ToCBOR (TxBody era), ToCBOR (TxOut era), TransValue ToCBOR era, TransValue c era)
type TransTxOut (c :: Type -> Constraint) era = (c (Value era), Compactible (Value era))
type TransTxBody (c :: Type -> Constraint) era = (c (TxOut era), c (PParamsDelta era), HashAnnotated (TxBody era) EraIndependentTxBody (Crypto era))
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.Delegation crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.Delegation crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.Delegation crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.Delegation crypto)
instance GHC.Show.Show Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance GHC.Generics.Generic Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance GHC.Classes.Ord Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance GHC.Classes.Eq Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance GHC.Show.Show Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance GHC.Generics.Generic Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance GHC.Classes.Ord Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance GHC.Classes.Eq Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.DelegCert crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.DelegCert crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.DelegCert crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.DelegCert crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.PoolCert crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.PoolCert crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.PoolCert crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.PoolCert crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.GenesisDelegCert crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.GenesisDelegCert crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.GenesisDelegCert crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.GenesisDelegCert crypto)
instance GHC.Enum.Bounded Cardano.Ledger.Shelley.TxBody.MIRPot
instance GHC.Enum.Enum Cardano.Ledger.Shelley.TxBody.MIRPot
instance GHC.Classes.Ord Cardano.Ledger.Shelley.TxBody.MIRPot
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.TxBody.MIRPot
instance GHC.Classes.Eq Cardano.Ledger.Shelley.TxBody.MIRPot
instance GHC.Generics.Generic Cardano.Ledger.Shelley.TxBody.MIRPot
instance GHC.Show.Show Cardano.Ledger.Shelley.TxBody.MIRPot
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.MIRTarget crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.MIRTarget crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.MIRTarget crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.MIRTarget crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.MIRCert crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.MIRCert crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.MIRCert crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.MIRCert crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.DCert crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.DCert crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.DCert crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.DCert crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.TxBodyRaw era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Shelley.TxBody.TxBody era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.TxBody era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.WitVKey kr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.TxBody.StakeCreds crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.TxBody.StakeCreds crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.StakeCreds crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.StakeCreds crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.StakeCreds crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.TxBody.StakeCreds crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.StakeCreds crypto)
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance Cardano.Ledger.Shelley.TxBody.TransTxOut GHC.Classes.Eq era => GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.TxOut era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.TxOut era)
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.TxBody.MIRPot
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.MIRTarget crypto)
instance Cardano.Ledger.Shelley.TxBody.TransTxBody NoThunks.Class.NoThunks era => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.TxBodyRaw era)
instance (Control.DeepSeq.NFData (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Control.DeepSeq.NFData (Cardano.Ledger.Core.PParamsDelta era)) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.TxBody.TransTxBody GHC.Classes.Eq era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.TxBody.TransTxBody GHC.Show.Show era) => GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.TxBodyRaw era)
instance (Cardano.Ledger.Shelley.TxBody.TransTxBody NoThunks.Class.NoThunks era, Data.Typeable.Internal.Typeable era) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.TxBody era)
instance (Control.DeepSeq.NFData (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Control.DeepSeq.NFData (Cardano.Ledger.Core.PParamsDelta era)) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.TxBody era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.TxBody.TransTxBody GHC.Show.Show era) => GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.TxBody era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.TxBody.TransTxBody GHC.Classes.Eq era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.TxBody era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParamsDelta era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.TxBody.TxBody era))
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.WitVKey kr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Ledger.Shelley.TxBody.WitVKey kr crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Data.Typeable.Internal.Typeable kr) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.WitVKey kr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.TxBody.StakeCreds crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.StakeCreds crypto)
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.TxBody.SizeOfPoolRelays
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Serialization.ToCBORGroup (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.TxBody.SizeOfPoolOwners
instance Control.Iterate.Exp.HasExp (Cardano.Ledger.Shelley.TxBody.StakeCreds era) (Data.Map.Internal.Map (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking era) Cardano.Slotting.Slot.SlotNo)
instance Control.Iterate.BaseTypes.Embed (Cardano.Ledger.Shelley.TxBody.StakeCreds era) (Data.Map.Internal.Map (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking era) Cardano.Slotting.Slot.SlotNo)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.WitVKey kr crypto)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto crypto) => GHC.Classes.Ord (Cardano.Ledger.Shelley.TxBody.WitVKey kr crypto)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto crypto) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.WitVKey kr crypto)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto crypto) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.TxBody.WitVKey kr crypto))
instance (Cardano.Ledger.Era.Era era, c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Shelley.TxBody.TxBody era) Cardano.Ledger.Hashes.EraIndependentTxBody c
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.TxBody era)
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "inputs" (Cardano.Ledger.Shelley.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn crypto))
instance (Cardano.Ledger.Core.TxOut era GHC.Types.~ out) => GHC.Records.HasField "outputs" (Cardano.Ledger.Shelley.TxBody.TxBody era) (Data.Sequence.Strict.StrictSeq out)
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "certs" (Cardano.Ledger.Shelley.TxBody.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Shelley.TxBody.DCert crypto))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "wdrls" (Cardano.Ledger.Shelley.TxBody.TxBody era) (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance GHC.Records.HasField "txfee" (Cardano.Ledger.Shelley.TxBody.TxBody era) Cardano.Ledger.Coin.Coin
instance GHC.Records.HasField "ttl" (Cardano.Ledger.Shelley.TxBody.TxBody era) Cardano.Slotting.Slot.SlotNo
instance GHC.Records.HasField "update" (Cardano.Ledger.Shelley.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Shelley.PParams.Update era))
instance (Cardano.Ledger.Era.Crypto era GHC.Types.~ crypto) => GHC.Records.HasField "adHash" (Cardano.Ledger.Shelley.TxBody.TxBody era) (Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "minted" (Cardano.Ledger.Shelley.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.Hashes.ScriptHash c))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era) => GHC.Records.HasField "txinputs_fee" (Cardano.Ledger.Shelley.TxBody.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn c))
instance (Cardano.Ledger.Shelley.TxBody.TransTxBody Cardano.Binary.FromCBOR.FromCBOR era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParamsDelta era), Cardano.Ledger.Era.Era era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.TxBody.TxBodyRaw era))
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParamsDelta era), Cardano.Ledger.Shelley.TxBody.TransTxBody Cardano.Binary.ToCBOR.ToCBOR era) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.TxBodyRaw era)
instance (Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParamsDelta era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.TxBody.TxBodyRaw era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.DCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.DCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.TxBody.DCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.TxBody.MIRCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.MIRCert crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.MIRCert crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.TxBody.MIRTarget crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.MIRTarget crypto)
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.TxBody.MIRPot
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.TxBody.MIRPot
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.GenesisDelegCert crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.PoolCert crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.DelegCert crypto)
instance (Cardano.Ledger.Shelley.TxBody.TransTxOut GHC.Show.Show era, Cardano.Ledger.Era.Era era) => GHC.Show.Show (Cardano.Ledger.Shelley.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.TxBody.TransTxOut Cardano.Binary.ToCBOR.ToCBOR era) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.TxBody.TransTxOut Cardano.Ledger.Val.DecodeNonNegative era, GHC.Show.Show (Cardano.Ledger.Core.Value era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.TxBody.TxOut era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.TxBody.TransTxOut Cardano.Ledger.Val.DecodeNonNegative era, GHC.Show.Show (Cardano.Ledger.Core.Value era)) => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.TxBody.TxOut era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Cardano.Prelude.HeapWords.HeapWords (Cardano.Ledger.Compactible.CompactForm (Cardano.Ledger.Core.Value era))) => Cardano.Prelude.HeapWords.HeapWords (Cardano.Ledger.Shelley.TxBody.TxOut era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.TxOut era)
instance (Cardano.Ledger.Compactible.Compactible v, v GHC.Types.~ Cardano.Ledger.Core.Value era) => GHC.Records.HasField "value" (Cardano.Ledger.Shelley.TxBody.TxOut era) v
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.TxBody.Wdrl crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Ledger.Serialization.FromCBORGroup (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.TxBody.StakePoolRelay
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.TxBody.PoolMetadata
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.TxBody.Delegation crypto)

module Cardano.Ledger.Shelley.Tx
data Tx era
pattern Tx :: (Era era, ToCBOR (AuxiliaryData era), ToCBOR (TxBody era), ToCBOR (Witnesses era)) => TxBody era -> Witnesses era -> StrictMaybe (AuxiliaryData era) -> Tx era
newtype TxBody era
TxBodyConstr :: MemoBytes (TxBodyRaw era) -> TxBody era

-- | Pattern for use by external users
pattern TxBody :: (Era era, FromCBOR (PParamsDelta era), TransTxBody ToCBOR era) => Set (TxIn (Crypto era)) -> StrictSeq (TxOut era) -> StrictSeq (DCert (Crypto era)) -> Wdrl (Crypto era) -> Coin -> SlotNo -> StrictMaybe (Update era) -> StrictMaybe (AuxiliaryDataHash (Crypto era)) -> TxBody era

-- | The output of a UTxO.
data TxOut era
TxOutCompact :: {-# UNPACK #-} !CompactAddr (Crypto era) -> !CompactForm (Value era) -> TxOut era
pattern TxOut :: (Era era, Show (Value era), Compactible (Value era)) => Addr (Crypto era) -> Value era -> TxOut era

-- | The input of a UTxO.
data TxIn crypto
TxIn :: !TxId crypto -> {-# UNPACK #-} !TxIx -> TxIn crypto

-- | A unique ID of a transaction, which is computable from the
--   transaction.
newtype TxId crypto
TxId :: SafeHash crypto EraIndependentTxBody -> TxId crypto
[_unTxId] :: TxId crypto -> SafeHash crypto EraIndependentTxBody
decodeWits :: forall era s. (FromCBOR (Annotator (Script era)), ValidateScript era) => Decoder s (Annotator (WitnessSet era))
segwitTx :: (ToCBOR (TxBody era), ToCBOR (Witnesses era), ToCBOR (AuxiliaryData era)) => Annotator (TxBody era) -> Annotator (Witnesses era) -> Maybe (Annotator (AuxiliaryData era)) -> Annotator (Tx era)
type WitnessSet = WitnessSetHKD Identity
data WitnessSetHKD f era
pattern WitnessSet :: (Era era, AnnotatedData (Script era)) => Set (WitVKey 'Witness (Crypto era)) -> Map (ScriptHash (Crypto era)) (Script era) -> Set (BootstrapWitness (Crypto era)) -> WitnessSet era

-- | Proof/Witness that a transaction is authorized by the given key
--   holder.
data WitVKey kr crypto
pattern WitVKey :: (Typeable kr, Crypto crypto) => VKey kr crypto -> SignedDSIGN crypto (Hash crypto EraIndependentTxBody) -> WitVKey kr crypto

-- | Typeclass for script data types. Allows for script validation and
--   hashing. You must understand the role of SafeToHash and
--   scriptPrefixTag to make new instances. <a>scriptPrefixTag</a> is a
--   magic number representing the tag of the script language. For each new
--   script language defined, a new tag is chosen and the tag is included
--   in the script hash for a script. The safeToHash constraint ensures
--   that Scripts are never reserialised.
class (Era era, SafeToHash Script era, HasField "body" Tx era TxBody era) => ValidateScript era
scriptPrefixTag :: ValidateScript era => Script era -> ByteString
validateScript :: ValidateScript era => Script era -> Tx era -> Bool
hashScript :: ValidateScript era => Script era -> ScriptHash (Crypto era)
isNativeScript :: ValidateScript era => Script era -> Bool

-- | Multi-signature script witness accessor function for Transactions
txwitsScript :: Witnesses era ~ WitnessSet era => Tx era -> Map (ScriptHash (Crypto era)) (Script era)
extractKeyHashWitnessSet :: forall (r :: KeyRole) crypto. [Credential r crypto] -> Set (KeyHash 'Witness crypto)
addrWits' :: WitnessSetHKD f era -> HKD f (Set (WitVKey 'Witness (Crypto era)))

-- | Script evaluator for native multi-signature scheme. <tt>vhks</tt> is
--   the set of key hashes that signed the transaction to be validated.
evalNativeMultiSigScript :: Crypto crypto => MultiSig crypto -> Set (KeyHash 'Witness crypto) -> Bool

-- | Hashes native multi-signature script.
hashMultiSigScript :: forall era. (ValidateScript era, Script era ~ MultiSig (Crypto era)) => MultiSig (Crypto era) -> ScriptHash (Crypto era)

-- | Script validator for native multi-signature scheme.
validateNativeMultiSigScript :: (TransTx ToCBOR era, Witnesses era ~ WitnessSet era) => MultiSig (Crypto era) -> Tx era -> Bool
type TransTx (c :: Type -> Constraint) era = (Era era, c (Script era), c (TxBody era), c (AuxiliaryData era))
type TransWitnessSet (c :: Type -> Constraint) era = c (Script era)

-- | Exports the relevant parts from a (WintessSetHKD Identity era) for use
--   by the pretty printer without all the horrible constraints. Uses the
--   non-exported WitnessSet' constructor.
prettyWitnessSetParts :: WitnessSetHKD Identity era -> (Set (WitVKey 'Witness (Crypto era)), Map (ScriptHash (Crypto era)) (Script era), Set (BootstrapWitness (Crypto era)))
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Tx.TxRaw era)
instance Data.Typeable.Internal.Typeable era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Tx.Tx era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Shelley.Tx.Tx era)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Ledger.Shelley.Tx.IgnoreSigOrd kr crypto)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Core.AuxiliaryData era), GHC.Classes.Eq (Cardano.Ledger.Core.TxBody era), GHC.Classes.Eq (Cardano.Ledger.Core.Witnesses era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Tx.TxRaw era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.AuxiliaryData era), GHC.Show.Show (Cardano.Ledger.Core.TxBody era), GHC.Show.Show (Cardano.Ledger.Core.Witnesses era)) => GHC.Show.Show (Cardano.Ledger.Shelley.Tx.TxRaw era)
instance (Control.DeepSeq.NFData (Cardano.Ledger.Core.TxBody era), Control.DeepSeq.NFData (Cardano.Ledger.Core.Witnesses era), Control.DeepSeq.NFData (Cardano.Ledger.Core.AuxiliaryData era)) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Tx.Tx era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Tx.Tx era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Core.AuxiliaryData era), GHC.Show.Show (Cardano.Ledger.Core.TxBody era), GHC.Show.Show (Cardano.Ledger.Core.Witnesses era)) => GHC.Show.Show (Cardano.Ledger.Shelley.Tx.Tx era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.AuxiliaryData era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxBody era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.Witnesses era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Tx.Tx era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.TxBody era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.AuxiliaryData era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Witnesses era))) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.Tx.Tx era))
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.Tx.TransWitnessSet GHC.Show.Show era) => GHC.Show.Show (Cardano.Ledger.Shelley.Tx.WitnessSetHKD Data.Functor.Identity.Identity era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.Tx.TransWitnessSet GHC.Classes.Eq era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Tx.WitnessSetHKD Data.Functor.Identity.Identity era)
instance Cardano.Ledger.Era.Era era => GHC.Generics.Generic (Cardano.Ledger.Shelley.Tx.WitnessSetHKD Data.Functor.Identity.Identity era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Shelley.Tx.TransWitnessSet NoThunks.Class.NoThunks era) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Tx.WitnessSetHKD Data.Functor.Identity.Identity era)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto crypto) => GHC.Classes.Ord (Cardano.Ledger.Shelley.Tx.IgnoreSigOrd kr crypto)
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era, Cardano.Ledger.Core.Witnesses era GHC.Types.~ Cardano.Ledger.Shelley.Tx.WitnessSet era) => GHC.Records.HasField "addrWits" (Cardano.Ledger.Shelley.Tx.Tx era) (Data.Set.Internal.Set (Cardano.Ledger.Shelley.TxBody.WitVKey 'Cardano.Ledger.Keys.Witness c))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era, Cardano.Ledger.Core.Witnesses era GHC.Types.~ Cardano.Ledger.Shelley.Tx.WitnessSet era) => GHC.Records.HasField "addrWits" (Cardano.Ledger.Shelley.Tx.WitnessSet era) (Data.Set.Internal.Set (Cardano.Ledger.Shelley.TxBody.WitVKey 'Cardano.Ledger.Keys.Witness c))
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era, script GHC.Types.~ Cardano.Ledger.Core.Script era, Cardano.Ledger.Core.Witnesses era GHC.Types.~ Cardano.Ledger.Shelley.Tx.WitnessSet era) => GHC.Records.HasField "scriptWits" (Cardano.Ledger.Shelley.Tx.Tx era) (Data.Map.Internal.Map (Cardano.Ledger.Hashes.ScriptHash c) script)
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era, script GHC.Types.~ Cardano.Ledger.Core.Script era, Cardano.Ledger.Core.Witnesses era GHC.Types.~ Cardano.Ledger.Shelley.Tx.WitnessSet era) => GHC.Records.HasField "scriptWits" (Cardano.Ledger.Shelley.Tx.WitnessSet era) (Data.Map.Internal.Map (Cardano.Ledger.Hashes.ScriptHash c) script)
instance (c GHC.Types.~ Cardano.Ledger.Era.Crypto era, Cardano.Ledger.Core.Witnesses era GHC.Types.~ Cardano.Ledger.Shelley.Tx.WitnessSet era) => GHC.Records.HasField "bootWits" (Cardano.Ledger.Shelley.Tx.Tx era) (Data.Set.Internal.Set (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness c))
instance (Cardano.Ledger.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.Script era), Control.DeepSeq.NFData (Cardano.Ledger.Shelley.TxBody.WitVKey 'Cardano.Ledger.Keys.Witness (Cardano.Ledger.Era.Crypto era)), Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Address.Bootstrap.BootstrapWitness (Cardano.Ledger.Era.Crypto era))) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Tx.WitnessSetHKD Data.Functor.Identity.Identity era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Tx.WitnessSetHKD Data.Functor.Identity.Identity era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.AnnotatedData (Cardano.Ledger.Core.Script era)) => GHC.Base.Semigroup (Cardano.Ledger.Shelley.Tx.WitnessSetHKD Data.Functor.Identity.Identity era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.AnnotatedData (Cardano.Ledger.Core.Script era)) => GHC.Base.Monoid (Cardano.Ledger.Shelley.Tx.WitnessSetHKD Data.Functor.Identity.Identity era)
instance Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.Shelley.Tx.WitnessSetHKD Data.Functor.Identity.Identity era)
instance (Data.Typeable.Internal.Typeable era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Script era)), Cardano.Ledger.Era.ValidateScript era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.Tx.WitnessSetHKD Data.Functor.Identity.Identity era))
instance (aux GHC.Types.~ Cardano.Ledger.Core.AuxiliaryData era) => GHC.Records.HasField "auxiliaryData" (Cardano.Ledger.Shelley.Tx.Tx era) (Data.Maybe.Strict.StrictMaybe aux)
instance (body GHC.Types.~ Cardano.Ledger.Core.TxBody era) => GHC.Records.HasField "body" (Cardano.Ledger.Shelley.Tx.Tx era) body
instance (wits GHC.Types.~ Cardano.Ledger.Core.Witnesses era) => GHC.Records.HasField "wits" (Cardano.Ledger.Shelley.Tx.Tx era) wits
instance GHC.Records.HasField "txsize" (Cardano.Ledger.Shelley.Tx.Tx era) GHC.Integer.Type.Integer
instance (Control.DeepSeq.NFData (Cardano.Ledger.Core.TxBody era), Control.DeepSeq.NFData (Cardano.Ledger.Core.Witnesses era), Control.DeepSeq.NFData (Cardano.Ledger.Core.AuxiliaryData era)) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Tx.TxRaw era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.AuxiliaryData era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxBody era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.Witnesses era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Tx.TxRaw era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.TxBody era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.AuxiliaryData era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Core.Witnesses era))) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.Tx.TxRaw era))

module Cardano.Ledger.Shelley.BlockChain
data TxSeq era
TxSeq' :: !StrictSeq (Tx era) -> ByteString -> ByteString -> ByteString -> TxSeq era

-- | Constuct a TxSeq (with all it bytes) from just Core.Tx's
pattern TxSeq :: forall era. (Era era, SafeToHash (Witnesses era)) => StrictSeq (Tx era) -> TxSeq era

-- | Given a size and a mapping from indices to maybe metadata, return a
--   sequence whose size is the size paramater and whose non-Nothing values
--   correspond to the values in the mapping.
constructMetadata :: forall era. Int -> Map Int (Annotator (AuxiliaryData era)) -> Seq (Maybe (Annotator (AuxiliaryData era)))
txSeqTxns :: TxSeq era -> StrictSeq (Tx era)

-- | Hash a given block body
bbHash :: forall era. Era era => TxSeq era -> Hash (Crypto era) EraIndependentBlockBody
bBodySize :: ToCBORGroup txSeq => txSeq -> Int
slotToNonce :: SlotNo -> Nonce
incrBlocks :: Bool -> KeyHash 'StakePool crypto -> BlocksMade crypto -> BlocksMade crypto
coreAuxDataBytes :: forall era. SafeToHash (AuxiliaryData era) => Tx era -> StrictMaybe ByteString

-- | The parts of the Tx in Blocks that have to have FromCBOR(Annotator x)
--   instances. These are exactly the parts that are SafeToHash. | Decode a
--   TxSeq, used in decoding a Block.
txSeqDecoder :: forall era. BlockAnn era => Bool -> forall s. Decoder s (Annotator (TxSeq era))
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.BlockChain.TxSeq era)
instance (Data.Typeable.Internal.Typeable era, NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Tx.Tx era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.BlockChain.TxSeq era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Tx.Tx era) => GHC.Show.Show (Cardano.Ledger.Shelley.BlockChain.TxSeq era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Tx.Tx era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.BlockChain.TxSeq era)
instance Cardano.Ledger.Era.Era era => Cardano.Ledger.Serialization.ToCBORGroup (Cardano.Ledger.Shelley.BlockChain.TxSeq era)
instance (Cardano.Ledger.Block.BlockAnn era, Data.Typeable.Internal.Typeable era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Shelley.BlockChain.TxSeq era))


-- | Definition of the shelley era, along with instances ot the
--   <tt>Core</tt> types defined in <tt>module Cardano.Ledger.Core</tt>,
--   and instances of the <tt>API</tt> classes exposed in <tt>module
--   Cardano.Ledger.Shelley.API</tt>.
module Cardano.Ledger.Shelley
data ShelleyEra c
type Self c = ShelleyEra c
type TxOut era = TxOut era
type TxBody era = TxBody era
type Value era = Coin
type Script era = MultiSig (Crypto era)
type AuxiliaryData era = Metadata era
type PParams era = PParams' Identity era

-- | The type of updates to Protocol parameters
type family PParamsDelta era = (r :: Type) | r -> era
type Tx era = Tx era
type Witnesses era = WitnessSet (Crypto era)

-- | Magic number "memorialized" in the ValidateScript class under the
--   method: scriptPrefixTag:: Core.Script era -&gt; Bs.ByteString, for the
--   Shelley Era.
nativeMultiSigTag :: ByteString
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.Era (Cardano.Ledger.Shelley.ShelleyEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesValue (Cardano.Ledger.Shelley.ShelleyEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesTxOut (Cardano.Ledger.Shelley.ShelleyEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.Constraints.UsesPParams (Cardano.Ledger.Shelley.ShelleyEra c)
instance (Cardano.Ledger.Crypto.Crypto c, Cardano.Ledger.Shelley.Constraints.UsesTxBody (Cardano.Ledger.Shelley.ShelleyEra c)) => Cardano.Ledger.Era.ValidateScript (Cardano.Ledger.Shelley.ShelleyEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Era.SupportsSegWit (Cardano.Ledger.Shelley.ShelleyEra c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.AuxiliaryData.ValidateAuxiliaryData (Cardano.Ledger.Shelley.ShelleyEra c) c

module Cardano.Ledger.Shelley.RewardProvenance

-- | <tt>RewardProvenenace</tt> captures some of the intermediate
--   calculations when computing the staking reward distribution. Most of
--   these fields are simple scalar values, computed from the current
--   State, and are fixed before we start to compute the distribution. Two
--   of them are aggregates computed when we compute the distribution
--   (<a>pools</a> and <a>desirabilities</a>).
--   
--   For more background, see "Figure 48: The Reward Calculation" and
--   "Figure 51: Reward Update Creation" of the <a>the formal
--   specification</a>. The variable names here align with those in the
--   specification. See also Section 5 of the <a>Design Specification</a>.
data RewardProvenance crypto
RewardProvenance :: !Word64 -> !BlocksMade crypto -> !Coin -> !Coin -> !Coin -> !Coin -> !Coin -> !Integer -> !Rational -> !Integer -> !Rational -> !Coin -> !Coin -> !Coin -> !Map (KeyHash 'StakePool crypto) (RewardProvenancePool crypto) -> !Map (KeyHash 'StakePool crypto) Desirability -> RewardProvenance crypto

-- | The number of slots per epoch.
[spe] :: RewardProvenance crypto -> !Word64

-- | A map from pool ID (the key hash of the stake pool operator's
--   verification key) to the number of blocks made in the given epoch.
[blocks] :: RewardProvenance crypto -> !BlocksMade crypto

-- | The maximum Lovelace supply. On mainnet, this value is equal to 45 *
--   10^15 (45 billion ADA).
[maxLL] :: RewardProvenance crypto -> !Coin

-- | The maximum amount of Lovelace which can be removed from the reserves
--   to be given out as rewards for the given epoch.
[deltaR1] :: RewardProvenance crypto -> !Coin

-- | The difference between the total Lovelace that could have been
--   distributed as rewards this epoch (which is <a>r</a>) and what was
--   actually distributed.
[deltaR2] :: RewardProvenance crypto -> !Coin

-- | The total Lovelace available for rewards for the given epoch, equal to
--   <a>rPot</a> less <a>deltaT1</a>.
[r] :: RewardProvenance crypto -> !Coin

-- | The maximum Lovelace supply (<a>maxLL</a>) less the current value of
--   the reserves.
[totalStake] :: RewardProvenance crypto -> !Coin

-- | The total number of blocks produced during the given epoch.
[blocksCount] :: RewardProvenance crypto -> !Integer

-- | The decentralization parameter.
[d] :: RewardProvenance crypto -> !Rational

-- | The number of blocks expected to be produced during the given epoch.
[expBlocks] :: RewardProvenance crypto -> !Integer

-- | The ratio of the number of blocks actually made versus the number of
--   blocks that were expected.
[eta] :: RewardProvenance crypto -> !Rational

-- | The reward pot for the given epoch, equal to <a>deltaR1</a> plus the
--   fee pot.
[rPot] :: RewardProvenance crypto -> !Coin

-- | The amount of Lovelace taken from the treasury for the given epoch.
[deltaT1] :: RewardProvenance crypto -> !Coin

-- | The amount of Lovelace that is delegated during the given epoch.
[activeStake] :: RewardProvenance crypto -> !Coin

-- | Individual stake pool provenance.
[pools] :: RewardProvenance crypto -> !Map (KeyHash 'StakePool crypto) (RewardProvenancePool crypto)

-- | A map from pool ID to the desirability score. See the <a>stake pool
--   ranking document</a>.
[desirabilities] :: RewardProvenance crypto -> !Map (KeyHash 'StakePool crypto) Desirability

-- | Provenance for an individual stake pool's reward calculation.
data RewardProvenancePool crypto
RewardProvenancePool :: !Natural -> !Rational -> !Rational -> !Coin -> !PoolParams crypto -> !Rational -> !Coin -> !Rational -> !Coin -> !Coin -> RewardProvenancePool crypto

-- | The number of blocks the pool produced.
[poolBlocksP] :: RewardProvenancePool crypto -> !Natural

-- | The stake pool's stake share (portion of the total stake).
[sigmaP] :: RewardProvenancePool crypto -> !Rational

-- | The stake pool's active stake share (portion of the active stake).
[sigmaAP] :: RewardProvenancePool crypto -> !Rational

-- | The number of Lovelace owned by the stake pool owners. If this value
--   is not at least as large as the <a>pledgeRatioP</a>, the stake pool
--   will not earn any rewards for the given epoch.
[ownerStakeP] :: RewardProvenancePool crypto -> !Coin

-- | The stake pool's registered parameters.
[poolParamsP] :: RewardProvenancePool crypto -> !PoolParams crypto

-- | The stake pool's pledge.
[pledgeRatioP] :: RewardProvenancePool crypto -> !Rational

-- | The maximum number of Lovelace this stake pool can earn.
[maxPP] :: RewardProvenancePool crypto -> !Coin

-- | The stake pool's apparent performance. See Section 5.5.2 of the
--   <a>Design Specification</a>.
[appPerfP] :: RewardProvenancePool crypto -> !Rational

-- | The total Lovelace earned by the stake pool.
[poolRP] :: RewardProvenancePool crypto -> !Coin

-- | The total Lovelace earned by the stake pool leader.
[lRewardP] :: RewardProvenancePool crypto -> !Coin

-- | The desirability score of a stake pool, as described in <a>"Reward
--   Sharing Schemes for Stake Pools"</a>. Additionally, the hit rate
--   estimation described in the <a>stake pool ranking document</a> is
--   included.
data Desirability
Desirability :: !Double -> !Double -> Desirability
[desirabilityScore] :: Desirability -> !Double
[hitRateEstimate] :: Desirability -> !Double
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance GHC.Generics.Generic Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance GHC.Show.Show Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance GHC.Classes.Eq Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenance crypto)
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.RewardProvenance.Desirability
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Default.Class.Default (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.RewardProvenance.RewardProvenancePool crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Default.Class.Default (Cardano.Ledger.Shelley.TxBody.PoolParams crypto)
instance Cardano.Ledger.Crypto.Crypto e => Data.Default.Class.Default (Cardano.Ledger.Credential.Credential r e)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Default.Class.Default (Cardano.Ledger.Address.RewardAcnt crypto)
instance Cardano.Ledger.Crypto.Crypto c => Data.Default.Class.Default (Cardano.Ledger.SafeHash.SafeHash c i)


-- | This modules implements the necessary functions for the changes that
--   can happen at epoch boundaries.
module Cardano.Ledger.Shelley.EpochBoundary

-- | Type of stake as map from hash key to coins associated.
newtype Stake crypto
Stake :: VMap VB VP (Credential 'Staking crypto) (CompactForm Coin) -> Stake crypto
[$sel:unStake:Stake] :: Stake crypto -> VMap VB VP (Credential 'Staking crypto) (CompactForm Coin)
sumAllStake :: Stake crypto -> Coin
sumStakePerPool :: VMap VB VB (Credential 'Staking crypto) (KeyHash 'StakePool crypto) -> Stake crypto -> Map (KeyHash 'StakePool crypto) Coin

-- | Snapshot of the stake distribution.
data SnapShot crypto
SnapShot :: !Stake crypto -> !VMap VB VB (Credential 'Staking crypto) (KeyHash 'StakePool crypto) -> !VMap VB VB (KeyHash 'StakePool crypto) (PoolParams crypto) -> SnapShot crypto
[$sel:_stake:SnapShot] :: SnapShot crypto -> !Stake crypto
[$sel:_delegations:SnapShot] :: SnapShot crypto -> !VMap VB VB (Credential 'Staking crypto) (KeyHash 'StakePool crypto)
[$sel:_poolParams:SnapShot] :: SnapShot crypto -> !VMap VB VB (KeyHash 'StakePool crypto) (PoolParams crypto)

-- | Snapshots of the stake distribution.
data SnapShots crypto
SnapShots :: SnapShot crypto -> !SnapShot crypto -> !SnapShot crypto -> !Coin -> SnapShots crypto
[$sel:_pstakeMark:SnapShots] :: SnapShots crypto -> SnapShot crypto
[$sel:_pstakeSet:SnapShots] :: SnapShots crypto -> !SnapShot crypto
[$sel:_pstakeGo:SnapShots] :: SnapShots crypto -> !SnapShot crypto
[$sel:_feeSS:SnapShots] :: SnapShots crypto -> !Coin
emptySnapShot :: SnapShot crypto
emptySnapShots :: SnapShots crypto

-- | Get stake of one pool
poolStake :: KeyHash 'StakePool crypto -> VMap VB VB (Credential 'Staking crypto) (KeyHash 'StakePool crypto) -> Stake crypto -> Stake crypto

-- | Calculate total possible refunds.
obligation :: forall crypto pp anymap. (HasField "_keyDeposit" pp Coin, HasField "_poolDeposit" pp Coin, Foldable (anymap (Credential 'Staking crypto))) => pp -> anymap (Credential 'Staking crypto) Coin -> Map (KeyHash 'StakePool crypto) (PoolParams crypto) -> Coin

-- | Version of maxPool' that extracts a0 and nOpt from a PParam with the
--   right HasField instances
maxPool :: (HasField "_a0" pp NonNegativeInterval, HasField "_nOpt" pp Natural) => pp -> Coin -> Rational -> Rational -> Coin

-- | Calculate maximal pool reward
maxPool' :: NonNegativeInterval -> Natural -> Coin -> Rational -> Rational -> Coin
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.EpochBoundary.Stake crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.EpochBoundary.Stake crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.EpochBoundary.Stake crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.EpochBoundary.Stake crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.EpochBoundary.SnapShot crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.EpochBoundary.SnapShot crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.EpochBoundary.SnapShot crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.EpochBoundary.SnapShots crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.EpochBoundary.SnapShots crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.EpochBoundary.SnapShots crypto)
instance Data.Typeable.Internal.Typeable crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.EpochBoundary.Stake crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.EpochBoundary.Stake crypto)
instance Data.Typeable.Internal.Typeable crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.EpochBoundary.SnapShots crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.EpochBoundary.SnapShots crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.EpochBoundary.SnapShots crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.EpochBoundary.SnapShots crypto)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.EpochBoundary.SnapShots crypto)
instance Data.Typeable.Internal.Typeable crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.EpochBoundary.SnapShot crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.EpochBoundary.SnapShot crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.EpochBoundary.SnapShot crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.EpochBoundary.SnapShot crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.EpochBoundary.Stake crypto)

module Cardano.Ledger.Shelley.Delegation.PoolParams
poolSpec :: PoolParams crypto -> (Coin, UnitInterval, Coin)

module Cardano.Ledger.Shelley.Rewards

-- | StakeShare type
newtype StakeShare
StakeShare :: Rational -> StakeShare
[unStakeShare] :: StakeShare -> Rational

-- | Stake Pool specific information needed to compute the rewards for its
--   members.
data PoolRewardInfo crypto
PoolRewardInfo :: !StakeShare -> !Coin -> !PoolParams crypto -> !Natural -> !LeaderOnlyReward crypto -> PoolRewardInfo crypto

-- | The stake pool's stake divided by the total stake
[poolRelativeStake] :: PoolRewardInfo crypto -> !StakeShare

-- | The maximum rewards available for the entire pool
[poolPot] :: PoolRewardInfo crypto -> !Coin

-- | The stake pool parameters
[poolPs] :: PoolRewardInfo crypto -> !PoolParams crypto

-- | The number of blocks the stake pool produced
[poolBlocks] :: PoolRewardInfo crypto -> !Natural

-- | The leader reward
[poolLeaderReward] :: PoolRewardInfo crypto -> !LeaderOnlyReward crypto

-- | Calculate pool reward
mkApparentPerformance :: UnitInterval -> Rational -> Natural -> Natural -> Rational
data RewardType
MemberReward :: RewardType
LeaderReward :: RewardType
data LeaderOnlyReward crypto
LeaderOnlyReward :: !KeyHash 'StakePool crypto -> !Coin -> LeaderOnlyReward crypto
[lRewardPool] :: LeaderOnlyReward crypto -> !KeyHash 'StakePool crypto
[lRewardAmount] :: LeaderOnlyReward crypto -> !Coin
leaderRewardToGeneral :: LeaderOnlyReward c -> Reward c
data Reward crypto
Reward :: RewardType -> KeyHash 'StakePool crypto -> Coin -> Reward crypto
[rewardType] :: Reward crypto -> RewardType
[rewardPool] :: Reward crypto -> KeyHash 'StakePool crypto
[rewardAmount] :: Reward crypto -> Coin

-- | Calculate pool leader reward
leaderRew :: Coin -> PoolParams crypto -> StakeShare -> StakeShare -> Coin

-- | Calculate pool member reward
memberRew :: Coin -> PoolParams crypto -> StakeShare -> StakeShare -> Coin
aggregateRewards :: forall crypto pp. HasField "_protocolVersion" pp ProtVer => pp -> Map (Credential 'Staking crypto) (Set (Reward crypto)) -> Map (Credential 'Staking crypto) Coin

-- | Filter the reward payments to those that will actually be delivered.
--   This function exists since in Shelley, a stake credential earning
--   rewards from multiple sources would only receive one reward.
filterRewards :: forall crypto pp. HasField "_protocolVersion" pp ProtVer => pp -> Map (Credential 'Staking crypto) (Set (Reward crypto)) -> (Map (Credential 'Staking crypto) (Set (Reward crypto)), Map (Credential 'Staking crypto) (Set (Reward crypto)))
sumRewards :: forall crypto pp. HasField "_protocolVersion" pp ProtVer => pp -> Map (Credential 'Staking crypto) (Set (Reward crypto)) -> Coin

-- | The stake pool member reward calculation
rewardOnePoolMember :: HasField "_protocolVersion" pp ProtVer => pp -> Coin -> Set (Credential 'Staking c) -> PoolRewardInfo c -> Credential 'Staking c -> Coin -> Maybe Coin

-- | Calculate single stake pool specific values for the reward
--   computation.
--   
--   Note that if a stake pool has made no blocks in the given epoch, it
--   will get no rewards, and so we do not need to return
--   <a>PoolRewardInfo</a>. We do, however, need to return the relative
--   stake of the pool in order to compute data for the stake pool ranking.
--   Eventually we will remove the ranking information out of the ledger
--   code and into a separate service, and at that point we can simplify
--   this function to not care about ranking.
mkPoolRewardInfo :: (HasField "_d" (PParams era) UnitInterval, HasField "_a0" (PParams era) NonNegativeInterval, HasField "_nOpt" (PParams era) Natural) => PParams era -> Coin -> BlocksMade (Crypto era) -> Natural -> Stake (Crypto era) -> VMap VB VB (Credential 'Staking (Crypto era)) (KeyHash 'StakePool (Crypto era)) -> Map (KeyHash 'StakePool (Crypto era)) Coin -> Coin -> Coin -> PoolParams (Crypto era) -> Either StakeShare (PoolRewardInfo (Crypto era))
instance GHC.Show.Show Cardano.Ledger.Shelley.Rewards.StakeShare
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.Rewards.StakeShare
instance GHC.Classes.Eq Cardano.Ledger.Shelley.Rewards.StakeShare
instance GHC.Classes.Ord Cardano.Ledger.Shelley.Rewards.StakeShare
instance GHC.Generics.Generic Cardano.Ledger.Shelley.Rewards.StakeShare
instance GHC.Generics.Generic Cardano.Ledger.Shelley.Rewards.RewardType
instance GHC.Classes.Ord Cardano.Ledger.Shelley.Rewards.RewardType
instance GHC.Show.Show Cardano.Ledger.Shelley.Rewards.RewardType
instance GHC.Classes.Eq Cardano.Ledger.Shelley.Rewards.RewardType
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rewards.PoolRewardInfo crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rewards.LeaderOnlyReward crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rewards.Reward crypto)
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.Rewards.RewardType
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.Rewards.RewardType
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.Rewards.RewardType
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.Rewards.RewardType
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.Rewards.StakeShare

module Cardano.Ledger.Shelley.PoolRank

-- | Desirability calculation for non-myopic utility, corresponding to f^~
--   in section 5.6.1 of "Design Specification for Delegation and
--   Incentives in Cardano"
desirability :: (NonNegativeInterval, Natural) -> Coin -> PoolParams c -> PerformanceEstimate -> Coin -> Double

-- | This is a estimate of the proportion of allowed blocks a pool will
--   make in the future. It is used for ranking pools in delegation.
newtype PerformanceEstimate
PerformanceEstimate :: Double -> PerformanceEstimate
[unPerformanceEstimate] :: PerformanceEstimate -> Double
data NonMyopic crypto
NonMyopic :: !Map (KeyHash 'StakePool crypto) Likelihood -> !Coin -> NonMyopic crypto
[likelihoodsNM] :: NonMyopic crypto -> !Map (KeyHash 'StakePool crypto) Likelihood
[rewardPotNM] :: NonMyopic crypto -> !Coin

-- | Computes the top ranked stake pools corresponding to section 5.6.1 of
--   "Design Specification for Delegation and Incentives in Cardano"
getTopRankedPools :: (HasField "_a0" pp NonNegativeInterval, HasField "_nOpt" pp Natural) => Coin -> Coin -> pp -> Map (KeyHash 'StakePool crypto) (PoolParams crypto) -> Map (KeyHash 'StakePool crypto) PerformanceEstimate -> Set (KeyHash 'StakePool crypto)
getTopRankedPoolsVMap :: (HasField "_a0" pp NonNegativeInterval, HasField "_nOpt" pp Natural) => Coin -> Coin -> pp -> VMap VB VB (KeyHash 'StakePool crypto) (PoolParams crypto) -> Map (KeyHash 'StakePool crypto) PerformanceEstimate -> Set (KeyHash 'StakePool crypto)

-- | Compute the Non-Myopic Pool Stake
--   
--   This function implements non-myopic stake calculation in section 5.6.2
--   of "Design Specification for Delegation and Incentives in Cardano".
--   Note that the protocol parameters are implicit in the design document.
--   Additionally, instead of passing a rank r to compare with k, we pass
--   the top k desirable pools and check for membership.
nonMyopicStake :: HasField "_nOpt" pp Natural => pp -> StakeShare -> StakeShare -> StakeShare -> KeyHash 'StakePool c -> Set (KeyHash 'StakePool c) -> StakeShare

-- | Compute the Non-Myopic Pool Member Reward
--   
--   This function implements equation (3) in section 5.6.4 of "Design
--   Specification for Delegation and Incentives in Cardano". Note that the
--   protocol parameters and the reward pot are implicit in the design
--   document. Additionally, instead of passing a rank r to compare with k,
--   we pass the top k desirable pools and check for membership.
nonMyopicMemberRew :: (HasField "_a0" pp NonNegativeInterval, HasField "_nOpt" pp Natural) => pp -> Coin -> PoolParams c -> StakeShare -> StakeShare -> StakeShare -> Set (KeyHash 'StakePool c) -> PerformanceEstimate -> Coin
percentile' :: Likelihood -> PerformanceEstimate
newtype Histogram
Histogram :: StrictSeq LogWeight -> Histogram
[unHistogram] :: Histogram -> StrictSeq LogWeight
newtype LogWeight
LogWeight :: Float -> LogWeight
[unLogWeight] :: LogWeight -> Float
likelihood :: Natural -> Double -> EpochSize -> Likelihood

-- | Decay previous likelihood
applyDecay :: Float -> Likelihood -> Likelihood
newtype Likelihood
Likelihood :: StrictSeq LogWeight -> Likelihood
[unLikelihood] :: Likelihood -> StrictSeq LogWeight
leaderProbability :: ActiveSlotCoeff -> Rational -> UnitInterval -> Double
instance GHC.Show.Show Cardano.Ledger.Shelley.PoolRank.LogWeight
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.PoolRank.LogWeight
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.PoolRank.LogWeight
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.PoolRank.LogWeight
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.PoolRank.LogWeight
instance GHC.Num.Num Cardano.Ledger.Shelley.PoolRank.LogWeight
instance GHC.Classes.Ord Cardano.Ledger.Shelley.PoolRank.LogWeight
instance GHC.Generics.Generic Cardano.Ledger.Shelley.PoolRank.LogWeight
instance GHC.Classes.Eq Cardano.Ledger.Shelley.PoolRank.LogWeight
instance GHC.Generics.Generic Cardano.Ledger.Shelley.PoolRank.Histogram
instance GHC.Show.Show Cardano.Ledger.Shelley.PoolRank.Histogram
instance GHC.Classes.Eq Cardano.Ledger.Shelley.PoolRank.Histogram
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Generics.Generic Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Classes.Ord Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Show.Show Cardano.Ledger.Shelley.PoolRank.Likelihood
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance GHC.Generics.Generic Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance GHC.Classes.Eq Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance GHC.Show.Show Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.PoolRank.NonMyopic crypto)
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.PoolRank.PerformanceEstimate
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Classes.Eq Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Base.Semigroup Cardano.Ledger.Shelley.PoolRank.Likelihood
instance GHC.Base.Monoid Cardano.Ledger.Shelley.PoolRank.Likelihood
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.PoolRank.Likelihood
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.PoolRank.Likelihood


-- | How to compute the reward update compuation. Also, how to spread the
--   compuation over many blocks, once the chain reaches a stability point.
module Cardano.Ledger.Shelley.RewardUpdate
type RewardEvent c = (Map (Credential 'Staking c) (Set (Reward c)))

-- | The result of reward calculation is a pair of aggregate Maps. One for
--   the accumulated answer, and one for the answer since the last pulse
data RewardAns c
RewardAns :: !Map (Credential 'Staking c) (Reward c) -> !RewardEvent c -> RewardAns c
[accumRewardAns] :: RewardAns c -> !Map (Credential 'Staking c) (Reward c)
[recentRewardAns] :: RewardAns c -> !RewardEvent c

-- | The provenance we collect
type KeyHashPoolProvenance c = Map (KeyHash 'StakePool c) (RewardProvenancePool c)

-- | The type of RewardPulser we pulse on.
type Pulser c = RewardPulser c ShelleyBase (RewardAns c)

-- | The ultiate goal of a reward update computation. Aggregating rewards
--   for each staking credential.
data RewardUpdate crypto
RewardUpdate :: !DeltaCoin -> !DeltaCoin -> !Map (Credential 'Staking crypto) (Set (Reward crypto)) -> !DeltaCoin -> !NonMyopic crypto -> RewardUpdate crypto
[deltaT] :: RewardUpdate crypto -> !DeltaCoin
[deltaR] :: RewardUpdate crypto -> !DeltaCoin
[rs] :: RewardUpdate crypto -> !Map (Credential 'Staking crypto) (Set (Reward crypto))
[deltaF] :: RewardUpdate crypto -> !DeltaCoin
[nonMyopic] :: RewardUpdate crypto -> !NonMyopic crypto
emptyRewardUpdate :: RewardUpdate crypto

-- | To complete the reward update, we need a snap shot of the EpochState
--   particular to this computation
data RewardSnapShot crypto
RewardSnapShot :: !Coin -> !ProtVer -> !NonMyopic crypto -> !Coin -> !Coin -> !Coin -> !Map (KeyHash 'StakePool crypto) Likelihood -> !Map (Credential 'Staking crypto) (Set (Reward crypto)) -> RewardSnapShot crypto
[rewFees] :: RewardSnapShot crypto -> !Coin
[rewprotocolVersion] :: RewardSnapShot crypto -> !ProtVer
[rewNonMyopic] :: RewardSnapShot crypto -> !NonMyopic crypto
[rewDeltaR1] :: RewardSnapShot crypto -> !Coin
[rewR] :: RewardSnapShot crypto -> !Coin
[rewDeltaT1] :: RewardSnapShot crypto -> !Coin
[rewLikelihoods] :: RewardSnapShot crypto -> !Map (KeyHash 'StakePool crypto) Likelihood
[rewLeaders] :: RewardSnapShot crypto -> !Map (Credential 'Staking crypto) (Set (Reward crypto))
data FreeVars crypto
FreeVars :: !VMap VB VB (Credential 'Staking crypto) (KeyHash 'StakePool crypto) -> !Set (Credential 'Staking crypto) -> !Integer -> !ProtVer -> !Map (KeyHash 'StakePool crypto) (PoolRewardInfo crypto) -> FreeVars crypto
[delegs] :: FreeVars crypto -> !VMap VB VB (Credential 'Staking crypto) (KeyHash 'StakePool crypto)
[addrsRew] :: FreeVars crypto -> !Set (Credential 'Staking crypto)
[totalStake] :: FreeVars crypto -> !Integer
[pp_pv] :: FreeVars crypto -> !ProtVer
[poolRewardInfo] :: FreeVars crypto -> !Map (KeyHash 'StakePool crypto) (PoolRewardInfo crypto)

-- | The function to call on each reward update pulse. Called by the
--   pulser.
rewardStakePoolMember :: FreeVars c -> RewardAns c -> Credential 'Staking c -> CompactForm Coin -> RewardAns c

-- | The type of a Pulser which uses <a>rewardStakePoolMember</a> as its
--   underlying function. <tt>rewardStakePool</tt> will be partially
--   applied to the component of type (FreeVars c) when pulsing. Note that
--   we use two type equality (~) constraints to fix both the monad
--   <tt>m</tt> and the <tt>ans</tt> type, to the context where we will use
--   the type as a Pulser. The type must have <tt>m</tt> and <tt>ans</tt>
--   as its last two parameters so we can make a Pulsable instance. RSPL =
--   Reward Serializable Listbased Pulser
data RewardPulser c (m :: Type -> Type) ans
[RSLP] :: (ans ~ RewardAns c, m ~ ShelleyBase) => !Int -> !FreeVars c -> !VMap VB VP (Credential 'Staking c) (CompactForm Coin) -> !ans -> RewardPulser c m ans
clearRecent :: RewardAns c -> RewardAns c

-- | The state used in the STS rules
data PulsingRewUpdate crypto
Pulsing :: !RewardSnapShot crypto -> !Pulser crypto -> PulsingRewUpdate crypto
Complete :: !RewardUpdate crypto -> PulsingRewUpdate crypto
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot crypto)
instance Data.Typeable.Internal.Typeable crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.FreeVars crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardUpdate.FreeVars crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.FreeVars crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.FreeVars crypto)
instance Data.Typeable.Internal.Typeable crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate crypto)
instance GHC.Classes.Eq ans => GHC.Classes.Eq (Cardano.Ledger.Shelley.RewardUpdate.RewardPulser c m ans)
instance GHC.Show.Show ans => GHC.Show.Show (Cardano.Ledger.Shelley.RewardUpdate.RewardPulser c m ans)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate crypto)
instance Data.Typeable.Internal.Typeable c => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.Pulser c)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.Pulser c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.RewardUpdate.Pulser c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.RewardUpdate.Pulser c)
instance Data.Pulse.Pulsable (Cardano.Ledger.Shelley.RewardUpdate.RewardPulser crypto)
instance GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Shelley.RewardUpdate.FreeVars crypto) Cardano.Ledger.BaseTypes.ProtVer
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.FreeVars crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.RewardUpdate.FreeVars crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.RewardUpdate.FreeVars crypto)
instance Data.Typeable.Internal.Typeable crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot crypto)
instance GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Shelley.RewardUpdate.RewardSnapShot crypto) Cardano.Ledger.BaseTypes.ProtVer
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardUpdate crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.RewardUpdate.RewardAns crypto)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.RewardUpdate.RewardAns c)

module Cardano.Ledger.Shelley.Delegation.Certificates

-- | A heavyweight certificate.
data DCert crypto
DCertDeleg :: !DelegCert crypto -> DCert crypto
DCertPool :: !PoolCert crypto -> DCert crypto
DCertGenesis :: !GenesisDelegCert crypto -> DCert crypto
DCertMir :: !MIRCert crypto -> DCert crypto
data DelegCert crypto

-- | A stake key registration certificate.
RegKey :: !StakeCredential crypto -> DelegCert crypto

-- | A stake key deregistration certificate.
DeRegKey :: !StakeCredential crypto -> DelegCert crypto

-- | A stake delegation certificate.
Delegate :: !Delegation crypto -> DelegCert crypto
data PoolCert crypto

-- | A stake pool registration certificate.
RegPool :: !PoolParams crypto -> PoolCert crypto

-- | A stake pool retirement certificate.
RetirePool :: !KeyHash 'StakePool crypto -> !EpochNo -> PoolCert crypto

-- | Genesis key delegation certificate
data GenesisDelegCert crypto
GenesisDelegCert :: !KeyHash 'Genesis crypto -> !KeyHash 'GenesisDelegate crypto -> !Hash crypto (VerKeyVRF crypto) -> GenesisDelegCert crypto

-- | Move instantaneous rewards certificate
data MIRCert crypto
MIRCert :: MIRPot -> MIRTarget crypto -> MIRCert crypto
[mirPot] :: MIRCert crypto -> MIRPot
[mirRewards] :: MIRCert crypto -> MIRTarget crypto
newtype StakeCreds crypto
StakeCreds :: Map (Credential 'Staking crypto) SlotNo -> StakeCreds crypto
[unStakeCreds] :: StakeCreds crypto -> Map (Credential 'Staking crypto) SlotNo

-- | Determine the certificate author
delegCWitness :: DelegCert crypto -> Credential 'Staking crypto
poolCWitness :: PoolCert crypto -> Credential 'StakePool crypto
genesisCWitness :: GenesisDelegCert crypto -> KeyHash 'Genesis crypto

-- | Check for <a>RegKey</a> constructor
isRegKey :: DCert crypto -> Bool

-- | Check for <a>DeRegKey</a> constructor
isDeRegKey :: DCert crypto -> Bool

-- | Check for <a>Delegation</a> constructor
isDelegation :: DCert crypto -> Bool

-- | Check for <a>GenesisDelegate</a> constructor
isGenesisDelegation :: DCert crypto -> Bool

-- | Check for <a>RegPool</a> constructor
isRegPool :: DCert crypto -> Bool

-- | Check for <a>RetirePool</a> constructor
isRetirePool :: DCert crypto -> Bool
isInstantaneousRewards :: DCert crypto -> Bool
isReservesMIRCert :: DCert crypto -> Bool
isTreasuryMIRCert :: DCert crypto -> Bool

-- | Returns True for delegation certificates that require at least one
--   witness, and False otherwise. It is mainly used to ensure that calling
--   a variant of <tt>cwitness</tt> is safe.
requiresVKeyWitness :: DCert crypto -> Bool

module Cardano.Ledger.Shelley.UTxO

-- | The unspent transaction outputs.
newtype UTxO era
UTxO :: Map (TxIn (Crypto era)) (TxOut era) -> UTxO era
[unUTxO] :: UTxO era -> Map (TxIn (Crypto era)) (TxOut era)

-- | Compute the UTxO inputs of a transaction. txins has the same problems
--   as txouts, see notes below.
txins :: HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))) => TxBody era -> Set (TxIn (Crypto era))

-- | Lookup a txin for a given UTxO collection
txinLookup :: TxIn (Crypto era) -> UTxO era -> Maybe (TxOut era)

-- | Compute the transaction outputs of a transaction.
txouts :: forall era. Era era => TxBody era -> UTxO era
txup :: forall era tx. (HasField "update" (TxBody era) (StrictMaybe (Update era)), HasField "body" tx (TxBody era)) => tx -> Maybe (Update era)

-- | Determine the total balance contained in the UTxO.
balance :: forall era. Era era => UTxO era -> Value era

-- | Sum all the value in any Foldable with elements that have a field
--   "value"
sumAllValue :: forall era tx f. (Foldable f, HasField "value" tx (Value era), Monoid (Value era)) => f tx -> Value era

-- | Determine the total deposit amount needed. The block may
--   (legitimately) contain multiple registration certificates for the same
--   pool, where the first will be treated as a registration and any
--   subsequent ones as re-registration. As such, we must only take a
--   deposit for the first such registration.
--   
--   Note that this is not an issue for key registrations since subsequent
--   registration certificates would be invalid.
totalDeposits :: (HasField "_poolDeposit" pp Coin, HasField "_keyDeposit" pp Coin) => pp -> (KeyHash 'StakePool crypto -> Bool) -> [DCert crypto] -> Coin

-- | Create a witness for transaction
makeWitnessVKey :: forall c kr. (Crypto c, DSignable c (Hash (HASH c) EraIndependentTxBody)) => SafeHash c EraIndependentTxBody -> KeyPair kr c -> WitVKey 'Witness c

-- | Create witnesses for transaction
makeWitnessesVKey :: forall c kr. (Crypto c, DSignable c (Hash (HASH c) EraIndependentTxBody)) => SafeHash c EraIndependentTxBody -> [KeyPair kr c] -> Set (WitVKey 'Witness c)

-- | From a list of key pairs and a set of key hashes required for a
--   multi-sig scripts, return the set of required keys.
makeWitnessesFromScriptKeys :: (Crypto crypto, DSignable crypto (Hash crypto EraIndependentTxBody)) => SafeHash crypto EraIndependentTxBody -> Map (KeyHash kr crypto) (KeyPair kr crypto) -> Set (KeyHash kr crypto) -> Set (WitVKey 'Witness crypto)

-- | Verify a transaction body witness
verifyWitVKey :: (Typeable kr, Crypto crypto, DSignable crypto (Hash crypto EraIndependentTxBody)) => Hash crypto EraIndependentTxBody -> WitVKey kr crypto -> Bool

-- | Extract script hash from value address with script.
getScriptHash :: Addr crypto -> Maybe (ScriptHash crypto)

-- | Computes the set of script hashes required to unlock the transcation
--   inputs and the withdrawals.
scriptsNeeded :: forall era tx. (Era era, HasField "body" tx (TxBody era), HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era)))) => UTxO era -> tx -> Set (ScriptHash (Crypto era))
scriptCred :: Credential kr crypto -> Maybe (ScriptHash crypto)
scriptStakeCred :: DCert crypto -> Maybe (ScriptHash crypto)
type TransUTxO (c :: Type -> Constraint) era = (c (TxOut era), TransTxId c era)
instance GHC.Base.Semigroup (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance Cardano.Ledger.Shelley.UTxO.TransUTxO NoThunks.Class.NoThunks era => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance (Cardano.Ledger.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.TxOut era)) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance (GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era) => GHC.Base.Monoid (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance (GHC.Show.Show (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era)) => GHC.Show.Show (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Data.Sharing.FromSharedCBOR (Cardano.Ledger.Core.TxOut era), Data.Sharing.Share (Cardano.Ledger.Core.TxOut era) GHC.Types.~ Data.Sharing.Interns (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking (Cardano.Ledger.Era.Crypto era))) => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.UTxO.UTxO era)
instance (Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Ledger.Era.Era era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.UTxO.UTxO era)


-- | This module implements the operation rules for treating UTxO
--   transactions (<tt>Tx</tt>) as state transformations on a ledger state
--   (<a>LedgerState</a>), as specified in <i>A Simplified Formal
--   Specification of a UTxO Ledger</i>.
module Cardano.Ledger.Shelley.LedgerState
data AccountState
AccountState :: !Coin -> !Coin -> AccountState
[_treasury] :: AccountState -> !Coin
[_reserves] :: AccountState -> !Coin

-- | The state associated with the current stake delegation.
data DPState crypto
DPState :: !DState crypto -> !PState crypto -> DPState crypto
[dpsDState] :: DPState crypto -> !DState crypto
[dpsPState] :: DPState crypto -> !PState crypto

-- | State of staking pool delegations and rewards
data DState crypto
DState :: !UnifiedMap crypto -> !Map (FutureGenDeleg crypto) (GenDelegPair crypto) -> !GenDelegs crypto -> !InstantaneousRewards crypto -> DState crypto

-- | Unified Reward Maps
[_unified] :: DState crypto -> !UnifiedMap crypto

-- | Future genesis key delegations
[_fGenDelegs] :: DState crypto -> !Map (FutureGenDeleg crypto) (GenDelegPair crypto)

-- | Genesis key delegations
[_genDelegs] :: DState crypto -> !GenDelegs crypto

-- | Instantaneous Rewards
[_irwd] :: DState crypto -> !InstantaneousRewards crypto
emptyDState :: DState crypto
rewards :: DState crypto -> ViewMap crypto (Credential 'Staking crypto) Coin
delegations :: DState crypto -> ViewMap crypto (Credential 'Staking crypto) (KeyHash 'StakePool crypto)

-- | get the actual ptrs map, we don't need a view
ptrsMap :: DState crypto -> Map Ptr (Credential 'Staking crypto)
data EpochState era
EpochState :: !AccountState -> !SnapShots (Crypto era) -> !LedgerState era -> !PParams era -> !PParams era -> !NonMyopic (Crypto era) -> EpochState era
[esAccountState] :: EpochState era -> !AccountState
[esSnapshots] :: EpochState era -> !SnapShots (Crypto era)
[esLState] :: EpochState era -> !LedgerState era
[esPrevPp] :: EpochState era -> !PParams era
[esPp] :: EpochState era -> !PParams era

-- | This field, esNonMyopic, does not appear in the formal spec and is not
--   a part of the protocol. It is only used for providing data to the
--   stake pool ranking calculation <tt>getNonMyopicMemberRewards</tt>. See
--   <a>https://hydra.iohk.io/job/Cardano/cardano-ledger/specs.pool-ranking/latest/download-by-type/doc-pdf/pool-ranking</a>
[esNonMyopic] :: EpochState era -> !NonMyopic (Crypto era)
data UpecState era
UpecState :: !PParams era -> !State (EraRule "PPUP" era) -> UpecState era

-- | Current protocol parameters.
[currentPp] :: UpecState era -> !PParams era

-- | State of the protocol update transition system.
[ppupState] :: UpecState era -> !State (EraRule "PPUP" era)

-- | The state used in the STS rules
data PulsingRewUpdate crypto
Pulsing :: !RewardSnapShot crypto -> !Pulser crypto -> PulsingRewUpdate crypto
Complete :: !RewardUpdate crypto -> PulsingRewUpdate crypto
data FutureGenDeleg crypto
FutureGenDeleg :: !SlotNo -> !KeyHash 'Genesis crypto -> FutureGenDeleg crypto
[fGenDelegSlot] :: FutureGenDeleg crypto -> !SlotNo
[fGenDelegGenKeyHash] :: FutureGenDeleg crypto -> !KeyHash 'Genesis crypto

-- | InstantaneousRewards captures the pending changes to the ledger state
--   caused by MIR certificates. It consists of two mappings, the rewards
--   which will be paid out from the reserves and the rewards which will be
--   paid out from the treasury. It also consists of two coin values which
--   represent the transfer of coins from one pot to the other pot. NOTE
--   that the following property should always hold: deltaReserves +
--   deltaTreasury = 0
data InstantaneousRewards crypto
InstantaneousRewards :: !Map (Credential 'Staking crypto) Coin -> !Map (Credential 'Staking crypto) Coin -> !DeltaCoin -> !DeltaCoin -> InstantaneousRewards crypto
[iRReserves] :: InstantaneousRewards crypto -> !Map (Credential 'Staking crypto) Coin
[iRTreasury] :: InstantaneousRewards crypto -> !Map (Credential 'Staking crypto) Coin
[deltaReserves] :: InstantaneousRewards crypto -> !DeltaCoin
[deltaTreasury] :: InstantaneousRewards crypto -> !DeltaCoin

-- | Representation of a list of pairs of key pairs, e.g., pay and stake
--   keys
type KeyPairs crypto = [(KeyPair 'Payment crypto, KeyPair 'Staking crypto)]

-- | The state associated with a <tt>Ledger</tt>.
data LedgerState era
LedgerState :: !UTxOState era -> !DPState (Crypto era) -> LedgerState era

-- | The current unspent transaction outputs.
[lsUTxOState] :: LedgerState era -> !UTxOState era

-- | The current delegation state
[lsDPState] :: LedgerState era -> !DPState (Crypto era)
data PPUPState era
PPUPState :: !ProposedPPUpdates era -> !ProposedPPUpdates era -> PPUPState era
[proposals] :: PPUPState era -> !ProposedPPUpdates era
[futureProposals] :: PPUPState era -> !ProposedPPUpdates era

-- | Current state of staking pools and their certificate counters.
data PState crypto
PState :: !Map (KeyHash 'StakePool crypto) (PoolParams crypto) -> !Map (KeyHash 'StakePool crypto) (PoolParams crypto) -> !Map (KeyHash 'StakePool crypto) EpochNo -> PState crypto

-- | The pool parameters.
[_pParams] :: PState crypto -> !Map (KeyHash 'StakePool crypto) (PoolParams crypto)

-- | The future pool parameters.
[_fPParams] :: PState crypto -> !Map (KeyHash 'StakePool crypto) (PoolParams crypto)

-- | A map of retiring stake pools to the epoch when they retire.
[_retiring] :: PState crypto -> !Map (KeyHash 'StakePool crypto) EpochNo
type RewardAccounts crypto = Map (Credential 'Staking crypto) Coin

-- | The ultiate goal of a reward update computation. Aggregating rewards
--   for each staking credential.
data RewardUpdate crypto
RewardUpdate :: !DeltaCoin -> !DeltaCoin -> !Map (Credential 'Staking crypto) (Set (Reward crypto)) -> !DeltaCoin -> !NonMyopic crypto -> RewardUpdate crypto
[deltaT] :: RewardUpdate crypto -> !DeltaCoin
[deltaR] :: RewardUpdate crypto -> !DeltaCoin
[rs] :: RewardUpdate crypto -> !Map (Credential 'Staking crypto) (Set (Reward crypto))
[deltaF] :: RewardUpdate crypto -> !DeltaCoin
[nonMyopic] :: RewardUpdate crypto -> !NonMyopic crypto

-- | To complete the reward update, we need a snap shot of the EpochState
--   particular to this computation
data RewardSnapShot crypto
RewardSnapShot :: !Coin -> !ProtVer -> !NonMyopic crypto -> !Coin -> !Coin -> !Coin -> !Map (KeyHash 'StakePool crypto) Likelihood -> !Map (Credential 'Staking crypto) (Set (Reward crypto)) -> RewardSnapShot crypto
[rewFees] :: RewardSnapShot crypto -> !Coin
[rewprotocolVersion] :: RewardSnapShot crypto -> !ProtVer
[rewNonMyopic] :: RewardSnapShot crypto -> !NonMyopic crypto
[rewDeltaR1] :: RewardSnapShot crypto -> !Coin
[rewR] :: RewardSnapShot crypto -> !Coin
[rewDeltaT1] :: RewardSnapShot crypto -> !Coin
[rewLikelihoods] :: RewardSnapShot crypto -> !Map (KeyHash 'StakePool crypto) Likelihood
[rewLeaders] :: RewardSnapShot crypto -> !Map (Credential 'Staking crypto) (Set (Reward crypto))

-- | There is a serious invariant that we must maintain in the UTxOState.
--   Given (UTxOState utxo _ _ _ istake) it must be the case that istake ==
--   (updateStakeDistribution (UTxO Map.empty) (UTxO Map.empty) utxo) Of
--   course computing the RHS of the above equality can be very expensive,
--   so we only use this route in the testing function smartUTxO. But we
--   are very carefull, wherever we update the UTxO, we carefully make
--   INCREMENTAL changes to istake to maintain this invariant. This happens
--   in the UTxO rule.
data UTxOState era
UTxOState :: !UTxO era -> !Coin -> !Coin -> !State (EraRule "PPUP" era) -> !IncrementalStake (Crypto era) -> UTxOState era
[_utxo] :: UTxOState era -> !UTxO era
[_deposited] :: UTxOState era -> !Coin
[_fees] :: UTxOState era -> !Coin
[_ppups] :: UTxOState era -> !State (EraRule "PPUP" era)
[_stakeDistro] :: UTxOState era -> !IncrementalStake (Crypto era)

-- | A valid (or self-consistent) UTxOState{_utxo, _deposited, _fees,
--   _ppups, _stakeDistro} maintains an invariant between the _utxo and
--   _stakeDistro fields. the _stakeDistro field is the aggregation of Coin
--   over the StakeReferences in the UTxO. It can be computed by a pure
--   function from the _utxo field. In some situations, mostly unit or
--   example tests, or when initializing a small UTxO, we want to create a
--   UTxOState that computes the _stakeDistro from the _utxo. This is aways
--   safe to do, but if the _utxo field is big, this can be very expensive,
--   which defeats the purpose of memoizing the _stakeDistro field. So use
--   of this function should be restricted to tests and initializations,
--   where the invariant should be maintained.
smartUTxOState :: Era era => UTxO era -> Coin -> Coin -> State (EraRule "PPUP" era) -> UTxOState era

-- | Incremental Stake, Stake along with possible missed coins from danging
--   Ptrs. Transactions can use Ptrs to refer to a stake credential in a
--   TxOut. The Ptr does not have to point to anything until the epoch
--   boundary, when we compute rewards and aggregate staking information
--   for ranking. This is unusual but legal. In a non incremental system,
--   we use whatever <tt>legal</tt> Ptrs exist at the epoch boundary. Here
--   we are computing things incrementally, so we need to remember Ptrs
--   that might point to something by the time the epoch boundary is
--   reached. When the epoch boundary is reached we <tt>resolve</tt> these
--   pointers, to see if any have become non-dangling since the time they
--   were first used in the incremental computation.
data IncrementalStake crypto
IStake :: !Map (Credential 'Staking crypto) Coin -> !Map Ptr Coin -> IncrementalStake crypto
[credMap] :: IncrementalStake crypto -> !Map (Credential 'Staking crypto) Coin
[ptrMap] :: IncrementalStake crypto -> !Map Ptr Coin

-- | Calculate the change to the deposit pool for a given transaction.
depositPoolChange :: HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))) => LedgerState era -> PParams era -> TxBody era -> Coin
emptyRewardUpdate :: RewardUpdate crypto
pvCanFollow :: ProtVer -> StrictMaybe ProtVer -> Bool
reapRewards :: UnifiedMap crypto -> RewardAccounts crypto -> UnifiedMap crypto

-- | This function returns the coin balance of a given pot, either the
--   reserves or the treasury, after the instantaneous rewards and pot
--   transfers are accounted for.
availableAfterMIR :: MIRPot -> AccountState -> InstantaneousRewards crypto -> Coin

-- | Creates the ledger state for an empty ledger which contains the
--   specified transaction outputs.
genesisState :: Default (State (EraRule "PPUP" era)) => Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era)) -> UTxO era -> LedgerState era
newtype WitHashes crypto
WitHashes :: Set (KeyHash 'Witness crypto) -> WitHashes crypto
[unWitHashes] :: WitHashes crypto -> Set (KeyHash 'Witness crypto)

-- | Check if a set of witness hashes is empty.
nullWitHashes :: WitHashes crypto -> Bool

-- | Extract the difference between two sets of witness hashes.
diffWitHashes :: WitHashes crypto -> WitHashes crypto -> WitHashes crypto

-- | Minimum fee calculation
minfee :: (HasField "_minfeeA" pp Natural, HasField "_minfeeB" pp Natural, HasField "txsize" tx Integer) => pp -> tx -> Coin

-- | Convenience Function to bound the txsize function. | It can be helpful
--   for coin selection.
txsizeBound :: forall era out tx. (HasField "outputs" (TxBody era) (StrictSeq out), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "body" tx (TxBody era), HasField "txsize" tx Integer) => Proxy era -> tx -> Integer

-- | Compute the lovelace which are created by the transaction
produced :: forall era pp. (Era era, HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "_keyDeposit" pp Coin, HasField "_poolDeposit" pp Coin) => pp -> (KeyHash 'StakePool (Crypto era) -> Bool) -> TxBody era -> Value era

-- | Compute the lovelace which are destroyed by the transaction
consumed :: forall era pp. (Era era, HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "_keyDeposit" pp Coin) => pp -> UTxO era -> TxBody era -> Value era

-- | Extract the witness hashes from the Transaction.
witsFromTxWitnesses :: (Era era, HasField "addrWits" tx (Set (WitVKey 'Witness (Crypto era))), HasField "bootWits" tx (Set (BootstrapWitness (Crypto era)))) => tx -> WitHashes (Crypto era)

-- | Calculate the set of hash keys of the required witnesses for update
--   proposals.
propWits :: Maybe (Update era) -> GenDelegs (Crypto era) -> Set (KeyHash 'Witness (Crypto era))

-- | Compute the key deregistration refunds in a transaction
keyRefunds :: (HasField "certs" txb (StrictSeq (DCert crypto)), HasField "_keyDeposit" pp Coin) => pp -> txb -> Coin

-- | Compute the current state distribution by using the IncrementalStake,
--   
--   This computes the stake distribution using IncrementalStake (which is
--   an aggregate of the current UTxO) and UnifiedMap (which tracks Coin,
--   Delegations, and Ptrs simultaneously). Note that logically: 1)
--   IncrementalStake = (credStake, ptrStake) 2) UnifiedMap = (rewards,
--   activeDelegs, ptrmap :: Map ptr cred)
--   
--   Using this scheme the logic can do 3 things in one go, without
--   touching the UTxO. 1) Resolve Pointers 2) Throw away things not
--   actively delegated 3) Add up the coin
--   
--   The Stake distribution function (Map cred coin) (the first component
--   of a SnapShot) is defined by this SetAlgebra expression: (dom
--   activeDelegs) ◁ (aggregate+ (credStake ∪ ptrStake ∪ rewards))
--   
--   We can apply meaning preserving operations to get equivalent
--   expressions
--   
--   (dom activeDelegs) ◁ (aggregate+ (credStake ∪ ptrStake ∪ rewards))
--   aggregate+ (dom activeDelegs ◁ (credStake ∪ ptrStake ∪ rewards))
--   aggregate+ ((dom activeDelegs ◁ credStake) ∪ (dom activeDelegs ◁
--   ptrStake) ∪ (dom activeDelegs ◁ rewards))
--   
--   We will compute this in several steps step1 = (dom activeDelegs ◁
--   credStake) ∪ (dom activeDelegs ◁ ptrStake) step2 = aggregate (dom
--   activeDelegs ◁ rewards) step1 This function has a non-incremental
--   analog, <tt>stakeDistr</tt>, mosty used in tests, which does use the
--   UTxO.
incrementalStakeDistr :: forall crypto. IncrementalStake crypto -> DState crypto -> PState crypto -> SnapShot crypto

-- | Incrementally add the inserts <tt>utxoAdd</tt> and the deletes
--   <tt>utxoDel</tt> to the IncrementalStake.
updateStakeDistribution :: Era era => IncrementalStake (Crypto era) -> UTxO era -> UTxO era -> IncrementalStake (Crypto era)

-- | Apply a reward update
applyRUpd :: HasField "_protocolVersion" (PParams era) ProtVer => RewardUpdate (Crypto era) -> EpochState era -> EpochState era
applyRUpd' :: HasField "_protocolVersion" (PParams era) ProtVer => RewardUpdate (Crypto era) -> EpochState era -> (EpochState era, Map (Credential 'Staking (Crypto era)) (Set (Reward (Crypto era))), Map (Credential 'Staking (Crypto era)) (Set (Reward (Crypto era))), Set (Credential 'Staking (Crypto era)))
filterAllRewards :: HasField "_protocolVersion" (PParams era) ProtVer => Map (Credential 'Staking (Crypto era)) (Set (Reward (Crypto era))) -> EpochState era -> (Map (Credential 'Staking (Crypto era)) (Set (Reward (Crypto era))), Map (Credential 'Staking (Crypto era)) (Set (Reward (Crypto era))), Set (Credential 'Staking (Crypto era)), Coin)

-- | To create a reward update, run all 3 phases This function is not used
--   in the rules, so it ignores RewardEvents
createRUpd :: forall era. UsesPP era => EpochSize -> BlocksMade (Crypto era) -> EpochState era -> Coin -> ActiveSlotCoeff -> Word64 -> ProvM (RewardProvenance (Crypto era)) ShelleyBase (RewardUpdate (Crypto era))

-- | Phase 3 of reward update has several parts a) completeM the pulser (in
--   case there are still computions to run) b) Combine the pulser
--   provenance with the RewardProvenance c) Construct the final
--   RewardUpdate d) Add the leader rewards to both the events and the
--   computed Rewards
completeRupd :: PulsingRewUpdate crypto -> ProvM (RewardProvenance crypto) ShelleyBase (RewardUpdate crypto, RewardEvent crypto)

-- | Assemble the components for, and then create, a Pulser.
startStep :: forall era. UsesPP era => EpochSize -> BlocksMade (Crypto era) -> EpochState era -> Coin -> ActiveSlotCoeff -> Word64 -> (PulsingRewUpdate (Crypto era), RewardProvenance (Crypto era))

-- | Run the pulser for a bit. If is has nothing left to do, complete it.
pulseStep :: PulsingRewUpdate crypto -> ShelleyBase (PulsingRewUpdate crypto, RewardEvent crypto)
completeStep :: PulsingRewUpdate crypto -> ShelleyBase (PulsingRewUpdate crypto, RewardEvent crypto)

-- | New Epoch state and environment
data NewEpochState era
NewEpochState :: !EpochNo -> !BlocksMade (Crypto era) -> !BlocksMade (Crypto era) -> !EpochState era -> !StrictMaybe (PulsingRewUpdate (Crypto era)) -> !PoolDistr (Crypto era) -> !StashedAVVMAddresses era -> NewEpochState era
type family StashedAVVMAddresses era

-- | AVVM addresses to be removed at the end of the Shelley era. Note that
--   the existence of this field is a hack, related to the transition of
--   UTxO to disk. We remove AVVM addresses from the UTxO on the
--   Shelley/Allegra boundary. However, by this point the UTxO will be
--   moved to disk, and hence doing a scan of the UTxO for AVVM addresses
--   will be expensive. Our solution to this is to do a scan of the UTxO on
--   the Byron/Shelley boundary (since Byron UTxO are still on disk), stash
--   the results here, and then remove them at the Shelley/Allegra
--   boundary.
--   
--   This is very much an awkward implementation hack, and hence we hide it
--   from as many places as possible.
stashedAVVMAddresses :: NewEpochState era -> StashedAVVMAddresses era
getGKeys :: NewEpochState era -> Set (KeyHash 'Genesis (Crypto era))

-- | Update new epoch state
updateNES :: NewEpochState era -> BlocksMade (Crypto era) -> LedgerState era -> NewEpochState era

-- | Calculate the current circulation
--   
--   This is used in the rewards calculation, and for API endpoints for
--   pool ranking.
circulation :: EpochState era -> Coin -> Coin
decayFactor :: Float
returnRedeemAddrsToReserves :: forall era. Era era => EpochState era -> EpochState era
updateNonMyopic :: NonMyopic crypto -> Coin -> Map (KeyHash 'StakePool crypto) Likelihood -> NonMyopic crypto
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.FutureGenDeleg crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.LedgerState.FutureGenDeleg crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.FutureGenDeleg crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.FutureGenDeleg crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.InstantaneousRewards crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.InstantaneousRewards crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.InstantaneousRewards crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.DState crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.DState crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.DState crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.PState crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.PState crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.PState crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.DPState crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.DPState crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.DPState crypto)
instance GHC.Generics.Generic Cardano.Ledger.Shelley.LedgerState.AccountState
instance GHC.Classes.Eq Cardano.Ledger.Shelley.LedgerState.AccountState
instance GHC.Show.Show Cardano.Ledger.Shelley.LedgerState.AccountState
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.PPUPState era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.IncrementalStake crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.IncrementalStake crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Shelley.LedgerState.IncrementalStake crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.IncrementalStake crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.IncrementalStake crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.IncrementalStake crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.UTxOState era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.LedgerState era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.EpochState era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.NewEpochState era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.WitHashes crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.LedgerState.WitHashes crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.WitHashes crypto)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Cardano.Ledger.Core.PParams era), GHC.Show.Show (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.EpochState era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Cardano.Ledger.Core.PParams era), GHC.Classes.Eq (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.EpochState era)
instance (GHC.Show.Show (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), GHC.Show.Show (Cardano.Ledger.Core.PParams era)) => GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.UpecState era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParamsDelta era) => GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.PPUPState era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParamsDelta era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.PPUPState era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Core.PParamsDelta era) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.PPUPState era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.UTxOState era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.UTxOState era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Cardano.Ledger.Core.PParams era), GHC.Show.Show (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.StashedAVVMAddresses era)) => GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.NewEpochState era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Cardano.Ledger.Core.PParams era), GHC.Classes.Eq (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.StashedAVVMAddresses era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.NewEpochState era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.LedgerState era)
instance (Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.LedgerState era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.WitHashes crypto)
instance (Cardano.Ledger.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.TxOut era), Control.DeepSeq.NFData (Cardano.Ledger.Core.PParams era), Control.DeepSeq.NFData (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.StashedAVVMAddresses era)) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.NewEpochState era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxOut era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParams era), NoThunks.Class.NoThunks (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.StashedAVVMAddresses era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxBody era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.NewEpochState era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParams era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.StashedAVVMAddresses era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.NewEpochState era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParams era), Data.Sharing.FromSharedCBOR (Cardano.Ledger.Core.TxOut era), Data.Sharing.Share (Cardano.Ledger.Core.TxOut era) GHC.Types.~ Data.Sharing.Interns (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking (Cardano.Ledger.Era.Crypto era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.LedgerState.StashedAVVMAddresses era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.LedgerState.NewEpochState era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxOut era), NoThunks.Class.NoThunks (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParams era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxBody era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.EpochState era)
instance (Cardano.Ledger.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.TxOut era), Control.DeepSeq.NFData (Cardano.Ledger.Core.PParams era), Control.DeepSeq.NFData (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.EpochState era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParams era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.EpochState era)
instance (Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParams era), Cardano.Ledger.Shelley.Constraints.TransValue Cardano.Binary.FromCBOR.FromCBOR era, Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Core.TxBody era) Cardano.Ledger.Hashes.EraIndependentTxBody (Cardano.Ledger.Era.Crypto era), Data.Sharing.FromSharedCBOR (Cardano.Ledger.Core.TxOut era), Data.Sharing.Share (Cardano.Ledger.Core.TxOut era) GHC.Types.~ Data.Sharing.Interns (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking (Cardano.Ledger.Era.Crypto era)), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), Cardano.Ledger.Era.Era era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.LedgerState.EpochState era)
instance (Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.LedgerState era), Data.Default.Class.Default (Cardano.Ledger.Core.PParams era)) => Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.EpochState era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxOut era), NoThunks.Class.NoThunks (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxBody era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.LedgerState era)
instance (Cardano.Ledger.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.TxOut era), Control.DeepSeq.NFData (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.LedgerState era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.LedgerState era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Core.TxBody era) Cardano.Ledger.Hashes.EraIndependentTxBody (Cardano.Ledger.Era.Crypto era), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.Value era), Data.Sharing.FromSharedCBOR (Cardano.Ledger.Core.TxOut era), Data.Sharing.Share (Cardano.Ledger.Core.TxOut era) GHC.Types.~ Data.Sharing.Interns (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking (Cardano.Ledger.Era.Crypto era)), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.LedgerState.LedgerState era)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.UTxOState era) => Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.LedgerState era)
instance (Cardano.Ledger.Era.Era era, Control.DeepSeq.NFData (Cardano.Ledger.Core.TxOut era), Control.DeepSeq.NFData (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.UTxOState era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxOut era), NoThunks.Class.NoThunks (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxBody era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.UTxOState era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.UTxOState era)
instance (Cardano.Ledger.Shelley.Constraints.TransValue Cardano.Binary.FromCBOR.FromCBOR era, Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), Data.Sharing.FromSharedCBOR (Cardano.Ledger.Core.TxOut era), Data.Sharing.Share (Cardano.Ledger.Core.TxOut era) GHC.Types.~ Data.Sharing.Interns (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking (Cardano.Ledger.Era.Crypto era)), Cardano.Ledger.SafeHash.HashAnnotated (Cardano.Ledger.Core.TxBody era) Cardano.Ledger.Hashes.EraIndependentTxBody (Cardano.Ledger.Era.Crypto era)) => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.LedgerState.UTxOState era)
instance (Data.Default.Class.Default (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era)) => Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.UTxOState era)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.IncrementalStake crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.LedgerState.IncrementalStake crypto)
instance GHC.Base.Semigroup (Cardano.Ledger.Shelley.LedgerState.IncrementalStake c)
instance GHC.Base.Monoid (Cardano.Ledger.Shelley.LedgerState.IncrementalStake c)
instance Data.Group.Group (Cardano.Ledger.Shelley.LedgerState.IncrementalStake c)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.IncrementalStake c)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Core.PParamsDelta era) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.PPUPState era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.PPUPState era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Core.PParamsDelta era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.LedgerState.PPUPState era)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.PPUPState era)
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.LedgerState.AccountState
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.LedgerState.AccountState
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.LedgerState.AccountState
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.LedgerState.AccountState
instance Data.Default.Class.Default Cardano.Ledger.Shelley.LedgerState.AccountState
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.DPState crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.DPState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.DPState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.LedgerState.DPState crypto)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.DPState crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.PState crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.PState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.PState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.LedgerState.PState crypto)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.PState crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.DState crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.DState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.DState crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.LedgerState.DState crypto)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.DState crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.InstantaneousRewards crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.InstantaneousRewards crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.InstantaneousRewards crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Sharing.FromSharedCBOR (Cardano.Ledger.Shelley.LedgerState.InstantaneousRewards crypto)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.InstantaneousRewards crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.LedgerState.FutureGenDeleg crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Shelley.LedgerState.FutureGenDeleg crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.LedgerState.FutureGenDeleg crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.LedgerState.FutureGenDeleg crypto)

module Cardano.Ledger.Shelley.Rules.Snap
data SNAP era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data SnapPredicateFailure era
data SnapEvent era
StakeDistEvent :: !Map (Credential 'Staking (Crypto era)) (Coin, KeyHash 'StakePool (Crypto era)) -> SnapEvent era
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Snap.SnapPredicateFailure era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Snap.SnapPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Snap.SnapPredicateFailure era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Snap.SNAP era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Snap.SnapPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Rupd
data RUPD era
data RupdEnv era
RupdEnv :: BlocksMade (Crypto era) -> EpochState era -> RupdEnv era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data RupdPredicateFailure era
epochInfoRange :: Monad m => EpochInfo m -> EpochNo -> m (SlotNo, SlotNo)

-- | The state used in the STS rules
data PulsingRewUpdate crypto
Pulsing :: !RewardSnapShot crypto -> !Pulser crypto -> PulsingRewUpdate crypto
Complete :: !RewardUpdate crypto -> PulsingRewUpdate crypto

-- | Assemble the components for, and then create, a Pulser.
startStep :: forall era. UsesPP era => EpochSize -> BlocksMade (Crypto era) -> EpochState era -> Coin -> ActiveSlotCoeff -> Word64 -> (PulsingRewUpdate (Crypto era), RewardProvenance (Crypto era))

-- | Run the pulser for a bit. If is has nothing left to do, complete it.
pulseStep :: PulsingRewUpdate crypto -> ShelleyBase (PulsingRewUpdate crypto, RewardEvent crypto)
completeStep :: PulsingRewUpdate crypto -> ShelleyBase (PulsingRewUpdate crypto, RewardEvent crypto)

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a
data RupdEvent crypto
RupdEvent :: !EpochNo -> !Map (Credential 'Staking crypto) (Set (Reward crypto)) -> RupdEvent crypto
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Rupd.RupdPredicateFailure era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Rupd.RupdPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Rupd.RupdPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, GHC.Records.HasField "_a0" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.NonNegativeInterval, GHC.Records.HasField "_d" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.UnitInterval, GHC.Records.HasField "_nOpt" (Cardano.Ledger.Core.PParams era) GHC.Natural.Natural, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.ProtVer, GHC.Records.HasField "_rho" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.UnitInterval, GHC.Records.HasField "_tau" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.UnitInterval) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Rupd.RUPD era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Rupd.RupdPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Ppup
data PPUP era
data PPUPEnv era
PPUPEnv :: SlotNo -> PParams era -> GenDelegs (Crypto era) -> PPUPEnv era
data PpupPredicateFailure era
NonGenesisUpdatePPUP :: !Set (KeyHash 'Genesis (Crypto era)) -> !Set (KeyHash 'Genesis (Crypto era)) -> PpupPredicateFailure era
PPUpdateWrongEpoch :: !EpochNo -> !EpochNo -> !VotingPeriod -> PpupPredicateFailure era
PVCannotFollowPPUP :: !ProtVer -> PpupPredicateFailure era
newtype PpupEvent era
NewEpoch :: EpochNo -> PpupEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data VotingPeriod
VoteForThisEpoch :: VotingPeriod
VoteForNextEpoch :: VotingPeriod
instance GHC.Generics.Generic Cardano.Ledger.Shelley.Rules.Ppup.VotingPeriod
instance GHC.Classes.Eq Cardano.Ledger.Shelley.Rules.Ppup.VotingPeriod
instance GHC.Show.Show Cardano.Ledger.Shelley.Rules.Ppup.VotingPeriod
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era)
instance (Data.Typeable.Internal.Typeable era, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.ProtVer, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParamsDelta era) (Data.Maybe.Strict.StrictMaybe Cardano.Ledger.BaseTypes.ProtVer)) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era)
instance (Data.Typeable.Internal.Typeable era, Cardano.Ledger.Era.Era era) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era)
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.Rules.Ppup.VotingPeriod
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.Rules.Ppup.VotingPeriod
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.Rules.Ppup.VotingPeriod

module Cardano.Ledger.Shelley.Rules.Utxo
data UTXO era
data UtxoEnv era
UtxoEnv :: SlotNo -> PParams era -> Map (KeyHash 'StakePool (Crypto era)) (PoolParams (Crypto era)) -> GenDelegs (Crypto era) -> UtxoEnv era
data UtxoPredicateFailure era
BadInputsUTxO :: !Set (TxIn (Crypto era)) -> UtxoPredicateFailure era
ExpiredUTxO :: !SlotNo -> !SlotNo -> UtxoPredicateFailure era
MaxTxSizeUTxO :: !Integer -> !Integer -> UtxoPredicateFailure era
InputSetEmptyUTxO :: UtxoPredicateFailure era
FeeTooSmallUTxO :: !Coin -> !Coin -> UtxoPredicateFailure era
ValueNotConservedUTxO :: !Value era -> !Value era -> UtxoPredicateFailure era
WrongNetwork :: !Network -> !Set (Addr (Crypto era)) -> UtxoPredicateFailure era
WrongNetworkWithdrawal :: !Network -> !Set (RewardAcnt (Crypto era)) -> UtxoPredicateFailure era
OutputTooSmallUTxO :: ![TxOut era] -> UtxoPredicateFailure era
UpdateFailure :: PredicateFailure (EraRule "PPUP" era) -> UtxoPredicateFailure era
OutputBootAddrAttrsTooBig :: ![TxOut era] -> UtxoPredicateFailure era
data UtxoEvent era
TotalDeposits :: Coin -> UtxoEvent era
UpdateEvent :: Event (EraRule "PPUP" era) -> UtxoEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
updateUTxOState :: (Era era, HasField "inputs" (TxBody era) (Set (TxIn (Crypto era)))) => UTxOState era -> TxBody era -> Coin -> State (EraRule "PPUP" era) -> UTxOState era

-- | Ensure that there is at least one input in the <a>TxBody</a>
--   
--   <pre>
--   txins txb ≠ ∅
--   </pre>
validateInputSetEmptyUTxO :: HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))) => TxBody era -> Test (UtxoPredicateFailure era)

-- | Ensure that the fee is at least the amount specified by the
--   <a>minfee</a>
--   
--   <pre>
--   minfee pp tx ≤ txfee txb
--   </pre>
validateFeeTooSmallUTxO :: (HasField "body" (Tx era) (TxBody era), HasField "txfee" (TxBody era) Coin, HasField "_minfeeA" (PParams era) Natural, HasField "_minfeeB" (PParams era) Natural, HasField "txsize" (Tx era) Integer) => PParams era -> Tx era -> Test (UtxoPredicateFailure era)

-- | Ensure all transaction inputs are present in <a>UTxO</a>
--   
--   <pre>
--   inputs ⊆ dom utxo
--   </pre>
validateBadInputsUTxO :: UTxO era -> Set (TxIn (Crypto era)) -> Test (UtxoPredicateFailure era)

-- | Make sure all addresses match the supplied NetworkId
--   
--   <pre>
--   ∀(_ → (a, _)) ∈ txouts txb, netId a = NetworkId
--   </pre>
validateWrongNetwork :: Era era => Network -> [TxOut era] -> Test (UtxoPredicateFailure era)

-- | Make sure all addresses match the supplied NetworkId
--   
--   <pre>
--   ∀(a → ) ∈ txwdrls txb, netId a = NetworkId
--   </pre>
validateWrongNetworkWithdrawal :: HasField "wdrls" (TxBody era) (Wdrl (Crypto era)) => Network -> TxBody era -> Test (UtxoPredicateFailure era)

-- | Bootstrap (i.e. Byron) addresses have variable sized attributes in
--   them. It is important to limit their overall size.
--   
--   <pre>
--   ∀ ( _ ↦ (a,_)) ∈ txoutstxb,  a ∈ Addrbootstrap → bootstrapAttrsSize a ≤ 64
--   </pre>
validateOutputBootAddrAttrsTooBig :: Era era => UTxO era -> Test (UtxoPredicateFailure era)

-- | Ensure that the size of the transaction does not exceed the
--   <tt>maxTxSize</tt> protocol parameter
--   
--   <pre>
--   txsize tx ≤ maxTxSize pp
--   </pre>
validateMaxTxSizeUTxO :: (HasField "_maxTxSize" (PParams era) Natural, HasField "txsize" (Tx era) Integer) => PParams era -> Tx era -> Test (UtxoPredicateFailure era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParams era) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era)
instance (Cardano.Ledger.Shelley.Constraints.UsesValue era, GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era)
instance (GHC.Classes.Eq (Cardano.Ledger.Core.Value era), GHC.Classes.Eq (Cardano.Ledger.Core.TxOut era), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era)
instance (NoThunks.Class.NoThunks (Cardano.Ledger.Core.Value era), NoThunks.Class.NoThunks (Cardano.Ledger.Core.TxOut era), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era)
instance (Data.Typeable.Internal.Typeable era, Cardano.Ledger.Crypto.Crypto (Cardano.Ledger.Era.Crypto era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.Value era), Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Core.TxOut era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era)
instance (Cardano.Ledger.Shelley.Constraints.TransValue Cardano.Binary.FromCBOR.FromCBOR era, Cardano.Ledger.Shelley.UTxO.TransUTxO Cardano.Binary.FromCBOR.FromCBOR era, Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Core.Value era), GHC.Show.Show (Cardano.Ledger.Core.Value era), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era))) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Core.TxOut era GHC.Types.~ Cardano.Ledger.Shelley.TxBody.TxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Cardano.Ledger.Shelley.Constraints.UsesScript era, Cardano.Ledger.Shelley.Constraints.UsesAuxiliary era, Cardano.Ledger.Shelley.Constraints.UsesPParams era, GHC.Show.Show (Cardano.Ledger.Core.Witnesses era), Cardano.Ledger.Core.TxBody era GHC.Types.~ Cardano.Ledger.Shelley.TxBody.TxBody era, Cardano.Ledger.Core.PParams era GHC.Types.~ Cardano.Ledger.Shelley.PParams.PParams era, Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Shelley.Tx.Tx era, Cardano.Ledger.Core.Value era GHC.Types.~ Cardano.Ledger.Coin.Coin, GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era)), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "PPUP" era) (Cardano.Ledger.Shelley.Rules.Utxo.UTXO era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PPUPEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.PPUPState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ GHC.Maybe.Maybe (Cardano.Ledger.Shelley.PParams.Update era)) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Utxo.UTXO era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PpupEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Ppup.PPUP era) (Cardano.Ledger.Shelley.Rules.Utxo.UTXO era)
instance (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era) => Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Shelley.Rules.Ppup.PpupPredicateFailure era) (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Utxow
data UTXOW era
data UtxowPredicateFailure era
InvalidWitnessesUTXOW :: ![VKey 'Witness (Crypto era)] -> UtxowPredicateFailure era
MissingVKeyWitnessesUTXOW :: !WitHashes (Crypto era) -> UtxowPredicateFailure era
MissingScriptWitnessesUTXOW :: !Set (ScriptHash (Crypto era)) -> UtxowPredicateFailure era
ScriptWitnessNotValidatingUTXOW :: !Set (ScriptHash (Crypto era)) -> UtxowPredicateFailure era
UtxoFailure :: PredicateFailure (EraRule "UTXO" era) -> UtxowPredicateFailure era
MIRInsufficientGenesisSigsUTXOW :: Set (KeyHash 'Witness (Crypto era)) -> UtxowPredicateFailure era
MissingTxBodyMetadataHash :: !AuxiliaryDataHash (Crypto era) -> UtxowPredicateFailure era
MissingTxMetadata :: !AuxiliaryDataHash (Crypto era) -> UtxowPredicateFailure era
ConflictingMetadataHash :: !AuxiliaryDataHash (Crypto era) -> !AuxiliaryDataHash (Crypto era) -> UtxowPredicateFailure era
InvalidMetadata :: UtxowPredicateFailure era
ExtraneousScriptWitnessesUTXOW :: !Set (ScriptHash (Crypto era)) -> UtxowPredicateFailure era
newtype UtxowEvent era
UtxoEvent :: Event (EraRule "UTXO" era) -> UtxowEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a

-- | A generic Utxow witnessing function designed to be use across many
--   Eras. Note the <tt>embed</tt> argument lifts from the simple Shelley
--   (UtxowPredicateFailure) to the PredicateFailure (type family) of the
--   context of where it is called.
transitionRulesUTXOW :: forall era utxow. (Era era, BaseM (utxow era) ~ ShelleyBase, Embed (EraRule "UTXO" era) (utxow era), Environment (EraRule "UTXO" era) ~ UtxoEnv era, State (EraRule "UTXO" era) ~ UTxOState era, Signal (EraRule "UTXO" era) ~ Tx era, Environment (utxow era) ~ UtxoEnv era, State (utxow era) ~ UTxOState era, Signal (utxow era) ~ Tx era, PredicateFailure (utxow era) ~ UtxowPredicateFailure era, STS (utxow era), ShelleyStyleWitnessNeeds era) => TransitionRule (utxow era)
type ShelleyStyleWitnessNeeds era = (HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era))), HasField "inputs" (TxBody era) (Set (TxIn (Crypto era))), HasField "wdrls" (TxBody era) (Wdrl (Crypto era)), HasField "addrWits" (Tx era) (Set (WitVKey 'Witness (Crypto era))), HasField "bootWits" (Tx era) (Set (BootstrapWitness (Crypto era))), HasField "update" (TxBody era) (StrictMaybe (Update era)), HasField "_protocolVersion" (PParams era) ProtVer, ValidateAuxiliaryData era (Crypto era), ValidateScript era, DSignable (Crypto era) (Hash (Crypto era) EraIndependentTxBody))
validateFailedScripts :: forall era. ValidateScript era => Tx era -> Test (UtxowPredicateFailure era)
validateMissingScripts :: forall era. HasField "_protocolVersion" (PParams era) ProtVer => PParams era -> Set (ScriptHash (Crypto era)) -> Set (ScriptHash (Crypto era)) -> Test (UtxowPredicateFailure era)

-- | Given a ledger state, determine if the UTxO witnesses in a given
--   transaction are correct.
validateVerifiedWits :: forall era. (Era era, HasField "addrWits" (Tx era) (Set (WitVKey 'Witness (Crypto era))), HasField "bootWits" (Tx era) (Set (BootstrapWitness (Crypto era))), DSignable (Crypto era) (Hash (Crypto era) EraIndependentTxBody)) => Tx era -> Test (UtxowPredicateFailure era)

-- | check metadata hash ((adh = ◇) ∧ (ad= ◇)) ∨ (adh = hashAD ad)
validateMetadata :: forall era. (Era era, HasField "_protocolVersion" (PParams era) ProtVer, ValidateAuxiliaryData era (Crypto era)) => PParams era -> Tx era -> Test (UtxowPredicateFailure era)

-- | check genesis keys signatures for instantaneous rewards certificates
--   
--   genSig := { hashKey gkey | gkey ∈ dom(genDelegs)} ∩ witsKeyHashes { c
--   ∈ txcerts txb ∩ DCert_mir} ≠ ∅ ⇒ |genSig| ≥ Quorum
validateMIRInsufficientGenesisSigs :: (HasField "body" (Tx era) (TxBody era), HasField "certs" (TxBody era) (StrictSeq (DCert crypto))) => GenDelegs (Crypto era) -> Word64 -> WitHashes (Crypto era) -> Tx era -> Test (UtxowPredicateFailure era)
validateNeededWitnesses :: (UTxO era -> Tx era -> GenDelegs (Crypto era) -> WitHashes (Crypto era)) -> GenDelegs (Crypto era) -> UTxO era -> Tx era -> WitHashes (Crypto era) -> Test (UtxowPredicateFailure era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era)
instance (GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), Cardano.Ledger.Era.Era era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era)
instance (GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), Cardano.Ledger.Era.Era era) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Ledger.Core.Tx era GHC.Types.~ Cardano.Ledger.Shelley.Tx.Tx era, Cardano.Ledger.Keys.DSignable (Cardano.Ledger.Era.Crypto era) (Cardano.Ledger.Keys.Hash (Cardano.Ledger.Era.Crypto era) Cardano.Ledger.Hashes.EraIndependentTxBody), GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.ProtVer, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UTXO" era) (Cardano.Ledger.Shelley.Rules.Utxow.UTXOW era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UTxOState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Core.Tx era, Cardano.Ledger.Shelley.Rules.Utxow.ShelleyStyleWitnessNeeds era) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Utxow.UTXOW era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Utxo.UTXO era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Utxo.UTXO era) (Cardano.Ledger.Shelley.Rules.Utxow.UTXOW era)
instance (NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), Cardano.Ledger.Era.Era era) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era)), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.AuxiliaryData era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era)
instance Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era) (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era)
instance (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXO" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era) => Cardano.Ledger.Rules.ValidationMode.Inject (Cardano.Ledger.Shelley.Rules.Utxo.UtxoPredicateFailure era) (Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.PoolReap
data POOLREAP era
data PoolreapEvent era
RetiredPools :: Map (Credential 'Staking (Crypto era)) (Map (KeyHash 'StakePool (Crypto era)) Coin) -> Map (Credential 'Staking (Crypto era)) (Map (KeyHash 'StakePool (Crypto era)) Coin) -> EpochNo -> PoolreapEvent era
[refundPools] :: PoolreapEvent era -> Map (Credential 'Staking (Crypto era)) (Map (KeyHash 'StakePool (Crypto era)) Coin)
[unclaimedPools] :: PoolreapEvent era -> Map (Credential 'Staking (Crypto era)) (Map (KeyHash 'StakePool (Crypto era)) Coin)
[epochNo] :: PoolreapEvent era -> EpochNo
data PoolreapState era
PoolreapState :: UTxOState era -> AccountState -> DState (Crypto era) -> PState (Crypto era) -> PoolreapState era
[prUTxOSt] :: PoolreapState era -> UTxOState era
[prAcnt] :: PoolreapState era -> AccountState
[prDState] :: PoolreapState era -> DState (Crypto era)
[prPState] :: PoolreapState era -> PState (Crypto era)

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data PoolreapPredicateFailure era
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.PoolReap.PoolreapPredicateFailure era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.PoolReap.PoolreapPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rules.PoolReap.PoolreapPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.UTxOState era) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.PoolReap.PoolreapState era)
instance (Data.Typeable.Internal.Typeable era, Data.Default.Class.Default (Cardano.Ledger.Shelley.Rules.PoolReap.PoolreapState era), GHC.Records.HasField "_poolDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin, GHC.Records.HasField "_keyDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.PoolReap.POOLREAP era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.PoolReap.PoolreapPredicateFailure era)
instance Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.UTxOState era) => Data.Default.Class.Default (Cardano.Ledger.Shelley.Rules.PoolReap.PoolreapState era)

module Cardano.Ledger.Shelley.Rules.Pool
data POOL (era :: Type)
data PoolEvent era
RegisterPool :: KeyHash 'StakePool (Crypto era) -> PoolEvent era
ReregisterPool :: KeyHash 'StakePool (Crypto era) -> PoolEvent era
data PoolEnv era
PoolEnv :: SlotNo -> PParams era -> PoolEnv era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data PoolPredicateFailure era
StakePoolNotRegisteredOnKeyPOOL :: !KeyHash 'StakePool (Crypto era) -> PoolPredicateFailure era
StakePoolRetirementWrongEpochPOOL :: !Word64 -> !Word64 -> !Word64 -> PoolPredicateFailure era
WrongCertificateTypePOOL :: !Word8 -> PoolPredicateFailure era
StakePoolCostTooLowPOOL :: !Coin -> !Coin -> PoolPredicateFailure era
WrongNetworkPOOL :: !Network -> !Network -> !KeyHash 'StakePool (Crypto era) -> PoolPredicateFailure era
PoolMedataHashTooBig :: !KeyHash 'StakePool (Crypto era) -> !Int -> PoolPredicateFailure era
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Pool.PoolPredicateFailure era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Pool.PoolPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Pool.PoolPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParams era) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Pool.PoolEnv era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParams era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Pool.PoolEnv era)
instance (Cardano.Ledger.Era.Era era, GHC.Records.HasField "_minPoolCost" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin, GHC.Records.HasField "_eMax" (Cardano.Ledger.Core.PParams era) Cardano.Slotting.Slot.EpochNo, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.ProtVer) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Pool.POOL era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Pool.PoolPredicateFailure era)
instance (Data.Typeable.Internal.Typeable era, Cardano.Ledger.Era.Era era) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rules.Pool.PoolPredicateFailure era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rules.Pool.PoolPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Newpp
data NEWPP era
data NewppState era
NewppState :: PParams era -> PPUPState era -> NewppState era
data NewppEnv era
NewppEnv :: DState (Crypto era) -> PState (Crypto era) -> UTxOState era -> AccountState -> NewppEnv era
data NewppPredicateFailure era
UnexpectedDepositPot :: !Coin -> !Coin -> NewppPredicateFailure era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Newpp.NewppPredicateFailure era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Newpp.NewppPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Newpp.NewppPredicateFailure era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Newpp.NewppPredicateFailure era)
instance (Data.Default.Class.Default (Cardano.Ledger.Core.PParams era), GHC.Records.HasField "_keyDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin, GHC.Records.HasField "_poolDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.ProtVer, GHC.Records.HasField "_maxTxSize" (Cardano.Ledger.Core.PParams era) GHC.Natural.Natural, GHC.Records.HasField "_maxBHSize" (Cardano.Ledger.Core.PParams era) GHC.Natural.Natural, GHC.Records.HasField "_maxBBSize" (Cardano.Ledger.Core.PParams era) GHC.Natural.Natural, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParamsDelta era) (Data.Maybe.Strict.StrictMaybe Cardano.Ledger.BaseTypes.ProtVer), Data.Typeable.Internal.Typeable era) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Newpp.NEWPP era)
instance Data.Default.Class.Default (Cardano.Ledger.Core.PParams era) => Data.Default.Class.Default (Cardano.Ledger.Shelley.Rules.Newpp.NewppState era)


-- | Epoch change registration.
--   
--   The rules of this module determine how the update subsystem of the
--   ledger handles the epoch transitions.
module Cardano.Ledger.Shelley.Rules.Upec

-- | Update epoch change
data UPEC era
newtype UpecPredicateFailure era
NewPpFailure :: PredicateFailure (NEWPP era) -> UpecPredicateFailure era

-- | If at least <tt>n</tt> nodes voted to change <b>the same</b> protocol
--   parameters to <b>the same</b> values, return the given protocol
--   parameters updated to these values. Here <tt>n</tt> is the quorum
--   needed.
votedValue :: forall era. UsesPParams era => ProposedPPUpdates era -> PParams era -> Int -> Maybe (PParams era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Upec.UpecPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Upec.UpecPredicateFailure era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Upec.UpecPredicateFailure era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Upec.UpecPredicateFailure era)
instance (Cardano.Ledger.Shelley.Constraints.UsesAuxiliary era, Cardano.Ledger.Shelley.Constraints.UsesTxBody era, Cardano.Ledger.Shelley.Constraints.UsesScript era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Cardano.Ledger.Shelley.Constraints.UsesPParams era, Data.Default.Class.Default (Cardano.Ledger.Core.PParams era), Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.PPUPState era, GHC.Records.HasField "_keyDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin, GHC.Records.HasField "_maxBBSize" (Cardano.Ledger.Core.PParams era) GHC.Natural.Natural, GHC.Records.HasField "_maxTxSize" (Cardano.Ledger.Core.PParams era) GHC.Natural.Natural, GHC.Records.HasField "_maxBHSize" (Cardano.Ledger.Core.PParams era) GHC.Natural.Natural, GHC.Records.HasField "_poolDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.ProtVer, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParamsDelta era) (Data.Maybe.Strict.StrictMaybe Cardano.Ledger.BaseTypes.ProtVer)) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Upec.UPEC era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Newpp.NEWPP era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Newpp.NEWPP era) (Cardano.Ledger.Shelley.Rules.Upec.UPEC era)

module Cardano.Ledger.Shelley.Rules.Mir
data MIR era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data MirPredicateFailure era
data MirEvent era
MirTransfer :: InstantaneousRewards (Crypto era) -> MirEvent era

-- | We were not able to perform an MIR transfer due to insufficient funds.
--   This event gives the rewards we wanted to pay, plus the available
--   reserves and treasury.
NoMirTransfer :: InstantaneousRewards (Crypto era) -> Coin -> Coin -> MirEvent era
emptyInstantaneousRewards :: InstantaneousRewards crypto
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Mir.MirPredicateFailure era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Mir.MirPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Mir.MirPredicateFailure era)
instance (Data.Typeable.Internal.Typeable era, Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.EpochState era)) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Mir.MIR era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Mir.MirPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Epoch
data EPOCH era
data EpochPredicateFailure era
PoolReapFailure :: PredicateFailure (EraRule "POOLREAP" era) -> EpochPredicateFailure era
SnapFailure :: PredicateFailure (EraRule "SNAP" era) -> EpochPredicateFailure era
UpecFailure :: PredicateFailure (EraRule "UPEC" era) -> EpochPredicateFailure era
data EpochEvent era
PoolReapEvent :: Event (EraRule "POOLREAP" era) -> EpochEvent era
SnapEvent :: Event (EraRule "SNAP" era) -> EpochEvent era
UpecEvent :: Event (EraRule "UPEC" era) -> EpochEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Epoch.EpochPredicateFailure era)
instance (GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOLREAP" era)), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "SNAP" era)), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UPEC" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Epoch.EpochPredicateFailure era)
instance (GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOLREAP" era)), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "SNAP" era)), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UPEC" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Epoch.EpochPredicateFailure era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "SNAP" era) (Cardano.Ledger.Shelley.Rules.Epoch.EPOCH era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "SNAP" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.LedgerState era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "SNAP" era) GHC.Types.~ Cardano.Ledger.Shelley.EpochBoundary.SnapShots (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "SNAP" era) GHC.Types.~ (), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "POOLREAP" era) (Cardano.Ledger.Shelley.Rules.Epoch.EPOCH era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "POOLREAP" era) GHC.Types.~ Cardano.Ledger.Core.PParams era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "POOLREAP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.PoolReap.PoolreapState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "POOLREAP" era) GHC.Types.~ Cardano.Slotting.Slot.EpochNo, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UPEC" era) (Cardano.Ledger.Shelley.Rules.Epoch.EPOCH era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UPEC" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.EpochState era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UPEC" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UpecState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UPEC" era) GHC.Types.~ (), Data.Default.Class.Default (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), Data.Default.Class.Default (Cardano.Ledger.Core.PParams era), GHC.Records.HasField "_keyDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin, GHC.Records.HasField "_poolDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Epoch.EPOCH era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "SNAP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Snap.SnapPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "SNAP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Snap.SnapEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Snap.SNAP era) (Cardano.Ledger.Shelley.Rules.Epoch.EPOCH era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.PoolReap.POOLREAP era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOLREAP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.PoolReap.PoolreapPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "POOLREAP" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.PoolReap.PoolreapEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.PoolReap.POOLREAP era) (Cardano.Ledger.Shelley.Rules.Epoch.EPOCH era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Upec.UPEC era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UPEC" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Upec.UpecPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UPEC" era) GHC.Types.~ Data.Void.Void) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Upec.UPEC era) (Cardano.Ledger.Shelley.Rules.Epoch.EPOCH era)
instance (NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOLREAP" era)), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "SNAP" era)), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UPEC" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Epoch.EpochPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Deleg
data DELEG era
data DelegEnv era
DelegEnv :: SlotNo -> Ptr -> AccountState -> PParams era -> DelegEnv era
[slotNo] :: DelegEnv era -> SlotNo
[ptr_] :: DelegEnv era -> Ptr
[acnt_] :: DelegEnv era -> AccountState
[ppDE] :: DelegEnv era -> PParams era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
data DelegPredicateFailure era
StakeKeyAlreadyRegisteredDELEG :: !Credential 'Staking (Crypto era) -> DelegPredicateFailure era

-- | Indicates that the stake key is somehow already in the rewards map.
--   This error is now redundant with StakeKeyAlreadyRegisteredDELEG. We
--   should remove it and replace its one use with
--   StakeKeyAlreadyRegisteredDELEG.
StakeKeyInRewardsDELEG :: !Credential 'Staking (Crypto era) -> DelegPredicateFailure era
StakeKeyNotRegisteredDELEG :: !Credential 'Staking (Crypto era) -> DelegPredicateFailure era
StakeKeyNonZeroAccountBalanceDELEG :: !Maybe Coin -> DelegPredicateFailure era
StakeDelegationImpossibleDELEG :: !Credential 'Staking (Crypto era) -> DelegPredicateFailure era
WrongCertificateTypeDELEG :: DelegPredicateFailure era
GenesisKeyNotInMappingDELEG :: !KeyHash 'Genesis (Crypto era) -> DelegPredicateFailure era
DuplicateGenesisDelegateDELEG :: !KeyHash 'GenesisDelegate (Crypto era) -> DelegPredicateFailure era
InsufficientForInstantaneousRewardsDELEG :: !MIRPot -> !Coin -> !Coin -> DelegPredicateFailure era
MIRCertificateTooLateinEpochDELEG :: !SlotNo -> !SlotNo -> DelegPredicateFailure era
DuplicateGenesisVRFDELEG :: !Hash (Crypto era) (VerKeyVRF (Crypto era)) -> DelegPredicateFailure era
MIRTransferNotCurrentlyAllowed :: DelegPredicateFailure era
MIRNegativesNotCurrentlyAllowed :: DelegPredicateFailure era
InsufficientForTransferDELEG :: !MIRPot -> !Coin -> !Coin -> DelegPredicateFailure era
MIRProducesNegativeUpdate :: DelegPredicateFailure era
MIRNegativeTransfer :: !MIRPot -> !Coin -> DelegPredicateFailure era
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Deleg.DelegPredicateFailure era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Deleg.DelegPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Deleg.DelegPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParams era) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Deleg.DelegEnv era)
instance GHC.Classes.Eq (Cardano.Ledger.Core.PParams era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Deleg.DelegEnv era)
instance (Data.Typeable.Internal.Typeable era, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.ProtVer) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Deleg.DELEG era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Deleg.DelegPredicateFailure era)
instance (Data.Typeable.Internal.Typeable era, Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rules.Deleg.DelegPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rules.Deleg.DelegPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Delpl
data DELPL era
data DelplEnv era
DelplEnv :: SlotNo -> Ptr -> PParams era -> AccountState -> DelplEnv era
[delplSlotNo] :: DelplEnv era -> SlotNo
[delPlPtr] :: DelplEnv era -> Ptr
[delPlPp] :: DelplEnv era -> PParams era
[delPlAcnt] :: DelplEnv era -> AccountState
data DelplPredicateFailure era
PoolFailure :: PredicateFailure (EraRule "POOL" era) -> DelplPredicateFailure era
DelegFailure :: PredicateFailure (EraRule "DELEG" era) -> DelplPredicateFailure era
data DelplEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era)
instance (GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEG" era)), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOL" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era)
instance (GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEG" era)), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOL" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELEG" era) (Cardano.Ledger.Shelley.Rules.Delpl.DELPL era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "DELEG" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Deleg.DelegEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "DELEG" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.DState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "DELEG" era) GHC.Types.~ Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "POOL" era) (Cardano.Ledger.Shelley.Rules.Delpl.DELPL era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "POOL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Pool.PoolEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "POOL" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.PState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "POOL" era) GHC.Types.~ Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era)) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Delpl.DELPL era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Pool.POOL era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Pool.PoolPredicateFailure era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Pool.POOL era) (Cardano.Ledger.Shelley.Rules.Delpl.DELPL era)
instance (Cardano.Ledger.Era.Era era, GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.ProtVer, Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEG" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Deleg.DelegPredicateFailure era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Deleg.DELEG era) (Cardano.Ledger.Shelley.Rules.Delpl.DELPL era)
instance (NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEG" era)), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOL" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOL" era)), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEG" era)), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era)) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "POOL" era)), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEG" era)), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Delegs
data DELEGS era
data DelegsEnv era
DelegsEnv :: !SlotNo -> !TxIx -> !PParams era -> !Tx era -> !AccountState -> DelegsEnv era
[delegsSlotNo] :: DelegsEnv era -> !SlotNo
[delegsIx] :: DelegsEnv era -> !TxIx
[delegspp] :: DelegsEnv era -> !PParams era
[delegsTx] :: DelegsEnv era -> !Tx era
[delegsAccount] :: DelegsEnv era -> !AccountState
data DelegsPredicateFailure era
DelegateeNotRegisteredDELEG :: !KeyHash 'StakePool (Crypto era) -> DelegsPredicateFailure era
WithdrawalsNotInRewardsDELEGS :: !Map (RewardAcnt (Crypto era)) Coin -> DelegsPredicateFailure era
DelplFailure :: PredicateFailure (EraRule "DELPL" era) -> DelegsPredicateFailure era
newtype DelegsEvent era
DelplEvent :: Event (EraRule "DELPL" era) -> DelegsEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Delegs.DelegsPredicateFailure era)
instance (GHC.Show.Show (Cardano.Ledger.Core.Tx era), GHC.Show.Show (Cardano.Ledger.Core.PParams era)) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Delegs.DelegsEnv era)
instance GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era)) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Delegs.DelegsPredicateFailure era)
instance GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Delegs.DelegsPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, GHC.Records.HasField "wdrls" (Cardano.Ledger.Core.TxBody era) (Cardano.Ledger.Shelley.TxBody.Wdrl (Cardano.Ledger.Era.Crypto era)), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELPL" era) (Cardano.Ledger.Shelley.Rules.Delegs.DELEGS era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.DPState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era)) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Delegs.DELEGS era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Delpl.DELPL era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "DELPL" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delpl.DelplEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Delpl.DELPL era) (Cardano.Ledger.Shelley.Rules.Delegs.DELEGS era)
instance NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Delegs.DelegsPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rules.Delegs.DelegsPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELPL" era)), Data.Typeable.Internal.Typeable (Cardano.Ledger.Core.Script era)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rules.Delegs.DelegsPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Ledger
data LEDGER era
data LedgerEnv era
LedgerEnv :: !SlotNo -> !TxIx -> !PParams era -> !AccountState -> LedgerEnv era
[ledgerSlotNo] :: LedgerEnv era -> !SlotNo
[ledgerIx] :: LedgerEnv era -> !TxIx
[ledgerPp] :: LedgerEnv era -> !PParams era
[ledgerAccount] :: LedgerEnv era -> !AccountState
data LedgerPredicateFailure era
UtxowFailure :: PredicateFailure (EraRule "UTXOW" era) -> LedgerPredicateFailure era
DelegsFailure :: PredicateFailure (EraRule "DELEGS" era) -> LedgerPredicateFailure era
data LedgerEvent era
UtxowEvent :: Event (EraRule "UTXOW" era) -> LedgerEvent era
DelegsEvent :: Event (EraRule "DELEGS" era) -> LedgerEvent era

-- | Event type.
type family Event a

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Ledger.LedgerPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Core.PParams era) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Ledger.LedgerEnv era)
instance (GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEGS" era)), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOW" era)), Cardano.Ledger.Era.Era era) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Ledger.LedgerPredicateFailure era)
instance (GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEGS" era)), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOW" era)), Cardano.Ledger.Era.Era era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Ledger.LedgerPredicateFailure era)
instance (GHC.Show.Show (Cardano.Ledger.Core.PParams era), GHC.Show.Show (Cardano.Ledger.Core.Tx era), GHC.Show.Show (Cardano.Ledger.Core.TxOut era), GHC.Show.Show (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), GHC.Records.HasField "inputs" (Cardano.Ledger.Core.TxBody era) (Data.Set.Internal.Set (Cardano.Ledger.TxIn.TxIn (Cardano.Ledger.Era.Crypto era))), Cardano.Ledger.Keys.DSignable (Cardano.Ledger.Era.Crypto era) (Cardano.Ledger.Keys.Hash (Cardano.Ledger.Era.Crypto era) Cardano.Ledger.Hashes.EraIndependentTxBody), Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "DELEGS" era) (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "UTXOW" era) (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxo.UtxoEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.UTxOState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Core.Tx era, Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delegs.DelegsEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.DPState (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Data.Sequence.Internal.Seq (Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era)), GHC.Records.HasField "certs" (Cardano.Ledger.Core.TxBody era) (Data.Sequence.Strict.StrictSeq (Cardano.Ledger.Shelley.TxBody.DCert (Cardano.Ledger.Era.Crypto era))), GHC.Records.HasField "_keyDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin, GHC.Records.HasField "_poolDeposit" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.Coin.Coin) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Delegs.DELEGS era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delegs.DelegsPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "DELEGS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Delegs.DelegsEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Delegs.DELEGS era) (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Utxow.UTXOW era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Utxow.UtxowPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "UTXOW" era) GHC.Types.~ Control.State.Transition.Extended.Event (Cardano.Ledger.Shelley.Rules.Utxow.UTXOW era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Utxow.UTXOW era) (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era)
instance (NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEGS" era)), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOW" era)), Cardano.Ledger.Era.Era era) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Ledger.LedgerPredicateFailure era)
instance (Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEGS" era)), Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOW" era)), Cardano.Ledger.Era.Era era) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rules.Ledger.LedgerPredicateFailure era)
instance (Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "DELEGS" era)), Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "UTXOW" era)), Cardano.Ledger.Era.Era era) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rules.Ledger.LedgerPredicateFailure era)
instance Control.DeepSeq.NFData (Cardano.Ledger.Core.PParams era) => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.Rules.Ledger.LedgerEnv era)

module Cardano.Ledger.Shelley.Rules.Ledgers
data LEDGERS era
data LedgersEnv era
LedgersEnv :: SlotNo -> PParams era -> AccountState -> LedgersEnv era
[ledgersSlotNo] :: LedgersEnv era -> SlotNo
[ledgersPp] :: LedgersEnv era -> PParams era
[ledgersAccount] :: LedgersEnv era -> AccountState
newtype LedgersPredicateFailure era
LedgerFailure :: PredicateFailure (EraRule "LEDGER" era) -> LedgersPredicateFailure era
newtype LedgersEvent era
LedgerEvent :: Event (EraRule "LEDGER" era) -> LedgersEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Ledgers.LedgersPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Ledgers.LedgersPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Ledgers.LedgersPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "LEDGER" era) (Cardano.Ledger.Shelley.Rules.Ledgers.LEDGERS era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "LEDGER" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ledger.LedgerEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "LEDGER" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.LedgerState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "LEDGER" era) GHC.Types.~ Cardano.Ledger.Core.Tx era, Cardano.Ledger.Keys.DSignable (Cardano.Ledger.Era.Crypto era) (Cardano.Ledger.Keys.Hash (Cardano.Ledger.Era.Crypto era) Cardano.Ledger.Hashes.EraIndependentTxBody), Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.LedgerState era)) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Ledgers.LEDGERS era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ledger.LedgerPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "LEDGER" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ledger.LedgerEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Ledger.LEDGER era) (Cardano.Ledger.Shelley.Rules.Ledgers.LEDGERS era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Ledgers.LedgersPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Rules.Ledgers.LedgersPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Rules.Ledgers.LedgersPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Bbody
data BBODY era
data BbodyState era
BbodyState :: LedgerState era -> BlocksMade (Crypto era) -> BbodyState era
data BbodyEnv era
BbodyEnv :: PParams era -> AccountState -> BbodyEnv era
[bbodyPp] :: BbodyEnv era -> PParams era
[bbodyAccount] :: BbodyEnv era -> AccountState
data BbodyPredicateFailure era
WrongBlockBodySizeBBODY :: !Int -> !Int -> BbodyPredicateFailure era
InvalidBodyHashBBODY :: !Hash (Crypto era) EraIndependentBlockBody -> !Hash (Crypto era) EraIndependentBlockBody -> BbodyPredicateFailure era
LedgersFailure :: PredicateFailure (EraRule "LEDGERS" era) -> BbodyPredicateFailure era
newtype BbodyEvent era
LedgersEvent :: Event (EraRule "LEDGERS" era) -> BbodyEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a

-- | Type of the state which the system transitions between.
type family State a
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Bbody.BbodyPredicateFailure era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.LedgerState.LedgerState era) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Bbody.BbodyState era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.LedgerState.LedgerState era) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Bbody.BbodyState era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGERS" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Bbody.BbodyPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGERS" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Bbody.BbodyPredicateFailure era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxBody era, Cardano.Ledger.Shelley.Constraints.UsesAuxiliary era, Cardano.Ledger.Serialization.ToCBORGroup (Cardano.Ledger.Era.TxSeq era), Cardano.Ledger.Keys.DSignable (Cardano.Ledger.Era.Crypto era) (Cardano.Ledger.Keys.Hash (Cardano.Ledger.Era.Crypto era) Cardano.Ledger.Hashes.EraIndependentTxBody), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "LEDGERS" era) (Cardano.Ledger.Shelley.Rules.Bbody.BBODY era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "LEDGERS" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Ledgers.LedgersEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "LEDGERS" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.LedgerState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "LEDGERS" era) GHC.Types.~ Data.Sequence.Internal.Seq (Cardano.Ledger.Core.Tx era), GHC.Records.HasField "_d" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.UnitInterval) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Bbody.BBODY era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.BaseM ledgers GHC.Types.~ Cardano.Ledger.BaseTypes.ShelleyBase, ledgers GHC.Types.~ Cardano.Ledger.Core.EraRule "LEDGERS" era, Control.State.Transition.Extended.STS ledgers, Cardano.Ledger.Keys.DSignable (Cardano.Ledger.Era.Crypto era) (Cardano.Ledger.Keys.Hash (Cardano.Ledger.Era.Crypto era) Cardano.Ledger.Hashes.EraIndependentTxBody), Cardano.Ledger.Era.Era era) => Control.State.Transition.Extended.Embed ledgers (Cardano.Ledger.Shelley.Rules.Bbody.BBODY era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGERS" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Bbody.BbodyPredicateFailure era)

module Cardano.Ledger.Shelley.Genesis

-- | Genesis Shelley staking configuration.
--   
--   This allows us to configure some initial stake pools and delegation to
--   them, in order to test Praos in a static configuration, without
--   requiring on-chain registration and delegation.
--   
--   For simplicity, pools defined in the genesis staking do not pay
--   deposits for their registration.
data ShelleyGenesisStaking crypto
ShelleyGenesisStaking :: !Map (KeyHash 'StakePool crypto) (PoolParams crypto) -> !Map (KeyHash 'Staking crypto) (KeyHash 'StakePool crypto) -> ShelleyGenesisStaking crypto

-- | Pools to register
--   
--   The key in this map is the hash of the public key of the _pool_. This
--   need not correspond to any payment or staking key, but must correspond
--   to the cold key held by <tt>TPraosIsCoreNode</tt>.
[sgsPools] :: ShelleyGenesisStaking crypto -> !Map (KeyHash 'StakePool crypto) (PoolParams crypto)

-- | Stake-holding key hash credentials and the pools to delegate that
--   stake to. We require the raw staking key hash in order to:
--   
--   <ul>
--   <li>Avoid pointer addresses, which would be tricky when there's no
--   slot or transaction to point to.</li>
--   <li>Avoid script credentials.</li>
--   </ul>
[sgsStake] :: ShelleyGenesisStaking crypto -> !Map (KeyHash 'Staking crypto) (KeyHash 'StakePool crypto)

-- | Shelley genesis information
--   
--   Note that this is needed only for a pure Shelley network, hence it
--   being defined here rather than in its own module. In mainnet, Shelley
--   will transition naturally from Byron, and thus will never have its own
--   genesis information.
data ShelleyGenesis era
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTime -> !Word64 -> !Word64 -> !PParams era -> !Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era)) -> !Map (Addr (Crypto era)) Coin -> !ShelleyGenesisStaking (Crypto era) -> ShelleyGenesis era
[sgSystemStart] :: ShelleyGenesis era -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis era -> !Word32
[sgNetworkId] :: ShelleyGenesis era -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis era -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis era -> !Word64
[sgEpochLength] :: ShelleyGenesis era -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis era -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis era -> !Word64
[sgSlotLength] :: ShelleyGenesis era -> !NominalDiffTime
[sgUpdateQuorum] :: ShelleyGenesis era -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis era -> !Word64
[sgProtocolParams] :: ShelleyGenesis era -> !PParams era
[sgGenDelegs] :: ShelleyGenesis era -> !Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era))
[sgInitialFunds] :: ShelleyGenesis era -> !Map (Addr (Crypto era)) Coin
[sgStaking] :: ShelleyGenesis era -> !ShelleyGenesisStaking (Crypto era)
data ValidationErr
EpochNotLongEnough :: EpochSize -> Word64 -> Rational -> EpochSize -> ValidationErr
MaxKESEvolutionsUnsupported :: Word64 -> Word -> ValidationErr
QuorumTooSmall :: Word64 -> Word64 -> Word64 -> ValidationErr

-- | Empty genesis staking
emptyGenesisStaking :: ShelleyGenesisStaking crypto
sgActiveSlotCoeff :: ShelleyGenesis era -> ActiveSlotCoeff
genesisUTxO :: forall era. (Era era, UsesTxOut era) => ShelleyGenesis era -> UTxO era

-- | Compute the <a>TxIn</a> of the initial UTxO pseudo-transaction
--   corresponding to the given address in the genesis initial funds.
--   
--   The Shelley initial UTxO is constructed from the <a>sgInitialFunds</a>
--   which is not a full UTxO but just a map from addresses to coin values.
--   
--   This gets turned into a UTxO by making a pseudo-transaction for each
--   address, with the 0th output being the coin value. So to spend from
--   the initial UTxO we need this same <a>TxIn</a> to use as an input to
--   the spending transaction.
initialFundsPseudoTxIn :: forall crypto. Crypto crypto => Addr crypto -> TxIn crypto

-- | Do some basic sanity checking on the Shelley genesis file.
validateGenesis :: forall era. Era era => ShelleyGenesis era -> Either [ValidationErr] ()
describeValidationErr :: ValidationErr -> Text
mkShelleyGlobals :: ShelleyGenesis era -> EpochInfo (Either Text) -> Natural -> Globals
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking crypto)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis era)
instance GHC.Show.Show (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis era)
instance GHC.Classes.Eq (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis era)
instance GHC.Show.Show Cardano.Ledger.Shelley.Genesis.ValidationErr
instance GHC.Classes.Eq Cardano.Ledger.Shelley.Genesis.ValidationErr
instance Cardano.Ledger.Era.Era era => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis era)
instance Cardano.Ledger.Era.Era era => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis era)
instance Cardano.Ledger.Era.Era era => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis era)
instance Cardano.Ledger.Era.Era era => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Genesis.ShelleyGenesis era)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Shelley.Genesis.ShelleyGenesisStaking crypto)

module Cardano.Ledger.Shelley.AdaPots
data AdaPots
AdaPots :: Coin -> Coin -> Coin -> Coin -> Coin -> Coin -> AdaPots
[treasuryAdaPot] :: AdaPots -> Coin
[reservesAdaPot] :: AdaPots -> Coin
[rewardsAdaPot] :: AdaPots -> Coin
[utxoAdaPot] :: AdaPots -> Coin
[depositsAdaPot] :: AdaPots -> Coin
[feesAdaPot] :: AdaPots -> Coin

-- | Calculate the total ada in the epoch state
totalAdaES :: UsesValue era => EpochState era -> Coin

-- | Calculate the total ada pots in the epoch state
totalAdaPotsES :: UsesValue era => EpochState era -> AdaPots
instance GHC.Classes.Eq Cardano.Ledger.Shelley.AdaPots.AdaPots
instance GHC.Show.Show Cardano.Ledger.Shelley.AdaPots.AdaPots

module Cardano.Ledger.Shelley.Rules.NewEpoch
data NEWEPOCH era
data NewEpochPredicateFailure era
EpochFailure :: PredicateFailure (EraRule "EPOCH" era) -> NewEpochPredicateFailure era
CorruptRewardUpdate :: !RewardUpdate (Crypto era) -> NewEpochPredicateFailure era
MirFailure :: PredicateFailure (EraRule "MIR" era) -> NewEpochPredicateFailure era
data NewEpochEvent era
DeltaRewardEvent :: Event (EraRule "RUPD" era) -> NewEpochEvent era
RestrainedRewards :: EpochNo -> Map (Credential 'Staking (Crypto era)) (Set (Reward (Crypto era))) -> Set (Credential 'Staking (Crypto era)) -> NewEpochEvent era
TotalRewardEvent :: EpochNo -> Map (Credential 'Staking (Crypto era)) (Set (Reward (Crypto era))) -> NewEpochEvent era
EpochEvent :: Event (EraRule "EPOCH" era) -> NewEpochEvent era
MirEvent :: Event (EraRule "MIR" era) -> NewEpochEvent era
TotalAdaPotsEvent :: AdaPots -> NewEpochEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
calculatePoolDistr :: SnapShot crypto -> PoolDistr crypto
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.NewEpoch.NewEpochPredicateFailure era)
instance (GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "EPOCH" era)), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "MIR" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.NewEpoch.NewEpochPredicateFailure era)
instance (GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "EPOCH" era)), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "MIR" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.NewEpoch.NewEpochPredicateFailure era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "MIR" era) (Cardano.Ledger.Shelley.Rules.NewEpoch.NEWEPOCH era), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "EPOCH" era) (Cardano.Ledger.Shelley.Rules.NewEpoch.NEWEPOCH era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "MIR" era) GHC.Types.~ (), Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "MIR" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.EpochState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "MIR" era) GHC.Types.~ (), Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "RUPD" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Rupd.RupdEvent (Cardano.Ledger.Era.Crypto era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "EPOCH" era) GHC.Types.~ (), Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "EPOCH" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.EpochState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "EPOCH" era) GHC.Types.~ Cardano.Slotting.Slot.EpochNo, Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.EpochState era), GHC.Records.HasField "_protocolVersion" (Cardano.Ledger.Core.PParams era) Cardano.Ledger.BaseTypes.ProtVer, Data.Default.Class.Default (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" era)), Data.Default.Class.Default (Cardano.Ledger.Core.PParams era), Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.StashedAVVMAddresses era)) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.NewEpoch.NEWEPOCH era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Epoch.EPOCH era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "EPOCH" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Epoch.EpochPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "EPOCH" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Epoch.EpochEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Epoch.EPOCH era) (Cardano.Ledger.Shelley.Rules.NewEpoch.NEWEPOCH era)
instance (Cardano.Ledger.Era.Era era, Data.Default.Class.Default (Cardano.Ledger.Shelley.LedgerState.EpochState era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "MIR" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Mir.MirPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "MIR" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Mir.MirEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Mir.MIR era) (Cardano.Ledger.Shelley.Rules.NewEpoch.NEWEPOCH era)
instance (NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "EPOCH" era)), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "MIR" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.NewEpoch.NewEpochPredicateFailure era)

module Cardano.Ledger.Shelley.Rules.Tick
data TICK era

-- | Type of the state which the system transitions between.
type family State a
data TickPredicateFailure era
NewEpochFailure :: PredicateFailure (EraRule "NEWEPOCH" era) -> TickPredicateFailure era
RupdFailure :: PredicateFailure (EraRule "RUPD" era) -> TickPredicateFailure era
data TickEvent era
NewEpochEvent :: Event (EraRule "NEWEPOCH" era) -> TickEvent era
RupdEvent :: Event (EraRule "RUPD" era) -> TickEvent era

-- | Descriptive type for the possible failures which might cause a
--   transition to fail.
--   
--   As a convention, <a>PredicateFailure</a>s which are "structural"
--   (meaning that they are not "throwable" in practice, and are used to
--   pass control from one transition rule to another) are prefixed with
--   <tt>S_</tt>.
--   
--   Structural <a>PredicateFailure</a>s represent conditions between rules
--   where the disjunction of all rules' preconditions is equal to
--   <a>True</a>. That is, either one rule will throw a structural
--   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
type family PredicateFailure a
adoptGenesisDelegs :: EpochState era -> SlotNo -> EpochState era
data TICKF era
newtype TickfPredicateFailure era
TickfNewEpochFailure :: PredicateFailure (EraRule "NEWEPOCH" era) -> TickfPredicateFailure era
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Tick.TickPredicateFailure era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Tick.TickEvent era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.Rules.Tick.TickfPredicateFailure era)
instance (GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "NEWEPOCH" era)), GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "RUPD" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Tick.TickPredicateFailure era)
instance (GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "NEWEPOCH" era)), GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "RUPD" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Tick.TickPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "NEWEPOCH" era))) => GHC.Show.Show (Cardano.Ledger.Shelley.Rules.Tick.TickfPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "NEWEPOCH" era))) => GHC.Classes.Eq (Cardano.Ledger.Shelley.Rules.Tick.TickfPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) (Cardano.Ledger.Shelley.Rules.Tick.TICKF era), Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) GHC.Types.~ (), Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.NewEpochState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) GHC.Types.~ Cardano.Slotting.Slot.EpochNo) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Tick.TICKF era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.NewEpoch.NEWEPOCH era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.NewEpoch.NewEpochPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.NewEpoch.NewEpochEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.NewEpoch.NEWEPOCH era) (Cardano.Ledger.Shelley.Rules.Tick.TICKF era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "NEWEPOCH" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Tick.TickfPredicateFailure era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) (Cardano.Ledger.Shelley.Rules.Tick.TICK era), Control.State.Transition.Extended.Embed (Cardano.Ledger.Core.EraRule "RUPD" era) (Cardano.Ledger.Shelley.Rules.Tick.TICK era), Control.State.Transition.Extended.State (Cardano.Ledger.Shelley.Rules.Tick.TICK era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.NewEpochState era, Control.State.Transition.Extended.BaseM (Cardano.Ledger.Shelley.Rules.Tick.TICK era) GHC.Types.~ Cardano.Ledger.BaseTypes.ShelleyBase, Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "RUPD" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Rupd.RupdEnv era, Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "RUPD" era) GHC.Types.~ Data.Maybe.Strict.StrictMaybe (Cardano.Ledger.Shelley.RewardUpdate.PulsingRewUpdate (Cardano.Ledger.Era.Crypto era)), Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "RUPD" era) GHC.Types.~ Cardano.Slotting.Slot.SlotNo, Control.State.Transition.Extended.Environment (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) GHC.Types.~ (), Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) GHC.Types.~ Cardano.Ledger.Shelley.LedgerState.NewEpochState era, Control.State.Transition.Extended.Signal (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) GHC.Types.~ Cardano.Slotting.Slot.EpochNo) => Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Tick.TICK era)
instance (Cardano.Ledger.Shelley.Constraints.UsesTxOut era, Cardano.Ledger.Shelley.Constraints.UsesValue era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.NewEpoch.NEWEPOCH era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.NewEpoch.NewEpochPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "NEWEPOCH" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.NewEpoch.NewEpochEvent era) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.NewEpoch.NEWEPOCH era) (Cardano.Ledger.Shelley.Rules.Tick.TICK era)
instance (Cardano.Ledger.Era.Era era, Control.State.Transition.Extended.STS (Cardano.Ledger.Shelley.Rules.Rupd.RUPD era), Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "RUPD" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Rupd.RupdPredicateFailure era, Control.State.Transition.Extended.Event (Cardano.Ledger.Core.EraRule "RUPD" era) GHC.Types.~ Cardano.Ledger.Shelley.Rules.Rupd.RupdEvent (Cardano.Ledger.Era.Crypto era)) => Control.State.Transition.Extended.Embed (Cardano.Ledger.Shelley.Rules.Rupd.RUPD era) (Cardano.Ledger.Shelley.Rules.Tick.TICK era)
instance (NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "NEWEPOCH" era)), NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "RUPD" era))) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.Rules.Tick.TickPredicateFailure era)


-- | This module provides the mapping from conceptual rule names to
--   concrete rules for the Shelley era.
module Cardano.Ledger.Shelley.Rules.EraMapping


-- | Interface to the block validation and chain extension logic in the
--   Shelley API.
module Cardano.Ledger.Shelley.API.Validation
class (ChainData (NewEpochState era), SerialisableData (NewEpochState era), ChainData (BlockTransitionError era), ChainData ChainPredicateFailure, STS (EraRule "TICK" era), BaseM (EraRule "TICK" era) ~ ShelleyBase, Environment (EraRule "TICK" era) ~ (), State (EraRule "TICK" era) ~ NewEpochState era, Signal (EraRule "TICK" era) ~ SlotNo, STS (EraRule "BBODY" era), BaseM (EraRule "BBODY" era) ~ ShelleyBase, Environment (EraRule "BBODY" era) ~ BbodyEnv era, State (EraRule "BBODY" era) ~ BbodyState era, Signal (EraRule "BBODY" era) ~ Block (BHeaderView (Crypto era)) era, ToCBORGroup (TxSeq era)) => ApplyBlock era

-- | Apply the header level ledger transition.
--   
--   This handles checks and updates that happen on a slot tick, as well as
--   a few header level checks, such as size constraints.
applyTickOpts :: ApplyBlock era => ApplySTSOpts ep -> Globals -> NewEpochState era -> SlotNo -> EventReturnType ep (EraRule "TICK" era) (NewEpochState era)

-- | Apply the block level ledger transition.
applyBlockOpts :: forall ep m. (ApplyBlock era, EventReturnTypeRep ep, MonadError (BlockTransitionError era) m) => ApplySTSOpts ep -> Globals -> NewEpochState era -> Block (BHeaderView (Crypto era)) era -> m (EventReturnType ep (EraRule "BBODY" era) (NewEpochState era))

-- | Re-apply a ledger block to the same state it has been applied to
--   before.
--   
--   This function does no validation of whether the block applies
--   successfully; the caller implicitly guarantees that they have
--   previously called <tt>applyBlockTransition</tt> on the same block and
--   that this was successful.
reapplyBlock :: ApplyBlock era => Globals -> NewEpochState era -> Block (BHeaderView (Crypto era)) era -> NewEpochState era
applyBlock :: (ApplyBlock era, MonadError (BlockTransitionError era) m) => Globals -> NewEpochState era -> Block (BHeaderView (Crypto era)) era -> m (NewEpochState era)
applyTick :: ApplyBlock era => Globals -> NewEpochState era -> SlotNo -> NewEpochState era
newtype TickTransitionError era
TickTransitionError :: [PredicateFailure (EraRule "TICK" era)] -> TickTransitionError era
newtype BlockTransitionError era
BlockTransitionError :: [PredicateFailure (EraRule "BBODY" era)] -> BlockTransitionError era
chainChecks :: forall crypto m. MonadError ChainPredicateFailure m => Natural -> ChainChecksPParams -> BHeaderView crypto -> m ()
type ShelleyEraCrypto crypto = (Crypto crypto, DSignable crypto (Hash crypto EraIndependentTxBody))
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.API.Validation.TickTransitionError era)
instance GHC.Generics.Generic (Cardano.Ledger.Shelley.API.Validation.BlockTransitionError era)
instance GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICK" era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.API.Validation.TickTransitionError era)
instance GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICK" era)) => GHC.Show.Show (Cardano.Ledger.Shelley.API.Validation.TickTransitionError era)
instance GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "BBODY" era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.API.Validation.BlockTransitionError era)
instance GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "BBODY" era)) => GHC.Show.Show (Cardano.Ledger.Shelley.API.Validation.BlockTransitionError era)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto crypto => Cardano.Ledger.Shelley.API.Validation.ApplyBlock (Cardano.Ledger.Shelley.ShelleyEra crypto)
instance NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "BBODY" era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.API.Validation.BlockTransitionError era)
instance NoThunks.Class.NoThunks (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "TICK" era)) => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.API.Validation.TickTransitionError era)


-- | Interface to the Shelley ledger for the purposes of managing a Shelley
--   mempool.
module Cardano.Ledger.Shelley.API.Mempool
class (ChainData (Tx era), AnnotatedData (Tx era), Eq (ApplyTxError era), Show (ApplyTxError era), Typeable (ApplyTxError era), SerialisableData (ApplyTxError era), STS (EraRule "LEDGER" era), BaseM (EraRule "LEDGER" era) ~ ShelleyBase, Environment (EraRule "LEDGER" era) ~ LedgerEnv era, State (EraRule "LEDGER" era) ~ MempoolState era, Signal (EraRule "LEDGER" era) ~ Tx era, PredicateFailure (EraRule "LEDGER" era) ~ LedgerPredicateFailure era) => ApplyTx era

-- | Validate a transaction against a mempool state, and return both the
--   new mempool state and a "validated" <tt>TxInBlock</tt>.
--   
--   The meaning of being "validated" depends on the era. In general, a
--   <tt>TxInBlock</tt> has had all checks run, and can now only fail due
--   to checks which depend on the state; most notably, that UTxO inputs
--   disappear.
applyTx :: (ApplyTx era, MonadError (ApplyTxError era) m) => Globals -> MempoolEnv era -> MempoolState era -> Tx era -> m (MempoolState era, Validated (Tx era))

-- | Reapply a previously validated <tt>Tx</tt>.
--   
--   This applies the (validated) transaction to a new mempool state. It
--   may fail due to the mempool state changing (for example, a needed
--   output having already been spent). It should not fail due to any
--   static check (such as cryptographic checks).
--   
--   Implementations of this function may optionally skip the performance
--   of any static checks. This is not required, but strongly encouraged
--   since this function will be called each time the mempool revalidates
--   transactions against a new mempool state.
reapplyTx :: (ApplyTx era, MonadError (ApplyTxError era) m) => Globals -> MempoolEnv era -> MempoolState era -> Validated (Tx era) -> m (MempoolState era)
newtype ApplyTxError era
ApplyTxError :: [PredicateFailure (EraRule "LEDGER" era)] -> ApplyTxError era

-- | A newtype which indicates that a transaction has been validated
--   against some chain state.
data Validated tx

-- | Extract the underlying unvalidated Tx.
extractTx :: Validated tx -> tx
coerceValidated :: Coercible a b => Validated a -> Validated b

-- | Translate a validated transaction across eras.
--   
--   This is not a <a>TranslateEra</a> instance since <a>Validated</a> is
--   not itself era-parametrised.
translateValidated :: forall era f. TranslateEra era f => TranslationContext era -> Validated (f (PreviousEra era)) -> Except (TranslationError era f) (Validated (f era))
type MempoolEnv era = LedgerEnv era
type MempoolState era = LedgerState era
applyTxsTransition :: forall era m. (ApplyTx era, MonadError (ApplyTxError era) m) => Globals -> MempoolEnv era -> Seq (Tx era) -> MempoolState era -> m (MempoolState era)
unsafeMakeValidated :: tx -> Validated tx

-- | Old <a>applyTxs</a>
applyTxs :: (ApplyTx era, MonadError (ApplyTxError era) m) => Globals -> SlotNo -> Seq (Tx era) -> NewEpochState era -> m (NewEpochState era)

-- | Construct the environment used to validate transactions from the full
--   ledger state.
--   
--   Note that this function also takes a slot. During slot validation, the
--   slot given here is the slot of the block containing the transactions.
--   This slot is used for quite a number of things, but in general these
--   do not determine the validity of the transaction. There are two
--   exceptions:
--   
--   <ul>
--   <li>Each transaction has a ttl (time-to-live) value. If the slot is
--   beyond this value, then the transaction is invalid.</li>
--   <li>If the transaction contains a protocol update proposal, then it
--   may only be included until a certain number of slots before the end of
--   the epoch. A protocol update proposal submitted after this is
--   considered invalid.</li>
--   </ul>
mkMempoolEnv :: NewEpochState era -> SlotNo -> MempoolEnv era

-- | Construct a mempool state from the wider ledger state.
--   
--   The given mempool state may then be evolved using <a>applyTxs</a>, but
--   should be regenerated when the ledger state gets updated (e.g. through
--   application of a new block).
mkMempoolState :: NewEpochState era -> MempoolState era

-- | Transform a function over mempool states to one over the full
--   <a>NewEpochState</a>.
overNewEpochState :: Functor f => (MempoolState era -> f (MempoolState era)) -> NewEpochState era -> f (NewEpochState era)
instance Control.DeepSeq.NFData tx => Control.DeepSeq.NFData (Cardano.Ledger.Shelley.API.Mempool.Validated tx)
instance GHC.Show.Show tx => GHC.Show.Show (Cardano.Ledger.Shelley.API.Mempool.Validated tx)
instance NoThunks.Class.NoThunks tx => NoThunks.Class.NoThunks (Cardano.Ledger.Shelley.API.Mempool.Validated tx)
instance GHC.Classes.Eq tx => GHC.Classes.Eq (Cardano.Ledger.Shelley.API.Mempool.Validated tx)
instance GHC.Classes.Eq (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era)) => GHC.Classes.Eq (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance GHC.Show.Show (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era)) => GHC.Show.Show (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance Cardano.Ledger.Shelley.API.Validation.ShelleyEraCrypto c => Cardano.Ledger.Shelley.API.Mempool.ApplyTx (Cardano.Ledger.Shelley.ShelleyEra c)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.ToCBOR.ToCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)
instance (Cardano.Ledger.Era.Era era, Cardano.Binary.FromCBOR.FromCBOR (Control.State.Transition.Extended.PredicateFailure (Cardano.Ledger.Core.EraRule "LEDGER" era))) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Shelley.API.Mempool.ApplyTxError era)

module Cardano.Ledger.Shelley.API.Wallet

-- | Get the full UTxO.
getUTxO :: NewEpochState era -> UTxO era
getUTxOSubset :: NewEpochState era -> Set (TxIn (Crypto era)) -> UTxO era

-- | Get the UTxO filtered by address.
getFilteredUTxO :: Era era => NewEpochState era -> Set (Addr (Crypto era)) -> UTxO era

-- | Get the <i>current</i> registered stake pools.
getPools :: NewEpochState era -> Set (KeyHash 'StakePool (Crypto era))

-- | Get the <i>current</i> registered stake pool parameters for a given
--   set of stake pools. The result map will contain entries for all the
--   given stake pools that are currently registered.
getPoolParameters :: NewEpochState era -> Set (KeyHash 'StakePool (Crypto era)) -> Map (KeyHash 'StakePool (Crypto era)) (PoolParams (Crypto era))

-- | Calculate the current total stake.
getTotalStake :: Globals -> NewEpochState era -> Coin

-- | Get pool sizes, but in terms of total stake
--   
--   The stake distribution uses active stake (so that the leader schedule
--   is not affected by undelegated stake), but the wallet wants to display
--   pool saturation for rewards purposes. For that, it needs the fraction
--   of total stake.
--   
--   This is not based on any snapshot, but uses the current ledger state.
poolsByTotalStakeFraction :: forall era. Globals -> NewEpochState era -> PoolDistr (Crypto era)

-- | Information about a stake pool
data RewardInfoPool
RewardInfoPool :: Coin -> Coin -> Coin -> Coin -> UnitInterval -> Double -> RewardInfoPool

-- | Absolute stake delegated to this pool
[stake] :: RewardInfoPool -> Coin

-- | Pledge of pool owner(s)
[ownerPledge] :: RewardInfoPool -> Coin

-- | Absolute stake delegated by pool owner(s)
[ownerStake] :: RewardInfoPool -> Coin

-- | Pool cost
[cost] :: RewardInfoPool -> Coin

-- | Pool margin
[margin] :: RewardInfoPool -> UnitInterval

-- | Number of blocks produced divided by expected number of blocks. Can be
--   larger than <tt>1.0</tt> for pool that gets lucky. (If some pools get
--   unlucky, some pools must get lucky.)
[performanceEstimate] :: RewardInfoPool -> Double

-- | Global information that influences stake pool rewards
data RewardParams
RewardParams :: Natural -> NonNegativeInterval -> Coin -> Coin -> RewardParams

-- | Desired number of stake pools
[nOpt] :: RewardParams -> Natural

-- | Influence of the pool owner's pledge on rewards
[a0] :: RewardParams -> NonNegativeInterval

-- | Total rewards available for the given epoch
[rPot] :: RewardParams -> Coin

-- | Maximum lovelace supply minus treasury
[totalStake] :: RewardParams -> Coin

-- | Retrieve the information necessary to calculate stake pool member
--   rewards from the <i>current</i> stake distribution.
--   
--   This information includes the current stake distribution aggregated by
--   stake pools and pool owners, the <tt>current</tt> pool costs and
--   margins, and performance estimates. Also included are global
--   information such as the total stake or protocol parameters.
getRewardInfoPools :: (HasField "_a0" (PParams era) NonNegativeInterval, HasField "_nOpt" (PParams era) Natural) => Globals -> NewEpochState era -> (RewardParams, Map (KeyHash 'StakePool (Crypto era)) RewardInfoPool)

-- | Calculate stake pool rewards from the snapshot labeled <tt>go</tt>.
--   Also includes information on how the rewards were calculated
--   (<a>RewardProvenance</a>).
--   
--   For a calculation of rewards based on the current stake distribution,
--   see <a>getRewardInfoPools</a>.
--   
--   TODO: Deprecate <a>getRewardProvenance</a>, because wallets are more
--   likely to use <a>getRewardInfoPools</a> for up-to-date information on
--   stake pool rewards.
getRewardProvenance :: forall era. (HasField "_a0" (PParams era) NonNegativeInterval, HasField "_d" (PParams era) UnitInterval, HasField "_nOpt" (PParams era) Natural, HasField "_protocolVersion" (PParams era) ProtVer, HasField "_rho" (PParams era) UnitInterval, HasField "_tau" (PParams era) UnitInterval) => Globals -> NewEpochState era -> (RewardUpdate (Crypto era), RewardProvenance (Crypto era))

-- | Calculate the Non-Myopic Pool Member Rewards for a set of credentials.
--   For each given credential, this function returns a map from each stake
--   pool (identified by the key hash of the pool operator) to the
--   non-myopic pool member reward for that stake pool.
--   
--   This is not based on any snapshot, but uses the current ledger state.
getNonMyopicMemberRewards :: (HasField "_a0" (PParams era) NonNegativeInterval, HasField "_nOpt" (PParams era) Natural) => Globals -> NewEpochState era -> Set (Either Coin (Credential 'Staking (Crypto era))) -> Map (Either Coin (Credential 'Staking (Crypto era))) (Map (KeyHash 'StakePool (Crypto era)) Coin)

-- | A collection of functons to help construction transactions from the
--   cardano-cli.
class (Era era, HasField "_minfeeA" (PParams era) Natural, HasField "_keyDeposit" (PParams era) Coin, HasField "_poolDeposit" (PParams era) Coin, HasField "certs" (TxBody era) (StrictSeq (DCert (Crypto era)))) => CLI era

-- | The minimum fee calculation. Used for the default implentation of
--   <a>evaluateTransactionFee</a>.
evaluateMinFee :: CLI era => PParams era -> Tx era -> Coin

-- | The consumed calculation. Used for the default implentation of
--   <a>evaluateTransactionBalance</a>.
evaluateConsumed :: CLI era => PParams era -> UTxO era -> TxBody era -> Value era
addKeyWitnesses :: CLI era => Tx era -> Set (WitVKey 'Witness (Crypto era)) -> Tx era

-- | Evaluate the difference between the value currently being consumed by
--   a transaction and the number of lovelace being produced. This value
--   will be zero for a valid transaction.
evaluateTransactionBalance :: CLI era => PParams era -> UTxO era -> (KeyHash 'StakePool (Crypto era) -> Bool) -> TxBody era -> Value era

-- | Evaluate the fee for a given transaction.
evaluateTransactionFee :: CLI era => PParams era -> Tx era -> Word -> Coin

-- | Evaluate the minimum lovelace that a given transaciton output must
--   contain.
evaluateMinLovelaceOutput :: CLI era => PParams era -> TxOut era -> Coin
addShelleyKeyWitnesses :: (Era era, Witnesses era ~ WitnessSet era, AnnotatedData (Script era), ToCBOR (AuxiliaryData era), ToCBOR (TxBody era)) => Tx era -> Set (WitVKey 'Witness (Crypto era)) -> Tx era
data AdaPots
AdaPots :: Coin -> Coin -> Coin -> Coin -> Coin -> Coin -> AdaPots
[treasuryAdaPot] :: AdaPots -> Coin
[reservesAdaPot] :: AdaPots -> Coin
[rewardsAdaPot] :: AdaPots -> Coin
[utxoAdaPot] :: AdaPots -> Coin
[depositsAdaPot] :: AdaPots -> Coin
[feesAdaPot] :: AdaPots -> Coin

-- | Calculate the total ada in the epoch state
totalAdaES :: UsesValue era => EpochState era -> Coin

-- | Calculate the total ada pots in the epoch state
totalAdaPotsES :: UsesValue era => EpochState era -> AdaPots
instance GHC.Generics.Generic Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance GHC.Show.Show Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance GHC.Classes.Eq Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance GHC.Generics.Generic Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance GHC.Show.Show Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance GHC.Classes.Eq Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Cardano.Ledger.Crypto.Crypto c => Cardano.Ledger.Shelley.API.Wallet.CLI (Cardano.Ledger.Shelley.ShelleyEra c)
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.API.Wallet.RewardParams
instance NoThunks.Class.NoThunks Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance Control.DeepSeq.NFData Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Shelley.API.Wallet.RewardInfoPool

module Cardano.Ledger.Shelley.API.Types
hashVerKeyVRF :: (VRFAlgorithm v, HashAlgorithm h) => VerKeyVRF v -> Hash h (VerKeyVRF v)
data StrictMaybe a
SNothing :: StrictMaybe a
SJust :: !a -> StrictMaybe a
bbody :: Block h era -> TxSeq era
bheader :: Block h era -> h
data Block h era
Block' :: !h -> !TxSeq era -> ByteString -> Block h era

-- | Access a block without its serialised bytes. This is often useful when
--   we're using a <tt>BHeaderView</tt> in place of the concrete header.
pattern UnserialisedBlock :: h -> TxSeq era -> Block h era

-- | Unsafely construct a block without the ability to serialise its bytes.
--   
--   Anyone calling this pattern must ensure that the resulting block is
--   never serialised. Any uses of this pattern outside of testing code
--   should be regarded with suspicion.
pattern UnsafeUnserialisedBlock :: h -> TxSeq era -> Block h era
pattern Block :: (Era era, ToCBORGroup (TxSeq era), ToCBOR h) => h -> TxSeq era -> Block h era

-- | A unique ID of a transaction, which is computable from the
--   transaction.
newtype TxId crypto
TxId :: SafeHash crypto EraIndependentTxBody -> TxId crypto
[_unTxId] :: TxId crypto -> SafeHash crypto EraIndependentTxBody

-- | The input of a UTxO.
data TxIn crypto
TxIn :: !TxId crypto -> {-# UNPACK #-} !TxIx -> TxIn crypto

-- | An address for UTxO.
--   
--   Contents of Addr data type are intentionally left as lazy, otherwise
--   operating on compact form of an address will result in redundant work.
data Addr crypto
Addr :: Network -> PaymentCredential crypto -> StakeReference crypto -> Addr crypto
AddrBootstrap :: BootstrapAddress crypto -> Addr crypto

-- | An account based address for rewards
data RewardAcnt crypto
RewardAcnt :: !Network -> !Credential 'Staking crypto -> RewardAcnt crypto
[getRwdNetwork] :: RewardAcnt crypto -> !Network
[getRwdCred] :: RewardAcnt crypto -> !Credential 'Staking crypto

-- | Determine if the given slot is reserved for the overlay schedule.
isOverlaySlot :: SlotNo -> UnitInterval -> SlotNo -> Bool

-- | Script hash or key hash for a payment or a staking object.
--   
--   Note that credentials (unlike raw key hashes) do appear to vary from
--   era to era, since they reference the hash of a script, which can
--   change. This parameter is a phantom, however, so in actuality the
--   instances will remain the same.
data Credential (kr :: KeyRole) crypto
ScriptHashObj :: !ScriptHash crypto -> Credential (kr :: KeyRole) crypto
KeyHashObj :: !KeyHash kr crypto -> Credential (kr :: KeyRole) crypto
data StakeReference crypto
StakeRefBase :: !StakeCredential crypto -> StakeReference crypto
StakeRefPtr :: !Ptr -> StakeReference crypto
StakeRefNull :: StakeReference crypto

-- | Pointer to a slot number, transaction index and an index in
--   certificate list.
data Ptr
Ptr :: !SlotNo -> !TxIx -> !CertIx -> Ptr
certIxFromIntegral :: Integral a => a -> Maybe CertIx
certIxToInt :: CertIx -> Int
txIxFromIntegral :: Integral a => a -> Maybe TxIx
txIxToInt :: TxIx -> Int
data ProtVer
ProtVer :: !Natural -> !Natural -> ProtVer
[pvMajor] :: ProtVer -> !Natural
[pvMinor] :: ProtVer -> !Natural

-- | Evolving nonce type.
data Nonce
Nonce :: !Hash Blake2b_256 Nonce -> Nonce

-- | Identity element
NeutralNonce :: Nonce
newtype Port
Port :: Word16 -> Port
[portToWord16] :: Port -> Word16
data Globals
Globals :: !EpochInfo (Either Text) -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Natural -> !Word64 -> !ActiveSlotCoeff -> !Network -> !SystemStart -> Globals
[epochInfo] :: Globals -> !EpochInfo (Either Text)
[slotsPerKESPeriod] :: Globals -> !Word64

-- | The window size in which our chosen chain growth property guarantees
--   at least k blocks. From the paper "Ouroboros praos: An
--   adaptively-secure, semi-synchronous proof-of-stake protocol". The
--   <a>stabilityWindow</a> constant is used in a number of places; for
--   example, protocol updates must be submitted at least twice this many
--   slots before an epoch boundary.
[stabilityWindow] :: Globals -> !Word64

-- | Number of slots before the end of the epoch at which we stop updating
--   the candidate nonce for the next epoch.
[randomnessStabilisationWindow] :: Globals -> !Word64

-- | Maximum number of blocks we are allowed to roll back
[securityParameter] :: Globals -> !Word64

-- | Maximum number of KES iterations
[maxKESEvo] :: Globals -> !Word64

-- | Quorum for update system votes and MIR certificates
[quorum] :: Globals -> !Word64

-- | All blocks invalid after this protocol version
[maxMajorPV] :: Globals -> !Natural

-- | Maximum number of lovelace in the system
[maxLovelaceSupply] :: Globals -> !Word64

-- | Active Slot Coefficient, named f in "Ouroboros Praos: An
--   adaptively-secure, semi-synchronous proof-of-stake protocol"
[activeSlotCoeff] :: Globals -> !ActiveSlotCoeff

-- | The network ID
[networkId] :: Globals -> !Network

-- | System start time
[systemStart] :: Globals -> !SystemStart
data Network
Testnet :: Network
Mainnet :: Network

-- | Transaction index.
data TxIx

-- | Certificate index. Use <a>certIxFromIntegral</a> in order to construct
--   this index safely from anything other than <a>Word16</a>. There is
--   also <a>mkCertIxPartial</a> that can be used for testing.
data CertIx
individualPoolStake :: IndividualPoolStake crypto -> Rational

-- | A map of stake pool IDs (the hash of the stake pool operator's
--   verification key) to <a>IndividualPoolStake</a>.
newtype PoolDistr crypto
PoolDistr :: Map (KeyHash 'StakePool crypto) (IndividualPoolStake crypto) -> PoolDistr crypto
[unPoolDistr] :: PoolDistr crypto -> Map (KeyHash 'StakePool crypto) (IndividualPoolStake crypto)

-- | Hash a given public key
hashKey :: forall crypto (kd :: KeyRole). Crypto crypto => VKey kd crypto -> KeyHash kd crypto

-- | The role of a key.
--   
--   Note that a role is not _fixed_, nor is it unique. In particular, keys
--   may variously be used as witnesses, and so in many case we will change
--   the role of a key to the <a>Witness</a> role.
--   
--   It is also perfectly allowable for a key to be used in many roles;
--   there is nothing prohibiting somebody using the same underlying key as
--   their payment and staking key, as well as the key for their stake
--   pool. So these roles are more intended for two purposes:
--   
--   <ul>
--   <li>To make explicit how we are using a key in the specifications</li>
--   <li>To provide a guide to downstream implementors, for whom the
--   profusion of keys may be confusing.</li>
--   </ul>
data KeyRole
Genesis :: KeyRole
GenesisDelegate :: KeyRole
Payment :: KeyRole
Staking :: KeyRole
StakePool :: KeyRole
BlockIssuer :: KeyRole
Witness :: KeyRole

-- | General coercion of key roles.
--   
--   The presence of this function is mostly to help the user realise where
--   they are converting key roles.
coerceKeyRole :: forall (r :: KeyRole) crypto (r' :: KeyRole). HasKeyRole a => a r crypto -> a r' crypto

-- | Discriminated verification key
--   
--   We wrap the basic <tt>VerKeyDSIGN</tt> in order to add the key role.
newtype VKey (kd :: KeyRole) crypto
VKey :: VerKeyDSIGN (DSIGN crypto) -> VKey (kd :: KeyRole) crypto
[unVKey] :: VKey (kd :: KeyRole) crypto -> VerKeyDSIGN (DSIGN crypto)

-- | Pair of signing key and verification key, with a usage role.
data KeyPair (kd :: KeyRole) crypto
KeyPair :: !VKey kd crypto -> !SignKeyDSIGN (DSIGN crypto) -> KeyPair (kd :: KeyRole) crypto
[vKey] :: KeyPair (kd :: KeyRole) crypto -> !VKey kd crypto
[sKey] :: KeyPair (kd :: KeyRole) crypto -> !SignKeyDSIGN (DSIGN crypto)

-- | Discriminated hash of public Key
newtype KeyHash (discriminator :: KeyRole) crypto
KeyHash :: Hash (ADDRHASH crypto) (VerKeyDSIGN (DSIGN crypto)) -> KeyHash (discriminator :: KeyRole) crypto
type KESignable c = Signable KES c
data GenDelegPair crypto
GenDelegPair :: !KeyHash 'GenesisDelegate crypto -> !Hash crypto (VerKeyVRF crypto) -> GenDelegPair crypto
[genDelegKeyHash] :: GenDelegPair crypto -> !KeyHash 'GenesisDelegate crypto
[genDelegVrfHash] :: GenDelegPair crypto -> !Hash crypto (VerKeyVRF crypto)
newtype GenDelegs crypto
GenDelegs :: Map (KeyHash 'Genesis crypto) (GenDelegPair crypto) -> GenDelegs crypto
[unGenDelegs] :: GenDelegs crypto -> Map (KeyHash 'Genesis crypto) (GenDelegPair crypto)
type Hash c = Hash HASH c
type SignedDSIGN c = SignedDSIGN DSIGN c
type SignKeyDSIGN c = SignKeyDSIGN DSIGN c
type SignedKES c = SignedKES KES c
type SignKeyKES c = SignKeyKES KES c
type VerKeyKES c = VerKeyKES KES c
type CertifiedVRF c = CertifiedVRF VRF c
type SignKeyVRF c = SignKeyVRF VRF c
type VerKeyVRF c = VerKeyVRF VRF c
newtype ScriptHash crypto
ScriptHash :: Hash (ADDRHASH crypto) EraIndependentScript -> ScriptHash crypto
word64ToCoin :: Word64 -> Coin

-- | The amount of value held by a transaction output.
newtype Coin
Coin :: Integer -> Coin
[unCoin] :: Coin -> Integer
data BootstrapWitness crypto
pattern BootstrapWitness :: Crypto crypto => VKey 'Witness crypto -> SignedDSIGN crypto (Hash crypto EraIndependentTxBody) -> ChainCode -> ByteString -> BootstrapWitness crypto
data Metadata era
pattern Metadata :: Map Word64 Metadatum -> Metadata era

-- | A generic metadatum type.
data Metadatum
Map :: ![(Metadatum, Metadatum)] -> Metadatum
List :: ![Metadatum] -> Metadatum
I :: !Integer -> Metadatum
B :: !ByteString -> Metadatum
S :: !Text -> Metadatum

-- | Update operation for protocol parameters structure @PParams
newtype ProposedPPUpdates era
ProposedPPUpdates :: Map (KeyHash 'Genesis (Crypto era)) (PParamsDelta era) -> ProposedPPUpdates era

-- | Update Proposal
data Update era
Update :: !ProposedPPUpdates era -> !EpochNo -> Update era
type PParams era = PParams' Identity era

-- | Protocol parameters.
--   
--   We use the HKD type family so that the protocol parameters type and
--   the type for the updates to the protocol parameters can share records
--   fields. The protocol parameters will have type <a>PParams'</a>
--   <a>Identity</a>, and the updates will have type <a>PParams'</a>
--   <a>StrictMaybe</a>, though <a>Identity</a> will be hidden from use.
--   
--   For example:
--   
--   <pre>
--   myParameters =
--     PParams
--       { _minfeeA = 0,
--         _minfeeB = 0,
--         ...
--       }
--   
--   myUpdate =
--     PParamsUpdate
--       { _minfeeA = SNothing,
--         _minfeeB = SJust 42,
--         ...
--       }
--   </pre>
data PParams' f era
PParams :: !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Natural -> !HKD f Coin -> !HKD f Coin -> !HKD f EpochNo -> !HKD f Natural -> !HKD f NonNegativeInterval -> !HKD f UnitInterval -> !HKD f UnitInterval -> !HKD f UnitInterval -> !HKD f Nonce -> !HKD f ProtVer -> !HKD f Coin -> !HKD f Coin -> PParams' f era

-- | The linear factor for the minimum fee calculation
[_minfeeA] :: PParams' f era -> !HKD f Natural

-- | The constant factor for the minimum fee calculation
[_minfeeB] :: PParams' f era -> !HKD f Natural

-- | Maximal block body size
[_maxBBSize] :: PParams' f era -> !HKD f Natural

-- | Maximal transaction size
[_maxTxSize] :: PParams' f era -> !HKD f Natural

-- | Maximal block header size
[_maxBHSize] :: PParams' f era -> !HKD f Natural

-- | The amount of a key registration deposit
[_keyDeposit] :: PParams' f era -> !HKD f Coin

-- | The amount of a pool registration deposit
[_poolDeposit] :: PParams' f era -> !HKD f Coin

-- | epoch bound on pool retirement
[_eMax] :: PParams' f era -> !HKD f EpochNo

-- | Desired number of pools
[_nOpt] :: PParams' f era -> !HKD f Natural

-- | Pool influence
[_a0] :: PParams' f era -> !HKD f NonNegativeInterval

-- | Monetary expansion
[_rho] :: PParams' f era -> !HKD f UnitInterval

-- | Treasury expansion
[_tau] :: PParams' f era -> !HKD f UnitInterval

-- | Decentralization parameter
[_d] :: PParams' f era -> !HKD f UnitInterval

-- | Extra entropy
[_extraEntropy] :: PParams' f era -> !HKD f Nonce

-- | Protocol version
[_protocolVersion] :: PParams' f era -> !HKD f ProtVer

-- | Minimum UTxO value
[_minUTxOValue] :: PParams' f era -> !HKD f Coin

-- | Minimum Stake Pool Cost
[_minPoolCost] :: PParams' f era -> !HKD f Coin
data MultiSig crypto
pattern RequireMOf :: Crypto crypto => Int -> [MultiSig crypto] -> MultiSig crypto
pattern RequireSignature :: Crypto crypto => KeyHash 'Witness crypto -> MultiSig crypto
pattern RequireAllOf :: Crypto crypto => [MultiSig crypto] -> MultiSig crypto
pattern RequireAnyOf :: Crypto crypto => [MultiSig crypto] -> MultiSig crypto

-- | Calculate the stability window (e.g. the number of slots needed for a
--   block to become stable) from the security param and the active slot
--   coefficient.
--   
--   The value 3k/f is determined to be a suitabe value as per
--   <a>https://docs.google.com/document/d/1B8BNMx8jVWRjYiUBOaI3jfZ7dQNvNTSDODvT5iOuYCU/edit#heading=h.qh2zcajmu6hm</a>
computeStabilityWindow :: Word64 -> ActiveSlotCoeff -> Word64

-- | Calculate the randomness stabilisation window from the security param
--   and the active slot coefficient.
--   
--   The value 4k/f is determined to be a suitabe value as per
--   <a>https://docs.google.com/document/d/1B8BNMx8jVWRjYiUBOaI3jfZ7dQNvNTSDODvT5iOuYCU/edit#heading=h.qh2zcajmu6hm</a>
computeRandomnessStabilisationWindow :: Word64 -> ActiveSlotCoeff -> Word64
newtype StakeCreds crypto
StakeCreds :: Map (Credential 'Staking crypto) SlotNo -> StakeCreds crypto
[unStakeCreds] :: StakeCreds crypto -> Map (Credential 'Staking crypto) SlotNo

-- | Proof/Witness that a transaction is authorized by the given key
--   holder.
data WitVKey kr crypto
pattern WitVKey :: (Typeable kr, Crypto crypto) => VKey kr crypto -> SignedDSIGN crypto (Hash crypto EraIndependentTxBody) -> WitVKey kr crypto
newtype TxBody era
TxBodyConstr :: MemoBytes (TxBodyRaw era) -> TxBody era

-- | Pattern for use by external users
pattern TxBody :: (Era era, FromCBOR (PParamsDelta era), TransTxBody ToCBOR era) => Set (TxIn (Crypto era)) -> StrictSeq (TxOut era) -> StrictSeq (DCert (Crypto era)) -> Wdrl (Crypto era) -> Coin -> SlotNo -> StrictMaybe (Update era) -> StrictMaybe (AuxiliaryDataHash (Crypto era)) -> TxBody era

-- | A heavyweight certificate.
data DCert crypto
DCertDeleg :: !DelegCert crypto -> DCert crypto
DCertPool :: !PoolCert crypto -> DCert crypto
DCertGenesis :: !GenesisDelegCert crypto -> DCert crypto
DCertMir :: !MIRCert crypto -> DCert crypto

-- | Move instantaneous rewards certificate
data MIRCert crypto
MIRCert :: MIRPot -> MIRTarget crypto -> MIRCert crypto
[mirPot] :: MIRCert crypto -> MIRPot
[mirRewards] :: MIRCert crypto -> MIRTarget crypto

-- | MIRTarget specifies if funds from either the reserves or the treasury
--   are to be handed out to a collection of reward accounts or instead
--   transfered to the opposite pot.
data MIRTarget crypto
StakeAddressesMIR :: Map (Credential 'Staking crypto) DeltaCoin -> MIRTarget crypto
SendToOppositePotMIR :: Coin -> MIRTarget crypto
data MIRPot
ReservesMIR :: MIRPot
TreasuryMIR :: MIRPot

-- | Genesis key delegation certificate
data GenesisDelegCert crypto
GenesisDelegCert :: !KeyHash 'Genesis crypto -> !KeyHash 'GenesisDelegate crypto -> !Hash crypto (VerKeyVRF crypto) -> GenesisDelegCert crypto
data PoolCert crypto

-- | A stake pool registration certificate.
RegPool :: !PoolParams crypto -> PoolCert crypto

-- | A stake pool retirement certificate.
RetirePool :: !KeyHash 'StakePool crypto -> !EpochNo -> PoolCert crypto
data DelegCert crypto

-- | A stake key registration certificate.
RegKey :: !StakeCredential crypto -> DelegCert crypto

-- | A stake key deregistration certificate.
DeRegKey :: !StakeCredential crypto -> DelegCert crypto

-- | A stake delegation certificate.
Delegate :: !Delegation crypto -> DelegCert crypto

-- | The output of a UTxO.
data TxOut era
TxOutCompact :: {-# UNPACK #-} !CompactAddr (Crypto era) -> !CompactForm (Value era) -> TxOut era
pattern TxOut :: (Era era, Show (Value era), Compactible (Value era)) => Addr (Crypto era) -> Value era -> TxOut era
newtype Wdrl crypto
Wdrl :: Map (RewardAcnt crypto) Coin -> Wdrl crypto
[unWdrl] :: Wdrl crypto -> Map (RewardAcnt crypto) Coin

-- | A stake pool.
data PoolParams crypto
PoolParams :: !KeyHash 'StakePool crypto -> !Hash crypto (VerKeyVRF crypto) -> !Coin -> !Coin -> !UnitInterval -> !RewardAcnt crypto -> !Set (KeyHash 'Staking crypto) -> !StrictSeq StakePoolRelay -> !StrictMaybe PoolMetadata -> PoolParams crypto
[_poolId] :: PoolParams crypto -> !KeyHash 'StakePool crypto
[_poolVrf] :: PoolParams crypto -> !Hash crypto (VerKeyVRF crypto)
[_poolPledge] :: PoolParams crypto -> !Coin
[_poolCost] :: PoolParams crypto -> !Coin
[_poolMargin] :: PoolParams crypto -> !UnitInterval
[_poolRAcnt] :: PoolParams crypto -> !RewardAcnt crypto
[_poolOwners] :: PoolParams crypto -> !Set (KeyHash 'Staking crypto)
[_poolRelays] :: PoolParams crypto -> !StrictSeq StakePoolRelay
[_poolMD] :: PoolParams crypto -> !StrictMaybe PoolMetadata
data StakePoolRelay

-- | One or both of IPv4 &amp; IPv6
SingleHostAddr :: !StrictMaybe Port -> !StrictMaybe IPv4 -> !StrictMaybe IPv6 -> StakePoolRelay

-- | An <tt>A</tt> or <tt>AAAA</tt> DNS record
SingleHostName :: !StrictMaybe Port -> !DnsName -> StakePoolRelay

-- | A <tt>SRV</tt> DNS record
MultiHostName :: !DnsName -> StakePoolRelay
data PoolMetadata
PoolMetadata :: !Url -> !ByteString -> PoolMetadata
[_poolMDUrl] :: PoolMetadata -> !Url
[_poolMDHash] :: PoolMetadata -> !ByteString

-- | The delegation of one stake key to another.
data Delegation crypto
Delegation :: !StakeCredential crypto -> !KeyHash 'StakePool crypto -> Delegation crypto
[_delegator] :: Delegation crypto -> !StakeCredential crypto
[_delegatee] :: Delegation crypto -> !KeyHash 'StakePool crypto
type WitnessSet = WitnessSetHKD Identity
data Tx era
pattern Tx :: (Era era, ToCBOR (AuxiliaryData era), ToCBOR (TxBody era), ToCBOR (Witnesses era)) => TxBody era -> Witnesses era -> StrictMaybe (AuxiliaryData era) -> Tx era

-- | Hash a given block body
bbHash :: forall era. Era era => TxSeq era -> Hash (Crypto era) EraIndependentBlockBody

-- | Snapshots of the stake distribution.
data SnapShots crypto
SnapShots :: SnapShot crypto -> !SnapShot crypto -> !SnapShot crypto -> !Coin -> SnapShots crypto
[$sel:_pstakeMark:SnapShots] :: SnapShots crypto -> SnapShot crypto
[$sel:_pstakeSet:SnapShots] :: SnapShots crypto -> !SnapShot crypto
[$sel:_pstakeGo:SnapShots] :: SnapShots crypto -> !SnapShot crypto
[$sel:_feeSS:SnapShots] :: SnapShots crypto -> !Coin

-- | Snapshot of the stake distribution.
data SnapShot crypto
SnapShot :: !Stake crypto -> !VMap VB VB (Credential 'Staking crypto) (KeyHash 'StakePool crypto) -> !VMap VB VB (KeyHash 'StakePool crypto) (PoolParams crypto) -> SnapShot crypto
[$sel:_stake:SnapShot] :: SnapShot crypto -> !Stake crypto
[$sel:_delegations:SnapShot] :: SnapShot crypto -> !VMap VB VB (Credential 'Staking crypto) (KeyHash 'StakePool crypto)
[$sel:_poolParams:SnapShot] :: SnapShot crypto -> !VMap VB VB (KeyHash 'StakePool crypto) (PoolParams crypto)

-- | Type of stake as map from hash key to coins associated.
newtype Stake crypto
Stake :: VMap VB VP (Credential 'Staking crypto) (CompactForm Coin) -> Stake crypto
[$sel:unStake:Stake] :: Stake crypto -> VMap VB VP (Credential 'Staking crypto) (CompactForm Coin)
data NonMyopic crypto

-- | The ultiate goal of a reward update computation. Aggregating rewards
--   for each staking credential.
data RewardUpdate crypto
RewardUpdate :: !DeltaCoin -> !DeltaCoin -> !Map (Credential 'Staking crypto) (Set (Reward crypto)) -> !DeltaCoin -> !NonMyopic crypto -> RewardUpdate crypto
[deltaT] :: RewardUpdate crypto -> !DeltaCoin
[deltaR] :: RewardUpdate crypto -> !DeltaCoin
[rs] :: RewardUpdate crypto -> !Map (Credential 'Staking crypto) (Set (Reward crypto))
[deltaF] :: RewardUpdate crypto -> !DeltaCoin
[nonMyopic] :: RewardUpdate crypto -> !NonMyopic crypto

-- | The unspent transaction outputs.
newtype UTxO era
UTxO :: Map (TxIn (Crypto era)) (TxOut era) -> UTxO era
[unUTxO] :: UTxO era -> Map (TxIn (Crypto era)) (TxOut era)

-- | Determine the total balance contained in the UTxO.
balance :: forall era. Era era => UTxO era -> Value era
newtype WitHashes crypto
WitHashes :: Set (KeyHash 'Witness crypto) -> WitHashes crypto
[unWitHashes] :: WitHashes crypto -> Set (KeyHash 'Witness crypto)

-- | The state associated with a <tt>Ledger</tt>.
data LedgerState era
LedgerState :: !UTxOState era -> !DPState (Crypto era) -> LedgerState era

-- | The current unspent transaction outputs.
[lsUTxOState] :: LedgerState era -> !UTxOState era

-- | The current delegation state
[lsDPState] :: LedgerState era -> !DPState (Crypto era)

-- | New Epoch state and environment
data NewEpochState era
NewEpochState :: !EpochNo -> !BlocksMade (Crypto era) -> !BlocksMade (Crypto era) -> !EpochState era -> !StrictMaybe (PulsingRewUpdate (Crypto era)) -> !PoolDistr (Crypto era) -> !StashedAVVMAddresses era -> NewEpochState era

-- | Last epoch
[nesEL] :: NewEpochState era -> !EpochNo

-- | Blocks made before current epoch
[nesBprev] :: NewEpochState era -> !BlocksMade (Crypto era)

-- | Blocks made in current epoch
[nesBcur] :: NewEpochState era -> !BlocksMade (Crypto era)

-- | Epoch state before current
[nesEs] :: NewEpochState era -> !EpochState era

-- | Possible reward update
[nesRu] :: NewEpochState era -> !StrictMaybe (PulsingRewUpdate (Crypto era))

-- | Stake distribution within the stake pool
[nesPd] :: NewEpochState era -> !PoolDistr (Crypto era)

-- | AVVM addresses to be removed at the end of the Shelley era. Note that
--   the existence of this field is a hack, related to the transition of
--   UTxO to disk. We remove AVVM addresses from the UTxO on the
--   Shelley/Allegra boundary. However, by this point the UTxO will be
--   moved to disk, and hence doing a scan of the UTxO for AVVM addresses
--   will be expensive. Our solution to this is to do a scan of the UTxO on
--   the Byron/Shelley boundary (since Byron UTxO are still on disk), stash
--   the results here, and then remove them at the Shelley/Allegra
--   boundary.
--   
--   This is very much an awkward implementation hack, and hence we hide it
--   from as many places as possible.
[stashedAVVMAddresses] :: NewEpochState era -> !StashedAVVMAddresses era

-- | There is a serious invariant that we must maintain in the UTxOState.
--   Given (UTxOState utxo _ _ _ istake) it must be the case that istake ==
--   (updateStakeDistribution (UTxO Map.empty) (UTxO Map.empty) utxo) Of
--   course computing the RHS of the above equality can be very expensive,
--   so we only use this route in the testing function smartUTxO. But we
--   are very carefull, wherever we update the UTxO, we carefully make
--   INCREMENTAL changes to istake to maintain this invariant. This happens
--   in the UTxO rule.
data UTxOState era
UTxOState :: !UTxO era -> !Coin -> !Coin -> !State (EraRule "PPUP" era) -> !IncrementalStake (Crypto era) -> UTxOState era
[_utxo] :: UTxOState era -> !UTxO era
[_deposited] :: UTxOState era -> !Coin
[_fees] :: UTxOState era -> !Coin
[_ppups] :: UTxOState era -> !State (EraRule "PPUP" era)
[_stakeDistro] :: UTxOState era -> !IncrementalStake (Crypto era)

-- | Incremental Stake, Stake along with possible missed coins from danging
--   Ptrs. Transactions can use Ptrs to refer to a stake credential in a
--   TxOut. The Ptr does not have to point to anything until the epoch
--   boundary, when we compute rewards and aggregate staking information
--   for ranking. This is unusual but legal. In a non incremental system,
--   we use whatever <tt>legal</tt> Ptrs exist at the epoch boundary. Here
--   we are computing things incrementally, so we need to remember Ptrs
--   that might point to something by the time the epoch boundary is
--   reached. When the epoch boundary is reached we <tt>resolve</tt> these
--   pointers, to see if any have become non-dangling since the time they
--   were first used in the incremental computation.
data IncrementalStake crypto
IStake :: !Map (Credential 'Staking crypto) Coin -> !Map Ptr Coin -> IncrementalStake crypto
[credMap] :: IncrementalStake crypto -> !Map (Credential 'Staking crypto) Coin
[ptrMap] :: IncrementalStake crypto -> !Map Ptr Coin
data PPUPState era
PPUPState :: !ProposedPPUpdates era -> !ProposedPPUpdates era -> PPUPState era
[proposals] :: PPUPState era -> !ProposedPPUpdates era
[futureProposals] :: PPUPState era -> !ProposedPPUpdates era
data EpochState era
EpochState :: !AccountState -> !SnapShots (Crypto era) -> !LedgerState era -> !PParams era -> !PParams era -> !NonMyopic (Crypto era) -> EpochState era
[esAccountState] :: EpochState era -> !AccountState
[esSnapshots] :: EpochState era -> !SnapShots (Crypto era)
[esLState] :: EpochState era -> !LedgerState era
[esPrevPp] :: EpochState era -> !PParams era
[esPp] :: EpochState era -> !PParams era

-- | This field, esNonMyopic, does not appear in the formal spec and is not
--   a part of the protocol. It is only used for providing data to the
--   stake pool ranking calculation <tt>getNonMyopicMemberRewards</tt>. See
--   <a>https://hydra.iohk.io/job/Cardano/cardano-ledger/specs.pool-ranking/latest/download-by-type/doc-pdf/pool-ranking</a>
[esNonMyopic] :: EpochState era -> !NonMyopic (Crypto era)
data AccountState
AccountState :: !Coin -> !Coin -> AccountState
[_treasury] :: AccountState -> !Coin
[_reserves] :: AccountState -> !Coin

-- | The state associated with the current stake delegation.
data DPState crypto
DPState :: !DState crypto -> !PState crypto -> DPState crypto
[dpsDState] :: DPState crypto -> !DState crypto
[dpsPState] :: DPState crypto -> !PState crypto

-- | Current state of staking pools and their certificate counters.
data PState crypto
PState :: !Map (KeyHash 'StakePool crypto) (PoolParams crypto) -> !Map (KeyHash 'StakePool crypto) (PoolParams crypto) -> !Map (KeyHash 'StakePool crypto) EpochNo -> PState crypto

-- | The pool parameters.
[_pParams] :: PState crypto -> !Map (KeyHash 'StakePool crypto) (PoolParams crypto)

-- | The future pool parameters.
[_fPParams] :: PState crypto -> !Map (KeyHash 'StakePool crypto) (PoolParams crypto)

-- | A map of retiring stake pools to the epoch when they retire.
[_retiring] :: PState crypto -> !Map (KeyHash 'StakePool crypto) EpochNo

-- | State of staking pool delegations and rewards
data DState crypto
DState :: !UnifiedMap crypto -> !Map (FutureGenDeleg crypto) (GenDelegPair crypto) -> !GenDelegs crypto -> !InstantaneousRewards crypto -> DState crypto

-- | Unified Reward Maps
[_unified] :: DState crypto -> !UnifiedMap crypto

-- | Future genesis key delegations
[_fGenDelegs] :: DState crypto -> !Map (FutureGenDeleg crypto) (GenDelegPair crypto)

-- | Genesis key delegations
[_genDelegs] :: DState crypto -> !GenDelegs crypto

-- | Instantaneous Rewards
[_irwd] :: DState crypto -> !InstantaneousRewards crypto

-- | InstantaneousRewards captures the pending changes to the ledger state
--   caused by MIR certificates. It consists of two mappings, the rewards
--   which will be paid out from the reserves and the rewards which will be
--   paid out from the treasury. It also consists of two coin values which
--   represent the transfer of coins from one pot to the other pot. NOTE
--   that the following property should always hold: deltaReserves +
--   deltaTreasury = 0
data InstantaneousRewards crypto
InstantaneousRewards :: !Map (Credential 'Staking crypto) Coin -> !Map (Credential 'Staking crypto) Coin -> !DeltaCoin -> !DeltaCoin -> InstantaneousRewards crypto
[iRReserves] :: InstantaneousRewards crypto -> !Map (Credential 'Staking crypto) Coin
[iRTreasury] :: InstantaneousRewards crypto -> !Map (Credential 'Staking crypto) Coin
[deltaReserves] :: InstantaneousRewards crypto -> !DeltaCoin
[deltaTreasury] :: InstantaneousRewards crypto -> !DeltaCoin

-- | Representation of a list of pairs of key pairs, e.g., pay and stake
--   keys
type KeyPairs crypto = [(KeyPair 'Payment crypto, KeyPair 'Staking crypto)]
data PPUPEnv era
PPUPEnv :: SlotNo -> PParams era -> GenDelegs (Crypto era) -> PPUPEnv era
data PPUP era
data UtxoEnv era
UtxoEnv :: SlotNo -> PParams era -> Map (KeyHash 'StakePool (Crypto era)) (PoolParams (Crypto era)) -> GenDelegs (Crypto era) -> UtxoEnv era
data UTXO era
data UTXOW era
data POOLREAP era
data PoolEnv era
PoolEnv :: SlotNo -> PParams era -> PoolEnv era
data POOL (era :: Type)
data DelegEnv era
DelegEnv :: SlotNo -> Ptr -> AccountState -> PParams era -> DelegEnv era
[slotNo] :: DelegEnv era -> SlotNo
[ptr_] :: DelegEnv era -> Ptr
[acnt_] :: DelegEnv era -> AccountState
[ppDE] :: DelegEnv era -> PParams era
data DELEG era
data DelplEnv era
DelplEnv :: SlotNo -> Ptr -> PParams era -> AccountState -> DelplEnv era
[delplSlotNo] :: DelplEnv era -> SlotNo
[delPlPtr] :: DelplEnv era -> Ptr
[delPlPp] :: DelplEnv era -> PParams era
[delPlAcnt] :: DelplEnv era -> AccountState
data DELPL era
data DelegsEnv era
DelegsEnv :: !SlotNo -> !TxIx -> !PParams era -> !Tx era -> !AccountState -> DelegsEnv era
[delegsSlotNo] :: DelegsEnv era -> !SlotNo
[delegsIx] :: DelegsEnv era -> !TxIx
[delegspp] :: DelegsEnv era -> !PParams era
[delegsTx] :: DelegsEnv era -> !Tx era
[delegsAccount] :: DelegsEnv era -> !AccountState
data DELEGS era
data LedgerEnv era
LedgerEnv :: !SlotNo -> !TxIx -> !PParams era -> !AccountState -> LedgerEnv era
[ledgerSlotNo] :: LedgerEnv era -> !SlotNo
[ledgerIx] :: LedgerEnv era -> !TxIx
[ledgerPp] :: LedgerEnv era -> !PParams era
[ledgerAccount] :: LedgerEnv era -> !AccountState
data LEDGER era
data LedgersEnv era
LedgersEnv :: SlotNo -> PParams era -> AccountState -> LedgersEnv era
[ledgersSlotNo] :: LedgersEnv era -> SlotNo
[ledgersPp] :: LedgersEnv era -> PParams era
[ledgersAccount] :: LedgersEnv era -> AccountState
data LEDGERS era
data ValidationErr
EpochNotLongEnough :: EpochSize -> Word64 -> Rational -> EpochSize -> ValidationErr
MaxKESEvolutionsUnsupported :: Word64 -> Word -> ValidationErr
QuorumTooSmall :: Word64 -> Word64 -> Word64 -> ValidationErr

-- | Shelley genesis information
--   
--   Note that this is needed only for a pure Shelley network, hence it
--   being defined here rather than in its own module. In mainnet, Shelley
--   will transition naturally from Byron, and thus will never have its own
--   genesis information.
data ShelleyGenesis era
ShelleyGenesis :: !UTCTime -> !Word32 -> !Network -> !PositiveUnitInterval -> !Word64 -> !EpochSize -> !Word64 -> !Word64 -> !NominalDiffTime -> !Word64 -> !Word64 -> !PParams era -> !Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era)) -> !Map (Addr (Crypto era)) Coin -> !ShelleyGenesisStaking (Crypto era) -> ShelleyGenesis era
[sgSystemStart] :: ShelleyGenesis era -> !UTCTime
[sgNetworkMagic] :: ShelleyGenesis era -> !Word32
[sgNetworkId] :: ShelleyGenesis era -> !Network
[sgActiveSlotsCoeff] :: ShelleyGenesis era -> !PositiveUnitInterval
[sgSecurityParam] :: ShelleyGenesis era -> !Word64
[sgEpochLength] :: ShelleyGenesis era -> !EpochSize
[sgSlotsPerKESPeriod] :: ShelleyGenesis era -> !Word64
[sgMaxKESEvolutions] :: ShelleyGenesis era -> !Word64
[sgSlotLength] :: ShelleyGenesis era -> !NominalDiffTime
[sgUpdateQuorum] :: ShelleyGenesis era -> !Word64
[sgMaxLovelaceSupply] :: ShelleyGenesis era -> !Word64
[sgProtocolParams] :: ShelleyGenesis era -> !PParams era
[sgGenDelegs] :: ShelleyGenesis era -> !Map (KeyHash 'Genesis (Crypto era)) (GenDelegPair (Crypto era))
[sgInitialFunds] :: ShelleyGenesis era -> !Map (Addr (Crypto era)) Coin
[sgStaking] :: ShelleyGenesis era -> !ShelleyGenesisStaking (Crypto era)

-- | Genesis Shelley staking configuration.
--   
--   This allows us to configure some initial stake pools and delegation to
--   them, in order to test Praos in a static configuration, without
--   requiring on-chain registration and delegation.
--   
--   For simplicity, pools defined in the genesis staking do not pay
--   deposits for their registration.
data ShelleyGenesisStaking crypto
ShelleyGenesisStaking :: !Map (KeyHash 'StakePool crypto) (PoolParams crypto) -> !Map (KeyHash 'Staking crypto) (KeyHash 'StakePool crypto) -> ShelleyGenesisStaking crypto

-- | Pools to register
--   
--   The key in this map is the hash of the public key of the _pool_. This
--   need not correspond to any payment or staking key, but must correspond
--   to the cold key held by <tt>TPraosIsCoreNode</tt>.
[sgsPools] :: ShelleyGenesisStaking crypto -> !Map (KeyHash 'StakePool crypto) (PoolParams crypto)

-- | Stake-holding key hash credentials and the pools to delegate that
--   stake to. We require the raw staking key hash in order to:
--   
--   <ul>
--   <li>Avoid pointer addresses, which would be tricky when there's no
--   slot or transaction to point to.</li>
--   <li>Avoid script credentials.</li>
--   </ul>
[sgsStake] :: ShelleyGenesisStaking crypto -> !Map (KeyHash 'Staking crypto) (KeyHash 'StakePool crypto)

-- | Empty genesis staking
emptyGenesisStaking :: ShelleyGenesisStaking crypto
sgActiveSlotCoeff :: ShelleyGenesis era -> ActiveSlotCoeff
genesisUTxO :: forall era. (Era era, UsesTxOut era) => ShelleyGenesis era -> UTxO era

-- | Compute the <a>TxIn</a> of the initial UTxO pseudo-transaction
--   corresponding to the given address in the genesis initial funds.
--   
--   The Shelley initial UTxO is constructed from the <a>sgInitialFunds</a>
--   which is not a full UTxO but just a map from addresses to coin values.
--   
--   This gets turned into a UTxO by making a pseudo-transaction for each
--   address, with the 0th output being the coin value. So to spend from
--   the initial UTxO we need this same <a>TxIn</a> to use as an input to
--   the spending transaction.
initialFundsPseudoTxIn :: forall crypto. Crypto crypto => Addr crypto -> TxIn crypto
describeValidationErr :: ValidationErr -> Text

-- | Do some basic sanity checking on the Shelley genesis file.
validateGenesis :: forall era. Era era => ShelleyGenesis era -> Either [ValidationErr] ()
mkShelleyGlobals :: ShelleyGenesis era -> EpochInfo (Either Text) -> Natural -> Globals
data NEWEPOCH era
calculatePoolDistr :: SnapShot crypto -> PoolDistr crypto
data TICK era

module Cardano.Ledger.Shelley.API.ByronTranslation
translateToShelleyLedgerState :: forall c. (Crypto c, ADDRHASH c ~ Blake2b_224) => ShelleyGenesis (ShelleyEra c) -> EpochNo -> ChainValidationState -> NewEpochState (ShelleyEra c)
translateCompactTxOutByronToShelley :: CompactTxOut -> TxOut (ShelleyEra c)

-- | We use the same hashing algorithm so we can unwrap and rewrap the
--   bytes. We don't care about the type that is hashed, which will differ
--   going from Byron to Shelley, we just use the hashes as IDs.
translateTxIdByronToShelley :: (Crypto c, ADDRHASH c ~ Blake2b_224) => TxId -> TxId c

module Cardano.Ledger.Shelley.API.Genesis

-- | Indicates that this era may be bootstrapped from
--   <a>ShelleyGenesis</a>.
class CanStartFromGenesis era where {
    
    -- | Additional genesis configuration necessary for this era.
    type family AdditionalGenesisConfig era :: Type;
    type AdditionalGenesisConfig era = ();
}

-- | Construct an initial state given a <a>ShelleyGenesis</a> and any
--   appropriate <a>AdditionalGenesisConfig</a> for the era.
initialState :: CanStartFromGenesis era => ShelleyGenesis era -> AdditionalGenesisConfig era -> NewEpochState era
instance (Cardano.Ledger.Crypto.Crypto c, Data.Default.Class.Default (Control.State.Transition.Extended.State (Cardano.Ledger.Core.EraRule "PPUP" (Cardano.Ledger.Shelley.ShelleyEra c)))) => Cardano.Ledger.Shelley.API.Genesis.CanStartFromGenesis (Cardano.Ledger.Shelley.ShelleyEra c)


-- | API to the Shelley ledger
module Cardano.Ledger.Shelley.API
class (Crypto (Crypto era), ApplyBlock era, ApplyTx era, CanStartFromGenesis era, UsesValue era, UsesScript era, UsesAuxiliary era, UsesTxBody era, UsesTxOut era, UsesPParams era, DSignable (Crypto era) (Hash (Crypto era) EraIndependentTxBody), ChainData (State (EraRule "PPUP" era)), SerialisableData (State (EraRule "PPUP" era)), Share (TxOut era) ~ Interns (Credential 'Staking (Crypto era)), FromSharedCBOR (TxOut era)) => ShelleyBasedEra era
instance (Cardano.Ledger.Crypto.Crypto crypto, Cardano.Ledger.Keys.DSignable crypto (Cardano.Ledger.Keys.Hash crypto Cardano.Ledger.Hashes.EraIndependentTxBody)) => Cardano.Ledger.Shelley.API.ShelleyBasedEra (Cardano.Ledger.Shelley.ShelleyEra crypto)
