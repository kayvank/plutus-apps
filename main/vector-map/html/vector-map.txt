-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An efficient VMap that is backed by two vectors: one for keys and another for values.
--   
--   An efficient VMap that is backed by two vectors: one for keys and
--   another for values.
@package vector-map
@version 0.1.0.0

module Data.VMap

-- | Class of immutable vectors. Every immutable vector is associated with
--   its mutable version through the <a>Mutable</a> type family. Methods of
--   this class should not be used directly. Instead,
--   <a>Data.Vector.Generic</a> and other Data.Vector modules provide safe
--   and fusible wrappers.
--   
--   Minimum complete implementation:
--   
--   <ul>
--   <li><a>basicUnsafeFreeze</a></li>
--   <li><a>basicUnsafeThaw</a></li>
--   <li><a>basicLength</a></li>
--   <li><a>basicUnsafeSlice</a></li>
--   <li><a>basicUnsafeIndexM</a></li>
--   </ul>
class MVector Mutable v a => Vector (v :: Type -> Type) a
type VB = Vector
type VU = Vector
type VP = Vector
type VS = Vector
newtype VMap kv vv k v
VMap :: KVVector kv vv (k, v) -> VMap kv vv k v
[unVMap] :: VMap kv vv k v -> KVVector kv vv (k, v)
empty :: (Vector kv k, Vector vv v) => VMap kv vv k v
size :: Vector kv k => VMap kv vv k v -> Int
lookup :: (Ord k, Vector kv k, Vector vv v) => k -> VMap kv vv k v -> Maybe v
findWithDefault :: (Ord k, Vector kv k, Vector vv v) => v -> k -> VMap kv vv k v -> v
member :: (Ord k, Vector kv k) => k -> VMap kv vv k v -> Bool
notMember :: (Ord k, Vector kv k) => k -> VMap kv vv k v -> Bool
map :: (Vector vv a, Vector vv b) => (a -> b) -> VMap kv vv k a -> VMap kv vv k b
mapMaybe :: (Vector kv k, Vector vv a, Vector vv b) => (a -> Maybe b) -> VMap kv vv k a -> VMap kv vv k b
mapWithKey :: (Vector kv k, Vector vv a, Vector vv b) => (k -> a -> b) -> VMap kv vv k a -> VMap kv vv k b
filter :: (Vector kv k, Vector vv v) => (k -> v -> Bool) -> VMap kv vv k v -> VMap kv vv k v

-- | Fold values monoidally
fold :: (Vector vv m, Monoid m) => VMap kv vv k m -> m
foldl :: Vector vv v => (a -> v -> a) -> a -> VMap kv vv k v -> a
foldlWithKey :: (Vector kv k, Vector vv v) => (a -> k -> v -> a) -> a -> VMap kv vv k v -> a
foldMap :: (Vector vv v, Monoid m) => (v -> m) -> VMap kv vv k v -> m
foldMapWithKey :: (Vector kv k, Vector vv v, Monoid m) => (k -> v -> m) -> VMap kv vv k v -> m
fromMap :: (Vector kv k, Vector vv v) => Map k v -> VMap kv vv k v
toMap :: (Vector kv k, Vector vv v) => VMap kv vv k v -> Map k v
fromList :: (Ord k, Vector kv k, Vector vv v) => [(k, v)] -> VMap kv vv k v
fromListN :: (Ord k, Vector kv k, Vector vv v) => Int -> [(k, v)] -> VMap kv vv k v
toList :: (Vector kv k, Vector vv v) => VMap kv vv k v -> [(k, v)]
toAscList :: (Vector kv k, Vector vv v) => VMap kv vv k v -> [(k, v)]
keys :: Vector kv k => VMap kv vv k v -> [k]
elems :: Vector vv v => VMap kv vv k v -> [v]
fromAscList :: (Eq k, Vector kv k, Vector vv v) => [(k, v)] -> VMap kv vv k v
fromAscListN :: (Eq k, Vector kv k, Vector vv v) => Int -> [(k, v)] -> VMap kv vv k v
fromAscListWithKey :: (Eq k, Vector kv k, Vector vv v) => (k -> v -> v -> v) -> [(k, v)] -> VMap kv vv k v
fromAscListWithKeyN :: (Eq k, Vector kv k, Vector vv v) => Int -> (k -> v -> v -> v) -> [(k, v)] -> VMap kv vv k v
fromDistinctAscList :: (Vector kv k, Vector vv v) => [(k, v)] -> VMap kv vv k v
fromDistinctAscListN :: (Vector kv k, Vector vv v) => Int -> [(k, v)] -> VMap kv vv k v
internMaybe :: (Vector kv k, Ord k) => k -> VMap kv vv k v -> Maybe k
null :: (Vector vv v, Vector kv k) => VMap kv vv k v -> Bool
splitAt :: (Vector vv v, Vector kv k) => Int -> VMap kv vv k v -> (VMap kv vv k v, VMap kv vv k v)
data KVMVector kmv vmv s a
data KVVector kv vv a
normalize :: (Vector kv k, Vector vv v, Ord k) => KVVector kv vv (k, v) -> KVVector kv vv (k, v)
normalizeM :: (Ord k, PrimMonad m, Vector kv k, Vector vv v) => KVMVector (Mutable kv) (Mutable vv) (PrimState m) (k, v) -> m (KVMVector (Mutable kv) (Mutable vv) (PrimState m) (k, v))
instance (Data.Vector.Generic.Base.Vector kv k, Data.Vector.Generic.Base.Vector vv v, GHC.Classes.Ord k) => GHC.Base.Monoid (Data.VMap.VMap kv vv k v)
instance (Data.Vector.Generic.Base.Vector kv k, Data.Vector.Generic.Base.Vector vv v, GHC.Classes.Ord k) => GHC.Base.Semigroup (Data.VMap.VMap kv vv k v)
instance (Control.DeepSeq.NFData (kv k), Control.DeepSeq.NFData (vv v)) => Control.DeepSeq.NFData (Data.VMap.VMap kv vv k v)
instance (Data.Typeable.Internal.Typeable kv, Data.Typeable.Internal.Typeable vv, Cardano.Binary.FromCBOR.FromCBOR k, Cardano.Binary.FromCBOR.FromCBOR v, GHC.Classes.Ord k, Data.Vector.Generic.Base.Vector kv k, Data.Vector.Generic.Base.Vector vv v) => Cardano.Binary.FromCBOR.FromCBOR (Data.VMap.VMap kv vv k v)
instance (Data.Typeable.Internal.Typeable kv, Data.Typeable.Internal.Typeable vv, Cardano.Binary.ToCBOR.ToCBOR k, Cardano.Binary.ToCBOR.ToCBOR v, GHC.Classes.Ord k, Data.Vector.Generic.Base.Vector kv k, Data.Vector.Generic.Base.Vector vv v) => Cardano.Binary.ToCBOR.ToCBOR (Data.VMap.VMap kv vv k v)
instance (NoThunks.Class.NoThunks (kv k), NoThunks.Class.NoThunks (vv v), Data.Typeable.Internal.Typeable kv, Data.Typeable.Internal.Typeable vv, Data.Typeable.Internal.Typeable k, Data.Typeable.Internal.Typeable v) => NoThunks.Class.NoThunks (Data.VMap.VMap kv vv k v)
instance GHC.Generics.Generic (Data.VMap.VMap kv vv k v)
instance (GHC.Classes.Eq (kv k), GHC.Classes.Eq (vv v)) => GHC.Classes.Eq (Data.VMap.VMap kv vv k v)
instance (GHC.Show.Show k, GHC.Show.Show v, Data.Vector.Generic.Base.Vector kv k, Data.Vector.Generic.Base.Vector vv v) => GHC.Show.Show (Data.VMap.VMap kv vv k v)
instance (Data.Vector.Generic.Base.Vector kv k, Data.Vector.Generic.Base.Vector vv v, GHC.Classes.Ord k) => GHC.Exts.IsList (Data.VMap.VMap kv vv k v)
