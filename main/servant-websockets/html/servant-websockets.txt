-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Small library providing WebSocket endpoints for servant.
--   
--   Small library providing WebSocket endpoints for servant.
@package servant-websockets
@version 2.0.0

module Servant.API.WebSocket

-- | Endpoint for defining a route to provide a web socket. The handler
--   function gets an already negotiated websocket <a>Connection</a> to
--   send and receive data.
--   
--   Example:
--   
--   <pre>
--   type WebSocketApi = "stream" :&gt; WebSocket
--   
--   server :: Server WebSocketApi
--   server = streamData
--    where
--     streamData :: MonadIO m =&gt; Connection -&gt; m ()
--     streamData c = do
--       liftIO $ forkPingThread c 10
--       liftIO . forM_ [1..] $ \i -&gt; do
--          sendTextData c (pack $ show (i :: Int)) &gt;&gt; threadDelay 1000000
--   </pre>
data WebSocket

-- | Endpoint for defining a route to provide a web socket. The handler
--   function gets a <a>PendingConnection</a>. It can either
--   <tt>rejectRequest</tt> or <a>acceptRequest</a>. This function is
--   provided for greater flexibility to reject connections.
--   
--   Example:
--   
--   <pre>
--   type WebSocketApi = "stream" :&gt; WebSocketPending
--   
--   server :: Server WebSocketApi
--   server = streamData
--    where
--     streamData :: MonadIO m =&gt; PendingConnection -&gt; m ()
--     streamData pc = do
--        c &lt;- acceptRequest pc
--        liftIO $ forkPingThread c 10
--        liftIO . forM_ [1..] $ \i -&gt;
--          sendTextData c (pack $ show (i :: Int)) &gt;&gt; threadDelay 1000000
--   </pre>
data WebSocketPending
instance Servant.Server.Internal.HasServer Servant.API.WebSocket.WebSocketPending ctx
instance Servant.Server.Internal.HasServer Servant.API.WebSocket.WebSocket ctx

module Servant.API.WebSocketConduit

-- | Endpoint for defining a route to provide a websocket. In contrast to
--   the <tt>WebSocket</tt> endpoint, <a>WebSocketConduit</a> provides a
--   higher-level interface. The handler function must be of type
--   <tt>Conduit i m o</tt> with <tt>i</tt> and <tt>o</tt> being instances
--   of <a>FromJSON</a> and <a>ToJSON</a> respectively. <tt>await</tt>
--   reads from the web socket while <tt>yield</tt> writes to it.
--   
--   Example:
--   
--   <pre>
--   import Data.Aeson (Value)
--   import qualified Data.Conduit.List as CL
--   
--   type WebSocketApi = "echo" :&gt; WebSocketConduit Value Value
--   
--   server :: Server WebSocketApi
--   server = echo
--    where
--     echo :: Monad m =&gt; ConduitT Value Value m ()
--     echo = CL.map id
--   </pre>
--   
--   Note that the input format on the web socket is JSON, hence this
--   example only echos valid JSON data.
data WebSocketConduit i o

-- | Endpoint for defining a route to provide a websocket. In contrast to
--   the <a>WebSocketConduit</a>, this endpoint only produces data. It can
--   be useful when implementing web sockets that simply just send data to
--   clients.
--   
--   Example:
--   
--   <pre>
--   import Data.Text (Text)
--   import qualified Data.Conduit.List as CL
--   
--   type WebSocketApi = "hello" :&gt; WebSocketSource Text
--   
--   server :: Server WebSocketApi
--   server = hello
--    where
--     hello :: Monad m =&gt; Conduit Text m ()
--     hello = yield $ Just "hello"
--   </pre>
data WebSocketSource o
runConduitWebSocket :: (MonadBaseControl IO m, MonadUnliftIO m) => Connection -> ConduitT () Void (ResourceT m) () -> m ()
upgradeRequired :: ServerError
instance Data.Aeson.Types.ToJSON.ToJSON o => Servant.Server.Internal.HasServer (Servant.API.WebSocketConduit.WebSocketSource o) ctx
instance (Data.Aeson.Types.FromJSON.FromJSON i, Data.Aeson.Types.ToJSON.ToJSON o) => Servant.Server.Internal.HasServer (Servant.API.WebSocketConduit.WebSocketConduit i o) ctx
