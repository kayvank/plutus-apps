-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Strict linked list
--   
--   Implementation of strict linked list with care taken about stack.
@package strict-list
@version 0.1.7


-- | Definitions of strict linked list.
--   
--   Most basic operations like <a>fmap</a>, <a>filter</a>,
--   <a>&lt;*&gt;</a> can only be implemented efficiently by producing an
--   intermediate list in reversed order and then reversing it to the
--   original order. These intermediate reversed functions are exposed by
--   the API, because they very well may be useful for efficient
--   implementations of data-structures built on top of list. E.g., the
--   <a>"deque"</a> package exploits them heavily.
--   
--   One useful rule of thumb would be that whenever you see that a
--   function has a reversed counterpart, that counterpart is faster and
--   hence if you don't care about the order or intend to reverse the list
--   further down the line, you should give preference to that counterpart.
--   
--   The typical <a>toList</a> and <a>fromList</a> conversions are provided
--   by means of the <a>Foldable</a> and <a>IsList</a> instances.
module StrictList

-- | Strict linked list.
data List a
Cons :: !a -> !List a -> List a
Nil :: List a

-- | Convert to lazy list in normal form (with all elements and spine
--   evaluated).
toListReversed :: List a -> [a]

-- | Reverse the list.
reverse :: List a -> List a

-- | Leave only the specified amount of elements.
take :: Int -> List a -> List a

-- | Leave only the specified amount of elements, in reverse order.
takeReversed :: Int -> List a -> List a

-- | Leave only the elements after the specified amount of first elements.
drop :: Int -> List a -> List a

-- | Leave only the elements satisfying the predicate.
filter :: (a -> Bool) -> List a -> List a

-- | Leave only the elements satisfying the predicate, producing a list in
--   reversed order.
filterReversed :: (a -> Bool) -> List a -> List a

-- | Leave only the first elements satisfying the predicate.
takeWhile :: (a -> Bool) -> List a -> List a

-- | Leave only the first elements satisfying the predicate, producing a
--   list in reversed order.
takeWhileReversed :: (a -> Bool) -> List a -> List a

-- | Drop the first elements satisfying the predicate.
dropWhile :: (a -> Bool) -> List a -> List a

-- | An optimized version of the same predicate applied to <a>takeWhile</a>
--   and <a>dropWhile</a>. IOW,
--   
--   <pre>
--   span predicate list = (takeWhile predicate list, dropWhile predicate list)
--   </pre>
span :: (a -> Bool) -> List a -> (List a, List a)

-- | Same as <a>span</a>, only with the first list in reverse order.
spanReversed :: (a -> Bool) -> List a -> (List a, List a)

-- | An opposite version of <a>span</a>. I.e.,
--   
--   <pre>
--   break predicate = span (not . predicate)
--   </pre>
break :: (a -> Bool) -> List a -> (List a, List a)

-- | Same as <a>break</a>, only with the first list in reverse order.
breakReversed :: (a -> Bool) -> List a -> (List a, List a)

-- | Same as <tt>(<a>takeWhile</a> predicate . <a>reverse</a>)</tt>. E.g.,
--   
--   <pre>
--   &gt;&gt;&gt; takeWhileFromEnding (&gt; 2) (fromList [1,4,2,3,4,5])
--   fromList [5,4,3]
--   </pre>
takeWhileFromEnding :: (a -> Bool) -> List a -> List a

-- | Same as <tt>(<a>dropWhile</a> predicate . <a>reverse</a>)</tt>. E.g.,
--   
--   <pre>
--   &gt;&gt;&gt; dropWhileFromEnding (&gt; 2) (fromList [1,4,2,3,4,5])
--   fromList [2,4,1]
--   </pre>
dropWhileFromEnding :: (a -> Bool) -> List a -> List a

-- | Same as <tt>(<a>span</a> predicate . <a>reverse</a>)</tt>.
spanFromEnding :: (a -> Bool) -> List a -> (List a, List a)

-- | Pattern match on list using functions.
--   
--   Allows to achieve all the same as <a>uncons</a> only without
--   intermediate <a>Maybe</a>.
--   
--   Essentially provides the same functionality as <a>either</a> for
--   <a>Either</a> and <a>maybe</a> for <a>Maybe</a>.
match :: result -> (element -> List element -> result) -> List element -> result

-- | Get the first element and the remainder of the list if it's not empty.
uncons :: List a -> Maybe (a, List a)

-- | Get the first element, if list is not empty.
head :: List a -> Maybe a

-- | Get the last element, if list is not empty.
last :: List a -> Maybe a

-- | Get all elements of the list but the first one.
tail :: List a -> List a

-- | Get all elements but the last one.
init :: List a -> List a

-- | Get all elements but the last one, producing the results in reverse
--   order.
initReversed :: List a -> List a

-- | Apply the functions in the left list to elements in the right one.
apZipping :: List (a -> b) -> List a -> List b

-- | Apply the functions in the left list to elements in the right one,
--   producing a list of results in reversed order.
apZippingReversed :: List (a -> b) -> List a -> List b

-- | Construct from a lazy list in reversed order.
fromListReversed :: [a] -> List a

-- | Add elements of the left list in reverse order in the beginning of the
--   right list.
prependReversed :: List a -> List a -> List a

-- | Map producing a list in reversed order.
mapReversed :: (a -> b) -> List a -> List b

-- | Apply the functions in the left list to every element in the right
--   one, producing a list of results in reversed order.
apReversed :: List (a -> b) -> List a -> List b

-- | Use a function to produce a list of lists and then concat them
--   sequentially, producing the results in reversed order.
explodeReversed :: (a -> List b) -> List a -> List b

-- | Join (concat) producing results in reversed order.
joinReversed :: List (List a) -> List a

-- | Map and filter elements producing results in reversed order.
mapMaybeReversed :: (a -> Maybe b) -> List a -> List b

-- | Keep only the present values, reversing the order.
catMaybesReversed :: List (Maybe a) -> List a
instance Data.Data.Data a => Data.Data.Data (StrictList.List a)
instance GHC.Generics.Generic1 StrictList.List
instance GHC.Generics.Generic (StrictList.List a)
instance GHC.Read.Read a => GHC.Read.Read (StrictList.List a)
instance GHC.Show.Show a => GHC.Show.Show (StrictList.List a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (StrictList.List a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (StrictList.List a)
instance GHC.Exts.IsList (StrictList.List a)
instance GHC.Base.Semigroup (StrictList.List a)
instance GHC.Base.Monoid (StrictList.List a)
instance GHC.Base.Functor StrictList.List
instance Data.Foldable.Foldable StrictList.List
instance Data.Traversable.Traversable StrictList.List
instance Data.Functor.Bind.Class.Apply StrictList.List
instance GHC.Base.Applicative StrictList.List
instance Data.Functor.Alt.Alt StrictList.List
instance Data.Functor.Plus.Plus StrictList.List
instance GHC.Base.Alternative StrictList.List
instance Data.Functor.Bind.Class.Bind StrictList.List
instance GHC.Base.Monad StrictList.List
instance GHC.Base.MonadPlus StrictList.List
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (StrictList.List a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (StrictList.List a)
instance Control.DeepSeq.NFData1 StrictList.List
