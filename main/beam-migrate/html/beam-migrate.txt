-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | SQL DDL support and migrations support library for Beam
--   
--   This package provides type classes to allow backends to implement SQL
--   DDL support for beam. This allows you to use beam syntax to write
--   type-safe schema generation code. The package also provides features
--   to introspect beam schemas, and support for automatic generation of
--   migrations in SQL and Haskell formats. This is mostly a low-level
--   support library. Most often, this library is used to write tooling to
--   support DDL manipulation in your project, or to enable migrations
--   support in beam backends. For a more turnkey solution for database
--   migrations, consider the <a>beam-migrate</a> command line tool. This
--   provides out-of-the-box support for migrations, schema change
--   management, and version control, based on the features provided in
--   this library.
@package beam-migrate
@version 0.5.2.0


-- | Finally-tagless encoding of SQL92 DDL commands.
--   
--   If you're writing a beam backend driver and you want to support
--   migrations, making an instance of your command syntax for
--   <a>IsSql92DdlCommandSyntax</a> and making it satisfy
--   <a>Sql92SaneDdlCommandSyntax</a>.
module Database.Beam.Migrate.SQL.SQL92

-- | Syntax equalities that any reasonable DDL syntax would follow,
--   including equalities between beam-migrate and beam-core types.
type Sql92SaneDdlCommandSyntax cmd = (Sql92SaneDdlCommandSyntaxMigrateOnly cmd, Sql92ExpressionCastTargetSyntax (Sql92ExpressionSyntax cmd) ~ Sql92DdlCommandDataTypeSyntax cmd, Sql92ColumnSchemaExpressionSyntax (Sql92DdlCommandColumnSchemaSyntax cmd) ~ Sql92ExpressionSyntax cmd)

-- | Syntax equalities for any reasonable DDL syntax, only including types
--   defined here.
type Sql92SaneDdlCommandSyntaxMigrateOnly cmd = (IsSql92DdlCommandSyntax cmd, Sql92SerializableDataTypeSyntax (Sql92DdlCommandDataTypeSyntax cmd), Sql92SerializableConstraintDefinitionSyntax (Sql92DdlCommandConstraintDefinitionSyntax cmd), Typeable (Sql92DdlCommandColumnSchemaSyntax cmd), Sql92AlterTableColumnSchemaSyntax (Sql92AlterTableAlterTableActionSyntax (Sql92DdlCommandAlterTableSyntax cmd)) ~ Sql92CreateTableColumnSchemaSyntax (Sql92DdlCommandCreateTableSyntax cmd))
type Sql92DdlCommandDataTypeSyntax syntax = Sql92ColumnSchemaColumnTypeSyntax (Sql92DdlCommandColumnSchemaSyntax syntax)
type Sql92DdlCommandColumnSchemaSyntax syntax = Sql92CreateTableColumnSchemaSyntax (Sql92DdlCommandCreateTableSyntax syntax)
type Sql92DdlCommandConstraintDefinitionSyntax syntax = Sql92ColumnSchemaColumnConstraintDefinitionSyntax (Sql92DdlCommandColumnSchemaSyntax syntax)
type Sql92DdlColumnSchemaConstraintSyntax syntax = Sql92ColumnConstraintDefinitionConstraintSyntax (Sql92ColumnSchemaColumnConstraintDefinitionSyntax syntax)
type Sql92DdlCommandColumnConstraintSyntax syntax = Sql92DdlColumnSchemaConstraintSyntax (Sql92DdlCommandColumnSchemaSyntax syntax)
type Sql92DdlCommandMatchTypeSyntax syntax = Sql92ColumnConstraintMatchTypeSyntax (Sql92DdlCommandColumnConstraintSyntax syntax)
type Sql92DdlCommandReferentialActionSyntax syntax = Sql92ColumnConstraintReferentialActionSyntax (Sql92DdlCommandColumnConstraintSyntax syntax)
type Sql92DdlCommandConstraintAttributesSyntax syntax = Sql92ColumnConstraintDefinitionAttributesSyntax (Sql92DdlCommandConstraintDefinitionSyntax syntax)
type Sql92DdlCommandAlterTableActionSyntax syntax = Sql92AlterTableAlterTableActionSyntax (Sql92DdlCommandAlterTableSyntax syntax)
class (IsSql92CreateTableSyntax (Sql92DdlCommandCreateTableSyntax syntax), IsSql92DropTableSyntax (Sql92DdlCommandDropTableSyntax syntax), IsSql92AlterTableSyntax (Sql92DdlCommandAlterTableSyntax syntax)) => IsSql92DdlCommandSyntax syntax where {
    type family Sql92DdlCommandCreateTableSyntax syntax :: *;
    type family Sql92DdlCommandAlterTableSyntax syntax :: *;
    type family Sql92DdlCommandDropTableSyntax syntax :: *;
}
createTableCmd :: IsSql92DdlCommandSyntax syntax => Sql92DdlCommandCreateTableSyntax syntax -> syntax
dropTableCmd :: IsSql92DdlCommandSyntax syntax => Sql92DdlCommandDropTableSyntax syntax -> syntax
alterTableCmd :: IsSql92DdlCommandSyntax syntax => Sql92DdlCommandAlterTableSyntax syntax -> syntax
class (IsSql92TableConstraintSyntax (Sql92CreateTableTableConstraintSyntax syntax), IsSql92ColumnSchemaSyntax (Sql92CreateTableColumnSchemaSyntax syntax), IsSql92TableNameSyntax (Sql92CreateTableTableNameSyntax syntax)) => IsSql92CreateTableSyntax syntax where {
    type family Sql92CreateTableTableNameSyntax syntax :: *;
    type family Sql92CreateTableColumnSchemaSyntax syntax :: *;
    type family Sql92CreateTableTableConstraintSyntax syntax :: *;
    type family Sql92CreateTableOptionsSyntax syntax :: *;
}
createTableSyntax :: IsSql92CreateTableSyntax syntax => Maybe (Sql92CreateTableOptionsSyntax syntax) -> Sql92CreateTableTableNameSyntax syntax -> [(Text, Sql92CreateTableColumnSchemaSyntax syntax)] -> [Sql92CreateTableTableConstraintSyntax syntax] -> syntax
class IsSql92TableNameSyntax (Sql92DropTableTableNameSyntax syntax) => IsSql92DropTableSyntax syntax where {
    type family Sql92DropTableTableNameSyntax syntax :: *;
}
dropTableSyntax :: IsSql92DropTableSyntax syntax => Sql92DropTableTableNameSyntax syntax -> syntax
class (IsSql92TableNameSyntax (Sql92AlterTableTableNameSyntax syntax), IsSql92AlterTableActionSyntax (Sql92AlterTableAlterTableActionSyntax syntax)) => IsSql92AlterTableSyntax syntax where {
    type family Sql92AlterTableTableNameSyntax syntax :: *;
    type family Sql92AlterTableAlterTableActionSyntax syntax :: *;
}
alterTableSyntax :: IsSql92AlterTableSyntax syntax => Sql92AlterTableTableNameSyntax syntax -> Sql92AlterTableAlterTableActionSyntax syntax -> syntax
class (IsSql92ColumnSchemaSyntax (Sql92AlterTableColumnSchemaSyntax syntax), IsSql92AlterColumnActionSyntax (Sql92AlterTableAlterColumnActionSyntax syntax)) => IsSql92AlterTableActionSyntax syntax where {
    type family Sql92AlterTableAlterColumnActionSyntax syntax :: *;
    type family Sql92AlterTableColumnSchemaSyntax syntax :: *;
}
alterColumnSyntax :: IsSql92AlterTableActionSyntax syntax => Text -> Sql92AlterTableAlterColumnActionSyntax syntax -> syntax
addColumnSyntax :: IsSql92AlterTableActionSyntax syntax => Text -> Sql92AlterTableColumnSchemaSyntax syntax -> syntax
dropColumnSyntax :: IsSql92AlterTableActionSyntax syntax => Text -> syntax
renameTableToSyntax :: IsSql92AlterTableActionSyntax syntax => Text -> syntax
renameColumnToSyntax :: IsSql92AlterTableActionSyntax syntax => Text -> Text -> syntax
class IsSql92AlterColumnActionSyntax syntax
setNotNullSyntax :: IsSql92AlterColumnActionSyntax syntax => syntax
setNullSyntax :: IsSql92AlterColumnActionSyntax syntax => syntax
class (IsSql92ColumnConstraintDefinitionSyntax (Sql92ColumnSchemaColumnConstraintDefinitionSyntax columnSchema), IsSql92DataTypeSyntax (Sql92ColumnSchemaColumnTypeSyntax columnSchema), Typeable (Sql92ColumnSchemaColumnTypeSyntax columnSchema), Sql92DisplaySyntax (Sql92ColumnSchemaColumnTypeSyntax columnSchema), Hashable (Sql92ColumnSchemaColumnTypeSyntax columnSchema), Eq (Sql92ColumnSchemaColumnTypeSyntax columnSchema), Sql92DisplaySyntax (Sql92ColumnSchemaColumnConstraintDefinitionSyntax columnSchema), Eq (Sql92ColumnSchemaColumnConstraintDefinitionSyntax columnSchema), Hashable (Sql92ColumnSchemaColumnConstraintDefinitionSyntax columnSchema), IsSql92ExpressionSyntax (Sql92ColumnSchemaExpressionSyntax columnSchema), Typeable columnSchema, Sql92DisplaySyntax columnSchema, Eq columnSchema, Hashable columnSchema) => IsSql92ColumnSchemaSyntax columnSchema where {
    type family Sql92ColumnSchemaColumnTypeSyntax columnSchema :: *;
    type family Sql92ColumnSchemaExpressionSyntax columnSchema :: *;
    type family Sql92ColumnSchemaColumnConstraintDefinitionSyntax columnSchema :: *;
}
columnSchemaSyntax :: IsSql92ColumnSchemaSyntax columnSchema => Sql92ColumnSchemaColumnTypeSyntax columnSchema -> Maybe (Sql92ColumnSchemaExpressionSyntax columnSchema) -> [Sql92ColumnSchemaColumnConstraintDefinitionSyntax columnSchema] -> Maybe Text -> columnSchema
class Typeable constraint => IsSql92TableConstraintSyntax constraint
primaryKeyConstraintSyntax :: IsSql92TableConstraintSyntax constraint => [Text] -> constraint
class Typeable match => IsSql92MatchTypeSyntax match
fullMatchSyntax :: IsSql92MatchTypeSyntax match => match
partialMatchSyntax :: IsSql92MatchTypeSyntax match => match
class Typeable refAction => IsSql92ReferentialActionSyntax refAction
referentialActionCascadeSyntax :: IsSql92ReferentialActionSyntax refAction => refAction
referentialActionSetNullSyntax :: IsSql92ReferentialActionSyntax refAction => refAction
referentialActionSetDefaultSyntax :: IsSql92ReferentialActionSyntax refAction => refAction
referentialActionNoActionSyntax :: IsSql92ReferentialActionSyntax refAction => refAction
class (IsSql92ColumnConstraintSyntax (Sql92ColumnConstraintDefinitionConstraintSyntax constraint), IsSql92ConstraintAttributesSyntax (Sql92ColumnConstraintDefinitionAttributesSyntax constraint), Typeable constraint) => IsSql92ColumnConstraintDefinitionSyntax constraint where {
    type family Sql92ColumnConstraintDefinitionConstraintSyntax constraint :: *;
    type family Sql92ColumnConstraintDefinitionAttributesSyntax constraint :: *;
}
constraintDefinitionSyntax :: IsSql92ColumnConstraintDefinitionSyntax constraint => Maybe Text -> Sql92ColumnConstraintDefinitionConstraintSyntax constraint -> Maybe (Sql92ColumnConstraintDefinitionAttributesSyntax constraint) -> constraint
class (Semigroup attrs, Monoid attrs, Typeable attrs) => IsSql92ConstraintAttributesSyntax attrs
initiallyDeferredAttributeSyntax :: IsSql92ConstraintAttributesSyntax attrs => attrs
initiallyImmediateAttributeSyntax :: IsSql92ConstraintAttributesSyntax attrs => attrs
notDeferrableAttributeSyntax :: IsSql92ConstraintAttributesSyntax attrs => attrs
deferrableAttributeSyntax :: IsSql92ConstraintAttributesSyntax attrs => attrs
class (IsSql92MatchTypeSyntax (Sql92ColumnConstraintMatchTypeSyntax constraint), IsSql92ReferentialActionSyntax (Sql92ColumnConstraintReferentialActionSyntax constraint), Typeable (Sql92ColumnConstraintExpressionSyntax constraint), Typeable constraint) => IsSql92ColumnConstraintSyntax constraint where {
    type family Sql92ColumnConstraintMatchTypeSyntax constraint :: *;
    type family Sql92ColumnConstraintReferentialActionSyntax constraint :: *;
    type family Sql92ColumnConstraintExpressionSyntax constraint :: *;
}
notNullConstraintSyntax :: IsSql92ColumnConstraintSyntax constraint => constraint
uniqueColumnConstraintSyntax :: IsSql92ColumnConstraintSyntax constraint => constraint
primaryKeyColumnConstraintSyntax :: IsSql92ColumnConstraintSyntax constraint => constraint
checkColumnConstraintSyntax :: IsSql92ColumnConstraintSyntax constraint => Sql92ColumnConstraintExpressionSyntax constraint -> constraint
referencesConstraintSyntax :: IsSql92ColumnConstraintSyntax constraint => Text -> [Text] -> Maybe (Sql92ColumnConstraintMatchTypeSyntax constraint) -> Maybe (Sql92ColumnConstraintReferentialActionSyntax constraint) -> Maybe (Sql92ColumnConstraintReferentialActionSyntax constraint) -> constraint

-- | <a>IsSql92DataTypeSyntax</a>es that can be serialized to JSON
class Sql92SerializableDataTypeSyntax dataType
serializeDataType :: Sql92SerializableDataTypeSyntax dataType => dataType -> Value

-- | <a>IsSql92ColumnConstraintDefinitionSyntax</a>es that can be
--   serialized to JSON
class Sql92SerializableConstraintDefinitionSyntax constraint
serializeConstraint :: Sql92SerializableConstraintDefinitionSyntax constraint => constraint -> Value


-- | Serialization and deserialization helpers for beam data types.
--   
--   Used to read and write machine-readable schema descriptions.
module Database.Beam.Migrate.Serialization

-- | An <a>IsSql92DataTypeSyntax</a> for JSON. Supports all superclasses of
--   <a>IsSql92DataTypeSyntax</a> declared in <tt>beam-core</tt>.
newtype BeamSerializedDataType
BeamSerializedDataType :: Value -> BeamSerializedDataType
[fromBeamSerializedDataType] :: BeamSerializedDataType -> Value

-- | <a>IsSql92ColumnConstraintDefinitionSyntax</a> type for JSON
newtype BeamSerializedConstraintDefinition
BeamSerializedConstraintDefinition :: Value -> BeamSerializedConstraintDefinition
[fromBeamSerializedConstraintDefinition] :: BeamSerializedConstraintDefinition -> Value

-- | <a>IsSql92ConstraintAttributesSyntax</a> type for JSON
newtype BeamSerializedConstraintAttributes
BeamSerializedConstraintAttributes :: [Value] -> BeamSerializedConstraintAttributes
[fromBeamSerializedConstraintAttributes] :: BeamSerializedConstraintAttributes -> [Value]

-- | <a>IsSql92ColumnConstraintSyntax</a> type for JSON
newtype BeamSerializedConstraint
BeamSerializedConstraint :: Value -> BeamSerializedConstraint
[fromBeamSerializedConstraint] :: BeamSerializedConstraint -> Value

-- | <a>IsSql92MatchTypeSyntax</a> type for JSON
newtype BeamSerializedMatchType
BeamSerializedMatchType :: Value -> BeamSerializedMatchType
[fromBeamSerializedMatchType] :: BeamSerializedMatchType -> Value

-- | <a>IsSql92ReferentialActionSyntax</a> type for JSON
newtype BeamSerializedReferentialAction
BeamSerializedReferentialAction :: Value -> BeamSerializedReferentialAction
[fromBeamSerializedReferentialAction] :: BeamSerializedReferentialAction -> Value

-- | <a>IsSql92ExpressionSyntax</a> is too complex for us to store in JSON.
--   Additionally, many backends provide substantial amounts of extensions
--   to the syntax that would make storing this highly unfeasible.
--   Expressions are therefore represented as their full text rendering.
--   
--   This means that expressions only match as equal if they match
--   <i>exactly</i>. While this may seem overly pedantic, it's not much of
--   a concern if your migrations are generated solely by
--   <tt>beam-migrate</tt>. If you've modified the schema yourself, you may
--   have to use <tt>IsCustomSqlSyntax</tt> to provide an exact expression.
newtype BeamSerializedExpression
BeamSerializedExpression :: Text -> BeamSerializedExpression
[fromBeamSerializedExpression] :: BeamSerializedExpression -> Text

-- | Some backends serialize data that can only be read by that backend. If
--   so, they should wrap these data in <a>beamSerializeJSON</a>, which
--   provides a standard syntax for specifying backend specific data, as
--   well as which backend the data are valid for.
--   
--   The first argument is a string that is unique to a given backend
beamSerializeJSON :: Text -> Value -> Value

-- | Helper for serializing the precision and decimal count parameters to
--   <a>decimalType</a>, etc.
serializePrecAndDecimal :: Maybe (Word, Maybe Word) -> Value

-- | Provides a collection of deserializers from aeson <a>Value</a>s for
--   arbitrary types. The <tt>cmd</tt> type parameter is a phantom type
--   parameter. Notionally, all deserializers within this
--   <a>BeamDeserializers</a> relate to the <tt>cmd</tt> syntax.
newtype BeamDeserializers be
BeamDeserializers :: DMap BeamDeserializerLabel BeamDeserializer -> BeamDeserializers be
[beamArbitraryDeserializers] :: BeamDeserializers be -> DMap BeamDeserializerLabel BeamDeserializer

-- | Deserialize the requested type from the given deserializers and aeson
--   <a>Value</a>.
beamDeserialize :: forall a be. Typeable a => BeamDeserializers be -> Value -> Parser a

-- | Helper function to deserialize data from a <a>Maybe</a> <a>Value</a>.
--   
--   <pre>
--   beamDeserializeMaybe _ Nothing = pure Nothing
--   beamDeserializeMaybe d (Just v) = Just <a>$</a> beamDeserialize d v
--   </pre>
beamDeserializeMaybe :: Typeable a => BeamDeserializers be -> Maybe Value -> Parser (Maybe a)
beamDeserializer :: Typeable ty => (forall be'. BeamDeserializers be' -> Value -> Parser ty) -> BeamDeserializers be

-- | Deserializers for SQL92 syntaxes
sql92Deserializers :: forall be. BeamMigrateSqlBackend be => BeamDeserializers be

-- | Deserializes data types that are instances of
--   <a>IsSql99DataTypeSyntax</a>
sql99DataTypeDeserializers :: forall be. BeamMigrateSql99Backend be => BeamDeserializers be

-- | Deserialize data types that are instances of
--   <a>IsSql2003BinaryAndVarBinaryDataTypeSyntax</a>
sql2003BinaryAndVarBinaryDataTypeDeserializers :: forall be. (BeamMigrateSqlBackend be, BeamSqlT021Backend be) => BeamDeserializers be

-- | Deserialize data types that are instance of
--   <a>IsSql2008BigIntDataTypeSyntax</a>
sql2008BigIntDataTypeDeserializers :: forall be. (BeamMigrateSqlBackend be, BeamSqlT071Backend be) => BeamDeserializers be
instance GHC.Classes.Eq Database.Beam.Migrate.Serialization.BeamSerializedDataType
instance GHC.Show.Show Database.Beam.Migrate.Serialization.BeamSerializedDataType
instance GHC.Classes.Eq Database.Beam.Migrate.Serialization.BeamSerializedConstraintDefinition
instance GHC.Show.Show Database.Beam.Migrate.Serialization.BeamSerializedConstraintDefinition
instance GHC.Base.Semigroup Database.Beam.Migrate.Serialization.BeamSerializedConstraintAttributes
instance GHC.Base.Monoid Database.Beam.Migrate.Serialization.BeamSerializedConstraintAttributes
instance GHC.Classes.Eq Database.Beam.Migrate.Serialization.BeamSerializedConstraintAttributes
instance GHC.Show.Show Database.Beam.Migrate.Serialization.BeamSerializedConstraintAttributes
instance GHC.Classes.Eq Database.Beam.Migrate.Serialization.BeamSerializedConstraint
instance GHC.Show.Show Database.Beam.Migrate.Serialization.BeamSerializedConstraint
instance GHC.Classes.Eq Database.Beam.Migrate.Serialization.BeamSerializedMatchType
instance GHC.Show.Show Database.Beam.Migrate.Serialization.BeamSerializedMatchType
instance GHC.Classes.Eq Database.Beam.Migrate.Serialization.BeamSerializedReferentialAction
instance GHC.Show.Show Database.Beam.Migrate.Serialization.BeamSerializedReferentialAction
instance GHC.Classes.Eq Database.Beam.Migrate.Serialization.BeamSerializedExpression
instance GHC.Show.Show Database.Beam.Migrate.Serialization.BeamSerializedExpression
instance GHC.Base.Semigroup (Database.Beam.Migrate.Serialization.BeamDeserializer be)
instance GHC.Base.Monoid (Database.Beam.Migrate.Serialization.BeamDeserializer be)
instance GHC.Base.Semigroup (Database.Beam.Migrate.Serialization.BeamDeserializers be)
instance GHC.Base.Monoid (Database.Beam.Migrate.Serialization.BeamDeserializers be)
instance Data.GADT.Internal.GEq Database.Beam.Migrate.Serialization.BeamDeserializerLabel
instance Data.GADT.Internal.GCompare Database.Beam.Migrate.Serialization.BeamDeserializerLabel
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnConstraintSyntax Database.Beam.Migrate.Serialization.BeamSerializedConstraint
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ReferentialActionSyntax Database.Beam.Migrate.Serialization.BeamSerializedReferentialAction
instance Database.Beam.Migrate.SQL.SQL92.IsSql92MatchTypeSyntax Database.Beam.Migrate.Serialization.BeamSerializedMatchType
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnConstraintDefinitionSyntax Database.Beam.Migrate.Serialization.BeamSerializedConstraintDefinition
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ConstraintAttributesSyntax Database.Beam.Migrate.Serialization.BeamSerializedConstraintAttributes
instance Database.Beam.Backend.SQL.SQL92.IsSql92DataTypeSyntax Database.Beam.Migrate.Serialization.BeamSerializedDataType
instance Database.Beam.Backend.SQL.SQL99.IsSql99DataTypeSyntax Database.Beam.Migrate.Serialization.BeamSerializedDataType
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003BinaryAndVarBinaryDataTypeSyntax Database.Beam.Migrate.Serialization.BeamSerializedDataType
instance Database.Beam.Backend.SQL.SQL2003.IsSql2008BigIntDataTypeSyntax Database.Beam.Migrate.Serialization.BeamSerializedDataType
instance Data.Aeson.Types.ToJSON.ToJSON Database.Beam.Migrate.Serialization.BeamSerializedDataType


-- | Defines common <a>DatabasePredicate</a>s that are shared among
--   backends
module Database.Beam.Migrate.Checks

-- | Asserts that a table with the given name exists in a database
data TableExistsPredicate

-- | Table name
TableExistsPredicate :: QualifiedName -> TableExistsPredicate

-- | A class that can check whether a particular data type is present in a
--   set of preconditions.
class HasDataTypeCreatedCheck dataType
dataTypeHasBeenCreated :: HasDataTypeCreatedCheck dataType => dataType -> (forall preCondition. Typeable preCondition => [preCondition]) -> Bool

-- | Asserts that the table specified has a column with the given data
--   type. The type paramater <tt>syntax</tt> should be an instance of
--   <a>IsSql92ColumnSchemaSyntax</a>.
data TableHasColumn be
[TableHasColumn] :: HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be) => {hasColumn_table :: QualifiedName " Table name ", hasColumn_column :: Text " Column name ", hasColumn_type :: BeamMigrateSqlBackendDataTypeSyntax be " Data type "} -> TableHasColumn be

-- | Asserts that a particular column of a table has a given constraint.
--   The <tt>syntax</tt> type parameter should be an instance of
--   <a>IsSql92ColumnSchemaSyntax</a>
data TableColumnHasConstraint be
TableColumnHasConstraint :: QualifiedName -> Text -> BeamSqlBackendColumnConstraintDefinitionSyntax be -> TableColumnHasConstraint be

-- | Table name
[hasConstraint_table] :: TableColumnHasConstraint be -> QualifiedName

-- | Column name
[hasConstraint_column] :: TableColumnHasConstraint be -> Text

-- | Constraint definition
[hasConstraint_defn] :: TableColumnHasConstraint be -> BeamSqlBackendColumnConstraintDefinitionSyntax be

-- | Asserts that the given table has a primary key made of the given
--   columns. The order of the columns is significant.
data TableHasPrimaryKey
TableHasPrimaryKey :: QualifiedName -> [Text] -> TableHasPrimaryKey

-- | Table name
[hasPrimaryKey_table] :: TableHasPrimaryKey -> QualifiedName

-- | Column names
[hasPrimaryKey_cols] :: TableHasPrimaryKey -> [Text]

-- | <a>BeamDeserializers</a> for all the predicates defined in this module
beamCheckDeserializers :: forall be. (Typeable be, BeamMigrateOnlySqlBackend be, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)) => BeamDeserializers be
instance GHC.Generics.Generic Database.Beam.Migrate.Checks.TableExistsPredicate
instance GHC.Classes.Ord Database.Beam.Migrate.Checks.TableExistsPredicate
instance GHC.Classes.Eq Database.Beam.Migrate.Checks.TableExistsPredicate
instance GHC.Show.Show Database.Beam.Migrate.Checks.TableExistsPredicate
instance GHC.Generics.Generic (Database.Beam.Migrate.Checks.TableColumnHasConstraint be)
instance GHC.Generics.Generic Database.Beam.Migrate.Checks.TableHasPrimaryKey
instance GHC.Classes.Eq Database.Beam.Migrate.Checks.TableHasPrimaryKey
instance GHC.Show.Show Database.Beam.Migrate.Checks.TableHasPrimaryKey
instance GHC.Classes.Eq (Database.Beam.Migrate.SQL.Types.BeamSqlBackendColumnConstraintDefinitionSyntax be) => GHC.Classes.Eq (Database.Beam.Migrate.Checks.TableColumnHasConstraint be)
instance Data.Hashable.Class.Hashable Database.Beam.Migrate.Checks.TableHasPrimaryKey
instance Database.Beam.Migrate.Types.Predicates.DatabasePredicate Database.Beam.Migrate.Checks.TableHasPrimaryKey
instance Data.Hashable.Class.Hashable (Database.Beam.Migrate.SQL.Types.BeamSqlBackendColumnConstraintDefinitionSyntax be) => Data.Hashable.Class.Hashable (Database.Beam.Migrate.Checks.TableColumnHasConstraint be)
instance (Data.Typeable.Internal.Typeable be, Database.Beam.Migrate.SQL.Types.BeamMigrateOnlySqlBackend be, Data.Hashable.Class.Hashable (Database.Beam.Migrate.SQL.Types.BeamSqlBackendColumnConstraintDefinitionSyntax be)) => Database.Beam.Migrate.Types.Predicates.DatabasePredicate (Database.Beam.Migrate.Checks.TableColumnHasConstraint be)
instance Data.Hashable.Class.Hashable (Database.Beam.Migrate.SQL.Types.BeamMigrateSqlBackendDataTypeSyntax be) => Data.Hashable.Class.Hashable (Database.Beam.Migrate.Checks.TableHasColumn be)
instance GHC.Classes.Eq (Database.Beam.Migrate.SQL.Types.BeamMigrateSqlBackendDataTypeSyntax be) => GHC.Classes.Eq (Database.Beam.Migrate.Checks.TableHasColumn be)
instance (Data.Typeable.Internal.Typeable be, Database.Beam.Migrate.SQL.Types.BeamMigrateOnlySqlBackend be, Data.Hashable.Class.Hashable (Database.Beam.Migrate.SQL.Types.BeamMigrateSqlBackendDataTypeSyntax be)) => Database.Beam.Migrate.Types.Predicates.DatabasePredicate (Database.Beam.Migrate.Checks.TableHasColumn be)
instance Data.Hashable.Class.Hashable Database.Beam.Migrate.Checks.TableExistsPredicate
instance Database.Beam.Migrate.Types.Predicates.DatabasePredicate Database.Beam.Migrate.Checks.TableExistsPredicate

module Database.Beam.Migrate.Types

-- | The type of a checked database descriptor. Conceptually, this is just
--   a <a>DatabaseSettings</a> with a set of predicates. Use
--   <a>unCheckDatabase</a> to get the regular <a>DatabaseSettings</a>
--   object and <a>collectChecks</a> to access the predicates.
type CheckedDatabaseSettings be db = db (CheckedDatabaseEntity be db)

-- | Like <a>IsDatabaseEntity</a> in <tt>beam-core</tt>, but for entities
--   against which we can generate <a>DatabasePredicate</a>s. Conceptually,
--   this is the same as <a>IsDatabaseEntity</a>, but with one extra
--   function to generate <a>DatabasePredicate</a>s from the description.
class IsDatabaseEntity be entity => IsCheckedDatabaseEntity be entity where {
    
    -- | The type of the descriptor for this checked entity. Usually this wraps
    --   the corresponding <a>DatabaseEntityDescriptor</a> from
    --   <a>IsDatabaseEntity</a>, along with some mechanism for generating
    --   <a>DatabasePredicate</a>s.
    data family CheckedDatabaseEntityDescriptor be entity :: *;
    
    -- | Like <a>DatabaseEntityDefaultRequirements</a> but for checked entities
    type family CheckedDatabaseEntityDefaultRequirements be entity :: Constraint;
}

-- | Produce the corresponding <a>DatabaseEntityDescriptor</a>
unCheck :: IsCheckedDatabaseEntity be entity => CheckedDatabaseEntityDescriptor be entity -> DatabaseEntityDescriptor be entity

-- | A lens to access the internal unchecked descriptor
unChecked :: IsCheckedDatabaseEntity be entity => Lens' (CheckedDatabaseEntityDescriptor be entity) (DatabaseEntityDescriptor be entity)

-- | Produce the set of <a>DatabasePredicate</a>s that apply to this entity
collectEntityChecks :: IsCheckedDatabaseEntity be entity => CheckedDatabaseEntityDescriptor be entity -> [SomeDatabasePredicate]

-- | Like <a>dbEntityAuto</a> but for checked databases. Most often, this
--   wraps <a>dbEntityAuto</a> and provides some means to generate
--   <a>DatabasePredicate</a>s
checkedDbEntityAuto :: (IsCheckedDatabaseEntity be entity, CheckedDatabaseEntityDefaultRequirements be entity) => Text -> CheckedDatabaseEntityDescriptor be entity

-- | Like <a>DatabaseEntity</a> but for checked databases
data CheckedDatabaseEntity be (db :: (* -> *) -> *) entityType
[CheckedDatabaseEntity] :: IsCheckedDatabaseEntity be entityType => CheckedDatabaseEntityDescriptor be entityType -> [SomeDatabasePredicate] -> CheckedDatabaseEntity be db entityType

-- | Convert a <a>CheckedDatabaseSettings</a> to a regular
--   <a>DatabaseSettings</a>. The return value is suitable for use in any
--   regular beam query or DML statement.
unCheckDatabase :: forall be db. Database be db => CheckedDatabaseSettings be db -> DatabaseSettings be db

-- | A <tt>beam-migrate</tt> database schema is defined completely by the
--   set of predicates that apply to it. This function allows you to access
--   this definition for a <a>CheckedDatabaseSettings</a> object.
collectChecks :: forall be db. Database be db => CheckedDatabaseSettings be db -> [SomeDatabasePredicate]
renameCheckedEntity :: (Text -> Text) -> EntityModification (CheckedDatabaseEntity be db) be ent

-- | Purposefully opaque type describing how to modify a table field. Used
--   to parameterize the second argument to <a>modifyCheckedTable</a>. For
--   now, the only way to construct a value is the <a>IsString</a>
--   instance, which allows you to rename the field.
data CheckedFieldModification tbl a
checkedFieldNamed :: Text -> CheckedFieldModification tbl a

-- | Modify a checked table.
--   
--   The first argument is a function that takes the original table name as
--   input and produces a new table name.
--   
--   The second argument gives instructions on how to rename each field in
--   the table. Use <a>checkedTableModification</a> to create a value of
--   this type which does no renaming. Each field in the table supplied
--   here has the type <a>CheckedFieldModification</a>. Most commonly, the
--   programmer will use the <tt>OverloadedStrings</tt> instance to provide
--   a new name.
--   
--   <h2>Examples</h2>
--   
--   Rename a table, without renaming any of its fields:
--   
--   <pre>
--   modifyCheckedTable (_ -&gt; <a>NewTblNm</a>) checkedTableModification
--   </pre>
--   
--   Modify a table, renaming the field called <tt>_field1</tt> in Haskell
--   to <a>FirstName</a>. Note that below, <tt><a>FirstName</a></tt>
--   represents a <a>CheckedFieldModification</a> object.
--   
--   <pre>
--   modifyCheckedTable id (checkedTableModification { _field1 = <a>FirstName</a> })
--   </pre>
modifyCheckedTable :: (Text -> Text) -> tbl (CheckedFieldModification tbl) -> EntityModification (CheckedDatabaseEntity be db) be (TableEntity tbl)

-- | Produce a table field modification that does nothing
--   
--   Most commonly supplied as the second argument to
--   <a>modifyCheckedTable</a> when you just want to rename the table, not
--   the fields.
checkedTableModification :: forall tbl. Beamable tbl => tbl (CheckedFieldModification tbl)

-- | A predicate is a type that describes some condition that the database
--   schema must meet. Beam represents database schemas as the set of all
--   predicates that apply to a database schema. The <a>Hashable</a> and
--   <a>Eq</a> instances allow us to build <tt>HashSet</tt>s of predicates
--   to represent schemas in this way.
class (Typeable p, Hashable p, Eq p) => DatabasePredicate p

-- | An english language description of this predicate. For example, "There
--   is a table named <tt>TableName</tt>"
englishDescription :: DatabasePredicate p => p -> String

-- | Whether or not this predicate applies to all backends or only one
--   backend. This is used when attempting to translate schemas between
--   backends. If you are unsure, provide
--   <a>PredicateSpecificityOnlyBackend</a> along with an identifier unique
--   to your backend.
predicateSpecificity :: DatabasePredicate p => proxy p -> PredicateSpecificity

-- | Serialize a predicate to a JSON <a>Value</a>.
serializePredicate :: DatabasePredicate p => p -> Value

-- | Some predicates require other predicates to be true. For example, in
--   order for a table to have a column, that table must exist. This
--   function takes in the current predicate and another arbitrary database
--   predicate. It should return <a>True</a> if this predicate needs the
--   other predicate to be true in order to exist.
--   
--   By default, this simply returns <a>False</a>, which makes sense for
--   many predicates.
predicateCascadesDropOn :: (DatabasePredicate p, DatabasePredicate p') => p -> p' -> Bool

-- | A Database predicate is a value of any type which satisfies
--   <a>DatabasePredicate</a>. We often want to store these in lists and
--   sets, so we need a monomorphic container that can store these
--   polymorphic values.
data SomeDatabasePredicate
[SomeDatabasePredicate] :: DatabasePredicate p => p -> SomeDatabasePredicate

-- | Some predicates make sense in any backend. Others only make sense in
--   one. This denotes the difference.
data PredicateSpecificity
PredicateSpecificityOnlyBackend :: String -> PredicateSpecificity
PredicateSpecificityAllBackends :: PredicateSpecificity

-- | A name in a schema
data QualifiedName
QualifiedName :: Maybe Text -> Text -> QualifiedName

-- | Convenience synonym for <a>SomeDatabasePredicate</a>
p :: DatabasePredicate p => p -> SomeDatabasePredicate

-- | An optional predicate that depends on the name of a table as well as
--   its fields
newtype TableCheck
TableCheck :: (forall tbl. Table tbl => QualifiedName -> tbl (TableField tbl) -> Maybe SomeDatabasePredicate) -> TableCheck

-- | A predicate that depends on the name of a domain type
newtype DomainCheck
DomainCheck :: (QualifiedName -> SomeDatabasePredicate) -> DomainCheck

-- | A predicate that depends on the name of a table and one of its fields
newtype FieldCheck
FieldCheck :: (QualifiedName -> Text -> SomeDatabasePredicate) -> FieldCheck

-- | Represents a particular step in a migration
data MigrationStep be next
[MigrationStep] :: Text -> Migration be a -> (a -> next) -> MigrationStep be next

-- | A series of <a>MigrationStep</a>s that take a database from the schema
--   in <tt>from</tt> to the one in <tt>to</tt>. Use the
--   <a>migrationStep</a> function and the arrow interface to sequence
--   <a>MigrationSteps</a>.
newtype MigrationSteps be from to
MigrationSteps :: Kleisli (F (MigrationStep be)) from to -> MigrationSteps be from to

-- | A sequence of potentially reversible schema update commands
type Migration be = F (MigrationF be)

-- | Free monadic function for <a>Migration</a>s
data MigrationF be next
[MigrationRunCommand] :: {_migrationUpCommand :: BeamSqlBackendSyntax be " What to execute when applying the migration", _migrationDownCommand :: Maybe (BeamSqlBackendSyntax be) " What to execute when unapplying the migration", _migrationNext :: next} -> MigrationF be next

-- | A migration command along with metadata on whether the command can
--   lose data
data MigrationCommand be
MigrationCommand :: BeamSqlBackendSyntax be -> MigrationDataLoss -> MigrationCommand be

-- | The command to run
[migrationCommand] :: MigrationCommand be -> BeamSqlBackendSyntax be

-- | Information on whether the migration loses data
[migrationCommandDataLossPossible] :: MigrationCommand be -> MigrationDataLoss

-- | Information on whether a <a>MigrationCommand</a> loses data. You can
--   monoidally combine these to get the potential data loss for a sequence
--   of commands.
data MigrationDataLoss

-- | The command loses data
MigrationLosesData :: MigrationDataLoss

-- | The command keeps all data
MigrationKeepsData :: MigrationDataLoss

-- | Run the migration steps between the given indices, using a custom
--   execution function.
runMigrationSteps :: Monad m => Int -> Maybe Int -> MigrationSteps be () a -> (forall a'. Int -> Text -> Migration be a' -> m a') -> m a

-- | Get the result of a migration, without running any steps
runMigrationSilenced :: Migration be a -> a

-- | Execute a given migration, provided a command to execute arbitrary
--   syntax. You usually use this with <a>runNoReturn</a>.
executeMigration :: Applicative m => (BeamSqlBackendSyntax be -> m ()) -> Migration be a -> m a

-- | Remove the explicit source and destination schemas from a
--   <a>MigrationSteps</a> object
eraseMigrationType :: a -> MigrationSteps be a a' -> MigrationSteps be () ()

-- | Create a <a>MigrationSteps</a> from the given description and
--   migration function.
migrationStep :: Text -> (a -> Migration be a') -> MigrationSteps be a a'

-- | Given a command in the forward direction, and an optional one in the
--   reverse direction, construct a <a>Migration</a> that performs the
--   given command. Multiple commands can be sequenced monadically.
upDown :: BeamSqlBackendSyntax be -> Maybe (BeamSqlBackendSyntax be) -> Migration be ()

-- | Given a migration, get the potential data loss, if it's run top-down
migrationDataLoss :: Migration be a -> MigrationDataLoss

-- | Given functions to render a migration step description and the
--   underlying syntax, create a script for the given
--   <a>MigrationSteps</a>.
migrateScript :: forall be m a. (Monoid m, Semigroup m, BeamSqlBackend be) => (Text -> m) -> (BeamSqlBackendSyntax be -> m) -> MigrationSteps be () a -> m

-- | Run a <a>MigrationSteps</a> without executing any of the commands
--   against a database.
evaluateDatabase :: forall be a. MigrationSteps be () a -> a

-- | Collect the names of all steps in hte given <a>MigrationSteps</a>
stepNames :: forall be a. MigrationSteps be () a -> [Text]
instance Control.Arrow.Arrow (Database.Beam.Migrate.Types.MigrationSteps be)
instance Control.Category.Category (Database.Beam.Migrate.Types.MigrationSteps be)
instance GHC.Show.Show Database.Beam.Migrate.Types.MigrationDataLoss
instance GHC.Base.Functor (Database.Beam.Migrate.Types.MigrationStep be)
instance GHC.Base.Functor (Database.Beam.Migrate.Types.MigrationF be)
instance GHC.Show.Show (Database.Beam.Backend.SQL.BeamSqlBackendSyntax be) => GHC.Show.Show (Database.Beam.Migrate.Types.MigrationCommand be)
instance GHC.Base.Semigroup Database.Beam.Migrate.Types.MigrationDataLoss
instance GHC.Base.Monoid Database.Beam.Migrate.Types.MigrationDataLoss

module Database.Beam.Migrate.SQL.Tables

-- | Add a <tt>CREATE TABLE</tt> statement to this migration
--   
--   The first argument is the name of the table.
--   
--   The second argument is a table containing a <a>FieldSchema</a> for
--   each field. See documentation on the <tt>Field</tt> command for more
--   information.c
createTable :: (Beamable table, Table table, BeamMigrateSqlBackend be) => Text -> TableSchema be table -> Migration be (CheckedDatabaseEntity be db (TableEntity table))

-- | Add a <tt>DROP TABLE</tt> statement to this migration.
dropTable :: BeamMigrateSqlBackend be => CheckedDatabaseEntity be db (TableEntity table) -> Migration be ()

-- | Copy a table schema from one database to another
preserve :: CheckedDatabaseEntity be db e -> Migration be (CheckedDatabaseEntity be db' e)

-- | Monad representing a series of <tt>ALTER TABLE</tt> statements
newtype TableMigration be a
TableMigration :: WriterT [BeamSqlBackendAlterTableSyntax be] (State (TableName, [TableCheck])) a -> TableMigration be a

-- | A column in the process of being altered
data ColumnMigration a
ColumnMigration :: Text -> [FieldCheck] -> ColumnMigration a
[columnMigrationFieldName] :: ColumnMigration a -> Text
[columnMigrationFieldChecks] :: ColumnMigration a -> [FieldCheck]

-- | Compose a series of <tt>ALTER TABLE</tt> commands
--   
--   Example usage
--   
--   <pre>
--   migrate (OldDb oldTbl) = do
--     alterTable oldTbl $ oldTbl' -&gt;
--       field2 &lt;- renameColumnTo <a>NewNameForField2</a> (_field2 oldTbl')
--       dropColumn (_field3 oldTbl')
--       renameTableTo <a>NewTableName</a>
--       field4 &lt;- addColumn (field <a>ANewColumn</a> smallint notNull (defaultTo_ (val_ 0)))
--       return (NewTable (_field1 oldTbl') field2 field4)
--   </pre>
--   
--   The above would result in commands like:
--   
--   <pre>
--   ALTER TABLE <a>oldtable</a> RENAME COLUMN <a>field2</a> TO <a>NewNameForField2</a>;
--   ALTER TABLE <a>oldtable</a> DROP COLUMN <a>field3</a>;
--   ALTER TABLE <a>oldtable</a> RENAME TO <a>NewTableName</a>;
--   ALTER TABLE <a>NewTableName</a> ADD COLUMN <a>ANewColumn</a> SMALLINT NOT NULL DEFAULT 0;
--   </pre>
alterTable :: forall be db db' table table'. (Table table', BeamMigrateSqlBackend be) => CheckedDatabaseEntity be db (TableEntity table) -> (table ColumnMigration -> TableMigration be (table' ColumnMigration)) -> Migration be (CheckedDatabaseEntity be db' (TableEntity table'))

-- | <tt>ALTER TABLE ... RENAME TO</tt> command
renameTableTo :: BeamMigrateSqlBackend be => Text -> table ColumnMigration -> TableMigration be (table ColumnMigration)

-- | <tt>ALTER TABLE ... RENAME COLUMN ... TO ...</tt> command
renameColumnTo :: BeamMigrateSqlBackend be => Text -> ColumnMigration a -> TableMigration be (ColumnMigration a)

-- | <tt>ALTER TABLE ... ADD COLUMN ...</tt> command
addColumn :: BeamMigrateSqlBackend be => TableFieldSchema be a -> TableMigration be (ColumnMigration a)

-- | <tt>ALTER TABLE ... DROP COLUMN ...</tt> command
dropColumn :: BeamMigrateSqlBackend be => ColumnMigration a -> TableMigration be ()

-- | Represents the default value of a field with a given column schema
--   syntax and type
data DefaultValue be a

-- | Represents a constraint in the given column schema syntax
newtype Constraint be
Constraint :: BeamSqlBackendConstraintSyntax be -> Constraint be
data NotNullConstraint be

-- | Build a schema for a field. This function takes the name and type of
--   the field and a variable number of modifiers, such as constraints and
--   default values. GHC will complain at you if the modifiers do not make
--   sense. For example, you cannot apply the <a>notNull</a> constraint to
--   a column with a <a>Maybe</a> type.
--   
--   Example of creating a table named <a>Employee</a> with three columns:
--   <a>FirstName</a>, <a>LastName</a>, and <a>HireDate</a>
--   
--   <pre>
--   data Employee f =
--     Employee { _firstName :: C f Text
--              , _lastName  :: C f Text
--              , _hireDate  :: C f (Maybe LocalTime)
--              } deriving Generic
--   instance Beamable Employee
--   
--   instance Table Employee where
--      data PrimaryKey Employee f = EmployeeKey (C f Text) (C f Text) deriving Generic
--      primaryKey = EmployeeKey &lt;$&gt; _firstName &lt;*&gt; _lastName
--   
--   instance Beamable PrimaryKey Employee f
--   
--   data EmployeeDb entity
--       = EmployeeDb { _employees :: entity (TableEntity Employee) }
--       deriving Generic
--   instance Database EmployeeDb
--   
--   migration :: IsSql92DdlCommandSyntax syntax =&gt; Migration syntax () EmployeeDb
--   migration = do
--     employees &lt;- createTable <a>EmployeesTable</a>
--                    (Employee (field <a>FirstNameField</a> (varchar (Just 15)) notNull)
--                              (field "last_name" (varchar Nothing) notNull (defaultTo_ (val_ <a>Smith</a>)))
--                              (field "hiredDate" (maybeType timestamp)))
--     return (EmployeeDb employees)
--   </pre>
field :: (BeamMigrateSqlBackend be, FieldReturnType 'False 'False be resTy a) => Text -> DataType be resTy -> a

-- | Build a <a>DefaultValue</a> from a <a>QExpr</a>. GHC will complain if
--   you supply more than one default value.
defaultTo_ :: BeamMigrateSqlBackend be => (forall s. QExpr be s a) -> DefaultValue be a

-- | The SQL92 <tt>NOT NULL</tt> constraint
notNull :: BeamMigrateSqlBackend be => NotNullConstraint be

-- | SQL <tt>UNIQUE</tt> constraint
unique :: BeamMigrateSqlBackend be => Constraint be
class FieldReturnType (defaultGiven :: Bool) (collationGiven :: Bool) be resTy a | a -> be resTy
field' :: (FieldReturnType defaultGiven collationGiven be resTy a, BeamMigrateSqlBackend be) => Proxy defaultGiven -> Proxy collationGiven -> Text -> BeamMigrateSqlBackendDataTypeSyntax be -> Maybe (BeamSqlBackendExpressionSyntax be) -> Maybe Text -> [BeamSqlBackendColumnConstraintDefinitionSyntax be] -> a
type family IsNotNull (x :: *) :: Constraint
instance GHC.Base.Functor (Database.Beam.Migrate.SQL.Tables.TableMigration be)
instance GHC.Base.Applicative (Database.Beam.Migrate.SQL.Tables.TableMigration be)
instance GHC.Base.Monad (Database.Beam.Migrate.SQL.Tables.TableMigration be)
instance (Database.Beam.Migrate.SQL.Tables.FieldReturnType defaultGiven collationGiven be resTy (Database.Beam.Migrate.SQL.Tables.Constraint be -> a), Database.Beam.Migrate.SQL.Tables.IsNotNull resTy) => Database.Beam.Migrate.SQL.Tables.FieldReturnType defaultGiven collationGiven be resTy (Database.Beam.Migrate.SQL.Tables.NotNullConstraint be -> a)
instance Database.Beam.Migrate.SQL.Tables.FieldReturnType 'GHC.Types.True collationGiven be resTy a => Database.Beam.Migrate.SQL.Tables.FieldReturnType 'GHC.Types.False collationGiven be resTy (Database.Beam.Migrate.SQL.Tables.DefaultValue be resTy -> a)
instance Database.Beam.Migrate.SQL.Tables.FieldReturnType defaultGiven collationGiven be resTy a => Database.Beam.Migrate.SQL.Tables.FieldReturnType defaultGiven collationGiven be resTy (Database.Beam.Migrate.SQL.Tables.Constraint be -> a)
instance (Database.Beam.Migrate.SQL.Tables.FieldReturnType 'GHC.Types.True collationGiven be resTy a, (TypeError ...)) => Database.Beam.Migrate.SQL.Tables.FieldReturnType 'GHC.Types.True collationGiven be resTy (Database.Beam.Migrate.SQL.Tables.DefaultValue be resTy -> a)
instance (Database.Beam.Migrate.SQL.Tables.FieldReturnType defaultGiven collationGiven be resTy a, (TypeError ...)) => Database.Beam.Migrate.SQL.Tables.FieldReturnType defaultGiven collationGiven be resTy (Database.Beam.Query.DataTypes.DataType be' x -> a)
instance (Database.Beam.Migrate.SQL.Types.BeamMigrateSqlBackend be, Database.Beam.Migrate.Checks.HasDataTypeCreatedCheck (Database.Beam.Migrate.SQL.Types.BeamMigrateSqlBackendDataTypeSyntax be)) => Database.Beam.Migrate.SQL.Tables.FieldReturnType defaultGiven collationGiven be resTy (Database.Beam.Migrate.SQL.Types.TableFieldSchema be resTy)


-- | Beam extensions are optional functionality that do not conform to any
--   standard and may have wildly different interpretations across
--   backends.
--   
--   In spite of these drawbacks, these are provided for the purposes of
--   pragmatism and convenience.
module Database.Beam.Migrate.SQL.BeamExtensions

-- | Used to designate that a field should provide a default
--   auto-incrementing value.
--   
--   Usage:
--   
--   <pre>
--   field <a>Key</a> genericSerial
--   </pre>
--   
--   Then, when inserting into the table, you can use <tt>default_</tt> to
--   request the database automatically assign a new value to the column.
--   See <tt>runInsertReturning</tt> for another Beam extension that may
--   help if you want to know which value was assigned.
--   
--   Note that this is only provided for convenience. Backends often
--   implement auto-incrementing keys wildly differently. Many have
--   restrictions on where <a>genericSerial</a> may appear and may fail at
--   run-time if these conditions aren't met. Please refer to the backend
--   of your choice for more information.
class BeamMigrateSqlBackend be => BeamSqlBackendHasSerial be
genericSerial :: (BeamSqlBackendHasSerial be, FieldReturnType 'True 'False be (SqlSerial Int) a) => Text -> a


-- | Manual alternative to the <tt>CheckedDatabaseSettings</tt> mechanism.
--   
--   Database schemas are given as sequences of DDL commands expressed in a
--   <tt>beam-migrate</tt> DSL. The <tt>runMigrationSilenced</tt> function
--   can be used to recover the <tt>CheckedDatabaseSettings</tt> that
--   represents the database settings as well as the database predicates
--   corresponding to the sequence of DDL commands.
--   
--   This is often a more concise way of specifying a database schema when
--   your database names are wildly different from the defaults beam
--   assigns or you multiple constraints that make modifying the
--   auto-generated schema too difficult.
module Database.Beam.Migrate.SQL

-- | A table schema, produced by <tt>createTable</tt>
type TableSchema be tbl = tbl (TableFieldSchema be)

-- | A schema for a field within a given table
data TableFieldSchema be a
TableFieldSchema :: Text -> FieldSchema be a -> [FieldCheck] -> TableFieldSchema be a

-- | A schema for a field which hasn't been named yet
newtype FieldSchema be a
FieldSchema :: BeamSqlBackendColumnSchemaSyntax be -> FieldSchema be a
class (Typeable (BeamSqlBackendSyntax be), IsSql92DdlCommandSyntax (BeamSqlBackendSyntax be), Sql92SaneDdlCommandSyntaxMigrateOnly (BeamSqlBackendSyntax be), Sql92DisplaySyntax (BeamMigrateSqlBackendDataTypeSyntax be), Eq (BeamMigrateSqlBackendDataTypeSyntax be), Typeable (BeamMigrateSqlBackendDataTypeSyntax be), Sql92SerializableDataTypeSyntax (BeamMigrateSqlBackendDataTypeSyntax be), Sql92SerializableConstraintDefinitionSyntax (BeamSqlBackendColumnConstraintDefinitionSyntax be), Sql92DisplaySyntax (BeamSqlBackendColumnConstraintDefinitionSyntax be), Eq (BeamSqlBackendColumnConstraintDefinitionSyntax be), Typeable be) => BeamMigrateOnlySqlBackend be
type BeamMigrateSqlBackend be = (BeamMigrateOnlySqlBackend be, Sql92SaneDdlCommandSyntax (BeamSqlBackendSyntax be), BeamSqlBackend be)
type BeamMigrateSql99Backend be = (BeamMigrateSqlBackend be, IsSql99DataTypeSyntax (BeamSqlBackendDataTypeSyntax be))
type BeamSqlBackendConstraintSyntax be = Sql92DdlCommandColumnConstraintSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendColumnConstraintDefinitionSyntax be = Sql92DdlCommandConstraintDefinitionSyntax (BeamSqlBackendSyntax be)
type BeamMigrateSqlBackendDataTypeSyntax be = Sql92DdlCommandDataTypeSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendColumnSchemaSyntax be = Sql92DdlCommandColumnSchemaSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendAlterTableSyntax be = Sql92DdlCommandAlterTableSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendMatchTypeSyntax be = Sql92DdlCommandMatchTypeSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendReferentialActionSyntax be = Sql92DdlCommandReferentialActionSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendConstraintAttributesSyntax be = Sql92DdlCommandConstraintAttributesSyntax (BeamSqlBackendSyntax be)


-- | DDL syntax instances for <a>SqlSyntaxBuilder</a>
module Database.Beam.Migrate.SQL.Builder

-- | Options for <tt>CREATE TABLE</tt>. Given as a separate ADT because the
--   options may go in different places syntactically.
--   
--   You never really need to use this type directly.
data SqlSyntaxBuilderCreateTableOptions
SqlSyntaxBuilderCreateTableOptions :: SqlSyntaxBuilder -> SqlSyntaxBuilder -> SqlSyntaxBuilderCreateTableOptions

-- | Some backends use this to represent their constraint attributes. Does
--   not need to be used in practice.
data ConstraintAttributeTiming
InitiallyDeferred :: ConstraintAttributeTiming
InitiallyImmediate :: ConstraintAttributeTiming

-- | Valid <a>IsSql92ConstraintAttributesSyntax</a> shared among some
--   backends.
data SqlConstraintAttributesBuilder
SqlConstraintAttributesBuilder :: Maybe ConstraintAttributeTiming -> Maybe Bool -> SqlConstraintAttributesBuilder
[_sqlConstraintAttributeTiming] :: SqlConstraintAttributesBuilder -> Maybe ConstraintAttributeTiming
[_sqlConstraintAttributeDeferrable] :: SqlConstraintAttributesBuilder -> Maybe Bool

-- | Convert a <a>SqlConstraintAttributesBuilder</a> to its <tt>SQL92</tt>
--   representation in the returned <tt>ByteString</tt> <a>Builder</a>.
fromSqlConstraintAttributes :: SqlConstraintAttributesBuilder -> Builder

-- | Serialize a <a>SqlConstraintAttributesBuilder</a>
sqlConstraintAttributesSerialized :: SqlConstraintAttributesBuilder -> BeamSerializedConstraintAttributes
instance GHC.Classes.Eq Database.Beam.Migrate.SQL.Builder.SqlSyntaxBuilderCreateTableOptions
instance GHC.Enum.Bounded Database.Beam.Migrate.SQL.Builder.ConstraintAttributeTiming
instance GHC.Enum.Enum Database.Beam.Migrate.SQL.Builder.ConstraintAttributeTiming
instance GHC.Classes.Ord Database.Beam.Migrate.SQL.Builder.ConstraintAttributeTiming
instance GHC.Classes.Eq Database.Beam.Migrate.SQL.Builder.ConstraintAttributeTiming
instance GHC.Show.Show Database.Beam.Migrate.SQL.Builder.ConstraintAttributeTiming
instance GHC.Classes.Eq Database.Beam.Migrate.SQL.Builder.SqlConstraintAttributesBuilder
instance GHC.Show.Show Database.Beam.Migrate.SQL.Builder.SqlConstraintAttributesBuilder
instance GHC.Base.Semigroup Database.Beam.Migrate.SQL.Builder.SqlConstraintAttributesBuilder
instance GHC.Base.Monoid Database.Beam.Migrate.SQL.Builder.SqlConstraintAttributesBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ConstraintAttributesSyntax Database.Beam.Migrate.SQL.Builder.SqlConstraintAttributesBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnConstraintDefinitionSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92CreateTableSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92DdlCommandSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92DropTableSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92AlterTableSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92AlterTableActionSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92AlterColumnActionSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92TableConstraintSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnSchemaSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnConstraintSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92MatchTypeSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ReferentialActionSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.Sql92DisplaySyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder


-- | Support for creating checked databases from Haskell ADTs, using
--   <a>Generic</a>s.
--   
--   For more information, see <a>the manual</a>
module Database.Beam.Migrate.Generics

-- | Produce a checked database for the given Haskell database type
--   
--   See <a>the manual</a> for more information on the defaults.
defaultMigratableDbSettings :: forall be db. (Generic (CheckedDatabaseSettings be db), GAutoMigratableDb be (Rep (CheckedDatabaseSettings be db))) => CheckedDatabaseSettings be db

-- | Used to define a default SQL data type for a haskell type in a
--   particular backend, as well as any constraints that are needed
--   
--   Beam defines instances for several standard SQL types, which are
--   polymorphic over any standard data type syntax. Backends or extensions
--   which provide custom types should instantiate instances of this class
--   for any types they provide for which they would like checked schema
--   migrations
class BeamMigrateSqlBackend be => HasDefaultSqlDataType be ty

-- | Provide a data type for the given type
defaultSqlDataType :: HasDefaultSqlDataType be ty => Proxy ty -> Proxy be -> Bool -> BeamSqlBackendDataTypeSyntax be

-- | Provide arbitrary constraints on a field of the requested type. See
--   <a>FieldCheck</a> for more information on the formatting of
--   constraints.
defaultSqlDataTypeConstraints :: HasDefaultSqlDataType be ty => Proxy ty -> Proxy be -> Bool -> [FieldCheck]
class BeamMigrateSqlBackend be => HasNullableConstraint (x :: Bool) be
type family NullableStatus (x :: *) :: Bool


-- | Instances that allow us to use Haskell as a backend syntax. This
--   allows us to use migrations defined a la <a>SQL</a> to generate a beam
--   schema.
--   
--   Mainly of interest to backends.
--   
--   Unfortunately, we define some orphan <a>Hashable</a> instances that
--   aren't defined for us in <tt>haskell-src-exts</tt>.
module Database.Beam.Haskell.Syntax
newtype HsDbField
HsDbField :: (Type () -> Type ()) -> HsDbField
[buildHsDbField] :: HsDbField -> Type () -> Type ()
data HsConstraintDefinition
HsConstraintDefinition :: HsExpr -> HsConstraintDefinition
[hsConstraintDefinitionConstraint] :: HsConstraintDefinition -> HsExpr
newtype HsEntityName
HsEntityName :: String -> HsEntityName
[getHsEntityName] :: HsEntityName -> String
data HsImport
HsImportAll :: HsImport
HsImportSome :: Set (ImportSpec ()) -> HsImport
importSome :: Text -> [ImportSpec ()] -> HsImports
importTyNamed :: Text -> ImportSpec ()
importVarNamed :: Text -> ImportSpec ()
newtype HsImports
HsImports :: Map (ModuleName ()) HsImport -> HsImports
data HsDataType
HsDataType :: HsExpr -> HsType -> BeamSerializedDataType -> HsDataType
[hsDataTypeMigration] :: HsDataType -> HsExpr
[hsDataTypeType] :: HsDataType -> HsType
[hsDataTypeSerialized] :: HsDataType -> BeamSerializedDataType
data HsType
HsType :: Type () -> HsImports -> HsType
[hsTypeSyntax] :: HsType -> Type ()
[hsTypeImports] :: HsType -> HsImports
data HsExpr
HsExpr :: Exp () -> HsImports -> [Asst ()] -> Set (Name ()) -> HsExpr
[hsExprSyntax] :: HsExpr -> Exp ()
[hsExprImports] :: HsExpr -> HsImports
[hsExprConstraints] :: HsExpr -> [Asst ()]
[hsExprTypeVariables] :: HsExpr -> Set (Name ())
data HsColumnSchema
HsColumnSchema :: (Text -> HsExpr) -> HsType -> HsColumnSchema
[mkHsColumnSchema] :: HsColumnSchema -> Text -> HsExpr
[hsColumnSchemaType] :: HsColumnSchema -> HsType
data HsDecl
HsDecl :: Decl () -> HsImports -> [ExportSpec ()] -> HsDecl
[hsDeclSyntax] :: HsDecl -> Decl ()
[hsDeclImports] :: HsDecl -> HsImports
[hsDeclExports] :: HsDecl -> [ExportSpec ()]
data HsAction
HsAction :: [(Maybe (Pat ()), HsExpr)] -> [HsEntity] -> HsAction
[hsSyntaxMigration] :: HsAction -> [(Maybe (Pat ()), HsExpr)]
[hsSyntaxEntities] :: HsAction -> [HsEntity]
newtype HsBackendConstraint
HsBackendConstraint :: (Type () -> Asst ()) -> HsBackendConstraint
[buildHsBackendConstraint] :: HsBackendConstraint -> Type () -> Asst ()
data HsBeamBackend f
HsBeamBackendSingle :: HsType -> f -> HsBeamBackend f
HsBeamBackendConstrained :: [HsBackendConstraint] -> HsBeamBackend f
HsBeamBackendNone :: HsBeamBackend f
data HsEntity
HsEntity :: HsBeamBackend HsExpr -> HsEntityName -> [HsDecl] -> HsDbField -> HsExpr -> HsEntity
[hsEntityBackend] :: HsEntity -> HsBeamBackend HsExpr
[hsEntityName] :: HsEntity -> HsEntityName
[hsEntityDecls] :: HsEntity -> [HsDecl]
[hsEntityDbDecl] :: HsEntity -> HsDbField
[hsEntityExp] :: HsEntity -> HsExpr
newtype HsFieldLookup
HsFieldLookup :: (Text -> Maybe (Text, Type ())) -> HsFieldLookup
[hsFieldLookup] :: HsFieldLookup -> Text -> Maybe (Text, Type ())
newtype HsTableConstraint
HsTableConstraint :: (Text -> HsFieldLookup -> HsTableConstraintDecls) -> HsTableConstraint
data HsTableConstraintDecls
HsTableConstraintDecls :: [InstDecl ()] -> [HsDecl] -> HsTableConstraintDecls
[hsTableConstraintInstance] :: HsTableConstraintDecls -> [InstDecl ()]
[hsTableConstraintDecls] :: HsTableConstraintDecls -> [HsDecl]
data HsModule
HsModule :: String -> [HsEntity] -> [(Maybe (Pat ()), HsExpr)] -> HsModule
[hsModuleName] :: HsModule -> String
[hsModuleEntities] :: HsModule -> [HsEntity]
[hsModuleMigration] :: HsModule -> [(Maybe (Pat ()), HsExpr)]
hsActionsToModule :: String -> [HsAction] -> HsModule
unqual :: String -> QName ()
entityDbFieldName :: HsEntity -> String
derivingDecl :: [InstRule ()] -> Deriving ()
dataDecl :: DeclHead () -> [QualConDecl ()] -> Maybe (Deriving ()) -> Decl ()
insDataDecl :: Type () -> [QualConDecl ()] -> Maybe (Deriving ()) -> InstDecl ()
databaseTypeDecl :: [HsEntity] -> Decl ()
migrationTypeDecl :: HsBeamBackend HsExpr -> [Type ()] -> Decl ()
migrationDecl :: HsBeamBackend HsExpr -> [Exp ()] -> [(Maybe (Pat ()), HsExpr)] -> [HsEntity] -> Decl ()
dbTypeDecl :: HsBeamBackend HsExpr -> Decl ()
dbDecl :: HsBeamBackend HsExpr -> [HsExpr] -> Decl ()
renderHsSchema :: HsModule -> Either String String
data HsNone
HsNone :: HsNone
data HsMigrateBackend
HsMigrateBackend :: HsMigrateBackend
hsMkTableName :: (Char -> Char) -> TableName -> String
hsTableVarName :: TableName -> String
hsTableTypeName :: TableName -> String
hsErrorType :: String -> HsDataType
tyParens :: Type () -> Type ()
functionTy :: Type () -> Type () -> Type ()
tyTuple :: [Type ()] -> Type ()
tyApp :: Type () -> [Type ()] -> Type ()
tyConNamed :: String -> Type ()
tyVarNamed :: String -> Type ()
combineHsExpr :: (Exp () -> Exp () -> Exp ()) -> HsExpr -> HsExpr -> HsExpr
hsApp :: HsExpr -> [HsExpr] -> HsExpr
hsVisibleTyApp :: HsExpr -> Type () -> HsExpr
hsApApp :: HsExpr -> [HsExpr] -> HsExpr
hsStr :: Text -> HsExpr
hsRecCon :: Text -> [(Text, HsExpr)] -> HsExpr
hsMaybe :: Maybe HsExpr -> HsExpr
hsVar :: Text -> HsExpr
hsVarFrom :: Text -> Text -> HsExpr
hsTyCon :: Text -> HsExpr
hsInt :: (Integral a, Show a) => a -> HsExpr
hsOp :: Text -> QOp ()
hsInstance :: Text -> [Type ()] -> [InstDecl ()] -> Decl ()
hsDerivingInstance :: Text -> [Type ()] -> Decl ()
hsList :: [HsExpr] -> HsExpr
hsTuple :: [HsExpr] -> HsExpr
inst :: String -> InstRule ()
beamMigrateSqlBackend :: HsBackendConstraint
instance Data.String.IsString Database.Beam.Haskell.Syntax.HsEntityName
instance GHC.Classes.Ord Database.Beam.Haskell.Syntax.HsEntityName
instance GHC.Classes.Eq Database.Beam.Haskell.Syntax.HsEntityName
instance GHC.Show.Show Database.Beam.Haskell.Syntax.HsEntityName
instance GHC.Generics.Generic Database.Beam.Haskell.Syntax.HsImport
instance GHC.Classes.Eq Database.Beam.Haskell.Syntax.HsImport
instance GHC.Show.Show Database.Beam.Haskell.Syntax.HsImport
instance GHC.Classes.Eq Database.Beam.Haskell.Syntax.HsImports
instance GHC.Show.Show Database.Beam.Haskell.Syntax.HsImports
instance GHC.Generics.Generic Database.Beam.Haskell.Syntax.HsType
instance GHC.Classes.Eq Database.Beam.Haskell.Syntax.HsType
instance GHC.Show.Show Database.Beam.Haskell.Syntax.HsType
instance GHC.Generics.Generic Database.Beam.Haskell.Syntax.HsExpr
instance GHC.Classes.Eq Database.Beam.Haskell.Syntax.HsExpr
instance GHC.Show.Show Database.Beam.Haskell.Syntax.HsExpr
instance GHC.Generics.Generic Database.Beam.Haskell.Syntax.HsDataType
instance GHC.Show.Show Database.Beam.Haskell.Syntax.HsDataType
instance GHC.Classes.Eq Database.Beam.Haskell.Syntax.HsDataType
instance GHC.Generics.Generic Database.Beam.Haskell.Syntax.HsConstraintDefinition
instance GHC.Classes.Eq Database.Beam.Haskell.Syntax.HsConstraintDefinition
instance GHC.Show.Show Database.Beam.Haskell.Syntax.HsConstraintDefinition
instance GHC.Generics.Generic Database.Beam.Haskell.Syntax.HsNone
instance GHC.Classes.Ord Database.Beam.Haskell.Syntax.HsNone
instance GHC.Classes.Eq Database.Beam.Haskell.Syntax.HsNone
instance GHC.Show.Show Database.Beam.Haskell.Syntax.HsNone
instance Database.Beam.Migrate.SQL.Types.BeamMigrateOnlySqlBackend Database.Beam.Haskell.Syntax.HsMigrateBackend
instance Data.Hashable.Class.Hashable Database.Beam.Haskell.Syntax.HsNone
instance GHC.Base.Semigroup Database.Beam.Haskell.Syntax.HsNone
instance GHC.Base.Monoid Database.Beam.Haskell.Syntax.HsNone
instance Database.Beam.Migrate.SQL.SQL92.IsSql92AlterTableSyntax Database.Beam.Haskell.Syntax.HsAction
instance Database.Beam.Migrate.SQL.SQL92.IsSql92AlterTableActionSyntax Database.Beam.Haskell.Syntax.HsNone
instance Database.Beam.Migrate.SQL.SQL92.IsSql92AlterColumnActionSyntax Database.Beam.Haskell.Syntax.HsNone
instance Database.Beam.Migrate.SQL.SQL92.IsSql92CreateTableSyntax Database.Beam.Haskell.Syntax.HsAction
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnConstraintDefinitionSyntax Database.Beam.Haskell.Syntax.HsConstraintDefinition
instance Database.Beam.Migrate.SQL.SQL92.IsSql92MatchTypeSyntax Database.Beam.Haskell.Syntax.HsNone
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ReferentialActionSyntax Database.Beam.Haskell.Syntax.HsNone
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnConstraintSyntax Database.Beam.Haskell.Syntax.HsExpr
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ConstraintAttributesSyntax Database.Beam.Haskell.Syntax.HsNone
instance Database.Beam.Migrate.SQL.SQL92.IsSql92TableConstraintSyntax Database.Beam.Haskell.Syntax.HsTableConstraint
instance GHC.Base.Semigroup Database.Beam.Haskell.Syntax.HsTableConstraintDecls
instance GHC.Base.Monoid Database.Beam.Haskell.Syntax.HsTableConstraintDecls
instance GHC.Base.Semigroup Database.Beam.Haskell.Syntax.HsAction
instance GHC.Base.Monoid Database.Beam.Haskell.Syntax.HsAction
instance Database.Beam.Migrate.SQL.SQL92.IsSql92DdlCommandSyntax Database.Beam.Haskell.Syntax.HsAction
instance Database.Beam.Migrate.SQL.SQL92.IsSql92DropTableSyntax Database.Beam.Haskell.Syntax.HsAction
instance GHC.Base.Semigroup (Database.Beam.Haskell.Syntax.HsBeamBackend f)
instance GHC.Base.Monoid (Database.Beam.Haskell.Syntax.HsBeamBackend f)
instance GHC.Show.Show Database.Beam.Haskell.Syntax.HsColumnSchema
instance GHC.Classes.Eq Database.Beam.Haskell.Syntax.HsColumnSchema
instance Data.Hashable.Class.Hashable Database.Beam.Haskell.Syntax.HsColumnSchema
instance Database.Beam.Backend.SQL.SQL92.Sql92DisplaySyntax Database.Beam.Haskell.Syntax.HsColumnSchema
instance Database.Beam.Migrate.SQL.SQL92.IsSql92ColumnSchemaSyntax Database.Beam.Haskell.Syntax.HsColumnSchema
instance Data.Hashable.Class.Hashable Database.Beam.Haskell.Syntax.HsConstraintDefinition
instance Database.Beam.Backend.SQL.SQL92.Sql92DisplaySyntax Database.Beam.Haskell.Syntax.HsConstraintDefinition
instance Database.Beam.Migrate.SQL.SQL92.Sql92SerializableConstraintDefinitionSyntax Database.Beam.Haskell.Syntax.HsConstraintDefinition
instance Data.Hashable.Class.Hashable Database.Beam.Haskell.Syntax.HsDataType
instance Database.Beam.Backend.SQL.SQL92.Sql92DisplaySyntax Database.Beam.Haskell.Syntax.HsDataType
instance Database.Beam.Migrate.Checks.HasDataTypeCreatedCheck Database.Beam.Haskell.Syntax.HsDataType
instance Database.Beam.Backend.SQL.SQL92.IsSql92ExpressionSyntax Database.Beam.Haskell.Syntax.HsExpr
instance Database.Beam.Backend.SQL.SQL92.IsSql92DataTypeSyntax Database.Beam.Haskell.Syntax.HsDataType
instance Database.Beam.Backend.SQL.SQL99.IsSql99DataTypeSyntax Database.Beam.Haskell.Syntax.HsDataType
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003BinaryAndVarBinaryDataTypeSyntax Database.Beam.Haskell.Syntax.HsDataType
instance Database.Beam.Backend.SQL.SQL2003.IsSql2008BigIntDataTypeSyntax Database.Beam.Haskell.Syntax.HsDataType
instance Database.Beam.Migrate.SQL.SQL92.Sql92SerializableDataTypeSyntax Database.Beam.Haskell.Syntax.HsDataType
instance Data.Hashable.Class.Hashable Database.Beam.Haskell.Syntax.HsExpr
instance Database.Beam.Backend.SQL.SQL92.IsSql92ExtractFieldSyntax Database.Beam.Haskell.Syntax.HsExpr
instance Database.Beam.Backend.SQL.SQL92.IsSql92QuantifierSyntax Database.Beam.Haskell.Syntax.HsExpr
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Haskell.Syntax.HsExpr GHC.Int.Int32
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Haskell.Syntax.HsExpr GHC.Types.Bool
instance Database.Beam.Backend.SQL.SQL92.IsSql92FieldNameSyntax Database.Beam.Haskell.Syntax.HsExpr
instance Data.Hashable.Class.Hashable Database.Beam.Haskell.Syntax.HsType
instance Data.Hashable.Class.Hashable Database.Beam.Haskell.Syntax.HsImports
instance GHC.Base.Semigroup Database.Beam.Haskell.Syntax.HsImports
instance GHC.Base.Monoid Database.Beam.Haskell.Syntax.HsImports
instance Data.Hashable.Class.Hashable Database.Beam.Haskell.Syntax.HsImport
instance GHC.Base.Semigroup Database.Beam.Haskell.Syntax.HsImport
instance GHC.Base.Monoid Database.Beam.Haskell.Syntax.HsImport
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Exp ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.QName ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.ModuleName ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.IPName ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Asst ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Literal ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Name ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Type ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.QOp ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.TyVarBind ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Context ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.SpecialCon ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Pat ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Sign ())
instance Data.Hashable.Class.Hashable Language.Haskell.Exts.Syntax.Boxed
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Promoted ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Binds ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Splice ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.PatField ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Decl ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.DeclHead ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.IPBind ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.RPat ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Stmt ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.RPatOp ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.XName ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.ResultSig ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Alt ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Unpackedness ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.InjectivityInfo ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.PXAttr ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Rhs ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.FieldUpdate ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.TypeEqn ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.QualStmt ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.DataOrNew ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Bracket ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.QualConDecl ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.XAttr ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.ConDecl ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Deriving ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.InstRule ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.FieldDecl ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.GadtDecl ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.InstHead ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.FunDep ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.ClassDecl ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Overlap ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.InstDecl ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Assoc ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Op ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Match ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.PatternSynDirection ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.CallConv ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Safety ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Rule ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Activation ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.RuleVar ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Annotation ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.BooleanFormula ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Role ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.GuardedRhs ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.BangType ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.ImportSpec ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.Namespace ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.CName ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.DerivStrategy ())
instance Data.Hashable.Class.Hashable (Language.Haskell.Exts.Syntax.MaybePromotedName ())


-- | Data types and functions to discover sequences of DDL commands to go
--   from one database state to another. Used for migration generation.
--   
--   For our purposes, a database state is fully specified by the set of
--   predicates that apply to that database.
--   
--   Migration generation is approached as a graph search problem over the
--   infinite graph of databases <i>G</i>. The nodes of <i>G</i> are
--   database states, which (as said above) are simply sets of predicates
--   (see <a>DatabaseState</a> for the realization of this concept in
--   code). For two vertices <i>S1</i> and <i>S2</i> in <i>G</i>, there is
--   an edge between the two if and only if there is a DDL command that can
--   take a database at <i>S1</i> to <i>S2</i>.
--   
--   We generate migrations by exploring this graph, starting at the source
--   state and ending at the destination state. By default we use an
--   optimizing solver that weights each edge by the complexity of the
--   particular command, and we attempt to find the shortest path using
--   Dijkstra's algorithm, although a user may override this behavior and
--   provide a custom edge selection mechanism (or even defer this choice
--   to the user).
--   
--   In order to conduct the breadth-first search, we must know which edges
--   lead out of whichever vertex we're currently visiting. The solving
--   algorithm thus takes a set of <a>ActionProvider</a>s, which are means
--   of discovering edges that are incident to the current database state.
--   
--   Conceptually, an <a>ActionProvider</a> is a function of type
--   <a>ActionProviderFn</a>, which takes the current database state and
--   produces a list of edges in the form of <a>PotentialAction</a>
--   objects. For optimization purposes, <a>ActionProvider</a>s also take
--   in the desired destination state, which it can use to select only
--   edges that make sense. This does not affect the result, just the
--   amount of time it may take to get there.
--   
--   Note that because the graph of database states is infinite, a
--   breadth-first search may easily end up continuing to explore when
--   there is no chance of reaching our goal. This would result in
--   non-termination and is highly undesirable. In order to prevent this,
--   we limit ourselves to only exploring edges that take us <i>closer</i>
--   to the destination state. Here, we measure distance between two states
--   as the number of elements in the symmetric difference of two database
--   states. Thus, every action we take must either remove a predicate that
--   doesn't exist in the destination state, or add a predicate that does.
--   If a potential action only adds predicates that do not exist in the
--   final state or removes predicates that do not exist in the first, then
--   we never explore that edge.
--   
--   <h2>A note on speed</h2>
--   
--   There are some issues with this approach. Namely, if there is no
--   solution, we can end up exploring the entire action space, which may
--   be quite a lot. While <tt>beam-migrate</tt> can solve all databases
--   that can be made up of predicates in this module, other beam backends
--   may not make such strict guarantees (although in practice, all do).
--   Nevertheless, if you're hacking on this module and notice what seems
--   like an infinite loop, you may have accidentally removed code that
--   exposed the edge that leads to a solution to the migration.
module Database.Beam.Migrate.Actions

-- | Used to indicate whether a particular predicate is from the initial
--   database state, or due to a sequence of actions we've committed too.
--   Used to prevent runaway action generation based off of derived states.
data DatabaseStateSource

-- | Predicate is from the original set given by the user
DatabaseStateSourceOriginal :: DatabaseStateSource

-- | Predicate is from an action we've committed to in this action chain
DatabaseStateSourceDerived :: DatabaseStateSource

-- | Represents the state of a database as a migration is being generated
data DatabaseState be
DatabaseState :: !HashMap SomeDatabasePredicate DatabaseStateSource -> !HashSet SomeDatabasePredicate -> !Seq (MigrationCommand be) -> DatabaseState be

-- | The current set of predicates that apply to this database as well as
--   their source (user or from previous actions)
[dbStateCurrentState] :: DatabaseState be -> !HashMap SomeDatabasePredicate DatabaseStateSource

-- | HS.fromMap of <a>dbStateCurrentState</a>, for maximal sharing
[dbStateKey] :: DatabaseState be -> !HashSet SomeDatabasePredicate

-- | The current sequence of commands we've committed to in this state
[dbStateCmdSequence] :: DatabaseState be -> !Seq (MigrationCommand be)

-- | Represents an edge (or a path) in the database graph.
--   
--   Given a particular starting point, the destination database is the
--   database where each predicate in <a>actionPreConditions</a> has been
--   removed and each predicate in <a>actionPostConditions</a> has been
--   added.
data PotentialAction be
PotentialAction :: !HashSet SomeDatabasePredicate -> !HashSet SomeDatabasePredicate -> !Seq (MigrationCommand be) -> !Text -> {-# UNPACK #-} !Int -> PotentialAction be

-- | Preconditions that will no longer apply
[actionPreConditions] :: PotentialAction be -> !HashSet SomeDatabasePredicate

-- | Conditions that will apply after we're done
[actionPostConditions] :: PotentialAction be -> !HashSet SomeDatabasePredicate

-- | The sequence of commands that accomplish this movement in the database
--   graph. For an edge, <a>actionCommands</a> contains one command; for a
--   path, it will contain more.
[actionCommands] :: PotentialAction be -> !Seq (MigrationCommand be)

-- | An english description of the movement
[actionEnglish] :: PotentialAction be -> !Text

-- | A heuristic notion of complexity or weight; used to find the "easiest"
--   path through the graph.
[actionScore] :: PotentialAction be -> {-# UNPACK #-} !Int

-- | Edge discovery mechanism. A newtype wrapper over
--   <a>ActionProviderFn</a>.
--   
--   An <a>ActionProviderFn</a> takes two arguments. The first is the set
--   of predicates that exist in the current database.
--   
--   The function should a set of edges from the database specified in the
--   first argument to possible destination databases. For optimization
--   purposes, the second argument is the set of predicates that ought to
--   exist in the destination database. This can be used to eliminate edges
--   that will not lead to a solution.
--   
--   This second argument is just an optimization and doesn't change the
--   final result, although it can significantly impact the time it takes
--   to get there.
--   
--   Both the current database set and the destination database set are
--   given as polymorphic lists of predicates. When you instantiate the
--   type, the current database predicate set is queried for predicates of
--   that type.
--   
--   For example, <a>dropTableActionProvider</a> provides a <tt>DROP
--   TABLE</tt> action edge whenever it encounters a table that exists. In
--   order to do this, it attempts to find all <a>TableExistsPredicate</a>
--   that do not exist in the destination database. Its
--   <a>ActionProviderFn</a> may be implemented like such:
--   
--   <pre>
--   dropTableActionProvider preConditions postConditions = do
--       TableExistsPredicate srcTblNm &lt;- preConditions
--       ensuringNot_ $ $
--         do TableExistsPredicate destTblNm &lt;- postConditions
--            guard (srcTblNm == destTblNm)
--   </pre>
--   
--   <a>ensuringNot_</a> is a function that causes the action provider to
--   return no results if there are any elements in the provided list. In
--   this case, it's used to stop <tt>DROP TABLE</tt> action generation for
--   tables which must be present in the final database.
newtype ActionProvider be
ActionProvider :: ActionProviderFn be -> ActionProvider be
[getPotentialActions] :: ActionProvider be -> ActionProviderFn be

-- | See <a>ActionProvider</a>
type ActionProviderFn be = (forall preCondition. Typeable preCondition => [preCondition]) -> (forall postCondition. Typeable postCondition => [postCondition]) -> [PotentialAction be]

-- | Proceeds only if no predicate matches the given pattern. See the
--   implementation of <a>dropTableActionProvider</a> for an example of
--   usage.
ensuringNot_ :: Alternative m => [a] -> m ()

-- | Used to ensure that only one predicate matches the given pattern. See
--   the implementation of <a>createTableActionProvider</a> for an example
--   of usage.
justOne_ :: [a] -> [a]

-- | Action provider for SQL92 <tt>CREATE TABLE</tt> actions.
createTableActionProvider :: forall be. (Typeable be, BeamMigrateOnlySqlBackend be) => ActionProvider be

-- | Action provider for SQL92 <tt>DROP TABLE</tt> actions
dropTableActionProvider :: forall be. BeamMigrateOnlySqlBackend be => ActionProvider be

-- | Action provider for SQL92 <tt>ALTER TABLE ... ADD COLUMN ...</tt>
--   actions
addColumnProvider :: forall be. (Typeable be, BeamMigrateOnlySqlBackend be) => ActionProvider be

-- | Action provider for SQL92 <tt>ALTER TABLE ... ALTER COLUMN ... SET
--   NULL</tt>
addColumnNullProvider :: forall be. (Typeable be, BeamMigrateOnlySqlBackend be) => ActionProvider be

-- | Action provider for SQL92 <tt>ALTER TABLE ... ALTER COLUMN ... SET NOT
--   NULL</tt>
dropColumnNullProvider :: forall be. (Typeable be, BeamMigrateOnlySqlBackend be) => ActionProvider be

-- | Default action providers for any SQL92 compliant syntax.
--   
--   In particular, this provides edges consisting of the following
--   statements:
--   
--   <ul>
--   <li>CREATE TABLE</li>
--   <li>DROP TABLE</li>
--   <li>ALTER TABLE ... ADD COLUMN ...</li>
--   <li>ALTER TABLE ... DROP COLUMN ...</li>
--   <li>ALTER TABLE ... ALTER COLUMN ... SET [NOT] NULL</li>
--   </ul>
defaultActionProvider :: (Typeable be, BeamMigrateOnlySqlBackend be) => ActionProvider be

-- | Represents current state of a database graph search.
--   
--   If <a>ProvideSolution</a>, the destination database has been reached,
--   and the given list of commands provides the path from the source
--   database to the destination.
--   
--   If <a>SearchFailed</a>, the search has failed. The provided
--   <a>DatabaseState</a>s represent the closest we could make it to the
--   destination database. By default, only the best 10 are kept around (to
--   avoid unbounded memory growth).
--   
--   If <a>ChooseActions</a>, we are still searching. The caller is
--   provided with the current state as well as a list of actions, provided
--   as an opaque type <tt>f</tt>. The <a>getPotentialActionChoice</a>
--   function can be used to get the <a>PotentialAction</a> corresponding
--   to any given <tt>f</tt>. The caller is free to cull the set of
--   potential actions according however they'd like (for example, by
--   prompting the user). The selected actions to explore should be passed
--   to the <a>continueSearch</a> function.
--   
--   Use of the <tt>f</tt> existential type may seem obtuse, but it
--   prevents the caller from injecting arbitrary actions. Instead the
--   caller is limited to choosing only valid actions as provided by the
--   suppled <a>ActionProvider</a>.
data Solver cmd
[ProvideSolution] :: [MigrationCommand cmd] -> Solver cmd
[SearchFailed] :: [DatabaseState cmd] -> Solver cmd
[ChooseActions] :: {choosingActionsAtState :: !DatabaseState cmd " The current node we're searching at", getPotentialActionChoice :: f -> PotentialAction cmd " Convert the opaque @f@ type to a 'PotentialAction'. This can be used to present the actions to the user or to inspect the action to make a more informed choice on exploration strategies.", potentialActionChoices :: [f] " The possible actions that we can take, presented as an opaque list. Use the 'getPotentialActionChoice' function to get the corresponding 'PotentialAction'.", continueSearch :: [f] -> Solver cmd " Continue the search and get the next 'Solver'"} -> Solver cmd

-- | Represents the final results of a search
data FinalSolution be

-- | The search found a path from the source to the destination database,
--   and has provided a set of commands that would work
Solved :: [MigrationCommand be] -> FinalSolution be

-- | The search failed, but provided a set of <tt>DatbaseState</tt>s it
--   encountered that were the closest to the destination database. By
--   default, only 10 candidates are provided.
Candidates :: [DatabaseState be] -> FinalSolution be

-- | An exhaustive solving strategy that simply continues the search, while
--   exploring every possible action. If there is a solution, this will
--   find it.
finalSolution :: Solver be -> FinalSolution be

-- | Conduct a breadth-first search of the database graph to find a path
--   from the source database to the destination database, using the given
--   <a>ActionProvider</a> to discovere "edges" (i.e., DDL commands)
--   between the databases.
--   
--   See the documentation on <a>Solver</a> for more information on how to
--   consume the result.
heuristicSolver :: ActionProvider be -> [SomeDatabasePredicate] -> [SomeDatabasePredicate] -> Solver be
instance GHC.Generics.Generic Database.Beam.Migrate.Actions.DatabaseStateSource
instance GHC.Enum.Bounded Database.Beam.Migrate.Actions.DatabaseStateSource
instance GHC.Enum.Enum Database.Beam.Migrate.Actions.DatabaseStateSource
instance GHC.Classes.Ord Database.Beam.Migrate.Actions.DatabaseStateSource
instance GHC.Classes.Eq Database.Beam.Migrate.Actions.DatabaseStateSource
instance GHC.Show.Show Database.Beam.Migrate.Actions.DatabaseStateSource
instance GHC.Generics.Generic (Database.Beam.Migrate.Actions.MeasuredDatabaseState be)
instance GHC.Show.Show (Database.Beam.Backend.SQL.BeamSqlBackendSyntax be) => GHC.Show.Show (Database.Beam.Migrate.Actions.DatabaseState be)
instance GHC.Show.Show (Database.Beam.Backend.SQL.BeamSqlBackendSyntax be) => GHC.Show.Show (Database.Beam.Migrate.Actions.MeasuredDatabaseState be)
instance GHC.Show.Show (Database.Beam.Backend.SQL.BeamSqlBackendSyntax be) => GHC.Show.Show (Database.Beam.Migrate.Actions.FinalSolution be)
instance GHC.Base.Semigroup (Database.Beam.Migrate.Actions.ActionProvider be)
instance GHC.Base.Monoid (Database.Beam.Migrate.Actions.ActionProvider be)
instance GHC.Base.Semigroup (Database.Beam.Migrate.Actions.PotentialAction be)
instance GHC.Base.Monoid (Database.Beam.Migrate.Actions.PotentialAction be)
instance Control.DeepSeq.NFData (Database.Beam.Migrate.Actions.MeasuredDatabaseState cmd)
instance GHC.Classes.Eq (Database.Beam.Migrate.Actions.MeasuredDatabaseState cmd)
instance GHC.Classes.Ord (Database.Beam.Migrate.Actions.MeasuredDatabaseState cmd)
instance Control.DeepSeq.NFData (Database.Beam.Migrate.Actions.DatabaseState cmd)
instance Control.DeepSeq.NFData Database.Beam.Migrate.Actions.DatabaseStateSource


-- | Definitions of interest to those implement a new beam backend.
--   
--   Steps to defining a beam backend:
--   
--   <ol>
--   <li>Ensure the command syntax for your backend satisfies
--   <a>Sql92SaneDdlCommandSyntax</a>.</li>
--   <li>Create a value of type <a>BeamMigrationBackend</a></li>
--   <li>For compatibility with <tt>beam-migrate-cli</tt>, export this
--   value in an exposed module with the name
--   <tt>migrationBackend</tt>.</li>
--   </ol>
--   
--   This may sound trivial, but it's a bit more involved. In particular,
--   in order to complete step 2, you will have to define several instances
--   for some of your syntax pieces (for example, data types and
--   constraints will need to be <tt>Hashable</tt>). You will also need to
--   provide a reasonable function to fetch predicates from your database,
--   and a function to convert all these predicates to corresponding
--   predicates in the Haskell syntax. If you have custom data types or
--   predicates, you will need to supply <a>BeamDeserializers</a> to
--   deserialize them from JSON. Finally, if your backend has custom
--   <tt>DatabasePredicate</tt>s you will have to provide appropriate
--   <a>ActionProvider</a>s to discover potential actions for your backend.
--   See the documentation for <a>Database.Beam.Migrate.Actions</a> for
--   more information.
--   
--   Tools may be interested in the <a>SomeBeamMigrationBackend</a> data
--   type which provides a monomorphic type to wrap the polymorphic
--   <a>BeamMigrationBackend</a> type. Currently, <tt>beam-migrate-cli</tt>
--   uses this type to get the underlying <a>BeamMigrationBackend</a> via
--   the <tt>hint</tt> package.
--   
--   For an example migrate backend, see
--   <a>Database.Beam.Sqlite.Migrate</a>
module Database.Beam.Migrate.Backend

-- | Backends should create a value of this type and export it in an
--   exposed module under the name <tt>migrationBackend</tt>. See the
--   module documentation for more details.
data BeamMigrationBackend be m
[BeamMigrationBackend] :: (MonadBeam be m, MonadFail m, HasQBuilder be, BeamMigrateSqlBackend be, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be), BeamSqlBackendCanSerialize be LocalTime, BeamSqlBackendCanSerialize be (Maybe LocalTime), BeamSqlBackendCanSerialize be Text, BeamSqlBackendCanSerialize be SqlNull, Sql92ReasonableMarshaller be) => {backendName :: String, backendConnStringExplanation :: String, backendGetDbConstraints :: m [SomeDatabasePredicate], backendPredicateParsers :: BeamDeserializers be, backendRenderSyntax :: BeamSqlBackendSyntax be -> String, backendFileExtension :: String, backendConvertToHaskell :: HaskellPredicateConverter, backendActionProvider :: ActionProvider be, backendTransact :: forall a. String -> m a -> IO (Either DdlError a)} -> BeamMigrationBackend be m

-- | Type of errors that can be thrown by backends during DDL statement
--   execution. Currently just a synonym for <a>String</a>
type DdlError = String

-- | In order to support Haskell schema generation, backends need to
--   provide a way to convert arbitrary <tt>DatabasePredicate</tt>s
--   generated by the backend's <a>backendGetDbConstraints</a> function
--   into appropriate predicates in the Haskell syntax. Not all predicates
--   have any meaning when translated to Haskell, so backends can choose to
--   drop any predicate (simply return <a>Nothing</a>).
newtype HaskellPredicateConverter
HaskellPredicateConverter :: (SomeDatabasePredicate -> Maybe SomeDatabasePredicate) -> HaskellPredicateConverter

-- | Converters for the <a>TableExistsPredicate</a>,
--   <a>TableHasPrimaryKey</a>, and <a>TableHasColumn</a> (when supplied
--   with a function to convert a backend data type to a haskell one).
sql92HsPredicateConverters :: forall fromBe. Typeable fromBe => (BeamMigrateSqlBackendDataTypeSyntax fromBe -> Maybe HsDataType) -> HaskellPredicateConverter

-- | Converter for <a>TableHasColumn</a>, when given a function to convert
--   backend data type to a haskell one.
hasColumnConverter :: forall fromBe. Typeable fromBe => (BeamMigrateSqlBackendDataTypeSyntax fromBe -> Maybe HsDataType) -> HaskellPredicateConverter

-- | Some predicates have no dependence on a backend. For example,
--   <a>TableExistsPredicate</a> has no parameters that depend on the
--   backend. It can be converted straightforwardly:
--   
--   <pre>
--   trivialHsConverter @TableExistsPredicate
--   </pre>
trivialHsConverter :: forall pred. Typeable pred => HaskellPredicateConverter

-- | Utility function for converting a monomorphically typed predicate to a
--   haskell one.
hsPredicateConverter :: Typeable pred => (pred -> Maybe SomeDatabasePredicate) -> HaskellPredicateConverter

-- | Monomorphic wrapper for use with plugin loaders that cannot handle
--   polymorphism
data SomeBeamMigrationBackend
[SomeBeamMigrationBackend] :: Typeable be => BeamMigrationBackend be m -> SomeBeamMigrationBackend

-- | Monomorphic wrapper to use when interpreting a module which exports a
--   <a>CheckedDatabaseSettings</a>.
data SomeCheckedDatabaseSettings
[SomeCheckedDatabaseSettings] :: Database be db => CheckedDatabaseSettings be db -> SomeCheckedDatabaseSettings
instance GHC.Base.Semigroup Database.Beam.Migrate.Backend.HaskellPredicateConverter
instance GHC.Base.Monoid Database.Beam.Migrate.Backend.HaskellPredicateConverter


-- | Top-level module import for <tt>beam-migrate</tt>.
--   
--   This is most often the only module you want to import, unless you're
--   extending <tt>beam-migrate</tt>, implementing migrations support in a
--   backend, or writing tooling. If you are doing any of these things,
--   please see the Advanced features section below.
--   
--   The key abstractions in <tt>beam-migrate</tt> are the <i>checked
--   database</i> and the <i>migration</i>.
--   
--   <h2>Checked databases</h2>
--   
--   A checked database is similar to the <tt>DatabaseSettings</tt> type
--   from <tt>beam-core</tt> except it comes with a set of
--   <i>predicates</i>. Whereas a <tt>DatabaseSettings</tt> object consists
--   of a set of database entities, a checked database (represented by the
--   <a>CheckedDatabaseSettings</a> type) consists of a set of database
--   entities along with a set of <i>predicates</i> (represented by types
--   implementing <a>DatabasePredicate</a>). The <i>predicates</i> are
--   facts about a given database schema. For example, a checked database
--   with a table named <a>Customers</a>, would have a
--   <a>TableExistsPredicate</a> in its predicate set.
--   
--   Predicates can be used to verify that a given beam schema is
--   compatible with a backend database or to generate migrations from a
--   schema satisfying one set of predicates to a schema satisfying
--   another. Beam migrate provides a solver for figuring out the exact
--   sequence of steps needed to accomplish this. Beam backends can provide
--   additional predicates and solvers to implement backend-specific
--   migrations. For example, the <tt>beam-postgres</tt> backend provides
--   predicates to assert that extensions have been loaded, and solvers for
--   emitting proper <tt>CREATE EXTENSION</tt> statements where
--   appropriate.
--   
--   Predicates may also be serialized to disk in JSON format, providing an
--   easy means to detect significant changes in a beam schema.
--   
--   As one final point, <tt>beam-migrate</tt> can generate schemas in any
--   beam-supported SQL DDL syntax. The <tt>beam-migrate</tt> module
--   provides a DDL syntax for Haskell in
--   <a>Database.Beam.Haskell.Syntax</a>. This allows <tt>beam-migrate</tt>
--   to translate predicate sets into the corresponding Haskell schema and
--   the corresponding Haskell migration script. This reflection allows
--   tools based off of <tt>beam-migrate</tt> to support schema generation
--   from an existing database.
--   
--   For more information on checked databases, see the
--   <a>Database.Beam.Migrate.Checks</a> module.
--   
--   <h2>Migrations</h2>
--   
--   A migration is a value of type 'MigrationSteps a b', where <tt>a</tt>
--   and <tt>b</tt> are database types. Conceptually, a value of this type
--   is a list of DDL commands which can be used to bring a database of
--   type <tt>a</tt> to a database of type <tt>b</tt>. For example, if
--   <tt>b</tt> is a database type containing all the tables as <tt>a</tt>,
--   but with a new table added, a migration with type 'MigrationSteps a b'
--   may represent a SQL <tt>CREATE TABLE</tt> statement. Migrations can
--   sometimes be reversed to produce a value of type 'MigrationSteps b a'.
--   In our example, the corresponding reversed migration may be the
--   appropriate <tt>DROP TABLE</tt> statement.
--   
--   Migration steps can used to modify a database schema, generate a
--   migration script in a given backend syntax, or generate an appropriate
--   <tt>DatabaseSettings</tt> object for use with the rest of the beam
--   ecosystem.
--   
--   For more information in migrations see
--   <a>Database.Beam.Migrate.Types</a>
--   
--   <h2>Syntax</h2>
--   
--   For low-level access to the underlying SQL syntax builders, see
--   <a>Database.Beam.Migrate.SQL.SQL92</a>
--   
--   <h2>Advanced features</h2>
--   
--   If you are writing a new beam backend, you will need to construct a
--   value of type <tt>BeamBackend</tt>. See that module for more
--   information.
--   
--   If you are writing tooling, you will likely need to consume
--   <tt>BeamBackend</tt>. You will likely also be interested in the
--   migration generation. See the documentation on <a>heuristicSolver</a>.
module Database.Beam.Migrate


-- | Contains a schema for beam migration tools. Used by the CLI and the
--   managed migrations support here.
module Database.Beam.Migrate.Log
data LogEntryT f
LogEntry :: C f Int32 -> C f Text -> C f LocalTime -> LogEntryT f
[_logEntryId] :: LogEntryT f -> C f Int32
[_logEntryCommitId] :: LogEntryT f -> C f Text
[_logEntryDate] :: LogEntryT f -> C f LocalTime
type LogEntry = LogEntryT Identity
type LogEntryKey = PrimaryKey LogEntryT Identity
newtype BeamMigrateVersionT f
BeamMigrateVersion :: C f Int32 -> BeamMigrateVersionT f
[_beamMigrateVersion] :: BeamMigrateVersionT f -> C f Int32
type BeamMigrateVersion = BeamMigrateVersionT Identity
type BeamMigrateVersionKey = PrimaryKey BeamMigrateVersionT Identity
data BeamMigrateDb entity
BeamMigrateDb :: entity (TableEntity BeamMigrateVersionT) -> entity (TableEntity LogEntryT) -> BeamMigrateDb entity
[_beamMigrateVersionTbl] :: BeamMigrateDb entity -> entity (TableEntity BeamMigrateVersionT)
[_beamMigrateLogEntries] :: BeamMigrateDb entity -> entity (TableEntity LogEntryT)
beamMigratableDb :: forall be m. (BeamMigrateSqlBackend be, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be), MonadBeam be m) => CheckedDatabaseSettings be BeamMigrateDb
beamMigrateDb :: forall be m. (BeamMigrateSqlBackend be, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be), MonadBeam be m) => DatabaseSettings be BeamMigrateDb
beamMigrateDbMigration :: forall be m. (BeamMigrateSqlBackend be, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be), MonadBeam be m) => Migration be (CheckedDatabaseSettings be BeamMigrateDb)
beamMigrateSchemaVersion :: Int32
getLatestLogEntry :: forall be m. (BeamMigrateSqlBackend be, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be), BeamSqlBackendCanDeserialize be Int32, BeamSqlBackendCanDeserialize be LocalTime, BeamSqlBackendSupportsDataType be Text, HasQBuilder be, MonadBeam be m) => m (Maybe LogEntry)
updateSchemaToCurrent :: forall be m. (BeamMigrateSqlBackend be, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be), BeamSqlBackendCanSerialize be Text, MonadBeam be m) => m ()
recordCommit :: forall be m. (BeamMigrateSqlBackend be, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be), BeamSqlBackendSupportsDataType be Text, BeamSqlBackendCanDeserialize be Int32, BeamSqlBackendCanDeserialize be LocalTime, HasQBuilder be, MonadBeam be m) => UUID -> m ()
ensureBackendTables :: forall be m. (BeamSqlBackendCanSerialize be Text, MonadFail m) => BeamMigrationBackend be m -> m ()
checkForBackendTables :: BeamMigrationBackend be m -> m Bool
instance GHC.Generics.Generic (Database.Beam.Migrate.Log.LogEntryT f)
instance GHC.Generics.Generic (Database.Beam.Schema.Tables.PrimaryKey Database.Beam.Migrate.Log.LogEntryT f)
instance GHC.Generics.Generic (Database.Beam.Migrate.Log.BeamMigrateVersionT f)
instance GHC.Generics.Generic (Database.Beam.Schema.Tables.PrimaryKey Database.Beam.Migrate.Log.BeamMigrateVersionT f)
instance GHC.Generics.Generic (Database.Beam.Migrate.Log.BeamMigrateDb entity)
instance GHC.Show.Show Database.Beam.Migrate.Log.LogEntry
instance GHC.Show.Show Database.Beam.Migrate.Log.LogEntryKey
instance GHC.Show.Show Database.Beam.Migrate.Log.BeamMigrateVersion
instance GHC.Show.Show Database.Beam.Migrate.Log.BeamMigrateVersionKey
instance Database.Beam.Schema.Tables.Database be Database.Beam.Migrate.Log.BeamMigrateDb
instance Database.Beam.Schema.Tables.Beamable Database.Beam.Migrate.Log.BeamMigrateVersionT
instance Database.Beam.Schema.Tables.Table Database.Beam.Migrate.Log.BeamMigrateVersionT
instance Database.Beam.Schema.Tables.Beamable (Database.Beam.Schema.Tables.PrimaryKey Database.Beam.Migrate.Log.BeamMigrateVersionT)
instance Database.Beam.Schema.Tables.Beamable Database.Beam.Migrate.Log.LogEntryT
instance Database.Beam.Schema.Tables.Table Database.Beam.Migrate.Log.LogEntryT
instance Database.Beam.Schema.Tables.Beamable (Database.Beam.Schema.Tables.PrimaryKey Database.Beam.Migrate.Log.LogEntryT)


-- | Utility functions for common use cases
module Database.Beam.Migrate.Simple

-- | Given a <a>BeamMigrationBackend</a>, attempt to automatically bring
--   the current database up-to-date with the given
--   <a>CheckedDatabaseSettings</a>. Fails (via <a>fail</a>) if this
--   involves an irreversible migration (one that may result in data loss).
autoMigrate :: (Database be db, MonadFail m) => BeamMigrationBackend be m -> CheckedDatabaseSettings be db -> m ()

-- | Attempt to find a SQL schema given an <a>ActionProvider</a> and a
--   checked database. Returns <a>Nothing</a> if no schema could be found,
--   which usually means you have chosen the wrong <a>ActionProvider</a>,
--   or the backend you're using is buggy.
simpleSchema :: Database be db => ActionProvider be -> CheckedDatabaseSettings be db -> Maybe [BeamSqlBackendSyntax be]

-- | Given a migration backend, a handle to a database, and a checked
--   database, attempt to find a schema. This should always return
--   <a>Just</a>, unless the backend has incomplete migrations support.
--   
--   <a>BeamMigrationBackend</a>s can usually be found in a module named
--   <tt>Database.Beam.<a>Backend</a>.Migrate</tt> with the
--   name<tt>migrationBackend</tt>
simpleMigration :: (MonadBeam be m, Database be db) => (forall a. handle -> m a -> IO a) -> BeamMigrationBackend be m -> handle -> CheckedDatabaseSettings be db -> IO (Maybe [BeamSqlBackendSyntax be])

-- | Run a sequence of commands on a database
runSimpleMigration :: MonadBeam be m => (forall a. hdl -> m a -> IO a) -> hdl -> [BeamSqlBackendSyntax be] -> IO ()

-- | Given a function to convert a command to a <a>String</a>, produce a
--   script that will execute the given migration. Usually, the function
--   you provide eventually calls <a>displaySyntax</a> to rendere the
--   command.
backendMigrationScript :: BeamSqlBackend be => (BeamSqlBackendSyntax be -> String) -> Migration be a -> String

-- | Result type for <a>verifySchema</a>
data VerificationResult
VerificationSucceeded :: VerificationResult
VerificationFailed :: [SomeDatabasePredicate] -> VerificationResult

-- | Verify that the given, beam database matches the actual schema. On
--   success, returns <a>VerificationSucceeded</a>, on failure, returns
--   <a>VerificationFailed</a> and a list of missing predicates.
verifySchema :: (Database be db, MonadBeam be m) => BeamMigrationBackend be m -> CheckedDatabaseSettings be db -> m VerificationResult

-- | Selects a class of predicates to ignore if detected (e.g. metadata
--   tables for migrations, other schemas, etc.).
newtype IgnorePredicates
IgnorePredicates :: (SomeDatabasePredicate -> Any) -> IgnorePredicates
[unIgnorePredicates] :: IgnorePredicates -> SomeDatabasePredicate -> Any

-- | Result type for <a>checkSchema</a>
data CheckResult
CheckResult :: HashSet SomeDatabasePredicate -> HashSet SomeDatabasePredicate -> CheckResult

-- | Expected predicates from the <a>CheckedDatabaseSettings</a> which were
--   not found in the live database
[missingPredicates] :: CheckResult -> HashSet SomeDatabasePredicate

-- | Predicates found in the live database which are not present in the
--   <a>CheckedDatabaseSettings</a> and are not ignored
[unexpectedPredicates] :: CheckResult -> HashSet SomeDatabasePredicate

-- | Ignore predicates relating to tables matching the given name
--   predicate.
ignoreTables :: (QualifiedName -> Bool) -> IgnorePredicates

-- | Ignore any unknown predicates. This probably only makes sense to use
--   if you are only querying and not writing to the database.
ignoreAll :: IgnorePredicates

-- | Checks the given database settings against the live database. This is
--   similar to <a>verifySchema</a>, but detects and returns unknown
--   predicates that are true about the live database (e.g. unknown tables,
--   fields, etc.).
checkSchema :: (Database be db, Monad m) => BeamMigrationBackend be m -> CheckedDatabaseSettings be db -> IgnorePredicates -> m CheckResult

-- | Given a <a>CheckedDatabaseSettings</a> and a
--   <a>BeamMigrationBackend</a>, attempt to create the schema from scratch
--   in the current database.
--   
--   May <a>fail</a> if we cannot find a schema
createSchema :: (Database be db, MonadFail m) => BeamMigrationBackend be m -> CheckedDatabaseSettings be db -> m ()
data BringUpToDateHooks m
BringUpToDateHooks :: m Bool -> (Int -> Text -> m ()) -> (Int -> Text -> m ()) -> (Int -> String -> m ()) -> m () -> (Int -> m ()) -> (Int -> Text -> Text -> m ()) -> (Int -> m ()) -> BringUpToDateHooks m

-- | Called before we're about to run an irreversible migration step.
--   Return <a>True</a> to run the step, or <a>False</a> to abort
--   immediately.
[runIrreversibleHook] :: BringUpToDateHooks m -> m Bool

-- | Called at the beginning of each step with the step index and
--   description
[startStepHook] :: BringUpToDateHooks m -> Int -> Text -> m ()

-- | Called at the end of each step with the step index and description
[endStepHook] :: BringUpToDateHooks m -> Int -> Text -> m ()

-- | Called before a command is about to run. The first argument is the
--   step index and the second is a string representing the command about
--   to be run.
[runCommandHook] :: BringUpToDateHooks m -> Int -> String -> m ()

-- | Called when a query fails
[queryFailedHook] :: BringUpToDateHooks m -> m ()

-- | Called when the migration log has a discontinuity at the supplied
--   index
[discontinuousMigrationsHook] :: BringUpToDateHooks m -> Int -> m ()

-- | The migration log at the given index is not what was expected. The
--   first text is the actual commit id, the second, the expected
[logMismatchHook] :: BringUpToDateHooks m -> Int -> Text -> Text -> m ()

-- | The database is ahead of the given migrations. The parameter supplies
--   the number of entries passed the given migrations the database has.
[databaseAheadHook] :: BringUpToDateHooks m -> Int -> m ()

-- | Default set of <a>BringUpToDateHooks</a>. Refuses to run irreversible
--   migrations, and fails in case of error, using <a>fail</a>.
defaultUpToDateHooks :: MonadFail m => BringUpToDateHooks m

-- | Equivalent to calling <a>bringUpToDateWithHooks</a> with
--   <a>defaultUpToDateHooks</a>.
--   
--   Tries to bring the database up to date, using the database log and the
--   given <a>MigrationSteps</a>. Fails if the migration is irreversible,
--   or an error occurs.
bringUpToDate :: (Database be db, MonadFail m, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)) => BeamMigrationBackend be m -> MigrationSteps be () (CheckedDatabaseSettings be db) -> m (Maybe (CheckedDatabaseSettings be db))

-- | Check for the beam-migrate log. If it exists, use it and the supplied
--   migrations to bring the database up-to-date. Otherwise, create the log
--   and run all migrations.
--   
--   Accepts a set of hooks that can be used to customize behavior. See the
--   documentation for <a>BringUpToDateHooks</a> for more information.
--   Calling this with <a>defaultUpToDateHooks</a> is the same as using
--   <a>bringUpToDate</a>.
bringUpToDateWithHooks :: forall db be m. (Database be db, MonadFail m, HasDataTypeCreatedCheck (BeamMigrateSqlBackendDataTypeSyntax be)) => BringUpToDateHooks m -> BeamMigrationBackend be m -> MigrationSteps be () (CheckedDatabaseSettings be db) -> m (Maybe (CheckedDatabaseSettings be db))

-- | Given a <a>BeamMigrationBackend</a>, get a string representing a
--   Haskell module that would be a good starting point for further
--   development.
--   
--   For example, for a postgres database named <tt>chinook</tt>
--   
--   <pre>
--   import Database.Beam.Migrate.Simple
--   import Database.Beam.Postgres (runBeamPostgres)
--   import Database.Beam.Postgres.Migrate (migrationBackend)
--   import Database.PostgreSQL.Simple
--   
--   getSchema :: IO String
--   getSchema = do pg &lt;- connectPostgreSQL
--                  runBeamPostgres pg (haskellSchema migrationBackend)
--   </pre>
--   
--   Backends that have a migration backend typically export it under the
--   module name <tt>Database.Beam.<i>Backend</i>.Migrate</tt>.
haskellSchema :: (MonadBeam be m, MonadFail m) => BeamMigrationBackend be m -> m String
instance GHC.Show.Show Database.Beam.Migrate.Simple.VerificationResult
instance GHC.Show.Show Database.Beam.Migrate.Simple.CheckResult
instance GHC.Classes.Eq Database.Beam.Migrate.Simple.CheckResult
instance GHC.Base.Monoid Database.Beam.Migrate.Simple.IgnorePredicates
instance GHC.Base.Semigroup Database.Beam.Migrate.Simple.IgnorePredicates
