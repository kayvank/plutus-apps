-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | QuickCheck common typeclasses
--   
--   This library provides QuickCheck properties to ensure that typeclass
--   instances adhere to the set of laws that they are supposed to. There
--   are other libraries that do similar things, such as
--   `genvalidity-hspec` and <a>checkers</a>. This library differs from
--   other solutions by not introducing any new typeclasses that the user
--   needs to learn.
--   
--   <i>Note:</i> on GHC &lt; 8.5, this library uses the higher-kinded
--   typeclasses (<a>Data.Functor.Classes.Show1</a>,
--   <a>Data.Functor.Classes.Eq1</a>, <a>Data.Functor.Classes.Ord1</a>,
--   etc.), but on GHC &gt;= 8.5, it uses `-XQuantifiedConstraints` to
--   express these constraints more cleanly.
@package quickcheck-classes
@version 0.6.5.0

module Test.QuickCheck.Classes.IsList


-- | This library provides sets of properties that should hold for common
--   typeclasses.
--   
--   <i>Note:</i> on GHC &lt; 8.6, this library uses the higher-kinded
--   typeclasses (<a>Show1</a>, <a>Eq1</a>, <a>Ord1</a>, etc.), but on GHC
--   &gt;= 8.6, it uses <tt>-XQuantifiedConstraints</tt> to express these
--   constraints more cleanly.
module Test.QuickCheck.Classes

-- | A convenience function for testing properties in GHCi. For example, at
--   GHCi:
--   
--   <pre>
--   &gt;&gt;&gt; lawsCheck (monoidLaws (Proxy :: Proxy Ordering))
--   Monoid: Associative +++ OK, passed 100 tests.
--   Monoid: Left Identity +++ OK, passed 100 tests.
--   Monoid: Right Identity +++ OK, passed 100 tests.
--   </pre>
--   
--   Assuming that the <a>Arbitrary</a> instance for <a>Ordering</a> is
--   good, we now have confidence that the <a>Monoid</a> instance for
--   <a>Ordering</a> satisfies the monoid laws.
lawsCheck :: Laws -> IO ()

-- | A convenience function for checking multiple typeclass instances of
--   multiple types. Consider the following Haskell source file:
--   
--   <pre>
--   import Data.Proxy (Proxy(..))
--   import Data.Map (Map)
--   import Data.Set (Set)
--   
--   -- A <a>Proxy</a> for <tt>Set</tt> <a>Int</a>.
--   setInt :: Proxy (Set Int)
--   setInt = Proxy
--   
--   -- A <a>Proxy</a> for <tt>Map</tt> <a>Int</a> <a>Int</a>.
--   mapInt :: Proxy (Map Int Int)
--   mapInt = Proxy
--   
--   myLaws :: Proxy a -&gt; [Laws]
--   myLaws p = [eqLaws p, monoidLaws p]
--   
--   namedTests :: [(String, [Laws])]
--   namedTests =
--     [ ("Set Int", myLaws setInt)
--     , ("Map Int Int", myLaws mapInt)
--     ]
--   </pre>
--   
--   Now, in GHCi:
--   
--   <pre>
--   &gt;&gt;&gt; lawsCheckMany namedTests
--   </pre>
--   
--   <pre>
--   Testing properties for common typeclasses
--   -------------
--   -- Set Int --
--   -------------
--   
--   Eq: Transitive +++ OK, passed 100 tests.
--   Eq: Symmetric +++ OK, passed 100 tests.
--   Eq: Reflexive +++ OK, passed 100 tests.
--   Monoid: Associative +++ OK, passed 100 tests.
--   Monoid: Left Identity +++ OK, passed 100 tests.
--   Monoid: Right Identity +++ OK, passed 100 tests.
--   Monoid: Concatenation +++ OK, passed 100 tests.
--   
--   -----------------
--   -- Map Int Int --
--   -----------------
--   
--   Eq: Transitive +++ OK, passed 100 tests.
--   Eq: Symmetric +++ OK, passed 100 tests.
--   Eq: Reflexive +++ OK, passed 100 tests.
--   Monoid: Associative +++ OK, passed 100 tests.
--   Monoid: Left Identity +++ OK, passed 100 tests.
--   Monoid: Right Identity +++ OK, passed 100 tests.
--   Monoid: Concatenation +++ OK, passed 100 tests.
--   </pre>
--   
--   In the case of a failing test, the program terminates with exit code
--   1.
lawsCheckMany :: [(String, [Laws])] -> IO ()

-- | A convenience function that allows one to check many typeclass
--   instances of the same type.
--   
--   <pre>
--   &gt;&gt;&gt; specialisedLawsCheckMany (Proxy :: Proxy Word) [jsonLaws, showReadLaws]
--   ToJSON/FromJSON: Encoding Equals Value +++ OK, passed 100 tests.
--   ToJSON/FromJSON: Partial Isomorphism +++ OK, passed 100 tests.
--   Show/Read: Partial Isomorphism +++ OK, passed 100 tests.
--   </pre>
lawsCheckOne :: Proxy a -> [Proxy a -> Laws] -> IO ()

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Conjunction Idempotence</i></i> <tt>n .&amp;. n ≡
--   n</tt></li>
--   <li><i><i>Disjunction Idempotence</i></i> <tt>n .|. n ≡ n</tt></li>
--   <li><i><i>Double Complement</i></i> <tt>complement (complement n) ≡
--   n</tt></li>
--   <li><i><i>Set Bit</i></i> <tt>setBit n i ≡ n .|. bit i</tt></li>
--   <li><i><i>Clear Bit</i></i> <tt>clearBit n i ≡ n .&amp;. complement
--   (bit i)</tt></li>
--   <li><i><i>Complement Bit</i></i> <tt>complementBit n i ≡ xor n (bit
--   i)</tt></li>
--   <li><i><i>Clear Zero</i></i> <tt>clearBit zeroBits i ≡
--   zeroBits</tt></li>
--   <li><i><i>Set Zero</i></i> <tt>setBit zeroBits i ≡ bit i</tt></li>
--   <li><i><i>Test Zero</i></i> <tt>testBit zeroBits i ≡ False</tt></li>
--   <li><i><i>Pop Zero</i></i> <tt>popCount zeroBits ≡ 0</tt></li>
--   <li><i><i>Right Rotation</i></i> <tt>no sign extension → (rotateR n i
--   ≡ (shiftR n i) .|. (shiftL n (finiteBitSize ⊥ - i)))</tt></li>
--   <li><i><i>Left Rotation</i></i> <tt>no sign extension → (rotateL n i ≡
--   (shiftL n i) .|. (shiftR n (finiteBitSize ⊥ - i)))</tt></li>
--   <li><i><i>Count Leading Zeros of Zero</i></i> <tt>countLeadingZeros
--   zeroBits ≡ finiteBitSize ⊥</tt></li>
--   <li><i><i>Count Trailing Zeros of Zero</i></i> <tt>countTrailingZeros
--   zeroBits ≡ finiteBitSize ⊥</tt></li>
--   </ul>
--   
--   All of the useful instances of the <a>Bits</a> typeclass also have
--   <a>FiniteBits</a> instances, so these property tests actually require
--   that instance as well.
--   
--   <i>Note:</i> This property test is only available when using
--   <tt>base-4.7</tt> or newer.
bitsLaws :: (FiniteBits a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Transitive</i></i> <tt>a <a>==</a> b ∧ b <a>==</a> c ⇒ a
--   <a>==</a> c</tt></li>
--   <li><i><i>Symmetric</i></i> <tt>a <a>==</a> b ⇒ b <a>==</a>
--   a</tt></li>
--   <li><i><i>Reflexive</i></i> <tt>a <a>==</a> a</tt></li>
--   <li><i><i>Negation</i></i> <tt>x <a>/=</a> y <a>==</a> <a>not</a> (x
--   <a>==</a> y)</tt></li>
--   </ul>
--   
--   Some of these properties involve implication. In the case that the
--   left hand side of the implication arrow does not hold, we do not
--   retry. Consequently, these properties only end up being useful when
--   the data type has a small number of inhabitants.
eqLaws :: (Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Substitutive</i></i> <tt>x <a>==</a> y ⇒ f x <a>==</a> f
--   y</tt></li>
--   </ul>
--   
--   <i>Note</i>: This does not test <a>eqLaws</a>. If you want to use
--   this, You should use it in addition to <a>eqLaws</a>.
substitutiveEqLaws :: (Eq a, Arbitrary a, CoArbitrary a, Function a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Additive Commutativity</i></i> <tt>a + b ≡ b + a</tt></li>
--   <li><i><i>Additive Left Identity</i></i> <tt>0 + a ≡ a</tt></li>
--   <li><i><i>Additive Right Identity</i></i> <tt>a + 0 ≡ a</tt></li>
--   <li><i><i>Multiplicative Associativity</i></i> <tt>a * (b * c) ≡ (a *
--   b) * c</tt></li>
--   <li><i><i>Multiplicative Left Identity</i></i> <tt>1 * a ≡ a</tt></li>
--   <li><i><i>Multiplicative Right Identity</i></i> <tt>a * 1 ≡
--   a</tt></li>
--   <li><i><i>Multiplication Left Distributes Over Addition</i></i> <tt>a
--   * (b + c) ≡ (a * b) + (a * c)</tt></li>
--   <li><i><i>Multiplication Right Distributes Over Addition</i></i>
--   <tt>(a + b) * c ≡ (a * c) + (b * c)</tt></li>
--   <li><i><i>Multiplicative Left Annihilation</i></i> <tt>0 * a ≡
--   0</tt></li>
--   <li><i><i>Multiplicative Right Annihilation</i></i> <tt>a * 0 ≡
--   0</tt></li>
--   <li><i><i>Additive Inverse</i></i> <tt><a>negate</a> a <a>+</a> a ≡
--   0</tt></li>
--   <li><i><i>Subtraction</i></i> <tt>a <a>+</a> <a>negate</a> b ≡ a
--   <a>-</a> b</tt></li>
--   <li><i><i>Abs Is Idempotent</i></i> @<a>abs</a> (<a>abs</a> a) ≡
--   <a>abs</a> a</li>
--   <li><i><i>Signum Is Idempotent</i></i> @<a>signum</a> (<a>signum</a>
--   a) ≡ <a>signum</a> a</li>
--   <li><i><i>Product Of Abs And Signum Is Id</i></i> <tt><a>abs</a> a *
--   <a>signum</a> a ≡ a</tt></li>
--   </ul>
numLaws :: (Num a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Quotient Remainder</i></i> <tt>(quot x y) * y + (rem x y) ≡
--   x</tt></li>
--   <li><i><i>Division Modulus</i></i> <tt>(div x y) * y + (mod x y) ≡
--   x</tt></li>
--   <li><i><i>Integer Roundtrip</i></i> <tt>fromInteger (toInteger x) ≡
--   x</tt></li>
--   <li><i><i>QuotRem is (Quot, Rem)</i></i> <tt>quotRem x y ≡ (quot x y,
--   rem x y)</tt></li>
--   <li><i><i>DivMod is (Div, Mod)</i></i> <tt>divMod x y ≡ (div x y, mod
--   x y)</tt></li>
--   </ul>
integralLaws :: (Integral a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the various <a>Ix</a> properties:
--   
--   <pre>
--   <a>inRange</a> (l,u) i <a>==</a> <a>elem</a> i (<a>range</a> (l,u))
--   </pre>
--   
--   <tt><a>range</a> (l,u) <a>!!</a> <a>index</a> (l,u) i <a>==</a>
--   i</tt>, when <tt><a>inRange</a> (l,u) i</tt>
--   
--   <pre>
--   <a>map</a> (<a>index</a> (l,u)) (<a>range</a> (l,u)) <a>==</a> [0 .. <a>rangeSize</a> (l,u) - 1]
--   </pre>
--   
--   <pre>
--   <a>rangeSize</a> (l,u) <a>==</a> <a>length</a> (<a>range</a> (l,u))
--   </pre>
ixLaws :: (Ix a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Partial Isomorphism</i></i> <tt>fromList . toList ≡
--   id</tt></li>
--   <li><i><i>Length Preservation</i></i> <tt>fromList xs ≡ fromListN
--   (length xs) xs</tt></li>
--   </ul>
--   
--   <i>Note:</i> This property test is only available when using
--   <tt>base-4.7</tt> or newer.
isListLaws :: (IsList a, Show a, Show (Item a), Arbitrary a, Arbitrary (Item a), Eq a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Partial Isomorphism</i></i> <tt>decode . encode ≡
--   Just</tt></li>
--   <li><i><i>Encoding Equals Value</i></i> <tt>decode . encode ≡ Just .
--   toJSON</tt></li>
--   </ul>
--   
--   Note that in the second property, the type of decode is <tt>ByteString
--   -&gt; Value</tt>, not <tt>ByteString -&gt; a</tt>
jsonLaws :: (ToJSON a, FromJSON a, Show a, Arbitrary a, Eq a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Associative</i></i> <tt>mappend a (mappend b c) ≡ mappend
--   (mappend a b) c</tt></li>
--   <li><i><i>Left Identity</i></i> <tt>mappend mempty a ≡ a</tt></li>
--   <li><i><i>Right Identity</i></i> <tt>mappend a mempty ≡ a</tt></li>
--   <li><i><i>Concatenation</i></i> <tt>mconcat as ≡ foldr mappend mempty
--   as</tt></li>
--   </ul>
monoidLaws :: (Monoid a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Commutative</i></i> <tt>mappend a b ≡ mappend b a</tt></li>
--   </ul>
--   
--   Note that this does not test associativity or identity. Make sure to
--   use <a>monoidLaws</a> in addition to this set of laws.
commutativeMonoidLaws :: (Monoid a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws
semigroupMonoidLaws :: (Semigroup a, Monoid a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Antisymmetry</i></i> <tt>a ≤ b ∧ b ≤ a ⇒ a = b</tt></li>
--   <li><i><i>Transitivity</i></i> <tt>a ≤ b ∧ b ≤ c ⇒ a ≤ c</tt></li>
--   <li><i><i>Totality</i></i> <tt>a ≤ b ∨ a &gt; b</tt></li>
--   </ul>
ordLaws :: (Ord a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Succ Pred Identity</i></i> <tt><a>succ</a> (<a>pred</a> x) ≡
--   x</tt></li>
--   <li><i><i>Pred Succ Identity</i></i> <tt><a>pred</a> (<a>succ</a> x) ≡
--   x</tt></li>
--   </ul>
--   
--   This only works for <tt>Enum</tt> types that are not bounded, meaning
--   that <a>succ</a> and <a>pred</a> must be total. This means that these
--   property tests work correctly for types like <a>Integer</a> but not
--   for <a>Int</a>.
--   
--   Sadly, there is not a good way to test <a>fromEnum</a> and
--   <a>toEnum</a>, since many types that have reasonable implementations
--   for <a>succ</a> and <a>pred</a> have more inhabitants than <a>Int</a>
--   does.
enumLaws :: (Enum a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the same properties as <a>enumLaws</a> except that it requires
--   the type to have a <a>Bounded</a> instance. These tests avoid taking
--   the successor of the maximum element or the predecessor of the minimal
--   element.
boundedEnumLaws :: (Enum a, Bounded a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Test that a <a>Prim</a> instance obey the several laws.
primLaws :: (Prim a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Associative</i></i> <tt>a <a>&lt;&gt;</a> (b <a>&lt;&gt;</a>
--   c) ≡ (a <a>&lt;&gt;</a> b) <a>&lt;&gt;</a> c</tt></li>
--   <li><i><i>Concatenation</i></i> <tt><a>sconcat</a> as ≡ <a>foldr1</a>
--   (<a>&lt;&gt;</a>) as</tt></li>
--   <li><i><i>Times</i></i> <tt><a>stimes</a> n a ≡ <a>foldr1</a>
--   (<a>&lt;&gt;</a>) (<a>replicate</a> n a)</tt></li>
--   </ul>
semigroupLaws :: (Semigroup a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Commutative</i></i> <tt>a <a>&lt;&gt;</a> b ≡ b
--   <a>&lt;&gt;</a> a</tt></li>
--   </ul>
--   
--   Note that this does not test associativity. Make sure to use
--   <a>semigroupLaws</a> in addition to this set of laws.
commutativeSemigroupLaws :: (Semigroup a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Exponential</i></i> <tt><a>stimes</a> n (a <a>&lt;&gt;</a>
--   b) ≡ <a>stimes</a> n a <a>&lt;&gt;</a> <a>stimes</a> n b</tt></li>
--   </ul>
--   
--   Note that this does not test associativity. Make sure to use
--   <a>semigroupLaws</a> in addition to this set of laws.
exponentialSemigroupLaws :: (Semigroup a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Idempotent</i></i> <tt>a <a>&lt;&gt;</a> a ≡ a</tt></li>
--   </ul>
--   
--   Note that this does not test associativity. Make sure to use
--   <a>semigroupLaws</a> in addition to this set of laws. In literature,
--   this class of semigroup is known as a band.
idempotentSemigroupLaws :: (Semigroup a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Rectangular Band</i></i> <tt>a <a>&lt;&gt;</a> b
--   <a>&lt;&gt;</a> a ≡ a</tt></li>
--   </ul>
--   
--   Note that this does not test associativity. Make sure to use
--   <a>semigroupLaws</a> in addition to this set of laws.
rectangularBandSemigroupLaws :: (Semigroup a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Additive Commutativity</i></i> <tt>a + b ≡ b + a</tt></li>
--   <li><i><i>Additive Left Identity</i></i> <tt>0 + a ≡ a</tt></li>
--   <li><i><i>Additive Right Identity</i></i> <tt>a + 0 ≡ a</tt></li>
--   <li><i><i>Multiplicative Associativity</i></i> <tt>a * (b * c) ≡ (a *
--   b) * c</tt></li>
--   <li><i><i>Multiplicative Left Identity</i></i> <tt>1 * a ≡ a</tt></li>
--   <li><i><i>Multiplicative Right Identity</i></i> <tt>a * 1 ≡
--   a</tt></li>
--   <li><i><i>Multiplication Left Distributes Over Addition</i></i> <tt>a
--   * (b + c) ≡ (a * b) + (a * c)</tt></li>
--   <li><i><i>Multiplication Right Distributes Over Addition</i></i>
--   <tt>(a + b) * c ≡ (a * c) + (b * c)</tt></li>
--   <li><i><i>Multiplicative Left Annihilation</i></i> <tt>0 * a ≡
--   0</tt></li>
--   <li><i><i>Multiplicative Right Annihilation</i></i> <tt>a * 0 ≡
--   0</tt></li>
--   </ul>
--   
--   Also tests that <a>fromNatural</a> is a homomorphism of semirings:
--   
--   <ul>
--   <li><i><i>FromNatural Maps Zero</i></i> <a>fromNatural</a> 0 =
--   <a>zero</a></li>
--   <li><i><i>FromNatural Maps One</i></i> <a>fromNatural</a> 1 =
--   <a>one</a></li>
--   <li><i><i>FromNatural Maps Plus</i></i> <a>fromNatural</a> (<tt>a</tt>
--   + <tt>b</tt>) = <a>fromNatural</a> <tt>a</tt> + <a>fromNatural</a>
--   <tt>b</tt></li>
--   <li><i><i>FromNatural Maps Times</i></i> <a>fromNatural</a>
--   (<tt>a</tt> * <tt>b</tt>) = <a>fromNatural</a> <tt>a</tt> *
--   <a>fromNatural</a> <tt>b</tt></li>
--   </ul>
semiringLaws :: (Semiring a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Additive Inverse</i></i> <tt><a>negate</a> a <a>+</a> a ≡
--   0</tt></li>
--   </ul>
--   
--   Note that this does not test any of the laws tested by
--   <a>semiringLaws</a>.
ringLaws :: (Ring a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Test that a <a>GcdDomain</a> instance obey several laws.
--   
--   Check that <a>divide</a> is an inverse of times:
--   
--   <ul>
--   <li><tt>y /= 0 =&gt; (x * y) `divide` y == Just x</tt>,</li>
--   <li><tt>y /= 0, x `divide` y == Just z =&gt; x == z * y</tt>.</li>
--   </ul>
--   
--   Check that <a>gcd</a> is a common divisor and is a multiple of any
--   common divisor:
--   
--   <ul>
--   <li><tt>x /= 0, y /= 0 =&gt; isJust (x `divide` gcd x y) &amp;&amp;
--   isJust (y `divide` gcd x y)</tt>,</li>
--   <li><tt>z /= 0 =&gt; isJust (gcd (x * z) (y * z) `divide`
--   z)</tt>.</li>
--   </ul>
--   
--   Check that <a>lcm</a> is a common multiple and is a factor of any
--   common multiple:
--   
--   <ul>
--   <li><tt>x /= 0, y /= 0 =&gt; isJust (lcm x y `divide` x) &amp;&amp;
--   isJust (lcm x y `divide` y)</tt>,</li>
--   <li><tt>x /= 0, y /= 0, isJust (z `divide` x), isJust (z `divide` y)
--   =&gt; isJust (z `divide` lcm x y)</tt>.</li>
--   </ul>
--   
--   Check that <a>gcd</a> of <a>coprime</a> numbers is a unit of the
--   semiring (has an inverse):
--   
--   <ul>
--   <li><tt>y /= 0, coprime x y =&gt; isJust (1 `divide` gcd x
--   y)</tt>.</li>
--   </ul>
gcdDomainLaws :: (Eq a, GcdDomain a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Test that a <a>Euclidean</a> instance obey laws of a Euclidean domain.
--   
--   <ul>
--   <li><tt>y /= 0, r == x `rem` y =&gt; r == 0 || degree r &lt; degree
--   y</tt>,</li>
--   <li><tt>y /= 0, (q, r) == x `quotRem` y =&gt; x == q * y +
--   r</tt>,</li>
--   <li><tt>y /= 0 =&gt; x `quot` x y == fst (x `quotRem` y)</tt>,</li>
--   <li><tt>y /= 0 =&gt; x `rem` x y == snd (x `quotRem` y)</tt>.</li>
--   </ul>
euclideanLaws :: (Eq a, Euclidean a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Show</i></i> <tt><a>show</a> a ≡ <a>showsPrec</a> 0 a
--   ""</tt></li>
--   <li><i><i>Equivariance: <a>showsPrec</a></i></i> <tt><a>showsPrec</a>
--   p a r <a>++</a> s ≡ <a>showsPrec</a> p a (r <a>++</a> s)</tt></li>
--   <li><i><i>Equivariance: <a>showList</a></i></i> <tt><a>showList</a> as
--   r <a>++</a> s ≡ <a>showList</a> as (r <a>++</a> s)</tt></li>
--   </ul>
showLaws :: (Show a, Arbitrary a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>Partial Isomorphism: <a>show</a> / <a>read</a></i></i>
--   <tt><a>readMaybe</a> (<a>show</a> a) ≡ <a>Just</a> a</tt></li>
--   <li><i><i>Partial Isomorphism: <a>show</a> / <a>read</a> with initial
--   space</i></i> <tt><a>readMaybe</a> (" " ++ <a>show</a> a) ≡
--   <a>Just</a> a</tt></li>
--   <li><i><i>Partial Isomorphism: <a>showsPrec</a> /
--   <a>readsPrec</a></i></i> <tt>(a,"") `elem` <a>readsPrec</a> p
--   (<a>showsPrec</a> p a "")</tt></li>
--   <li><i><i>Partial Isomorphism: <a>showList</a> /
--   <a>readList</a></i></i> <tt>(as,"") `elem` <a>readList</a>
--   (<a>showList</a> as "")</tt></li>
--   <li><i><i>Partial Isomorphism: <a>showListWith</a> <a>shows</a> /
--   <a>readListDefault</a></i></i> <tt>(as,"") `elem`
--   <a>readListDefault</a> (<a>showListWith</a> <a>shows</a> as
--   "")</tt></li>
--   </ul>
--   
--   <i>Note:</i> When using <tt>base-4.5</tt> or older, a shim
--   implementation of <a>readMaybe</a> is used.
showReadLaws :: (Show a, Read a, Eq a, Arbitrary a) => Proxy a -> Laws

-- | Tests the following <a>Storable</a> properties:
--   
--   <ul>
--   <li><i><i>Set-Get</i></i> <tt>(<a>pokeElemOff</a> ptr ix a &gt;&gt;
--   <a>peekElemOff</a> ptr ix') ≡ <a>pure</a> a</tt></li>
--   <li><i><i>Get-Set</i></i> <tt>(<a>peekElemOff</a> ptr ix &gt;&gt;
--   <a>pokeElemOff</a> ptr ix a) ≡ <a>pure</a> a</tt></li>
--   </ul>
storableLaws :: (Storable a, Eq a, Arbitrary a, Show a) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>From-To Inverse</i></i> <tt><a>from</a> <a>.</a> <a>to</a> ≡
--   <a>id</a></tt></li>
--   <li><i><i>To-From Inverse</i></i> <tt><a>to</a> <a>.</a> <a>from</a> ≡
--   <a>id</a></tt></li>
--   </ul>
--   
--   <i>Note:</i> This property test is only available when using
--   <tt>base-4.5</tt> or newer.
--   
--   <i>Note:</i> <a>from</a> and <a>to</a> don't actually care about the
--   type variable <tt>x</tt> in <tt><a>Rep</a> a x</tt>, so here we
--   instantiate it to <tt><tt>()</tt></tt> by default. If you would like
--   to instantiate <tt>x</tt> as something else, please file a bug report.
genericLaws :: (Generic a, Eq a, Arbitrary a, Show a, Show (Rep a ()), Arbitrary (Rep a ()), Eq (Rep a ())) => Proxy a -> Laws

-- | Tests the following properties:
--   
--   <ul>
--   <li><i><i>From-To Inverse</i></i> <tt><a>from1</a> <a>.</a> <a>to1</a>
--   ≡ <a>id</a></tt></li>
--   <li><i><i>To-From Inverse</i></i> <tt><a>to1</a> <a>.</a> <a>from1</a>
--   ≡ <a>id</a></tt></li>
--   </ul>
--   
--   <i>Note:</i> This property test is only available when using
--   <tt>base-4.9</tt> or newer.
generic1Laws :: forall (f :: Type -> Type) proxy. (Generic1 f, Eq1 f, Arbitrary1 f, Show1 f, Eq1 (Rep1 f), Show1 (Rep1 f), Arbitrary1 (Rep1 f)) => proxy f -> Laws

-- | Tests the following alternative properties:
--   
--   <ul>
--   <li><i><i>Left Identity</i></i> <tt><a>empty</a> <a>&lt;|&gt;</a> x ≡
--   x</tt></li>
--   <li><i><i>Right Identity</i></i> <tt>x <a>&lt;|&gt;</a> <a>empty</a> ≡
--   x</tt></li>
--   <li><i><i>Associativity</i></i> <tt>a <a>&lt;|&gt;</a> (b
--   <a>&lt;|&gt;</a> c) ≡ (a <a>&lt;|&gt;</a> b) <a>&lt;|&gt;</a>
--   c)</tt></li>
--   </ul>
alternativeLaws :: forall (f :: Type -> Type) proxy. (Alternative f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following alt properties:
--   
--   <ul>
--   <li><i><i>Associativity</i></i> <tt>(a <a>&lt;!&gt;</a> b)
--   <a>&lt;!&gt;</a> c ≡ a <a>&lt;!&gt;</a> (b <a>&lt;!&gt;</a>
--   c)</tt></li>
--   <li><i><i>Left Distributivity</i></i> <tt>f <a>&lt;$&gt;</a> (a
--   <a>&lt;!&gt;</a> b) ≡ (f <a>&lt;$&gt;</a> a) <a>&lt;!&gt;</a> (f
--   <a>&lt;$&gt;</a> b)</tt></li>
--   </ul>
altLaws :: forall proxy f. (Alt f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following alt properties:
--   
--   <ul>
--   <li><i><i>LiftF2 (1)</i></i> <tt>(<a>&lt;.&gt;</a>) ≡ <a>liftF2</a>
--   <a>id</a></tt></li>
--   <li><i><i>Associativity</i></i> <tt><a>fmap</a> (<a>.</a>) u
--   <a>&lt;.&gt;</a> v <a>&lt;.&gt;</a> w ≡ u <a>&lt;.&gt;</a> (v
--   <a>&lt;.&gt;</a> w)</tt></li>
--   </ul>
applyLaws :: (Apply f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following applicative properties:
--   
--   <ul>
--   <li><i><i>Identity</i></i> <tt><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v ≡ v</tt></li>
--   <li><i><i>Composition</i></i> <tt><a>pure</a> (<a>.</a>)
--   <a>&lt;*&gt;</a> u <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w ≡ u
--   <a>&lt;*&gt;</a> (v <a>&lt;*&gt;</a> w)</tt></li>
--   <li><i><i>Homomorphism</i></i> <tt><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x ≡ <a>pure</a> (f x)</tt></li>
--   <li><i><i>Interchange</i></i> <tt>u <a>&lt;*&gt;</a> <a>pure</a> y ≡
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</tt></li>
--   <li><i><i>LiftA2 (1)</i></i> <tt>(<a>&lt;*&gt;</a>) ≡ <a>liftA2</a>
--   <a>id</a></tt></li>
--   </ul>
applicativeLaws :: forall (f :: Type -> Type) proxy. (Applicative f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following contravariant properties:
--   
--   <ul>
--   <li><i><i>Identity</i></i> <tt><a>contramap</a> <a>id</a> ≡
--   <a>id</a></tt></li>
--   <li><i><i>Composition</i></i> <tt><a>contramap</a> f <a>.</a>
--   <a>contramap</a> g ≡ <a>contramap</a> (g <a>.</a> f)</tt></li>
--   </ul>
contravariantLaws :: forall (f :: Type -> Type) proxy. (Contravariant f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following <a>Foldable</a> properties:
--   
--   <ul>
--   <li><i><i>fold</i></i> <tt><a>fold</a> ≡ <a>foldMap</a>
--   <a>id</a></tt></li>
--   <li><i><i>foldMap</i></i> <tt><a>foldMap</a> f ≡ <a>foldr</a>
--   (<a>mappend</a> . f) <a>mempty</a></tt></li>
--   <li><i><i>foldr</i></i> <tt><a>foldr</a> f z t ≡ <a>appEndo</a>
--   (<a>foldMap</a> (<a>Endo</a> . f) t ) z</tt></li>
--   <li><i><i>foldr'</i></i> <tt><a>foldr'</a> f z0 xs ≡ let f' k x z = k
--   <a>$!</a> f x z in <a>foldl</a> f' <a>id</a> xs z0</tt></li>
--   <li><i><i>foldr1</i></i> <tt><a>foldr1</a> f t ≡ let <a>Just</a>
--   (xs,x) = <a>unsnoc</a> (<a>toList</a> t) in <a>foldr</a> f x
--   xs</tt></li>
--   <li><i><i>foldl</i></i> <tt><a>foldl</a> f z t ≡ <a>appEndo</a>
--   (<a>getDual</a> (<a>foldMap</a> (<a>Dual</a> . <a>Endo</a> .
--   <a>flip</a> f) t)) z</tt></li>
--   <li><i><i>foldl'</i></i> <tt><a>foldl'</a> f z0 xs ≡ let f' x k z = k
--   <a>$!</a> f z x in <a>foldr</a> f' <a>id</a> xs z0</tt></li>
--   <li><i><i>foldl1</i></i> <tt><a>foldl1</a> f t ≡ let x : xs =
--   <a>toList</a> t in <a>foldl</a> f x xs</tt></li>
--   <li><i><i>toList</i></i> <tt><a>toList</a> ≡ <a>foldr</a> (:)
--   []</tt></li>
--   <li><i><i>null</i></i> <tt><a>null</a> ≡ <a>foldr</a> (<a>const</a>
--   (<a>const</a> <a>False</a>)) <a>True</a></tt></li>
--   <li><i><i>length</i></i> <tt><a>length</a> ≡ <a>getSum</a> .
--   <a>foldMap</a> (<a>const</a> (<a>Sum</a> 1))</tt></li>
--   </ul>
--   
--   Note that this checks to ensure that <tt>foldl'</tt> and
--   <tt>foldr'</tt> are suitably strict.
foldableLaws :: forall proxy (f :: Type -> Type). (Foldable f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following functor properties:
--   
--   <ul>
--   <li><i><i>Identity</i></i> <tt><a>fmap</a> <a>id</a> ≡
--   <a>id</a></tt></li>
--   <li><i><i>Composition</i></i> <tt><a>fmap</a> (f <a>.</a> g) ≡
--   <a>fmap</a> f <a>.</a> <a>fmap</a> g</tt></li>
--   <li><i><i>Const</i></i> <tt>(<a>&lt;$</a>) ≡ <a>fmap</a>
--   <a>const</a></tt></li>
--   </ul>
functorLaws :: forall (f :: Type -> Type) proxy. (Functor f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following monadic properties:
--   
--   <ul>
--   <li><i><i>Left Identity</i></i> <tt><a>return</a> a <a>&gt;&gt;=</a> k
--   ≡ k a</tt></li>
--   <li><i><i>Right Identity</i></i> <tt>m <a>&gt;&gt;=</a> <a>return</a>
--   ≡ m</tt></li>
--   <li><i><i>Associativity</i></i> <tt>m <a>&gt;&gt;=</a> (\x -&gt; k x
--   <a>&gt;&gt;=</a> h) ≡ (m <a>&gt;&gt;=</a> k) <a>&gt;&gt;=</a>
--   h</tt></li>
--   <li><i><i>Return</i></i> <tt><a>pure</a> ≡ <a>return</a></tt></li>
--   <li><i><i>Ap</i></i> <tt>(<a>&lt;*&gt;</a>) ≡ <a>ap</a></tt></li>
--   </ul>
monadLaws :: forall (f :: Type -> Type) proxy. (Monad f, Applicative f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following monad plus properties:
--   
--   <ul>
--   <li><i><i>Left Identity</i></i> <tt><a>mplus</a> <a>mzero</a> x ≡
--   x</tt></li>
--   <li><i><i>Right Identity</i></i> <tt><a>mplus</a> x <a>mzero</a> ≡
--   x</tt></li>
--   <li><i><i>Associativity</i></i> <tt><a>mplus</a> a (<a>mplus</a> b c)
--   ≡ <a>mplus</a> (<a>mplus</a> a b) c)</tt></li>
--   <li><i><i>Left Zero</i></i> <tt><a>mzero</a> <a>&gt;&gt;=</a> f ≡
--   <a>mzero</a></tt></li>
--   <li><i><i>Right Zero</i></i> <tt>m <a>&gt;&gt;</a> <a>mzero</a> ≡
--   <a>mzero</a></tt></li>
--   </ul>
monadPlusLaws :: forall (f :: Type -> Type) proxy. (MonadPlus f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following monadic zipping properties:
--   
--   <ul>
--   <li><i><i>Naturality</i></i> <tt><a>liftM</a> (f <a>***</a> g)
--   (<a>mzip</a> ma mb) = <a>mzip</a> (<a>liftM</a> f ma) (<a>liftM</a> g
--   mb)</tt></li>
--   </ul>
--   
--   In the laws above, the infix function <tt><a>***</a></tt> refers to a
--   typeclass method of <a>Arrow</a>.
monadZipLaws :: forall (f :: Type -> Type) proxy. (MonadZip f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following alt properties:
--   
--   <ul>
--   <li><i><i>Left Identity</i></i> <tt><a>zero</a> <a>&lt;!&gt;</a> m ≡
--   m</tt></li>
--   <li><i><i>Right Identity</i></i> <tt>m <a>&lt;!&gt;</a> <a>zero</a> ≡
--   m</tt></li>
--   </ul>
plusLaws :: forall proxy f. (Plus f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests everything from <tt>altLaws</tt>, plus the following:
--   
--   <ul>
--   <li><i><i>Congruency</i></i> <tt><a>zero</a> ≡ <a>empty</a></tt></li>
--   </ul>
extendedPlusLaws :: forall proxy f. (Plus f, Alternative f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following <a>Traversable</a> properties:
--   
--   <ul>
--   <li><i><i>Naturality</i></i> <tt>t <a>.</a> <a>traverse</a> f ≡
--   <a>traverse</a> (t <a>.</a> f)</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>Identity</i></i> <tt><a>traverse</a> <a>Identity</a> ≡
--   <a>Identity</a></tt></li>
--   <li><i><i>Composition</i></i> <tt><a>traverse</a> (<a>Compose</a>
--   <a>.</a> <a>fmap</a> g <a>.</a> f) ≡ <a>Compose</a> <a>.</a>
--   <a>fmap</a> (<a>traverse</a> g) <a>.</a> <a>traverse</a> f</tt></li>
--   <li><i><i>Sequence Naturality</i></i> <tt>t <a>.</a> <a>sequenceA</a>
--   ≡ <a>sequenceA</a> <a>.</a> <a>fmap</a> t</tt> for every applicative
--   transformation <tt>t</tt></li>
--   <li><i><i>Sequence Identity</i></i> <tt><a>sequenceA</a> <a>.</a>
--   <a>fmap</a> <a>Identity</a> ≡ <a>Identity</a></tt></li>
--   <li><i><i>Sequence Composition</i></i> <tt><a>sequenceA</a> <a>.</a>
--   <a>fmap</a> <a>Compose</a> ≡ <a>Compose</a> <a>.</a> <a>fmap</a>
--   <a>sequenceA</a> <a>.</a> <a>sequenceA</a></tt></li>
--   <li><i><i>foldMap</i></i> <tt><a>foldMap</a> ≡
--   <a>foldMapDefault</a></tt></li>
--   <li><i><i>fmap</i></i> <tt><a>fmap</a> ≡ <a>fmapDefault</a></tt></li>
--   </ul>
--   
--   Where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (Applicative f, Applicative g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations, i.e.
--   
--   <ul>
--   <li>Identity: <tt>t (<a>pure</a> x) ≡ <a>pure</a> x</tt></li>
--   <li>Distributivity: <tt>t (x <a>&lt;*&gt;</a> y) ≡ t x
--   <a>&lt;*&gt;</a> t y</tt></li>
--   </ul>
traversableLaws :: forall (f :: Type -> Type) proxy. (Traversable f, forall a. Eq a => Eq (f a), forall a. Show a => Show (f a), forall a. Arbitrary a => Arbitrary (f a)) => proxy f -> Laws

-- | Tests the following <a>Bifunctor</a> properties:
--   
--   <ul>
--   <li><i><i>Bifold Identity</i></i> <tt><a>bifold</a> ≡ <a>bifoldMap</a>
--   <a>id</a> <a>id</a></tt></li>
--   <li><i><i>BifoldMap Identity</i></i> <tt><a>bifoldMap</a> f g ≡
--   <a>bifoldr</a> (<a>mappend</a> <a>.</a> f) (<a>mappend</a> <a>.</a> g)
--   <a>mempty</a></tt></li>
--   <li><i><i>Bifoldr Identity</i></i> <tt><a>bifoldr</a> f g z t ≡
--   <a>appEndo</a> (<a>bifoldMap</a> (<a>Endo</a> <a>.</a> f) (<a>Endo</a>
--   <a>.</a> g) t) z</tt></li>
--   </ul>
--   
--   <i>Note</i>: This property test is only available when this package is
--   built with <tt>base-4.10+</tt> or <tt>transformers-0.5+</tt>.
bifoldableLaws :: forall proxy (f :: Type -> Type -> Type). (Bifoldable f, forall a b. (Eq a, Eq b) => Eq (f a b), forall a b. (Show a, Show b) => Show (f a b), forall a b. (Arbitrary a, Arbitrary b) => Arbitrary (f a b)) => proxy f -> Laws

-- | Tests the following <a>Bifunctor</a> properties:
--   
--   <ul>
--   <li><i><i>Identity</i></i> <tt><a>bimap</a> <a>id</a> <a>id</a> ≡
--   <a>id</a></tt></li>
--   <li><i><i>First Identity</i></i> <tt><a>first</a> <a>id</a> ≡
--   <a>id</a></tt></li>
--   <li><i><i>Second Identity</i></i> <tt><a>second</a> <a>id</a> ≡
--   <a>id</a></tt></li>
--   <li><i><i>Bifunctor Composition</i></i> <tt><a>bimap</a> f g ≡
--   <a>first</a> f <a>.</a> <a>second</a> g</tt></li>
--   </ul>
--   
--   <i>Note</i>: This property test is only available when this package is
--   built with <tt>base-4.9+</tt> or <tt>transformers-0.5+</tt>.
bifunctorLaws :: forall proxy (f :: Type -> Type -> Type). (Bifunctor f, forall a b. (Eq a, Eq b) => Eq (f a b), forall a b. (Show a, Show b) => Show (f a b), forall a b. (Arbitrary a, Arbitrary b) => Arbitrary (f a b)) => proxy f -> Laws

-- | Tests the following <a>Bitraversable</a> properties:
--   
--   <ul>
--   <li><i><i>Naturality</i></i> <tt><a>bitraverse</a> (t <a>.</a> f) (t
--   <a>.</a> g) ≡ t <a>.</a> <a>bitraverse</a> f g</tt> for every
--   applicative transformation <tt>t</tt></li>
--   <li><i><i>Identity</i></i> <tt><a>bitraverse</a> <a>Identity</a>
--   <a>Identity</a> ≡ <a>Identity</a></tt></li>
--   <li><i><i>Composition</i></i> <tt><a>Compose</a> <a>.</a> <a>fmap</a>
--   (<a>bitraverse</a> g1 g2) <a>.</a> <a>bitraverse</a> f1 f2 ≡
--   <a>bitraverse</a> (<a>Compose</a> <a>.</a> <a>fmap</a> g1 g2 <a>.</a>
--   f1) (<a>Compose</a> <a>.</a> <a>fmap</a> g2 <a>.</a> f2)</tt></li>
--   </ul>
--   
--   <i>Note</i>: This property test is only available when this package is
--   built with <tt>base-4.9+</tt> or <tt>transformers-0.5+</tt>.
bitraversableLaws :: forall proxy (f :: Type -> Type -> Type). (Bitraversable f, forall a b. (Eq a, Eq b) => Eq (f a b), forall a b. (Show a, Show b) => Show (f a b), forall a b. (Arbitrary a, Arbitrary b) => Arbitrary (f a b)) => proxy f -> Laws

-- | Tests the following <a>Category</a> properties:
--   
--   <ul>
--   <li><i><i>Right Identity</i></i> <tt>f <a>.</a> <a>id</a> ≡
--   f</tt></li>
--   <li><i><i>Left Identity</i></i> <tt><a>id</a> <a>.</a> f ≡ f</tt></li>
--   <li><i><i>Associativity</i></i> <tt>f <a>.</a> (g <a>.</a> h) ≡ (f
--   <a>.</a> g) <a>.</a> h</tt></li>
--   </ul>
--   
--   <i>Note</i>: This property test is only available when this package is
--   built with <tt>base-4.9+</tt> or <tt>transformers-0.5+</tt>.
categoryLaws :: forall proxy (c :: Type -> Type -> Type). (Category c, forall a b. (Eq a, Eq b) => Eq (c a b), forall a b. (Show a, Show b) => Show (c a b), forall a b. (Arbitrary a, Arbitrary b) => Arbitrary (c a b)) => proxy c -> Laws

-- | Test everything from <a>categoryLaws</a> plus the following:
--   
--   <ul>
--   <li><i><i>Commutative</i></i> <tt>f <a>.</a> g ≡ g <a>.</a>
--   f</tt></li>
--   </ul>
--   
--   <i>Note</i>: This property test is only available when this package is
--   built with <tt>base-4.9+</tt> or <tt>transformers-0.5+</tt>.
commutativeCategoryLaws :: forall proxy (c :: Type -> Type -> Type). (Category c, forall a b. (Eq a, Eq b) => Eq (c a b), forall a b. (Show a, Show b) => Show (c a b), forall a b. (Arbitrary a, Arbitrary b) => Arbitrary (c a b)) => proxy c -> Laws

-- | Tests the following <a>Semigroupoid</a> properties:
--   
--   <ul>
--   <li><i><i>Associativity</i></i> <tt>f `<a>o</a>` (g `<a>o</a>` h) ≡ (f
--   `<a>o</a>` g) `<a>o</a>` h</tt></li>
--   </ul>
--   
--   <i>Note</i>: This property test is only available when this package is
--   built with <tt>base-4.9+</tt> or <tt>transformers-0.5+</tt>.
semigroupoidLaws :: forall proxy s. (Semigroupoid s, forall a b. (Eq a, Eq b) => Eq (s a b), forall a b. (Show a, Show b) => Show (s a b), forall a b. (Arbitrary a, Arbitrary b) => Arbitrary (s a b)) => proxy s -> Laws

-- | Tests everything from <a>semigroupoidLaws</a> plus the following:
--   
--   <ul>
--   <li><i><i>Commutative</i></i> <tt>f `<a>o</a>` g ≡ g `<a>o</a>`
--   f</tt></li>
--   </ul>
--   
--   <i>Note</i>: This property test is only available when this package is
--   built with <tt>base-4.9+</tt> or <tt>transformers-0.5+</tt>.
commutativeSemigroupoidLaws :: forall proxy s. (Semigroupoid s, forall a b. (Eq a, Eq b) => Eq (s a b), forall a b. (Show a, Show b) => Show (s a b), forall a b. (Arbitrary a, Arbitrary b) => Arbitrary (s a b)) => proxy s -> Laws

-- | Test that a <a>MVector</a> instance obey several laws.
muvectorLaws :: (Eq a, Unbox a, Arbitrary a, Show a) => Proxy a -> Laws

-- | A set of laws associated with a typeclass.
--   
--   <i>Note</i>: Most of the top-level functions provided by this library
--   have the shape `forall a. (Ctx a) =&gt; Proxy a -&gt; Laws`. You can
--   just as easily provide your own <a>Laws</a> in libraries/test suites
--   using regular QuickCheck machinery.
data Laws
Laws :: String -> [(String, Property)] -> Laws

-- | Name of the typeclass whose laws are tested
[lawsTypeclass] :: Laws -> String

-- | Pairs of law name and property
[lawsProperties] :: Laws -> [(String, Property)]

-- | In older versions of GHC, Proxy is not poly-kinded, so we provide
--   Proxy1.
data Proxy1 (f :: Type -> Type)
Proxy1 :: Proxy1 (f :: Type -> Type)

-- | In older versions of GHC, Proxy is not poly-kinded, so we provide
--   Proxy2.
data Proxy2 (f :: Type -> Type -> Type)
Proxy2 :: Proxy2 (f :: Type -> Type -> Type)
