-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Byron ledger integration in the Ouroboros consensus layer
--   
--   Byron ledger integration in the Ouroboros consensus layer
@package ouroboros-consensus-byron
@version 0.1.0.1


-- | Byron digital signatures.
module Ouroboros.Consensus.Byron.Crypto.DSIGN
data ByronDSIGN
class HasSignTag a
signTag :: HasSignTag a => VerKeyDSIGN ByronDSIGN -> proxy a -> SignTag
data family SigDSIGN v
data family SignKeyDSIGN v
data family VerKeyDSIGN v
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SigDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SigDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.SigDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SigDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance NoThunks.Class.NoThunks (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Generics.Generic (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Classes.Eq (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance GHC.Show.Show (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)
instance (Ouroboros.Consensus.Byron.Crypto.DSIGN.HasSignTag a, Cardano.Binary.Annotated.Decoded a) => Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronSignable a
instance Cardano.Crypto.DSIGN.Class.DSIGNAlgorithm Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN
instance Ouroboros.Consensus.Byron.Crypto.DSIGN.HasSignTag Cardano.Chain.UTxO.TxWitness.TxSigData
instance Ouroboros.Consensus.Byron.Crypto.DSIGN.HasSignTag (Cardano.Binary.Annotated.Annotated Cardano.Chain.Block.Header.ToSign Data.ByteString.Internal.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Crypto.DSIGN.Class.SigDSIGN Ouroboros.Consensus.Byron.Crypto.DSIGN.ByronDSIGN)

module Ouroboros.Consensus.Byron.EBBs
knownEBBs :: [(HeaderHash, Maybe HeaderHash)]

module Ouroboros.Consensus.Byron.Ledger.Orphans
instance NoThunks.Class.NoThunks Cardano.Chain.Block.Validation.ChainValidationError
instance Codec.Serialise.Class.Serialise Cardano.Chain.Block.Validation.ChainValidationState
instance Codec.Serialise.Class.Serialise Cardano.Chain.Common.KeyHash.KeyHash
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Chain.Block.Header.HeaderHash
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.Block.Block.ABlock Data.ByteString.Internal.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.Block.Header.AHeader Data.ByteString.Internal.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.Block.Block.ABoundaryBlock Data.ByteString.Internal.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.Block.Block.ABlockOrBoundary Data.ByteString.Internal.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.Block.Header.ABoundaryHeader Data.ByteString.Internal.ByteString)
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Chain.UTxO.Tx.TxId
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Chain.Update.Proposal.UpId
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Chain.Delegation.Certificate.CertificateId
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Chain.Update.Vote.VoteId
instance Ouroboros.Consensus.Util.Condense.Condense (Cardano.Chain.MempoolPayload.AMempoolPayload a)
instance Ouroboros.Consensus.Util.Condense.Condense Cardano.Crypto.Signing.VerificationKey.VerificationKey

module Ouroboros.Consensus.Byron.Ledger.Conversions
fromByronBlockCount :: BlockCount -> SecurityParam
fromByronBlockNo :: ChainDifficulty -> BlockNo
fromByronEpochSlots :: EpochSlots -> EpochSize
fromByronSlotLength :: Natural -> SlotLength
fromByronSlotNo :: SlotNumber -> SlotNo
toByronBlockCount :: SecurityParam -> BlockCount
toByronSlotLength :: SlotLength -> Natural
toByronSlotNo :: SlotNo -> SlotNumber
genesisNumCoreNodes :: Config -> NumCoreNodes
genesisSecurityParam :: Config -> SecurityParam
genesisSlotLength :: Config -> Natural

module Ouroboros.Consensus.Byron.Ledger.Block
newtype ByronHash
ByronHash :: HeaderHash -> ByronHash
[unByronHash] :: ByronHash -> HeaderHash
mkByronHash :: ABlockOrBoundaryHdr ByteString -> ByronHash

-- | Byron block
--   
--   We cache two bits of information:
--   
--   <ul>
--   <li>We cache the slot number as this is not readily available for
--   EBBs. Having it cached allows us to e.g. give a <a>HasHeader</a>
--   instance.</li>
--   <li>We cache the hash as this is expensive to compute and we need it
--   often.</li>
--   </ul>
data ByronBlock
ByronBlock :: !ABlockOrBoundary ByteString -> !SlotNo -> !ByronHash -> ByronBlock
[byronBlockRaw] :: ByronBlock -> !ABlockOrBoundary ByteString
[byronBlockSlotNo] :: ByronBlock -> !SlotNo
[byronBlockHash] :: ByronBlock -> !ByronHash

-- | Construct Byron block from unannotated <a>Block</a>
--   
--   This should be used only when forging blocks (not when receiving
--   blocks over the wire).
annotateByronBlock :: EpochSlots -> Block -> ByronBlock
mkByronBlock :: EpochSlots -> ABlockOrBoundary ByteString -> ByronBlock
data family Header blk
mkBoundaryByronHeader :: SlotNo -> ABoundaryHeader ByteString -> SizeInBytes -> Header ByronBlock
mkByronHeader :: EpochSlots -> ABlockOrBoundaryHdr ByteString -> SizeInBytes -> Header ByronBlock
mkRegularByronHeader :: AHeader ByteString -> SizeInBytes -> Header ByronBlock
byronBlockIsEBB :: ByronBlock -> IsEBB
byronHeaderIsEBB :: Header ByronBlock -> IsEBB
knownEBBs :: Map (HeaderHash ByronBlock) (ChainHash ByronBlock)

-- | Header without a size hint
--   
--   Defined in order to support backwards compatible binary encodings.
data UnsizedHeader
UnsizedHeader :: !ABlockOrBoundaryHdr ByteString -> !SlotNo -> !ByronHash -> UnsizedHeader
[unsizedHeaderRaw] :: UnsizedHeader -> !ABlockOrBoundaryHdr ByteString
[unsizedHeaderSlotNo] :: UnsizedHeader -> !SlotNo
[unsizedHeaderHash] :: UnsizedHeader -> !ByronHash
joinSizeHint :: UnsizedHeader -> SizeInBytes -> Header ByronBlock
mkUnsizedHeader :: EpochSlots -> ABlockOrBoundaryHdr ByteString -> UnsizedHeader
splitSizeHint :: Header ByronBlock -> (UnsizedHeader, SizeInBytes)
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance Ouroboros.Consensus.Util.Condense.Condense Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance Cardano.Binary.FromCBOR.FromCBOR Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance Cardano.Binary.ToCBOR.ToCBOR Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance GHC.Generics.Generic Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance GHC.Classes.Ord Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Show.Show (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Classes.Eq (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Block.Abstract.ConvertRawHash Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Util.Condense.Condense Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Network.Util.ShowProxy.ShowProxy Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Block.Abstract.GetHeader Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Network.Block.StandardHash Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Network.Block.HasHeader Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Network.Block.HasHeader (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Block.Abstract.GetPrevHash Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion
data ByronNodeToClientVersion
ByronNodeToClientVersion1 :: ByronNodeToClientVersion
data ByronNodeToNodeVersion

-- | We send headers without a size hint
ByronNodeToNodeVersion1 :: ByronNodeToNodeVersion

-- | We send headers <i>with</i> a size hint
ByronNodeToNodeVersion2 :: ByronNodeToNodeVersion
instance GHC.Enum.Bounded Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToNodeVersion
instance GHC.Enum.Enum Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToNodeVersion
instance GHC.Classes.Ord Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToNodeVersion
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToNodeVersion
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToNodeVersion
instance GHC.Enum.Bounded Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToClientVersion
instance GHC.Enum.Enum Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToClientVersion
instance GHC.Classes.Ord Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToClientVersion
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToClientVersion
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.NetworkProtocolVersion.ByronNodeToClientVersion
instance Ouroboros.Consensus.Node.NetworkProtocolVersion.HasNetworkProtocolVersion Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.NetworkProtocolVersion.SupportedNetworkProtocolVersion Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Ledger.Config

-- | Static configuration required to work with this type of blocks
data family BlockConfig blk
byronEpochSlots :: BlockConfig ByronBlock -> EpochSlots
byronGenesisHash :: BlockConfig ByronBlock -> GenesisHash
byronProtocolMagic :: BlockConfig ByronBlock -> ProtocolMagic
byronProtocolMagicId :: BlockConfig ByronBlock -> ProtocolMagicId

-- | Static configuration required for serialisation and deserialisation of
--   types pertaining to this type of block.
--   
--   Data family instead of type family to get better type inference.
data family CodecConfig blk
mkByronCodecConfig :: Config -> CodecConfig ByronBlock

-- | Config needed for the <a>NodeInitStorage</a> class. Defined here to
--   avoid circular dependencies.
data family StorageConfig blk

-- | Byron's genesis config contains the AVVM balances, of which there are
--   +14k in mainnet's genesis config. These balances are only used to
--   create the initial ledger state, there is no reason to keep them in
--   memory afterwards.
--   
--   This function empties the <tt>gdAvvmDistr</tt> field in the genesis
--   config. As we keep Byron's genesis config in memory (even in later
--   eras), this can save us a bit of memory.
compactGenesisConfig :: Config -> Config
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.BlockConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.BlockConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.CodecConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.CodecConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Block.Abstract.StorageConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Generics.Generic (Ouroboros.Consensus.Block.Abstract.StorageConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)

module Ouroboros.Consensus.Byron.Ledger.Serialisation

-- | Context identifying what kind of block we have
--   
--   In almost all places we will use <a>NestedCtxt</a> rather than
--   <a>NestedCtxt_</a>.
data family NestedCtxt_ blk :: Type -> Type -> Type -> Type
type RawBoundaryHeader = ABoundaryHeader ByteString
type RawHeader = AHeader ByteString

-- | The Byron block encoding overhead size in bytes.
--   
--   This encompasses the overhead in bytes for everything that is encoded
--   within a Byron block, excluding the actual generalized transactions
--   (transactions, delegation certificates, update votes, and update
--   proposals).
byronBlockEncodingOverhead :: Word32

-- | Inverse of <a>encodeByronBlock</a>
decodeByronBlock :: EpochSlots -> Decoder s (ByteString -> ByronBlock)

-- | Decoder for a boundary Byron block.
--   
--   PRECONDITION: the <a>ByteString</a> given as argument to the decoder
--   is the same as the one that is decoded.
--   
--   This is a wrapper for <a>fromCBORABoundaryBlock</a>.
--   
--   Use <a>decodeByronBlock</a> when you can, this function is provided
--   for use by the hard-fork combinator.
decodeByronBoundaryBlock :: EpochSlots -> Decoder s (ByteString -> ByronBlock)

-- | Inverse of <a>encodeByronBoundaryHeader</a>
decodeByronBoundaryHeader :: Decoder s (ByteString -> RawBoundaryHeader)
decodeByronHeaderHash :: Decoder s (HeaderHash ByronBlock)

-- | Decoder for a regular (non-EBB) Byron block.
--   
--   PRECONDITION: the <a>ByteString</a> given as argument to the decoder
--   is the same as the one that is decoded.
--   
--   This is a wrapper for <a>fromCBORABlock</a>.
--   
--   Use <a>decodeByronBlock</a> when you can, this function is provided
--   for use by the hard-fork combinator.
decodeByronRegularBlock :: EpochSlots -> Decoder s (ByteString -> ByronBlock)

-- | Inverse of <a>encodeByronRegularHeader</a>
decodeByronRegularHeader :: EpochSlots -> Decoder s (ByteString -> RawHeader)

-- | Encode a block
--   
--   Should be backwards compatible with legacy (cardano-sl) nodes.
--   
--   Implementation note: the decoder uses <a>fromCBORABlockOrBoundary</a>,
--   which has inverse <a>toCBORABlockOrBoundary</a>. This encoder is
--   intended to be binary compatible with <a>toCBORABlockOrBoundary</a>,
--   but does not use it and instead takes advantage of the annotations
--   (using <a>encodePreEncoded</a>).
encodeByronBlock :: ByronBlock -> Encoding

-- | Encodes a raw Byron EBB header <i>without</i> a tag indicating whether
--   it's a regular header or an EBB header.
--   
--   Uses the annotation, so cheap.
encodeByronBoundaryHeader :: RawBoundaryHeader -> Encoding
encodeByronHeaderHash :: HeaderHash ByronBlock -> Encoding

-- | Encodes a raw Byron header <i>without</i> a tag indicating whether
--   it's a regular header or an EBB header.
--   
--   Uses the annotation, so cheap.
encodeByronRegularHeader :: RawHeader -> Encoding

-- | The <a>BinaryBlockInfo</a> of the given <a>ByronBlock</a>.
--   
--   NOTE: the bytestring obtained by slicing the serialised block using
--   the header offset and size will correspond to the <i>header
--   annotation</i>, but not to the serialised header, as we add an
--   envelope (<a>encodeListLen</a> + tag) around a header in
--   <tt>encodeByronHeader</tt>. This envelope must thus still be added to
--   the sliced bytestring before it can be deserialised using
--   <tt>decodeByronHeader</tt>.
byronBinaryBlockInfo :: ByronBlock -> BinaryBlockInfo
addV1Envelope :: (SomeSecond (NestedCtxt Header) ByronBlock, ByteString) -> ByteString

-- | Inverse of <tt>encodeSizedHeader</tt>
decodeUnsizedHeader :: EpochSlots -> Decoder s (ByteString -> UnsizedHeader)

-- | Drop the V1 EBB-or-regular-header envelope and reconstruct the
--   context. Since we don't know the block size, use
--   <a>fakeByronBlockSizeHint</a>.
dropV1Envelope :: ByteString -> Except String (SomeSecond (NestedCtxt Header) ByronBlock, ByteString)

-- | Encode an unsized header
--   
--   Does <i>not</i> have to backwards compatible with legacy (cardano-sl)
--   nodes (which never send or store these headers), but should be inverse
--   to <tt>decodeSizedHeader</tt>, and moreover uses
--   <tt>fromCBORABlockOrBoundaryHdr</tt> from cardano-ledger-byron, and so
--   we don't have too much choice in this encoder.
encodeUnsizedHeader :: UnsizedHeader -> Encoding

-- | Fake size (used in compatibility mode)
fakeByronBlockSizeHint :: SizeInBytes
instance GHC.Show.Show (Ouroboros.Consensus.Block.NestedContent.NestedCtxt_ Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock f a)
instance Codec.Serialise.Class.Serialise Ouroboros.Consensus.Byron.Ledger.Block.ByronHash
instance Ouroboros.Consensus.Util.DepPair.SameDepIndex (Ouroboros.Consensus.Block.NestedContent.NestedCtxt_ Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock f)
instance Ouroboros.Consensus.Block.NestedContent.HasNestedContent Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Protocol
data PBftByronCrypto

-- | Determine the <a>CoreNodeId</a> for a code node, based on the genesis
--   key it will sign blocks on behalf of.
--   
--   In PBFT, the <a>CoreNodeId</a> index is determined by the 0-based
--   position in the sort order of the genesis key hashes.
genesisKeyCoreNodeId :: Config -> VerKeyDSIGN ByronDSIGN -> Maybe CoreNodeId

-- | Inverse of <a>genesisKeyCoreNodeId</a>
nodeIdToGenesisKey :: Config -> CoreNodeId -> Maybe KeyHash
instance Ouroboros.Consensus.Protocol.PBFT.Crypto.PBftCrypto Ouroboros.Consensus.Byron.Protocol.PBftByronCrypto


-- | Instances required to support PBFT
module Ouroboros.Consensus.Byron.Ledger.PBFT
decodeByronChainDepState :: Decoder s (ChainDepState (BlockProtocol ByronBlock))
encodeByronChainDepState :: ChainDepState (BlockProtocol ByronBlock) -> Encoding
fromPBftLedgerView :: PBftLedgerView PBftByronCrypto -> Map

-- | Construct DSIGN required for Byron crypto
mkByronContextDSIGN :: BlockConfig ByronBlock -> VerKeyDSIGN ByronDSIGN -> ContextDSIGN ByronDSIGN
toPBftLedgerView :: Map -> PBftLedgerView PBftByronCrypto
toTickedPBftLedgerView :: Map -> Ticked (PBftLedgerView PBftByronCrypto)
instance Ouroboros.Consensus.Block.SupportsProtocol.BlockSupportsProtocol Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Ledger.Integrity

-- | Verifies whether the block is not corrupted by checking its signature
--   and witnesses.
--   
--   This function will always return <a>True</a> for an EBB, as we cannot
--   check anything for an EBB.
verifyBlockIntegrity :: BlockConfig ByronBlock -> ByronBlock -> Bool

-- | Verify whether a header is not corrupted.
--   
--   The difference with <a>verifyHeaderSignature</a> is that this function
--   also checks the integrity of the <a>headerProtocolMagicId</a> field,
--   which is the only field of a regular header that is not signed.
--   
--   Note that we cannot check this for an EBB, as an EBB contains no
--   signature. This function will always return <a>True</a> for an EBB.
verifyHeaderIntegrity :: BlockConfig ByronBlock -> Header ByronBlock -> Bool

-- | Verify whether a header matches its signature.
--   
--   Note that we cannot check this for an EBB, as an EBB contains no
--   signature. This function will always return <a>True</a> for an EBB.
verifyHeaderSignature :: BlockConfig ByronBlock -> Header ByronBlock -> Bool

module Ouroboros.Consensus.Byron.Ledger.HeaderValidation
data ByronOtherHeaderEnvelopeError
UnexpectedEBBInSlot :: !SlotNo -> ByronOtherHeaderEnvelopeError

-- | Reusable strict data type for <a>TipInfo</a> in case the
--   <a>TipInfo</a> should contain <a>IsEBB</a> in addition to the
--   <a>HeaderHash</a>.
data TipInfoIsEBB blk
TipInfoIsEBB :: !HeaderHash blk -> !IsEBB -> TipInfoIsEBB blk
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Byron.Ledger.HeaderValidation.ByronOtherHeaderEnvelopeError
instance GHC.Generics.Generic Ouroboros.Consensus.Byron.Ledger.HeaderValidation.ByronOtherHeaderEnvelopeError
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.HeaderValidation.ByronOtherHeaderEnvelopeError
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.HeaderValidation.ByronOtherHeaderEnvelopeError
instance Ouroboros.Consensus.HeaderValidation.ValidateEnvelope Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.HeaderValidation.HasAnnTip Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.HeaderValidation.BasicEnvelopeValidation Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock


-- | Instances requires for consensus/ledger integration
module Ouroboros.Consensus.Byron.Ledger.Ledger

-- | Information required to determine the transition from Byron to Shelley
data ByronTransition

-- | Per candidate proposal, the <a>BlockNo</a> in which it became a
--   candidate
--   
--   The HFC needs to know when a candidate proposal becomes stable. We
--   cannot reliably do this using <a>SlotNo</a>: doing so would mean that
--   if we were to switch to a denser fork, something that was previously
--   deemed stable is suddenly not deemed stable anymore (although in
--   actuality it still is). We therefore must do this based on
--   <a>BlockNo</a> instead, but unfortunately the Byron ledger does not
--   record this information. Therefore, we record it here instead.
--   
--   Invariant: the domain of this map should equal the set of candidate
--   proposals.
ByronTransitionInfo :: !Map ProtocolVersion BlockNo -> ByronTransition

-- | To be used for a Byron-to-X (where X is typically Shelley) chain.
byronEraParams :: Config -> EraParams

-- | Separate variant of <a>byronEraParams</a> to be used for a Byron-only
--   chain.
byronEraParamsNeverHardForks :: Config -> EraParams
initByronLedgerState :: Config -> Maybe UTxO -> LedgerState ByronBlock
decodeByronAnnTip :: Decoder s (AnnTip ByronBlock)
decodeByronLedgerState :: Decoder s (LedgerState ByronBlock)
decodeByronQuery :: Decoder s (SomeSecond BlockQuery ByronBlock)
decodeByronResult :: BlockQuery ByronBlock result -> forall s. Decoder s result
encodeByronAnnTip :: AnnTip ByronBlock -> Encoding
encodeByronExtLedgerState :: ExtLedgerState ByronBlock -> Encoding
encodeByronHeaderState :: HeaderState ByronBlock -> Encoding
encodeByronLedgerState :: LedgerState ByronBlock -> Encoding
encodeByronQuery :: BlockQuery ByronBlock result -> Encoding
encodeByronResult :: BlockQuery ByronBlock result -> result -> Encoding

-- | Different queries supported by the ledger, indexed by the result type.
data family BlockQuery blk :: Type -> Type

-- | Ledger state associated with a block
data family LedgerState blk

-- | " Ticked " piece of state (<tt>LedgerState</tt>, <tt>LedgerView</tt>,
--   <tt>ChainIndepState</tt>)
--   
--   Ticking refers to the passage of time (the ticking of the clock). When
--   a piece of state is marked as ticked, it means that time-related
--   changes have been applied to the state (or forecast).
--   
--   Some examples of time related changes:
--   
--   <ul>
--   <li>Scheduled delegations might have been applied in Byron</li>
--   <li>New leader schedule computed for Shelley</li>
--   <li>Transition from Byron to Shelley activated in the hard fork
--   combinator.</li>
--   <li>Nonces switched out at the start of a new epoch.</li>
--   </ul>
data family Ticked st

-- | Mark computation as validation error free
--   
--   Given a <tt>BlockValidationMode</tt> of <tt>NoBlockValidation</tt>, a
--   call to <a>applyByronBlock</a> shouldn't fail since the ledger layer
--   won't be performing any block validation checks. However, because
--   <a>applyByronBlock</a> can fail in the event it is given a
--   <tt>BlockValidationMode</tt> of <tt>BlockValidation</tt>, it still
--   <i>looks</i> like it can fail (since its type doesn't change based on
--   the <tt>ValidationMode</tt>) and we must still treat it as such.
validationErrorImpossible :: forall err a. Except err a -> a
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Byron.Ledger.Ledger.ByronTransition
instance GHC.Generics.Generic Ouroboros.Consensus.Byron.Ledger.Ledger.ByronTransition
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Ledger.ByronTransition
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Ledger.ByronTransition
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Generics.Generic (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock result)
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock result)
instance Ouroboros.Consensus.Ledger.Abstract.UpdateLedger Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Ledger.Basics.GetTip (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Ledger.Basics.GetTip (Ouroboros.Consensus.Ticked.Ticked (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance Ouroboros.Consensus.Ledger.Basics.IsLedger (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Ledger.Abstract.ApplyBlock (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock) Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Ledger.Query.QueryLedger Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Util.DepPair.SameDepIndex (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Network.Protocol.LocalStateQuery.Type.ShowQuery (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Ledger.SupportsPeerSelection.LedgerSupportsPeerSelection Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Ledger.CommonProtocolParams.CommonProtocolParams Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Ledger.SupportsProtocol.LedgerSupportsProtocol Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.HardFork.Abstract.HasHardForkHistory Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock


-- | Byron mempool integration
module Ouroboros.Consensus.Byron.Ledger.Mempool

-- | Generalized transaction
--   
--   The mempool (and, accordingly, blocks) consist of "generalized
--   transactions"; this could be "proper" transactions (transferring
--   funds) but also other kinds of things such as update proposals,
--   delegations, etc.
data family GenTx blk

-- | A generalized transaction, <a>GenTx</a>, identifier.
data family TxId tx

-- | " Validated " transaction or block
--   
--   The ledger defines how to validate transactions and blocks. It's
--   possible the type before and after validation may be distinct (eg
--   Alonzo transactions), which originally motivated this family.
--   
--   We also gain the related benefit that certain interface functions,
--   such as those that <i>reapply</i> blocks, can have a more precise type
--   now. TODO
--   
--   Similarly, the Node-to-Client mini protocols can explicitly indicate
--   that the client trusts the blocks from the local server, by having the
--   server send <a>Validated</a> blocks to the client. TODO
--   
--   Note that validation has different implications for a transaction than
--   for a block. In particular, a validated transaction can be " reapplied
--   " to different ledger states, whereas a validated block must only be "
--   reapplied " to the exact same ledger state (eg as part of rebuilding
--   from an on-disk ledger snapshot).
--   
--   Since the ledger defines validation, see the ledger details for
--   concrete examples of what determines the validity (wrt to a
--   <a>LedgerState</a>) of a transaction and/or block. Example properties
--   include: a transaction's claimed inputs exist and are still unspent, a
--   block carries a sufficient cryptographic signature, etc.
data family Validated x
byronIdDlg :: ACertificate ByteString -> CertificateId
byronIdProp :: AProposal ByteString -> UpId
byronIdTx :: ATxAux ByteString -> TxId
byronIdVote :: AVote ByteString -> VoteId
decodeByronApplyTxError :: Decoder s (ApplyTxErr ByronBlock)

-- | The <a>ByteString</a> annotation will be the canonical encoding.
--   
--   While the new implementation does not care about canonical encodings,
--   the old one does. When a generalised transaction arrives that is not
--   in its canonical encoding (only the <a>ATxAux</a> of the
--   <a>ByronTx</a> can be produced by nodes that are not under our
--   control), the old implementation will reject it. Therefore, we need to
--   reject them too. See #905.
--   
--   We use the ledger to check for canonical encodings: the ledger will
--   check whether the signed hash of the transaction (in the case of a
--   <a>ATxAux</a>, the transaction witness) matches the annotated
--   bytestring. Is therefore <b>important</b> that the annotated
--   bytestring be the <i>canonical</i> encoding, not the <i>original,
--   possibly non-canonical</i> encoding.
decodeByronGenTx :: Decoder s (GenTx ByronBlock)
decodeByronGenTxId :: Decoder s (GenTxId ByronBlock)
encodeByronApplyTxError :: ApplyTxErr ByronBlock -> Encoding
encodeByronGenTx :: GenTx ByronBlock -> Encoding
encodeByronGenTxId :: GenTxId ByronBlock -> Encoding
fromMempoolPayload :: AMempoolPayload ByteString -> GenTx ByronBlock
toMempoolPayload :: GenTx ByronBlock -> AMempoolPayload ByteString

-- | Count all (generalized) transactions in the block
countByronGenTxs :: ByronBlock -> Word64
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Generics.Generic (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance NoThunks.Class.NoThunks (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Classes.Ord (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Classes.Eq (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance Ouroboros.Consensus.Mempool.TxLimits.TxLimits Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Network.Util.ShowProxy.ShowProxy Cardano.Chain.Byron.API.Mempool.ApplyMempoolPayloadErr
instance Ouroboros.Consensus.Ledger.SupportsMempool.LedgerSupportsMempool Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Consensus.Ledger.SupportsMempool.TxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance Ouroboros.Consensus.Ledger.SupportsMempool.HasTxId (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Ledger.SupportsMempool.HasTxs Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Util.Condense.Condense (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.Abstract.Validated (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock))
instance GHC.Show.Show (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)

module Ouroboros.Consensus.Byron.Ledger.Inspect
data ByronLedgerUpdate
ByronUpdatedProtocolUpdates :: [ProtocolUpdate] -> ByronLedgerUpdate

-- | Wrapper around a Byron protocol update with information about its
--   state
--   
--   NOTE: We don't currently record the <a>ProtocolParameters</a> here
--   because we don't really need to track them, and adding them would add
--   a lot of output to the <a>Show</a> instance. We could easily add them
--   however if that would be useful.
data ProtocolUpdate
ProtocolUpdate :: ProtocolVersion -> UpdateState -> ProtocolUpdate
[protocolUpdateVersion] :: ProtocolUpdate -> ProtocolVersion
[protocolUpdateState] :: ProtocolUpdate -> UpdateState

-- | The various states a protocol update goes through
--   
--   Listed in chronological order.
data UpdateState

-- | The update was registered, but does not yet have any votes
--   
--   We record the <a>SlotNo</a> of the slot in which the update was
--   registered. After registration, nodes must vote on it.
UpdateRegistered :: SlotNo -> UpdateState

-- | The update is accumulating votes
--   
--   We record which nodes have voted for the proposal. The proposal must
--   accumulate a sufficient number of votes before it can be confirmed.
UpdateActive :: Set KeyHash -> UpdateState

-- | The update has amassed a sufficient number of votes
--   
--   We record the <a>SlotNo</a> of the slot in which the required
--   threshold of votes was met. At this point <tt>2k</tt> slots need to
--   pass before the update can be endorsed.
UpdateConfirmed :: SlotNo -> UpdateState

-- | The votes are stable. We can start to accumulate endorsements.
--   
--   We record which nodes have endorsed the proposal. The proposal must
--   accumulate a sufficient number of endorsements before it is nominated
--   and becomes a candidate.
UpdateStablyConfirmed :: Set KeyHash -> UpdateState

-- | The update has amassed a sufficient number of endorsements
--   
--   We record the <a>SlotNo</a> of the slot in which the required
--   threshold of endorsement was met. At this point a further <tt>2k</tt>
--   slots need to pass before the update becomes a stable candidate and
--   can be adopted.
--   
--   We additionally record the <a>EpochNo</a> in which the candidate will
--   be adopted, <i>if</i> it becomes stable.
UpdateCandidate :: SlotNo -> EpochNo -> UpdateState

-- | The endorsements are stable. The update will be accepted.
--   
--   We record the <a>EpochNo</a> of the epoch in which it will become
--   active.
UpdateStableCandidate :: EpochNo -> UpdateState

-- | All proposal updates, from new to old
protocolUpdates :: LedgerConfig ByronBlock -> LedgerState ByronBlock -> [ProtocolUpdate]
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Inspect.UpdateState
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Inspect.UpdateState
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Inspect.ProtocolUpdate
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Inspect.ProtocolUpdate
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Ledger.Inspect.ByronLedgerUpdate
instance GHC.Show.Show Ouroboros.Consensus.Byron.Ledger.Inspect.ByronLedgerUpdate
instance Ouroboros.Consensus.Util.Condense.Condense Ouroboros.Consensus.Byron.Ledger.Inspect.ByronLedgerUpdate
instance Ouroboros.Consensus.Ledger.Inspect.InspectLedger Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Ledger.Forge
forgeByronBlock :: HasCallStack => TopLevelConfig ByronBlock -> Overrides ByronBlock -> BlockNo -> SlotNo -> TickedLedgerState ByronBlock -> [Validated (GenTx ByronBlock)] -> PBftIsLeader PBftByronCrypto -> ByronBlock
forgeRegularBlock :: HasCallStack => BlockConfig ByronBlock -> Overrides ByronBlock -> BlockNo -> SlotNo -> TickedLedgerState ByronBlock -> [Validated (GenTx ByronBlock)] -> PBftIsLeader PBftByronCrypto -> ByronBlock
forgeEBB :: BlockConfig ByronBlock -> SlotNo -> BlockNo -> ChainHash ByronBlock -> ByronBlock

module Ouroboros.Consensus.Byron.Ledger

module Ouroboros.Consensus.Byron.Node.Serialisation
instance Ouroboros.Consensus.Storage.Serialisation.HasBinaryBlockInfo Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.ChainDB.Impl.Types.SerialiseDiskConstraints Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Data.ByteString.Lazy.Internal.ByteString -> Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.Basics.LedgerState Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Protocol.PBFT.State.PBftState Ouroboros.Consensus.Byron.Protocol.PBftByronCrypto)
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Protocol.PBFT.State.PBftState Ouroboros.Consensus.Byron.Protocol.PBftByronCrypto)
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.HeaderValidation.AnnTip Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDisk Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.HeaderValidation.AnnTip Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Run.SerialiseNodeToNodeConstraints Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Network.Block.Serialised Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Storage.Serialisation.SerialisedHeader Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Run.SerialiseNodeToClientConstraints Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Network.Block.Serialised Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.SupportsMempool.GenTx Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.SupportsMempool.GenTxId Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock Cardano.Slotting.Slot.SlotNo
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock Cardano.Chain.Byron.API.Mempool.ApplyMempoolPayloadErr
instance Ouroboros.Consensus.Node.Serialisation.SerialiseNodeToClient Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Util.SomeSecond Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Node.Serialisation.SerialiseResult Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock (Ouroboros.Consensus.Ledger.Query.BlockQuery Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock)
instance Ouroboros.Consensus.Storage.Serialisation.ReconstructNestedCtxt Ouroboros.Consensus.Block.Abstract.Header Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDiskDepIx (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.EncodeDiskDep (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDiskDepIx (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Storage.Serialisation.DecodeDiskDep (Ouroboros.Consensus.Block.NestedContent.NestedCtxt Ouroboros.Consensus.Block.Abstract.Header) Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock

module Ouroboros.Consensus.Byron.Node

-- | Signature threshold. This represents the proportion of blocks in a
--   <tt>pbftSignatureWindow</tt>-sized window which may be signed by any
--   single key.
newtype PBftSignatureThreshold
PBftSignatureThreshold :: Double -> PBftSignatureThreshold
[getPBftSignatureThreshold] :: PBftSignatureThreshold -> Double

-- | Parameters needed to run Byron
data ProtocolParamsByron
ProtocolParamsByron :: Config -> Maybe PBftSignatureThreshold -> ProtocolVersion -> SoftwareVersion -> Maybe ByronLeaderCredentials -> Overrides ByronBlock -> ProtocolParamsByron
[$sel:byronGenesis:ProtocolParamsByron] :: ProtocolParamsByron -> Config
[$sel:byronPbftSignatureThreshold:ProtocolParamsByron] :: ProtocolParamsByron -> Maybe PBftSignatureThreshold
[$sel:byronProtocolVersion:ProtocolParamsByron] :: ProtocolParamsByron -> ProtocolVersion
[$sel:byronSoftwareVersion:ProtocolParamsByron] :: ProtocolParamsByron -> SoftwareVersion
[$sel:byronLeaderCredentials:ProtocolParamsByron] :: ProtocolParamsByron -> Maybe ByronLeaderCredentials
[$sel:byronMaxTxCapacityOverrides:ProtocolParamsByron] :: ProtocolParamsByron -> Overrides ByronBlock
byronBlockForging :: Monad m => Overrides ByronBlock -> ByronLeaderCredentials -> BlockForging m ByronBlock

-- | See chapter 4.1 of
--   <a>https://hydra.iohk.io/job/Cardano/cardano-ledger-specs/byronChainSpec/latest/download-by-type/doc-pdf/blockchain-spec</a>
defaultPBftSignatureThreshold :: PBftSignatureThreshold
mkByronConfig :: Config -> ProtocolVersion -> SoftwareVersion -> BlockConfig ByronBlock
protocolClientInfoByron :: EpochSlots -> ProtocolClientInfo ByronBlock
protocolInfoByron :: forall m. Monad m => ProtocolParamsByron -> ProtocolInfo m ByronBlock

-- | Credentials needed to produce blocks in the Byron era.
data ByronLeaderCredentials
ByronLeaderCredentials :: SigningKey -> Certificate -> CoreNodeId -> Text -> ByronLeaderCredentials
[$sel:blcSignKey:ByronLeaderCredentials] :: ByronLeaderCredentials -> SigningKey
[$sel:blcDlgCert:ByronLeaderCredentials] :: ByronLeaderCredentials -> Certificate

-- | Only core nodes can produce blocks. The <a>CoreNodeId</a> is used to
--   determine the order (round-robin) in which core nodes produce blocks.
[$sel:blcCoreNodeId:ByronLeaderCredentials] :: ByronLeaderCredentials -> CoreNodeId

-- | Identifier for this set of credentials.
--   
--   Useful when the node is running with multiple sets of credentials.
[$sel:blcLabel:ByronLeaderCredentials] :: ByronLeaderCredentials -> Text
data ByronLeaderCredentialsError

-- | Make the <a>ByronLeaderCredentials</a>, with a couple sanity checks:
--   
--   <ul>
--   <li>That the block signing key and the delegation certificate
--   match.</li>
--   <li>That the delegation certificate does correspond to one of the
--   genesis keys from the genesis file.</li>
--   </ul>
mkByronLeaderCredentials :: Config -> SigningKey -> Certificate -> Text -> Either ByronLeaderCredentialsError ByronLeaderCredentials
mkPBftCanBeLeader :: ByronLeaderCredentials -> CanBeLeader (PBft PBftByronCrypto)
instance GHC.Show.Show Ouroboros.Consensus.Byron.Node.ByronLeaderCredentials
instance GHC.Show.Show Ouroboros.Consensus.Byron.Node.ByronLeaderCredentialsError
instance GHC.Classes.Eq Ouroboros.Consensus.Byron.Node.ByronLeaderCredentialsError
instance Ouroboros.Consensus.Config.SupportsNode.ConfigSupportsNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.InitStorage.NodeInitStorage Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Block.SupportsMetrics.BlockSupportsMetrics Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Node.Run.RunNode Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
