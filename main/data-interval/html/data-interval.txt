-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interval datatype, interval arithmetic and interval-based containers
--   
--   Interval datatype, interval arithmetic and interval-based containers
--   for Haskell. Unlike the intervals package
--   (<a>http://hackage.haskell.org/package/intervals</a>), this package
--   provides both open and closed intervals and is intended to be used
--   with exact number types such as Rational and Integer.
@package data-interval
@version 2.1.1


-- | Interval relations and their algebra.
module Data.IntervalRelation

-- | Describes how two intervals <tt>x</tt> and <tt>y</tt> can be related.
--   See <a>Allen's interval algebra</a> and <a>Intervals and their
--   relations</a>.
data Relation

-- | Any element of <tt>x</tt> is smaller than any element of <tt>y</tt>,
--   and intervals are not connected. In other words, there exists an
--   element that is bigger than any element of <tt>x</tt> and smaller than
--   any element of <tt>y</tt>.
Before :: Relation

-- | Any element of <tt>x</tt> is smaller than any element of <tt>y</tt>,
--   but intervals are connected and non-empty. This implies that
--   intersection of intervals is empty, and union is a single interval.
JustBefore :: Relation

-- | Intersection of <tt>x</tt> and <tt>y</tt> is non-empty, <tt>x</tt>
--   start and finishes earlier than <tt>y</tt>. This implies that union is
--   a single interval, and <tt>x</tt> finishes no earlier than <tt>y</tt>
--   starts.
Overlaps :: Relation

-- | <tt>x</tt> is a proper subset of <tt>y</tt>, and they share lower
--   bounds.
Starts :: Relation

-- | <tt>x</tt> is a proper subset of <tt>y</tt>, but they share neither
--   lower nor upper bounds.
During :: Relation

-- | <tt>x</tt> is a proper subset of <tt>y</tt>, and they share upper
--   bounds.
Finishes :: Relation

-- | Intervals are equal.
Equal :: Relation

-- | Inverse of <a>Finishes</a>.
FinishedBy :: Relation

-- | Inverse of <a>During</a>.
Contains :: Relation

-- | Inverse of <a>Starts</a>.
StartedBy :: Relation

-- | Inverse of <a>Overlaps</a>.
OverlappedBy :: Relation

-- | Inverse of <a>JustBefore</a>.
JustAfter :: Relation

-- | Inverse of <a>Before</a>.
After :: Relation

-- | Inverts a relation, such that <tt><a>invert</a> (<a>relate</a> x y) =
--   <a>relate</a> y x</tt>
invert :: Relation -> Relation
instance Data.Data.Data Data.IntervalRelation.Relation
instance GHC.Generics.Generic Data.IntervalRelation.Relation
instance GHC.Read.Read Data.IntervalRelation.Relation
instance GHC.Show.Show Data.IntervalRelation.Relation
instance GHC.Enum.Bounded Data.IntervalRelation.Relation
instance GHC.Enum.Enum Data.IntervalRelation.Relation
instance GHC.Classes.Ord Data.IntervalRelation.Relation
instance GHC.Classes.Eq Data.IntervalRelation.Relation


-- | Interval datatype and interval arithmetic.
--   
--   Unlike the intervals package
--   (<a>http://hackage.haskell.org/package/intervals</a>), this module
--   provides both open and closed intervals and is intended to be used
--   with <a>Rational</a>.
--   
--   For the purpose of abstract interpretation, it might be convenient to
--   use <a>Lattice</a> instance. See also lattices package
--   (<a>http://hackage.haskell.org/package/lattices</a>).
module Data.Interval

-- | The intervals (<i>i.e.</i> connected and convex subsets) over real
--   numbers <b>R</b>.
data Interval r

-- | Boundary of an interval may be open (excluding an endpoint) or closed
--   (including an endpoint).
data Boundary
Open :: Boundary
Closed :: Boundary

-- | smart constructor for <a>Interval</a>
interval :: Ord r => (Extended r, Boundary) -> (Extended r, Boundary) -> Interval r

-- | closed interval [<tt>l</tt>,<tt>u</tt>]
(<=..<=) :: Ord r => Extended r -> Extended r -> Interval r
infix 5 <=..<=

-- | left-open right-closed interval (<tt>l</tt>,<tt>u</tt>]
(<..<=) :: Ord r => Extended r -> Extended r -> Interval r
infix 5 <..<=

-- | left-closed right-open interval [<tt>l</tt>, <tt>u</tt>)
(<=..<) :: Ord r => Extended r -> Extended r -> Interval r
infix 5 <=..<

-- | open interval (<tt>l</tt>, <tt>u</tt>)
(<..<) :: Ord r => Extended r -> Extended r -> Interval r
infix 5 <..<

-- | whole real number line (-∞, ∞)
whole :: Ord r => Interval r

-- | empty (contradicting) interval
empty :: Ord r => Interval r

-- | singleton set [x,x]
singleton :: Ord r => r -> Interval r

-- | Is the interval empty?
null :: Ord r => Interval r -> Bool

-- | Is the interval single point?
isSingleton :: Ord r => Interval r -> Bool

-- | If the interval is a single point, return this point.
extractSingleton :: Ord r => Interval r -> Maybe r

-- | Is the element in the interval?
member :: Ord r => r -> Interval r -> Bool

-- | Is the element not in the interval?
notMember :: Ord r => r -> Interval r -> Bool

-- | Is this a subset? <tt>(i1 `<a>isSubsetOf</a>` i2)</tt> tells whether
--   <tt>i1</tt> is a subset of <tt>i2</tt>.
isSubsetOf :: Ord r => Interval r -> Interval r -> Bool

-- | Is this a proper subset? (<i>i.e.</i> a subset but not equal).
isProperSubsetOf :: Ord r => Interval r -> Interval r -> Bool

-- | Does the union of two range form a connected set?
--   
--   Since 1.3.0
isConnected :: Ord r => Interval r -> Interval r -> Bool

-- | Lower endpoint (<i>i.e.</i> greatest lower bound) of the interval.
--   
--   <ul>
--   <li><a>lowerBound</a> of the empty interval is <a>PosInf</a>.</li>
--   <li><a>lowerBound</a> of a left unbounded interval is
--   <a>NegInf</a>.</li>
--   <li><a>lowerBound</a> of an interval may or may not be a member of the
--   interval.</li>
--   </ul>
lowerBound :: Interval r -> Extended r

-- | Upper endpoint (<i>i.e.</i> least upper bound) of the interval.
--   
--   <ul>
--   <li><a>upperBound</a> of the empty interval is <a>NegInf</a>.</li>
--   <li><a>upperBound</a> of a right unbounded interval is
--   <a>PosInf</a>.</li>
--   <li><a>upperBound</a> of an interval may or may not be a member of the
--   interval.</li>
--   </ul>
upperBound :: Interval r -> Extended r

-- | Lower endpoint (<i>i.e.</i> greatest lower bound) of the interval,
--   together with <a>Boundary</a> information. The result is convenient to
--   use as an argument for <a>interval</a>.
lowerBound' :: Interval r -> (Extended r, Boundary)

-- | Upper endpoint (<i>i.e.</i> least upper bound) of the interval,
--   together with <a>Boundary</a> information. The result is convenient to
--   use as an argument for <a>interval</a>.
upperBound' :: Interval r -> (Extended r, Boundary)

-- | Width of a interval. Width of an unbounded interval is
--   <tt>undefined</tt>.
width :: (Num r, Ord r) => Interval r -> r

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;</a> y</tt>?
(<!) :: Ord r => Interval r -> Interval r -> Bool
infix 4 <!

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;=</a> y</tt>?
(<=!) :: Ord r => Interval r -> Interval r -> Bool
infix 4 <=!

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>==</a> y</tt>?
(==!) :: Ord r => Interval r -> Interval r -> Bool
infix 4 ==!

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;=</a> y</tt>?
(>=!) :: Ord r => Interval r -> Interval r -> Bool
infix 4 >=!

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;</a> y</tt>?
(>!) :: Ord r => Interval r -> Interval r -> Bool
infix 4 >!

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>/=</a> y</tt>?
--   
--   Since 1.0.1
(/=!) :: Ord r => Interval r -> Interval r -> Bool
infix 4 /=!

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<?) :: Ord r => Interval r -> Interval r -> Bool
infix 4 <?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=?) :: Ord r => Interval r -> Interval r -> Bool
infix 4 <=?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
--   
--   Since 1.0.0
(==?) :: Ord r => Interval r -> Interval r -> Bool
infix 4 ==?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=?) :: Ord r => Interval r -> Interval r -> Bool
infix 4 >=?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>?) :: Ord r => Interval r -> Interval r -> Bool
infix 4 >?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>/=</a> y</tt>?
--   
--   Since 1.0.1
(/=?) :: Ord r => Interval r -> Interval r -> Bool
infix 4 /=?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
--   
--   Since 1.0.0
(<??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)
infix 4 <??

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
--   
--   Since 1.0.0
(<=??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)
infix 4 <=??

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
--   
--   Since 1.0.0
(==??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)
infix 4 ==??

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
--   
--   Since 1.0.0
(>=??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)
infix 4 >=??

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
--   
--   Since 1.0.0
(>??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)
infix 4 >??

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>/=</a> y</tt>?
--   
--   Since 1.0.1
(/=??) :: (Real r, Fractional r) => Interval r -> Interval r -> Maybe (r, r)
infix 4 /=??

-- | intersection of two intervals
intersection :: forall r. Ord r => Interval r -> Interval r -> Interval r

-- | intersection of a list of intervals.
--   
--   Since 0.6.0
intersections :: Ord r => [Interval r] -> Interval r

-- | convex hull of two intervals
hull :: forall r. Ord r => Interval r -> Interval r -> Interval r

-- | convex hull of a list of intervals.
--   
--   Since 0.6.0
hulls :: Ord r => [Interval r] -> Interval r

-- | <tt>mapMonotonic f i</tt> is the image of <tt>i</tt> under <tt>f</tt>,
--   where <tt>f</tt> must be a strict monotone function, preserving
--   negative and positive infinities.
mapMonotonic :: (Ord a, Ord b) => (a -> b) -> Interval a -> Interval b

-- | pick up an element from the interval if the interval is not empty.
pickup :: (Real r, Fractional r) => Interval r -> Maybe r

-- | <a>simplestRationalWithin</a> returns the simplest rational number
--   within the interval.
--   
--   A rational number <tt>y</tt> is said to be <i>simpler</i> than another
--   <tt>y'</tt> if
--   
--   <ul>
--   <li><tt><a>abs</a> (<a>numerator</a> y) &lt;= <a>abs</a>
--   (<a>numerator</a> y')</tt>, and</li>
--   <li><tt><a>denominator</a> y &lt;= <a>denominator</a> y'</tt>.</li>
--   </ul>
--   
--   (see also <a>approxRational</a>)
--   
--   Since 0.4.0
simplestRationalWithin :: RealFrac r => Interval r -> Maybe Rational

-- | Computes how two intervals are related according to the
--   <tt><a>Relation</a></tt> classification
relate :: Ord r => Interval r -> Interval r -> Relation
instance GHC.Classes.Ord r => Algebra.Lattice.Lattice (Data.Interval.Internal.Interval r)
instance GHC.Classes.Ord r => Algebra.Lattice.BoundedJoinSemiLattice (Data.Interval.Internal.Interval r)
instance GHC.Classes.Ord r => Algebra.Lattice.BoundedMeetSemiLattice (Data.Interval.Internal.Interval r)
instance (GHC.Classes.Ord r, GHC.Show.Show r) => GHC.Show.Show (Data.Interval.Internal.Interval r)
instance (GHC.Classes.Ord r, GHC.Read.Read r) => GHC.Read.Read (Data.Interval.Internal.Interval r)
instance (GHC.Num.Num r, GHC.Classes.Ord r) => GHC.Num.Num (Data.Interval.Internal.Interval r)
instance (GHC.Real.Real r, GHC.Real.Fractional r) => GHC.Real.Fractional (Data.Interval.Internal.Interval r)
instance (GHC.Real.RealFrac r, GHC.Float.Floating r) => GHC.Float.Floating (Data.Interval.Internal.Interval r)


-- | Interval datatype and interval arithmetic over integers.
--   
--   Since 1.2.0
--   
--   For the purpose of abstract interpretation, it might be convenient to
--   use <a>Lattice</a> instance. See also lattices package
--   (<a>http://hackage.haskell.org/package/lattices</a>).
module Data.IntegerInterval

-- | The intervals (<i>i.e.</i> connected and convex subsets) over integers
--   (<b>Z</b>).
data IntegerInterval

-- | Boundary of an interval may be open (excluding an endpoint) or closed
--   (including an endpoint).
data Boundary
Open :: Boundary
Closed :: Boundary

-- | smart constructor for <a>IntegerInterval</a>
interval :: (Extended Integer, Boundary) -> (Extended Integer, Boundary) -> IntegerInterval

-- | closed interval [<tt>l</tt>,<tt>u</tt>]
(<=..<=) :: Extended Integer -> Extended Integer -> IntegerInterval
infix 5 <=..<=

-- | left-open right-closed interval (<tt>l</tt>,<tt>u</tt>]
(<..<=) :: Extended Integer -> Extended Integer -> IntegerInterval
infix 5 <..<=

-- | left-closed right-open interval [<tt>l</tt>, <tt>u</tt>)
(<=..<) :: Extended Integer -> Extended Integer -> IntegerInterval
infix 5 <=..<

-- | open interval (<tt>l</tt>, <tt>u</tt>)
(<..<) :: Extended Integer -> Extended Integer -> IntegerInterval
infix 5 <..<

-- | whole real number line (-∞, ∞)
whole :: IntegerInterval

-- | empty (contradicting) interval
empty :: IntegerInterval

-- | singleton set [x,x]
singleton :: Integer -> IntegerInterval

-- | Is the interval empty?
null :: IntegerInterval -> Bool

-- | Is the interval single point?
isSingleton :: IntegerInterval -> Bool

-- | Is the element in the interval?
member :: Integer -> IntegerInterval -> Bool

-- | Is the element not in the interval?
notMember :: Integer -> IntegerInterval -> Bool

-- | Is this a subset? <tt>(i1 `<a>isSubsetOf</a>` i2)</tt> tells whether
--   <tt>i1</tt> is a subset of <tt>i2</tt>.
isSubsetOf :: IntegerInterval -> IntegerInterval -> Bool

-- | Is this a proper subset? (<i>i.e.</i> a subset but not equal).
isProperSubsetOf :: IntegerInterval -> IntegerInterval -> Bool

-- | Does the union of two range form a set which is the intersection
--   between the integers and a connected real interval?
isConnected :: IntegerInterval -> IntegerInterval -> Bool

-- | Lower endpoint (<i>i.e.</i> greatest lower bound) of the interval.
--   
--   <ul>
--   <li><a>lowerBound</a> of the empty interval is <a>PosInf</a>.</li>
--   <li><a>lowerBound</a> of a left unbounded interval is
--   <a>NegInf</a>.</li>
--   <li><a>lowerBound</a> of an interval may or may not be a member of the
--   interval.</li>
--   </ul>
lowerBound :: IntegerInterval -> Extended Integer

-- | Upper endpoint (<i>i.e.</i> least upper bound) of the interval.
--   
--   <ul>
--   <li><a>upperBound</a> of the empty interval is <a>NegInf</a>.</li>
--   <li><a>upperBound</a> of a right unbounded interval is
--   <a>PosInf</a>.</li>
--   <li><a>upperBound</a> of an interval is a member of the interval.</li>
--   </ul>
upperBound :: IntegerInterval -> Extended Integer

-- | <a>lowerBound</a> of the interval and whether it is included in the
--   interval. The result is convenient to use as an argument for
--   <a>interval</a>.
lowerBound' :: IntegerInterval -> (Extended Integer, Boundary)

-- | <a>upperBound</a> of the interval and whether it is included in the
--   interval. The result is convenient to use as an argument for
--   <a>interval</a>.
upperBound' :: IntegerInterval -> (Extended Integer, Boundary)

-- | Width of a interval. Width of an unbounded interval is
--   <tt>undefined</tt>.
width :: IntegerInterval -> Integer

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;</a> y</tt>?
(<!) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 <!

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;=</a> y</tt>?
(<=!) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 <=!

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>==</a> y</tt>?
(==!) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 ==!

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;=</a> y</tt>?
(>=!) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 >=!

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;</a> y</tt>?
(>!) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 >!

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>/=</a> y</tt>?
(/=!) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 /=!

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<?) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 <?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=?) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 <=?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
(==?) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 ==?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=?) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 >=?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>?) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 >?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>/=</a> y</tt>?
(/=?) :: IntegerInterval -> IntegerInterval -> Bool
infix 4 /=?

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)
infix 4 <??

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)
infix 4 <=??

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
(==??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)
infix 4 ==??

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)
infix 4 >=??

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)
infix 4 >??

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>/=</a> y</tt>?
(/=??) :: IntegerInterval -> IntegerInterval -> Maybe (Integer, Integer)
infix 4 /=??

-- | intersection of two intervals
intersection :: IntegerInterval -> IntegerInterval -> IntegerInterval

-- | intersection of a list of intervals.
intersections :: [IntegerInterval] -> IntegerInterval

-- | convex hull of two intervals
hull :: IntegerInterval -> IntegerInterval -> IntegerInterval

-- | convex hull of a list of intervals.
hulls :: [IntegerInterval] -> IntegerInterval

-- | <tt>mapMonotonic f i</tt> is the image of <tt>i</tt> under <tt>f</tt>,
--   where <tt>f</tt> must be a strict monotone function.
mapMonotonic :: (Integer -> Integer) -> IntegerInterval -> IntegerInterval

-- | pick up an element from the interval if the interval is not empty.
pickup :: IntegerInterval -> Maybe Integer

-- | <a>simplestIntegerWithin</a> returns the simplest rational number
--   within the interval.
--   
--   An integer <tt>y</tt> is said to be <i>simpler</i> than another
--   <tt>y'</tt> if
--   
--   <ul>
--   <li><pre><a>abs</a> y &lt;= <a>abs</a> y'</pre></li>
--   </ul>
--   
--   (see also <a>approxRational</a> and <a>simplestRationalWithin</a>)
simplestIntegerWithin :: IntegerInterval -> Maybe Integer

-- | Convert the interval to <a>Interval</a> data type.
toInterval :: Real r => IntegerInterval -> Interval r

-- | Conversion from <a>Interval</a> data type.
fromInterval :: Interval Integer -> IntegerInterval

-- | Given a <a>Interval</a> <tt>I</tt> over R, compute the smallest
--   <a>IntegerInterval</a> <tt>J</tt> such that <tt>I ⊆ J</tt>.
fromIntervalOver :: RealFrac r => Interval r -> IntegerInterval

-- | Given a <a>Interval</a> <tt>I</tt> over R, compute the largest
--   <a>IntegerInterval</a> <tt>J</tt> such that <tt>J ⊆ I</tt>.
fromIntervalUnder :: RealFrac r => Interval r -> IntegerInterval

-- | Computes how two intervals are related according to the
--   <tt><a>Relation</a></tt> classification
relate :: IntegerInterval -> IntegerInterval -> Relation
instance Algebra.Lattice.Lattice Data.IntegerInterval.Internal.IntegerInterval
instance Algebra.Lattice.BoundedJoinSemiLattice Data.IntegerInterval.Internal.IntegerInterval
instance Algebra.Lattice.BoundedMeetSemiLattice Data.IntegerInterval.Internal.IntegerInterval
instance GHC.Show.Show Data.IntegerInterval.Internal.IntegerInterval
instance GHC.Read.Read Data.IntegerInterval.Internal.IntegerInterval
instance GHC.Num.Num Data.IntegerInterval.Internal.IntegerInterval


-- | Interval datatype and interval arithmetic.
module Data.IntervalSet

-- | A set comprising zero or more non-empty, <i>disconnected</i>
--   intervals.
--   
--   Any connected intervals are merged together, and empty intervals are
--   ignored.
data IntervalSet r

-- | whole real number line (-∞, ∞)
whole :: Ord r => IntervalSet r

-- | empty interval set
empty :: Ord r => IntervalSet r

-- | single interval
singleton :: Ord r => Interval r -> IntervalSet r

-- | Is the interval set empty?
null :: IntervalSet r -> Bool

-- | Is the element in the interval set?
member :: Ord r => r -> IntervalSet r -> Bool

-- | Is the element not in the interval set?
notMember :: Ord r => r -> IntervalSet r -> Bool

-- | Is this a subset? <tt>(is1 `<a>isSubsetOf</a>` is2)</tt> tells whether
--   <tt>is1</tt> is a subset of <tt>is2</tt>.
isSubsetOf :: Ord r => IntervalSet r -> IntervalSet r -> Bool

-- | Is this a proper subset? (<i>i.e.</i> a subset but not equal).
isProperSubsetOf :: Ord r => IntervalSet r -> IntervalSet r -> Bool

-- | convex hull of a set of intervals.
span :: Ord r => IntervalSet r -> Interval r

-- | Complement the interval set.
complement :: Ord r => IntervalSet r -> IntervalSet r

-- | Insert a new interval into the interval set.
insert :: Ord r => Interval r -> IntervalSet r -> IntervalSet r

-- | Delete an interval from the interval set.
delete :: Ord r => Interval r -> IntervalSet r -> IntervalSet r

-- | union of two interval sets
union :: Ord r => IntervalSet r -> IntervalSet r -> IntervalSet r

-- | union of a list of interval sets
unions :: Ord r => [IntervalSet r] -> IntervalSet r

-- | intersection of two interval sets
intersection :: Ord r => IntervalSet r -> IntervalSet r -> IntervalSet r

-- | intersection of a list of interval sets
intersections :: Ord r => [IntervalSet r] -> IntervalSet r

-- | difference of two interval sets
difference :: Ord r => IntervalSet r -> IntervalSet r -> IntervalSet r

-- | Build a interval set from a list of intervals.
fromList :: Ord r => [Interval r] -> IntervalSet r

-- | Convert a interval set into a list of intervals.
toList :: Ord r => IntervalSet r -> [Interval r]

-- | Convert a interval set into a list of intervals in ascending order.
toAscList :: Ord r => IntervalSet r -> [Interval r]

-- | Convert a interval set into a list of intervals in descending order.
toDescList :: Ord r => IntervalSet r -> [Interval r]

-- | Build a map from an ascending list of intervals. <i>The precondition
--   is not checked.</i>
fromAscList :: Ord r => [Interval r] -> IntervalSet r
instance GHC.Classes.Eq r => GHC.Classes.Eq (Data.IntervalSet.IntervalSet r)
instance (GHC.Classes.Ord r, GHC.Show.Show r) => GHC.Show.Show (Data.IntervalSet.IntervalSet r)
instance (GHC.Classes.Ord r, GHC.Read.Read r) => GHC.Read.Read (Data.IntervalSet.IntervalSet r)
instance (GHC.Classes.Ord r, Data.Data.Data r) => Data.Data.Data (Data.IntervalSet.IntervalSet r)
instance Control.DeepSeq.NFData r => Control.DeepSeq.NFData (Data.IntervalSet.IntervalSet r)
instance Data.Hashable.Class.Hashable r => Data.Hashable.Class.Hashable (Data.IntervalSet.IntervalSet r)
instance GHC.Classes.Ord r => Algebra.Lattice.Lattice (Data.IntervalSet.IntervalSet r)
instance GHC.Classes.Ord r => Algebra.Lattice.BoundedJoinSemiLattice (Data.IntervalSet.IntervalSet r)
instance GHC.Classes.Ord r => Algebra.Lattice.BoundedMeetSemiLattice (Data.IntervalSet.IntervalSet r)
instance GHC.Classes.Ord r => GHC.Base.Monoid (Data.IntervalSet.IntervalSet r)
instance GHC.Classes.Ord r => GHC.Base.Semigroup (Data.IntervalSet.IntervalSet r)
instance (GHC.Num.Num r, GHC.Classes.Ord r) => GHC.Num.Num (Data.IntervalSet.IntervalSet r)
instance (GHC.Real.Real r, GHC.Real.Fractional r) => GHC.Real.Fractional (Data.IntervalSet.IntervalSet r)
instance GHC.Classes.Ord r => GHC.Exts.IsList (Data.IntervalSet.IntervalSet r)


-- | Mapping from intervals to values.
--   
--   API of this module is strict in both the keys and the values. If you
--   need value-lazy maps, use <a>Data.IntervalMap.Lazy</a> instead. The
--   <a>IntervalMap</a> type itself is shared between the lazy and strict
--   modules, meaning that the same <a>IntervalMap</a> value can be passed
--   to functions in both modules (although that is rarely needed).
--   
--   These modules are intended to be imported qualified, to avoid name
--   clashes with Prelude functions, e.g.
--   
--   <pre>
--   import Data.IntervalMap.Strict (IntervalMap)
--   import qualified Data.IntervalMap.Strict as IntervalMap
--   </pre>
module Data.IntervalMap.Strict

-- | A Map from non-empty, disjoint intervals over k to values a.
--   
--   Unlike <a>IntervalSet</a>, <a>IntervalMap</a> never merge adjacent
--   mappings, even if adjacent intervals are connected and mapped to the
--   same value.
data IntervalMap r a

-- | Find the value at a key. Calls <a>error</a> when the element can not
--   be found.
(!) :: Ord k => IntervalMap k a -> k -> a
infixl 9 !

-- | Same as <a>difference</a>.
(\\) :: Ord k => IntervalMap k a -> IntervalMap k b -> IntervalMap k a
infixl 9 \\

-- | Is the map empty?
null :: Ord k => IntervalMap k a -> Bool

-- | Is the key a member of the map? See also <a>notMember</a>.
member :: Ord k => k -> IntervalMap k a -> Bool

-- | Is the key not a member of the map? See also <a>member</a>.
notMember :: Ord k => k -> IntervalMap k a -> Bool

-- | Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as <tt>(<a>Just</a>
--   value)</tt>, or <a>Nothing</a> if the key isn't in the map.
lookup :: Ord k => k -> IntervalMap k a -> Maybe a

-- | The expression <tt>(<a>findWithDefault</a> def k map)</tt> returns the
--   value at key <tt>k</tt> or returns default value <tt>def</tt> when the
--   key is not in the map.
findWithDefault :: Ord k => a -> k -> IntervalMap k a -> a

-- | convex hull of key intervals.
span :: Ord k => IntervalMap k a -> Interval k

-- | The map that maps whole range of k to a.
whole :: Ord k => a -> IntervalMap k a

-- | The empty map.
empty :: Ord k => IntervalMap k a

-- | A map with a single interval.
singleton :: Ord k => Interval k -> a -> IntervalMap k a

-- | insert a new key and value in the map. If the key is already present
--   in the map, the associated value is replaced with the supplied value.
insert :: Ord k => Interval k -> a -> IntervalMap k a -> IntervalMap k a

-- | Insert with a function, combining new value and old value.
--   <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (interval, value) into <tt>mp</tt>. If the interval overlaps with
--   existing entries, the value for the entry is replace with <tt>(f
--   new_value old_value)</tt>.
insertWith :: Ord k => (a -> a -> a) -> Interval k -> a -> IntervalMap k a -> IntervalMap k a

-- | Delete an interval and its value from the map. When the interval does
--   not overlap with the map, the original map is returned.
delete :: Ord k => Interval k -> IntervalMap k a -> IntervalMap k a

-- | Update a value at a specific interval with the result of the provided
--   function. When the interval does not overlatp with the map, the
--   original map is returned.
adjust :: Ord k => (a -> a) -> Interval k -> IntervalMap k a -> IntervalMap k a

-- | The expression (<tt><a>update</a> f i map</tt>) updates the value
--   <tt>x</tt> at <tt>i</tt> (if it is in the map). If (<tt>f x</tt>) is
--   <a>Nothing</a>, the element is deleted. If it is (<tt><a>Just</a>
--   y</tt>), the key <tt>i</tt> is bound to the new value <tt>y</tt>.
update :: Ord k => (a -> Maybe a) -> Interval k -> IntervalMap k a -> IntervalMap k a

-- | The expression (<tt><a>alter</a> f i map</tt>) alters the value
--   <tt>x</tt> at <tt>i</tt>, or absence thereof. <a>alter</a> can be used
--   to insert, delete, or update a value in a <a>IntervalMap</a>.
alter :: Ord k => (Maybe a -> Maybe a) -> Interval k -> IntervalMap k a -> IntervalMap k a

-- | The expression (<tt><a>union</a> t1 t2</tt>) takes the left-biased
--   union of <tt>t1</tt> and <tt>t2</tt>. It prefers <tt>t1</tt> when
--   overlapping keys are encountered,
union :: Ord k => IntervalMap k a -> IntervalMap k a -> IntervalMap k a

-- | Union with a combining function.
unionWith :: Ord k => (a -> a -> a) -> IntervalMap k a -> IntervalMap k a -> IntervalMap k a

-- | The union of a list of maps: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
unions :: Ord k => [IntervalMap k a] -> IntervalMap k a

-- | The union of a list of maps, with a combining operation:
--   (<tt><a>unionsWith</a> f == <a>foldl</a> (<a>unionWith</a> f)
--   <a>empty</a></tt>).
unionsWith :: Ord k => (a -> a -> a) -> [IntervalMap k a] -> IntervalMap k a

-- | Intersection of two maps. Return data in the first map for the keys
--   existing in both maps.
intersection :: Ord k => IntervalMap k a -> IntervalMap k a -> IntervalMap k a

-- | Intersection with a combining function.
intersectionWith :: Ord k => (a -> b -> c) -> IntervalMap k a -> IntervalMap k b -> IntervalMap k c

-- | Return elements of the first map not existing in the second map.
difference :: Ord k => IntervalMap k a -> IntervalMap k b -> IntervalMap k a

-- | Map a function over all values in the map.
map :: (a -> b) -> IntervalMap k a -> IntervalMap k b

-- | <tt><a>mapKeysMonotonic</a> f s</tt> is the map obtained by applying
--   <tt>f</tt> to each key of <tt>s</tt>. <tt>f</tt> must be strictly
--   monotonic. That is, for any values <tt>x</tt> and <tt>y</tt>, if
--   <tt>x</tt> &lt; <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>.
mapKeysMonotonic :: forall k1 k2 a. (Ord k1, Ord k2) => (k1 -> k2) -> IntervalMap k1 a -> IntervalMap k2 a

-- | Return all elements of the map in the ascending order of their keys.
elems :: IntervalMap k a -> [a]

-- | Return all keys of the map in ascending order. Subject to list
keys :: IntervalMap k a -> [Interval k]

-- | An alias for <a>toAscList</a>. Return all key/value pairs in the map
--   in ascending key order.
assocs :: IntervalMap k a -> [(Interval k, a)]

-- | The set of all keys of the map.
keysSet :: Ord k => IntervalMap k a -> IntervalSet k

-- | Build a map from a list of key/value pairs. If the list contains more
--   than one value for the same key, the last value for the key is
--   retained.
fromList :: Ord k => [(Interval k, a)] -> IntervalMap k a

-- | Build a map from a list of key/value pairs with a combining function.
fromListWith :: Ord k => (a -> a -> a) -> [(Interval k, a)] -> IntervalMap k a

-- | Convert the map to a list of key/value pairs.
toList :: IntervalMap k a -> [(Interval k, a)]

-- | Convert the map to a list of key/value pairs where the keys are in
--   ascending order.
toAscList :: IntervalMap k a -> [(Interval k, a)]

-- | Convert the map to a list of key/value pairs where the keys are in
--   descending order.
toDescList :: IntervalMap k a -> [(Interval k, a)]

-- | Filter all values that satisfy some predicate.
filter :: Ord k => (a -> Bool) -> IntervalMap k a -> IntervalMap k a

-- | The expression (<tt><a>split</a> i map</tt>) is a triple
--   <tt>(map1,map2,map3)</tt> where the keys in <tt>map1</tt> are smaller
--   than <tt>i</tt>, the keys in <tt>map2</tt> are included in <tt>i</tt>,
--   and the keys in <tt>map3</tt> are larger than <tt>i</tt>.
split :: Ord k => Interval k -> IntervalMap k a -> (IntervalMap k a, IntervalMap k a, IntervalMap k a)

-- | This function is defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: (Ord k, Eq a) => IntervalMap k a -> IntervalMap k a -> Bool

-- | The expression (<tt><a>isSubmapOfBy</a> f t1 t2</tt>) returns
--   <a>True</a> if all keys in <tt>t1</tt> are in tree <tt>t2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values.
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> IntervalMap k a -> IntervalMap k b -> Bool

-- | Is this a proper submap? (ie. a submap but not equal). Defined as
--   (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a> (==)</tt>).
isProperSubmapOf :: (Ord k, Eq a) => IntervalMap k a -> IntervalMap k a -> Bool

-- | Is this a proper submap? (ie. a submap but not equal). The expression
--   (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns <a>True</a> when
--   <tt>m1</tt> and <tt>m2</tt> are not equal, all keys in <tt>m1</tt> are
--   in <tt>m2</tt>, and when <tt>f</tt> returns <a>True</a> when applied
--   to their respective values.
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> IntervalMap k a -> IntervalMap k b -> Bool


-- | Mapping from intervals to values.
--   
--   API of this module is strict in the keys, but lazy in the values. If
--   you need value-strict maps, use <a>Data.IntervalMap.Strict</a>
--   instead. The <a>IntervalMap</a> type itself is shared between the lazy
--   and strict modules, meaning that the same <a>IntervalMap</a> value can
--   be passed to functions in both modules (although that is rarely
--   needed).
--   
--   These modules are intended to be imported qualified, to avoid name
--   clashes with Prelude functions, e.g.
--   
--   <pre>
--   import Data.IntervalMap.Lazy (IntervalMap)
--   import qualified Data.IntervalMap.Lazy as IntervalMap
--   </pre>
module Data.IntervalMap.Lazy

-- | A Map from non-empty, disjoint intervals over k to values a.
--   
--   Unlike <a>IntervalSet</a>, <a>IntervalMap</a> never merge adjacent
--   mappings, even if adjacent intervals are connected and mapped to the
--   same value.
data IntervalMap r a

-- | Find the value at a key. Calls <a>error</a> when the element can not
--   be found.
(!) :: Ord k => IntervalMap k a -> k -> a
infixl 9 !

-- | Same as <a>difference</a>.
(\\) :: Ord k => IntervalMap k a -> IntervalMap k b -> IntervalMap k a
infixl 9 \\

-- | Is the map empty?
null :: Ord k => IntervalMap k a -> Bool

-- | Is the key a member of the map? See also <a>notMember</a>.
member :: Ord k => k -> IntervalMap k a -> Bool

-- | Is the key not a member of the map? See also <a>member</a>.
notMember :: Ord k => k -> IntervalMap k a -> Bool

-- | Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as <tt>(<a>Just</a>
--   value)</tt>, or <a>Nothing</a> if the key isn't in the map.
lookup :: Ord k => k -> IntervalMap k a -> Maybe a

-- | The expression <tt>(<a>findWithDefault</a> def k map)</tt> returns the
--   value at key <tt>k</tt> or returns default value <tt>def</tt> when the
--   key is not in the map.
findWithDefault :: Ord k => a -> k -> IntervalMap k a -> a

-- | convex hull of key intervals.
span :: Ord k => IntervalMap k a -> Interval k

-- | The map that maps whole range of k to a.
whole :: Ord k => a -> IntervalMap k a

-- | The empty map.
empty :: Ord k => IntervalMap k a

-- | A map with a single interval.
singleton :: Ord k => Interval k -> a -> IntervalMap k a

-- | insert a new key and value in the map. If the key is already present
--   in the map, the associated value is replaced with the supplied value.
insert :: Ord k => Interval k -> a -> IntervalMap k a -> IntervalMap k a

-- | Insert with a function, combining new value and old value.
--   <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (interval, value) into <tt>mp</tt>. If the interval overlaps with
--   existing entries, the value for the entry is replace with <tt>(f
--   new_value old_value)</tt>.
insertWith :: Ord k => (a -> a -> a) -> Interval k -> a -> IntervalMap k a -> IntervalMap k a

-- | Delete an interval and its value from the map. When the interval does
--   not overlap with the map, the original map is returned.
delete :: Ord k => Interval k -> IntervalMap k a -> IntervalMap k a

-- | Update a value at a specific interval with the result of the provided
--   function. When the interval does not overlatp with the map, the
--   original map is returned.
adjust :: Ord k => (a -> a) -> Interval k -> IntervalMap k a -> IntervalMap k a

-- | The expression (<tt><a>update</a> f i map</tt>) updates the value
--   <tt>x</tt> at <tt>i</tt> (if it is in the map). If (<tt>f x</tt>) is
--   <a>Nothing</a>, the element is deleted. If it is (<tt><a>Just</a>
--   y</tt>), the key <tt>i</tt> is bound to the new value <tt>y</tt>.
update :: Ord k => (a -> Maybe a) -> Interval k -> IntervalMap k a -> IntervalMap k a

-- | The expression (<tt><a>alter</a> f i map</tt>) alters the value
--   <tt>x</tt> at <tt>i</tt>, or absence thereof. <a>alter</a> can be used
--   to insert, delete, or update a value in a <a>IntervalMap</a>.
alter :: Ord k => (Maybe a -> Maybe a) -> Interval k -> IntervalMap k a -> IntervalMap k a

-- | The expression (<tt><a>union</a> t1 t2</tt>) takes the left-biased
--   union of <tt>t1</tt> and <tt>t2</tt>. It prefers <tt>t1</tt> when
--   overlapping keys are encountered,
union :: Ord k => IntervalMap k a -> IntervalMap k a -> IntervalMap k a

-- | Union with a combining function.
unionWith :: Ord k => (a -> a -> a) -> IntervalMap k a -> IntervalMap k a -> IntervalMap k a

-- | The union of a list of maps: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
unions :: Ord k => [IntervalMap k a] -> IntervalMap k a

-- | The union of a list of maps, with a combining operation:
--   (<tt><a>unionsWith</a> f == <a>foldl</a> (<a>unionWith</a> f)
--   <a>empty</a></tt>).
unionsWith :: Ord k => (a -> a -> a) -> [IntervalMap k a] -> IntervalMap k a

-- | Intersection of two maps. Return data in the first map for the keys
--   existing in both maps.
intersection :: Ord k => IntervalMap k a -> IntervalMap k a -> IntervalMap k a

-- | Intersection with a combining function.
intersectionWith :: Ord k => (a -> b -> c) -> IntervalMap k a -> IntervalMap k b -> IntervalMap k c

-- | Return elements of the first map not existing in the second map.
difference :: Ord k => IntervalMap k a -> IntervalMap k b -> IntervalMap k a

-- | Map a function over all values in the map.
map :: (a -> b) -> IntervalMap k a -> IntervalMap k b

-- | <tt><a>mapKeysMonotonic</a> f s</tt> is the map obtained by applying
--   <tt>f</tt> to each key of <tt>s</tt>. <tt>f</tt> must be strictly
--   monotonic. That is, for any values <tt>x</tt> and <tt>y</tt>, if
--   <tt>x</tt> &lt; <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>.
mapKeysMonotonic :: forall k1 k2 a. (Ord k1, Ord k2) => (k1 -> k2) -> IntervalMap k1 a -> IntervalMap k2 a

-- | Return all elements of the map in the ascending order of their keys.
elems :: IntervalMap k a -> [a]

-- | Return all keys of the map in ascending order. Subject to list
keys :: IntervalMap k a -> [Interval k]

-- | An alias for <a>toAscList</a>. Return all key/value pairs in the map
--   in ascending key order.
assocs :: IntervalMap k a -> [(Interval k, a)]

-- | The set of all keys of the map.
keysSet :: Ord k => IntervalMap k a -> IntervalSet k

-- | Build a map from a list of key/value pairs. If the list contains more
--   than one value for the same key, the last value for the key is
--   retained.
fromList :: Ord k => [(Interval k, a)] -> IntervalMap k a

-- | Build a map from a list of key/value pairs with a combining function.
fromListWith :: Ord k => (a -> a -> a) -> [(Interval k, a)] -> IntervalMap k a

-- | Convert the map to a list of key/value pairs.
toList :: IntervalMap k a -> [(Interval k, a)]

-- | Convert the map to a list of key/value pairs where the keys are in
--   ascending order.
toAscList :: IntervalMap k a -> [(Interval k, a)]

-- | Convert the map to a list of key/value pairs where the keys are in
--   descending order.
toDescList :: IntervalMap k a -> [(Interval k, a)]

-- | Filter all values that satisfy some predicate.
filter :: Ord k => (a -> Bool) -> IntervalMap k a -> IntervalMap k a

-- | The expression (<tt><a>split</a> i map</tt>) is a triple
--   <tt>(map1,map2,map3)</tt> where the keys in <tt>map1</tt> are smaller
--   than <tt>i</tt>, the keys in <tt>map2</tt> are included in <tt>i</tt>,
--   and the keys in <tt>map3</tt> are larger than <tt>i</tt>.
split :: Ord k => Interval k -> IntervalMap k a -> (IntervalMap k a, IntervalMap k a, IntervalMap k a)

-- | This function is defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: (Ord k, Eq a) => IntervalMap k a -> IntervalMap k a -> Bool

-- | The expression (<tt><a>isSubmapOfBy</a> f t1 t2</tt>) returns
--   <a>True</a> if all keys in <tt>t1</tt> are in tree <tt>t2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values.
isSubmapOfBy :: Ord k => (a -> b -> Bool) -> IntervalMap k a -> IntervalMap k b -> Bool

-- | Is this a proper submap? (ie. a submap but not equal). Defined as
--   (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a> (==)</tt>).
isProperSubmapOf :: (Ord k, Eq a) => IntervalMap k a -> IntervalMap k a -> Bool

-- | Is this a proper submap? (ie. a submap but not equal). The expression
--   (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns <a>True</a> when
--   <tt>m1</tt> and <tt>m2</tt> are not equal, all keys in <tt>m1</tt> are
--   in <tt>m2</tt>, and when <tt>f</tt> returns <a>True</a> when applied
--   to their respective values.
isProperSubmapOfBy :: Ord k => (a -> b -> Bool) -> IntervalMap k a -> IntervalMap k b -> Bool
