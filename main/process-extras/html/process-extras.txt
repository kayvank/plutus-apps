-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Process extras
--   
--   Extends <a>http://hackage.haskell.org/package/process</a>. Read
--   process input and output as ByteStrings or Text, or write your own
--   ProcessOutput instance. Lazy process input and output. ProcessMaker
--   class for more flexibility in the process creation API.
@package process-extras
@version 0.7.4

module System.Process.Common
class ProcessMaker a
process :: ProcessMaker a => a -> IO (Handle, Handle, Handle, ProcessHandle)
showProcessMakerForUser :: ProcessMaker a => a -> String

-- | Process IO is based on the <a>ListLikeIO</a> class from the ListLike
--   package
class ListLikeIO text char => ListLikeProcessIO text char
forceOutput :: ListLikeProcessIO text char => text -> IO text

-- | Read from a handle, returning a lazy list of the monoid a.
readChunks :: ListLikeProcessIO text char => Handle -> IO [text]
class (IsString text, Monoid text, ListLike text char) => ProcessText text char
class Monoid result => ProcessResult text result | result -> text
pidf :: ProcessResult text result => ProcessHandle -> result
outf :: ProcessResult text result => text -> result
errf :: ProcessResult text result => text -> result
intf :: ProcessResult text result => SomeException -> result
codef :: ProcessResult text result => ExitCode -> result

-- | Like <a>readProcessWithExitCode</a>, but with generalized input and
--   output type. Aside from the usual text-like types, the output can be a
--   list of Chunk a. This lets you process the chunks received from stdout
--   and stderr lazil, in the order they are received, as well as the exit
--   code. Utilities to handle Chunks are provided in
--   System.Process.ListLike.
readProcessWithExitCode :: ListLikeProcessIO text char => FilePath -> [String] -> text -> IO (ExitCode, text, text)
readCreateProcessWithExitCode :: (ProcessMaker maker, ListLikeProcessIO text char) => maker -> text -> IO (ExitCode, text, text)
readCreateProcessStrict :: (ProcessMaker maker, ProcessResult text result, ListLikeProcessIO text char) => maker -> text -> IO result

-- | Like readCreateProcessStrict, but the output is read lazily.
readCreateProcessLazy :: (ProcessMaker maker, ProcessResult a b, ListLikeProcessIO a c) => maker -> a -> IO b
showCmdSpecForUser :: CmdSpec -> String

-- | System.Process utility functions.
showCreateProcessForUser :: CreateProcess -> String
instance System.Process.Common.ListLikeProcessIO text char => System.Process.Common.ProcessResult text (GHC.IO.Exception.ExitCode, text, text)
instance System.Process.Common.ProcessMaker System.Process.Common.CreateProcess
instance System.Process.Common.ProcessMaker (System.Process.Common.CreateProcess, GHC.IO.Handle.Types.BufferMode, GHC.IO.Handle.Types.BufferMode)
instance GHC.Base.Monoid GHC.IO.Exception.ExitCode
instance GHC.Base.Semigroup GHC.IO.Exception.ExitCode

module System.Process.Text.Lazy

-- | Specialized version for backwards compatibility.
readProcessWithExitCode :: FilePath -> [String] -> Text -> IO (ExitCode, Text, Text)
readCreateProcessWithExitCode :: CreateProcess -> Text -> IO (ExitCode, Text, Text)
instance System.Process.Common.ProcessText Data.Text.Internal.Lazy.Text GHC.Types.Char
instance System.Process.Common.ListLikeProcessIO Data.Text.Internal.Lazy.Text GHC.Types.Char

module System.Process.Text.Builder

-- | Specialized version for backwards compatibility.
readProcessWithExitCode :: FilePath -> [String] -> Builder -> IO (ExitCode, Builder, Builder)
readCreateProcessWithExitCode :: CreateProcess -> Builder -> IO (ExitCode, Builder, Builder)
instance System.Process.Common.ListLikeProcessIO Data.Text.Internal.Builder.Builder GHC.Types.Char

module System.Process.Text

-- | Specialized version for backwards compatibility.
readProcessWithExitCode :: FilePath -> [String] -> Text -> IO (ExitCode, Text, Text)
readCreateProcessWithExitCode :: CreateProcess -> Text -> IO (ExitCode, Text, Text)
instance System.Process.Common.ProcessText Data.Text.Internal.Text GHC.Types.Char
instance System.Process.Common.ListLikeProcessIO Data.Text.Internal.Text GHC.Types.Char

module System.Process.Chars

-- | Specialized version for backwards compatibility.
readProcessWithExitCode :: FilePath -> [String] -> Chars -> IO (ExitCode, Chars, Chars)
readCreateProcessWithExitCode :: CreateProcess -> Chars -> IO (ExitCode, Chars, Chars)
instance System.Process.Common.ListLikeProcessIO Data.ListLike.Chars.Chars GHC.Types.Char

module System.Process.ByteString.Lazy

-- | Specialized version for backwards compatibility.
readProcessWithExitCode :: FilePath -> [String] -> ByteString -> IO (ExitCode, ByteString, ByteString)
readCreateProcessWithExitCode :: CreateProcess -> ByteString -> IO (ExitCode, ByteString, ByteString)
instance System.Process.Common.ProcessText Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8
instance System.Process.Common.ListLikeProcessIO Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8

module System.Process.ByteString

-- | Specialized version for backwards compatibility.
readProcessWithExitCode :: FilePath -> [String] -> ByteString -> IO (ExitCode, ByteString, ByteString)
readCreateProcessWithExitCode :: CreateProcess -> ByteString -> IO (ExitCode, ByteString, ByteString)
instance System.Process.Common.ProcessText Data.ByteString.Internal.ByteString GHC.Word.Word8
instance System.Process.Common.ListLikeProcessIO Data.ByteString.Internal.ByteString GHC.Word.Word8


-- | Re-export all symbols and instances of the process-extras package.
--   Adds the Chunk type with a ProcessOutput instance, and a collectOutput
--   function to turn a list of chunks into any instance of ProcessOutput,
--   such as (ExitCode, String, String). This means you can have
--   readCreateProcess output a list of Chunk, operate on it to do progress
--   reporting, and finally convert it to the type that
--   readProcessWithExitCode woud have returned.
module System.Process.ListLike

-- | Process IO is based on the <a>ListLikeIO</a> class from the ListLike
--   package
class ListLikeIO text char => ListLikeProcessIO text char
forceOutput :: ListLikeProcessIO text char => text -> IO text
class (IsString text, Monoid text, ListLike text char) => ProcessText text char
class Monoid result => ProcessResult text result | result -> text
pidf :: ProcessResult text result => ProcessHandle -> result
outf :: ProcessResult text result => text -> result
errf :: ProcessResult text result => text -> result
intf :: ProcessResult text result => SomeException -> result
codef :: ProcessResult text result => ExitCode -> result
class ProcessMaker a
process :: ProcessMaker a => a -> IO (Handle, Handle, Handle, ProcessHandle)
showProcessMakerForUser :: ProcessMaker a => a -> String
readCreateProcess :: (ProcessMaker maker, ProcessResult text result, ListLikeProcessIO text char) => maker -> text -> IO result
readCreateProcessStrict :: (ProcessMaker maker, ProcessResult text result, ListLikeProcessIO text char) => maker -> text -> IO result

-- | Like readCreateProcessStrict, but the output is read lazily.
readCreateProcessLazy :: (ProcessMaker maker, ProcessResult a b, ListLikeProcessIO a c) => maker -> a -> IO b
readCreateProcessWithExitCode :: (ProcessMaker maker, ListLikeProcessIO text char) => maker -> text -> IO (ExitCode, text, text)

-- | Like <a>readProcessWithExitCode</a>, but with generalized input and
--   output type. Aside from the usual text-like types, the output can be a
--   list of Chunk a. This lets you process the chunks received from stdout
--   and stderr lazil, in the order they are received, as well as the exit
--   code. Utilities to handle Chunks are provided in
--   System.Process.ListLike.
readProcessWithExitCode :: ListLikeProcessIO text char => FilePath -> [String] -> text -> IO (ExitCode, text, text)

-- | System.Process utility functions.
showCreateProcessForUser :: CreateProcess -> String
showCmdSpecForUser :: CmdSpec -> String

-- | This type is a concrete representation of the methods of class
--   ProcessOutput. If you take your process output as this type you could,
--   for example, echo all the output and then use collectOutput below to
--   convert it to any other instance of ProcessOutput.
data Chunk a

-- | This will always come first, before any output or exit code.
ProcessHandle :: ProcessHandle -> Chunk a
Stdout :: a -> Chunk a
Stderr :: a -> Chunk a
Result :: ExitCode -> Chunk a

-- | Note that the instances below do not use this constructor.
Exception :: SomeException -> Chunk a

-- | Turn a <tt>[Chunk a]</tt> into any other instance of
--   <tt>ProcessOutput</tt>. I usually use this after processing the chunk
--   list to turn it into the (ExitCode, String, String) type returned by
--   readProcessWithExitCode.
collectOutput :: ProcessResult a b => [Chunk a] -> b
foldOutput :: (ProcessHandle -> r) -> (a -> r) -> (a -> r) -> (SomeException -> r) -> (ExitCode -> r) -> Chunk a -> r

-- | Send Stdout chunks to stdout and Stderr chunks to stderr. Returns
--   input list unmodified.
writeOutput :: ListLikeIO a c => [Chunk a] -> IO [Chunk a]
writeChunk :: ListLikeIO a c => Chunk a -> IO (Chunk a)
data CmdSpec

-- | A command line to execute using the shell
ShellCommand :: String -> CmdSpec

-- | The name of an executable with a list of arguments
--   
--   The <a>FilePath</a> argument names the executable, and is interpreted
--   according to the platform's standard policy for searching for
--   executables. Specifically:
--   
--   <ul>
--   <li>on Unix systems the <a>execvp(3)</a> semantics is used, where if
--   the executable filename does not contain a slash (<tt>/</tt>) then the
--   <tt>PATH</tt> environment variable is searched for the
--   executable.</li>
--   <li>on Windows systems the Win32 <tt>CreateProcess</tt> semantics is
--   used. Briefly: if the filename does not contain a path, then the
--   directory containing the parent executable is searched, followed by
--   the current directory, then some standard locations, and finally the
--   current <tt>PATH</tt>. An <tt>.exe</tt> extension is added if the
--   filename does not already have an extension. For full details see the
--   <a>documentation</a> for the Windows <tt>SearchPath</tt> API.</li>
--   </ul>
RawCommand :: FilePath -> [String] -> CmdSpec
data CreateProcess
CreateProcess :: CmdSpec -> Maybe FilePath -> Maybe [(String, String)] -> StdStream -> StdStream -> StdStream -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Maybe GroupID -> Maybe UserID -> Bool -> CreateProcess

-- | Executable &amp; arguments, or shell command. If <a>cwd</a> is
--   <a>Nothing</a>, relative paths are resolved with respect to the
--   current working directory. If <a>cwd</a> is provided, it is
--   implementation-dependent whether relative paths are resolved with
--   respect to <a>cwd</a> or the current working directory, so absolute
--   paths should be used to ensure portability.
[cmdspec] :: CreateProcess -> CmdSpec

-- | Optional path to the working directory for the new process
[cwd] :: CreateProcess -> Maybe FilePath

-- | Optional environment (otherwise inherit from the current process)
[env] :: CreateProcess -> Maybe [(String, String)]

-- | How to determine stdin
[std_in] :: CreateProcess -> StdStream

-- | How to determine stdout
[std_out] :: CreateProcess -> StdStream

-- | How to determine stderr
[std_err] :: CreateProcess -> StdStream

-- | Close all file descriptors except stdin, stdout and stderr in the new
--   process (on Windows, only works if std_in, std_out, and std_err are
--   all Inherit). This implementation will call close an every fd from 3
--   to the maximum of open files, which can be slow for high maximum of
--   open files.
[close_fds] :: CreateProcess -> Bool

-- | Create a new process group
[create_group] :: CreateProcess -> Bool

-- | Delegate control-C handling. Use this for interactive console
--   processes to let them handle control-C themselves (see below for
--   details).
--   
--   On Windows this has no effect.
[delegate_ctlc] :: CreateProcess -> Bool

-- | Use the windows DETACHED_PROCESS flag when creating the process; does
--   nothing on other platforms.
[detach_console] :: CreateProcess -> Bool

-- | Use the windows CREATE_NEW_CONSOLE flag when creating the process;
--   does nothing on other platforms.
--   
--   Default: <tt>False</tt>
[create_new_console] :: CreateProcess -> Bool

-- | Use posix setsid to start the new process in a new session; does
--   nothing on other platforms.
[new_session] :: CreateProcess -> Bool

-- | Use posix setgid to set child process's group id; does nothing on
--   other platforms.
--   
--   Default: <tt>Nothing</tt>
[child_group] :: CreateProcess -> Maybe GroupID

-- | Use posix setuid to set child process's user id; does nothing on other
--   platforms.
--   
--   Default: <tt>Nothing</tt>
[child_user] :: CreateProcess -> Maybe UserID

-- | On Windows systems this flag indicates that we should wait for the
--   entire process tree to finish before unblocking. On POSIX systems this
--   flag is ignored. See $exec-on-windows for details.
--   
--   Default: <tt>False</tt>
[use_process_jobs] :: CreateProcess -> Bool

-- | Construct a <a>CreateProcess</a> record for passing to
--   <a>createProcess</a>, representing a raw command with arguments.
--   
--   See <a>RawCommand</a> for precise semantics of the specified
--   <tt>FilePath</tt>.
proc :: FilePath -> [String] -> CreateProcess

-- | Construct a <a>CreateProcess</a> record for passing to
--   <a>createProcess</a>, representing a command to be passed to the
--   shell.
shell :: String -> CreateProcess

-- | Given a program <tt><i>p</i></tt> and arguments <tt><i>args</i></tt>,
--   <tt>showCommandForUser <i>p</i> <i>args</i></tt> returns a string
--   suitable for pasting into <tt>/bin/sh</tt> (on Unix systems) or
--   <tt>CMD.EXE</tt> (on Windows).
showCommandForUser :: FilePath -> [String] -> String
instance GHC.Show.Show a => GHC.Show.Show (System.Process.ListLike.Chunk a)
instance System.Process.Common.ListLikeProcessIO a c => System.Process.Common.ProcessResult a [System.Process.ListLike.Chunk a]
instance System.Process.Common.ListLikeProcessIO a c => System.Process.Common.ProcessResult a (GHC.IO.Exception.ExitCode, [System.Process.ListLike.Chunk a])
instance System.Process.Common.ProcessText GHC.Base.String GHC.Types.Char
instance System.Process.Common.ListLikeProcessIO GHC.Base.String GHC.Types.Char
instance GHC.Show.Show System.Process.Common.ProcessHandle


-- | Flexible control of progress reporting for readCreateProcess and
--   friends.
module System.Process.Run
type RunT text m = StateT (RunState text) m
runT :: forall m text char a. (MonadIO m, ProcessText text char) => RunT text m a -> m a

-- | This is the state record that controls the output style.
data RunState text
RunState :: OutputStyle -> text -> text -> Bool -> Bool -> Int -> Bool -> text -> RunState text

-- | Overall style of output
[_output] :: RunState text -> OutputStyle

-- | Prefix for lines of stdout
[_outprefix] :: RunState text -> text

-- | Prefix for lines of stderr
[_errprefix] :: RunState text -> text

-- | Echo command as process starts
[_echoStart] :: RunState text -> Bool

-- | Echo command as process finishes
[_echoEnd] :: RunState text -> Bool

-- | A progression of progress modes
[_verbosity] :: RunState text -> Int

-- | Use the lazy or strict runner?
[_lazy] :: RunState text -> Bool

-- | Extra text for start/end message - e.g. the change root
[_message] :: RunState text -> text
data OutputStyle

-- | Output one dot per n output characters
Dots :: Int -> OutputStyle

-- | send process stdout to console stdout and process stderr to console
--   stderr
All :: OutputStyle

-- | Output with prefixes
Indented :: OutputStyle

-- | No output
Silent :: OutputStyle
class (MonadState (RunState text) m, ProcessText text char, ListLikeProcessIO text char, MonadIO m, IsString text, Eq char, Dot char) => RunM text char m
echoStart :: MonadState (RunState t) m => m ()
echoEnd :: MonadState (RunState t) m => m ()
output :: MonadState (RunState t) m => m ()
silent :: MonadState (RunState t) m => m ()
dots :: MonadState (RunState t) m => Int -> m ()

-- | Modify the indentation prefixes for stdout and stderr in the progress
--   monad.
indent :: (MonadState (RunState t) m, ListLike t char) => (t -> t) -> (t -> t) -> m ()

-- | Set verbosity to a specific level from 0 to 3. vlevel :: (MonadIO m,
--   Monoid text, MonadState (RunState text) m) =&gt; Int -&gt; m () vlevel
--   :: forall m text char. (IsString text, ListLike text char, MonadIO m)
--   =&gt; Int -&gt; m ()
vlevel :: forall m text char. (IsString text, ListLike text char, MonadIO m, MonadState (RunState text) m) => Int -> m ()
quieter :: RunM text char m => m ()
noisier :: RunM text char m => m ()
lazy :: RunM text char m => m ()
strict :: RunM text char m => m ()
message :: RunM text char m => (text -> text) -> m ()
run :: forall m maker text char result. (RunM text char m, ProcessMaker maker, ProcessResult text result) => maker -> text -> m result
instance GHC.Classes.Eq System.Process.Run.BOL
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.State.Class.MonadState (System.Process.Run.RunState GHC.Base.String) m) => System.Process.Run.RunM GHC.Base.String GHC.Types.Char m
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.State.Class.MonadState (System.Process.Run.RunState Data.Text.Internal.Text) m) => System.Process.Run.RunM Data.Text.Internal.Text GHC.Types.Char m
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.State.Class.MonadState (System.Process.Run.RunState Data.Text.Internal.Lazy.Text) m) => System.Process.Run.RunM Data.Text.Internal.Lazy.Text GHC.Types.Char m
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.State.Class.MonadState (System.Process.Run.RunState Data.ByteString.Internal.ByteString) m) => System.Process.Run.RunM Data.ByteString.Internal.ByteString GHC.Word.Word8 m
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.State.Class.MonadState (System.Process.Run.RunState Data.ByteString.Lazy.Internal.ByteString) m) => System.Process.Run.RunM Data.ByteString.Lazy.Internal.ByteString GHC.Word.Word8 m
instance System.Process.Run.Dot GHC.Word.Word8
instance System.Process.Run.Dot GHC.Types.Char
instance System.Process.Common.ProcessText text char => Data.Default.Class.Default (System.Process.Run.RunState text)
