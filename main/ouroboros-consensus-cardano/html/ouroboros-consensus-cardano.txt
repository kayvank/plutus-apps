-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The instantation of the Ouroboros consensus layer used by Cardano
--   
--   The instantation of the Ouroboros consensus layer used by Cardano
@package ouroboros-consensus-cardano
@version 0.1.0.1

module Ouroboros.Consensus.Cardano.Block

-- | The eras in the Cardano blockchain.
--   
--   We parameterise over the crypto used in the post-Byron eras:
--   <tt>c</tt>.
--   
--   TODO: parameterise ByronBlock over crypto too
type CardanoEras c = ByronBlock : CardanoShelleyEras c
type CardanoShelleyEras c = '[ShelleyBlock (TPraos c) (ShelleyEra c), ShelleyBlock (TPraos c) (AllegraEra c), ShelleyBlock (TPraos c) (MaryEra c), ShelleyBlock (TPraos c) (AlonzoEra c), ShelleyBlock (Praos c) (BabbageEra c)]

-- | <i>The</i> Cardano block.
--   
--   Thanks to the pattern synonyms, you can treat this as a sum type with
--   constructors <a>BlockByron</a> and <a>BlockShelley</a>.
--   
--   <pre>
--   f :: CardanoBlock c -&gt; _
--   f (BlockByron   b) = _
--   f (BlockShelley s) = _
--   f (BlockAllegra a) = _
--   f (BlockMary    m) = _
--   f (BlockAlonzo  m) = _
--   </pre>
type CardanoBlock c = HardForkBlock (CardanoEras c)
data HardForkBlock (xs :: [Type])
pattern BlockAllegra :: ShelleyBlock (TPraos c) (AllegraEra c) -> CardanoBlock c
pattern BlockAlonzo :: ShelleyBlock (TPraos c) (AlonzoEra c) -> CardanoBlock c
pattern BlockByron :: ByronBlock -> CardanoBlock c
pattern BlockMary :: ShelleyBlock (TPraos c) (MaryEra c) -> CardanoBlock c
pattern BlockShelley :: ShelleyBlock (TPraos c) (ShelleyEra c) -> CardanoBlock c
pattern BlockBabbage :: ShelleyBlock (Praos c) (BabbageEra c) -> CardanoBlock c

-- | The Cardano header.
type CardanoHeader c = Header (CardanoBlock c)
data family Header blk
pattern HeaderAllegra :: Header (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoHeader c
pattern HeaderAlonzo :: Header (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoHeader c
pattern HeaderByron :: Header ByronBlock -> CardanoHeader c
pattern HeaderMary :: Header (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoHeader c
pattern HeaderShelley :: Header (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoHeader c
pattern HeaderBabbage :: Header (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoHeader c

-- | An error resulting from applying a <a>CardanoGenTx</a> to the ledger.
--   
--   Thanks to the pattern synonyms, you can treat this as a sum type with
--   constructors <tt>ApplyTxByronErr</tt>, <a>ApplyTxErrShelley</a>, and
--   <a>ApplyTxErrWrongEra</a>.
--   
--   <pre>
--   toText :: CardanoApplyTxErr c -&gt; Text
--   toText (ApplyTxErrByron b) = byronApplyTxErrToText b
--   toText (ApplyTxErrShelley s) = shelleyApplyTxErrToText s
--   toText (ApplyTxErrAllegra a) = allegraApplyTxErrToText a
--   toText (ApplyTxErrMary m) = maryApplyTxErrToText m
--   toText (ApplyTxErrWrongEra eraMismatch) =
--     "Transaction from the " &lt;&gt; otherEraName eraMismatch &lt;&gt;
--     " era applied to a ledger from the " &lt;&gt;
--     ledgerEraName eraMismatch &lt;&gt; " era"
--   </pre>
type CardanoApplyTxErr c = HardForkApplyTxErr (CardanoEras c)

-- | The Cardano transaction.
type CardanoGenTx c = GenTx (CardanoBlock c)

-- | The ID of a Cardano transaction.
type CardanoGenTxId c = GenTxId (CardanoBlock c)

-- | Generalized transaction
--   
--   The mempool (and, accordingly, blocks) consist of "generalized
--   transactions"; this could be "proper" transactions (transferring
--   funds) but also other kinds of things such as update proposals,
--   delegations, etc.
data family GenTx blk
pattern GenTxAllegra :: GenTx (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoGenTx c
pattern GenTxAlonzo :: GenTx (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoGenTx c
pattern GenTxByron :: GenTx ByronBlock -> CardanoGenTx c
pattern GenTxMary :: GenTx (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoGenTx c
pattern GenTxShelley :: GenTx (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoGenTx c
pattern GenTxBabbage :: GenTx (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoGenTx c
data HardForkApplyTxErr (xs :: [Type])
pattern ApplyTxErrAllegra :: ApplyTxErr (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoApplyTxErr c
pattern ApplyTxErrAlonzo :: ApplyTxErr (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoApplyTxErr c
pattern ApplyTxErrByron :: ApplyTxErr ByronBlock -> CardanoApplyTxErr c
pattern ApplyTxErrMary :: ApplyTxErr (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoApplyTxErr c
pattern ApplyTxErrShelley :: ApplyTxErr (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoApplyTxErr c
pattern ApplyTxErrWrongEra :: EraMismatch -> CardanoApplyTxErr c
pattern ApplyTxErrBabbage :: ApplyTxErr (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoApplyTxErr c

-- | A generalized transaction, <a>GenTx</a>, identifier.
data family TxId tx
pattern GenTxIdAllegra :: GenTxId (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoGenTxId c
pattern GenTxIdAlonzo :: GenTxId (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoGenTxId c
pattern GenTxIdByron :: GenTxId ByronBlock -> CardanoGenTxId c
pattern GenTxIdMary :: GenTxId (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoGenTxId c
pattern GenTxIdShelley :: GenTxId (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoGenTxId c
pattern GenTxIdBabbage :: GenTxId (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoGenTxId c

-- | An error resulting from applying a <a>CardanoBlock</a> to the ledger.
--   
--   Thanks to the pattern synonyms, you can treat this as a sum type with
--   constructors <a>LedgerErrorByron</a>, <a>LedgerErrorShelley</a>, and
--   <a>LedgerErrorWrongEra</a>.
--   
--   <pre>
--   toText :: CardanoLedgerError c -&gt; Text
--   toText (LedgerErrorByron b) = byronLedgerErrorToText b
--   toText (LedgerErrorShelley s) = shelleyLedgerErrorToText s
--   toText (LedgerErrorAllegra a) = allegraLedgerErrorToText a
--   toText (LedgerErrorMary m) = maryLedgerErrorToText m
--   toText (LedgerErrorWrongEra eraMismatch) =
--     "Block from the " &lt;&gt; otherEraName eraMismatch &lt;&gt;
--     " era applied to a ledger from the " &lt;&gt;
--     ledgerEraName eraMismatch &lt;&gt; " era"
--   </pre>
type CardanoLedgerError c = HardForkLedgerError (CardanoEras c)
data HardForkLedgerError (xs :: [Type])
pattern LedgerErrorAllegra :: LedgerError (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoLedgerError c
pattern LedgerErrorAlonzo :: LedgerError (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoLedgerError c
pattern LedgerErrorByron :: LedgerError ByronBlock -> CardanoLedgerError c
pattern LedgerErrorMary :: LedgerError (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoLedgerError c
pattern LedgerErrorShelley :: LedgerError (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoLedgerError c
pattern LedgerErrorWrongEra :: EraMismatch -> CardanoLedgerError c
pattern LedgerErrorBabbage :: LedgerError (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoLedgerError c

-- | An error resulting from validating a <a>CardanoHeader</a>.
type CardanoOtherHeaderEnvelopeError c = HardForkEnvelopeErr (CardanoEras c)
data HardForkEnvelopeErr (xs :: [Type])
pattern OtherHeaderEnvelopeErrorAllegra :: OtherHeaderEnvelopeError (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorBabbage :: OtherHeaderEnvelopeError (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorAlonzo :: OtherHeaderEnvelopeError (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorByron :: OtherHeaderEnvelopeError ByronBlock -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorMary :: OtherHeaderEnvelopeError (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorShelley :: OtherHeaderEnvelopeError (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoOtherHeaderEnvelopeError c
pattern OtherHeaderEnvelopeErrorWrongEra :: EraMismatch -> CardanoOtherHeaderEnvelopeError c

-- | The <a>TipInfo</a> of the Cardano chain.
type CardanoTipInfo c = OneEraTipInfo (CardanoEras c)
data OneEraTipInfo (xs :: [Type])
pattern TipInfoAllegra :: TipInfo (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoTipInfo c
pattern TipInfoAlonzo :: TipInfo (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoTipInfo c
pattern TipInfoByron :: TipInfo ByronBlock -> CardanoTipInfo c
pattern TipInfoBabbage :: TipInfo (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoTipInfo c
pattern TipInfoMary :: TipInfo (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoTipInfo c
pattern TipInfoShelley :: TipInfo (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoTipInfo c

-- | Different queries supported by the ledger, indexed by the result type.
data family BlockQuery blk :: Type -> Type

-- | Query about the Allegra era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Allegra era (whether the tip
--   of the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeAllegra EraStart
--   </pre>
pattern QueryAnytimeAllegra :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Alonzo era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Alonzo era (whether the tip
--   of the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeAlonzo EraStart
--   </pre>
pattern QueryAnytimeAlonzo :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Babbage era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Babbage era (whether the tip
--   of the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeBabbage EraStart
--   </pre>
pattern QueryAnytimeBabbage :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Byron era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Byron era (whether the tip of
--   the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeByron EraStart
--   </pre>
pattern QueryAnytimeByron :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Mary era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Mary era (whether the tip of
--   the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeMary EraStart
--   </pre>
pattern QueryAnytimeMary :: QueryAnytime result -> CardanoQuery c result

-- | Query about the Shelley era that can be answered anytime, i.e.,
--   independent from where the tip of the ledger is.
--   
--   For example, to ask for the start of the Shelley era (whether the tip
--   of the ledger is in the Byron, Shelley, ... era), use:
--   
--   <pre>
--   QueryAnytimeShelley EraStart
--   </pre>
pattern QueryAnytimeShelley :: QueryAnytime result -> CardanoQuery c result

-- | Allegra-specific query that can only be answered when the ledger is in
--   the Allegra era.
pattern QueryIfCurrentAllegra :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (TPraos c) (AllegraEra c)) result -> CardanoQuery c a

-- | Alonzo-specific query that can only be answered when the ledger is in
--   the Alonzo era.
pattern QueryIfCurrentAlonzo :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (TPraos c) (AlonzoEra c)) result -> CardanoQuery c a

-- | Babbage-specific query that can only be answered when the ledger is in
--   the Babbage era.
pattern QueryIfCurrentBabbage :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (Praos c) (BabbageEra c)) result -> CardanoQuery c a

-- | Byron-specific query that can only be answered when the ledger is in
--   the Byron era.
pattern QueryIfCurrentByron :: () => CardanoQueryResult c result ~ a => BlockQuery ByronBlock result -> CardanoQuery c a

-- | Mary-specific query that can only be answered when the ledger is in
--   the Mary era.
pattern QueryIfCurrentMary :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (TPraos c) (MaryEra c)) result -> CardanoQuery c a

-- | Shelley-specific query that can only be answered when the ledger is in
--   the Shelley era.
pattern QueryIfCurrentShelley :: () => CardanoQueryResult c result ~ a => BlockQuery (ShelleyBlock (TPraos c) (ShelleyEra c)) result -> CardanoQuery c a

-- | The <tt>Query</tt> of Cardano chain.
type CardanoQuery c = BlockQuery (CardanoBlock c)

-- | The result of a <a>CardanoQuery</a>
--   
--   Thanks to the pattern synonyms, you can treat this as a sum type with
--   constructors <a>QueryResultSuccess</a> and
--   <a>QueryResultEraMismatch</a>.
type CardanoQueryResult c = HardForkQueryResult (CardanoEras c)

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
--   
--   <h4><b>Examples</b></h4>
--   
--   The type <tt><a>Either</a> <a>String</a> <a>Int</a></tt> is the type
--   of values which can be either a <a>String</a> or an <a>Int</a>. The
--   <a>Left</a> constructor can be used only on <a>String</a>s, and the
--   <a>Right</a> constructor can be used only on <a>Int</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; s
--   Left "foo"
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; n
--   Right 3
--   
--   &gt;&gt;&gt; :type s
--   s :: Either String Int
--   
--   &gt;&gt;&gt; :type n
--   n :: Either String Int
--   </pre>
--   
--   The <a>fmap</a> from our <a>Functor</a> instance will ignore
--   <a>Left</a> values, but will apply the supplied function to values
--   contained in a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = Left "foo" :: Either String Int
--   
--   &gt;&gt;&gt; let n = Right 3 :: Either String Int
--   
--   &gt;&gt;&gt; fmap (*2) s
--   Left "foo"
--   
--   &gt;&gt;&gt; fmap (*2) n
--   Right 6
--   </pre>
--   
--   The <a>Monad</a> instance for <a>Either</a> allows us to chain
--   together multiple actions which may fail, and fail overall if any of
--   the individual steps failed. First we'll write a function that can
--   either parse an <a>Int</a> from a <a>Char</a>, or fail.
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Char ( digitToInt, isDigit )
--   
--   &gt;&gt;&gt; :{
--       let parseEither :: Char -&gt; Either String Int
--           parseEither c
--             | isDigit c = Right (digitToInt c)
--             | otherwise = Left "parse error"
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   The following should work, since both <tt>'1'</tt> and <tt>'2'</tt>
--   can be parsed as <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither '1'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Right 3
--   </pre>
--   
--   But the following should fail overall, since the first operation where
--   we attempt to parse <tt>'m'</tt> as an <a>Int</a> will fail:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       let parseMultiple :: Either String Int
--           parseMultiple = do
--             x &lt;- parseEither 'm'
--             y &lt;- parseEither '2'
--             return (x + y)
--   
--   &gt;&gt;&gt; :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; parseMultiple
--   Left "parse error"
--   </pre>
data Either a b
pattern QueryResultSuccess :: result -> CardanoQueryResult c result

-- | A query from a different era than the ledger's era was sent.
pattern QueryResultEraMismatch :: EraMismatch -> CardanoQueryResult c result

-- | The <a>CodecConfig</a> for <a>CardanoBlock</a>.
--   
--   Thanks to the pattern synonyms, you can treat this as the product of
--   the Byron, Shelley, ... <a>CodecConfig</a>s.
type CardanoCodecConfig c = CodecConfig (CardanoBlock c)

-- | Static configuration required for serialisation and deserialisation of
--   types pertaining to this type of block.
--   
--   Data family instead of type family to get better type inference.
data family CodecConfig blk
pattern CardanoCodecConfig :: CodecConfig ByronBlock -> CodecConfig (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CodecConfig (ShelleyBlock (TPraos c) (AllegraEra c)) -> CodecConfig (ShelleyBlock (TPraos c) (MaryEra c)) -> CodecConfig (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CodecConfig (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoCodecConfig c

-- | Static configuration required to work with this type of blocks
data family BlockConfig blk
pattern CardanoBlockConfig :: BlockConfig ByronBlock -> BlockConfig (ShelleyBlock (TPraos c) (ShelleyEra c)) -> BlockConfig (ShelleyBlock (TPraos c) (AllegraEra c)) -> BlockConfig (ShelleyBlock (TPraos c) (MaryEra c)) -> BlockConfig (ShelleyBlock (TPraos c) (AlonzoEra c)) -> BlockConfig (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoBlockConfig c

-- | The <a>BlockConfig</a> for <a>CardanoBlock</a>.
--   
--   Thanks to the pattern synonyms, you can treat this as the product of
--   the Byron, Shelley, ... <a>BlockConfig</a>s.
type CardanoBlockConfig c = BlockConfig (CardanoBlock c)

-- | The <a>StorageConfig</a> for <a>CardanoBlock</a>.
--   
--   Thanks to the pattern synonyms, you can treat this as the product of
--   the Byron, Shelley, ... <a>StorageConfig</a>s.
type CardanoStorageConfig c = StorageConfig (CardanoBlock c)

-- | Config needed for the <a>NodeInitStorage</a> class. Defined here to
--   avoid circular dependencies.
data family StorageConfig blk
pattern CardanoStorageConfig :: StorageConfig ByronBlock -> StorageConfig (ShelleyBlock (TPraos c) (ShelleyEra c)) -> StorageConfig (ShelleyBlock (TPraos c) (AllegraEra c)) -> StorageConfig (ShelleyBlock (TPraos c) (MaryEra c)) -> StorageConfig (ShelleyBlock (TPraos c) (AlonzoEra c)) -> StorageConfig (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoStorageConfig c

-- | The <a>ConsensusConfig</a> for <a>CardanoBlock</a>.
--   
--   Thanks to the pattern synonyms, you can treat this as the product of
--   the Byron, Shelley, ... <a>PartialConsensusConfig</a>s.
--   
--   NOTE: not <a>ConsensusConfig</a>, but <a>PartialConsensusConfig</a>.
type CardanoConsensusConfig c = ConsensusConfig (HardForkProtocol (CardanoEras c))

-- | Static configuration required to run the consensus protocol
--   
--   Every method in the <a>ConsensusProtocol</a> class takes the consensus
--   configuration as a parameter, so having this as a data family rather
--   than a type family resolves most ambiguity.
--   
--   Defined out of the class so that protocols can define this type
--   without having to define the entire protocol at the same time (or
--   indeed in the same module).
data family ConsensusConfig p
pattern CardanoConsensusConfig :: PartialConsensusConfig (BlockProtocol ByronBlock) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (TPraos c) (ShelleyEra c))) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (TPraos c) (AllegraEra c))) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (TPraos c) (MaryEra c))) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (TPraos c) (AlonzoEra c))) -> PartialConsensusConfig (BlockProtocol (ShelleyBlock (Praos c) (BabbageEra c))) -> CardanoConsensusConfig c

-- | The <tt>LedgerConfig</tt> for <a>CardanoBlock</a>.
--   
--   Thanks to the pattern synonyms, you can treat this as the product of
--   the Byron, Shelley, ... <a>PartialLedgerConfig</a>s.
--   
--   NOTE: not <tt>LedgerConfig</tt>, but <a>PartialLedgerConfig</a>.
type CardanoLedgerConfig c = HardForkLedgerConfig (CardanoEras c)
data HardForkLedgerConfig (xs :: [Type])
pattern CardanoLedgerConfig :: PartialLedgerConfig ByronBlock -> PartialLedgerConfig (ShelleyBlock (TPraos c) (ShelleyEra c)) -> PartialLedgerConfig (ShelleyBlock (TPraos c) (AllegraEra c)) -> PartialLedgerConfig (ShelleyBlock (TPraos c) (MaryEra c)) -> PartialLedgerConfig (ShelleyBlock (TPraos c) (AlonzoEra c)) -> PartialLedgerConfig (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoLedgerConfig c

-- | The <a>LedgerState</a> for <a>CardanoBlock</a>.
--   
--   NOTE: the <a>CardanoLedgerState</a> contains more than just the
--   current era's <a>LedgerState</a>. We don't give access to those
--   internal details through the pattern synonyms. This is also the reason
--   the pattern synonyms are not bidirectional.
type CardanoLedgerState c = LedgerState (CardanoBlock c)

-- | Ledger state associated with a block
data family LedgerState blk
pattern LedgerStateAllegra :: LedgerState (ShelleyBlock (TPraos c) (AllegraEra c)) -> CardanoLedgerState c
pattern LedgerStateAlonzo :: LedgerState (ShelleyBlock (TPraos c) (AlonzoEra c)) -> CardanoLedgerState c
pattern LedgerStateBabbage :: LedgerState (ShelleyBlock (Praos c) (BabbageEra c)) -> CardanoLedgerState c
pattern LedgerStateByron :: LedgerState ByronBlock -> CardanoLedgerState c
pattern LedgerStateMary :: LedgerState (ShelleyBlock (TPraos c) (MaryEra c)) -> CardanoLedgerState c
pattern LedgerStateShelley :: LedgerState (ShelleyBlock (TPraos c) (ShelleyEra c)) -> CardanoLedgerState c

-- | The <a>ChainDepState</a> for <a>CardanoBlock</a>.
--   
--   NOTE: the <a>CardanoChainDepState</a> contains more than just the
--   current era's <a>ChainDepState</a>. We don't give access to those
--   internal details through the pattern synonyms. This is also the reason
--   the pattern synonyms are not bidirectional.
type CardanoChainDepState c = HardForkChainDepState (CardanoEras c)

-- | Generic hard fork state
--   
--   This is used both for the consensus state and the ledger state.
data HardForkState (f :: Type -> Type) (xs :: [Type])
pattern ChainDepStateAllegra :: ChainDepState (BlockProtocol (ShelleyBlock (TPraos c) (AllegraEra c))) -> CardanoChainDepState c
pattern ChainDepStateAlonzo :: ChainDepState (BlockProtocol (ShelleyBlock (TPraos c) (AlonzoEra c))) -> CardanoChainDepState c
pattern ChainDepStateBabbage :: ChainDepState (BlockProtocol (ShelleyBlock (Praos c) (BabbageEra c))) -> CardanoChainDepState c
pattern ChainDepStateByron :: ChainDepState (BlockProtocol ByronBlock) -> CardanoChainDepState c
pattern ChainDepStateMary :: ChainDepState (BlockProtocol (ShelleyBlock (TPraos c) (MaryEra c))) -> CardanoChainDepState c
pattern ChainDepStateShelley :: ChainDepState (BlockProtocol (ShelleyBlock (TPraos c) (ShelleyEra c))) -> CardanoChainDepState c

-- | Extra info for errors caused by applying a block, header, transaction,
--   or query from one era to a ledger from a different era.
data EraMismatch
EraMismatch :: !Text -> !Text -> EraMismatch

-- | Name of the era of the ledger (<a>Byron</a> or <a>Shelley</a>).
[ledgerEraName] :: EraMismatch -> !Text

-- | Era of the block, header, transaction, or query.
[otherEraName] :: EraMismatch -> !Text

module Ouroboros.Consensus.Cardano.CanHardFork

-- | When Byron is part of the hard-fork combinator, we use the partial
--   ledger config. Standalone Byron uses the regular ledger config. This
--   means that the partial ledger config is the perfect place to store the
--   trigger condition for the hard fork to Shelley, as we don't have to
--   modify the ledger config for standalone Byron.
data ByronPartialLedgerConfig
ByronPartialLedgerConfig :: !LedgerConfig ByronBlock -> !TriggerHardFork -> ByronPartialLedgerConfig
[byronLedgerConfig] :: ByronPartialLedgerConfig -> !LedgerConfig ByronBlock
[byronTriggerHardFork] :: ByronPartialLedgerConfig -> !TriggerHardFork
type CardanoHardForkConstraints c = (PraosCrypto c, PraosCrypto c, TranslateProto (TPraos c) (Praos c), ShelleyCompatible (TPraos c) (ShelleyEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (ShelleyEra c)), ShelleyCompatible (TPraos c) (AllegraEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (AllegraEra c)), ShelleyCompatible (TPraos c) (MaryEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (MaryEra c)), ShelleyCompatible (TPraos c) (AlonzoEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (AlonzoEra c)), ShelleyCompatible (Praos c) (BabbageEra c), LedgerSupportsProtocol (ShelleyBlock (Praos c) (BabbageEra c)), HASH c ~ Blake2b_256, ADDRHASH c ~ Blake2b_224, DSIGN c ~ Ed25519DSIGN)

-- | The trigger condition that will cause the hard fork transition.
data TriggerHardFork

-- | Trigger the transition when the on-chain protocol major version (from
--   the ledger state) reaches this number.
TriggerHardForkAtVersion :: !Word16 -> TriggerHardFork

-- | For testing only, trigger the transition at a specific hard-coded
--   epoch, irrespective of the ledger state.
TriggerHardForkAtEpoch :: !EpochNo -> TriggerHardFork

-- | Never trigger a hard fork
TriggerHardForkNever :: TriggerHardFork
data ShelleyPartialLedgerConfig era
ShelleyPartialLedgerConfig :: !ShelleyLedgerConfig era -> !TriggerHardFork -> ShelleyPartialLedgerConfig era

-- | We cache the non-partial ledger config containing a dummy
--   <a>EpochInfo</a> that needs to be replaced with the correct one.
--   
--   We do this to avoid recomputing the ledger config each time
--   <a>completeLedgerConfig</a> is called, as <a>mkShelleyLedgerConfig</a>
--   does some rather expensive computations that shouldn't be repeated too
--   often (e.g., <tt>sgActiveSlotCoeff</tt>).
[shelleyLedgerConfig] :: ShelleyPartialLedgerConfig era -> !ShelleyLedgerConfig era
[shelleyTriggerHardFork] :: ShelleyPartialLedgerConfig era -> !TriggerHardFork

-- | Forecast from a Shelley-based era to the next Shelley-based era.
forecastAcrossShelley :: (TranslateProto protoFrom protoTo, LedgerSupportsProtocol (ShelleyBlock protoFrom eraFrom)) => ShelleyLedgerConfig eraFrom -> ShelleyLedgerConfig eraTo -> Bound -> SlotNo -> LedgerState (ShelleyBlock protoFrom eraFrom) -> Except OutsideForecastRange (Ticked (WrapLedgerView (ShelleyBlock protoTo eraTo)))
translateChainDepStateAcrossShelley :: forall eraFrom eraTo protoFrom protoTo. TranslateProto protoFrom protoTo => RequiringBoth WrapConsensusConfig (Translate WrapChainDepState) (ShelleyBlock protoFrom eraFrom) (ShelleyBlock protoTo eraTo)
instance NoThunks.Class.NoThunks Ouroboros.Consensus.Cardano.CanHardFork.ByronPartialLedgerConfig
instance GHC.Generics.Generic Ouroboros.Consensus.Cardano.CanHardFork.ByronPartialLedgerConfig
instance Ouroboros.Consensus.Cardano.CanHardFork.CardanoHardForkConstraints c => Ouroboros.Consensus.HardFork.Combinator.Abstract.CanHardFork.CanHardFork (Ouroboros.Consensus.Cardano.Block.CardanoEras c)
instance Ouroboros.Consensus.HardFork.Combinator.Abstract.SingleEraBlock.SingleEraBlock Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.HardFork.Combinator.PartialConfig.HasPartialLedgerConfig Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Protocol.PBFT.Crypto.PBftCrypto bc => Ouroboros.Consensus.HardFork.Combinator.PartialConfig.HasPartialConsensusConfig (Ouroboros.Consensus.Protocol.PBFT.PBft bc)

module Ouroboros.Consensus.Cardano.Condense
instance Ouroboros.Consensus.HardFork.Combinator.Condense.CondenseConstraints Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyCompatible proto era => Ouroboros.Consensus.HardFork.Combinator.Condense.CondenseConstraints (Ouroboros.Consensus.Shelley.Ledger.Block.ShelleyBlock proto era)
instance Ouroboros.Consensus.Cardano.CanHardFork.CardanoHardForkConstraints c => Ouroboros.Consensus.HardFork.Combinator.Condense.CondenseConstraints (Ouroboros.Consensus.Cardano.Block.CardanoBlock c)

module Ouroboros.Consensus.Cardano.ShelleyBased

-- | When the given ledger state corresponds to a Shelley-based era, apply
--   the given function to it.
overShelleyBasedLedgerState :: forall c. (PraosCrypto c, PraosCrypto c) => (forall era proto. (EraCrypto era ~ c, ShelleyCompatible proto era) => LedgerState (ShelleyBlock proto era) -> LedgerState (ShelleyBlock proto era)) -> LedgerState (CardanoBlock c) -> LedgerState (CardanoBlock c)

module Ouroboros.Consensus.Cardano.Node
type CardanoHardForkConstraints c = (PraosCrypto c, PraosCrypto c, TranslateProto (TPraos c) (Praos c), ShelleyCompatible (TPraos c) (ShelleyEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (ShelleyEra c)), ShelleyCompatible (TPraos c) (AllegraEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (AllegraEra c)), ShelleyCompatible (TPraos c) (MaryEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (MaryEra c)), ShelleyCompatible (TPraos c) (AlonzoEra c), LedgerSupportsProtocol (ShelleyBlock (TPraos c) (AlonzoEra c)), ShelleyCompatible (Praos c) (BabbageEra c), LedgerSupportsProtocol (ShelleyBlock (Praos c) (BabbageEra c)), HASH c ~ Blake2b_256, ADDRHASH c ~ Blake2b_224, DSIGN c ~ Ed25519DSIGN)

-- | The maximum major protocol version.
--   
--   Must be at least the current major protocol version. For Cardano
--   mainnet, the Shelley era has major protocol verison <b>2</b>.
newtype MaxMajorProtVer
MaxMajorProtVer :: Natural -> MaxMajorProtVer
[getMaxMajorProtVer] :: MaxMajorProtVer -> Natural

-- | Parameters needed to run Allegra
data ProtocolParamsAllegra c
ProtocolParamsAllegra :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (AllegraEra c)) -> ProtocolParamsAllegra c
[$sel:allegraProtVer:ProtocolParamsAllegra] :: ProtocolParamsAllegra c -> ProtVer
[$sel:allegraMaxTxCapacityOverrides:ProtocolParamsAllegra] :: ProtocolParamsAllegra c -> Overrides (ShelleyBlock (TPraos c) (AllegraEra c))

-- | Parameters needed to run Mary
data ProtocolParamsMary c
ProtocolParamsMary :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (MaryEra c)) -> ProtocolParamsMary c
[$sel:maryProtVer:ProtocolParamsMary] :: ProtocolParamsMary c -> ProtVer
[$sel:maryMaxTxCapacityOverrides:ProtocolParamsMary] :: ProtocolParamsMary c -> Overrides (ShelleyBlock (TPraos c) (MaryEra c))

-- | Parameters needed to transition to a Shelley era.
data ProtocolTransitionParamsShelleyBased era
ProtocolTransitionParamsShelleyBased :: TranslationContext era -> TriggerHardFork -> ProtocolTransitionParamsShelleyBased era
[transitionTranslationContext] :: ProtocolTransitionParamsShelleyBased era -> TranslationContext era
[transitionTrigger] :: ProtocolTransitionParamsShelleyBased era -> TriggerHardFork

-- | The trigger condition that will cause the hard fork transition.
data TriggerHardFork

-- | Trigger the transition when the on-chain protocol major version (from
--   the ledger state) reaches this number.
TriggerHardForkAtVersion :: !Word16 -> TriggerHardFork

-- | For testing only, trigger the transition at a specific hard-coded
--   epoch, irrespective of the ledger state.
TriggerHardForkAtEpoch :: !EpochNo -> TriggerHardFork

-- | Never trigger a hard fork
TriggerHardForkNever :: TriggerHardFork
protocolClientInfoCardano :: forall c. EpochSlots -> ProtocolClientInfo (CardanoBlock c)

-- | Create a <a>ProtocolInfo</a> for <a>CardanoBlock</a>
--   
--   NOTE: the initial staking and funds in the <a>ShelleyGenesis</a> are
--   ignored, <i>unless</i> configured to skip the Byron era and hard fork
--   to Shelley or a later era from the start using
--   <tt>TriggerHardForkAtEpoch 0</tt> for testing purposes.
--   
--   PRECONDITION: only a single set of Shelley credentials is allowed when
--   used for mainnet (check against <tt><a>gNetworkId</a>
--   <a>shelleyBasedGenesis</a></tt>).
protocolInfoCardano :: forall c m. (IOLike m, CardanoHardForkConstraints c) => ProtocolParamsByron -> ProtocolParamsShelleyBased (ShelleyEra c) -> ProtocolParamsShelley c -> ProtocolParamsAllegra c -> ProtocolParamsMary c -> ProtocolParamsAlonzo c -> ProtocolParamsBabbage c -> ProtocolTransitionParamsShelleyBased (ShelleyEra c) -> ProtocolTransitionParamsShelleyBased (AllegraEra c) -> ProtocolTransitionParamsShelleyBased (MaryEra c) -> ProtocolTransitionParamsShelleyBased (AlonzoEra c) -> ProtocolTransitionParamsShelleyBased (BabbageEra c) -> ProtocolInfo m (CardanoBlock c)

-- | We support the sole Byron version with the hard fork disabled.
pattern CardanoNodeToClientVersion1 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled and the Shelley era enabled.
pattern CardanoNodeToClientVersion2 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled and the Shelley era enabled, but using
--   <a>ShelleyNodeToClientVersion2</a> and
--   <a>HardForkSpecificNodeToClientVersion2</a>.
pattern CardanoNodeToClientVersion3 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley and Allegra eras enabled.
--   
--   We don't bother with <a>ShelleyNodeToClientVersion1</a> and
--   <a>HardForkSpecificNodeToClientVersion1</a>.
pattern CardanoNodeToClientVersion4 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, and Mary eras
--   enabled.
--   
--   We don't bother with <a>ShelleyNodeToClientVersion1</a>.
pattern CardanoNodeToClientVersion5 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, and Mary eras
--   enabled, but using <a>ShelleyNodeToClientVersion3</a> for the
--   Shelley-based eras , which enables new queries.
pattern CardanoNodeToClientVersion6 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, Mary and Alonzo eras
--   enabled
pattern CardanoNodeToClientVersion7 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, Mary and Alonzo eras
--   enabled Using <a>ShelleyNodeToClientVersion5</a> for the Shelley-based
--   eras , which enables new queries.
pattern CardanoNodeToClientVersion8 :: BlockNodeToClientVersion (CardanoBlock c)

-- | The hard fork enabled, and the Shelley, Allegra, Mary, Alonzo and
--   Babbage eras enabled Using <a>ShelleyNodeToClientVersion5</a> for the
--   Shelley-based eras, which enables new queries.
pattern CardanoNodeToClientVersion9 :: BlockNodeToClientVersion (CardanoBlock c)

-- | We support only Byron V1 with the hard fork disabled, as no other
--   versions have been released before the hard fork
pattern CardanoNodeToNodeVersion1 :: BlockNodeToNodeVersion (CardanoBlock c)

-- | The hard fork enabled with the latest Byron version and the Shelley
--   era enabled.
pattern CardanoNodeToNodeVersion2 :: BlockNodeToNodeVersion (CardanoBlock c)

-- | The hard fork enabled with the latest Byron version, the Shelley and
--   Allegra eras enabled.
pattern CardanoNodeToNodeVersion3 :: BlockNodeToNodeVersion (CardanoBlock c)

-- | The hard fork enabled with the latest Byron version, the Shelley,
--   Allegra, and Mary eras enabled.
pattern CardanoNodeToNodeVersion4 :: BlockNodeToNodeVersion (CardanoBlock c)

-- | The hard fork enabled with the latest Byron version, the Shelley,
--   Allegra, Mary and Alonzo eras enabled.
pattern CardanoNodeToNodeVersion5 :: BlockNodeToNodeVersion (CardanoBlock c)

-- | The hard fork enabled with the latest Byron version, the Shelley,
--   Allegra, Mary, Alonzo and Babbage eras enabled.
pattern CardanoNodeToNodeVersion6 :: BlockNodeToNodeVersion (CardanoBlock c)
instance Ouroboros.Consensus.HardFork.Combinator.Serialisation.Common.SerialiseConstraintsHFC Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.Cardano.CanHardFork.CardanoHardForkConstraints c => Ouroboros.Consensus.HardFork.Combinator.Serialisation.Common.SerialiseHFC (Ouroboros.Consensus.Cardano.Block.CardanoEras c)
instance Ouroboros.Consensus.Cardano.CanHardFork.CardanoHardForkConstraints c => Ouroboros.Consensus.Node.NetworkProtocolVersion.SupportedNetworkProtocolVersion (Ouroboros.Consensus.Cardano.Block.CardanoBlock c)

module Ouroboros.Consensus.Cardano.ByronHFC

-- | Byron as the single era in the hard fork combinator
type ByronBlockHFC = HardForkBlock '[ByronBlock]
instance Ouroboros.Consensus.Node.NetworkProtocolVersion.SupportedNetworkProtocolVersion Ouroboros.Consensus.Cardano.ByronHFC.ByronBlockHFC
instance Ouroboros.Consensus.HardFork.Combinator.Abstract.NoHardForks.NoHardForks Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock
instance Ouroboros.Consensus.HardFork.Combinator.Serialisation.Common.SerialiseHFC '[Ouroboros.Consensus.Byron.Ledger.Block.ByronBlock]

module Ouroboros.Consensus.Cardano

-- | <i>The</i> Cardano block.
--   
--   Thanks to the pattern synonyms, you can treat this as a sum type with
--   constructors <a>BlockByron</a> and <a>BlockShelley</a>.
--   
--   <pre>
--   f :: CardanoBlock c -&gt; _
--   f (BlockByron   b) = _
--   f (BlockShelley s) = _
--   f (BlockAllegra a) = _
--   f (BlockMary    m) = _
--   f (BlockAlonzo  m) = _
--   </pre>
type CardanoBlock c = HardForkBlock (CardanoEras c)
type ProtocolByron = HardForkProtocol '[ByronBlock]
type ProtocolCardano = HardForkProtocol '[ByronBlock, ShelleyBlock (TPraos StandardCrypto) StandardShelley, ShelleyBlock (TPraos StandardCrypto) StandardAllegra, ShelleyBlock (TPraos StandardCrypto) StandardMary, ShelleyBlock (TPraos StandardCrypto) StandardAlonzo, ShelleyBlock (Praos StandardCrypto) StandardBabbage]
type ProtocolShelley = HardForkProtocol '[ShelleyBlock TPraos StandardCrypto StandardShelley]

-- | Parameters needed to run Allegra
data ProtocolParamsAllegra c
ProtocolParamsAllegra :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (AllegraEra c)) -> ProtocolParamsAllegra c
[$sel:allegraProtVer:ProtocolParamsAllegra] :: ProtocolParamsAllegra c -> ProtVer
[$sel:allegraMaxTxCapacityOverrides:ProtocolParamsAllegra] :: ProtocolParamsAllegra c -> Overrides (ShelleyBlock (TPraos c) (AllegraEra c))

-- | Parameters needed to run Alonzo
data ProtocolParamsAlonzo c
ProtocolParamsAlonzo :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (AlonzoEra c)) -> ProtocolParamsAlonzo c
[$sel:alonzoProtVer:ProtocolParamsAlonzo] :: ProtocolParamsAlonzo c -> ProtVer
[$sel:alonzoMaxTxCapacityOverrides:ProtocolParamsAlonzo] :: ProtocolParamsAlonzo c -> Overrides (ShelleyBlock (TPraos c) (AlonzoEra c))

-- | Parameters needed to run Byron
data ProtocolParamsByron
ProtocolParamsByron :: Config -> Maybe PBftSignatureThreshold -> ProtocolVersion -> SoftwareVersion -> Maybe ByronLeaderCredentials -> Overrides ByronBlock -> ProtocolParamsByron
[$sel:byronGenesis:ProtocolParamsByron] :: ProtocolParamsByron -> Config
[$sel:byronPbftSignatureThreshold:ProtocolParamsByron] :: ProtocolParamsByron -> Maybe PBftSignatureThreshold
[$sel:byronProtocolVersion:ProtocolParamsByron] :: ProtocolParamsByron -> ProtocolVersion
[$sel:byronSoftwareVersion:ProtocolParamsByron] :: ProtocolParamsByron -> SoftwareVersion
[$sel:byronLeaderCredentials:ProtocolParamsByron] :: ProtocolParamsByron -> Maybe ByronLeaderCredentials
[$sel:byronMaxTxCapacityOverrides:ProtocolParamsByron] :: ProtocolParamsByron -> Overrides ByronBlock

-- | Parameters needed to run Mary
data ProtocolParamsMary c
ProtocolParamsMary :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (MaryEra c)) -> ProtocolParamsMary c
[$sel:maryProtVer:ProtocolParamsMary] :: ProtocolParamsMary c -> ProtVer
[$sel:maryMaxTxCapacityOverrides:ProtocolParamsMary] :: ProtocolParamsMary c -> Overrides (ShelleyBlock (TPraos c) (MaryEra c))

-- | Parameters needed to run Shelley
data ProtocolParamsShelley c
ProtocolParamsShelley :: ProtVer -> Overrides (ShelleyBlock (TPraos c) (ShelleyEra c)) -> ProtocolParamsShelley c
[$sel:shelleyProtVer:ProtocolParamsShelley] :: ProtocolParamsShelley c -> ProtVer
[$sel:shelleyMaxTxCapacityOverrides:ProtocolParamsShelley] :: ProtocolParamsShelley c -> Overrides (ShelleyBlock (TPraos c) (ShelleyEra c))

-- | Parameters needed to transition to a Shelley era.
data ProtocolTransitionParamsShelleyBased era
ProtocolTransitionParamsShelleyBased :: TranslationContext era -> TriggerHardFork -> ProtocolTransitionParamsShelleyBased era
[transitionTranslationContext] :: ProtocolTransitionParamsShelleyBased era -> TranslationContext era
[transitionTrigger] :: ProtocolTransitionParamsShelleyBased era -> TriggerHardFork
