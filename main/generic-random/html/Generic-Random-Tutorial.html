<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Generic.Random.Tutorial</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">generic-random-1.5.0.1: Generic random generators for QuickCheck</span><ul class="links" id="page-menu"><li><a href="src/Generic.Random.Tutorial.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Generic.Random.Tutorial</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Generic implementations of
 <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>'s
 <code>arbitrary</code>.</p><h1>Example</h1><p>Define your type.</p><pre>data Tree a = Leaf a | Node (Tree a) (Tree a)
  deriving <code><a href="../../ghc/html/libraries/base-4.14.3.0/GHC-Generics.html#v:Generic" title="GHC.Generics">Generic</a></code>
</pre><p>Pick an <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:arbitrary" title="Test.QuickCheck">arbitrary</a></code> implementation, specifying the required distribution of
 data constructors.</p><pre>instance Arbitrary a =&gt; Arbitrary (Tree a) where
  arbitrary = <code><a href="Generic-Random.html#v:genericArbitrary" title="Generic.Random">genericArbitrary</a></code> (9 <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> 8 <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> ())
</pre><p>That random generator <code>arbitrary :: <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:Gen" title="Test.QuickCheck">Gen</a></code> (Tree a)</code> picks a
 <code>Leaf</code> with probability 9/17, or a
 <code>Node</code> with probability 8/17, and recursively fills their fields with
 <code>arbitrary</code>.</p><p>For <code>Tree</code>, the generic implementation <code><a href="Generic-Random.html#v:genericArbitrary" title="Generic.Random">genericArbitrary</a></code> is equivalent to
 the following:</p><pre><code><a href="Generic-Random.html#v:genericArbitrary" title="Generic.Random">genericArbitrary</a></code> :: Arbitrary a =&gt; <code><a href="Generic-Random.html#t:Weights" title="Generic.Random">Weights</a></code> (Tree a) -&gt; Gen (Tree a)
<code><a href="Generic-Random.html#v:genericArbitrary" title="Generic.Random">genericArbitrary</a></code> (x <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> y <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> ()) =
  frequency
    [ (x, Leaf <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> arbitrary)
    , (y, Node <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> arbitrary <code><a href="../../ghc/html/libraries/base-4.14.3.0/Control-Applicative.html#v:-60--42--62-" title="Control.Applicative">&lt;*&gt;</a></code> arbitrary)
    ]
</pre><h1>Distribution of constructors</h1><p>The distribution of constructors can be specified as
 a special list of <em>weights</em> in the same order as the data type definition.
 This assigns to each constructor a probability <code>p_C</code> proportional to its weight <code>weight_C</code>;
 in other words, <code>p_C = weight_C / sumOfWeights</code>.</p><p>The list of weights is built up with the <code>(<code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code>)</code> operator as a cons, and using
 the unit <code>()</code> as the empty list, in the order corresponding to the data type
 definition.</p><h2>Uniform distribution</h2><p>You can specify the uniform distribution (all weights equal to 1) with <code><a href="Generic-Random.html#v:uniform" title="Generic.Random">uniform</a></code>.
 (<code><a href="Generic-Random.html#v:genericArbitraryU" title="Generic.Random">genericArbitraryU</a></code> is available as a shorthand for
 <code><code><a href="Generic-Random.html#v:genericArbitrary" title="Generic.Random">genericArbitrary</a></code> <code><a href="Generic-Random.html#v:uniform" title="Generic.Random">uniform</a></code></code>.)</p><p>Note that for many recursive types, a uniform distribution tends to produce
 big or even infinite values.</p><h2>Typed weights</h2><p>The weights actually have type <code><code><a href="Generic-Random.html#t:W" title="Generic.Random">W</a></code> &quot;ConstructorName&quot;</code> (just a newtype
 around <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Int.html#t:Int" title="Data.Int">Int</a></code>), so that you can annotate a weight with its corresponding
 constructor. The constructors must appear in the same order as in the
 original type definition.</p><p>This will type-check:</p><pre>((x :: <code><a href="Generic-Random.html#t:W" title="Generic.Random">W</a></code> &quot;Leaf&quot;) <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> (y :: <code><a href="Generic-Random.html#t:W" title="Generic.Random">W</a></code> &quot;Node&quot;) <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> ()) :: <code><a href="Generic-Random.html#t:Weights" title="Generic.Random">Weights</a></code> (Tree a)
( x              <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> (y :: <code><a href="Generic-Random.html#t:W" title="Generic.Random">W</a></code> &quot;Node&quot;) <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> ()) :: <code><a href="Generic-Random.html#t:Weights" title="Generic.Random">Weights</a></code> (Tree a)
</pre><p>This will not:</p><pre>((x :: <code><a href="Generic-Random.html#t:W" title="Generic.Random">W</a></code> &quot;Node&quot;) <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> y <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> ()) :: <code><a href="Generic-Random.html#t:Weights" title="Generic.Random">Weights</a></code> (Tree a)
-- Requires an order of constructors different from the definition of the <code>Tree</code> type.

( x              <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> y <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> z <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> ()) :: <code><a href="Generic-Random.html#t:Weights" title="Generic.Random">Weights</a></code> (Tree a)
-- Doesn't have the right number of weights.
</pre><h1>Ensuring termination</h1><p>As mentioned earlier, one must be careful with recursive types
 to avoid producing extremely large values.
 The alternative generator <code><a href="Generic-Random.html#v:genericArbitraryRec" title="Generic.Random">genericArbitraryRec</a></code> decreases the size
 parameter at every call to keep values at reasonable sizes.
 It is to be used together with <code><a href="Generic-Random.html#v:withBaseCase" title="Generic.Random">withBaseCase</a></code>.</p><p>For example, we may provide a base case consisting of only <code>Leaf</code>:</p><pre>instance Arbitrary a =&gt; Arbitrary (Tree a) where
  arbitrary = <code><a href="Generic-Random.html#v:genericArbitraryRec" title="Generic.Random">genericArbitraryRec</a></code> (1 <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> 2 <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> ())
    <code><a href="Generic-Random.html#v:withBaseCase" title="Generic.Random">`withBaseCase`</a></code> (Leaf <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> arbitrary)
</pre><p>That is equivalent to the following definition. Note the
 <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:resize" title="Test.QuickCheck">resize</a></code> modifier.</p><pre>arbitrary :: Arbitrary a =&gt; Gen (Tree a)
arbitrary = sized $ \n -&gt;
  -- &quot;if&quot; condition from withBaseCase
  if n == 0 then
    Leaf &lt;$&gt; arbitrary
  else
    -- genericArbitraryRec
    frequency
      [ (1, resize (max 0 (n - 1)) (Leaf <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> arbitrary))
      , (2, resize (n `div` 2)     (Node <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> arbitrary <code><a href="../../ghc/html/libraries/base-4.14.3.0/Control-Applicative.html#v:-60--42--62-" title="Control.Applicative">&lt;*&gt;</a></code> arbitrary))
      ]
</pre><p>The resizing strategy is as follows:
 the size parameter of <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:Gen" title="Test.QuickCheck">Gen</a></code> is divided among the fields of
 the chosen constructor, or decreases by one if the constructor is unary.
 <code><code><a href="Generic-Random.html#v:withBaseCase" title="Generic.Random">withBaseCase</a></code> defG baseG</code> is equal to <code>defG</code> as long as the size parameter
 is nonzero, and it becomes <code>baseG</code> once the size reaches zero.
 This combination generally ensures that the number of constructors remains
 bounded by the initial size parameter passed to <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:Gen" title="Test.QuickCheck">Gen</a></code>.</p><h2>Automatic base case discovery</h2><p>In some situations, generic-random can also construct base cases automatically.
 This works best with fully concrete types (no type parameters).</p><pre>{-# LANGUAGE FlexibleInstances #-}

instance Arbitrary (Tree ()) where
  arbitrary = <code><a href="Generic-Random.html#v:genericArbitrary-39-" title="Generic.Random">genericArbitrary'</a></code> (1 <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> 2 <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> ())
</pre><p>The above instance will infer the value <code>Leaf ()</code> as a base case.</p><p>To discover values of type <code>Tree a</code>, we must inspect the type argument <code>a</code>,
 thus we incur some extra constraints if we want polymorphism.
 It is preferrable to apply the type class <code><a href="Generic-Random.html#t:BaseCase" title="Generic.Random">BaseCase</a></code> to the instance head
 (<code>Tree a</code>) as follows, as it doesn't reduce to something worth seeing.</p><pre>{-# LANGUAGE FlexibleContexts, UndecidableInstances #-}

instance (Arbitrary a, <code><a href="Generic-Random.html#t:BaseCase" title="Generic.Random">BaseCase</a></code> (Tree a))
  =&gt; Arbitrary (Tree a) where
  arbitrary = <code><a href="Generic-Random.html#v:genericArbitrary-39-" title="Generic.Random">genericArbitrary'</a></code> (1 <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> 2 <code><a href="Generic-Random.html#v:-37-" title="Generic.Random">%</a></code> ())
</pre><p>The <code><a href="Generic-Random.html#t:BaseCase" title="Generic.Random">BaseCase</a></code> type class finds values of minimal depth,
 where the depth of a constructor is defined as <code>1 + max(0, depths of fields)</code>,
 e.g., <code>Leaf ()</code> has depth 2.</p><h2>Note about lists <a id="notelists"></a></h2><p>The <code>Arbitrary</code> instance for lists can be problematic for this way
 of implementing recursive sized generators, because they make a lot of
 recursive calls to <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:arbitrary" title="Test.QuickCheck">arbitrary</a></code> without decreasing the size parameter.
 Hence, as a default, <code><a href="Generic-Random.html#v:genericArbitraryRec" title="Generic.Random">genericArbitraryRec</a></code> also detects fields which are
 lists to replace <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:arbitrary" title="Test.QuickCheck">arbitrary</a></code> with a different generator that divides
 the size parameter by the length of the list before generating each
 element. This uses the customizable mechanism shown in the next section.</p><p>If you really want to use <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:arbitrary" title="Test.QuickCheck">arbitrary</a></code> for lists in the derived instances,
 substitute <code><code><a href="Generic-Random.html#v:genericArbitraryRec" title="Generic.Random">genericArbitraryRec</a></code></code> with <code><code><a href="Generic-Random.html#v:genericArbitraryRecG" title="Generic.Random">genericArbitraryRecG</a></code> ()</code>.</p><pre>arbitrary = <code><a href="Generic-Random.html#v:genericArbitraryRecG" title="Generic.Random">genericArbitraryRecG</a></code> ()
  <code><a href="Generic-Random.html#v:withBaseCase" title="Generic.Random">`withBaseCase`</a></code> baseGen
</pre><p>Some combinators are available for further tweaking: <code><a href="Generic-Random.html#v:listOf-39-" title="Generic.Random">listOf'</a></code>, <code><a href="Generic-Random.html#v:listOf1-39-" title="Generic.Random">listOf1'</a></code>,
 <code><a href="Generic-Random.html#v:vectorOf-39-" title="Generic.Random">vectorOf'</a></code>.</p><h1>Custom generators for some fields</h1><h2>Example 1 (<code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:Gen" title="Test.QuickCheck">Gen</a></code>, <code><a href="Generic-Random.html#t:FieldGen" title="Generic.Random">FieldGen</a></code>)</h2><p>Sometimes, a few fields may need custom generators instead of <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:arbitrary" title="Test.QuickCheck">arbitrary</a></code>.
 For example, imagine here that <code>String</code> is meant to represent
 alphanumerical strings only, and that IDs are meant to be nonnegative,
 whereas balances can have any sign.</p><pre>data User = User {
  userName :: String,
  userId :: Int,
  userBalance :: Int
  } deriving <code><a href="../../ghc/html/libraries/base-4.14.3.0/GHC-Generics.html#v:Generic" title="GHC.Generics">Generic</a></code>
</pre><p>A naive approach has the following problems:</p><ul><li><code><code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:Arbitrary" title="Test.QuickCheck">Arbitrary</a></code> String</code> may generate any unicode character,
   alphanumeric or not;</li><li><code><code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:Arbitrary" title="Test.QuickCheck">Arbitrary</a></code> Int</code> may generate negative values;</li><li>using <code>newtype</code> wrappers or passing generators explicitly to properties
   may be impractical (the maintenance overhead can be high because the types
   are big or change often).</li></ul><p>Using generic-random, we can declare a (heterogeneous) list of generators to
 be used instead of <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:arbitrary" title="Test.QuickCheck">arbitrary</a></code> when generating certain fields.</p><pre>customGens :: <code><a href="Generic-Random.html#t:FieldGen" title="Generic.Random">FieldGen</a></code> &quot;userId&quot; Int <code><a href="Generic-Random.html#t::-43-" title="Generic.Random">:+</a></code> <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:Gen" title="Test.QuickCheck">Gen</a></code> String
customGens =
  <code><a href="Generic-Random.html#t:FieldGen" title="Generic.Random">FieldGen</a></code> (<code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:getNonNegative" title="Test.QuickCheck">getNonNegative</a></code> <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> arbitrary) <code><a href="Generic-Random.html#t::-43-" title="Generic.Random">:+</a></code>
  <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:listOf" title="Test.QuickCheck">listOf</a></code> (<code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:elements" title="Test.QuickCheck">elements</a></code> (filter isAlphaNum [minBound .. maxBound]))
</pre><p>Now we use the <code><a href="Generic-Random.html#v:genericArbitraryG" title="Generic.Random">genericArbitraryG</a></code> combinator and other <code>G</code>-suffixed
 variants that accept those explicit generators.</p><ul><li>All <code>String</code> fields will use the provided generator of
   alphanumeric strings;</li><li>the field <code>&quot;userId&quot;</code> of type <code>Int</code> will use the generator
   of nonnegative integers;</li><li>everything else defaults to <code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:arbitrary" title="Test.QuickCheck">arbitrary</a></code>.</li></ul><pre>instance Arbitrary User where
  arbitrary = <code><a href="Generic-Random.html#v:genericArbitrarySingleG" title="Generic.Random">genericArbitrarySingleG</a></code> customGens
</pre><h2>Example 2 (<code><a href="Generic-Random.html#t:ConstrGen" title="Generic.Random">ConstrGen</a></code>)</h2><p>Here's the <code>Tree</code> type from the beginning again.</p><pre>data Tree a = Leaf a | Node (Tree a) (Tree a)
  deriving <code><a href="../../ghc/html/libraries/base-4.14.3.0/GHC-Generics.html#v:Generic" title="GHC.Generics">Generic</a></code>
</pre><p>We will generate &quot;right-leaning linear trees&quot;, which look like this:</p><pre>Node (Leaf 1)
     (Node (Leaf 2)
           (Node (Leaf 3)
                 (Node (Leaf 4)
                       (Leaf 5))))</pre><p>To do so, we force every left child of a <code>Node</code> to be a <code>Leaf</code>:</p><pre>{-# LANGUAGE ScopedTypeVariables #-}

instance Arbitrary a =&gt; Arbitrary (Tree a) where
  arbitrary = <code><a href="Generic-Random.html#v:genericArbitraryUG" title="Generic.Random">genericArbitraryUG</a></code> customGens
    where
      -- Generator for the left field (i.e., at index 0) of constructor Node,
      -- which must have type (Tree a).
      customGens :: <code><a href="Generic-Random.html#t:ConstrGen" title="Generic.Random">ConstrGen</a></code> &quot;Node&quot; 0 (Tree a)
      customGens =  <code><a href="Generic-Random.html#t:ConstrGen" title="Generic.Random">ConstrGen</a></code> (Leaf <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> arbitrary)
</pre><p>That instance is equivalent to the following:</p><pre>instance Arbitrary a =&gt; Arbitrary (Tree a) where
  arbitrary = oneof
    [ Leaf <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> arbitrary
    , Node <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> (Leaf <code><a href="../../ghc/html/libraries/base-4.14.3.0/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> arbitrary) <code><a href="../../ghc/html/libraries/base-4.14.3.0/Control-Applicative.html#v:-60--42--62-" title="Control.Applicative">&lt;*&gt;</a></code> arbitrary
    --                                  ^ recursive call
    ]
</pre><h2>Custom generators reference</h2><p>The custom generator modifiers that can occur in the list are:</p><ul><li><code><a href="../../QuickCheck/html/Test-QuickCheck.html#v:Gen" title="Test.QuickCheck">Gen</a></code>: a generator for a specific type;</li><li><code><a href="Generic-Random.html#t:FieldGen" title="Generic.Random">FieldGen</a></code>: a generator for a record field;</li><li><code><a href="Generic-Random.html#t:ConstrGen" title="Generic.Random">ConstrGen</a></code>: a generator for a field of a given constructor;</li><li><code><a href="Generic-Random.html#t:Gen1" title="Generic.Random">Gen1</a></code>: a generator for &quot;containers&quot;, parameterized by a generator
   for individual elements;</li><li><code><a href="Generic-Random.html#t:Gen1_" title="Generic.Random">Gen1_</a></code>: a generator for unary type constructors that are not
   containers.</li></ul><p>Suggestions to add more modifiers or otherwise improve this tutorial are welcome!
 <a href="https://github.com/Lysxia/generic-random/issues">The issue tracker is this way.</a></p></div></div><div id="interface"></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>