-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Core components of Cardano ledgers from the Shelley release on.
--   
--   Cardano ledgers from the Shelley release onwards share a core basis
--   rooted in the Shelley ledger specification. This package abstracts a
--   number of components which we expect to be shared amongst all future
--   ledgers implemented around this base.
@package cardano-ledger-core
@version 0.1.0.0

module Cardano.Ledger.Compactible
class (Show (CompactForm a), Eq (CompactForm a), ToCBOR (CompactForm a)) => Compactible a where {
    data family CompactForm a :: Type;
}
toCompact :: Compactible a => a -> Maybe (CompactForm a)
fromCompact :: Compactible a => CompactForm a -> a

module Cardano.Ledger.Coin

-- | The amount of value held by a transaction output.
newtype Coin
Coin :: Integer -> Coin
[unCoin] :: Coin -> Integer
data family CompactForm a :: Type
newtype DeltaCoin
DeltaCoin :: Integer -> DeltaCoin
word64ToCoin :: Word64 -> Coin
coinToRational :: Coin -> Rational
rationalToCoinViaFloor :: Rational -> Coin
rationalToCoinViaCeiling :: Rational -> Coin
addDeltaCoin :: Coin -> DeltaCoin -> Coin
toDeltaCoin :: Coin -> DeltaCoin
integerToWord64 :: Integer -> Maybe Word64
instance Cardano.Prelude.HeapWords.HeapWords Cardano.Ledger.Coin.Coin
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Coin.Coin
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Coin.Coin
instance Data.PartialOrd.PartialOrd Cardano.Ledger.Coin.Coin
instance Data.Group.Abelian Cardano.Ledger.Coin.Coin
instance Data.Group.Group Cardano.Ledger.Coin.Coin
instance GHC.Base.Monoid Cardano.Ledger.Coin.Coin
instance GHC.Base.Semigroup Cardano.Ledger.Coin.Coin
instance GHC.Show.Show Cardano.Ledger.Coin.Coin
instance Control.DeepSeq.NFData Cardano.Ledger.Coin.Coin
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.Coin.Coin
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.Coin.Coin
instance GHC.Generics.Generic Cardano.Ledger.Coin.Coin
instance NoThunks.Class.NoThunks Cardano.Ledger.Coin.Coin
instance GHC.Enum.Enum Cardano.Ledger.Coin.Coin
instance GHC.Classes.Ord Cardano.Ledger.Coin.Coin
instance GHC.Classes.Eq Cardano.Ledger.Coin.Coin
instance Data.Primitive.Types.Prim (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Cardano.Prelude.HeapWords.HeapWords (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Control.DeepSeq.NFData (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance GHC.Show.Show (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance GHC.Classes.Eq (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Data.PartialOrd.PartialOrd Cardano.Ledger.Coin.DeltaCoin
instance Data.Group.Abelian Cardano.Ledger.Coin.DeltaCoin
instance Data.Group.Group Cardano.Ledger.Coin.DeltaCoin
instance GHC.Base.Monoid Cardano.Ledger.Coin.DeltaCoin
instance GHC.Base.Semigroup Cardano.Ledger.Coin.DeltaCoin
instance GHC.Show.Show Cardano.Ledger.Coin.DeltaCoin
instance Cardano.Prelude.HeapWords.HeapWords Cardano.Ledger.Coin.DeltaCoin
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Coin.DeltaCoin
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Coin.DeltaCoin
instance Control.DeepSeq.NFData Cardano.Ledger.Coin.DeltaCoin
instance NoThunks.Class.NoThunks Cardano.Ledger.Coin.DeltaCoin
instance GHC.Enum.Enum Cardano.Ledger.Coin.DeltaCoin
instance GHC.Generics.Generic Cardano.Ledger.Coin.DeltaCoin
instance GHC.Classes.Ord Cardano.Ledger.Coin.DeltaCoin
instance GHC.Classes.Eq Cardano.Ledger.Coin.DeltaCoin
instance Data.Primitive.Types.Prim (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Cardano.Prelude.HeapWords.HeapWords (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Control.DeepSeq.NFData (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance GHC.Show.Show (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance GHC.Classes.Eq (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Cardano.Ledger.Compactible.Compactible Cardano.Ledger.Coin.DeltaCoin
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.DeltaCoin)
instance Cardano.Ledger.Compactible.Compactible Cardano.Ledger.Coin.Coin
instance Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)
instance Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Compactible.CompactForm Cardano.Ledger.Coin.Coin)


-- | This module defines core type families which we know to vary from era
--   to era.
--   
--   Families in this module should be indexed on era.
--   
--   It is intended for qualified import: &gt; import qualified
--   Cardano.Ledger.Core as Core
module Cardano.Ledger.Core

-- | A transaction output.
type family TxOut era = (r :: Type) | r -> era

-- | The body of a transaction.
type family TxBody era = (r :: Type) | r -> era

-- | A value is something which quantifies a transaction output.
type family Value era :: Type

-- | Scripts which may lock transaction outputs in this era
type family Script era :: Type

-- | AuxiliaryData which may be attached to a transaction
type family AuxiliaryData era = (r :: Type) | r -> era

-- | Protocol parameters
type family PParams era = (r :: Type) | r -> era

-- | The type of updates to Protocol parameters
type family PParamsDelta era = (r :: Type) | r -> era

-- | The set of witnesses in a Tx
type family Witnesses era = (r :: Type) | r -> era

-- | A transaction.
type family Tx era = (r :: Type) | r -> era

-- | Common constraints
--   
--   NOTE: <a>Ord</a> is not included, as <a>Ord</a> for a <tt>Block</tt>
--   or a <tt>NewEpochState</tt> doesn't make sense.
type ChainData t = (Eq t, Show t, NoThunks t, Typeable t)

-- | Constraints for serialising from/to CBOR
type SerialisableData t = (FromCBOR t, ToCBOR t)

-- | Constraints for serialising from/to CBOR using <a>Annotator</a>
type AnnotatedData t = (FromCBOR (Annotator t), ToCBOR t)

-- | Era STS map
type family EraRule (k :: Symbol) era :: Type


-- | Package all the crypto constraints into one place.
module Cardano.Ledger.Crypto
class (HashAlgorithm (HASH c), HashAlgorithm (ADDRHASH c), DSIGNAlgorithm (DSIGN c), KESAlgorithm (KES c), VRFAlgorithm (VRF c), ContextDSIGN (DSIGN c) ~ (), ContextKES (KES c) ~ (), ContextVRF (VRF c) ~ (), Typeable c) => Crypto c where {
    type family HASH c :: Type;
    type family ADDRHASH c :: Type;
    type family DSIGN c :: Type;
    type family KES c :: Type;
    type family VRF c :: Type;
}

-- | The same crypto used on the net
data StandardCrypto
instance Cardano.Ledger.Crypto.Crypto Cardano.Ledger.Crypto.StandardCrypto


-- | Describes modes under which we might validate certain rules in the
--   ledger.
--   
--   What does this mean? Sometimes, we will want to check only certain
--   conditions specified in the rules. For example, when replaying a
--   previously validated chain, we do not care about rerunning _any_
--   checks, only making the relevant changes to the ledger state.
module Cardano.Ledger.Rules.ValidationMode

-- | Indicates that this check depends only upon the signal to the
--   transition, not the state or environment.
lblStatic :: Label

-- | Construct a static predicate check.
--   
--   The choice of <tt>#</tt> as a postfix here is made because often these
--   are crypto checks.
(?!#) :: Bool -> PredicateFailure sts -> Rule sts ctx ()
infix 1 ?!#

-- | Construct a static predicate check with an explanation.
--   
--   The choice of <tt>#</tt> as a postfix here is made because often these
--   are crypto checks.
(?!#:) :: Either e () -> (e -> PredicateFailure sts) -> Rule sts ctx ()
infix 1 ?!#:

-- | Fail, if static checks are enabled.
failBecauseS :: PredicateFailure sts -> Rule sts ctx ()

-- | Apply an STS system and do not validate any static checks.
applySTSNonStatic :: forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> m (Either [PredicateFailure s] (State s))
applySTSValidateSuchThat :: forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => ([Label] -> Bool) -> RuleContext rtype s -> m (Either [PredicateFailure s] (State s))

-- | Helper function to filter out unused failures
mapMaybeValidation :: (e -> Maybe e') -> Validation (NonEmpty e) () -> Validation (NonEmpty e') ()
class Inject t s
inject :: Inject t s => t -> s
class InjectMaybe t s
injectMaybe :: InjectMaybe t s => t -> Maybe s
type Test failure = Validation (NonEmpty failure) ()
runTest :: Inject t (PredicateFailure sts) => Test t -> Rule sts ctx ()
runTestMaybe :: InjectMaybe t (PredicateFailure sts) => Test t -> Rule sts ctx ()
runTestOnSignal :: Inject t (PredicateFailure sts) => Test t -> Rule sts ctx ()

module Cardano.Ledger.SafeHash

-- | A SafeHash is a hash of something that is safe to hash. Such types
--   store their own serialisation bytes. The prime example is (MemoBytes
--   t), but other examples are things that consist of only ByteStrings.
--   
--   We do NOT export the constructor SafeHash, but instead export other
--   functions such as 'hashWithCrypto, <a>hashAnnotated</a> and
--   <a>extractHash</a> which have constraints that limit their application
--   to types which preserve their original serialization bytes.
data SafeHash crypto index

-- | Only Types that preserve their serialisation bytes are members of the
--   class SafeToHash. There are only a limited number of primitive direct
--   instances of SafeToHash, all but two of them are present in this file.
--   Instead of making explicit instances, we almost always use a newtype
--   (around a type S) where their is already an instance (SafeToHash S).
--   In that case the newtype has its SafeToHash instance derived using
--   newtype deriving. The only exceptions are the legacy Shelley types:
--   Metadata and Tx, that preserve their serialisation bytes using a
--   different mechanism than MemoBytes. SafeToHash is a superclass
--   requirement of the classes HashAnnotated and HashWithCrypto (below)
--   which provide more convenient ways to construct SafeHashes than using
--   makeHashWithExplicitProxys.
class SafeToHash t
originalBytes :: SafeToHash t => t -> ByteString
makeHashWithExplicitProxys :: (SafeToHash t, HasAlgorithm c) => Proxy c -> Proxy index -> t -> SafeHash c index

-- | To change the index parameter of SafeHash (which is a phantom type)
--   use castSafeHash
castSafeHash :: forall i j c. SafeHash c i -> SafeHash c j

-- | Determine the index from the type <tt>x</tt>
class SafeToHash x => HashAnnotated x index crypto | x -> index crypto
hashAnnotated :: forall c i x. (HasAlgorithm c, HashAnnotated x i c) => x -> SafeHash c i
indexProxy :: HashAnnotated x index crypto => x -> Proxy index

-- | When the type being hashed: <tt>x</tt> determines the <tt>index</tt>
--   tag but not the <tt>crypto</tt>
class SafeToHash x => HashWithCrypto x index | x -> index
hashWithCrypto :: forall crypto. (HashWithCrypto x index, HasAlgorithm crypto) => Proxy crypto -> x -> SafeHash crypto index
type HasAlgorithm c = HashAlgorithm (HASH c)
extractHash :: SafeHash crypto i -> Hash (HASH crypto) i
hashSafeList :: HasAlgorithm c => Proxy c -> Proxy index -> [Safe] -> SafeHash c index

-- | Sometimes one wants to hash multiple things, simply by concatenating
--   all the bytes. This abstraction allows one to do that safely.
data Safe
[Safe] :: SafeToHash x => x -> Safe
unsafeMakeSafeHash :: Hash (HASH crypto) index -> SafeHash crypto index
instance Control.DeepSeq.NFData (Cardano.Ledger.SafeHash.SafeHash crypto index)
instance NoThunks.Class.NoThunks (Cardano.Ledger.SafeHash.SafeHash crypto index)
instance GHC.Classes.Ord (Cardano.Ledger.SafeHash.SafeHash crypto index)
instance GHC.Classes.Eq (Cardano.Ledger.SafeHash.SafeHash crypto index)
instance GHC.Show.Show (Cardano.Ledger.SafeHash.SafeHash crypto index)
instance Cardano.Crypto.Hash.Class.HashAlgorithm (Cardano.Ledger.Crypto.HASH crypto) => Cardano.Ledger.SafeHash.SafeToHash (Cardano.Ledger.SafeHash.SafeHash crypto index)
instance Cardano.Prelude.HeapWords.HeapWords (Cardano.Crypto.Hash.Class.Hash (Cardano.Ledger.Crypto.HASH c) i) => Cardano.Prelude.HeapWords.HeapWords (Cardano.Ledger.SafeHash.SafeHash c i)
instance (Data.Typeable.Internal.Typeable index, Cardano.Ledger.Crypto.Crypto c) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.SafeHash.SafeHash c index)
instance (Data.Typeable.Internal.Typeable index, Cardano.Ledger.Crypto.Crypto c) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.SafeHash.SafeHash c index)
instance Cardano.Ledger.SafeHash.SafeToHash Cardano.Ledger.SafeHash.Safe
instance Cardano.Ledger.SafeHash.SafeToHash (Data.MemoBytes.MemoBytes t)
instance Cardano.Ledger.SafeHash.SafeToHash Data.ByteString.Short.Internal.ShortByteString
instance Cardano.Ledger.SafeHash.SafeToHash Data.ByteString.Internal.ByteString
instance Cardano.Crypto.Hash.Class.HashAlgorithm c => Cardano.Ledger.SafeHash.SafeToHash (Cardano.Crypto.Hash.Class.Hash c i)


-- | Various identifiers in the ledger are hashes of particular structures.
--   While the structures may change from era to era, the hash will remain
--   the same, and we can refer to the hash of, say, a transaction, without
--   knowing the actual transaction type. As such, we define a number of
--   these hashes here.
module Cardano.Ledger.Hashes
data EraIndependentTxBody
data EraIndependentBlockHeader
data EraIndependentBlockBody
data EraIndependentMetadata
data EraIndependentScript
data EraIndependentData
data EraIndependentScriptData
data EraIndependentAuxiliaryData
data EraIndependentPParamView
data EraIndependentScriptIntegrity
newtype ScriptHash crypto
ScriptHash :: Hash (ADDRHASH crypto) EraIndependentScript -> ScriptHash crypto
type DataHash crypto = SafeHash crypto EraIndependentData
instance NoThunks.Class.NoThunks (Cardano.Ledger.Hashes.ScriptHash crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Hashes.ScriptHash crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Hashes.ScriptHash crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Hashes.ScriptHash crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Hashes.ScriptHash crypto)
instance GHC.Show.Show (Cardano.Ledger.Hashes.ScriptHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Hashes.ScriptHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Hashes.ScriptHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Hashes.ScriptHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Hashes.ScriptHash crypto)

module Cardano.Ledger.Serialization
class Typeable a => ToCBORGroup a
toCBORGroup :: ToCBORGroup a => a -> Encoding
encodedGroupSizeExpr :: ToCBORGroup a => (forall x. ToCBOR x => Proxy x -> Size) -> Proxy a -> Size
listLen :: ToCBORGroup a => a -> Word

-- | an upper bound for <a>listLen</a>, used in <a>Size</a> expressions.
listLenBound :: ToCBORGroup a => Proxy a -> Word
class Typeable a => FromCBORGroup a
fromCBORGroup :: FromCBORGroup a => Decoder s a
newtype CBORGroup a
CBORGroup :: a -> CBORGroup a
[unCBORGroup] :: CBORGroup a -> a
newtype CborSeq a
CborSeq :: Seq a -> CborSeq a
[unwrapCborSeq] :: CborSeq a -> Seq a
decodeList :: Decoder s a -> Decoder s [a]
decodeSeq :: Decoder s a -> Decoder s (Seq a)
decodeStrictSeq :: Decoder s a -> Decoder s (StrictSeq a)
decodeSet :: Ord a => Decoder s a -> Decoder s (Set a)
decodeMap :: Ord a => Decoder s a -> Decoder s b -> Decoder s (Map a b)
decodeMapContents :: Decoder s a -> Decoder s [a]
decodeMapTraverse :: (Ord a, Applicative t) => Decoder s (t a) -> Decoder s (t b) -> Decoder s (t (Map a b))
decodeMaybe :: Decoder s a -> Decoder s (Maybe a)
decodeRecordNamed :: Text -> (a -> Int) -> Decoder s a -> Decoder s a
decodeRecordNamedT :: (MonadTrans m, Monad (m (Decoder s))) => Text -> (a -> Int) -> m (Decoder s) a -> m (Decoder s) a
decodeRecordSum :: String -> (Word -> Decoder s (Int, a)) -> Decoder s a
decodeNullMaybe :: Decoder s a -> Decoder s (Maybe a)
encodeFoldable :: (ToCBOR a, Foldable f) => f a -> Encoding
encodeFoldableEncoder :: Foldable f => (a -> Encoding) -> f a -> Encoding
encodeFoldableMapEncoder :: Foldable f => (Word -> a -> Maybe Encoding) -> f a -> Encoding
encodeNullMaybe :: (a -> Encoding) -> Maybe a -> Encoding
encodeMap :: (a -> Encoding) -> (b -> Encoding) -> Map a b -> Encoding
groupRecord :: forall a s. (ToCBORGroup a, FromCBORGroup a) => Decoder s a
ratioToCBOR :: ToCBOR a => Ratio a -> Encoding
ratioFromCBOR :: (Bounded a, Integral a, FromCBOR a) => Decoder s (Ratio a)
mapToCBOR :: (ToCBOR a, ToCBOR b) => Map a b -> Encoding
mapFromCBOR :: (Ord a, FromCBOR a, FromCBOR b) => Decoder s (Map a b)
translateViaCBORAnn :: (ToCBOR a, FromCBOR (Annotator b)) => Text -> a -> Except DecoderError b
ipv4ToBytes :: IPv4 -> ByteString
ipv4FromBytes :: ByteString -> Either String IPv4
ipv4ToCBOR :: IPv4 -> Encoding
ipv4FromCBOR :: Decoder s IPv4
ipv6ToBytes :: IPv6 -> ByteString
ipv6FromBytes :: ByteString -> Either String IPv6
ipv6ToCBOR :: IPv6 -> Encoding
ipv6FromCBOR :: Decoder s IPv6
listLenInt :: ToCBORGroup a => a -> Int

-- | Run a ByteString <a>Builder</a> using a strategy aimed at making
--   smaller things efficiently.
--   
--   It takes a size hint and produces a strict <tt>ByteString</tt>. This
--   will be fast when the size hint is the same or slightly bigger than
--   the true size.
runByteBuilder :: Int -> Builder -> ByteString
utcTimeToCBOR :: UTCTime -> Encoding
utcTimeFromCBOR :: Decoder s UTCTime

-- | A CBOR deserialized value together with its size. When deserializing
--   use either <a>sizedDecoder</a> or its <a>FromCBOR</a> instance.
--   
--   Use <a>mkSized</a> to construct such value.
data Sized a
Sized :: !a -> Int64 -> Sized a
[sizedValue] :: Sized a -> !a

-- | Overhead in bytes. The field is lazy on purpose, because it might not
--   be needed, but it can be expensive to compute.
[sizedSize] :: Sized a -> Int64

-- | Construct a <a>Sized</a> value by serializing it first and recording
--   the amount of bytes it requires. Note, however, CBOR serialization is
--   not canonical, therefore it is *NOT* a requirement that this property
--   holds:
--   
--   <pre>
--   sizedSize (mkSized a) === sizedSize (unsafeDeserialize (serialize a) :: a)
--   </pre>
mkSized :: ToCBOR a => a -> Sized a
sizedDecoder :: Decoder s a -> Decoder s (Sized a)
instance Data.Foldable.Foldable Cardano.Ledger.Serialization.CborSeq
instance GHC.Generics.Generic (Cardano.Ledger.Serialization.Sized a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Ledger.Serialization.Sized a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Ledger.Serialization.Sized a)
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Cardano.Ledger.Serialization.Sized a)
instance Cardano.Binary.FromCBOR.FromCBOR a => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Serialization.Sized a)
instance Cardano.Binary.ToCBOR.ToCBOR a => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Serialization.Sized a)
instance Cardano.Binary.ToCBOR.ToCBOR a => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Serialization.CborSeq a)
instance Cardano.Binary.FromCBOR.FromCBOR a => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Serialization.CborSeq a)
instance (Cardano.Ledger.Serialization.FromCBORGroup a, Cardano.Ledger.Serialization.ToCBORGroup a) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Serialization.CBORGroup a)
instance Cardano.Ledger.Serialization.ToCBORGroup a => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Serialization.CBORGroup a)

module Cardano.Ledger.Keys

-- | The role of a key.
--   
--   Note that a role is not _fixed_, nor is it unique. In particular, keys
--   may variously be used as witnesses, and so in many case we will change
--   the role of a key to the <a>Witness</a> role.
--   
--   It is also perfectly allowable for a key to be used in many roles;
--   there is nothing prohibiting somebody using the same underlying key as
--   their payment and staking key, as well as the key for their stake
--   pool. So these roles are more intended for two purposes:
--   
--   <ul>
--   <li>To make explicit how we are using a key in the specifications</li>
--   <li>To provide a guide to downstream implementors, for whom the
--   profusion of keys may be confusing.</li>
--   </ul>
data KeyRole
Genesis :: KeyRole
GenesisDelegate :: KeyRole
Payment :: KeyRole
Staking :: KeyRole
StakePool :: KeyRole
BlockIssuer :: KeyRole
Witness :: KeyRole
class HasKeyRole (a :: KeyRole -> Type -> Type)

-- | General coercion of key roles.
--   
--   The presence of this function is mostly to help the user realise where
--   they are converting key roles.
coerceKeyRole :: HasKeyRole a => a r crypto -> a r' crypto

-- | General coercion of key roles.
--   
--   The presence of this function is mostly to help the user realise where
--   they are converting key roles.
coerceKeyRole :: (HasKeyRole a, Coercible (a r crypto) (a r' crypto)) => a r crypto -> a r' crypto

-- | Use a key as a witness.
--   
--   This is the most common coercion between key roles, because most keys
--   can be used as witnesses to some types of transaction. As such, we
--   provide an explicit coercion for it.
asWitness :: HasKeyRole a => a r crypto -> a 'Witness crypto
type DSignable c = Signable (DSIGN c)

-- | Discriminated verification key
--   
--   We wrap the basic <tt>VerKeyDSIGN</tt> in order to add the key role.
newtype VKey (kd :: KeyRole) crypto
VKey :: VerKeyDSIGN (DSIGN crypto) -> VKey (kd :: KeyRole) crypto
[unVKey] :: VKey (kd :: KeyRole) crypto -> VerKeyDSIGN (DSIGN crypto)

-- | Pair of signing key and verification key, with a usage role.
data KeyPair (kd :: KeyRole) crypto
KeyPair :: !VKey kd crypto -> !SignKeyDSIGN (DSIGN crypto) -> KeyPair (kd :: KeyRole) crypto
[vKey] :: KeyPair (kd :: KeyRole) crypto -> !VKey kd crypto
[sKey] :: KeyPair (kd :: KeyRole) crypto -> !SignKeyDSIGN (DSIGN crypto)

-- | Produce a digital signature
signedDSIGN :: (Crypto crypto, Signable (DSIGN crypto) a) => SignKeyDSIGN (DSIGN crypto) -> a -> SignedDSIGN crypto a

-- | Verify a digital signature
verifySignedDSIGN :: (Crypto crypto, Signable (DSIGN crypto) a) => VKey kd crypto -> a -> SignedDSIGN crypto a -> Bool

-- | Hash a given signature
hashSignature :: Crypto crypto => SignedDSIGN crypto (Hash crypto h) -> Hash crypto (SignedDSIGN crypto (Hash crypto h))

-- | Discriminated hash of public Key
newtype KeyHash (discriminator :: KeyRole) crypto
KeyHash :: Hash (ADDRHASH crypto) (VerKeyDSIGN (DSIGN crypto)) -> KeyHash (discriminator :: KeyRole) crypto

-- | Hash a given public key
hashKey :: Crypto crypto => VKey kd crypto -> KeyHash kd crypto
data GenDelegPair crypto
GenDelegPair :: !KeyHash 'GenesisDelegate crypto -> !Hash crypto (VerKeyVRF crypto) -> GenDelegPair crypto
[genDelegKeyHash] :: GenDelegPair crypto -> !KeyHash 'GenesisDelegate crypto
[genDelegVrfHash] :: GenDelegPair crypto -> !Hash crypto (VerKeyVRF crypto)
newtype GenDelegs crypto
GenDelegs :: Map (KeyHash 'Genesis crypto) (GenDelegPair crypto) -> GenDelegs crypto
[unGenDelegs] :: GenDelegs crypto -> Map (KeyHash 'Genesis crypto) (GenDelegPair crypto)
newtype GKeys crypto
GKeys :: Set (VKey 'Genesis crypto) -> GKeys crypto
[unGKeys] :: GKeys crypto -> Set (VKey 'Genesis crypto)
type KESignable c = Signable (KES c)
type VRFSignable c = Signable (VRF c)
decodeSignedDSIGN :: DSIGNAlgorithm v => Decoder s (SignedDSIGN v a)
encodeSignedDSIGN :: DSIGNAlgorithm v => SignedDSIGN v a -> Encoding

-- | A variation on <a>hashWith</a>, but specially for CBOR encodings.
hashWithSerialiser :: HashAlgorithm h => (a -> Encoding) -> a -> Hash h a
decodeSignedKES :: KESAlgorithm v => Decoder s (SignedKES v a)
decodeVerKeyKES :: KESAlgorithm v => Decoder s (VerKeyKES v)
encodeSignedKES :: KESAlgorithm v => SignedKES v a -> Encoding
encodeVerKeyKES :: KESAlgorithm v => VerKeyKES v -> Encoding
signedKES :: (KESAlgorithm v, Signable v a) => ContextKES v -> Period -> a -> SignKeyKES v -> SignedKES v a

-- | Update the KES signature key to the <i>next</i> period, given the
--   <i>current</i> period.
--   
--   It returns <a>Nothing</a> if the cannot be evolved any further.
--   
--   The precondition (to get a <a>Just</a> result) is that the current KES
--   period of the input key is not the last period. The given period must
--   be the current KES period of the input key (not the next or target).
--   
--   The postcondition is that in case a key is returned, its current KES
--   period is incremented by one compared to before.
--   
--   Note that you must track the current period separately, and to skip to
--   a later period requires repeated use of this function, since it only
--   increments one period at once.
updateKES :: KESAlgorithm v => ContextKES v -> SignKeyKES v -> Period -> Maybe (SignKeyKES v)

-- | Full KES verification. This method checks that the signature itself
--   checks out (as per <a>verifySigKES</a>), and also makes sure that it
--   matches the provided VerKey.
verifyKES :: (KESAlgorithm v, Signable v a, HasCallStack) => ContextKES v -> VerKeyKES v -> Period -> a -> SigKES v -> Either String ()
verifySignedKES :: (KESAlgorithm v, Signable v a) => ContextKES v -> VerKeyKES v -> Period -> a -> SignedKES v a -> Either String ()
decodeVerKeyVRF :: VRFAlgorithm v => Decoder s (VerKeyVRF v)
encodeVerKeyVRF :: VRFAlgorithm v => VerKeyVRF v -> Encoding
hashVerKeyVRF :: (VRFAlgorithm v, HashAlgorithm h) => VerKeyVRF v -> Hash h (VerKeyVRF v)
verifyVRF :: (VRFAlgorithm v, HasCallStack, Signable v a) => ContextVRF v -> VerKeyVRF v -> a -> (OutputVRF v, CertVRF v) -> Bool
type CertifiedVRF c = CertifiedVRF (VRF c)
type Hash c = Hash (HASH c)
type SignedDSIGN c = SignedDSIGN (DSIGN c)
type SignKeyDSIGN c = SignKeyDSIGN (DSIGN c)
type SignedKES c = SignedKES (KES c)
type SignKeyKES c = SignKeyKES (KES c)
type SignKeyVRF c = SignKeyVRF (VRF c)
type VerKeyKES c = VerKeyKES (KES c)
type VerKeyVRF c = VerKeyVRF (VRF c)
instance GHC.Show.Show Cardano.Ledger.Keys.KeyRole
instance GHC.Generics.Generic (Cardano.Ledger.Keys.VKey kd crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Cardano.Ledger.Keys.KeyPair kd crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Keys.KeyPair kd crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Keys.KeyHash discriminator crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Keys.KeyHash discriminator crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Keys.KeyHash discriminator crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Keys.KeyHash discriminator crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Keys.KeyHash discriminator crypto)
instance GHC.Show.Show (Cardano.Ledger.Keys.KeyHash discriminator crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Cardano.Ledger.Keys.GKeys crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Keys.GKeys crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Keys.GKeys crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Ledger.Keys.GKeys crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Keys.GenDelegPair crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Keys.GenDelegPair crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Keys.GenDelegPair crypto)
instance GHC.Show.Show (Cardano.Ledger.Keys.GenDelegPair crypto)
instance GHC.Show.Show (Cardano.Ledger.Keys.GenDelegs crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Keys.GenDelegs crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Keys.GenDelegs crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Keys.GenDelegs crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Keys.GenDelegs crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Keys.GenDelegs crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Show.Show (Cardano.Ledger.Keys.VKey kd crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => GHC.Classes.Eq (Cardano.Ledger.Keys.VKey kd crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN (Cardano.Ledger.Crypto.DSIGN crypto))) => Control.DeepSeq.NFData (Cardano.Ledger.Keys.VKey kd crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Keys.VKey kd crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Data.Typeable.Internal.Typeable disc) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Keys.KeyHash disc crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Data.Typeable.Internal.Typeable disc) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Keys.KeyHash disc crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.Keys.KeyHash disc crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Ledger.Keys.KeyHash disc crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Keys.KeyHash disc crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Keys.KeyHash disc crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Keys.GenDelegs crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Keys.GenDelegPair crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Keys.GenDelegPair crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Keys.GenDelegPair crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Keys.GenDelegPair crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Keys.GenDelegPair crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Keys.GenDelegPair crypto)
instance Cardano.Ledger.Keys.HasKeyRole Cardano.Ledger.Keys.KeyHash
instance (Cardano.Ledger.Crypto.Crypto crypto, Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN (Cardano.Ledger.Crypto.DSIGN crypto)), Control.DeepSeq.NFData (Cardano.Crypto.DSIGN.Class.SignKeyDSIGN (Cardano.Ledger.Crypto.DSIGN crypto))) => Control.DeepSeq.NFData (Cardano.Ledger.Keys.KeyPair kd crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => NoThunks.Class.NoThunks (Cardano.Ledger.Keys.KeyPair kd crypto)
instance Cardano.Ledger.Keys.HasKeyRole Cardano.Ledger.Keys.KeyPair
instance Cardano.Ledger.Keys.HasKeyRole Cardano.Ledger.Keys.VKey
instance (Cardano.Ledger.Crypto.Crypto crypto, Data.Typeable.Internal.Typeable kd) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Keys.VKey kd crypto)
instance (Cardano.Ledger.Crypto.Crypto crypto, Data.Typeable.Internal.Typeable kd) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Keys.VKey kd crypto)


-- | The stake distribution, aggregated by stake pool (as opposed to stake
--   credential), plays a primary role in Cardano's proof of stake network.
--   Together with the VRF checks, the stake distribution determines leader
--   election. The leader election is the precisely the part of the ledger
--   that is determined by Ouroboros (Praos and Genesis), our consensus
--   mechanism. See Section 16, "Leader Value Calculation", of the
--   <a>formal specification</a>.
module Cardano.Ledger.PoolDistr

-- | The <a>IndividualPoolStake</a> contains all the stake controlled by a
--   single stake pool (the combination of owners and delegates) for a
--   given epoch, and also the hash of the stake pool's registered VRF key.
--   
--   When a stake pool produces a block, the header contains the full VRF
--   verification key and VRF value for leader election. We check the VRF
--   key against the value in <a>IndividualPoolStake</a> and we check the
--   VRF value using the epoch nonce and the relative stake of the pool as
--   given in <a>IndividualPoolStake</a>. The stake is relative to the
--   total amount of active stake in the network. Stake is active if it is
--   both registered and delegated to a registered stake pool.
data IndividualPoolStake crypto
IndividualPoolStake :: !Rational -> !Hash crypto (VerKeyVRF crypto) -> IndividualPoolStake crypto
[individualPoolStake] :: IndividualPoolStake crypto -> !Rational
[individualPoolStakeVrf] :: IndividualPoolStake crypto -> !Hash crypto (VerKeyVRF crypto)

-- | A map of stake pool IDs (the hash of the stake pool operator's
--   verification key) to <a>IndividualPoolStake</a>.
newtype PoolDistr crypto
PoolDistr :: Map (KeyHash 'StakePool crypto) (IndividualPoolStake crypto) -> PoolDistr crypto
[unPoolDistr] :: PoolDistr crypto -> Map (KeyHash 'StakePool crypto) (IndividualPoolStake crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.PoolDistr.IndividualPoolStake crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.PoolDistr.IndividualPoolStake crypto)
instance GHC.Generics.Generic (Cardano.Ledger.PoolDistr.IndividualPoolStake crypto)
instance GHC.Classes.Eq (Cardano.Ledger.PoolDistr.IndividualPoolStake crypto)
instance GHC.Show.Show (Cardano.Ledger.PoolDistr.IndividualPoolStake crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.PoolDistr.PoolDistr crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.PoolDistr.PoolDistr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.PoolDistr.PoolDistr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.PoolDistr.PoolDistr crypto)
instance GHC.Classes.Eq (Cardano.Ledger.PoolDistr.PoolDistr crypto)
instance GHC.Show.Show (Cardano.Ledger.PoolDistr.PoolDistr crypto)
instance Control.Iterate.Exp.HasExp (Cardano.Ledger.PoolDistr.PoolDistr crypto) (Data.Map.Internal.Map (Cardano.Ledger.Keys.KeyHash 'Cardano.Ledger.Keys.StakePool crypto) (Cardano.Ledger.PoolDistr.IndividualPoolStake crypto))
instance Control.Iterate.BaseTypes.Embed (Cardano.Ledger.PoolDistr.PoolDistr crypto) (Data.Map.Internal.Map (Cardano.Ledger.Keys.KeyHash 'Cardano.Ledger.Keys.StakePool crypto) (Cardano.Ledger.PoolDistr.IndividualPoolStake crypto))
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.PoolDistr.IndividualPoolStake crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.PoolDistr.IndividualPoolStake crypto)

module Cardano.Ledger.BaseTypes
data ProtVer
ProtVer :: !Natural -> !Natural -> ProtVer
[pvMajor] :: ProtVer -> !Natural
[pvMinor] :: ProtVer -> !Natural
type FixedPoint = Digits34
(==>) :: Bool -> Bool -> Bool
infix 1 ==>

-- | Evolve the nonce
(⭒) :: Nonce -> Nonce -> Nonce
data Network
Testnet :: Network
Mainnet :: Network
networkToWord8 :: Network -> Word8
word8ToNetwork :: Word8 -> Maybe Network

-- | Evolving nonce type.
data Nonce
Nonce :: !Hash Blake2b_256 Nonce -> Nonce

-- | Identity element
NeutralNonce :: Nonce

-- | Seed to the verifiable random function.
--   
--   We do not expose the constructor to <a>Seed</a>. Instead, a
--   <a>Seed</a> should be created using <tt>mkSeed</tt> for a VRF
--   calculation.
newtype Seed
Seed :: Hash Blake2b_256 Seed -> Seed

-- | Type to represent a value in the unit interval [0; 1]
data UnitInterval

-- | Type to represent a value in the unit interval (0; 1]
data PositiveUnitInterval

-- | Type to represent a value in the interval (0; +∞)
data PositiveInterval

-- | Type to represent a value in the interval [0; +∞)
data NonNegativeInterval

-- | Type clases that allows conversion between <a>Rational</a> and some
--   form of bounded rational type. Bounds can be restricted by both the
--   <a>Bounded</a> type class and underlyng representation.
--   
--   <pre>
--   maybe True (\br -&gt; minBound &lt;= br &amp;&amp; br &lt;= maxBound) . boundRational
--   </pre>
--   
--   Roundtrip properties must hold:
--   
--   <pre>
--   \r -&gt; maybe True ((r ==) . unboundRational) (boundRational r)
--   \br -&gt; Just br == boundRational (unboundRational br)
--   </pre>
class Bounded r => BoundedRational r

-- | Returns <a>Nothing</a> when supplied value is not within bounds or
--   when precision is too high to be represented by the underlying type
--   
--   <h3><b>Example</b></h3>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XTypeApplications
--   
--   &gt;&gt;&gt; import Data.Ratio
--   
--   &gt;&gt;&gt; boundRational @UnitInterval $ 2 % 3
--   Just (2 % 3)
--   
--   &gt;&gt;&gt; boundRational @UnitInterval (-0.5)
--   Nothing
--   
--   &gt;&gt;&gt; boundRational @UnitInterval (1.5)
--   Nothing
--   
--   &gt;&gt;&gt; boundRational @UnitInterval 0
--   Just (0 % 1)
--   
--   &gt;&gt;&gt; boundRational @PositiveUnitInterval 0
--   Nothing
--   </pre>
boundRational :: BoundedRational r => Rational -> Maybe r

-- | Promote bounded rational type into the unbounded <a>Rational</a>.
unboundRational :: BoundedRational r => r -> Rational

-- | Deserialize <a>BoundedRational</a> type using <a>Rational</a>
--   deserialization and fail when bounds are violated.
boundedRationalFromCBOR :: BoundedRational r => Decoder s r

-- | Serialize <a>BoundedRational</a> type in the same way <a>Rational</a>
--   is serialized.
boundedRationalToCBOR :: BoundedRational r => r -> Encoding
fpPrecision :: FixedPoint
promoteRatio :: Integral a => Ratio a -> Rational
invalidKey :: Word -> Decoder s a

-- | Make a nonce from the VRF output bytes
mkNonceFromOutputVRF :: OutputVRF v -> Nonce

-- | Make a nonce from a number.
mkNonceFromNumber :: Word64 -> Nonce
data Url
urlToText :: Url -> Text
textToUrl :: Text -> Maybe Url
data DnsName
dnsToText :: DnsName -> Text
textToDns :: Text -> Maybe DnsName
newtype Port
Port :: Word16 -> Port
[portToWord16] :: Port -> Word16
data ActiveSlotCoeff
mkActiveSlotCoeff :: PositiveUnitInterval -> ActiveSlotCoeff
activeSlotVal :: ActiveSlotCoeff -> PositiveUnitInterval
activeSlotLog :: ActiveSlotCoeff -> FixedPoint

-- | Blocks made
newtype BlocksMade crypto
BlocksMade :: Map (KeyHash 'StakePool crypto) Natural -> BlocksMade crypto
[unBlocksMade] :: BlocksMade crypto -> Map (KeyHash 'StakePool crypto) Natural

-- | Transaction index.
newtype TxIx
TxIx :: Word64 -> TxIx
txIxToInt :: TxIx -> Int
txIxFromIntegral :: Integral a => a -> Maybe TxIx

-- | Construct a <a>TxIx</a> from an arbitrary precision <a>Integer</a>.
--   Throws an error for values out of range. Make sure to use it only for
--   testing.
mkTxIxPartial :: HasCallStack => Integer -> TxIx

-- | Certificate index. Use <a>certIxFromIntegral</a> in order to construct
--   this index safely from anything other than <a>Word16</a>. There is
--   also <a>mkCertIxPartial</a> that can be used for testing.
newtype CertIx
CertIx :: Word64 -> CertIx
certIxToInt :: CertIx -> Int
certIxFromIntegral :: Integral a => a -> Maybe CertIx

-- | Construct a <a>CertIx</a> from an arbitrary precision <a>Integer</a>.
--   Throws an error for values out of range. Make sure to use it only for
--   testing.
mkCertIxPartial :: HasCallStack => Integer -> CertIx
data Globals
Globals :: !EpochInfo (Either Text) -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Word64 -> !Natural -> !Word64 -> !ActiveSlotCoeff -> !Network -> !SystemStart -> Globals
[epochInfo] :: Globals -> !EpochInfo (Either Text)
[slotsPerKESPeriod] :: Globals -> !Word64

-- | The window size in which our chosen chain growth property guarantees
--   at least k blocks. From the paper "Ouroboros praos: An
--   adaptively-secure, semi-synchronous proof-of-stake protocol". The
--   <a>stabilityWindow</a> constant is used in a number of places; for
--   example, protocol updates must be submitted at least twice this many
--   slots before an epoch boundary.
[stabilityWindow] :: Globals -> !Word64

-- | Number of slots before the end of the epoch at which we stop updating
--   the candidate nonce for the next epoch.
[randomnessStabilisationWindow] :: Globals -> !Word64

-- | Maximum number of blocks we are allowed to roll back
[securityParameter] :: Globals -> !Word64

-- | Maximum number of KES iterations
[maxKESEvo] :: Globals -> !Word64

-- | Quorum for update system votes and MIR certificates
[quorum] :: Globals -> !Word64

-- | All blocks invalid after this protocol version
[maxMajorPV] :: Globals -> !Natural

-- | Maximum number of lovelace in the system
[maxLovelaceSupply] :: Globals -> !Word64

-- | Active Slot Coefficient, named f in "Ouroboros Praos: An
--   adaptively-secure, semi-synchronous proof-of-stake protocol"
[activeSlotCoeff] :: Globals -> !ActiveSlotCoeff

-- | The network ID
[networkId] :: Globals -> !Network

-- | System start time
[systemStart] :: Globals -> !SystemStart

-- | Pure epoch info via throw. Note that this should only be used when we
--   can guarantee the validity of the translation; in particular, the
--   <a>EpochInfo</a> used here should never be applied to user-supplied
--   input.
epochInfoPure :: Globals -> EpochInfo Identity
type ShelleyBase = ReaderT Globals Identity
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.ProtVer
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.ProtVer
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.ProtVer
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.ProtVer
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.ProtVer
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.ProtVer
instance GHC.Show.Show Cardano.Ledger.BaseTypes.ProtVer
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance GHC.Show.Show a => GHC.Show.Show (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance GHC.Generics.Generic (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.NonNegativeInterval
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Cardano.Ledger.BaseTypes.BoundedRational Cardano.Ledger.BaseTypes.NonNegativeInterval
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.NonNegativeInterval
instance GHC.Show.Show Cardano.Ledger.BaseTypes.NonNegativeInterval
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.NonNegativeInterval
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.NonNegativeInterval
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.NonNegativeInterval
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.PositiveInterval
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.PositiveInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.PositiveInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.PositiveInterval
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.PositiveInterval
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.PositiveInterval
instance Cardano.Ledger.BaseTypes.BoundedRational Cardano.Ledger.BaseTypes.PositiveInterval
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.PositiveInterval
instance GHC.Show.Show Cardano.Ledger.BaseTypes.PositiveInterval
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.PositiveInterval
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.PositiveInterval
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.PositiveInterval
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Cardano.Ledger.BaseTypes.BoundedRational Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance GHC.Show.Show Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.PositiveUnitInterval
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.UnitInterval
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.UnitInterval
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.UnitInterval
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.UnitInterval
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.UnitInterval
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.UnitInterval
instance Cardano.Ledger.BaseTypes.BoundedRational Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Show.Show Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.UnitInterval
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.Nonce
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Nonce
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.Nonce
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Nonce
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.Nonce
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.Seed
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Seed
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Seed
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Seed
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.Seed
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.Seed
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.Url
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.Url
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Url
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.Url
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.Url
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Url
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Url
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.Url
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.Url
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.DnsName
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.DnsName
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.DnsName
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.DnsName
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.DnsName
instance GHC.Show.Show Cardano.Ledger.BaseTypes.DnsName
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.DnsName
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.DnsName
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.DnsName
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.Port
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.Port
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Port
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.Port
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.Port
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.Port
instance GHC.Num.Num Cardano.Ledger.BaseTypes.Port
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Port
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Port
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.Port
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.Port
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance GHC.Show.Show Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Network
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.Network
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.Network
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.Network
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Network
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Network
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.Network
instance GHC.Enum.Enum Cardano.Ledger.BaseTypes.Network
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.Network
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.Network
instance GHC.Generics.Generic Cardano.Ledger.BaseTypes.Globals
instance GHC.Show.Show Cardano.Ledger.BaseTypes.Globals
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.BaseTypes.BlocksMade crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.BaseTypes.BlocksMade crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.BaseTypes.BlocksMade crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.BaseTypes.BlocksMade crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.BaseTypes.BlocksMade crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.BaseTypes.BlocksMade crypto)
instance GHC.Show.Show (Cardano.Ledger.BaseTypes.BlocksMade crypto)
instance GHC.Generics.Generic (Cardano.Ledger.BaseTypes.BlocksMade crypto)
instance GHC.Classes.Eq (Cardano.Ledger.BaseTypes.BlocksMade crypto)
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.TxIx
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.TxIx
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.TxIx
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.TxIx
instance GHC.Enum.Enum Cardano.Ledger.BaseTypes.TxIx
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.TxIx
instance GHC.Show.Show Cardano.Ledger.BaseTypes.TxIx
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.TxIx
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.TxIx
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.CertIx
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.CertIx
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.CertIx
instance GHC.Enum.Bounded Cardano.Ledger.BaseTypes.CertIx
instance GHC.Enum.Enum Cardano.Ledger.BaseTypes.CertIx
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.CertIx
instance GHC.Show.Show Cardano.Ledger.BaseTypes.CertIx
instance GHC.Classes.Ord Cardano.Ledger.BaseTypes.CertIx
instance GHC.Classes.Eq Cardano.Ledger.BaseTypes.CertIx
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.Nonce
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.Nonce
instance GHC.Show.Show Cardano.Ledger.BaseTypes.EpochErr
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Globals
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.Network
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.Network
instance GHC.Exception.Type.Exception Cardano.Ledger.BaseTypes.EpochErr
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance Control.DeepSeq.NFData Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.ActiveSlotCoeff
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.DnsName
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.Url
instance Cardano.Crypto.Util.SignableRepresentation Cardano.Ledger.BaseTypes.Seed
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.Nonce
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.BaseTypes.Nonce
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.BaseTypes.Nonce
instance GHC.Real.Integral a => GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio Cardano.Ledger.BaseTypes.UnitInterval a)
instance Data.Default.Class.Default Cardano.Ledger.BaseTypes.UnitInterval
instance GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio Cardano.Ledger.BaseTypes.PositiveUnitInterval GHC.Word.Word64)
instance GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio Cardano.Ledger.BaseTypes.PositiveInterval GHC.Word.Word64)
instance GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio Cardano.Ledger.BaseTypes.NonNegativeInterval GHC.Word.Word64)
instance (GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio b a), GHC.Enum.Bounded a, GHC.Real.Integral a) => Cardano.Ledger.BaseTypes.BoundedRational (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance GHC.Real.Integral a => GHC.Classes.Ord (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance (Cardano.Binary.ToCBOR.ToCBOR a, GHC.Real.Integral a, GHC.Enum.Bounded a, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable a) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance (Cardano.Binary.FromCBOR.FromCBOR a, GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio b a), GHC.Enum.Bounded a, GHC.Real.Integral a, Data.Typeable.Internal.Typeable b, Data.Typeable.Internal.Typeable a, GHC.Show.Show a) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.BaseTypes.BoundedRatio b a)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.BaseTypes.BoundedRatio b GHC.Word.Word64)
instance GHC.Enum.Bounded (Cardano.Ledger.BaseTypes.BoundedRatio b GHC.Word.Word64) => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.BaseTypes.BoundedRatio b GHC.Word.Word64)
instance Data.Fixed.HasResolution Cardano.Ledger.BaseTypes.E34
instance NoThunks.Class.NoThunks Cardano.Ledger.BaseTypes.ProtVer
instance Data.Aeson.Types.ToJSON.ToJSON Cardano.Ledger.BaseTypes.ProtVer
instance Data.Aeson.Types.FromJSON.FromJSON Cardano.Ledger.BaseTypes.ProtVer
instance Cardano.Ledger.Serialization.ToCBORGroup Cardano.Ledger.BaseTypes.ProtVer
instance Cardano.Ledger.Serialization.FromCBORGroup Cardano.Ledger.BaseTypes.ProtVer

module Cardano.Ledger.AuxiliaryData
newtype AuxiliaryDataHash crypto
AuxiliaryDataHash :: SafeHash crypto EraIndependentAuxiliaryData -> AuxiliaryDataHash crypto
[unsafeAuxiliaryDataHash] :: AuxiliaryDataHash crypto -> SafeHash crypto EraIndependentAuxiliaryData
class ValidateAuxiliaryData era c | era -> c
hashAuxiliaryData :: ValidateAuxiliaryData era c => AuxiliaryData era -> AuxiliaryDataHash c
validateAuxiliaryData :: ValidateAuxiliaryData era c => ProtVer -> AuxiliaryData era -> Bool
instance Control.DeepSeq.NFData (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto)
instance GHC.Classes.Ord (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto)
instance GHC.Classes.Eq (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto)
instance GHC.Show.Show (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.AuxiliaryData.AuxiliaryDataHash crypto)

module Cardano.Ledger.Slot

-- | The 0-based index for the Ourboros time slot.
newtype SlotNo
SlotNo :: Word64 -> SlotNo
[unSlotNo] :: SlotNo -> Word64
newtype Duration
Duration :: Word64 -> Duration
[unDuration] :: Duration -> Word64
(-*) :: SlotNo -> SlotNo -> Duration
(+*) :: SlotNo -> Duration -> SlotNo

-- | Subtract a duration from a slot
(*-) :: SlotNo -> Duration -> SlotNo

-- | An epoch, i.e. the number of the epoch.
newtype EpochNo
EpochNo :: Word64 -> EpochNo
[unEpochNo] :: EpochNo -> Word64
newtype EpochSize
EpochSize :: Word64 -> EpochSize
[unEpochSize] :: EpochSize -> Word64

-- | Information about epochs
--   
--   Different epochs may have different sizes and different slot lengths.
--   This information is encapsulated by <a>EpochInfo</a>. It is
--   parameterized over a monad <tt>m</tt> because the information about
--   how long each epoch is may depend on information derived from the
--   blockchain itself. It ultimately requires acess to state, and so
--   either uses the monad for that or uses the monad to reify failure due
--   to cached state information being too stale for the current query.
data EpochInfo (m :: Type -> Type)

-- | The 0-based index of the block in the blockchain. BlockNo is &lt;=
--   SlotNo and is only equal at slot N if there is a block for every slot
--   where N &lt;= SlotNo.
newtype BlockNo
BlockNo :: Word64 -> BlockNo
[unBlockNo] :: BlockNo -> Word64
epochInfoEpoch :: HasCallStack => EpochInfo Identity -> SlotNo -> ShelleyBase EpochNo
epochInfoFirst :: HasCallStack => EpochInfo Identity -> EpochNo -> ShelleyBase SlotNo
epochInfoSize :: HasCallStack => EpochInfo Identity -> EpochNo -> ShelleyBase EpochSize
instance GHC.Show.Show Cardano.Ledger.Slot.Duration
instance GHC.Enum.Enum Cardano.Ledger.Slot.Duration
instance GHC.Real.Real Cardano.Ledger.Slot.Duration
instance GHC.Real.Integral Cardano.Ledger.Slot.Duration
instance GHC.Num.Num Cardano.Ledger.Slot.Duration
instance NoThunks.Class.NoThunks Cardano.Ledger.Slot.Duration
instance GHC.Classes.Ord Cardano.Ledger.Slot.Duration
instance GHC.Generics.Generic Cardano.Ledger.Slot.Duration
instance GHC.Classes.Eq Cardano.Ledger.Slot.Duration
instance GHC.Base.Semigroup Cardano.Ledger.Slot.Duration
instance GHC.Base.Monoid Cardano.Ledger.Slot.Duration

module Cardano.Ledger.Credential

-- | Script hash or key hash for a payment or a staking object.
--   
--   Note that credentials (unlike raw key hashes) do appear to vary from
--   era to era, since they reference the hash of a script, which can
--   change. This parameter is a phantom, however, so in actuality the
--   instances will remain the same.
data Credential (kr :: KeyRole) crypto
ScriptHashObj :: !ScriptHash crypto -> Credential (kr :: KeyRole) crypto
KeyHashObj :: !KeyHash kr crypto -> Credential (kr :: KeyRole) crypto
newtype GenesisCredential crypto
GenesisCredential :: KeyHash 'Genesis crypto -> GenesisCredential crypto
[unGenesisCredential] :: GenesisCredential crypto -> KeyHash 'Genesis crypto
type PaymentCredential crypto = Credential 'Payment crypto

-- | Pointer to a slot number, transaction index and an index in
--   certificate list.
data Ptr
Ptr :: !SlotNo -> !TxIx -> !CertIx -> Ptr
ptrSlotNo :: Ptr -> SlotNo
ptrTxIx :: Ptr -> TxIx
ptrCertIx :: Ptr -> CertIx
type StakeCredential crypto = Credential 'Staking crypto
data StakeReference crypto
StakeRefBase :: !StakeCredential crypto -> StakeReference crypto
StakeRefPtr :: !Ptr -> StakeReference crypto
StakeRefNull :: StakeReference crypto
instance GHC.Classes.Ord (Cardano.Ledger.Credential.Credential kr crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Credential.Credential kr crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Credential.Credential kr crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Credential.Credential kr crypto)
instance GHC.Show.Show (Cardano.Ledger.Credential.Credential kr crypto)
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Ledger.Credential.Ptr
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Ledger.Credential.Ptr
instance NoThunks.Class.NoThunks Cardano.Ledger.Credential.Ptr
instance Control.DeepSeq.NFData Cardano.Ledger.Credential.Ptr
instance GHC.Generics.Generic Cardano.Ledger.Credential.Ptr
instance GHC.Classes.Ord Cardano.Ledger.Credential.Ptr
instance GHC.Classes.Eq Cardano.Ledger.Credential.Ptr
instance GHC.Classes.Ord (Cardano.Ledger.Credential.StakeReference crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Credential.StakeReference crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Credential.StakeReference crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Credential.StakeReference crypto)
instance GHC.Show.Show (Cardano.Ledger.Credential.StakeReference crypto)
instance GHC.Show.Show (Cardano.Ledger.Credential.GenesisCredential crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Credential.GenesisCredential crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Credential.GenesisCredential crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Credential.GenesisCredential crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Credential.GenesisCredential crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Credential.StakeReference crypto)
instance GHC.Show.Show Cardano.Ledger.Credential.Ptr
instance Cardano.Ledger.Serialization.ToCBORGroup Cardano.Ledger.Credential.Ptr
instance Cardano.Ledger.Serialization.FromCBORGroup Cardano.Ledger.Credential.Ptr
instance Cardano.Ledger.Keys.HasKeyRole Cardano.Ledger.Credential.Credential
instance NoThunks.Class.NoThunks (Cardano.Ledger.Credential.Credential kr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Credential.Credential kr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Credential.Credential kr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.Credential.Credential kr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Ledger.Credential.Credential kr crypto)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto crypto) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Credential.Credential kr crypto)
instance (Data.Typeable.Internal.Typeable kr, Cardano.Ledger.Crypto.Crypto crypto) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Credential.Credential kr crypto)

module Cardano.Ledger.BHeaderView

-- | <a>BHeaderView</a> provides an interface between block headers from
--   different Cardano protocols and packages that should be agnostic of
--   Cardano protocol specific details, such as those in TPraos, Praos,
--   Genesis, etc.
--   
--   In particular, the <tt>BBODY</tt> rule comprises most of the ledger
--   logic and should work independently of the protocol. The values in
--   <a>BHeaderView</a> provide <tt>BBODY</tt> all the data that it needs
--   from the block headers.
data BHeaderView crypto
BHeaderView :: KeyHash 'BlockIssuer crypto -> Natural -> Int -> Hash crypto EraIndependentBlockBody -> SlotNo -> BHeaderView crypto

-- | The block issuer. In the TPraos protocol, this can be a Genesis
--   delegate, everywhere else it is the stake pool ID.
[bhviewID] :: BHeaderView crypto -> KeyHash 'BlockIssuer crypto

-- | The purported size (in bytes) of the block body.
[bhviewBSize] :: BHeaderView crypto -> Natural

-- | The purported size (in bytes) of the block header.
[bhviewHSize] :: BHeaderView crypto -> Int

-- | The purported hash of the block body.
[bhviewBHash] :: BHeaderView crypto -> Hash crypto EraIndependentBlockBody

-- | The slot for which this block was submitted to the chain.
[bhviewSlot] :: BHeaderView crypto -> SlotNo

-- | Determine if the given slot is reserved for the overlay schedule.
isOverlaySlot :: SlotNo -> UnitInterval -> SlotNo -> Bool

module Cardano.Ledger.Address
mkVKeyRwdAcnt :: Crypto crypto => Network -> KeyPair 'Staking crypto -> RewardAcnt crypto
mkRwdAcnt :: Network -> Credential 'Staking crypto -> RewardAcnt crypto
toAddr :: Crypto crypto => Network -> (KeyPair 'Payment crypto, KeyPair 'Staking crypto) -> Addr crypto
toCred :: Crypto crypto => KeyPair kr crypto -> Credential kr crypto

-- | Serialise an address to the external format.
serialiseAddr :: Addr crypto -> ByteString

-- | Deserialise an address from the external format. This will fail if the
--   input data is not in the right format (or if there is trailing data).
deserialiseAddr :: Crypto crypto => ByteString -> Maybe (Addr crypto)

-- | Deserialise a stake refence from a address. This will fail if this is
--   a Bootstrap address (or malformed).
deserialiseAddrStakeRef :: Crypto crypto => ByteString -> Maybe (StakeReference crypto)

-- | An address for UTxO.
--   
--   Contents of Addr data type are intentionally left as lazy, otherwise
--   operating on compact form of an address will result in redundant work.
data Addr crypto
Addr :: Network -> PaymentCredential crypto -> StakeReference crypto -> Addr crypto
AddrBootstrap :: BootstrapAddress crypto -> Addr crypto
newtype BootstrapAddress crypto
BootstrapAddress :: Address -> BootstrapAddress crypto
[unBootstrapAddress] :: BootstrapAddress crypto -> Address

-- | The size of the extra attributes in a bootstrp (ie Byron) address.
--   Used to help enforce that people do not post huge ones on the chain.
bootstrapAddressAttrsSize :: BootstrapAddress crypto -> Int

-- | Return True if a given address is a redeemer address from the Byron
--   Era
isBootstrapRedeemer :: BootstrapAddress crypto -> Bool
getNetwork :: Addr crypto -> Network

-- | An account based address for rewards
data RewardAcnt crypto
RewardAcnt :: !Network -> !Credential 'Staking crypto -> RewardAcnt crypto
[getRwdNetwork] :: RewardAcnt crypto -> !Network
[getRwdCred] :: RewardAcnt crypto -> !Credential 'Staking crypto

-- | Serialise a reward account to the external format.
serialiseRewardAcnt :: RewardAcnt crypto -> ByteString

-- | Deserialise an reward account from the external format. This will fail
--   if the input data is not in the right format (or if there is trailing
--   data).
deserialiseRewardAcnt :: Crypto crypto => ByteString -> Maybe (RewardAcnt crypto)
byron :: Int
notBaseAddr :: Int
isEnterpriseAddr :: Int
stakeCredIsScript :: Int
getAddr :: Crypto crypto => Get (Addr crypto)
getKeyHash :: Crypto crypto => Get (Credential kr crypto)
bootstrapKeyHash :: forall crypto. Crypto crypto => BootstrapAddress crypto -> KeyHash 'Payment crypto
getPtr :: Get Ptr
getRewardAcnt :: Crypto crypto => Get (RewardAcnt crypto)
getScriptHash :: Crypto crypto => Get (Credential kr crypto)
getVariableLengthWord64 :: Get Word64
payCredIsScript :: Int
putAddr :: Addr crypto -> Put
putCredential :: Credential kr crypto -> Put
putPtr :: Ptr -> Put
putRewardAcnt :: RewardAcnt crypto -> Put
putVariableLengthWord64 :: Word64 -> Put
word64ToWord7s :: Word64 -> [Word7]
word7sToWord64 :: [Word7] -> Word64
newtype Word7
Word7 :: Word8 -> Word7
toWord7 :: Word8 -> Word7
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Ledger.Address.RewardAcnt crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.Address.RewardAcnt crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Address.RewardAcnt crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Address.RewardAcnt crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Address.RewardAcnt crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Address.RewardAcnt crypto)
instance GHC.Show.Show (Cardano.Ledger.Address.RewardAcnt crypto)
instance GHC.Show.Show Cardano.Ledger.Address.Word7
instance GHC.Classes.Eq Cardano.Ledger.Address.Word7
instance GHC.Show.Show (Cardano.Ledger.Address.BootstrapAddress crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Address.BootstrapAddress crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Address.BootstrapAddress crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Address.BootstrapAddress crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Address.BootstrapAddress crypto)
instance GHC.Classes.Ord (Cardano.Ledger.Address.Addr crypto)
instance Control.DeepSeq.NFData (Cardano.Ledger.Address.Addr crypto)
instance GHC.Generics.Generic (Cardano.Ledger.Address.Addr crypto)
instance GHC.Classes.Eq (Cardano.Ledger.Address.Addr crypto)
instance GHC.Show.Show (Cardano.Ledger.Address.Addr crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Address.Addr crypto)
instance Data.Aeson.Types.ToJSON.ToJSONKey (Cardano.Ledger.Address.Addr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSONKey (Cardano.Ledger.Address.Addr crypto)
instance Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Address.Addr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Address.Addr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Address.Addr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Address.Addr crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Address.BootstrapAddress crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.ToJSON.ToJSON (Cardano.Ledger.Address.RewardAcnt crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Data.Aeson.Types.FromJSON.FromJSON (Cardano.Ledger.Address.RewardAcnt crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.Address.RewardAcnt crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Address.RewardAcnt crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.Address.RewardAcnt crypto)

module Cardano.Ledger.CompactAddress
compactAddr :: Addr crypto -> CompactAddr crypto
decompactAddr :: forall crypto. Crypto crypto => CompactAddr crypto -> Addr crypto
newtype CompactAddr crypto
UnsafeCompactAddr :: ShortByteString -> CompactAddr crypto
substring :: ShortByteString -> Int -> Int -> ShortByteString

-- | Efficiently check whether compated adddress is an address with a
--   credential that is a payment script.
isPayCredScriptCompactAddr :: CompactAddr crypto -> Bool

-- | Efficiently check whether compated adddress is a Byron address.
isBootstrapCompactAddr :: CompactAddr crypto -> Bool
decodeAddr :: forall crypto m. (Crypto crypto, MonadFail m) => ByteString -> m (Addr crypto)
decodeAddrShort :: forall crypto m. (Crypto crypto, MonadFail m) => ShortByteString -> m (Addr crypto)
decodeAddrEither :: forall crypto. Crypto crypto => ByteString -> Either String (Addr crypto)
decodeAddrShortEither :: forall crypto. Crypto crypto => ShortByteString -> Either String (Addr crypto)
fromCborAddr :: forall crypto s. Crypto crypto => Decoder s (Addr crypto)
fromCborBothAddr :: forall crypto s. Crypto crypto => Decoder s (Addr crypto, CompactAddr crypto)
fromCborCompactAddr :: forall crypto s. Crypto crypto => Decoder s (CompactAddr crypto)
fromCborBackwardsBothAddr :: forall crypto s. Crypto crypto => Decoder s (Addr crypto, CompactAddr crypto)
decodeRewardAcnt :: forall crypto b m. (Crypto crypto, AddressBuffer b, MonadFail m) => b -> m (RewardAcnt crypto)
fromCborRewardAcnt :: forall crypto s. Crypto crypto => Decoder s (RewardAcnt crypto)
fromCborCompactAddrOld :: forall s crypto. Crypto crypto => Decoder s (CompactAddr crypto)

-- | This lazy deserializer is kept around purely for benchmarking, so we
--   can verify that new deserializer <a>decodeAddrStateT</a> is doing the
--   work lazily.
decompactAddrLazy :: forall crypto. Crypto crypto => CompactAddr crypto -> Addr crypto
instance Control.DeepSeq.NFData (Cardano.Ledger.CompactAddress.CompactAddr crypto)
instance GHC.Classes.Ord (Cardano.Ledger.CompactAddress.CompactAddr crypto)
instance GHC.Classes.Eq (Cardano.Ledger.CompactAddress.CompactAddr crypto)
instance GHC.Num.Num Cardano.Ledger.CompactAddress.Header
instance Data.Bits.Bits Cardano.Ledger.CompactAddress.Header
instance GHC.Classes.Ord Cardano.Ledger.CompactAddress.Header
instance GHC.Classes.Eq Cardano.Ledger.CompactAddress.Header
instance GHC.Base.Monad Cardano.Ledger.CompactAddress.Fail
instance GHC.Base.Applicative Cardano.Ledger.CompactAddress.Fail
instance GHC.Base.Functor Cardano.Ledger.CompactAddress.Fail
instance GHC.Base.Functor Cardano.Ledger.CompactAddress.GetShort
instance GHC.Base.Applicative Cardano.Ledger.CompactAddress.GetShort
instance GHC.Base.Monad Cardano.Ledger.CompactAddress.GetShort
instance Control.Monad.Fail.MonadFail Cardano.Ledger.CompactAddress.GetShort
instance Control.Monad.Fail.MonadFail Cardano.Ledger.CompactAddress.Fail
instance GHC.Show.Show Cardano.Ledger.CompactAddress.Header
instance Cardano.Ledger.CompactAddress.AddressBuffer Data.ByteString.Short.Internal.ShortByteString
instance Cardano.Ledger.CompactAddress.AddressBuffer Data.ByteString.Internal.ByteString
instance Cardano.Ledger.Crypto.Crypto c => GHC.Show.Show (Cardano.Ledger.CompactAddress.CompactAddr c)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.CompactAddress.CompactAddr crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.CompactAddress.CompactAddr crypto)

module Cardano.Ledger.TxIn

-- | A unique ID of a transaction, which is computable from the
--   transaction.
newtype TxId crypto
TxId :: SafeHash crypto EraIndependentTxBody -> TxId crypto
[_unTxId] :: TxId crypto -> SafeHash crypto EraIndependentTxBody

-- | The input of a UTxO.
data TxIn crypto
TxIn :: !TxId crypto -> {-# UNPACK #-} !TxIx -> TxIn crypto

-- | Construct <a>TxIn</a> while throwing an error for an out of range
--   <a>TxIx</a>. Make sure to use it only for testing.
mkTxInPartial :: HasCallStack => TxId crypto -> Integer -> TxIn crypto

-- | Transaction index.
data TxIx

-- | Compute the id of a transaction.
txid :: forall era c. (HashAlgorithm (HASH c), HashAnnotated (TxBody era) EraIndependentTxBody c) => TxBody era -> TxId c
instance Cardano.Prelude.HeapWords.HeapWords (Cardano.Ledger.TxIn.TxId crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.TxIn.TxId crypto)
instance GHC.Generics.Generic (Cardano.Ledger.TxIn.TxId crypto)
instance GHC.Classes.Ord (Cardano.Ledger.TxIn.TxId crypto)
instance GHC.Classes.Eq (Cardano.Ledger.TxIn.TxId crypto)
instance GHC.Show.Show (Cardano.Ledger.TxIn.TxId crypto)
instance GHC.Generics.Generic (Cardano.Ledger.TxIn.TxIn crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.TxIn.TxId crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.TxIn.TxId crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Control.DeepSeq.NFData (Cardano.Ledger.TxIn.TxId crypto)
instance GHC.Classes.Eq (Cardano.Ledger.TxIn.TxIn crypto)
instance GHC.Classes.Ord (Cardano.Ledger.TxIn.TxIn crypto)
instance GHC.Show.Show (Cardano.Ledger.TxIn.TxIn crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Control.DeepSeq.NFData (Cardano.Ledger.TxIn.TxIn crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Prelude.HeapWords.HeapWords (Cardano.Ledger.TxIn.TxIn crypto)
instance NoThunks.Class.NoThunks (Cardano.Ledger.TxIn.TxIn crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.TxIn.TxIn crypto)
instance Cardano.Ledger.Crypto.Crypto crypto => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Ledger.TxIn.TxIn crypto)


-- | A Monomorphic version of UMap specialized to the needs of Cardano
module Cardano.Ledger.UnifiedMap
type ViewMap crypto = View Coin (Credential 'Staking crypto) (KeyHash 'StakePool crypto) Ptr
type UnifiedMap crypto = UMap Coin (Credential 'Staking crypto) (KeyHash 'StakePool crypto) Ptr
type Triple crypto = Trip Coin Ptr (KeyHash 'StakePool crypto)
data View coin cr pl ptr k v
[Rewards] :: forall coin cr pl ptr. !UMap coin cr pl ptr -> View coin cr pl ptr cr coin
[Delegations] :: forall coin cr pl ptr. !UMap coin cr pl ptr -> View coin cr pl ptr cr pl
[Ptrs] :: forall coin cr pl ptr. !UMap coin cr pl ptr -> View coin cr pl ptr ptr cr
data UMap coin cred pool ptr
UnifiedMap :: !Map cred (Trip coin ptr pool) -> !Map ptr cred -> UMap coin cred pool ptr
data Trip coin ptr pool
pattern Triple :: StrictMaybe coin -> Set ptr -> StrictMaybe pool -> Trip coin ptr pool
class UnifiedView coin cred pool ptr k v
tag :: UnifiedView coin cred pool ptr k v => Tag coin cred pool ptr k v
data Tag coin cred pool ptr k v
[Rew] :: forall coin cred pool ptr. Tag coin cred pool ptr cred coin
[Del] :: forall coin cred pool ptr. Tag coin cred pool ptr cred pool
[Ptr] :: forall coin cred pool ptr. Tag coin cred pool ptr ptr cred
instance Data.UMap.UnifiedView Cardano.Ledger.Coin.Coin (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking crypto) (Cardano.Ledger.Keys.KeyHash 'Cardano.Ledger.Keys.StakePool crypto) Cardano.Ledger.Credential.Ptr (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking crypto) Cardano.Ledger.Coin.Coin
instance Data.UMap.UnifiedView Cardano.Ledger.Coin.Coin (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking crypto) (Cardano.Ledger.Keys.KeyHash 'Cardano.Ledger.Keys.StakePool crypto) Cardano.Ledger.Credential.Ptr (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking crypto) (Cardano.Ledger.Keys.KeyHash 'Cardano.Ledger.Keys.StakePool crypto)
instance Data.UMap.UnifiedView Cardano.Ledger.Coin.Coin (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking crypto) (Cardano.Ledger.Keys.KeyHash 'Cardano.Ledger.Keys.StakePool crypto) Cardano.Ledger.Credential.Ptr Cardano.Ledger.Credential.Ptr (Cardano.Ledger.Credential.Credential 'Cardano.Ledger.Keys.Staking crypto)


-- | This module defines a generalised notion of a "value" - that is,
--   something with which we may quantify a transaction output.
module Cardano.Ledger.Val
class (Abelian t, Eq t) => Val t

-- | the value with nothing in it
zero :: Val t => t

-- | add two value
(<+>) :: Val t => t -> t -> t

-- | scale a value by an Integral constant
(<×>) :: (Val t, Integral i) => i -> t -> t

-- | subtract two values
(<->) :: Val t => t -> t -> t

-- | Is the argument zero?
isZero :: Val t => t -> Bool

-- | Get the ADA present in the value (since ADA is our "blessed" currency)
coin :: Val t => t -> Coin

-- | Create a value containing only this amount of ADA
inject :: Val t => Coin -> t

-- | modify the blessed Coin part of t
modifyCoin :: Val t => (Coin -> Coin) -> t -> t
size :: Val t => t -> Integer

-- | used to compare values pointwise. Rather than using: (v1 &lt;= v2)
--   use: pointwise (&lt;=) v1 v2 | If a quantity is stored in only one of
--   <tt>v1</tt> or <tt>v2</tt>, we use 0 for the missing quantity.
pointwise :: Val t => (Integer -> Integer -> Bool) -> t -> t -> Bool

-- | Check if value contains only ADA. Must hold property:
--   
--   <pre>
--   inject (coin v) == v
--   </pre>
isAdaOnly :: Val t => t -> Bool
isAdaOnlyCompact :: Val t => CompactForm t -> Bool
injectCompact :: Val t => CompactForm Coin -> CompactForm t
infixl 6 <+>
infixl 7 <×>
infixl 6 <->
scale :: (Val t, Integral i) => i -> t -> t
invert :: Val t => t -> t
sumVal :: (Foldable t, Val v) => t v -> v

-- | <i>Deprecated: In favor of <a>isAdaOnly</a></i>
adaOnly :: Val v => v -> Bool
class DecodeNonNegative v
decodeNonNegative :: DecodeNonNegative v => Decoder s v
class DecodeMint v
decodeMint :: DecodeMint v => Decoder s v
class EncodeMint v
encodeMint :: EncodeMint v => v -> Encoding
instance Cardano.Ledger.Val.EncodeMint Cardano.Ledger.Coin.Coin
instance Cardano.Ledger.Val.DecodeMint Cardano.Ledger.Coin.Coin
instance Cardano.Ledger.Val.DecodeNonNegative Cardano.Ledger.Coin.Coin
instance (Cardano.Ledger.Val.DecodeNonNegative a, Cardano.Ledger.Compactible.Compactible a, GHC.Show.Show a) => Cardano.Ledger.Val.DecodeNonNegative (Cardano.Ledger.Compactible.CompactForm a)
instance Cardano.Ledger.Val.Val Cardano.Ledger.Coin.Coin
instance Cardano.Ledger.Val.Val Cardano.Ledger.Coin.DeltaCoin


-- | Support for multiple (Shelley-based) eras in the ledger.
module Cardano.Ledger.Era
class (Crypto (Crypto e), Typeable e, WellFormed e) => Era e where {
    type family Crypto e :: Type;
}

-- | Extract from TxOut either an address or its compact version by doing
--   the least amount of work.
--   
--   The utility of this function comes from the fact that TxOut usually
--   stores the address in either one of two forms: compacted or unpacked.
--   In order to avoid extroneous conversions in <a>getTxOutAddr</a> and
--   <a>getTxOutCompactAddr</a> we can define just this functionality. Also
--   sometimes it crutial to know at the callsite which form of address we
--   have readily available without any conversions (eg. searching millions
--   of TxOuts for a particular address)
getTxOutEitherAddr :: Era e => TxOut e -> Either (Addr (Crypto e)) (CompactAddr (Crypto e))
getTxOutAddr :: Era e => TxOut e -> Addr (Crypto e)
getTxOutCompactAddr :: Era e => TxOut e -> CompactAddr (Crypto e)

-- | The validity of any individual block depends only on a subset of the
--   UTxO stored in the ledger state. The consensus layer makes use of this
--   fact, and uses the function below to to retrieve the needed UTxO from
--   disk and present only those to the ledger. It is therefore neccessary
--   that this function account for all the different types of inputs
--   inside a transaction.
getAllTxInputs :: Era e => TxBody e -> Set (TxIn (Crypto e))

-- | Get the Bootsrap address from the TxOut. Returns <a>Nothing</a> if it
--   is a Shelley address or newer
getTxOutBootstrapAddress :: forall era. Era era => TxOut era -> Maybe (BootstrapAddress (Crypto era))

-- | Map an era to its predecessor.
--   
--   For example:
--   
--   <pre>
--   type instance PreviousEra (AllegraEra c) = ShelleyEra c
--   </pre>
type family PreviousEra era :: Type

-- | Per-era context used for <a>TranslateEra</a>.
--   
--   This context will be passed to the translation instances of <i>all</i>
--   types of that particular era. In practice, most instances won't need
--   the context, but this approach makes the translation composable (as
--   opposed to having a separate context per type).
type family TranslationContext era :: Type

-- | Translation of types between eras, e.g., from Shelley to Allegra.
--   
--   When <tt>era</tt> is just a phantom type parameter, an empty
--   standalone deriving can be used:
--   
--   <pre>
--   newtype Foo era = Foo Int
--   
--   instance TranslateEra (Allegra c) Foo
--   </pre>
--   
--   Note that one could use <tt>DerivingAnyClass</tt> (<tt>deriving
--   (TranslateEra (Allegra c))</tt>), but this would introduce an
--   undesired coupling between the era-parametric type and (a) particular
--   era(s). The intention is to have a module with orphan instances per
--   era.
--   
--   In most cases, the <tt>era</tt> parameter won't be phantom, and a
--   manual instance will have to be written:
--   
--   <pre>
--   newtype Bar era = Bar (TxBody era)
--   
--   instance CryptoClass.Crypto c =&gt; TranslateEra (Allegra c) Bar where
--       translateEra ctxt = Bar &lt;$&gt; translateEra ctxt
--   
--   -- With the following instance being in scope:
--   instance CryptoClass.Crypto c =&gt; TranslatEra (Allegra c) TxBody
--   </pre>
--   
--   Note: we use <a>PreviousEra</a> instead of <tt>NextEra</tt> as an era
--   definitely knows its predecessor, but not necessarily its successor.
--   Moreover, one could argue that it makes more sense to define the
--   translation from era A to era B where era B is defined, than where era
--   A is defined.
class (Era era, Era (PreviousEra era)) => TranslateEra era f where {
    
    -- | Most translations should be infallible (default instance), but we
    --   leave the door open for partial translations.
    --   
    --   For a partial translation, override the default type to be <tt>()</tt>
    --   or a concrete error type.
    type family TranslationError era f :: Type;
    type TranslationError era f = Void;
}

-- | Translate a type <tt>f</tt> parameterised by the era from an era to
--   the era after it.
--   
--   The translation is a given the translation context of <tt>era</tt>.
--   
--   A default instance is provided for when the two types are
--   <a>Coercible</a>.
translateEra :: TranslateEra era f => TranslationContext era -> f (PreviousEra era) -> Except (TranslationError era f) (f era)

-- | Translate a type <tt>f</tt> parameterised by the era from an era to
--   the era after it.
--   
--   The translation is a given the translation context of <tt>era</tt>.
--   
--   A default instance is provided for when the two types are
--   <a>Coercible</a>.
translateEra :: (TranslateEra era f, Coercible (f (PreviousEra era)) (f era)) => TranslationContext era -> f (PreviousEra era) -> Except (TranslationError era f) (f era)

-- | Variant of <a>translateEra</a> for when <a>TranslationError</a> is
--   <a>Void</a> and the translation thus cannot fail.
translateEra' :: (TranslateEra era f, TranslationError era f ~ Void) => TranslationContext era -> f (PreviousEra era) -> f era

-- | Variant of <a>translateEra</a> for when <a>TranslationError</a> is
--   <tt>()</tt>, converting the result to a <a>Maybe</a>.
translateEraMaybe :: (TranslateEra era f, TranslationError era f ~ ()) => TranslationContext era -> f (PreviousEra era) -> Maybe (f era)

-- | All Well Formed Eras have this minimal structure.
type WellFormed era = (HasField "outputs" (TxBody era) (StrictSeq (TxOut era)), HasField "txfee" (TxBody era) Coin, HasField "minted" (TxBody era) (Set (ScriptHash (Crypto era))), HasField "adHash" (TxBody era) (StrictMaybe (AuxiliaryDataHash (Crypto era))), HasField "body" (Tx era) (TxBody era), HasField "wits" (Tx era) (Witnesses era), HasField "auxiliaryData" (Tx era) (StrictMaybe (AuxiliaryData era)), HasField "txsize" (Tx era) Integer, HasField "scriptWits" (Tx era) (Map (ScriptHash (Crypto era)) (Script era)), HasField "value" (TxOut era) (Value era), HashAnnotated (AuxiliaryData era) EraIndependentAuxiliaryData (Crypto era), HashAnnotated (TxBody era) EraIndependentTxBody (Crypto era), SupportsSegWit era, Val (Value era), Compactible (Value era))

-- | Typeclass for script data types. Allows for script validation and
--   hashing. You must understand the role of SafeToHash and
--   scriptPrefixTag to make new instances. <a>scriptPrefixTag</a> is a
--   magic number representing the tag of the script language. For each new
--   script language defined, a new tag is chosen and the tag is included
--   in the script hash for a script. The safeToHash constraint ensures
--   that Scripts are never reserialised.
class (Era era, SafeToHash (Script era), HasField "body" (Tx era) (TxBody era)) => ValidateScript era
scriptPrefixTag :: ValidateScript era => Script era -> ByteString
validateScript :: ValidateScript era => Script era -> Tx era -> Bool
hashScript :: ValidateScript era => Script era -> ScriptHash (Crypto era)
isNativeScript :: ValidateScript era => Script era -> Bool

-- | Indicates that an era supports segregated witnessing.
--   
--   This class is embodies an isomorphism between 'TxSeq era' and
--   'StrictSeq (Tx era)', witnessed by <a>fromTxSeq</a> and
--   <a>toTxSeq</a>.
class SupportsSegWit era where {
    type family TxSeq era = (r :: Type) | r -> era;
}
fromTxSeq :: SupportsSegWit era => TxSeq era -> StrictSeq (Tx era)
toTxSeq :: SupportsSegWit era => StrictSeq (Tx era) -> TxSeq era

-- | Get the block body hash from the TxSeq. Note that this is not a
--   regular "hash the stored bytes" function since the block body hash
--   forms a small Merkle tree.
hashTxSeq :: SupportsSegWit era => TxSeq era -> Hash (HASH (Crypto era)) EraIndependentBlockBody

-- | The number of segregated components
numSegComponents :: SupportsSegWit era => Word64

module Cardano.Ledger.Block
data Block h era
Block' :: !h -> !TxSeq era -> ByteString -> Block h era
pattern Block :: (Era era, ToCBORGroup (TxSeq era), ToCBOR h) => h -> TxSeq era -> Block h era

-- | Access a block without its serialised bytes. This is often useful when
--   we're using a <tt>BHeaderView</tt> in place of the concrete header.
pattern UnserialisedBlock :: h -> TxSeq era -> Block h era

-- | Unsafely construct a block without the ability to serialise its bytes.
--   
--   Anyone calling this pattern must ensure that the resulting block is
--   never serialised. Any uses of this pattern outside of testing code
--   should be regarded with suspicion.
pattern UnsafeUnserialisedBlock :: h -> TxSeq era -> Block h era
type BlockAnn era = (FromCBOR (Annotator (TxBody era)), FromCBOR (Annotator (AuxiliaryData era)), FromCBOR (Annotator (Witnesses era)), ToCBOR (TxBody era), ToCBOR (AuxiliaryData era), ToCBOR (Witnesses era))
bheader :: Block h era -> h
bbody :: Block h era -> TxSeq era

-- | The validity of any individual block depends only on a subset of the
--   UTxO stored in the ledger state. This function returns the transaction
--   inputs corresponding to the required UTxO for a given Block.
--   
--   This function will be used by the consensus layer to enable storing
--   the UTxO on disk. In particular, given a block, the consensus layer
--   will use <a>neededTxInsForBlock</a> to retrieve the needed UTxO from
--   disk and present only those to the ledger.
neededTxInsForBlock :: Era era => Block h era -> Set (TxIn (Crypto era))
instance GHC.Generics.Generic (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Era.Era era, GHC.Show.Show (Cardano.Ledger.Era.TxSeq era), GHC.Show.Show h) => GHC.Show.Show (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Era.Era era, GHC.Classes.Eq (Cardano.Ledger.Era.TxSeq era), GHC.Classes.Eq h) => GHC.Classes.Eq (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Era.Era era, NoThunks.Class.NoThunks (Cardano.Ledger.Era.TxSeq era), NoThunks.Class.NoThunks h) => NoThunks.Class.NoThunks (Cardano.Ledger.Block.Block h era)
instance (Cardano.Ledger.Block.BlockAnn era, Cardano.Ledger.Era.ValidateScript era, Cardano.Ledger.Era.SupportsSegWit era, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Era.TxSeq era)), Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator h), Data.Typeable.Internal.Typeable h) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Cardano.Ledger.Block.Block h era))
instance (Cardano.Ledger.Era.Era era, Data.Typeable.Internal.Typeable h) => Cardano.Binary.ToCBOR.ToCBOR (Cardano.Ledger.Block.Block h era)
