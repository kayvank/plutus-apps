-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe, feature-complete SQL query and manipulation interface for Haskell
--   
--   Beam is a Haskell library for type-safe querying and manipulation of
--   SQL databases. Beam is modular and supports various backends. In order
--   to use beam, you will need to use <tt>beam-core</tt> along with a
--   specific backend (such as <tt>beam-postgres</tt> or
--   <tt>beam-sqlite</tt>) as well as the corresponding backend. For more
--   information, see the user manual and tutorial on <a>GitHub pages</a>.
@package beam-core
@version 0.10.0.0


-- | This module contains utilities that backend writers can use to assist
--   with compatibility and breaking API changes.
--   
--   Users should not need anything from this module.
module Database.Beam.Backend.Internal.Compat

-- | A type error directing the user to use an explicitly sized integers,
--   instead of <a>Int</a> or <a>Word</a>.
type PreferExplicitSize implicit explicit = 'Text "The size of " :<>: 'ShowType implicit :<>: 'Text " is machine-dependent. Use an explicitly sized integer such as " :<>: 'ShowType explicit :<>: 'Text " instead."

module Database.Beam.Backend.SQL.Types
data SqlNull
SqlNull :: SqlNull
newtype SqlBitString
SqlBitString :: Integer -> SqlBitString
newtype SqlSerial a
SqlSerial :: a -> SqlSerial a
[unSerial] :: SqlSerial a -> a
instance GHC.Enum.Enum Database.Beam.Backend.SQL.Types.SqlNull
instance GHC.Enum.Bounded Database.Beam.Backend.SQL.Types.SqlNull
instance GHC.Classes.Ord Database.Beam.Backend.SQL.Types.SqlNull
instance GHC.Classes.Eq Database.Beam.Backend.SQL.Types.SqlNull
instance GHC.Show.Show Database.Beam.Backend.SQL.Types.SqlNull
instance Data.Bits.Bits Database.Beam.Backend.SQL.Types.SqlBitString
instance GHC.Enum.Enum Database.Beam.Backend.SQL.Types.SqlBitString
instance GHC.Classes.Ord Database.Beam.Backend.SQL.Types.SqlBitString
instance GHC.Classes.Eq Database.Beam.Backend.SQL.Types.SqlBitString
instance GHC.Show.Show Database.Beam.Backend.SQL.Types.SqlBitString
instance GHC.Enum.Enum a => GHC.Enum.Enum (Database.Beam.Backend.SQL.Types.SqlSerial a)
instance GHC.Real.Real a => GHC.Real.Real (Database.Beam.Backend.SQL.Types.SqlSerial a)
instance GHC.Real.Integral a => GHC.Real.Integral (Database.Beam.Backend.SQL.Types.SqlSerial a)
instance GHC.Num.Num a => GHC.Num.Num (Database.Beam.Backend.SQL.Types.SqlSerial a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Database.Beam.Backend.SQL.Types.SqlSerial a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Database.Beam.Backend.SQL.Types.SqlSerial a)
instance GHC.Read.Read a => GHC.Read.Read (Database.Beam.Backend.SQL.Types.SqlSerial a)
instance GHC.Show.Show a => GHC.Show.Show (Database.Beam.Backend.SQL.Types.SqlSerial a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Database.Beam.Backend.SQL.Types.SqlSerial a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Database.Beam.Backend.SQL.Types.SqlSerial a)

module Database.Beam.Backend.Types

-- | Class for all Beam backends
class BeamBackend be where {
    
    -- | Requirements to marshal a certain type from a database of a particular
    --   backend
    type family BackendFromField be :: Type -> Constraint;
}

-- | newtype mainly used to inspect the tag structure of a particular
--   <tt>Beamable</tt>. Prevents overlapping instances in some case.
--   Usually not used in end-user code.
data Exposed x

-- | Support for NULLable Foreign Key references.
--   
--   <pre>
--   data MyTable f = MyTable
--                  { nullableRef :: PrimaryKey AnotherTable (Nullable f)
--                  , ... }
--                   deriving (Generic, Typeable)
--   </pre>
--   
--   See <tt>Columnar</tt> for more information.
data Nullable (c :: Type -> Type) x

module Database.Beam.Backend.SQL.Row
data FromBackendRowF be f
[ParseOneField] :: (BackendFromField be a, Typeable a) => (a -> f) -> FromBackendRowF be f
[Alt] :: FromBackendRowM be a -> FromBackendRowM be a -> (a -> f) -> FromBackendRowF be f
[FailParseWith] :: BeamRowReadError -> FromBackendRowF be f
newtype FromBackendRowM be a
FromBackendRowM :: F (FromBackendRowF be) a -> FromBackendRowM be a
parseOneField :: (BackendFromField be a, Typeable a) => FromBackendRowM be a
peekField :: (Typeable a, BackendFromField be a) => FromBackendRowM be (Maybe a)

-- | The exact error encountered
data ColumnParseError
ColumnUnexpectedNull :: ColumnParseError
ColumnNotEnoughColumns :: !Int -> ColumnParseError
ColumnTypeMismatch :: String -> String -> String -> ColumnParseError
[ctmHaskellType] :: ColumnParseError -> String
[ctmSQLType] :: ColumnParseError -> String
[ctmMessage] :: ColumnParseError -> String
ColumnErrorInternal :: String -> ColumnParseError

-- | An error that may occur when parsing a row. Contains an optional
--   annotation of which column was being parsed (if available).
data BeamRowReadError
BeamRowReadError :: !Maybe Int -> !ColumnParseError -> BeamRowReadError
[brreColumn] :: BeamRowReadError -> !Maybe Int
[brreError] :: BeamRowReadError -> !ColumnParseError
class BeamBackend be => FromBackendRow be a

-- | Parses a beam row. This should not fail, except in the case of an
--   internal bug in beam deserialization code. If it does fail, this
--   should throw a <tt>BeamRowParseError</tt>.
fromBackendRow :: FromBackendRow be a => FromBackendRowM be a

-- | Parses a beam row. This should not fail, except in the case of an
--   internal bug in beam deserialization code. If it does fail, this
--   should throw a <tt>BeamRowParseError</tt>.
fromBackendRow :: (FromBackendRow be a, Typeable a, BackendFromField be a) => FromBackendRowM be a
valuesNeeded :: FromBackendRow be a => Proxy be -> Proxy a -> Int
instance GHC.Classes.Ord Database.Beam.Backend.SQL.Row.ColumnParseError
instance GHC.Classes.Eq Database.Beam.Backend.SQL.Row.ColumnParseError
instance GHC.Show.Show Database.Beam.Backend.SQL.Row.ColumnParseError
instance GHC.Classes.Ord Database.Beam.Backend.SQL.Row.BeamRowReadError
instance GHC.Classes.Eq Database.Beam.Backend.SQL.Row.BeamRowReadError
instance GHC.Show.Show Database.Beam.Backend.SQL.Row.BeamRowReadError
instance GHC.Base.Applicative (Database.Beam.Backend.SQL.Row.FromBackendRowM be)
instance GHC.Base.Functor (Database.Beam.Backend.SQL.Row.FromBackendRowM be)
instance GHC.Generics.Generic (a, b, c, d, e, f, g, h)
instance Database.Beam.Backend.SQL.Row.GFromBackendRow be e p => Database.Beam.Backend.SQL.Row.GFromBackendRow be (GHC.Generics.M1 t f e) (GHC.Generics.M1 t f p)
instance Database.Beam.Backend.SQL.Row.GFromBackendRow be e GHC.Generics.U1
instance (Database.Beam.Backend.SQL.Row.GFromBackendRow be aExp a, Database.Beam.Backend.SQL.Row.GFromBackendRow be bExp b) => Database.Beam.Backend.SQL.Row.GFromBackendRow be (aExp GHC.Generics.:*: bExp) (a GHC.Generics.:*: b)
instance Database.Beam.Backend.SQL.Row.FromBackendRow be x => Database.Beam.Backend.SQL.Row.GFromBackendRow be (GHC.Generics.K1 GHC.Generics.R (Database.Beam.Backend.Types.Exposed x)) (GHC.Generics.K1 GHC.Generics.R x)
instance Database.Beam.Backend.SQL.Row.FromBackendRow be (t Data.Functor.Identity.Identity) => Database.Beam.Backend.SQL.Row.GFromBackendRow be (GHC.Generics.K1 GHC.Generics.R (t Database.Beam.Backend.Types.Exposed)) (GHC.Generics.K1 GHC.Generics.R (t Data.Functor.Identity.Identity))
instance Database.Beam.Backend.SQL.Row.FromBackendRow be (t (Database.Beam.Backend.Types.Nullable Data.Functor.Identity.Identity)) => Database.Beam.Backend.SQL.Row.GFromBackendRow be (GHC.Generics.K1 GHC.Generics.R (t (Database.Beam.Backend.Types.Nullable Database.Beam.Backend.Types.Exposed))) (GHC.Generics.K1 GHC.Generics.R (t (Database.Beam.Backend.Types.Nullable Data.Functor.Identity.Identity)))
instance Database.Beam.Backend.Types.BeamBackend be => Database.Beam.Backend.SQL.Row.FromBackendRow be ()
instance (Database.Beam.Backend.Types.BeamBackend be, Database.Beam.Backend.SQL.Row.FromBackendRow be a, Database.Beam.Backend.SQL.Row.FromBackendRow be b) => Database.Beam.Backend.SQL.Row.FromBackendRow be (a, b)
instance (Database.Beam.Backend.Types.BeamBackend be, Database.Beam.Backend.SQL.Row.FromBackendRow be a, Database.Beam.Backend.SQL.Row.FromBackendRow be b, Database.Beam.Backend.SQL.Row.FromBackendRow be c) => Database.Beam.Backend.SQL.Row.FromBackendRow be (a, b, c)
instance (Database.Beam.Backend.Types.BeamBackend be, Database.Beam.Backend.SQL.Row.FromBackendRow be a, Database.Beam.Backend.SQL.Row.FromBackendRow be b, Database.Beam.Backend.SQL.Row.FromBackendRow be c, Database.Beam.Backend.SQL.Row.FromBackendRow be d) => Database.Beam.Backend.SQL.Row.FromBackendRow be (a, b, c, d)
instance (Database.Beam.Backend.Types.BeamBackend be, Database.Beam.Backend.SQL.Row.FromBackendRow be a, Database.Beam.Backend.SQL.Row.FromBackendRow be b, Database.Beam.Backend.SQL.Row.FromBackendRow be c, Database.Beam.Backend.SQL.Row.FromBackendRow be d, Database.Beam.Backend.SQL.Row.FromBackendRow be e) => Database.Beam.Backend.SQL.Row.FromBackendRow be (a, b, c, d, e)
instance (Database.Beam.Backend.Types.BeamBackend be, Database.Beam.Backend.SQL.Row.FromBackendRow be a, Database.Beam.Backend.SQL.Row.FromBackendRow be b, Database.Beam.Backend.SQL.Row.FromBackendRow be c, Database.Beam.Backend.SQL.Row.FromBackendRow be d, Database.Beam.Backend.SQL.Row.FromBackendRow be e, Database.Beam.Backend.SQL.Row.FromBackendRow be f) => Database.Beam.Backend.SQL.Row.FromBackendRow be (a, b, c, d, e, f)
instance (Database.Beam.Backend.Types.BeamBackend be, Database.Beam.Backend.SQL.Row.FromBackendRow be a, Database.Beam.Backend.SQL.Row.FromBackendRow be b, Database.Beam.Backend.SQL.Row.FromBackendRow be c, Database.Beam.Backend.SQL.Row.FromBackendRow be d, Database.Beam.Backend.SQL.Row.FromBackendRow be e, Database.Beam.Backend.SQL.Row.FromBackendRow be f, Database.Beam.Backend.SQL.Row.FromBackendRow be g) => Database.Beam.Backend.SQL.Row.FromBackendRow be (a, b, c, d, e, f, g)
instance (Database.Beam.Backend.Types.BeamBackend be, Database.Beam.Backend.SQL.Row.FromBackendRow be a, Database.Beam.Backend.SQL.Row.FromBackendRow be b, Database.Beam.Backend.SQL.Row.FromBackendRow be c, Database.Beam.Backend.SQL.Row.FromBackendRow be d, Database.Beam.Backend.SQL.Row.FromBackendRow be e, Database.Beam.Backend.SQL.Row.FromBackendRow be f, Database.Beam.Backend.SQL.Row.FromBackendRow be g, Database.Beam.Backend.SQL.Row.FromBackendRow be h) => Database.Beam.Backend.SQL.Row.FromBackendRow be (a, b, c, d, e, f, g, h)
instance (Database.Beam.Backend.Types.BeamBackend be, GHC.Generics.Generic (tbl Data.Functor.Identity.Identity), GHC.Generics.Generic (tbl Database.Beam.Backend.Types.Exposed), Database.Beam.Backend.SQL.Row.GFromBackendRow be (GHC.Generics.Rep (tbl Database.Beam.Backend.Types.Exposed)) (GHC.Generics.Rep (tbl Data.Functor.Identity.Identity))) => Database.Beam.Backend.SQL.Row.FromBackendRow be (tbl Data.Functor.Identity.Identity)
instance (Database.Beam.Backend.Types.BeamBackend be, GHC.Generics.Generic (tbl (Database.Beam.Backend.Types.Nullable Data.Functor.Identity.Identity)), GHC.Generics.Generic (tbl (Database.Beam.Backend.Types.Nullable Database.Beam.Backend.Types.Exposed)), Database.Beam.Backend.SQL.Row.GFromBackendRow be (GHC.Generics.Rep (tbl (Database.Beam.Backend.Types.Nullable Database.Beam.Backend.Types.Exposed))) (GHC.Generics.Rep (tbl (Database.Beam.Backend.Types.Nullable Data.Functor.Identity.Identity)))) => Database.Beam.Backend.SQL.Row.FromBackendRow be (tbl (Database.Beam.Backend.Types.Nullable Data.Functor.Identity.Identity))
instance (Database.Beam.Backend.Types.BeamBackend be, GHC.TypeNats.KnownNat n, Database.Beam.Backend.SQL.Row.FromBackendRow be a) => Database.Beam.Backend.SQL.Row.FromBackendRow be (Data.Vector.Sized.Vector n a)
instance (Database.Beam.Backend.SQL.Row.FromBackendRow be x, Database.Beam.Backend.SQL.Row.FromBackendRow be Database.Beam.Backend.SQL.Types.SqlNull) => Database.Beam.Backend.SQL.Row.FromBackendRow be (GHC.Maybe.Maybe x)
instance forall k be t (tag :: k). (Database.Beam.Backend.Types.BeamBackend be, Database.Beam.Backend.SQL.Row.FromBackendRow be t) => Database.Beam.Backend.SQL.Row.FromBackendRow be (Data.Tagged.Tagged tag t)
instance Database.Beam.Backend.SQL.Row.FromBackendRow be x => Database.Beam.Backend.SQL.Row.FromBackendRow be (Database.Beam.Backend.SQL.Types.SqlSerial x)
instance GHC.Base.Functor (Database.Beam.Backend.SQL.Row.FromBackendRowF be)
instance GHC.Base.Monad (Database.Beam.Backend.SQL.Row.FromBackendRowM be)
instance Control.Monad.Fail.MonadFail (Database.Beam.Backend.SQL.Row.FromBackendRowM be)
instance GHC.Base.Alternative (Database.Beam.Backend.SQL.Row.FromBackendRowM be)
instance GHC.Exception.Type.Exception Database.Beam.Backend.SQL.Row.BeamRowReadError


-- | Finally tagless encoding of SQL92 syntax
module Database.Beam.Backend.SQL.SQL92
class HasSqlValueSyntax expr ty
sqlValueSyntax :: HasSqlValueSyntax expr ty => ty -> expr
autoSqlValueSyntax :: (HasSqlValueSyntax expr String, Show a) => a -> expr
type Sql92SelectExpressionSyntax select = Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax select)
type Sql92SelectProjectionSyntax select = Sql92SelectTableProjectionSyntax (Sql92SelectSelectTableSyntax select)
type Sql92SelectGroupingSyntax select = Sql92SelectTableGroupingSyntax (Sql92SelectSelectTableSyntax select)
type Sql92SelectFromSyntax select = Sql92SelectTableFromSyntax (Sql92SelectSelectTableSyntax select)
type Sql92InsertExpressionSyntax select = Sql92InsertValuesExpressionSyntax (Sql92InsertValuesSyntax select)
type Sql92TableNameSyntax select = Sql92TableSourceTableNameSyntax (Sql92FromTableSourceSyntax (Sql92SelectFromSyntax select))
type Sql92ValueSyntax cmdSyntax = Sql92ExpressionValueSyntax (Sql92ExpressionSyntax cmdSyntax)
type Sql92ExpressionSyntax cmdSyntax = Sql92SelectExpressionSyntax (Sql92SelectSyntax cmdSyntax)
type Sql92ExtractFieldSyntax cmdSyntax = Sql92ExpressionExtractFieldSyntax (Sql92ExpressionSyntax cmdSyntax)
type Sql92HasValueSyntax cmdSyntax = HasSqlValueSyntax (Sql92ValueSyntax cmdSyntax)
type Sql92SelectSanityCheck select = (Sql92FromExpressionSyntax (Sql92SelectTableFromSyntax (Sql92SelectSelectTableSyntax select)) ~ Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax select), Sql92TableSourceSelectSyntax (Sql92FromTableSourceSyntax (Sql92SelectTableFromSyntax (Sql92SelectSelectTableSyntax select))) ~ select, Sql92ProjectionExpressionSyntax (Sql92SelectTableProjectionSyntax (Sql92SelectSelectTableSyntax select)) ~ Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax select), Sql92OrderingExpressionSyntax (Sql92SelectOrderingSyntax select) ~ Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax select), Sql92TableSourceExpressionSyntax (Sql92FromTableSourceSyntax (Sql92SelectTableFromSyntax (Sql92SelectSelectTableSyntax select))) ~ Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax select))
type Sql92SanityCheck cmd = (Sql92SelectSanityCheck (Sql92SelectSyntax cmd), Sql92ExpressionValueSyntax (Sql92InsertValuesExpressionSyntax (Sql92InsertValuesSyntax (Sql92InsertSyntax cmd))) ~ Sql92ValueSyntax cmd, Sql92ExpressionValueSyntax (Sql92UpdateExpressionSyntax (Sql92UpdateSyntax cmd)) ~ Sql92ValueSyntax cmd, Sql92ExpressionValueSyntax (Sql92DeleteExpressionSyntax (Sql92DeleteSyntax cmd)) ~ Sql92ValueSyntax cmd, Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax (Sql92SelectSyntax cmd)) ~ Sql92InsertValuesExpressionSyntax (Sql92InsertValuesSyntax (Sql92InsertSyntax cmd)), Sql92SelectTableExpressionSyntax (Sql92SelectSelectTableSyntax (Sql92SelectSyntax cmd)) ~ Sql92UpdateExpressionSyntax (Sql92UpdateSyntax cmd), Sql92DeleteExpressionSyntax (Sql92DeleteSyntax cmd) ~ Sql92UpdateExpressionSyntax (Sql92UpdateSyntax cmd), Sql92ExpressionSelectSyntax (Sql92InsertExpressionSyntax (Sql92InsertSyntax cmd)) ~ Sql92SelectSyntax cmd, Sql92InsertValuesSelectSyntax (Sql92InsertValuesSyntax (Sql92InsertSyntax cmd)) ~ Sql92SelectSyntax cmd, Sql92UpdateFieldNameSyntax (Sql92UpdateSyntax cmd) ~ Sql92ExpressionFieldNameSyntax (Sql92InsertValuesExpressionSyntax (Sql92InsertValuesSyntax (Sql92InsertSyntax cmd))))
type Sql92ReasonableMarshaller be = (FromBackendRow be SqlNull, FromBackendRow be Text, FromBackendRow be Bool, FromBackendRow be Char, FromBackendRow be Int16, FromBackendRow be Int32, FromBackendRow be Int64, FromBackendRow be LocalTime)

-- | Type classes for syntaxes which can be displayed
class Sql92DisplaySyntax syntax

-- | Render the syntax as a <a>String</a>, representing the SQL expression
--   it stands for
displaySyntax :: Sql92DisplaySyntax syntax => syntax -> String
class (IsSql92SelectSyntax (Sql92SelectSyntax cmd), IsSql92InsertSyntax (Sql92InsertSyntax cmd), IsSql92UpdateSyntax (Sql92UpdateSyntax cmd), IsSql92DeleteSyntax (Sql92DeleteSyntax cmd)) => IsSql92Syntax cmd where {
    type family Sql92SelectSyntax cmd :: Type;
    type family Sql92InsertSyntax cmd :: Type;
    type family Sql92UpdateSyntax cmd :: Type;
    type family Sql92DeleteSyntax cmd :: Type;
}
selectCmd :: IsSql92Syntax cmd => Sql92SelectSyntax cmd -> cmd
insertCmd :: IsSql92Syntax cmd => Sql92InsertSyntax cmd -> cmd
updateCmd :: IsSql92Syntax cmd => Sql92UpdateSyntax cmd -> cmd
deleteCmd :: IsSql92Syntax cmd => Sql92DeleteSyntax cmd -> cmd
class (IsSql92SelectTableSyntax (Sql92SelectSelectTableSyntax select), IsSql92OrderingSyntax (Sql92SelectOrderingSyntax select)) => IsSql92SelectSyntax select where {
    type family Sql92SelectSelectTableSyntax select :: Type;
    type family Sql92SelectOrderingSyntax select :: Type;
}
selectStmt :: IsSql92SelectSyntax select => Sql92SelectSelectTableSyntax select -> [Sql92SelectOrderingSyntax select] -> Maybe Integer -> Maybe Integer -> select
class (IsSql92ExpressionSyntax (Sql92SelectTableExpressionSyntax select), IsSql92AggregationExpressionSyntax (Sql92SelectTableExpressionSyntax select), IsSql92ProjectionSyntax (Sql92SelectTableProjectionSyntax select), IsSql92FromSyntax (Sql92SelectTableFromSyntax select), IsSql92GroupingSyntax (Sql92SelectTableGroupingSyntax select), IsSql92AggregationSetQuantifierSyntax (Sql92SelectTableSetQuantifierSyntax select), Sql92GroupingExpressionSyntax (Sql92SelectTableGroupingSyntax select) ~ Sql92SelectTableExpressionSyntax select, Sql92FromExpressionSyntax (Sql92SelectTableFromSyntax select) ~ Sql92SelectTableExpressionSyntax select, Sql92SelectSelectTableSyntax (Sql92SelectTableSelectSyntax select) ~ select, Eq (Sql92SelectTableExpressionSyntax select)) => IsSql92SelectTableSyntax select where {
    type family Sql92SelectTableSelectSyntax select :: Type;
    type family Sql92SelectTableExpressionSyntax select :: Type;
    type family Sql92SelectTableProjectionSyntax select :: Type;
    type family Sql92SelectTableFromSyntax select :: Type;
    type family Sql92SelectTableGroupingSyntax select :: Type;
    type family Sql92SelectTableSetQuantifierSyntax select :: Type;
}
selectTableStmt :: IsSql92SelectTableSyntax select => Maybe (Sql92SelectTableSetQuantifierSyntax select) -> Sql92SelectTableProjectionSyntax select -> Maybe (Sql92SelectTableFromSyntax select) -> Maybe (Sql92SelectTableExpressionSyntax select) -> Maybe (Sql92SelectTableGroupingSyntax select) -> Maybe (Sql92SelectTableExpressionSyntax select) -> select
unionTables :: IsSql92SelectTableSyntax select => Bool -> select -> select -> select
intersectTables :: IsSql92SelectTableSyntax select => Bool -> select -> select -> select
exceptTable :: IsSql92SelectTableSyntax select => Bool -> select -> select -> select
class (IsSql92InsertValuesSyntax (Sql92InsertValuesSyntax insert), IsSql92TableNameSyntax (Sql92InsertTableNameSyntax insert)) => IsSql92InsertSyntax insert where {
    type family Sql92InsertValuesSyntax insert :: Type;
    type family Sql92InsertTableNameSyntax insert :: Type;
}
insertStmt :: IsSql92InsertSyntax insert => Sql92InsertTableNameSyntax insert -> [Text] -> Sql92InsertValuesSyntax insert -> insert
class IsSql92ExpressionSyntax (Sql92InsertValuesExpressionSyntax insertValues) => IsSql92InsertValuesSyntax insertValues where {
    type family Sql92InsertValuesExpressionSyntax insertValues :: Type;
    type family Sql92InsertValuesSelectSyntax insertValues :: Type;
}
insertSqlExpressions :: IsSql92InsertValuesSyntax insertValues => [[Sql92InsertValuesExpressionSyntax insertValues]] -> insertValues
insertFromSql :: IsSql92InsertValuesSyntax insertValues => Sql92InsertValuesSelectSyntax insertValues -> insertValues
class (IsSql92ExpressionSyntax (Sql92UpdateExpressionSyntax update), IsSql92FieldNameSyntax (Sql92UpdateFieldNameSyntax update), IsSql92TableNameSyntax (Sql92UpdateTableNameSyntax update)) => IsSql92UpdateSyntax update where {
    type family Sql92UpdateTableNameSyntax update :: Type;
    type family Sql92UpdateFieldNameSyntax update :: Type;
    type family Sql92UpdateExpressionSyntax update :: Type;
}
updateStmt :: IsSql92UpdateSyntax update => Sql92UpdateTableNameSyntax update -> [(Sql92UpdateFieldNameSyntax update, Sql92UpdateExpressionSyntax update)] -> Maybe (Sql92UpdateExpressionSyntax update) -> update
class (IsSql92TableNameSyntax (Sql92DeleteTableNameSyntax delete), IsSql92ExpressionSyntax (Sql92DeleteExpressionSyntax delete)) => IsSql92DeleteSyntax delete where {
    type family Sql92DeleteTableNameSyntax delete :: Type;
    type family Sql92DeleteExpressionSyntax delete :: Type;
}
deleteStmt :: IsSql92DeleteSyntax delete => Sql92DeleteTableNameSyntax delete -> Maybe Text -> Maybe (Sql92DeleteExpressionSyntax delete) -> delete

-- | Whether or not the <tt>DELETE</tt> command supports aliases
deleteSupportsAlias :: IsSql92DeleteSyntax delete => Proxy delete -> Bool
class IsSql92FieldNameSyntax fn
qualifiedField :: IsSql92FieldNameSyntax fn => Text -> Text -> fn
unqualifiedField :: IsSql92FieldNameSyntax fn => Text -> fn
class IsSql92QuantifierSyntax quantifier
quantifyOverAll :: IsSql92QuantifierSyntax quantifier => quantifier
quantifyOverAny :: IsSql92QuantifierSyntax quantifier => quantifier
class IsSql92ExtractFieldSyntax extractField
secondsField :: IsSql92ExtractFieldSyntax extractField => extractField
minutesField :: IsSql92ExtractFieldSyntax extractField => extractField
hourField :: IsSql92ExtractFieldSyntax extractField => extractField
dayField :: IsSql92ExtractFieldSyntax extractField => extractField
monthField :: IsSql92ExtractFieldSyntax extractField => extractField
yearField :: IsSql92ExtractFieldSyntax extractField => extractField
class IsSql92DataTypeSyntax dataType
domainType :: IsSql92DataTypeSyntax dataType => Text -> dataType
charType :: IsSql92DataTypeSyntax dataType => Maybe Word -> Maybe Text -> dataType
varCharType :: IsSql92DataTypeSyntax dataType => Maybe Word -> Maybe Text -> dataType
nationalCharType :: IsSql92DataTypeSyntax dataType => Maybe Word -> dataType
nationalVarCharType :: IsSql92DataTypeSyntax dataType => Maybe Word -> dataType
bitType :: IsSql92DataTypeSyntax dataType => Maybe Word -> dataType
varBitType :: IsSql92DataTypeSyntax dataType => Maybe Word -> dataType
numericType :: IsSql92DataTypeSyntax dataType => Maybe (Word, Maybe Word) -> dataType
decimalType :: IsSql92DataTypeSyntax dataType => Maybe (Word, Maybe Word) -> dataType
intType :: IsSql92DataTypeSyntax dataType => dataType
smallIntType :: IsSql92DataTypeSyntax dataType => dataType
floatType :: IsSql92DataTypeSyntax dataType => Maybe Word -> dataType
doubleType :: IsSql92DataTypeSyntax dataType => dataType
realType :: IsSql92DataTypeSyntax dataType => dataType
dateType :: IsSql92DataTypeSyntax dataType => dataType
timeType :: IsSql92DataTypeSyntax dataType => Maybe Word -> Bool -> dataType
timestampType :: IsSql92DataTypeSyntax dataType => Maybe Word -> Bool -> dataType
class (HasSqlValueSyntax (Sql92ExpressionValueSyntax expr) Int32, HasSqlValueSyntax (Sql92ExpressionValueSyntax expr) Bool, IsSql92FieldNameSyntax (Sql92ExpressionFieldNameSyntax expr), IsSql92QuantifierSyntax (Sql92ExpressionQuantifierSyntax expr), IsSql92DataTypeSyntax (Sql92ExpressionCastTargetSyntax expr), IsSql92ExtractFieldSyntax (Sql92ExpressionExtractFieldSyntax expr), Typeable expr) => IsSql92ExpressionSyntax expr where {
    type family Sql92ExpressionQuantifierSyntax expr :: Type;
    type family Sql92ExpressionValueSyntax expr :: Type;
    type family Sql92ExpressionSelectSyntax expr :: Type;
    type family Sql92ExpressionFieldNameSyntax expr :: Type;
    type family Sql92ExpressionCastTargetSyntax expr :: Type;
    type family Sql92ExpressionExtractFieldSyntax expr :: Type;
}
valueE :: IsSql92ExpressionSyntax expr => Sql92ExpressionValueSyntax expr -> expr
rowE :: IsSql92ExpressionSyntax expr => [expr] -> expr
quantifierListE :: IsSql92ExpressionSyntax expr => [expr] -> expr
coalesceE :: IsSql92ExpressionSyntax expr => [expr] -> expr
caseE :: IsSql92ExpressionSyntax expr => [(expr, expr)] -> expr -> expr
fieldE :: IsSql92ExpressionSyntax expr => Sql92ExpressionFieldNameSyntax expr -> expr
betweenE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr -> expr
andE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
orE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
addE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
subE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
mulE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
divE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
likeE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
modE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
overlapsE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
nullIfE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
positionE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr
eqE :: IsSql92ExpressionSyntax expr => Maybe (Sql92ExpressionQuantifierSyntax expr) -> expr -> expr -> expr
neqE :: IsSql92ExpressionSyntax expr => Maybe (Sql92ExpressionQuantifierSyntax expr) -> expr -> expr -> expr
ltE :: IsSql92ExpressionSyntax expr => Maybe (Sql92ExpressionQuantifierSyntax expr) -> expr -> expr -> expr
gtE :: IsSql92ExpressionSyntax expr => Maybe (Sql92ExpressionQuantifierSyntax expr) -> expr -> expr -> expr
leE :: IsSql92ExpressionSyntax expr => Maybe (Sql92ExpressionQuantifierSyntax expr) -> expr -> expr -> expr
geE :: IsSql92ExpressionSyntax expr => Maybe (Sql92ExpressionQuantifierSyntax expr) -> expr -> expr -> expr

-- | Compare the first and second argument for nullable equality, if they
--   are both not null, return the result of the third expression
--   
--   Some backends, like <tt>beam-postgres</tt> totally ignore the third
--   result, because all equality there is sensible.
eqMaybeE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr -> expr

-- | Compare the first and second argument for nullable equality, if they
--   are both not null, return the result of the third expression
--   
--   Some backends, like <tt>beam-postgres</tt> totally ignore the third
--   result, because all equality there is sensible.
neqMaybeE :: IsSql92ExpressionSyntax expr => expr -> expr -> expr -> expr
castE :: IsSql92ExpressionSyntax expr => expr -> Sql92ExpressionCastTargetSyntax expr -> expr
notE :: IsSql92ExpressionSyntax expr => expr -> expr
negateE :: IsSql92ExpressionSyntax expr => expr -> expr
isNullE :: IsSql92ExpressionSyntax expr => expr -> expr
isNotNullE :: IsSql92ExpressionSyntax expr => expr -> expr
isTrueE :: IsSql92ExpressionSyntax expr => expr -> expr
isNotTrueE :: IsSql92ExpressionSyntax expr => expr -> expr
isFalseE :: IsSql92ExpressionSyntax expr => expr -> expr
isNotFalseE :: IsSql92ExpressionSyntax expr => expr -> expr
isUnknownE :: IsSql92ExpressionSyntax expr => expr -> expr
isNotUnknownE :: IsSql92ExpressionSyntax expr => expr -> expr
charLengthE :: IsSql92ExpressionSyntax expr => expr -> expr
octetLengthE :: IsSql92ExpressionSyntax expr => expr -> expr
bitLengthE :: IsSql92ExpressionSyntax expr => expr -> expr
lowerE :: IsSql92ExpressionSyntax expr => expr -> expr
upperE :: IsSql92ExpressionSyntax expr => expr -> expr
trimE :: IsSql92ExpressionSyntax expr => expr -> expr

-- | Included so that we can easily write a Num instance, but not defined
--   in SQL92. Implementations that do not support this, should use CASE ..
--   WHEN ..
absE :: IsSql92ExpressionSyntax expr => expr -> expr
extractE :: IsSql92ExpressionSyntax expr => Sql92ExpressionExtractFieldSyntax expr -> expr -> expr
existsE :: IsSql92ExpressionSyntax expr => Sql92ExpressionSelectSyntax expr -> expr
uniqueE :: IsSql92ExpressionSyntax expr => Sql92ExpressionSelectSyntax expr -> expr
subqueryE :: IsSql92ExpressionSyntax expr => Sql92ExpressionSelectSyntax expr -> expr
currentTimestampE :: IsSql92ExpressionSyntax expr => expr
defaultE :: IsSql92ExpressionSyntax expr => expr
inE :: IsSql92ExpressionSyntax expr => expr -> [expr] -> expr
inSelectE :: IsSql92ExpressionSyntax expr => expr -> Sql92ExpressionSelectSyntax expr -> expr
class IsSql92AggregationSetQuantifierSyntax (Sql92AggregationSetQuantifierSyntax expr) => IsSql92AggregationExpressionSyntax expr where {
    type family Sql92AggregationSetQuantifierSyntax expr :: Type;
}
countAllE :: IsSql92AggregationExpressionSyntax expr => expr
countE :: IsSql92AggregationExpressionSyntax expr => Maybe (Sql92AggregationSetQuantifierSyntax expr) -> expr -> expr
avgE :: IsSql92AggregationExpressionSyntax expr => Maybe (Sql92AggregationSetQuantifierSyntax expr) -> expr -> expr
maxE :: IsSql92AggregationExpressionSyntax expr => Maybe (Sql92AggregationSetQuantifierSyntax expr) -> expr -> expr
minE :: IsSql92AggregationExpressionSyntax expr => Maybe (Sql92AggregationSetQuantifierSyntax expr) -> expr -> expr
sumE :: IsSql92AggregationExpressionSyntax expr => Maybe (Sql92AggregationSetQuantifierSyntax expr) -> expr -> expr
class IsSql92AggregationSetQuantifierSyntax q
setQuantifierDistinct :: IsSql92AggregationSetQuantifierSyntax q => q
setQuantifierAll :: IsSql92AggregationSetQuantifierSyntax q => q
class IsSql92ExpressionSyntax (Sql92ProjectionExpressionSyntax proj) => IsSql92ProjectionSyntax proj where {
    type family Sql92ProjectionExpressionSyntax proj :: Type;
}
projExprs :: IsSql92ProjectionSyntax proj => [(Sql92ProjectionExpressionSyntax proj, Maybe Text)] -> proj
class IsSql92OrderingSyntax ord where {
    type family Sql92OrderingExpressionSyntax ord :: Type;
}
ascOrdering :: IsSql92OrderingSyntax ord => Sql92OrderingExpressionSyntax ord -> ord
descOrdering :: IsSql92OrderingSyntax ord => Sql92OrderingExpressionSyntax ord -> ord
class IsSql92TableNameSyntax tblName
tableName :: IsSql92TableNameSyntax tblName => Maybe Text -> Text -> tblName
class IsSql92TableNameSyntax (Sql92TableSourceTableNameSyntax tblSource) => IsSql92TableSourceSyntax tblSource where {
    type family Sql92TableSourceSelectSyntax tblSource :: Type;
    type family Sql92TableSourceExpressionSyntax tblSource :: Type;
    type family Sql92TableSourceTableNameSyntax tblSource :: Type;
}
tableNamed :: IsSql92TableSourceSyntax tblSource => Sql92TableSourceTableNameSyntax tblSource -> tblSource
tableFromSubSelect :: IsSql92TableSourceSyntax tblSource => Sql92TableSourceSelectSyntax tblSource -> tblSource
tableFromValues :: IsSql92TableSourceSyntax tblSource => [[Sql92TableSourceExpressionSyntax tblSource]] -> tblSource
class IsSql92GroupingSyntax grouping where {
    type family Sql92GroupingExpressionSyntax grouping :: Type;
}
groupByExpressions :: IsSql92GroupingSyntax grouping => [Sql92GroupingExpressionSyntax grouping] -> grouping
class (IsSql92TableSourceSyntax (Sql92FromTableSourceSyntax from), IsSql92ExpressionSyntax (Sql92FromExpressionSyntax from)) => IsSql92FromSyntax from where {
    type family Sql92FromTableSourceSyntax from :: Type;
    type family Sql92FromExpressionSyntax from :: Type;
}
fromTable :: IsSql92FromSyntax from => Sql92FromTableSourceSyntax from -> Maybe (Text, Maybe [Text]) -> from
innerJoin :: IsSql92FromSyntax from => from -> from -> Maybe (Sql92FromExpressionSyntax from) -> from
leftJoin :: IsSql92FromSyntax from => from -> from -> Maybe (Sql92FromExpressionSyntax from) -> from
rightJoin :: IsSql92FromSyntax from => from -> from -> Maybe (Sql92FromExpressionSyntax from) -> from
class IsSql92FromSyntax from => IsSql92FromOuterJoinSyntax from
outerJoin :: IsSql92FromOuterJoinSyntax from => from -> from -> Maybe (Sql92FromExpressionSyntax from) -> from
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax syntax x => Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax syntax (Database.Beam.Backend.SQL.Types.SqlSerial x)
instance forall k vs t (tag :: k). Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax vs t => Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax vs (Data.Tagged.Tagged tag t)


-- | Finally tagless extension of SQL92 syntaxes for SQL99
module Database.Beam.Backend.SQL.SQL99
class IsSql92ExpressionSyntax expr => IsSql99FunctionExpressionSyntax expr
functionCallE :: IsSql99FunctionExpressionSyntax expr => expr -> [expr] -> expr
functionNameE :: IsSql99FunctionExpressionSyntax expr => Text -> expr
class IsSql99FunctionExpressionSyntax expr => IsSql99ExpressionSyntax expr
distinctE :: IsSql99ExpressionSyntax expr => Sql92ExpressionSelectSyntax expr -> expr
similarToE :: IsSql99ExpressionSyntax expr => expr -> expr -> expr
instanceFieldE :: IsSql99ExpressionSyntax expr => expr -> Text -> expr
refFieldE :: IsSql99ExpressionSyntax expr => expr -> Text -> expr
class IsSql92ExpressionSyntax expr => IsSql99ConcatExpressionSyntax expr
concatE :: IsSql99ConcatExpressionSyntax expr => [expr] -> expr
class IsSql92AggregationExpressionSyntax expr => IsSql99AggregationExpressionSyntax expr
everyE :: IsSql99AggregationExpressionSyntax expr => Maybe (Sql92AggregationSetQuantifierSyntax expr) -> expr -> expr
someE :: IsSql99AggregationExpressionSyntax expr => Maybe (Sql92AggregationSetQuantifierSyntax expr) -> expr -> expr
anyE :: IsSql99AggregationExpressionSyntax expr => Maybe (Sql92AggregationSetQuantifierSyntax expr) -> expr -> expr
class IsSql92SelectSyntax syntax => IsSql99CommonTableExpressionSelectSyntax syntax where {
    type family Sql99SelectCTESyntax syntax :: Type;
}
withSyntax :: IsSql99CommonTableExpressionSelectSyntax syntax => [Sql99SelectCTESyntax syntax] -> syntax -> syntax
class IsSql99CommonTableExpressionSyntax syntax where {
    type family Sql99CTESelectSyntax syntax :: Type;
}
cteSubquerySyntax :: IsSql99CommonTableExpressionSyntax syntax => Text -> [Text] -> Sql99CTESelectSyntax syntax -> syntax
class IsSql99CommonTableExpressionSelectSyntax syntax => IsSql99RecursiveCommonTableExpressionSelectSyntax syntax
withRecursiveSyntax :: IsSql99RecursiveCommonTableExpressionSelectSyntax syntax => [Sql99SelectCTESyntax syntax] -> syntax -> syntax
class IsSql92SelectSyntax select => IsSql99SelectSyntax select
class IsSql92DataTypeSyntax dataType => IsSql99DataTypeSyntax dataType
characterLargeObjectType :: IsSql99DataTypeSyntax dataType => dataType
binaryLargeObjectType :: IsSql99DataTypeSyntax dataType => dataType
booleanType :: IsSql99DataTypeSyntax dataType => dataType
arrayType :: IsSql99DataTypeSyntax dataType => dataType -> Int -> dataType
rowType :: IsSql99DataTypeSyntax dataType => [(Text, dataType)] -> dataType


-- | Modular finally tagless extension of SQL99 and SQL92 syntaxes for
--   various SQL2003 core and optional features.
module Database.Beam.Backend.SQL.SQL2003
class IsSql92FromSyntax from => IsSql2003FromSyntax from where {
    type family Sql2003FromSampleMethodSyntax from :: Type;
}
fromTableSample :: IsSql2003FromSyntax from => Sql92FromTableSourceSyntax from -> Sql2003FromSampleMethodSyntax from -> Maybe Double -> Maybe Integer -> Maybe Text -> from

-- | Optional SQL2003 "Elementary OLAP operations" T611 support
class IsSql92OrderingSyntax ord => IsSql2003OrderingElementaryOLAPOperationsSyntax ord
nullsFirstOrdering :: IsSql2003OrderingElementaryOLAPOperationsSyntax ord => ord -> ord
nullsLastOrdering :: IsSql2003OrderingElementaryOLAPOperationsSyntax ord => ord -> ord
class (IsSql99ExpressionSyntax expr, IsSql2003WindowFrameSyntax (Sql2003ExpressionWindowFrameSyntax expr)) => IsSql2003ExpressionSyntax expr where {
    type family Sql2003ExpressionWindowFrameSyntax expr :: Type;
}
overE :: IsSql2003ExpressionSyntax expr => expr -> Sql2003ExpressionWindowFrameSyntax expr -> expr
rowNumberE :: IsSql2003ExpressionSyntax expr => expr

-- | Optional SQL2003 "Elementary OLAP operations" T611 support
class IsSql2003ExpressionSyntax expr => IsSql2003ExpressionElementaryOLAPOperationsSyntax expr
filterAggE :: IsSql2003ExpressionElementaryOLAPOperationsSyntax expr => expr -> expr -> expr
rankAggE :: IsSql2003ExpressionElementaryOLAPOperationsSyntax expr => expr

-- | Optional SQL2003 "Advanced OLAP operations" T612 support
class IsSql2003ExpressionSyntax expr => IsSql2003ExpressionAdvancedOLAPOperationsSyntax expr
percentRankAggE :: IsSql2003ExpressionAdvancedOLAPOperationsSyntax expr => expr
denseRankAggE :: IsSql2003ExpressionAdvancedOLAPOperationsSyntax expr => expr
cumeDistAggE :: IsSql2003ExpressionAdvancedOLAPOperationsSyntax expr => expr

-- | Optional SQL2003 "BINARY AND VARBINARY data type" T021 support
class IsSql99DataTypeSyntax dataType => IsSql2003BinaryAndVarBinaryDataTypeSyntax dataType
binaryType :: IsSql2003BinaryAndVarBinaryDataTypeSyntax dataType => Maybe Word -> dataType
varBinaryType :: IsSql2003BinaryAndVarBinaryDataTypeSyntax dataType => Maybe Word -> dataType
class IsSql2003WindowFrameBoundsSyntax (Sql2003WindowFrameBoundsSyntax frame) => IsSql2003WindowFrameSyntax frame where {
    type family Sql2003WindowFrameExpressionSyntax frame :: Type;
    type family Sql2003WindowFrameOrderingSyntax frame :: Type;
    type family Sql2003WindowFrameBoundsSyntax frame :: Type;
}
frameSyntax :: IsSql2003WindowFrameSyntax frame => Maybe [Sql2003WindowFrameExpressionSyntax frame] -> Maybe [Sql2003WindowFrameOrderingSyntax frame] -> Maybe (Sql2003WindowFrameBoundsSyntax frame) -> frame
class IsSql2003WindowFrameBoundSyntax (Sql2003WindowFrameBoundsBoundSyntax bounds) => IsSql2003WindowFrameBoundsSyntax bounds where {
    type family Sql2003WindowFrameBoundsBoundSyntax bounds :: Type;
}
fromToBoundSyntax :: IsSql2003WindowFrameBoundsSyntax bounds => Sql2003WindowFrameBoundsBoundSyntax bounds -> Maybe (Sql2003WindowFrameBoundsBoundSyntax bounds) -> bounds
class IsSql2003WindowFrameBoundSyntax bound
unboundedSyntax :: IsSql2003WindowFrameBoundSyntax bound => bound
nrowsBoundSyntax :: IsSql2003WindowFrameBoundSyntax bound => Int -> bound

-- | Optional SQL2003 "Enhanced numeric functions" T621 support
class IsSql99ExpressionSyntax expr => IsSql2003EnhancedNumericFunctionsExpressionSyntax expr
lnE :: IsSql2003EnhancedNumericFunctionsExpressionSyntax expr => expr -> expr
expE :: IsSql2003EnhancedNumericFunctionsExpressionSyntax expr => expr -> expr
sqrtE :: IsSql2003EnhancedNumericFunctionsExpressionSyntax expr => expr -> expr
ceilE :: IsSql2003EnhancedNumericFunctionsExpressionSyntax expr => expr -> expr
floorE :: IsSql2003EnhancedNumericFunctionsExpressionSyntax expr => expr -> expr
powerE :: IsSql2003EnhancedNumericFunctionsExpressionSyntax expr => expr -> expr -> expr
class IsSql99AggregationExpressionSyntax agg => IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg
stddevPopE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg
stddevSampE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg
varPopE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg
varSampE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg
covarPopE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
covarSampE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
corrE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
regrSlopeE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
regrInterceptE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
regrCountE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
regrRSquaredE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
regrAvgXE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
regrAvgYE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
regrSXXE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
regrSXYE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg
regrSYYE :: IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax agg => Maybe (Sql92AggregationSetQuantifierSyntax agg) -> agg -> agg -> agg

-- | Optional SQL2003 "FIRST_VALUE and LAST_VALUE function" T616 support
class IsSql99AggregationExpressionSyntax agg => IsSql2003FirstValueAndLastValueExpressionSyntax agg
firstValueE :: IsSql2003FirstValueAndLastValueExpressionSyntax agg => agg -> agg
lastValueE :: IsSql2003FirstValueAndLastValueExpressionSyntax agg => agg -> agg

-- | Optional SQL2003 "NTILE function" T614 support
class IsSql99AggregationExpressionSyntax agg => IsSql2003NtileExpressionSyntax agg
ntileE :: IsSql2003NtileExpressionSyntax agg => agg -> agg

-- | Optional SQL2003 "NTH_VALUE function" T618 support
class IsSql99AggregationExpressionSyntax agg => IsSql2003NthValueExpressionSyntax agg
nthValueE :: IsSql2003NthValueExpressionSyntax agg => agg -> agg -> agg

-- | Optional SQL2003 "LEAD and LAG function" T615 support
class IsSql99AggregationExpressionSyntax agg => IsSql2003LeadAndLagExpressionSyntax agg
leadE :: IsSql2003LeadAndLagExpressionSyntax agg => agg -> Maybe agg -> Maybe agg -> agg
lagE :: IsSql2003LeadAndLagExpressionSyntax agg => agg -> Maybe agg -> Maybe agg -> agg

-- | Optional SQL2008 "BIGINT data type" T071 support
class IsSql99DataTypeSyntax dataType => IsSql2008BigIntDataTypeSyntax dataType
bigIntType :: IsSql2008BigIntDataTypeSyntax dataType => dataType
type Sql2003SanityCheck syntax = (Sql92ExpressionSyntax syntax ~ Sql2003WindowFrameExpressionSyntax (Sql2003ExpressionWindowFrameSyntax (Sql92ExpressionSyntax syntax)), Sql92SelectOrderingSyntax (Sql92SelectSyntax syntax) ~ Sql2003WindowFrameOrderingSyntax (Sql2003ExpressionWindowFrameSyntax (Sql92ExpressionSyntax syntax)))


-- | This module implements an AST type for SQL92. It allows us to realize
--   the call structure of the builders defined in
--   <a>Database.Beam.Backend.SQL.SQL92</a>
module Database.Beam.Backend.SQL.AST
data Command
SelectCommand :: Select -> Command
InsertCommand :: Insert -> Command
UpdateCommand :: Update -> Command
DeleteCommand :: Delete -> Command
data Select
Select :: SelectTable -> [Ordering] -> Maybe Integer -> Select
[selectTable] :: Select -> SelectTable
[selectOrdering] :: Select -> [Ordering]
[selectLimit, selectOffset] :: Select -> Maybe Integer
data SelectTable
SelectTable :: Maybe SetQuantifier -> Projection -> Maybe From -> Maybe Expression -> Maybe Grouping -> Maybe Expression -> SelectTable
[selectQuantifier] :: SelectTable -> Maybe SetQuantifier
[selectProjection] :: SelectTable -> Projection
[selectFrom] :: SelectTable -> Maybe From
[selectWhere] :: SelectTable -> Maybe Expression
[selectGrouping] :: SelectTable -> Maybe Grouping
[selectHaving] :: SelectTable -> Maybe Expression
UnionTables :: Bool -> SelectTable -> SelectTable -> SelectTable
IntersectTables :: Bool -> SelectTable -> SelectTable -> SelectTable
ExceptTable :: Bool -> SelectTable -> SelectTable -> SelectTable
data Insert
Insert :: TableName -> [Text] -> InsertValues -> Insert
[insertTable] :: Insert -> TableName
[insertFields] :: Insert -> [Text]
[insertValues] :: Insert -> InsertValues
data InsertValues
InsertValues :: [[Expression]] -> InsertValues
[insertValuesExpressions] :: InsertValues -> [[Expression]]
InsertSelect :: Select -> InsertValues
[insertSelectStmt] :: InsertValues -> Select
data Update
Update :: TableName -> [(FieldName, Expression)] -> Maybe Expression -> Update
[updateTable] :: Update -> TableName
[updateFields] :: Update -> [(FieldName, Expression)]
[updateWhere] :: Update -> Maybe Expression
data Delete
Delete :: TableName -> Maybe Text -> Maybe Expression -> Delete
[deleteTable] :: Delete -> TableName
[deleteAlias] :: Delete -> Maybe Text
[deleteWhere] :: Delete -> Maybe Expression
data FieldName
QualifiedField :: Text -> Text -> FieldName
UnqualifiedField :: Text -> FieldName
data ComparatorQuantifier
ComparatorQuantifierAny :: ComparatorQuantifier
ComparatorQuantifierAll :: ComparatorQuantifier
data ExtractField
ExtractFieldTimeZoneHour :: ExtractField
ExtractFieldTimeZoneMinute :: ExtractField
ExtractFieldDateTimeYear :: ExtractField
ExtractFieldDateTimeMonth :: ExtractField
ExtractFieldDateTimeDay :: ExtractField
ExtractFieldDateTimeHour :: ExtractField
ExtractFieldDateTimeMinute :: ExtractField
ExtractFieldDateTimeSecond :: ExtractField
data DataType
DataTypeChar :: Bool -> Maybe Word -> Maybe Text -> DataType
DataTypeNationalChar :: Bool -> Maybe Word -> DataType
DataTypeBit :: Bool -> Maybe Word -> DataType
DataTypeNumeric :: Maybe (Word, Maybe Word) -> DataType
DataTypeDecimal :: Maybe (Word, Maybe Word) -> DataType
DataTypeInteger :: DataType
DataTypeSmallInt :: DataType
DataTypeBigInt :: DataType
DataTypeFloat :: Maybe Word -> DataType
DataTypeReal :: DataType
DataTypeDoublePrecision :: DataType
DataTypeDate :: DataType
DataTypeTime :: Maybe Word -> Bool -> DataType
DataTypeTimeStamp :: Maybe Word -> Bool -> DataType
DataTypeInterval :: ExtractField -> DataType
DataTypeIntervalFromTo :: ExtractField -> ExtractField -> DataType
DataTypeBoolean :: DataType
DataTypeBinaryLargeObject :: DataType
DataTypeCharacterLargeObject :: DataType
DataTypeArray :: DataType -> Int -> DataType
DataTypeRow :: [(Text, DataType)] -> DataType
DataTypeDomain :: Text -> DataType
data SetQuantifier
SetQuantifierAll :: SetQuantifier
SetQuantifierDistinct :: SetQuantifier
data Expression
ExpressionValue :: Value -> Expression
ExpressionDefault :: Expression
ExpressionRow :: [Expression] -> Expression
ExpressionIn :: Expression -> [Expression] -> Expression
ExpressionInSelect :: Expression -> Select -> Expression
ExpressionIsNull :: Expression -> Expression
ExpressionIsNotNull :: Expression -> Expression
ExpressionIsTrue :: Expression -> Expression
ExpressionIsNotTrue :: Expression -> Expression
ExpressionIsFalse :: Expression -> Expression
ExpressionIsNotFalse :: Expression -> Expression
ExpressionIsUnknown :: Expression -> Expression
ExpressionIsNotUnknown :: Expression -> Expression
ExpressionCase :: [(Expression, Expression)] -> Expression -> Expression
ExpressionCoalesce :: [Expression] -> Expression
ExpressionNullIf :: Expression -> Expression -> Expression
ExpressionFieldName :: FieldName -> Expression
ExpressionBetween :: Expression -> Expression -> Expression -> Expression
ExpressionBinOp :: Text -> Expression -> Expression -> Expression
ExpressionCompOp :: Text -> Maybe ComparatorQuantifier -> Expression -> Expression -> Expression
ExpressionUnOp :: Text -> Expression -> Expression
ExpressionPosition :: Expression -> Expression -> Expression
ExpressionCast :: Expression -> DataType -> Expression
ExpressionExtract :: ExtractField -> Expression -> Expression
ExpressionCharLength :: Expression -> Expression
ExpressionOctetLength :: Expression -> Expression
ExpressionBitLength :: Expression -> Expression
ExpressionAbs :: Expression -> Expression
ExpressionLower :: Expression -> Expression
ExpressionUpper :: Expression -> Expression
ExpressionTrim :: Expression -> Expression
ExpressionNamedFunction :: Text -> Expression
ExpressionFunctionCall :: Expression -> [Expression] -> Expression
ExpressionInstanceField :: Expression -> Text -> Expression
ExpressionRefField :: Expression -> Text -> Expression
ExpressionCountAll :: Expression
ExpressionAgg :: Text -> Maybe SetQuantifier -> [Expression] -> Expression
ExpressionBuiltinFunction :: Text -> [Expression] -> Expression
ExpressionSubquery :: Select -> Expression
ExpressionUnique :: Select -> Expression
ExpressionDistinct :: Select -> Expression
ExpressionExists :: Select -> Expression
ExpressionOver :: Expression -> WindowFrame -> Expression
ExpressionCurrentTimestamp :: Expression
newtype Projection
ProjExprs :: [(Expression, Maybe Text)] -> Projection
data Ordering
OrderingAsc :: Expression -> Ordering
OrderingDesc :: Expression -> Ordering
newtype Grouping
Grouping :: [Expression] -> Grouping
data TableName
TableName :: Maybe Text -> Text -> TableName
data TableSource
TableNamed :: TableName -> TableSource
TableFromSubSelect :: Select -> TableSource
TableFromValues :: [[Expression]] -> TableSource
data From
FromTable :: TableSource -> Maybe (Text, Maybe [Text]) -> From
InnerJoin :: From -> From -> Maybe Expression -> From
LeftJoin :: From -> From -> Maybe Expression -> From
RightJoin :: From -> From -> Maybe Expression -> From
OuterJoin :: From -> From -> Maybe Expression -> From
data Value
[Value] :: (Show a, Eq a, Typeable a) => a -> Value
data WindowFrame
WindowFrame :: Maybe [Expression] -> Maybe [Ordering] -> Maybe WindowFrameBounds -> WindowFrame
[windowFramePartitions] :: WindowFrame -> Maybe [Expression]
[windowFrameOrdering] :: WindowFrame -> Maybe [Ordering]
[windowFrameBounds] :: WindowFrame -> Maybe WindowFrameBounds
data WindowFrameBounds
WindowFrameBounds :: WindowFrameBound -> Maybe WindowFrameBound -> WindowFrameBounds
[boundsFrom] :: WindowFrameBounds -> WindowFrameBound
[boundsTo] :: WindowFrameBounds -> Maybe WindowFrameBound
data WindowFrameBound
WindowFrameUnbounded :: WindowFrameBound
WindowFrameBoundNRows :: Int -> WindowFrameBound
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.FieldName
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.FieldName
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.ComparatorQuantifier
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.ComparatorQuantifier
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.ExtractField
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.ExtractField
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.DataType
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.DataType
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.SetQuantifier
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.SetQuantifier
instance GHC.Classes.Ord Database.Beam.Backend.SQL.AST.TableName
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.TableName
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.TableName
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.WindowFrameBound
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.WindowFrameBound
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.WindowFrameBounds
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.WindowFrameBounds
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.Projection
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.Projection
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.Grouping
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.Grouping
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.TableSource
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.TableSource
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.From
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.From
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.SelectTable
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.SelectTable
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.Select
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.Select
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.Expression
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.Expression
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.Ordering
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.Ordering
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.WindowFrame
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.WindowFrame
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.Delete
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.Delete
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.Update
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.Update
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.InsertValues
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.InsertValues
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.Insert
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.Insert
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.Command
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.Command
instance Database.Beam.Backend.SQL.SQL92.IsSql92Syntax Database.Beam.Backend.SQL.AST.Command
instance Database.Beam.Backend.SQL.SQL92.IsSql92InsertSyntax Database.Beam.Backend.SQL.AST.Insert
instance Database.Beam.Backend.SQL.SQL92.IsSql92InsertValuesSyntax Database.Beam.Backend.SQL.AST.InsertValues
instance Database.Beam.Backend.SQL.SQL92.IsSql92UpdateSyntax Database.Beam.Backend.SQL.AST.Update
instance Database.Beam.Backend.SQL.SQL92.IsSql92DeleteSyntax Database.Beam.Backend.SQL.AST.Delete
instance Database.Beam.Backend.SQL.SQL92.IsSql92SelectSyntax Database.Beam.Backend.SQL.AST.Select
instance Database.Beam.Backend.SQL.SQL92.IsSql92SelectTableSyntax Database.Beam.Backend.SQL.AST.SelectTable
instance Database.Beam.Backend.SQL.SQL92.IsSql92ExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL99.IsSql99FunctionExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL99.IsSql99ExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL92.IsSql92AggregationExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL99.IsSql99AggregationExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003EnhancedNumericFunctionsExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003NtileExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003LeadAndLagExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003NthValueExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003ExpressionSyntax Database.Beam.Backend.SQL.AST.Expression
instance Database.Beam.Backend.SQL.SQL92.IsSql92ProjectionSyntax Database.Beam.Backend.SQL.AST.Projection
instance Database.Beam.Backend.SQL.SQL92.IsSql92OrderingSyntax Database.Beam.Backend.SQL.AST.Ordering
instance Database.Beam.Backend.SQL.SQL92.IsSql92GroupingSyntax Database.Beam.Backend.SQL.AST.Grouping
instance Database.Beam.Backend.SQL.SQL92.IsSql92TableSourceSyntax Database.Beam.Backend.SQL.AST.TableSource
instance Database.Beam.Backend.SQL.SQL92.IsSql92FromSyntax Database.Beam.Backend.SQL.AST.From
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003WindowFrameSyntax Database.Beam.Backend.SQL.AST.WindowFrame
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003WindowFrameBoundsSyntax Database.Beam.Backend.SQL.AST.WindowFrameBounds
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003WindowFrameBoundSyntax Database.Beam.Backend.SQL.AST.WindowFrameBound
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Int.Int16
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Int.Int32
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Int.Int64
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Word.Word16
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Word.Word32
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Word.Word64
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Integer.Type.Integer
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Base.String
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value Data.Text.Internal.Text
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value Data.ByteString.Internal.ByteString
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value Data.Time.Clock.Internal.UTCTime.UTCTime
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value Data.Time.Calendar.Days.Day
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value Database.Beam.Backend.SQL.Types.SqlNull
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Types.Double
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Types.Bool
instance (TypeError ...) => Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Types.Int
instance (TypeError ...) => Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value GHC.Types.Word
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value x => Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.AST.Value (GHC.Maybe.Maybe x)
instance GHC.Classes.Eq Database.Beam.Backend.SQL.AST.Value
instance GHC.Show.Show Database.Beam.Backend.SQL.AST.Value
instance Database.Beam.Backend.SQL.SQL92.IsSql92TableNameSyntax Database.Beam.Backend.SQL.AST.TableName
instance Database.Beam.Backend.SQL.SQL92.IsSql92AggregationSetQuantifierSyntax Database.Beam.Backend.SQL.AST.SetQuantifier
instance Database.Beam.Backend.SQL.SQL92.IsSql92DataTypeSyntax Database.Beam.Backend.SQL.AST.DataType
instance Database.Beam.Backend.SQL.SQL99.IsSql99DataTypeSyntax Database.Beam.Backend.SQL.AST.DataType
instance Database.Beam.Backend.SQL.SQL2003.IsSql2008BigIntDataTypeSyntax Database.Beam.Backend.SQL.AST.DataType
instance Database.Beam.Backend.SQL.SQL92.IsSql92ExtractFieldSyntax Database.Beam.Backend.SQL.AST.ExtractField
instance Database.Beam.Backend.SQL.SQL92.IsSql92QuantifierSyntax Database.Beam.Backend.SQL.AST.ComparatorQuantifier
instance Database.Beam.Backend.SQL.SQL92.IsSql92FieldNameSyntax Database.Beam.Backend.SQL.AST.FieldName

module Database.Beam.Backend.SQL

-- | A class that ties together a monad with a particular backend
--   
--   Provided here is a low-level interface for executing commands. The
--   'run*' functions are wrapped by the appropriate functions in
--   <a>Query</a>.
--   
--   This interface is very high-level and isn't meant to expose the full
--   power of the underlying database. Namely, it only supports simple data
--   retrieval strategies. More complicated strategies (for example,
--   Postgres's <tt>COPY</tt>) are supported in individual backends. See
--   the documentation of those backends for more details.
class (BeamBackend be, Monad m) => MonadBeam be m | m -> be

-- | Run a query determined by the given syntax, providing an action that
--   will be called to consume the results from the database (if any). The
--   action will get a reader action that can be used to fetch the next
--   row. When this reader action returns <a>Nothing</a>, there are no rows
--   left to consume. When the reader action returns, the database result
--   is freed.
runReturningMany :: (MonadBeam be m, FromBackendRow be x) => BeamSqlBackendSyntax be -> (m (Maybe x) -> m a) -> m a

-- | Run the given command and don't consume any results. Useful for DML
--   statements like INSERT, UPDATE, and DELETE, or DDL statements.
runNoReturn :: MonadBeam be m => BeamSqlBackendSyntax be -> m ()

-- | Run the given command and fetch the unique result. The result is
--   <a>Nothing</a> if either no results are returned or more than one
--   result is returned.
runReturningOne :: (MonadBeam be m, FromBackendRow be x) => BeamSqlBackendSyntax be -> m (Maybe x)

-- | Run the given command and fetch the first result. The result is
--   <a>Nothing</a> if no results are returned. This is not guaranteed to
--   automatically limit the query to one result.
runReturningFirst :: (MonadBeam be m, FromBackendRow be x) => BeamSqlBackendSyntax be -> m (Maybe x)

-- | Run the given command, collect all the results, and return them as a
--   list. May be more convenient than <a>runReturningMany</a>, but reads
--   the entire result set into memory.
runReturningList :: (MonadBeam be m, FromBackendRow be x) => BeamSqlBackendSyntax be -> m [x]

-- | Class for all Beam SQL backends
class (BeamBackend be, IsSql92Syntax (BeamSqlBackendSyntax be), Sql92SanityCheck (BeamSqlBackendSyntax be), HasSqlValueSyntax (BeamSqlBackendValueSyntax be) Bool, HasSqlValueSyntax (BeamSqlBackendValueSyntax be) SqlNull, Eq (BeamSqlBackendExpressionSyntax be)) => BeamSqlBackend be
type family BeamSqlBackendSyntax be :: Type

-- | Fake backend that cannot deserialize anything, but is useful for
--   testing
data MockSqlBackend syntax

-- | Type class for things which are text-like in this backend
class BeamSqlBackendIsString be text
type BeamSql99ExpressionBackend be = IsSql99ExpressionSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSql99AggregationBackend be = IsSql99AggregationExpressionSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSql99ConcatExpressionBackend be = IsSql99ConcatExpressionSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSql99CommonTableExpressionBackend be = (BeamSqlBackend be, IsSql99CommonTableExpressionSelectSyntax (BeamSqlBackendSelectSyntax be), IsSql99CommonTableExpressionSyntax (BeamSql99BackendCTESyntax be), Sql99CTESelectSyntax (BeamSql99BackendCTESyntax be) ~ BeamSqlBackendSelectSyntax be)
type BeamSql99RecursiveCTEBackend be = (BeamSql99CommonTableExpressionBackend be, IsSql99RecursiveCommonTableExpressionSelectSyntax (BeamSqlBackendSelectSyntax be))
type BeamSql2003ExpressionBackend be = (IsSql2003ExpressionSyntax (BeamSqlBackendExpressionSyntax be), Sql2003SanityCheck (BeamSqlBackendSyntax be))
type BeamSqlT021Backend be = IsSql2003BinaryAndVarBinaryDataTypeSyntax (BeamSqlBackendCastTargetSyntax be)
type BeamSqlT071Backend be = IsSql2008BigIntDataTypeSyntax (BeamSqlBackendCastTargetSyntax be)
type BeamSqlT611Backend be = IsSql2003ExpressionElementaryOLAPOperationsSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlT612Backend be = IsSql2003ExpressionAdvancedOLAPOperationsSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlT614Backend be = IsSql2003NtileExpressionSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlT615Backend be = IsSql2003LeadAndLagExpressionSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlT616Backend be = IsSql2003FirstValueAndLastValueExpressionSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlT618Backend be = IsSql2003NthValueExpressionSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlT621Backend be = (IsSql2003EnhancedNumericFunctionsExpressionSyntax (BeamSqlBackendExpressionSyntax be), IsSql2003EnhancedNumericFunctionsAggregationExpressionSyntax (BeamSqlBackendExpressionSyntax be))
type BeamSql99DataTypeBackend be = (BeamSqlBackend be, IsSql99DataTypeSyntax (BeamSqlBackendCastTargetSyntax be))
type BeamSqlBackendSupportsOuterJoin be = IsSql92FromOuterJoinSyntax (BeamSqlBackendFromSyntax be)
type BeamSqlBackendSelectSyntax be = Sql92SelectSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendInsertSyntax be = Sql92InsertSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendInsertValuesSyntax be = Sql92InsertValuesSyntax (BeamSqlBackendInsertSyntax be)
type BeamSqlBackendUpdateSyntax be = Sql92UpdateSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendDeleteSyntax be = Sql92DeleteSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendCastTargetSyntax be = Sql92ExpressionCastTargetSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlBackendSelectTableSyntax be = Sql92SelectSelectTableSyntax (BeamSqlBackendSelectSyntax be)
type BeamSqlBackendAggregationQuantifierSyntax be = Sql92AggregationSetQuantifierSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlBackendSetQuantifierSyntax be = Sql92SelectTableSetQuantifierSyntax (BeamSqlBackendSelectTableSyntax be)
type BeamSqlBackendFromSyntax be = Sql92SelectFromSyntax (BeamSqlBackendSelectSyntax be)
type BeamSqlBackendTableNameSyntax be = Sql92TableSourceTableNameSyntax (Sql92FromTableSourceSyntax (BeamSqlBackendFromSyntax be))
type BeamSqlBackendExpressionSyntax be = Sql92ExpressionSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendDataTypeSyntax be = Sql92ExpressionCastTargetSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlBackendFieldNameSyntax be = Sql92ExpressionFieldNameSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlBackendExpressionQuantifierSyntax be = Sql92ExpressionQuantifierSyntax (Sql92ExpressionSyntax (BeamSqlBackendSyntax be))
type BeamSqlBackendValueSyntax be = Sql92ValueSyntax (BeamSqlBackendSyntax be)
type BeamSqlBackendOrderingSyntax be = Sql92SelectOrderingSyntax (BeamSqlBackendSelectSyntax be)
type BeamSqlBackendGroupingSyntax be = Sql92SelectTableGroupingSyntax (BeamSqlBackendSelectTableSyntax be)
type BeamSqlBackendWindowFrameSyntax be = Sql2003ExpressionWindowFrameSyntax (BeamSqlBackendExpressionSyntax be)
type BeamSqlBackendWindowFrameBoundsSyntax be = Sql2003WindowFrameBoundsSyntax (BeamSqlBackendWindowFrameSyntax be)
type BeamSqlBackendWindowFrameBoundSyntax be = Sql2003WindowFrameBoundsBoundSyntax (BeamSqlBackendWindowFrameBoundsSyntax be)
type BeamSql99BackendCTESyntax be = Sql99SelectCTESyntax (BeamSqlBackendSelectSyntax be)
type BeamSqlBackendCanSerialize be = HasSqlValueSyntax (BeamSqlBackendValueSyntax be)
type BeamSqlBackendCanDeserialize be = FromBackendRow be
type BeamSqlBackendSupportsDataType be x = (BeamSqlBackendCanDeserialize be x, BeamSqlBackendCanSerialize be x)
instance (Database.Beam.Backend.SQL.SQL92.IsSql92Syntax syntax, Database.Beam.Backend.SQL.SQL92.Sql92SanityCheck syntax, Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax (Database.Beam.Backend.SQL.SQL92.Sql92ValueSyntax syntax) GHC.Types.Bool, Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax (Database.Beam.Backend.SQL.SQL92.Sql92ValueSyntax syntax) Database.Beam.Backend.SQL.Types.SqlNull, GHC.Classes.Eq (Database.Beam.Backend.SQL.SQL92.Sql92ExpressionSyntax syntax)) => Database.Beam.Backend.SQL.BeamSqlBackend (Database.Beam.Backend.SQL.MockSqlBackend syntax)
instance forall k1 k2 (be :: k1) t (tag :: k2). Database.Beam.Backend.SQL.BeamSqlBackendIsString be t => Database.Beam.Backend.SQL.BeamSqlBackendIsString be (Data.Tagged.Tagged tag t)
instance forall k (cmd :: k). Database.Beam.Backend.SQL.BeamSqlBackendIsString (Database.Beam.Backend.SQL.MockSqlBackend cmd) Data.Text.Internal.Text
instance forall k (cmd :: k). Database.Beam.Backend.SQL.BeamSqlBackendIsString (Database.Beam.Backend.SQL.MockSqlBackend cmd) [GHC.Types.Char]
instance forall k (a :: k). Database.Beam.Backend.SQL.Trivial a
instance forall k (syntax :: k). Database.Beam.Backend.Types.BeamBackend (Database.Beam.Backend.SQL.MockSqlBackend syntax)
instance Database.Beam.Backend.SQL.MonadBeam be m => Database.Beam.Backend.SQL.MonadBeam be (Control.Monad.Trans.Except.ExceptT e m)
instance Database.Beam.Backend.SQL.MonadBeam be m => Database.Beam.Backend.SQL.MonadBeam be (Control.Monad.Trans.Cont.ContT r m)
instance Database.Beam.Backend.SQL.MonadBeam be m => Database.Beam.Backend.SQL.MonadBeam be (Control.Monad.Trans.Reader.ReaderT r m)
instance Database.Beam.Backend.SQL.MonadBeam be m => Database.Beam.Backend.SQL.MonadBeam be (Control.Monad.Trans.State.Lazy.StateT s m)
instance Database.Beam.Backend.SQL.MonadBeam be m => Database.Beam.Backend.SQL.MonadBeam be (Control.Monad.Trans.State.Strict.StateT s m)
instance (Database.Beam.Backend.SQL.MonadBeam be m, GHC.Base.Monoid s) => Database.Beam.Backend.SQL.MonadBeam be (Control.Monad.Trans.Writer.Lazy.WriterT s m)
instance (Database.Beam.Backend.SQL.MonadBeam be m, GHC.Base.Monoid s) => Database.Beam.Backend.SQL.MonadBeam be (Control.Monad.Trans.Writer.Strict.WriterT s m)
instance (Database.Beam.Backend.SQL.MonadBeam be m, GHC.Base.Monoid w) => Database.Beam.Backend.SQL.MonadBeam be (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Database.Beam.Backend.SQL.MonadBeam be m, GHC.Base.Monoid w) => Database.Beam.Backend.SQL.MonadBeam be (Control.Monad.Trans.RWS.Strict.RWST r w s m)


-- | Provides a syntax <a>SqlSyntaxBuilder</a> that uses a <a>Builder</a>
--   to construct SQL expressions as strings. Mainly serves as
--   documentation for how to write a syntax for backends. Note that,
--   although you can use this to turn most <tt>Q</tt> and
--   <tt>QGenExpr</tt>s into <a>ByteString</a> queries, it is <i>very
--   unwise</i> to ship these to the database. This module does not take
--   into account server-specific quoting. Some backends are very
--   particular to quoting, and shipping arbitrary <a>ByteString</a>s as
--   queries can expose you to SQL injection vulnerabilities. Always use
--   the provided backends to submit queries and data manipulation commands
--   to the database.
module Database.Beam.Backend.SQL.Builder

-- | The main syntax. A wrapper over <a>Builder</a>
newtype SqlSyntaxBuilder
SqlSyntaxBuilder :: Builder -> SqlSyntaxBuilder
[buildSql] :: SqlSyntaxBuilder -> Builder
buildSepBy :: Builder -> [Builder] -> Builder
quoteSql :: Text -> Builder
renderSql :: SqlSyntaxBuilder -> String
instance GHC.Show.Show Database.Beam.Backend.SQL.Builder.SqlWindowFrameBound
instance Control.Monad.Fail.MonadFail Database.Beam.Backend.SQL.Builder.SqlSyntaxM
instance Control.Monad.IO.Class.MonadIO Database.Beam.Backend.SQL.Builder.SqlSyntaxM
instance GHC.Base.Monad Database.Beam.Backend.SQL.Builder.SqlSyntaxM
instance GHC.Base.Functor Database.Beam.Backend.SQL.Builder.SqlSyntaxM
instance GHC.Base.Applicative Database.Beam.Backend.SQL.Builder.SqlSyntaxM
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003WindowFrameBoundsSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003WindowFrameBoundSyntax Database.Beam.Backend.SQL.Builder.SqlWindowFrameBound
instance Data.Hashable.Class.Hashable Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance GHC.Show.Show Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance GHC.Classes.Eq Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance GHC.Base.Semigroup Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance GHC.Base.Monoid Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92Syntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92SelectSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92GroupingSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92SelectTableSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92InsertSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92InsertValuesSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92UpdateSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92DeleteSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92FieldNameSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92QuantifierSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92ExtractFieldSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92ExpressionSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL99.IsSql99FunctionExpressionSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL99.IsSql99ExpressionSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003ExpressionSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003WindowFrameSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003ExpressionElementaryOLAPOperationsSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL2003.IsSql2003ExpressionAdvancedOLAPOperationsSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92AggregationExpressionSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92AggregationSetQuantifierSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92ProjectionSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92OrderingSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92TableSourceSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92TableNameSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92FromSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.IsSql92DataTypeSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder GHC.Int.Int32
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder GHC.Types.Bool
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder Data.Text.Internal.Text
instance Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder Database.Beam.Backend.SQL.Types.SqlNull
instance (TypeError ...) => Database.Beam.Backend.SQL.SQL92.HasSqlValueSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder GHC.Types.Int

module Database.Beam.Backend


-- | Convenience methods for constructing backend-agnostic applications
module Database.Beam.Backend.URI
data BeamResourceNotFound
BeamResourceNotFound :: BeamResourceNotFound
data BeamOpenURIInvalid
BeamOpenURIInvalid :: BeamOpenURIInvalid
data BeamOpenURIUnsupportedScheme
BeamOpenURIUnsupportedScheme :: String -> BeamOpenURIUnsupportedScheme
data BeamURIOpener c
[BeamURIOpener] :: c be hdl m -> (forall a. hdl -> m a -> IO a) -> (URI -> IO (hdl, IO ())) -> BeamURIOpener c
newtype BeamURIOpeners c
[BeamURIOpeners] :: Map String (BeamURIOpener c) -> BeamURIOpeners c
data OpenedBeamConnection c
[OpenedBeamConnection] :: {beamRunner :: forall a. hdl -> m a -> IO a, openedBeamDatabase :: c be hdl m, openedBeamHandle :: hdl, closeBeamConnection :: IO ()} -> OpenedBeamConnection c
mkUriOpener :: (forall a. hdl -> m a -> IO a) -> String -> (URI -> IO (hdl, IO ())) -> c be hdl m -> BeamURIOpeners c
withDbFromUri :: forall c a. BeamURIOpeners c -> String -> (forall be hdl m. (forall r. hdl -> m r -> IO r) -> c be hdl m -> m a) -> IO a
withDbConnection :: forall c a. BeamURIOpeners c -> String -> (forall be hdl m. (forall r. hdl -> m r -> IO r) -> c be hdl m -> hdl -> IO a) -> IO a
openDbConnection :: forall c. BeamURIOpeners c -> String -> IO (OpenedBeamConnection c)
findURIOpener :: BeamURIOpeners c -> String -> IO (URI, BeamURIOpener c)
instance GHC.Show.Show Database.Beam.Backend.URI.BeamResourceNotFound
instance GHC.Show.Show Database.Beam.Backend.URI.BeamOpenURIInvalid
instance GHC.Show.Show Database.Beam.Backend.URI.BeamOpenURIUnsupportedScheme
instance GHC.Base.Semigroup (Database.Beam.Backend.URI.BeamURIOpeners c)
instance GHC.Base.Monoid (Database.Beam.Backend.URI.BeamURIOpeners c)
instance GHC.Exception.Type.Exception Database.Beam.Backend.URI.BeamOpenURIUnsupportedScheme
instance GHC.Exception.Type.Exception Database.Beam.Backend.URI.BeamOpenURIInvalid
instance GHC.Exception.Type.Exception Database.Beam.Backend.URI.BeamResourceNotFound


-- | Defines a generic schema type that can be used to define schemas for
--   Beam tables
module Database.Beam.Schema.Tables

-- | Allows introspection into database types.
--   
--   All database types must be of kind '(Type -&gt; Type) -&gt; Type'. If
--   the type parameter is named <tt>f</tt>, each field must be of the type
--   of <tt>f</tt> applied to some type for which an
--   <a>IsDatabaseEntity</a> instance exists.
--   
--   The <tt>be</tt> type parameter is necessary so that the compiler can
--   ensure that backend-specific entities only work on the proper backend.
--   
--   Entities are documented under <a>the corresponding section</a> and in
--   the <a>manual</a>
class Database be db

-- | Default derived function. Do not implement this yourself.
--   
--   The idea is that, for any two databases over particular entity tags
--   <tt>f</tt> and <tt>g</tt>, if we can take any entity in <tt>f</tt> and
--   <tt>g</tt> to the corresponding entity in <tt>h</tt> (in the possibly
--   effectful applicative functor <tt>m</tt>), then we can transform the
--   two databases over <tt>f</tt> and <tt>g</tt> to a database in
--   <tt>h</tt>, within <tt>m</tt>.
--   
--   If that doesn't make sense, don't worry. This is mostly beam internal
zipTables :: (Database be db, Applicative m) => Proxy be -> (forall tbl. (IsDatabaseEntity be tbl, DatabaseEntityRegularRequirements be tbl) => f tbl -> g tbl -> m (h tbl)) -> db f -> db g -> m (db h)

-- | When parameterized by this entity tag, a database type will hold
--   meta-information on the Haskell mappings of database entities. Under
--   the hood, each entity type is transformed into its
--   <a>DatabaseEntityDescriptor</a> type. For tables this includes the
--   table name as well as the corresponding <a>TableSettings</a>, which
--   provides names for each column.
type DatabaseSettings be db = db (DatabaseEntity be db)
class RenamableWithRule (FieldRenamer (DatabaseEntityDescriptor be entityType)) => IsDatabaseEntity be entityType where {
    data family DatabaseEntityDescriptor be entityType :: Type;
    type family DatabaseEntityDefaultRequirements be entityType :: Constraint;
    type family DatabaseEntityRegularRequirements be entityType :: Constraint;
}
dbEntityName :: IsDatabaseEntity be entityType => Lens' (DatabaseEntityDescriptor be entityType) Text
dbEntitySchema :: IsDatabaseEntity be entityType => Traversal' (DatabaseEntityDescriptor be entityType) (Maybe Text)
dbEntityAuto :: (IsDatabaseEntity be entityType, DatabaseEntityDefaultRequirements be entityType) => Text -> DatabaseEntityDescriptor be entityType

-- | Represents a meta-description of a particular entityType. Mostly, a
--   wrapper around 'DatabaseEntityDescriptor be entityType', but carries
--   around the <a>IsDatabaseEntity</a> dictionary.
data DatabaseEntity be (db :: (Type -> Type) -> Type) entityType
[DatabaseEntity] :: IsDatabaseEntity be entityType => DatabaseEntityDescriptor be entityType -> DatabaseEntity be db entityType

-- | An entity tag for tables. See the documentation for <a>Table</a> or
--   consult the <a>manual</a> for more.
data TableEntity (tbl :: (Type -> Type) -> Type)
data ViewEntity (view :: (Type -> Type) -> Type)
data DomainTypeEntity (ty :: Type)
dbEntityDescriptor :: SimpleGetter (DatabaseEntity be db entityType) (DatabaseEntityDescriptor be entityType)

-- | A helper data type that lets you modify a database schema. Converts
--   all entities in the database into functions from that entity to
--   itself.
type DatabaseModification f be db = db (EntityModification f be)

-- | A newtype wrapper around 'f e -&gt; f e' (i.e., an endomorphism
--   between entity types in <tt>f</tt>). You usually want to use
--   <a>modifyTable</a> or another function to contstruct these for you.
newtype EntityModification f be e
EntityModification :: Endo (f e) -> EntityModification f be e

-- | A newtype wrapper around 'Columnar f a -&gt; Columnar f a' (i.e., an
--   endomorphism between <a>Columnar</a>s over <tt>f</tt>). You usually
--   want to use <a>fieldNamed</a> or the <a>IsString</a> instance to
--   rename the field, when 'f ~ TableField'
newtype FieldModification f a
FieldModification :: (Columnar f a -> Columnar f a) -> FieldModification f a

-- | Return a <a>DatabaseModification</a> that does nothing. This is useful
--   if you only want to rename one table. You can do
--   
--   <pre>
--   dbModification { tbl1 = modifyTable (\oldNm -&gt; "NewTableName") tableModification }
--   </pre>
dbModification :: forall f be db. Database be db => DatabaseModification f be db

-- | Return a table modification (for use with <a>modifyTable</a>) that
--   does nothing. Useful if you only want to change the table name, or if
--   you only want to modify a few fields.
--   
--   For example,
--   
--   <pre>
--   tableModification { field1 = "Column1" }
--   </pre>
--   
--   is a table modification (where 'f ~ TableField tbl') that changes the
--   column name of <tt>field1</tt> to <a>Column1</a>.
tableModification :: forall f tbl. Beamable tbl => tbl (FieldModification f)

-- | Modify a database according to a given modification. Most useful for
--   <a>DatabaseSettings</a> to change the name mappings of tables and
--   fields. For example, you can use this to modify the default names of a
--   table
--   
--   <pre>
--   db :: DatabaseSettings MyDb
--   db = defaultDbSettings `withDbModification`
--        dbModification {
--          -- Change default name "table1" to "Table_1". Change the name of "table1Field1" to "first_name"
--          table1 = modifyTable (\_ -&gt; "Table_1") (tableModification { table1Field1 = "first_name" }
--        }
--   </pre>
withDbModification :: forall db be entity. Database be db => db (entity be db) -> DatabaseModification (entity be db) be db -> db (entity be db)

-- | Modify a table according to the given field modifications. Invoked by
--   <a>modifyTable</a> to apply the modification in the database. Not used
--   as often in user code, but provided for completeness.
withTableModification :: Beamable tbl => tbl (FieldModification f) -> tbl f -> tbl f

-- | Provide an <a>EntityModification</a> for <a>TableEntity</a>s. Allows
--   you to modify the name of the table and provide a modification for
--   each field in the table. See the examples for
--   <a>withDbModification</a> for more.

-- | <i>Deprecated: Instead of 'modifyTable fTblNm fFields', use
--   'modifyEntityName _ &lt;&gt; modifyTableFields _'</i>
modifyTable :: (Beamable tbl, Table tbl) => (Text -> Text) -> tbl (FieldModification (TableField tbl)) -> EntityModification (DatabaseEntity be db) be (TableEntity tbl)

-- | Construct an <a>EntityModification</a> to rename any database entity
modifyEntityName :: IsDatabaseEntity be entity => (Text -> Text) -> EntityModification (DatabaseEntity be db) be entity

-- | Change the entity name without consulting the beam-assigned one
setEntityName :: IsDatabaseEntity be entity => Text -> EntityModification (DatabaseEntity be db) be entity

-- | Construct an <a>EntityModification</a> to rename the fields of a
--   <a>TableEntity</a>
modifyTableFields :: tbl (FieldModification (TableField tbl)) -> EntityModification (DatabaseEntity be db) be (TableEntity tbl)

-- | A field modification to rename the field. Also offered under the
--   <a>IsString</a> instance for 'FieldModification (TableField tbl) a'
--   for convenience.
fieldNamed :: Text -> FieldModification (TableField tbl) a

-- | Construct an <a>EntityModification</a> to set the schema of a database
--   entity
modifyEntitySchema :: IsDatabaseEntity be entity => (Maybe Text -> Maybe Text) -> EntityModification (DatabaseEntity be db) be entity
setEntitySchema :: IsDatabaseEntity be entity => Maybe Text -> EntityModification (DatabaseEntity be db) be entity

-- | Automatically provide names for tables, and descriptions for tables
--   (using <a>defTblFieldSettings</a>). Your database must implement
--   <a>Generic</a>, and must be auto-derivable. For more information on
--   name generation, see the <a>manual</a>
defaultDbSettings :: (Generic (DatabaseSettings be db), GAutoDbSettings (Rep (DatabaseSettings be db) ())) => DatabaseSettings be db
class RenamableWithRule mod
renamingFields :: RenamableWithRule mod => (NonEmpty Text -> Text) -> mod
class RenamableField f
renameField :: RenamableField f => Proxy f -> Proxy a -> (NonEmpty Text -> Text) -> Columnar f a -> Columnar f a
newtype FieldRenamer entity
FieldRenamer :: (entity -> entity) -> FieldRenamer entity
[withFieldRenamer] :: FieldRenamer entity -> entity -> entity
data Lenses (t :: (Type -> Type) -> Type) (f :: Type -> Type) x
data LensFor t x
[LensFor] :: Generic t => Lens' t x -> LensFor t x

-- | A type family that we use to "tag" columns in our table datatypes.
--   
--   This is what allows us to use the same table type to hold table data,
--   describe table settings, derive lenses, and provide expressions.
--   
--   The basic rules are
--   
--   <pre>
--   Columnar Identity x = x
--   </pre>
--   
--   Thus, any Beam table applied to <a>Identity</a> will yield a
--   simplified version of the data type, that contains just what you'd
--   expect.
--   
--   The <a>Nullable</a> type is used when referencing <a>PrimaryKey</a>s
--   that we want to include optionally. For example, if we have a table
--   with a <a>PrimaryKey</a>, like the following
--   
--   <pre>
--   data BeamTableT f = BeamTableT
--                     { _refToAnotherTable :: PrimaryKey AnotherTableT f
--                     , ... }
--   </pre>
--   
--   we would typically be required to provide values for the
--   <a>PrimaryKey</a> embedded into <tt>BeamTableT</tt>. We can use
--   <a>Nullable</a> to lift this constraint.
--   
--   <pre>
--   data BeamTableT f = BeamTableT
--                     { _refToAnotherTable :: PrimaryKey AnotherTableT (Nullable f)
--                     , ... }
--   </pre>
--   
--   Now we can use <tt>just_</tt> and <tt>nothing_</tt> to refer to this
--   table optionally. The embedded <a>PrimaryKey</a> in
--   <tt>_refToAnotherTable</tt> automatically has its fields converted
--   into <a>Maybe</a> using <a>Nullable</a>.
--   
--   The last <a>Columnar</a> rule is
--   
--   <pre>
--   Columnar f x = f x
--   </pre>
--   
--   Use this rule if you'd like to parameterize your table type over any
--   other functor. For example, this is used in the query modules to write
--   expressions such as 'TableT QExpr', which returns a table whose fields
--   have been turned into query expressions.
--   
--   The other rules are used within Beam to provide lenses and to expose
--   the inner structure of the data type.
type family Columnar (f :: Type -> Type) x

-- | A short type-alias for <a>Columnar</a>. May shorten your schema
--   definitions
type C f a = Columnar f a

-- | If you declare a function 'Columnar f a -&gt; b' and try to constrain
--   your function by a type class for <tt>f</tt>, GHC will complain,
--   because <tt>f</tt> is ambiguous in 'Columnar f a'. For example,
--   'Columnar Identity (Maybe a) ~ Maybe a' and 'Columnar (Nullable
--   Identity) a ~ Maybe a', so given a type 'Columnar f a', we cannot know
--   the type of <tt>f</tt>.
--   
--   Thus, if you need to know <tt>f</tt>, you can instead use
--   <a>Columnar'</a>. Since its a newtype, it carries around the
--   <tt>f</tt> paramater unambiguously. Internally, it simply wraps
--   'Columnar f a'
newtype Columnar' f a
Columnar' :: Columnar f a -> Columnar' f a

-- | Like <a>Compose</a>, but with an intermediate <a>Columnar</a>
newtype ComposeColumnar f g a
ComposeColumnar :: f (Columnar g a) -> ComposeColumnar f g a

-- | Support for NULLable Foreign Key references.
--   
--   <pre>
--   data MyTable f = MyTable
--                  { nullableRef :: PrimaryKey AnotherTable (Nullable f)
--                  , ... }
--                   deriving (Generic, Typeable)
--   </pre>
--   
--   See <tt>Columnar</tt> for more information.
data Nullable (c :: Type -> Type) x

-- | Metadata for a field of type <tt>ty</tt> in <tt>table</tt>.
--   
--   Essentially a wrapper over the field name, but with a phantom type
--   parameter, so that it forms an appropriate column tag.
--   
--   Usually you use the <a>defaultDbSettings</a> function to generate an
--   appropriate naming convention for you, and then modify it with
--   <a>withDbModification</a> if necessary. Under this scheme, the field n
--   be renamed using the <a>IsString</a> instance for <a>TableField</a>,
--   or the <a>fieldNamed</a> function.
data TableField (table :: (Type -> Type) -> Type) ty
TableField :: NonEmpty Text -> Text -> TableField (table :: (Type -> Type) -> Type) ty

-- | The path that led to this field. Each element is the haskell name of
--   the record field in which this table is stored.
[_fieldPath] :: TableField (table :: (Type -> Type) -> Type) ty -> NonEmpty Text

-- | The field name
[_fieldName] :: TableField (table :: (Type -> Type) -> Type) ty -> Text

-- | newtype mainly used to inspect the tag structure of a particular
--   <tt>Beamable</tt>. Prevents overlapping instances in some case.
--   Usually not used in end-user code.
data Exposed x

-- | Van Laarhoven lens to retrieve or set the field name from a
--   <a>TableField</a>.
fieldName :: Lens' (TableField table ty) Text
fieldPath :: Traversal' (TableField table ty) Text

-- | Represents a table that contains metadata on its fields. In
--   particular, each field of type 'Columnar f a' is transformed into
--   'TableField table a'. You can get or update the name of each field by
--   using the <a>fieldName</a> lens.
type TableSettings table = table (TableField table)

-- | The regular Haskell version of the table. Equivalent to 'tbl Identity'
type HaskellTable table = table Identity

-- | A form of <tt>table</tt> all fields <a>Ignored</a>. Useful as a
--   parameter to <a>zipTables</a> when you only care about one table.
type TableSkeleton table = table Ignored

-- | Column tag that ignores the type.
data Ignored x
Ignored :: Ignored x
class GFieldsFulfillConstraint (c :: Type -> Constraint) (exposed :: Type -> Type) withconstraint
gWithConstrainedFields :: GFieldsFulfillConstraint c exposed withconstraint => Proxy c -> Proxy exposed -> withconstraint ()
type FieldsFulfillConstraint (c :: Type -> Constraint) t = (Generic (t (HasConstraint c)), Generic (t Identity), Generic (t Exposed), GFieldsFulfillConstraint c (Rep (t Exposed)) (Rep (t (HasConstraint c))))
type FieldsFulfillConstraintNullable (c :: Type -> Constraint) t = (Generic (t (Nullable (HasConstraint c))), Generic (t (Nullable Identity)), Generic (t (Nullable Exposed)), GFieldsFulfillConstraint c (Rep (t (Nullable Exposed))) (Rep (t (Nullable (HasConstraint c)))))

-- | Carry a constraint instance and the value it applies to.
data WithConstraint (c :: Type -> Constraint) x
[WithConstraint] :: c x => x -> WithConstraint c x

-- | Carry a constraint instance.
data HasConstraint (c :: Type -> Constraint) x
[HasConstraint] :: c x => HasConstraint c x

-- | Class to automatically unwrap nested Nullables
class TagReducesTo f f' | f -> f'
reduceTag :: (TagReducesTo f f', Functor m) => (Columnar' f' a' -> m (Columnar' f' a')) -> Columnar' f a -> m (Columnar' f a)
type family ReplaceBaseTag tag f
withConstrainedFields :: forall c tbl. (FieldsFulfillConstraint c tbl, Beamable tbl) => tbl Identity -> tbl (WithConstraint c)
withConstraints :: forall c tbl. (Beamable tbl, FieldsFulfillConstraint c tbl) => tbl (HasConstraint c)
withNullableConstrainedFields :: forall c tbl. (FieldsFulfillConstraintNullable c tbl, Beamable tbl) => tbl (Nullable Identity) -> tbl (Nullable (WithConstraint c))
withNullableConstraints :: forall c tbl. (Beamable tbl, FieldsFulfillConstraintNullable c tbl) => tbl (Nullable (HasConstraint c))

-- | The big Kahuna! All beam tables implement this class.
--   
--   The kind of all table types is '(Type -&gt; Type) -&gt; Type'. This is
--   because all table types are actually <i>table type constructors</i>.
--   Every table type takes in another type constructor, called the
--   <i>column tag</i>, and uses that constructor to instantiate the column
--   types. See the documentation for <a>Columnar</a>.
--   
--   This class is mostly Generic-derivable. You need only specify a type
--   for the table's primary key and a method to extract the primary key
--   given the table.
--   
--   An example table:
--   
--   <pre>
--   data BlogPostT f = BlogPost
--                    { _blogPostSlug    :: Columnar f Text
--                    , _blogPostBody    :: Columnar f Text
--                    , _blogPostDate    :: Columnar f UTCTime
--                    , _blogPostAuthor  :: PrimaryKey AuthorT f
--                    , _blogPostTagline :: Columnar f (Maybe Text)
--                    , _blogPostImageGallery :: PrimaryKey ImageGalleryT (Nullable f) }
--                      deriving Generic
--   instance Beamable BlogPostT
--   instance Table BlogPostT where
--      data PrimaryKey BlogPostT f = BlogPostId (Columnar f Text) deriving Generic
--      primaryKey = BlogPostId . _blogPostSlug
--   instance Beamable (PrimaryKey BlogPostT)
--   </pre>
--   
--   We can interpret this as follows:
--   
--   <ul>
--   <li>The <tt>_blogPostSlug</tt>, <tt>_blogPostBody</tt>,
--   <tt>_blogPostDate</tt>, and <tt>_blogPostTagline</tt> fields are of
--   types <a>Text</a>, <a>Text</a>, <tt>UTCTime</tt>, and 'Maybe Text'
--   respectfully.</li>
--   <li>Since <tt>_blogPostSlug</tt>, <tt>_blogPostBody</tt>,
--   <tt>_blogPostDate</tt>, <tt>_blogPostAuthor</tt> must be provided
--   (i.e, they cannot contain <a>Nothing</a>), they will be given SQL NOT
--   NULL constraints. <tt>_blogPostTagline</tt> is declared <a>Maybe</a>
--   so <a>Nothing</a> will be stored as NULL in the database.
--   <tt>_blogPostImageGallery</tt> will be allowed to be empty because it
--   uses the <a>Nullable</a> tag modifier.</li>
--   <li><tt>blogPostAuthor</tt> references the <tt>AuthorT</tt> table (not
--   given here) and is required.</li>
--   <li><tt>blogPostImageGallery</tt> references the
--   <tt>ImageGalleryT</tt> table (not given here), but this relation is
--   not required (i.e., it may be <a>Nothing</a>. See
--   <a>Nullable</a>).</li>
--   </ul>
class (Typeable table, Beamable table, Beamable (PrimaryKey table)) => Table (table :: (Type -> Type) -> Type) where {
    
    -- | A data type representing the types of primary keys for this table. In
    --   order to play nicely with the default deriving mechanism, this type
    --   must be an instance of <a>Generic</a>.
    data family PrimaryKey table (column :: Type -> Type) :: Type;
}

-- | Given a table, this should return the PrimaryKey from the table. By
--   keeping this polymorphic over column, we ensure that the primary key
--   values come directly from the table (i.e., they can't be arbitrary
--   constants)
primaryKey :: Table table => table column -> PrimaryKey table column

-- | Provides a number of introspection routines for the beam library.
--   Allows us to "zip" tables with different column tags together. Always
--   instantiate an empty <a>Beamable</a> instance for tables, primary
--   keys, and any type that you would like to embed within either. See the
--   <a>manual</a> for more information on embedding.
class Beamable table
zipBeamFieldsM :: (Beamable table, Applicative m) => (forall a. Columnar' f a -> Columnar' g a -> m (Columnar' h a)) -> table f -> table g -> m (table h)
zipBeamFieldsM :: (Beamable table, HasBeamFields table f g h, Applicative m) => (forall a. Columnar' f a -> Columnar' g a -> m (Columnar' h a)) -> table f -> table g -> m (table h)
tblSkeleton :: Beamable table => TableSkeleton table
tblSkeleton :: (Beamable table, Generic (TableSkeleton table), GTableSkeleton (Rep (TableSkeleton table))) => TableSkeleton table
class Retaggable f x | x -> f where {
    type family Retag (tag :: (Type -> Type) -> Type -> Type) x :: Type;
}
retag :: Retaggable f x => (forall a. Columnar' f a -> Columnar' (tag f) a) -> x -> Retag tag x

-- | Products: encode multiple arguments to constructors
data ( (f :: k -> Type) :*: (g :: k -> Type) ) (p :: k)
(:*:) :: f p -> g p -> (:*:) (f :: k -> Type) (g :: k -> Type) (p :: k)
infixr 6 :*:
infixr 6 :*:

-- | Return a <a>TableSettings</a> for the appropriate <tt>table</tt> type
--   where each column has been given its default name. See the
--   <a>manual</a> for information on the default naming convention.
defTblFieldSettings :: (Generic (TableSettings table), GDefaultTableFieldSettings (Rep (TableSettings table) ())) => TableSettings table
tableValuesNeeded :: Beamable table => Proxy table -> Int

-- | Synonym for <a>primaryKey</a>
pk :: Table t => t f -> PrimaryKey t f
allBeamValues :: Beamable table => (forall a. Columnar' f a -> b) -> table f -> [b]
changeBeamRep :: Beamable table => (forall a. Columnar' f a -> Columnar' g a) -> table f -> table g
alongsideTable :: Beamable tbl => tbl f -> tbl g -> tbl (Columnar' f :*: Columnar' g)

-- | Produce the beam default field name for the given path
defaultFieldName :: NonEmpty Text -> Text
instance GHC.Base.Semigroup (Database.Beam.Schema.Tables.EntityModification f be e)
instance GHC.Base.Monoid (Database.Beam.Schema.Tables.EntityModification f be e)
instance GHC.Classes.Eq (Database.Beam.Schema.Tables.TableField table ty)
instance GHC.Show.Show (Database.Beam.Schema.Tables.TableField table ty)
instance (GHC.Generics.Selector f', Database.Beam.Schema.Tables.ChooseSubTableStrategy tbl sub GHC.Types.~ strategy, Database.Beam.Schema.Tables.SubTableStrategyImpl strategy f sub, Database.Beam.Schema.Tables.TagReducesTo f (Database.Beam.Schema.Tables.TableField tbl), Database.Beam.Schema.Tables.Beamable sub) => Database.Beam.Schema.Tables.GDefaultTableFieldSettings (GHC.Generics.S1 f' (GHC.Generics.K1 GHC.Generics.R (sub f)) p)
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Schema.Tables.IsDatabaseEntity be (Database.Beam.Schema.Tables.TableEntity tbl)
instance (Database.Beam.Schema.Tables.Table rel, GHC.Generics.Generic (rel (Database.Beam.Schema.Tables.TableField rel)), Database.Beam.Schema.Tables.TagReducesTo f (Database.Beam.Schema.Tables.TableField tbl), Database.Beam.Schema.Tables.GDefaultTableFieldSettings (GHC.Generics.Rep (rel (Database.Beam.Schema.Tables.TableField rel)) ())) => Database.Beam.Schema.Tables.SubTableStrategyImpl 'Database.Beam.Schema.Tables.PrimaryKeyStrategy f (Database.Beam.Schema.Tables.PrimaryKey rel)
instance (Database.Beam.Schema.Tables.CheckNullable f, Database.Beam.Schema.Tables.SubTableStrategyImpl 'Database.Beam.Schema.Tables.PrimaryKeyStrategy f (Database.Beam.Schema.Tables.PrimaryKey rel)) => Database.Beam.Schema.Tables.SubTableStrategyImpl 'Database.Beam.Schema.Tables.RecursiveKeyStrategy f (Database.Beam.Schema.Tables.PrimaryKey rel)
instance (Database.Beam.Schema.Tables.Beamable tbl, Database.Beam.Schema.Tables.RenamableField f) => Database.Beam.Schema.Tables.RenamableWithRule (tbl (Database.Beam.Schema.Tables.FieldModification f))
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Schema.Tables.RenamableWithRule (Database.Beam.Schema.Tables.FieldRenamer (Database.Beam.Schema.Tables.DatabaseEntityDescriptor be (Database.Beam.Schema.Tables.TableEntity tbl)))
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Schema.Tables.RenamableWithRule (Database.Beam.Schema.Tables.FieldRenamer (Database.Beam.Schema.Tables.DatabaseEntityDescriptor be (Database.Beam.Schema.Tables.ViewEntity tbl)))
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Schema.Tables.IsDatabaseEntity be (Database.Beam.Schema.Tables.ViewEntity tbl)
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Schema.Tables.Retaggable f (tbl f)
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Schema.Tables.GZipTables f g h (GHC.Generics.K1 GHC.Generics.R (tbl Database.Beam.Backend.Types.Exposed)) (GHC.Generics.K1 GHC.Generics.R (tbl f)) (GHC.Generics.K1 GHC.Generics.R (tbl g)) (GHC.Generics.K1 GHC.Generics.R (tbl h))
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Schema.Tables.GZipTables f g h (GHC.Generics.K1 GHC.Generics.R (tbl (Database.Beam.Backend.Types.Nullable Database.Beam.Backend.Types.Exposed))) (GHC.Generics.K1 GHC.Generics.R (tbl (Database.Beam.Backend.Types.Nullable f))) (GHC.Generics.K1 GHC.Generics.R (tbl (Database.Beam.Backend.Types.Nullable g))) (GHC.Generics.K1 GHC.Generics.R (tbl (Database.Beam.Backend.Types.Nullable h)))
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Schema.Tables.GTableSkeleton (GHC.Generics.K1 GHC.Generics.R (tbl Database.Beam.Schema.Tables.Ignored))
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Schema.Tables.GTableSkeleton (GHC.Generics.K1 GHC.Generics.R (tbl (Database.Beam.Backend.Types.Nullable Database.Beam.Schema.Tables.Ignored)))
instance Database.Beam.Schema.Tables.GTableSkeleton p => Database.Beam.Schema.Tables.GTableSkeleton (GHC.Generics.M1 t f p)
instance Database.Beam.Schema.Tables.GTableSkeleton GHC.Generics.U1
instance (Database.Beam.Schema.Tables.GTableSkeleton a, Database.Beam.Schema.Tables.GTableSkeleton b) => Database.Beam.Schema.Tables.GTableSkeleton (a GHC.Generics.:*: b)
instance Database.Beam.Schema.Tables.GTableSkeleton (GHC.Generics.K1 GHC.Generics.R (Database.Beam.Schema.Tables.Ignored field))
instance Database.Beam.Schema.Tables.TagReducesTo (Database.Beam.Schema.Tables.TableField tbl) (Database.Beam.Schema.Tables.TableField tbl)
instance Database.Beam.Schema.Tables.TagReducesTo f f' => Database.Beam.Schema.Tables.TagReducesTo (Database.Beam.Backend.Types.Nullable f) f'
instance (GHC.Generics.Generic (sub f), Database.Beam.Schema.Tables.GDefaultTableFieldSettings (GHC.Generics.Rep (sub f) ())) => Database.Beam.Schema.Tables.SubTableStrategyImpl 'Database.Beam.Schema.Tables.BeamableStrategy f sub
instance Database.Beam.Schema.Tables.GDefaultTableFieldSettings (p x) => Database.Beam.Schema.Tables.GDefaultTableFieldSettings (GHC.Generics.D1 f p x)
instance Database.Beam.Schema.Tables.GDefaultTableFieldSettings (p x) => Database.Beam.Schema.Tables.GDefaultTableFieldSettings (GHC.Generics.C1 f p x)
instance (Database.Beam.Schema.Tables.GDefaultTableFieldSettings (a p), Database.Beam.Schema.Tables.GDefaultTableFieldSettings (b p)) => Database.Beam.Schema.Tables.GDefaultTableFieldSettings ((GHC.Generics.:*:) a b p)
instance GHC.Generics.Selector f => Database.Beam.Schema.Tables.GDefaultTableFieldSettings (GHC.Generics.S1 f (GHC.Generics.K1 GHC.Generics.R (Database.Beam.Schema.Tables.TableField table field)) p)
instance (TypeError ...) => Database.Beam.Schema.Tables.GDefaultTableFieldSettings (GHC.Generics.K1 r f p)
instance (Database.Beam.Schema.Tables.GZipTables f g h exp1 f1 g1 h1, Database.Beam.Schema.Tables.GZipTables f g h exp2 f2 g2 h2) => Database.Beam.Schema.Tables.GZipTables f g h (exp1 GHC.Generics.:*: exp2) (f1 GHC.Generics.:*: f2) (g1 GHC.Generics.:*: g2) (h1 GHC.Generics.:*: h2)
instance Database.Beam.Schema.Tables.GZipTables f g h exp fRep gRep hRep => Database.Beam.Schema.Tables.GZipTables f g h (GHC.Generics.M1 x y exp) (GHC.Generics.M1 x y fRep) (GHC.Generics.M1 x y gRep) (GHC.Generics.M1 x y hRep)
instance (fa GHC.Types.~ Database.Beam.Schema.Tables.Columnar f a, ga GHC.Types.~ Database.Beam.Schema.Tables.Columnar g a, ha GHC.Types.~ Database.Beam.Schema.Tables.Columnar h a, ha GHC.Types.~ Database.Beam.Schema.Tables.Columnar h a) => Database.Beam.Schema.Tables.GZipTables f g h (GHC.Generics.K1 GHC.Generics.R (Database.Beam.Backend.Types.Exposed a)) (GHC.Generics.K1 GHC.Generics.R fa) (GHC.Generics.K1 GHC.Generics.R ga) (GHC.Generics.K1 GHC.Generics.R ha)
instance Database.Beam.Schema.Tables.GZipTables f g h GHC.Generics.U1 GHC.Generics.U1 GHC.Generics.U1 GHC.Generics.U1
instance Database.Beam.Schema.Tables.FieldsFulfillConstraintNullable c t => Database.Beam.Schema.Tables.GFieldsFulfillConstraint c (GHC.Generics.K1 GHC.Generics.R (t (Database.Beam.Backend.Types.Nullable Database.Beam.Backend.Types.Exposed))) (GHC.Generics.K1 GHC.Generics.R (t (Database.Beam.Backend.Types.Nullable (Database.Beam.Schema.Tables.HasConstraint c))))
instance Database.Beam.Schema.Tables.FieldsFulfillConstraint c t => Database.Beam.Schema.Tables.GFieldsFulfillConstraint c (GHC.Generics.K1 GHC.Generics.R (t Database.Beam.Backend.Types.Exposed)) (GHC.Generics.K1 GHC.Generics.R (t (Database.Beam.Schema.Tables.HasConstraint c)))
instance Database.Beam.Schema.Tables.GFieldsFulfillConstraint c exposed withconstraint => Database.Beam.Schema.Tables.GFieldsFulfillConstraint c (GHC.Generics.M1 s m exposed) (GHC.Generics.M1 s m withconstraint)
instance Database.Beam.Schema.Tables.GFieldsFulfillConstraint c GHC.Generics.U1 GHC.Generics.U1
instance (Database.Beam.Schema.Tables.GFieldsFulfillConstraint c aExp aC, Database.Beam.Schema.Tables.GFieldsFulfillConstraint c bExp bC) => Database.Beam.Schema.Tables.GFieldsFulfillConstraint c (aExp GHC.Generics.:*: bExp) (aC GHC.Generics.:*: bC)
instance c x => Database.Beam.Schema.Tables.GFieldsFulfillConstraint c (GHC.Generics.K1 GHC.Generics.R (Database.Beam.Backend.Types.Exposed x)) (GHC.Generics.K1 GHC.Generics.R (Database.Beam.Schema.Tables.HasConstraint c x))
instance (Database.Beam.Schema.Tables.Retaggable f a, Database.Beam.Schema.Tables.Retaggable f b) => Database.Beam.Schema.Tables.Retaggable f (a, b)
instance (Database.Beam.Schema.Tables.Retaggable f a, Database.Beam.Schema.Tables.Retaggable f b, Database.Beam.Schema.Tables.Retaggable f c) => Database.Beam.Schema.Tables.Retaggable f (a, b, c)
instance (Database.Beam.Schema.Tables.Retaggable f a, Database.Beam.Schema.Tables.Retaggable f b, Database.Beam.Schema.Tables.Retaggable f c, Database.Beam.Schema.Tables.Retaggable f d) => Database.Beam.Schema.Tables.Retaggable f (a, b, c, d)
instance (Database.Beam.Schema.Tables.Retaggable f a, Database.Beam.Schema.Tables.Retaggable f b, Database.Beam.Schema.Tables.Retaggable f c, Database.Beam.Schema.Tables.Retaggable f d, Database.Beam.Schema.Tables.Retaggable f e) => Database.Beam.Schema.Tables.Retaggable f (a, b, c, d, e)
instance (Database.Beam.Schema.Tables.Retaggable f' a, Database.Beam.Schema.Tables.Retaggable f' b, Database.Beam.Schema.Tables.Retaggable f' c, Database.Beam.Schema.Tables.Retaggable f' d, Database.Beam.Schema.Tables.Retaggable f' e, Database.Beam.Schema.Tables.Retaggable f' f) => Database.Beam.Schema.Tables.Retaggable f' (a, b, c, d, e, f)
instance (Database.Beam.Schema.Tables.Retaggable f' a, Database.Beam.Schema.Tables.Retaggable f' b, Database.Beam.Schema.Tables.Retaggable f' c, Database.Beam.Schema.Tables.Retaggable f' d, Database.Beam.Schema.Tables.Retaggable f' e, Database.Beam.Schema.Tables.Retaggable f' f, Database.Beam.Schema.Tables.Retaggable f' g) => Database.Beam.Schema.Tables.Retaggable f' (a, b, c, d, e, f, g)
instance (Database.Beam.Schema.Tables.Retaggable f' a, Database.Beam.Schema.Tables.Retaggable f' b, Database.Beam.Schema.Tables.Retaggable f' c, Database.Beam.Schema.Tables.Retaggable f' d, Database.Beam.Schema.Tables.Retaggable f' e, Database.Beam.Schema.Tables.Retaggable f' f, Database.Beam.Schema.Tables.Retaggable f' g, Database.Beam.Schema.Tables.Retaggable f' h) => Database.Beam.Schema.Tables.Retaggable f' (a, b, c, d, e, f, g, h)
instance Database.Beam.Schema.Tables.RenamableField (Database.Beam.Schema.Tables.TableField tbl)
instance Data.String.IsString (Database.Beam.Schema.Tables.FieldModification (Database.Beam.Schema.Tables.TableField tbl) a)
instance Database.Beam.Schema.Tables.Database be db => Database.Beam.Schema.Tables.RenamableWithRule (db (Database.Beam.Schema.Tables.EntityModification (Database.Beam.Schema.Tables.DatabaseEntity be db) be))
instance Database.Beam.Schema.Tables.GZipDatabase be f g h x y z => Database.Beam.Schema.Tables.GZipDatabase be f g h (GHC.Generics.M1 a b x) (GHC.Generics.M1 a b y) (GHC.Generics.M1 a b z)
instance (Database.Beam.Schema.Tables.GZipDatabase be f g h ax ay az, Database.Beam.Schema.Tables.GZipDatabase be f g h bx by bz) => Database.Beam.Schema.Tables.GZipDatabase be f g h (ax GHC.Generics.:*: bx) (ay GHC.Generics.:*: by) (az GHC.Generics.:*: bz)
instance (Database.Beam.Schema.Tables.IsDatabaseEntity be tbl, Database.Beam.Schema.Tables.DatabaseEntityRegularRequirements be tbl) => Database.Beam.Schema.Tables.GZipDatabase be f g h (GHC.Generics.K1 GHC.Generics.R (f tbl)) (GHC.Generics.K1 GHC.Generics.R (g tbl)) (GHC.Generics.K1 GHC.Generics.R (h tbl))
instance Database.Beam.Schema.Tables.GAutoDbSettings (x p) => Database.Beam.Schema.Tables.GAutoDbSettings (GHC.Generics.D1 f x p)
instance Database.Beam.Schema.Tables.GAutoDbSettings (x p) => Database.Beam.Schema.Tables.GAutoDbSettings (GHC.Generics.C1 f x p)
instance (Database.Beam.Schema.Tables.GAutoDbSettings (x p), Database.Beam.Schema.Tables.GAutoDbSettings (y p)) => Database.Beam.Schema.Tables.GAutoDbSettings ((GHC.Generics.:*:) x y p)
instance (GHC.Generics.Selector f, Database.Beam.Schema.Tables.IsDatabaseEntity be x, Database.Beam.Schema.Tables.DatabaseEntityDefaultRequirements be x) => Database.Beam.Schema.Tables.GAutoDbSettings (GHC.Generics.S1 f (GHC.Generics.K1 GHC.Generics.R (Database.Beam.Schema.Tables.DatabaseEntity be db x)) p)
instance Database.Beam.Schema.Tables.IsDatabaseEntity be entity => Database.Beam.Schema.Tables.RenamableWithRule (Database.Beam.Schema.Tables.EntityModification (Database.Beam.Schema.Tables.DatabaseEntity be db) be entity)
instance Database.Beam.Schema.Tables.RenamableWithRule (Database.Beam.Schema.Tables.FieldRenamer (Database.Beam.Schema.Tables.DatabaseEntityDescriptor be (Database.Beam.Schema.Tables.DomainTypeEntity ty)))
instance Database.Beam.Schema.Tables.IsDatabaseEntity be (Database.Beam.Schema.Tables.DomainTypeEntity ty)


-- | Defines type classes for <a>Table</a>s and <a>Database</a>s.
--   
--   All important class methods of these classes can be derived
--   automatically using <tt>Generic</tt>s and GHC's DefaultSignatures
--   extension, but you can override any method if necessary.
--   
--   To get started, see <a>Table</a>, <a>Columnar</a>, and
--   <a>Nullable</a>.
module Database.Beam.Schema

-- | Allows introspection into database types.
--   
--   All database types must be of kind '(Type -&gt; Type) -&gt; Type'. If
--   the type parameter is named <tt>f</tt>, each field must be of the type
--   of <tt>f</tt> applied to some type for which an
--   <a>IsDatabaseEntity</a> instance exists.
--   
--   The <tt>be</tt> type parameter is necessary so that the compiler can
--   ensure that backend-specific entities only work on the proper backend.
--   
--   Entities are documented under <a>the corresponding section</a> and in
--   the <a>manual</a>
class Database be db

-- | When parameterized by this entity tag, a database type will hold
--   meta-information on the Haskell mappings of database entities. Under
--   the hood, each entity type is transformed into its
--   <a>DatabaseEntityDescriptor</a> type. For tables this includes the
--   table name as well as the corresponding <a>TableSettings</a>, which
--   provides names for each column.
type DatabaseSettings be db = db (DatabaseEntity be db)

-- | Represents a meta-description of a particular entityType. Mostly, a
--   wrapper around 'DatabaseEntityDescriptor be entityType', but carries
--   around the <a>IsDatabaseEntity</a> dictionary.
data DatabaseEntity be (db :: (Type -> Type) -> Type) entityType

-- | An entity tag for tables. See the documentation for <a>Table</a> or
--   consult the <a>manual</a> for more.
data TableEntity (tbl :: (Type -> Type) -> Type)

-- | The big Kahuna! All beam tables implement this class.
--   
--   The kind of all table types is '(Type -&gt; Type) -&gt; Type'. This is
--   because all table types are actually <i>table type constructors</i>.
--   Every table type takes in another type constructor, called the
--   <i>column tag</i>, and uses that constructor to instantiate the column
--   types. See the documentation for <a>Columnar</a>.
--   
--   This class is mostly Generic-derivable. You need only specify a type
--   for the table's primary key and a method to extract the primary key
--   given the table.
--   
--   An example table:
--   
--   <pre>
--   data BlogPostT f = BlogPost
--                    { _blogPostSlug    :: Columnar f Text
--                    , _blogPostBody    :: Columnar f Text
--                    , _blogPostDate    :: Columnar f UTCTime
--                    , _blogPostAuthor  :: PrimaryKey AuthorT f
--                    , _blogPostTagline :: Columnar f (Maybe Text)
--                    , _blogPostImageGallery :: PrimaryKey ImageGalleryT (Nullable f) }
--                      deriving Generic
--   instance Beamable BlogPostT
--   instance Table BlogPostT where
--      data PrimaryKey BlogPostT f = BlogPostId (Columnar f Text) deriving Generic
--      primaryKey = BlogPostId . _blogPostSlug
--   instance Beamable (PrimaryKey BlogPostT)
--   </pre>
--   
--   We can interpret this as follows:
--   
--   <ul>
--   <li>The <tt>_blogPostSlug</tt>, <tt>_blogPostBody</tt>,
--   <tt>_blogPostDate</tt>, and <tt>_blogPostTagline</tt> fields are of
--   types <a>Text</a>, <a>Text</a>, <tt>UTCTime</tt>, and 'Maybe Text'
--   respectfully.</li>
--   <li>Since <tt>_blogPostSlug</tt>, <tt>_blogPostBody</tt>,
--   <tt>_blogPostDate</tt>, <tt>_blogPostAuthor</tt> must be provided
--   (i.e, they cannot contain <a>Nothing</a>), they will be given SQL NOT
--   NULL constraints. <tt>_blogPostTagline</tt> is declared <a>Maybe</a>
--   so <a>Nothing</a> will be stored as NULL in the database.
--   <tt>_blogPostImageGallery</tt> will be allowed to be empty because it
--   uses the <a>Nullable</a> tag modifier.</li>
--   <li><tt>blogPostAuthor</tt> references the <tt>AuthorT</tt> table (not
--   given here) and is required.</li>
--   <li><tt>blogPostImageGallery</tt> references the
--   <tt>ImageGalleryT</tt> table (not given here), but this relation is
--   not required (i.e., it may be <a>Nothing</a>. See
--   <a>Nullable</a>).</li>
--   </ul>
class (Typeable table, Beamable table, Beamable (PrimaryKey table)) => Table (table :: (Type -> Type) -> Type) where {
    
    -- | A data type representing the types of primary keys for this table. In
    --   order to play nicely with the default deriving mechanism, this type
    --   must be an instance of <a>Generic</a>.
    data family PrimaryKey table (column :: Type -> Type) :: Type;
}

-- | Given a table, this should return the PrimaryKey from the table. By
--   keeping this polymorphic over column, we ensure that the primary key
--   values come directly from the table (i.e., they can't be arbitrary
--   constants)
primaryKey :: Table table => table column -> PrimaryKey table column

-- | Provides a number of introspection routines for the beam library.
--   Allows us to "zip" tables with different column tags together. Always
--   instantiate an empty <a>Beamable</a> instance for tables, primary
--   keys, and any type that you would like to embed within either. See the
--   <a>manual</a> for more information on embedding.
class Beamable table

-- | Return a <a>TableSettings</a> for the appropriate <tt>table</tt> type
--   where each column has been given its default name. See the
--   <a>manual</a> for information on the default naming convention.
defTblFieldSettings :: (Generic (TableSettings table), GDefaultTableFieldSettings (Rep (TableSettings table) ())) => TableSettings table

-- | Synonym for <a>primaryKey</a>
pk :: Table t => t f -> PrimaryKey t f

-- | A type family that we use to "tag" columns in our table datatypes.
--   
--   This is what allows us to use the same table type to hold table data,
--   describe table settings, derive lenses, and provide expressions.
--   
--   The basic rules are
--   
--   <pre>
--   Columnar Identity x = x
--   </pre>
--   
--   Thus, any Beam table applied to <a>Identity</a> will yield a
--   simplified version of the data type, that contains just what you'd
--   expect.
--   
--   The <a>Nullable</a> type is used when referencing <a>PrimaryKey</a>s
--   that we want to include optionally. For example, if we have a table
--   with a <a>PrimaryKey</a>, like the following
--   
--   <pre>
--   data BeamTableT f = BeamTableT
--                     { _refToAnotherTable :: PrimaryKey AnotherTableT f
--                     , ... }
--   </pre>
--   
--   we would typically be required to provide values for the
--   <a>PrimaryKey</a> embedded into <tt>BeamTableT</tt>. We can use
--   <a>Nullable</a> to lift this constraint.
--   
--   <pre>
--   data BeamTableT f = BeamTableT
--                     { _refToAnotherTable :: PrimaryKey AnotherTableT (Nullable f)
--                     , ... }
--   </pre>
--   
--   Now we can use <tt>just_</tt> and <tt>nothing_</tt> to refer to this
--   table optionally. The embedded <a>PrimaryKey</a> in
--   <tt>_refToAnotherTable</tt> automatically has its fields converted
--   into <a>Maybe</a> using <a>Nullable</a>.
--   
--   The last <a>Columnar</a> rule is
--   
--   <pre>
--   Columnar f x = f x
--   </pre>
--   
--   Use this rule if you'd like to parameterize your table type over any
--   other functor. For example, this is used in the query modules to write
--   expressions such as 'TableT QExpr', which returns a table whose fields
--   have been turned into query expressions.
--   
--   The other rules are used within Beam to provide lenses and to expose
--   the inner structure of the data type.
type family Columnar (f :: Type -> Type) x

-- | A short type-alias for <a>Columnar</a>. May shorten your schema
--   definitions
type C f a = Columnar f a

-- | If you declare a function 'Columnar f a -&gt; b' and try to constrain
--   your function by a type class for <tt>f</tt>, GHC will complain,
--   because <tt>f</tt> is ambiguous in 'Columnar f a'. For example,
--   'Columnar Identity (Maybe a) ~ Maybe a' and 'Columnar (Nullable
--   Identity) a ~ Maybe a', so given a type 'Columnar f a', we cannot know
--   the type of <tt>f</tt>.
--   
--   Thus, if you need to know <tt>f</tt>, you can instead use
--   <a>Columnar'</a>. Since its a newtype, it carries around the
--   <tt>f</tt> paramater unambiguously. Internally, it simply wraps
--   'Columnar f a'
data Columnar' f a

-- | Support for NULLable Foreign Key references.
--   
--   <pre>
--   data MyTable f = MyTable
--                  { nullableRef :: PrimaryKey AnotherTable (Nullable f)
--                  , ... }
--                   deriving (Generic, Typeable)
--   </pre>
--   
--   See <tt>Columnar</tt> for more information.
data Nullable (c :: Type -> Type) x

-- | Metadata for a field of type <tt>ty</tt> in <tt>table</tt>.
--   
--   Essentially a wrapper over the field name, but with a phantom type
--   parameter, so that it forms an appropriate column tag.
--   
--   Usually you use the <a>defaultDbSettings</a> function to generate an
--   appropriate naming convention for you, and then modify it with
--   <a>withDbModification</a> if necessary. Under this scheme, the field n
--   be renamed using the <a>IsString</a> instance for <a>TableField</a>,
--   or the <a>fieldNamed</a> function.
data TableField (table :: (Type -> Type) -> Type) ty

-- | Van Laarhoven lens to retrieve or set the field name from a
--   <a>TableField</a>.
fieldName :: Lens' (TableField table ty) Text

-- | Represents a table that contains metadata on its fields. In
--   particular, each field of type 'Columnar f a' is transformed into
--   'TableField table a'. You can get or update the name of each field by
--   using the <a>fieldName</a> lens.
type TableSettings table = table (TableField table)

-- | The regular Haskell version of the table. Equivalent to 'tbl Identity'
type HaskellTable table = table Identity

-- | Automatically provide names for tables, and descriptions for tables
--   (using <a>defTblFieldSettings</a>). Your database must implement
--   <a>Generic</a>, and must be auto-derivable. For more information on
--   name generation, see the <a>manual</a>
defaultDbSettings :: (Generic (DatabaseSettings be db), GAutoDbSettings (Rep (DatabaseSettings be db) ())) => DatabaseSettings be db

-- | A helper data type that lets you modify a database schema. Converts
--   all entities in the database into functions from that entity to
--   itself.
type DatabaseModification f be db = db (EntityModification f be)

-- | A newtype wrapper around 'f e -&gt; f e' (i.e., an endomorphism
--   between entity types in <tt>f</tt>). You usually want to use
--   <a>modifyTable</a> or another function to contstruct these for you.
data EntityModification f be e

-- | A newtype wrapper around 'Columnar f a -&gt; Columnar f a' (i.e., an
--   endomorphism between <a>Columnar</a>s over <tt>f</tt>). You usually
--   want to use <a>fieldNamed</a> or the <a>IsString</a> instance to
--   rename the field, when 'f ~ TableField'
data FieldModification f a

-- | Modify a database according to a given modification. Most useful for
--   <a>DatabaseSettings</a> to change the name mappings of tables and
--   fields. For example, you can use this to modify the default names of a
--   table
--   
--   <pre>
--   db :: DatabaseSettings MyDb
--   db = defaultDbSettings `withDbModification`
--        dbModification {
--          -- Change default name "table1" to "Table_1". Change the name of "table1Field1" to "first_name"
--          table1 = modifyTable (\_ -&gt; "Table_1") (tableModification { table1Field1 = "first_name" }
--        }
--   </pre>
withDbModification :: forall db be entity. Database be db => db (entity be db) -> DatabaseModification (entity be db) be db -> db (entity be db)

-- | Modify a table according to the given field modifications. Invoked by
--   <a>modifyTable</a> to apply the modification in the database. Not used
--   as often in user code, but provided for completeness.
withTableModification :: Beamable tbl => tbl (FieldModification f) -> tbl f -> tbl f

-- | Return a <a>DatabaseModification</a> that does nothing. This is useful
--   if you only want to rename one table. You can do
--   
--   <pre>
--   dbModification { tbl1 = modifyTable (\oldNm -&gt; "NewTableName") tableModification }
--   </pre>
dbModification :: forall f be db. Database be db => DatabaseModification f be db

-- | Return a table modification (for use with <a>modifyTable</a>) that
--   does nothing. Useful if you only want to change the table name, or if
--   you only want to modify a few fields.
--   
--   For example,
--   
--   <pre>
--   tableModification { field1 = "Column1" }
--   </pre>
--   
--   is a table modification (where 'f ~ TableField tbl') that changes the
--   column name of <tt>field1</tt> to <a>Column1</a>.
tableModification :: forall f tbl. Beamable tbl => tbl (FieldModification f)

-- | Provide an <a>EntityModification</a> for <a>TableEntity</a>s. Allows
--   you to modify the name of the table and provide a modification for
--   each field in the table. See the examples for
--   <a>withDbModification</a> for more.

-- | <i>Deprecated: Instead of 'modifyTable fTblNm fFields', use
--   'modifyEntityName _ &lt;&gt; modifyTableFields _'</i>
modifyTable :: (Beamable tbl, Table tbl) => (Text -> Text) -> tbl (FieldModification (TableField tbl)) -> EntityModification (DatabaseEntity be db) be (TableEntity tbl)

-- | A field modification to rename the field. Also offered under the
--   <a>IsString</a> instance for 'FieldModification (TableField tbl) a'
--   for convenience.
fieldNamed :: Text -> FieldModification (TableField tbl) a

-- | Change the entity name without consulting the beam-assigned one
setEntityName :: IsDatabaseEntity be entity => Text -> EntityModification (DatabaseEntity be db) be entity

-- | Construct an <a>EntityModification</a> to rename any database entity
modifyEntityName :: IsDatabaseEntity be entity => (Text -> Text) -> EntityModification (DatabaseEntity be db) be entity

-- | Construct an <a>EntityModification</a> to rename the fields of a
--   <a>TableEntity</a>
modifyTableFields :: tbl (FieldModification (TableField tbl)) -> EntityModification (DatabaseEntity be db) be (TableEntity tbl)
data Lenses (t :: (Type -> Type) -> Type) (f :: Type -> Type) x
data LensFor t x
[LensFor] :: Generic t => Lens' t x -> LensFor t x

-- | Automatically deduce lenses for a table over any column tag. lenses at
--   global level by doing a top-level pattern match on <a>tableLenses</a>,
--   replacing every column in the pattern with `LensFor
--   <a>nameOfLensForField</a>'. The lenses are generated per-column, not
--   per field in the record. Thus if you have nested <a>Beamable</a>
--   types, lenses are generated for each nested field.
--   
--   For example,
--   
--   <pre>
--   data AuthorT f = AuthorT
--                  { _authorEmail     :: Columnar f Text
--                  , _authorFirstName :: Columnar f Text
--                  , _authorLastName  :: Columnar f Text }
--                    deriving Generic
--   
--   data BlogPostT f = BlogPost
--                    { _blogPostSlug    :: Columnar f Text
--                    , _blogPostBody    :: Columnar f Text
--                    , _blogPostDate    :: Columnar f UTCTime
--                    , _blogPostAuthor  :: PrimaryKey AuthorT f
--                    , _blogPostTagline :: Columnar f (Maybe Text) }
--                      deriving Generic
--   instance Table BlogPostT where
--      data PrimaryKey BlogPostT f = BlogPostId (Columnar f Text)
--      primaryKey = BlogPostId . _blogPostSlug
--   instance Table AuthorT where
--      data PrimaryKey AuthorT f = AuthorId (Columnar f Text)
--      primaryKey = AuthorId . _authorEmail
--   </pre>
--   
--   <pre>
--   BlogPost (LensFor blogPostSlug
--            (LensFor blogPostBody)
--            (LensFor blogPostDate)
--            (AuthorId (LensFor blogPostAuthorEmail))
--            (LensFor blogPostTagLine) = tableLenses
--   </pre>
--   
--   Note: In order to have GHC deduce the right type, you will need to
--   turn off the monomorphism restriction. This is a part of the Haskell
--   standard that specifies that top-level definitions must be inferred to
--   have a monomorphic type. However, lenses need a polymorphic type to
--   work properly. You can turn off the monomorphism restriction by
--   enabling the <tt>NoMonomorphismRestriction</tt> extension. You can do
--   this per-file by using the {-# LANGUAGE NoMonomorphismRestriction #-}
--   pragma at the top of the file. You can also pass the
--   <tt>-XNoMonomorphismRestriction</tt> command line flag to GHC during
--   compilation.
tableLenses :: (lensType ~ Lenses t f, Generic (t lensType), Generic (t f), GTableLenses t f (Rep (t f)) (Rep (t lensType))) => t (Lenses t f)
newtype TableLens f db (x :: k)
TableLens :: Lens' (db f) (f x) -> TableLens f db (x :: k)

-- | Like <a>tableLenses</a> but for types that are instances of
--   <a>Database</a>. Instead of pattern matching on <a>LensFor</a>,
--   pattern match on <a>TableLens</a>.
dbLenses :: (Generic (db (TableLens f db)), Generic (db f), GDatabaseLenses (db f) (Rep (db f)) (Rep (db (TableLens f db)))) => db (TableLens f db)

module Database.Beam.Query.Internal
type ProjectibleInBackend be a = (Projectible be a, ProjectibleValue be a)
type TablePrefix = Text
data QF be (db :: (Type -> Type) -> Type) s next
[QDistinct] :: Projectible be r => (r -> WithExprContext (BeamSqlBackendSetQuantifierSyntax be)) -> QM be db s r -> (r -> next) -> QF be db s next
[QAll] :: Projectible be r => (TablePrefix -> Text -> BeamSqlBackendFromSyntax be) -> (Text -> r) -> (r -> Maybe (WithExprContext (BeamSqlBackendExpressionSyntax be))) -> ((Text, r) -> next) -> QF be db s next
[QArbitraryJoin] :: Projectible be r => QM be db (QNested s) r -> Text -> (BeamSqlBackendFromSyntax be -> BeamSqlBackendFromSyntax be -> Maybe (BeamSqlBackendExpressionSyntax be) -> BeamSqlBackendFromSyntax be) -> (r -> Maybe (WithExprContext (BeamSqlBackendExpressionSyntax be))) -> (r -> next) -> QF be db s next
[QTwoWayJoin] :: (Projectible be a, Projectible be b) => QM be db (QNested s) a -> QM be db (QNested s) b -> (BeamSqlBackendFromSyntax be -> BeamSqlBackendFromSyntax be -> Maybe (BeamSqlBackendExpressionSyntax be) -> BeamSqlBackendFromSyntax be) -> ((a, b) -> Maybe (WithExprContext (BeamSqlBackendExpressionSyntax be))) -> ((a, b) -> next) -> QF be db s next
[QSubSelect] :: Projectible be r => QM be db (QNested s) r -> (r -> next) -> QF be db s next
[QGuard] :: WithExprContext (BeamSqlBackendExpressionSyntax be) -> next -> QF be db s next
[QLimit] :: Projectible be r => Integer -> QM be db (QNested s) r -> (r -> next) -> QF be db s next
[QOffset] :: Projectible be r => Integer -> QM be db (QNested s) r -> (r -> next) -> QF be db s next
[QSetOp] :: Projectible be r => (BeamSqlBackendSelectTableSyntax be -> BeamSqlBackendSelectTableSyntax be -> BeamSqlBackendSelectTableSyntax be) -> QM be db (QNested s) r -> QM be db (QNested s) r -> (r -> next) -> QF be db s next
[QOrderBy] :: Projectible be r => (r -> WithExprContext [BeamSqlBackendOrderingSyntax be]) -> QM be db (QNested s) r -> (r -> next) -> QF be db s next
[QWindowOver] :: (ProjectibleWithPredicate WindowFrameContext be (WithExprContext (BeamSqlBackendWindowFrameSyntax' be)) window, Projectible be r, Projectible be a) => (r -> window) -> (r -> window -> a) -> QM be db (QNested s) r -> (a -> next) -> QF be db s next
[QAggregate] :: (Projectible be grouping, Projectible be a) => (a -> TablePrefix -> (Maybe (BeamSqlBackendGroupingSyntax be), grouping)) -> QM be db (QNested s) a -> (grouping -> next) -> QF be db s next
[QForceSelect] :: Projectible be r => (r -> BeamSqlBackendSelectTableSyntax be -> [BeamSqlBackendOrderingSyntax be] -> Maybe Integer -> Maybe Integer -> BeamSqlBackendSelectSyntax be) -> QM be db (QNested s) r -> (r -> next) -> QF be db s next
type QM be db s = F (QF be db s)

-- | The type of queries over the database <tt>db</tt> returning results of
--   type <tt>a</tt>. The <tt>s</tt> argument is a threading argument meant
--   to restrict cross-usage of <a>QExpr</a>s. <tt>syntax</tt> represents
--   the SQL syntax that this query is building.
newtype Q be (db :: (Type -> Type) -> Type) s a
Q :: QM be db s a -> Q be (db :: (Type -> Type) -> Type) s a
[runQ] :: Q be (db :: (Type -> Type) -> Type) s a -> QM be db s a
data QInternal
data QNested s
data QField s ty
QField :: !Bool -> !Text -> !Text -> QField s ty
[qFieldShouldQualify] :: QField s ty -> !Bool
[qFieldTblName] :: QField s ty -> !Text
[qFieldName] :: QField s ty -> !Text
newtype QAssignment be s
QAssignment :: [(BeamSqlBackendFieldNameSyntax be, BeamSqlBackendExpressionSyntax be)] -> QAssignment be s
[unQAssignment] :: QAssignment be s -> [(BeamSqlBackendFieldNameSyntax be, BeamSqlBackendExpressionSyntax be)]
newtype QFieldAssignment be tbl a
QFieldAssignment :: (forall s. tbl (QExpr be s) -> Maybe (QExpr be s a)) -> QFieldAssignment be tbl a
data QAggregateContext
data QGroupingContext
data QValueContext
data QWindowingContext
data QWindowFrameContext

-- | The type of lifted beam expressions that will yield the haskell type
--   <tt>t</tt>.
--   
--   <tt>context</tt> is a type-level representation of the types of
--   expressions this can contain. For example, <a>QAggregateContext</a>
--   represents expressions that may contain aggregates, and
--   <a>QWindowingContext</a> represents expressions that may contain
--   <tt>OVER</tt>.
--   
--   <tt>syntax</tt> is the expression syntax being built (usually a type
--   that implements <a>IsSql92ExpressionSyntax</a> at least, but not
--   always).
--   
--   <tt>s</tt> is a state threading parameter that prevents <a>QExpr</a>s
--   from incompatible sources to be combined. For example, this is used to
--   prevent monadic joins from depending on the result of previous joins
--   (so-called <tt>LATERAL</tt> joins).
newtype QGenExpr context be s t
QExpr :: (TablePrefix -> BeamSqlBackendExpressionSyntax be) -> QGenExpr context be s t
newtype QOrd be s t
QOrd :: (TablePrefix -> BeamSqlBackendOrderingSyntax be) -> QOrd be s t
type WithExprContext a = TablePrefix -> a

-- | <a>QExpr</a>s represent expressions not containing aggregates.
type QExpr = QGenExpr QValueContext
type QAgg = QGenExpr QAggregateContext
type QWindowExpr = QGenExpr QWindowingContext
type QGroupExpr = QGenExpr QGroupingContext
newtype QWindow be s
QWindow :: WithExprContext (BeamSqlBackendWindowFrameSyntax be) -> QWindow be s
newtype QFrameBounds be
QFrameBounds :: Maybe (BeamSqlBackendWindowFrameBoundsSyntax be) -> QFrameBounds be
newtype QFrameBound be
QFrameBound :: BeamSqlBackendWindowFrameBoundSyntax be -> QFrameBound be
qBinOpE :: BeamSqlBackend be => (BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be) -> QGenExpr context be s a -> QGenExpr context be s b -> QGenExpr context be s c
unsafeRetype :: QGenExpr ctxt be s a -> QGenExpr ctxt be s a'

-- | Typeclass for all haskell data types that can be used to create a
--   projection in a SQL select statement. This includes all tables as well
--   as all tuple classes. Projections are only defined on tuples up to
--   size 5. If you need more, follow the implementations here.
class Typeable context => AggregateContext context
type family ContextName a :: Symbol
type family IsAggregateContext a :: Constraint
type family AggregateContextSuggestion a :: ErrorMessage
class Typeable context => ValueContext context
class Typeable context => WindowFrameContext context
type family IsWindowFrameContext a :: Constraint
class AnyType a
type family IsValueContext a :: Constraint
type family ValueContextSuggestion a :: ErrorMessage
type Projectible be = ProjectibleWithPredicate AnyType be (WithExprContext (BeamSqlBackendExpressionSyntax' be))
type ProjectibleValue be = ProjectibleWithPredicate ValueContext be (WithExprContext (BeamSqlBackendExpressionSyntax' be))
class ThreadRewritable (s :: Type) (a :: Type) | a -> s where {
    type family WithRewrittenThread s (s' :: Type) a :: Type;
}
rewriteThread :: ThreadRewritable s a => Proxy s' -> a -> WithRewrittenThread s s' a
class ContextRewritable a where {
    type family WithRewrittenContext a ctxt :: Type;
}
rewriteContext :: ContextRewritable a => Proxy ctxt -> a -> WithRewrittenContext a ctxt
newtype BeamSqlBackendExpressionSyntax' be
BeamSqlBackendExpressionSyntax' :: BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax' be
[fromBeamSqlBackendExpressionSyntax] :: BeamSqlBackendExpressionSyntax' be -> BeamSqlBackendExpressionSyntax be
newtype BeamSqlBackendWindowFrameSyntax' be
BeamSqlBackendWindowFrameSyntax' :: BeamSqlBackendWindowFrameSyntax be -> BeamSqlBackendWindowFrameSyntax' be
[fromBeamSqlBackendWindowFrameSyntax] :: BeamSqlBackendWindowFrameSyntax' be -> BeamSqlBackendWindowFrameSyntax be
class ProjectibleWithPredicate (contextPredicate :: Type -> Constraint) be res a | a -> be
project' :: (ProjectibleWithPredicate contextPredicate be res a, Monad m) => Proxy contextPredicate -> Proxy (be, res) -> (forall context. contextPredicate context => Proxy context -> Proxy be -> res -> m res) -> a -> m a
projectSkeleton' :: (ProjectibleWithPredicate contextPredicate be res a, Monad m) => Proxy contextPredicate -> Proxy (be, res) -> (forall context. contextPredicate context => Proxy context -> Proxy be -> m res) -> m a
project :: forall be a. Projectible be a => Proxy be -> a -> WithExprContext [BeamSqlBackendExpressionSyntax be]
reproject :: forall be a. (BeamSqlBackend be, Projectible be a) => Proxy be -> (Int -> BeamSqlBackendExpressionSyntax be) -> a -> a

-- | suitable as argument to <a>QAll</a> in the case of a table result
tableFieldsToExpressions :: (BeamSqlBackend be, Beamable table) => TableSettings table -> Text -> table (QGenExpr ctxt be s)
mkFieldsSkeleton :: forall be res m. (Projectible be res, MonadState Int m) => (Int -> m (WithExprContext (BeamSqlBackendExpressionSyntax' be))) -> m res
mkFieldNames :: forall be res. (BeamSqlBackend be, Projectible be res) => (Text -> BeamSqlBackendFieldNameSyntax be) -> (res, [Text])
tableNameFromEntity :: IsSql92TableNameSyntax name => DatabaseEntityDescriptor be (TableEntity tbl) -> name
rescopeQ :: QM be db s res -> QM be db s' res
instance GHC.Classes.Ord (Database.Beam.Query.Internal.QField s ty)
instance GHC.Classes.Eq (Database.Beam.Query.Internal.QField s ty)
instance GHC.Show.Show (Database.Beam.Query.Internal.QField s ty)
instance GHC.Base.Semigroup (Database.Beam.Query.Internal.QAssignment be s)
instance GHC.Base.Monoid (Database.Beam.Query.Internal.QAssignment be s)
instance GHC.Base.Functor (Database.Beam.Query.Internal.Q be db s)
instance GHC.Base.Applicative (Database.Beam.Query.Internal.Q be db s)
instance GHC.Base.Monad (Database.Beam.Query.Internal.Q be db s)
instance GHC.Base.Functor (Database.Beam.Query.Internal.QF be db s)
instance (Database.Beam.Schema.Tables.Beamable t, contextPredicate context) => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be (Database.Beam.Query.Internal.WithExprContext (Database.Beam.Query.Internal.BeamSqlBackendExpressionSyntax' be)) (t (Database.Beam.Query.Internal.QGenExpr context be s))
instance (Database.Beam.Schema.Tables.Beamable t, contextPredicate context) => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be (Database.Beam.Query.Internal.WithExprContext (Database.Beam.Query.Internal.BeamSqlBackendExpressionSyntax' be)) (t (Database.Beam.Backend.Types.Nullable (Database.Beam.Query.Internal.QGenExpr context be s)))
instance contextPredicate context => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be (Database.Beam.Query.Internal.WithExprContext (Database.Beam.Query.Internal.BeamSqlBackendExpressionSyntax' be)) (Database.Beam.Query.Internal.QGenExpr context be s a)
instance contextPredicate Database.Beam.Query.Internal.QWindowFrameContext => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be (Database.Beam.Query.Internal.WithExprContext (Database.Beam.Query.Internal.BeamSqlBackendWindowFrameSyntax' be)) (Database.Beam.Query.Internal.QWindow be s)
instance (Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res a, GHC.TypeNats.KnownNat n) => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res (Data.Vector.Sized.Vector n a)
instance (Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res a, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res b) => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res (a, b)
instance (Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res a, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res b, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res c) => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res (a, b, c)
instance (Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res a, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res b, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res c, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res d) => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res (a, b, c, d)
instance (Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res a, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res b, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res c, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res d, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res e) => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res (a, b, c, d, e)
instance (Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res a, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res b, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res c, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res d, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res e, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res f) => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res (a, b, c, d, e, f)
instance (Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res a, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res b, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res c, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res d, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res e, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res f, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res g) => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res (a, b, c, d, e, f, g)
instance (Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res a, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res b, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res c, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res d, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res e, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res f, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res g, Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res h) => Database.Beam.Query.Internal.ProjectibleWithPredicate contextPredicate be res (a, b, c, d, e, f, g, h)
instance Database.Beam.Schema.Tables.Beamable t => Database.Beam.Query.Internal.ProjectibleWithPredicate Database.Beam.Query.Internal.AnyType () Data.Text.Internal.Text (t (Database.Beam.Query.Internal.QField s))
instance Database.Beam.Schema.Tables.Beamable t => Database.Beam.Query.Internal.ProjectibleWithPredicate Database.Beam.Query.Internal.AnyType () Data.Text.Internal.Text (t (Database.Beam.Backend.Types.Nullable (Database.Beam.Query.Internal.QField s)))
instance Database.Beam.Schema.Tables.Beamable t => Database.Beam.Query.Internal.ProjectibleWithPredicate Database.Beam.Query.Internal.AnyType () res (t (Data.Functor.Const.Const res))
instance Database.Beam.Schema.Tables.Beamable t => Database.Beam.Query.Internal.ProjectibleWithPredicate Database.Beam.Query.Internal.AnyType () Data.Text.Internal.Text (t (Database.Beam.Backend.Types.Nullable (Data.Functor.Const.Const Data.Text.Internal.Text)))
instance Database.Beam.Query.Internal.ProjectibleWithPredicate Database.Beam.Query.Internal.AnyType () res (Data.Functor.Const.Const res a)
instance Database.Beam.Query.Internal.ProjectibleWithPredicate Database.Beam.Query.Internal.AnyType () Data.Text.Internal.Text (Database.Beam.Query.Internal.QField s a)
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Query.Internal.ContextRewritable (tbl (Database.Beam.Query.Internal.QGenExpr old syntax s))
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Query.Internal.ContextRewritable (tbl (Database.Beam.Backend.Types.Nullable (Database.Beam.Query.Internal.QGenExpr old syntax s)))
instance Database.Beam.Query.Internal.ContextRewritable (Database.Beam.Query.Internal.QGenExpr old syntax s a)
instance Database.Beam.Query.Internal.ContextRewritable a => Database.Beam.Query.Internal.ContextRewritable [a]
instance (Database.Beam.Query.Internal.ContextRewritable a, GHC.TypeNats.KnownNat n) => Database.Beam.Query.Internal.ContextRewritable (Data.Vector.Sized.Vector n a)
instance (Database.Beam.Query.Internal.ContextRewritable a, Database.Beam.Query.Internal.ContextRewritable b) => Database.Beam.Query.Internal.ContextRewritable (a, b)
instance (Database.Beam.Query.Internal.ContextRewritable a, Database.Beam.Query.Internal.ContextRewritable b, Database.Beam.Query.Internal.ContextRewritable c) => Database.Beam.Query.Internal.ContextRewritable (a, b, c)
instance (Database.Beam.Query.Internal.ContextRewritable a, Database.Beam.Query.Internal.ContextRewritable b, Database.Beam.Query.Internal.ContextRewritable c, Database.Beam.Query.Internal.ContextRewritable d) => Database.Beam.Query.Internal.ContextRewritable (a, b, c, d)
instance (Database.Beam.Query.Internal.ContextRewritable a, Database.Beam.Query.Internal.ContextRewritable b, Database.Beam.Query.Internal.ContextRewritable c, Database.Beam.Query.Internal.ContextRewritable d, Database.Beam.Query.Internal.ContextRewritable e) => Database.Beam.Query.Internal.ContextRewritable (a, b, c, d, e)
instance (Database.Beam.Query.Internal.ContextRewritable a, Database.Beam.Query.Internal.ContextRewritable b, Database.Beam.Query.Internal.ContextRewritable c, Database.Beam.Query.Internal.ContextRewritable d, Database.Beam.Query.Internal.ContextRewritable e, Database.Beam.Query.Internal.ContextRewritable f) => Database.Beam.Query.Internal.ContextRewritable (a, b, c, d, e, f)
instance (Database.Beam.Query.Internal.ContextRewritable a, Database.Beam.Query.Internal.ContextRewritable b, Database.Beam.Query.Internal.ContextRewritable c, Database.Beam.Query.Internal.ContextRewritable d, Database.Beam.Query.Internal.ContextRewritable e, Database.Beam.Query.Internal.ContextRewritable f, Database.Beam.Query.Internal.ContextRewritable g) => Database.Beam.Query.Internal.ContextRewritable (a, b, c, d, e, f, g)
instance (Database.Beam.Query.Internal.ContextRewritable a, Database.Beam.Query.Internal.ContextRewritable b, Database.Beam.Query.Internal.ContextRewritable c, Database.Beam.Query.Internal.ContextRewritable d, Database.Beam.Query.Internal.ContextRewritable e, Database.Beam.Query.Internal.ContextRewritable f, Database.Beam.Query.Internal.ContextRewritable g, Database.Beam.Query.Internal.ContextRewritable h) => Database.Beam.Query.Internal.ContextRewritable (a, b, c, d, e, f, g, h)
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Query.Internal.ThreadRewritable s (tbl (Database.Beam.Query.Internal.QGenExpr ctxt syntax s))
instance Database.Beam.Schema.Tables.Beamable tbl => Database.Beam.Query.Internal.ThreadRewritable s (tbl (Database.Beam.Backend.Types.Nullable (Database.Beam.Query.Internal.QGenExpr ctxt syntax s)))
instance Database.Beam.Query.Internal.ThreadRewritable s (Database.Beam.Query.Internal.QGenExpr ctxt syntax s a)
instance Database.Beam.Query.Internal.ThreadRewritable s a => Database.Beam.Query.Internal.ThreadRewritable s [a]
instance (Database.Beam.Query.Internal.ThreadRewritable s a, GHC.TypeNats.KnownNat n) => Database.Beam.Query.Internal.ThreadRewritable s (Data.Vector.Sized.Vector n a)
instance (Database.Beam.Query.Internal.ThreadRewritable s a, Database.Beam.Query.Internal.ThreadRewritable s b) => Database.Beam.Query.Internal.ThreadRewritable s (a, b)
instance (Database.Beam.Query.Internal.ThreadRewritable s a, Database.Beam.Query.Internal.ThreadRewritable s b, Database.Beam.Query.Internal.ThreadRewritable s c) => Database.Beam.Query.Internal.ThreadRewritable s (a, b, c)
instance (Database.Beam.Query.Internal.ThreadRewritable s a, Database.Beam.Query.Internal.ThreadRewritable s b, Database.Beam.Query.Internal.ThreadRewritable s c, Database.Beam.Query.Internal.ThreadRewritable s d) => Database.Beam.Query.Internal.ThreadRewritable s (a, b, c, d)
instance (Database.Beam.Query.Internal.ThreadRewritable s a, Database.Beam.Query.Internal.ThreadRewritable s b, Database.Beam.Query.Internal.ThreadRewritable s c, Database.Beam.Query.Internal.ThreadRewritable s d, Database.Beam.Query.Internal.ThreadRewritable s e) => Database.Beam.Query.Internal.ThreadRewritable s (a, b, c, d, e)
instance (Database.Beam.Query.Internal.ThreadRewritable s a, Database.Beam.Query.Internal.ThreadRewritable s b, Database.Beam.Query.Internal.ThreadRewritable s c, Database.Beam.Query.Internal.ThreadRewritable s d, Database.Beam.Query.Internal.ThreadRewritable s e, Database.Beam.Query.Internal.ThreadRewritable s f) => Database.Beam.Query.Internal.ThreadRewritable s (a, b, c, d, e, f)
instance (Database.Beam.Query.Internal.ThreadRewritable s a, Database.Beam.Query.Internal.ThreadRewritable s b, Database.Beam.Query.Internal.ThreadRewritable s c, Database.Beam.Query.Internal.ThreadRewritable s d, Database.Beam.Query.Internal.ThreadRewritable s e, Database.Beam.Query.Internal.ThreadRewritable s f, Database.Beam.Query.Internal.ThreadRewritable s g) => Database.Beam.Query.Internal.ThreadRewritable s (a, b, c, d, e, f, g)
instance (Database.Beam.Query.Internal.ThreadRewritable s a, Database.Beam.Query.Internal.ThreadRewritable s b, Database.Beam.Query.Internal.ThreadRewritable s c, Database.Beam.Query.Internal.ThreadRewritable s d, Database.Beam.Query.Internal.ThreadRewritable s e, Database.Beam.Query.Internal.ThreadRewritable s f, Database.Beam.Query.Internal.ThreadRewritable s g, Database.Beam.Query.Internal.ThreadRewritable s h) => Database.Beam.Query.Internal.ThreadRewritable s (a, b, c, d, e, f, g, h)
instance (Database.Beam.Query.Internal.IsValueContext a, Data.Typeable.Internal.Typeable a, a GHC.Types.~ Database.Beam.Query.Internal.QValueContext) => Database.Beam.Query.Internal.ValueContext a
instance Database.Beam.Query.Internal.AnyType a
instance (Data.Typeable.Internal.Typeable context, Database.Beam.Query.Internal.IsWindowFrameContext context, context GHC.Types.~ Database.Beam.Query.Internal.QWindowFrameContext) => Database.Beam.Query.Internal.WindowFrameContext context
instance (Database.Beam.Query.Internal.IsAggregateContext a, Data.Typeable.Internal.Typeable a) => Database.Beam.Query.Internal.AggregateContext a
instance Database.Beam.Backend.SQL.BeamSqlBackend be => GHC.Classes.Eq (Database.Beam.Query.Internal.QGenExpr context be s t)
instance Database.Beam.Schema.Tables.Retaggable (Database.Beam.Query.Internal.QGenExpr ctxt expr s) (Database.Beam.Query.Internal.QGenExpr ctxt expr s t)
instance (Database.Beam.Backend.SQL.BeamSqlBackend backend, Database.Beam.Backend.SQL.BeamSqlBackendCanSerialize backend [GHC.Types.Char]) => Data.String.IsString (Database.Beam.Query.Internal.QGenExpr context backend s Data.Text.Internal.Text)
instance (GHC.Num.Num a, Database.Beam.Backend.SQL.BeamSqlBackend be, Database.Beam.Backend.SQL.BeamSqlBackendCanSerialize be a) => GHC.Num.Num (Database.Beam.Query.Internal.QGenExpr context be s a)
instance (GHC.Real.Fractional a, Database.Beam.Backend.SQL.BeamSqlBackend be, Database.Beam.Backend.SQL.BeamSqlBackendCanSerialize be a) => GHC.Real.Fractional (Database.Beam.Query.Internal.QGenExpr context be s a)

module Database.Beam.Query.SQL92

-- | Convenience functions to construct an arbitrary SQL92 select syntax
--   type from a <a>Q</a>. Used by most backends as the default
--   implementation of <tt>buildSqlQuery</tt> in <tt>HasQBuilder</tt>.
buildSql92Query' :: forall be db s a. (BeamSqlBackend be, Projectible be a) => Bool -> Text -> Q be db s a -> BeamSqlBackendSelectSyntax be
instance (GHC.Base.Monoid a, Database.Beam.Query.Internal.ProjectibleWithPredicate c syntax res b) => Database.Beam.Query.Internal.ProjectibleWithPredicate c syntax res (Database.Beam.Query.SQL92.PreserveLeft a b)

module Database.Beam.Query.Types

-- | The type of queries over the database <tt>db</tt> returning results of
--   type <tt>a</tt>. The <tt>s</tt> argument is a threading argument meant
--   to restrict cross-usage of <a>QExpr</a>s. <tt>syntax</tt> represents
--   the SQL syntax that this query is building.
data Q be (db :: (Type -> Type) -> Type) s a

-- | <a>QExpr</a>s represent expressions not containing aggregates.
type QExpr = QGenExpr QValueContext

-- | The type of lifted beam expressions that will yield the haskell type
--   <tt>t</tt>.
--   
--   <tt>context</tt> is a type-level representation of the types of
--   expressions this can contain. For example, <a>QAggregateContext</a>
--   represents expressions that may contain aggregates, and
--   <a>QWindowingContext</a> represents expressions that may contain
--   <tt>OVER</tt>.
--   
--   <tt>syntax</tt> is the expression syntax being built (usually a type
--   that implements <a>IsSql92ExpressionSyntax</a> at least, but not
--   always).
--   
--   <tt>s</tt> is a state threading parameter that prevents <a>QExpr</a>s
--   from incompatible sources to be combined. For example, this is used to
--   prevent monadic joins from depending on the result of previous joins
--   (so-called <tt>LATERAL</tt> joins).
newtype QGenExpr context be s t
QExpr :: (TablePrefix -> BeamSqlBackendExpressionSyntax be) -> QGenExpr context be s t
type family QExprToIdentity x
type family QExprToField x
data QWindow be s
type Projectible be = ProjectibleWithPredicate AnyType be (WithExprContext (BeamSqlBackendExpressionSyntax' be))
class BeamSqlBackend be => HasQBuilder be
buildSqlQuery :: (HasQBuilder be, Projectible be a) => TablePrefix -> Q be db s a -> BeamSqlBackendSelectSyntax be
instance Database.Beam.Backend.SQL.BeamSqlBackend (Database.Beam.Backend.SQL.MockSqlBackend cmd) => Database.Beam.Query.Types.HasQBuilder (Database.Beam.Backend.SQL.MockSqlBackend cmd)

module Database.Beam.Query.DataTypes

-- | A data type in a given <a>IsSql92DataTypeSyntax</a> which describes a
--   SQL type mapping to the Haskell type <tt>a</tt>
newtype DataType be a
DataType :: BeamSqlBackendCastTargetSyntax be -> DataType be a

-- | Cast a value to a specific data type, specified using <a>DataType</a>.
--   
--   Note: this may fail at run-time if the cast is invalid for a
--   particular value
cast_ :: BeamSqlBackend be => QGenExpr ctxt be s a -> DataType be b -> QGenExpr ctxt be s b

-- | SQL92 <tt>INTEGER</tt> data type
int :: (BeamSqlBackend be, Integral a) => DataType be a

-- | SQL92 <tt>SMALLINT</tt> data type
smallint :: (BeamSqlBackend be, Integral a) => DataType be a

-- | SQL2008 Optional <tt>BIGINT</tt> data type
bigint :: (BeamSqlBackend be, BeamSqlT071Backend be, Integral a) => DataType be a

-- | SQL2003 Optional <tt>BINARY</tt> data type
binary :: (BeamSqlBackend be, BeamSqlT021Backend be) => Maybe Word -> DataType be Integer

-- | SQL2003 Optional <tt>VARBINARY</tt> data type
varbinary :: (BeamSqlBackend be, BeamSqlT021Backend be) => Maybe Word -> DataType be Integer

-- | SQL92 <tt>DATE</tt> data type
date :: BeamSqlBackend be => DataType be Day

-- | SQL92 <tt>CHAR</tt> data type
char :: BeamSqlBackend be => Maybe Word -> DataType be Text

-- | SQL92 <tt>VARCHAR</tt> data type
varchar :: BeamSqlBackend be => Maybe Word -> DataType be Text

-- | SQL92 <tt>NATIONAL CHARACTER VARYING</tt> data type
nationalVarchar :: BeamSqlBackend be => Maybe Word -> DataType be Text

-- | SQL92 <tt>NATIONAL CHARACTER</tt> data type
nationalChar :: BeamSqlBackend be => Maybe Word -> DataType be Text

-- | SQL92 <tt>DOUBLE</tt> data type
double :: BeamSqlBackend be => DataType be Double

-- | SQL92 <tt>NUMERIC</tt> data type
numeric :: BeamSqlBackend be => Maybe (Word, Maybe Word) -> DataType be Scientific

-- | SQL92 <tt>TIMESTAMP WITH TIME ZONE</tt> data type
timestamptz :: BeamSqlBackend be => DataType be LocalTime

-- | SQL92 <tt>TIMESTAMP WITHOUT TIME ZONE</tt> data type
timestamp :: BeamSqlBackend be => DataType be LocalTime

-- | SQL92 <tt>TIME</tt> data type
time :: BeamSqlBackend be => Maybe Word -> DataType be TimeOfDay

-- | SQL99 <tt>BOOLEAN</tt> data type
boolean :: BeamSql99DataTypeBackend be => DataType be Bool

-- | SQL99 <tt>CLOB</tt> data type
characterLargeObject :: BeamSql99DataTypeBackend be => DataType be Text

-- | SQL99 <tt>BLOB</tt> data type
binaryLargeObject :: BeamSql99DataTypeBackend be => DataType be Text

-- | SQL99 array data types
array :: (Typeable a, BeamSql99DataTypeBackend be) => DataType be a -> Int -> DataType be (Vector a)

-- | Haskell requires <a>DataType</a>s to match exactly. Use this function
--   to convert a <a>DataType</a> that expects a concrete value to one
--   expecting a <a>Maybe</a>
maybeType :: DataType be a -> DataType be (Maybe a)
instance GHC.Classes.Eq (Database.Beam.Backend.SQL.BeamSqlBackendCastTargetSyntax be) => GHC.Classes.Eq (Database.Beam.Query.DataTypes.DataType be a)
instance Database.Beam.Backend.SQL.SQL92.Sql92DisplaySyntax (Database.Beam.Backend.SQL.BeamSqlBackendCastTargetSyntax be) => GHC.Show.Show (Database.Beam.Query.DataTypes.DataType be a)


-- | Allows the creation of custom SQL expressions from arbitrary
--   string-like values.
--   
--   Simply write a polymorphic function with an arbitrary number of
--   arguments, all of the same type, and returns a value of the same type.
--   The type will have instances of <a>Monoid</a> and <a>IsString</a>.
--   
--   For example, to implement a function <tt>MYFUNC</tt> that takes three
--   arguments
--   
--   <pre>
--   myFuncImpl :: (Monoid a, IsString a) =&gt; a -&gt; a -&gt; a -&gt; a
--   </pre>
--   
--   Then, apply <a>customExpr_</a> to your function. This will result in a
--   function with the same arity, that takes in and returns
--   <a>QGenExpr</a>s instead of generic <tt>a</tt>s.
--   
--   The returned function is polymorphic in the types of SQL expressions
--   it will accept, but you can give it a more specific signature. For
--   example, to mandate that we receive two <tt>Int32</tt>s and a
--   <a>Text</a> and return a <a>Bool</a>.
--   
--   <pre>
--   myFunc_ :: QGenExpr e ctxt s Int32 -&gt; QGenExpr e ctxt s Int32 -&gt; QGenExpr e ctxt s T.Text -&gt; QGenExpr e ctxt s Bool
--   myFunc_ = customExpr_ myFuncImpl
--   </pre>
--   
--   Semantically, the expression builder function (<tt>myFuncImpl</tt> in
--   this case) is called with arguments representing SQL expressions,
--   that, when evaluated, will evaluate to the result of the expressions
--   supplied as arguments to <a>customExpr_</a>. See the section on
--   <a>https://haskell-beam.github.io/beam/user-guide/extensibility/extensibility</a>
--   in the user guide for example usage.
module Database.Beam.Query.CustomSQL
class IsCustomExprFn fn res | res -> fn
customExpr_ :: IsCustomExprFn fn res => fn -> res

-- | Force a <a>QGenExpr</a> to be typed as a value expression (a
--   <a>QExpr</a>). Useful for getting around type-inference errors with
--   supplying the entire type.
valueExpr_ :: QExpr be s a -> QExpr be s a

-- | Force a <a>QGenExpr</a> to be typed as an aggregate. Useful for
--   defining custom aggregates for use in <tt>aggregate_</tt>.
agg_ :: QAgg be s a -> QAgg be s a

-- | A type-class for expression syntaxes that can embed custom
--   expressions.
class (Monoid (CustomSqlSyntax syntax), Semigroup (CustomSqlSyntax syntax), IsString (CustomSqlSyntax syntax)) => IsCustomSqlSyntax syntax where {
    data family CustomSqlSyntax syntax :: Type;
}

-- | Given an arbitrary string-like expression, produce a <tt>syntax</tt>
--   that represents the <a>ByteString</a> as a SQL expression.
customExprSyntax :: IsCustomSqlSyntax syntax => CustomSqlSyntax syntax -> syntax

-- | Given an arbitrary <tt>syntax</tt>, produce a string-like value that
--   corresponds to how that syntax would look when rendered in the
--   backend.
renderSyntax :: IsCustomSqlSyntax syntax => syntax -> CustomSqlSyntax syntax
instance GHC.Base.Semigroup (Database.Beam.Query.CustomSQL.CustomSqlSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder)
instance GHC.Base.Monoid (Database.Beam.Query.CustomSQL.CustomSqlSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder)
instance Data.String.IsString (Database.Beam.Query.CustomSQL.CustomSqlSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder)
instance Database.Beam.Query.CustomSQL.BeamSqlBackendHasCustomSyntax be => Database.Beam.Query.CustomSQL.IsCustomExprFn (Database.Beam.Query.CustomSQL.CustomSqlSnippet be) (Database.Beam.Query.Internal.QGenExpr ctxt be s res)
instance (Database.Beam.Query.CustomSQL.IsCustomExprFn a res, Database.Beam.Query.CustomSQL.BeamSqlBackendHasCustomSyntax be) => Database.Beam.Query.CustomSQL.IsCustomExprFn (Database.Beam.Query.CustomSQL.CustomSqlSnippet be -> a) (Database.Beam.Query.Internal.QGenExpr ctxt be s r -> res)
instance Database.Beam.Query.CustomSQL.IsCustomSqlSyntax (Database.Beam.Backend.SQL.BeamSqlBackendExpressionSyntax be) => GHC.Base.Semigroup (Database.Beam.Query.CustomSQL.CustomSqlSnippet be)
instance Database.Beam.Query.CustomSQL.IsCustomSqlSyntax (Database.Beam.Backend.SQL.BeamSqlBackendExpressionSyntax be) => GHC.Base.Monoid (Database.Beam.Query.CustomSQL.CustomSqlSnippet be)
instance Database.Beam.Query.CustomSQL.IsCustomSqlSyntax (Database.Beam.Backend.SQL.BeamSqlBackendExpressionSyntax be) => Data.String.IsString (Database.Beam.Query.CustomSQL.CustomSqlSnippet be)
instance Database.Beam.Query.CustomSQL.IsCustomSqlSyntax Database.Beam.Backend.SQL.Builder.SqlSyntaxBuilder

module Database.Beam.Query.CTE
data Recursiveness be
[Nonrecursive] :: Recursiveness be
[Recursive] :: IsSql99RecursiveCommonTableExpressionSelectSyntax (BeamSqlBackendSelectSyntax be) => Recursiveness be

-- | Monad in which <tt>SELECT</tt> statements can be made (via
--   <a>selecting</a>) and bound to result names for re-use later. This has
--   the advantage of only computing each result once. In SQL, this is
--   translated to a common table expression.
--   
--   Once introduced, results can be re-used in future queries with
--   <a>reuse</a>.
--   
--   <a>With</a> is also a member of <a>MonadFix</a> for backends that
--   support recursive CTEs. In this case, you can use <tt>mdo</tt> or
--   <tt>rec</tt> notation (with <tt>RecursiveDo</tt> enabled) to bind
--   result values (again, using <a>reuse</a>) even <i>before</i> they're
--   introduced.
--   
--   See further documentation <a>here</a>.
newtype With be (db :: (Type -> Type) -> Type) a
With :: WriterT (Recursiveness be, [BeamSql99BackendCTESyntax be]) (State Int) a -> With be (db :: (Type -> Type) -> Type) a
[runWith] :: With be (db :: (Type -> Type) -> Type) a -> WriterT (Recursiveness be, [BeamSql99BackendCTESyntax be]) (State Int) a
data QAnyScope

-- | Query results that have been introduced into a common table expression
--   via <a>selecting</a> that can be used in future queries with
--   <a>reuse</a>.
data ReusableQ be db res
[ReusableQ] :: Proxy res -> (forall s. Proxy s -> Q be db s (WithRewrittenThread QAnyScope s res)) -> ReusableQ be db res
reusableForCTE :: forall be res db. (ThreadRewritable QAnyScope res, Projectible be res, BeamSqlBackend be) => Text -> ReusableQ be db res

-- | Introduce the result of a query as a result in a common table
--   expression. The returned value can be used in future queries by
--   applying <a>reuse</a>.
selecting :: forall res be db. (BeamSql99CommonTableExpressionBackend be, HasQBuilder be, Projectible be res, ThreadRewritable QAnyScope res) => Q be db QAnyScope res -> With be db (ReusableQ be db res)

-- | Introduces the result of a previous <a>selecting</a> (a CTE) into a
--   new query
reuse :: forall s be db res. ReusableQ be db res -> Q be db s (WithRewrittenThread QAnyScope s res)
instance GHC.Base.Functor (Database.Beam.Query.CTE.With be db)
instance GHC.Base.Applicative (Database.Beam.Query.CTE.With be db)
instance GHC.Base.Monad (Database.Beam.Query.CTE.With be db)
instance Database.Beam.Backend.SQL.SQL99.IsSql99RecursiveCommonTableExpressionSelectSyntax (Database.Beam.Backend.SQL.BeamSqlBackendSelectSyntax be) => Control.Monad.Fix.MonadFix (Database.Beam.Query.CTE.With be db)
instance GHC.Base.Monoid (Database.Beam.Query.CTE.Recursiveness be)
instance GHC.Base.Semigroup (Database.Beam.Query.CTE.Recursiveness be)


-- | This module contains support for defining "ad-hoc" queries. That is
--   queries on tables that do not necessarily have corresponding
--   <tt>Beamable</tt> table types.
module Database.Beam.Query.Adhoc
class Adhoc structure where {
    type family AdhocTable structure (f :: Type -> Type) :: Type;
}
mkAdhocField :: Adhoc structure => (forall a. Text -> f a) -> structure -> AdhocTable structure f
data NamedField a

-- | Introduce a table into a query without using the <tt>Beamable</tt> and
--   <tt>Database</tt> machinery.
--   
--   The first argument is the optional name of the schema the table is in
--   and the second is the name of the table to source from.
--   
--   The third argument is a tuple (or any nesting of tuples) where each
--   value is of type <a>NamedField</a> (use <a>field_</a> to construct).
--   
--   The return value is a tuple (or any nesting of tuples) of the same
--   shape as <tt>structure</tt> but where each value is a <a>QExpr</a>.
--   
--   For example, to source from the table <tt>Table1</tt>, with fields
--   <tt>Field1</tt> (A boolean), <tt>Field2</tt> (a timestamp), and
--   <tt>Field3</tt> (a string)
--   
--   <pre>
--   table_ Nothing "Table1" ( field_ @Bool "Field1", field_ @UTCTime "Field2", field_ @Text "Field3" )
--   </pre>
table_ :: forall be db structure s. (Adhoc structure, BeamSqlBackend be, Projectible be (AdhocTable structure (QExpr be s))) => Maybe Text -> Text -> structure -> Q be db s (AdhocTable structure (QExpr be s))

-- | Used to construct <a>NamedField</a>s, most often with an explicitly
--   applied type.
--   
--   The type can be omitted if the value is used unambiguously elsewhere.
field_ :: forall a. Text -> NamedField a
instance Database.Beam.Query.Adhoc.Adhoc (Database.Beam.Query.Adhoc.NamedField a)
instance (Database.Beam.Query.Adhoc.Adhoc a, Database.Beam.Query.Adhoc.Adhoc b) => Database.Beam.Query.Adhoc.Adhoc (a, b)
instance (Database.Beam.Query.Adhoc.Adhoc a, Database.Beam.Query.Adhoc.Adhoc b, Database.Beam.Query.Adhoc.Adhoc c) => Database.Beam.Query.Adhoc.Adhoc (a, b, c)
instance (Database.Beam.Query.Adhoc.Adhoc a, Database.Beam.Query.Adhoc.Adhoc b, Database.Beam.Query.Adhoc.Adhoc c, Database.Beam.Query.Adhoc.Adhoc d) => Database.Beam.Query.Adhoc.Adhoc (a, b, c, d)
instance (Database.Beam.Query.Adhoc.Adhoc a, Database.Beam.Query.Adhoc.Adhoc b, Database.Beam.Query.Adhoc.Adhoc c, Database.Beam.Query.Adhoc.Adhoc d, Database.Beam.Query.Adhoc.Adhoc e) => Database.Beam.Query.Adhoc.Adhoc (a, b, c, d, e)
instance (Database.Beam.Query.Adhoc.Adhoc a, Database.Beam.Query.Adhoc.Adhoc b, Database.Beam.Query.Adhoc.Adhoc c, Database.Beam.Query.Adhoc.Adhoc d, Database.Beam.Query.Adhoc.Adhoc e, Database.Beam.Query.Adhoc.Adhoc f) => Database.Beam.Query.Adhoc.Adhoc (a, b, c, d, e, f)
instance (Database.Beam.Query.Adhoc.Adhoc a, Database.Beam.Query.Adhoc.Adhoc b, Database.Beam.Query.Adhoc.Adhoc c, Database.Beam.Query.Adhoc.Adhoc d, Database.Beam.Query.Adhoc.Adhoc e, Database.Beam.Query.Adhoc.Adhoc f, Database.Beam.Query.Adhoc.Adhoc g) => Database.Beam.Query.Adhoc.Adhoc (a, b, c, d, e, f, g)
instance (Database.Beam.Query.Adhoc.Adhoc a, Database.Beam.Query.Adhoc.Adhoc b, Database.Beam.Query.Adhoc.Adhoc c, Database.Beam.Query.Adhoc.Adhoc d, Database.Beam.Query.Adhoc.Adhoc e, Database.Beam.Query.Adhoc.Adhoc f, Database.Beam.Query.Adhoc.Adhoc g, Database.Beam.Query.Adhoc.Adhoc h) => Database.Beam.Query.Adhoc.Adhoc (a, b, c, d, e, f, g, h)

module Database.Beam.Query
type Projectible be = ProjectibleWithPredicate AnyType be (WithExprContext (BeamSqlBackendExpressionSyntax' be))
data QWindow be s

-- | <a>QExpr</a>s represent expressions not containing aggregates.
type QExpr = QGenExpr QValueContext

-- | The type of lifted beam expressions that will yield the haskell type
--   <tt>t</tt>.
--   
--   <tt>context</tt> is a type-level representation of the types of
--   expressions this can contain. For example, <a>QAggregateContext</a>
--   represents expressions that may contain aggregates, and
--   <a>QWindowingContext</a> represents expressions that may contain
--   <tt>OVER</tt>.
--   
--   <tt>syntax</tt> is the expression syntax being built (usually a type
--   that implements <a>IsSql92ExpressionSyntax</a> at least, but not
--   always).
--   
--   <tt>s</tt> is a state threading parameter that prevents <a>QExpr</a>s
--   from incompatible sources to be combined. For example, this is used to
--   prevent monadic joins from depending on the result of previous joins
--   (so-called <tt>LATERAL</tt> joins).
newtype QGenExpr context be s t
QExpr :: (TablePrefix -> BeamSqlBackendExpressionSyntax be) -> QGenExpr context be s t

-- | The type of queries over the database <tt>db</tt> returning results of
--   type <tt>a</tt>. The <tt>s</tt> argument is a threading argument meant
--   to restrict cross-usage of <a>QExpr</a>s. <tt>syntax</tt> represents
--   the SQL syntax that this query is building.
data Q be (db :: (Type -> Type) -> Type) s a
class BeamSqlBackend be => HasQBuilder be
buildSqlQuery :: (HasQBuilder be, Projectible be a) => TablePrefix -> Q be db s a -> BeamSqlBackendSelectSyntax be
type family QExprToField x
type family QExprToIdentity x
data QAggregateContext
data QGroupingContext
data QValueContext
data QWindowingContext
data QWindowFrameContext

-- | A version of the table where each field is a <a>QGenExpr</a>
type QGenExprTable ctxt be s tbl = tbl (QGenExpr ctxt be s)
type QExprTable be s tbl = QGenExprTable QValueContext be s tbl
data QAssignment be s
data QField s ty
data QFieldAssignment be tbl a
data QBaseScope

-- | SQL <tt>COALESCE</tt> support
coalesce_ :: BeamSqlBackend be => [QGenExpr ctxt be s (Maybe a)] -> QGenExpr ctxt be s a -> QGenExpr ctxt be s a

-- | Convert a <a>Maybe</a> value to a concrete value, by suppling a
--   default
fromMaybe_ :: BeamSqlBackend be => QGenExpr ctxt be s a -> QGenExpr ctxt be s (Maybe a) -> QGenExpr ctxt be s a

-- | SQL <tt>POSITION(.. IN ..)</tt> function
position_ :: (BeamSqlBackendIsString be text, BeamSqlBackend be, Integral b) => QExpr be s text -> QExpr be s text -> QExpr be s b

-- | SQL <tt>CHAR_LENGTH</tt> function
charLength_ :: (BeamSqlBackend be, BeamSqlBackendIsString be text, Integral a) => QGenExpr context be s text -> QGenExpr context be s a

-- | SQL <tt>OCTET_LENGTH</tt> function
octetLength_ :: (BeamSqlBackend be, BeamSqlBackendIsString be text, Integral a) => QGenExpr context be s text -> QGenExpr context be s a

-- | SQL <tt>BIT_LENGTH</tt> function
bitLength_ :: (BeamSqlBackend be, Integral a) => QGenExpr context be s SqlBitString -> QGenExpr context be s a

-- | SQL <tt>CURRENT_TIMESTAMP</tt> function
currentTimestamp_ :: BeamSqlBackend be => QGenExpr ctxt be s LocalTime

-- | SQL <tt>LOWER</tt> function
lower_ :: (BeamSqlBackendIsString be text, BeamSqlBackend be) => QGenExpr context be s text -> QGenExpr context be s text

-- | SQL <tt>UPPER</tt> function
upper_ :: (BeamSqlBackendIsString be text, BeamSqlBackend be) => QGenExpr context be s text -> QGenExpr context be s text

-- | SQL <tt>TRIM</tt> function
trim_ :: (BeamSqlBackendIsString be text, BeamSqlBackend be) => QGenExpr context be s text -> QGenExpr context be s text
if_ :: BeamSqlBackend be => [QIfCond context be s a] -> QIfElse context be s a -> QGenExpr context be s a
then_ :: QGenExpr context be s Bool -> QGenExpr context be s a -> QIfCond context be s a
else_ :: QGenExpr context be s a -> QIfElse context be s a
then_' :: QGenExpr context be s SqlBool -> QGenExpr context be s a -> QIfCond context be s a
ifThenElse_ :: BeamSqlBackend be => QGenExpr context be s Bool -> QGenExpr context be s a -> QGenExpr context be s a -> QGenExpr context be s a
bool_ :: BeamSqlBackend be => QGenExpr context be s a -> QGenExpr context be s a -> QGenExpr context be s Bool -> QGenExpr context be s a

-- | Update a <a>QField</a> or <a>Beamable</a> type containing
--   <a>QField</a>s with the given <a>QExpr</a> or <a>Beamable</a> type
--   containing <a>QExpr</a>
(<-.) :: SqlUpdatable be s lhs rhs => lhs -> rhs -> QAssignment be s
infix 4 <-.

-- | Extract an expression representing the current (non-UPDATEd) value of
--   a <a>QField</a>
current_ :: BeamSqlBackend be => QField s ty -> QExpr be s ty
type family HaskellLiteralForQExpr x = a
class SqlValable a
val_ :: SqlValable a => HaskellLiteralForQExpr a -> a
type SqlValableTable be table = (Beamable table, FieldsFulfillConstraint (HasSqlValueSyntax (BeamSqlBackendValueSyntax be)) table)
default_ :: BeamSqlBackend be => QGenExpr ctxt be s a

-- | Introduce all entries of a table into the <a>Q</a> monad
all_ :: (Database be db, BeamSqlBackend be) => DatabaseEntity be db (TableEntity table) -> Q be db s (table (QExpr be s))

-- | SQL <tt>VALUES</tt> clause. Introduce the elements of the given list
--   as rows in a joined table.
values_ :: forall be db s a. (Projectible be a, BeamSqlBackend be) => [a] -> Q be db s a

-- | Introduce all entries of a view into the <a>Q</a> monad
allFromView_ :: (Database be db, Beamable table, BeamSqlBackend be) => DatabaseEntity be db (ViewEntity table) -> Q be db s (table (QExpr be s))

-- | Introduce all entries of a table into the <a>Q</a> monad based on the
--   given QExpr. The join condition is expected to return a <a>Bool</a>.
--   For a version that takes <a>SqlBool</a> (a possibly <tt>UNKNOWN</tt>
--   boolean, that maps more closely to the SQL standard), see
--   <a>join_'</a>.
join_ :: (Database be db, Table table, BeamSqlBackend be) => DatabaseEntity be db (TableEntity table) -> (table (QExpr be s) -> QExpr be s Bool) -> Q be db s (table (QExpr be s))

-- | Like <a>join_</a>, but accepting an <tt>ON</tt> condition that returns
--   <a>SqlBool</a>
join_' :: (Database be db, Table table, BeamSqlBackend be) => DatabaseEntity be db (TableEntity table) -> (table (QExpr be s) -> QExpr be s SqlBool) -> Q be db s (table (QExpr be s))

-- | Only allow results for which the <a>QExpr</a> yields <a>True</a>. For
--   a version that operates over possibly <tt>NULL</tt> <a>SqlBool</a>s,
--   see <a>guard_'</a>.
guard_ :: forall be db s. BeamSqlBackend be => QExpr be s Bool -> Q be db s ()

-- | Only allow results for which the <a>QExpr</a> yields <tt>TRUE</tt>.
--   
--   This function operates over <a>SqlBool</a>, which are like haskell
--   <a>Bool</a>s, except for the special <tt>UNKNOWN</tt> value that
--   occurs when comparisons include <tt>NULL</tt>. For a version that
--   operates over known non-<tt>NULL</tt> booleans, see <a>guard_</a>.
guard_' :: forall be db s. BeamSqlBackend be => QExpr be s SqlBool -> Q be db s ()

-- | Synonym for <tt>clause &gt;&gt;= \x -&gt; guard_ (mkExpr x)&gt;&gt;
--   pure x</tt>. Use <a>filter_'</a> for comparisons with <a>SqlBool</a>
filter_ :: forall r be db s. BeamSqlBackend be => (r -> QExpr be s Bool) -> Q be db s r -> Q be db s r

-- | Synonym for <tt>clause &gt;&gt;= \x -&gt; guard_' (mkExpr x)&gt;&gt;
--   pure x</tt>. Use <a>filter_</a> for comparisons with <a>Bool</a>
filter_' :: forall r be db s. BeamSqlBackend be => (r -> QExpr be s SqlBool) -> Q be db s r -> Q be db s r

-- | Introduce all entries of the given table which are referenced by the
--   given <a>PrimaryKey</a>
related_ :: forall be db rel s. (Database be db, Table rel, BeamSqlBackend be, HasTableEquality be (PrimaryKey rel)) => DatabaseEntity be db (TableEntity rel) -> PrimaryKey rel (QExpr be s) -> Q be db s (rel (QExpr be s))

-- | Introduce all entries of the given table for which the expression
--   (which can depend on the queried table returns true)
relatedBy_ :: forall be db rel s. (Database be db, Table rel, BeamSqlBackend be) => DatabaseEntity be db (TableEntity rel) -> (rel (QExpr be s) -> QExpr be s Bool) -> Q be db s (rel (QExpr be s))

-- | Introduce all entries of the given table for which the expression
--   (which can depend on the queried table returns true)
relatedBy_' :: forall be db rel s. (Database be db, Table rel, BeamSqlBackend be) => DatabaseEntity be db (TableEntity rel) -> (rel (QExpr be s) -> QExpr be s SqlBool) -> Q be db s (rel (QExpr be s))

-- | Introduce a table using a left join. The ON clause is required
--   here.Because this is not an inner join, the resulting table is made
--   nullable. This means that each field that would normally have type
--   'QExpr x' will now have type 'QExpr (Maybe x)'.
--   
--   The <tt>ON</tt> condition given must return <a>Bool</a>. For a version
--   that accepts an <tt>ON</tt> condition returning <a>SqlBool</a>, see
--   <a>leftJoin_'</a>.
leftJoin_ :: forall s r be db. (BeamSqlBackend be, Projectible be r, ThreadRewritable (QNested s) r, Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s r)) => Q be db (QNested s) r -> (WithRewrittenThread (QNested s) s r -> QExpr be s Bool) -> Q be db s (Retag Nullable (WithRewrittenThread (QNested s) s r))

-- | Like <a>leftJoin_</a>, but accepts an <tt>ON</tt> clause returning
--   <a>SqlBool</a>.
leftJoin_' :: forall s r be db. (BeamSqlBackend be, Projectible be r, ThreadRewritable (QNested s) r, Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s r)) => Q be db (QNested s) r -> (WithRewrittenThread (QNested s) s r -> QExpr be s SqlBool) -> Q be db s (Retag Nullable (WithRewrittenThread (QNested s) s r))

-- | Introduce a table using a left join with no ON clause. Because this is
--   not an inner join, the resulting table is made nullable. This means
--   that each field that would normally have type 'QExpr x' will now have
--   type 'QExpr (Maybe x)'.
perhaps_ :: forall s r be db. (Projectible be r, BeamSqlBackend be, ThreadRewritable (QNested s) r, Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s r)) => Q be db (QNested s) r -> Q be db s (Retag Nullable (WithRewrittenThread (QNested s) s r))

-- | Outer join. every row of each table, returning <tt>NULL</tt> for any
--   row of either table for which the join condition finds no related
--   rows.
--   
--   This expects a join expression returning <a>Bool</a>, for a version
--   that accepts a <a>SqlBool</a> (a possibly <tt>UNKNOWN</tt> boolean,
--   that maps more closely to the SQL standard), see <a>outerJoin_'</a>
outerJoin_ :: forall s a b be db. (BeamSqlBackend be, BeamSqlBackendSupportsOuterJoin be, Projectible be a, Projectible be b, ThreadRewritable (QNested s) a, ThreadRewritable (QNested s) b, Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s a), Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s b)) => Q be db (QNested s) a -> Q be db (QNested s) b -> ((WithRewrittenThread (QNested s) s a, WithRewrittenThread (QNested s) s b) -> QExpr be s Bool) -> Q be db s (Retag Nullable (WithRewrittenThread (QNested s) s a), Retag Nullable (WithRewrittenThread (QNested s) s b))

-- | Like <a>outerJoin_</a>, but accepting <a>SqlBool</a>. Pairs of rows
--   for which the join condition is unknown are considered to be
--   unrelated, by SQL compliant databases at least.
outerJoin_' :: forall s a b be db. (BeamSqlBackend be, BeamSqlBackendSupportsOuterJoin be, Projectible be a, Projectible be b, ThreadRewritable (QNested s) a, ThreadRewritable (QNested s) b, Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s a), Retaggable (QExpr be s) (WithRewrittenThread (QNested s) s b)) => Q be db (QNested s) a -> Q be db (QNested s) b -> ((WithRewrittenThread (QNested s) s a, WithRewrittenThread (QNested s) s b) -> QExpr be s SqlBool) -> Q be db s (Retag Nullable (WithRewrittenThread (QNested s) s a), Retag Nullable (WithRewrittenThread (QNested s) s b))
subselect_ :: forall s r be db. (ThreadRewritable (QNested s) r, Projectible be r) => Q be db (QNested s) r -> Q be db s (WithRewrittenThread (QNested s) s r)

-- | Generate an appropriate boolean <a>QGenExpr</a> comparing the given
--   foreign key to the given table. Useful for creating join conditions.
--   Use <a>references_'</a> for a <a>SqlBool</a> comparison.
references_ :: (Table t, BeamSqlBackend be, HasTableEquality be (PrimaryKey t)) => PrimaryKey t (QGenExpr ctxt be s) -> t (QGenExpr ctxt be s) -> QGenExpr ctxt be s Bool

-- | Generate an appropriate boolean <a>QGenExpr</a> comparing the given
--   foreign key to the given table. Useful for creating join conditions.
--   Use <a>references_</a> for a <a>Bool</a> comparison.
references_' :: (Table t, BeamSqlBackend be, HasTableEquality be (PrimaryKey t)) => PrimaryKey t (QGenExpr ctxt be s) -> t (QGenExpr ctxt be s) -> QGenExpr ctxt be s SqlBool

-- | Only return distinct values from a query
nub_ :: (BeamSqlBackend be, Projectible be r) => Q be db s r -> Q be db s r

-- | Type class for things that can be nullable. This includes 'QExpr
--   (Maybe a)', 'tbl (Nullable QExpr)', and 'PrimaryKey tbl (Nullable
--   QExpr)'
class SqlJustable a b | b -> a

-- | Given something of type 'QExpr a', 'tbl QExpr', or 'PrimaryKey tbl
--   QExpr', turn it into a 'QExpr (Maybe a)', 'tbl (Nullable QExpr)', or
--   'PrimaryKey t (Nullable QExpr)' respectively that contains the same
--   values.
just_ :: SqlJustable a b => a -> b

-- | Return either a 'QExpr (Maybe x)' representing <a>Nothing</a> or a
--   nullable <a>Table</a> or <a>PrimaryKey</a> filled with <a>Nothing</a>.
nothing_ :: SqlJustable a b => b

-- | Type class for anything which can be checked for null-ness. This
--   includes 'QExpr (Maybe a)' as well as <a>Table</a>s or
--   <a>PrimaryKey</a>s over 'Nullable QExpr'.
class BeamSqlBackend be => SqlDeconstructMaybe be a nonNullA s | a s -> be, a -> nonNullA, a -> s, nonNullA -> s

-- | Returns a <a>QExpr</a> that evaluates to true when the first argument
--   is not null
isJust_ :: SqlDeconstructMaybe be a nonNullA s => a -> QGenExpr ctxt be s Bool

-- | Returns a <a>QExpr</a> that evaluates to true when the first argument
--   is null
isNothing_ :: SqlDeconstructMaybe be a nonNullA s => a -> QGenExpr ctxt be s Bool

-- | Given an object (third argument) which may or may not be null, return
--   the default value if null (first argument), or transform the value
--   that could be null to yield the result of the expression (second
--   argument)
maybe_ :: SqlDeconstructMaybe be a nonNullA s => QGenExpr ctxt be s y -> (nonNullA -> QGenExpr ctxt be s y) -> a -> QGenExpr ctxt be s y
class SqlOrderable be a | a -> be
data QIfCond context be s a
data QIfElse context be s a
(<|>.) :: (SqlJustable a (QGenExpr ctxt syntax s y), SqlDeconstructMaybe syntax (QGenExpr ctxt syntax s y) a s) => QGenExpr ctxt syntax s y -> QGenExpr ctxt syntax s y -> QGenExpr ctxt syntax s y
infixl 3 <|>.

-- | Limit the number of results returned by a query.
limit_ :: forall s a be db. (Projectible be a, ThreadRewritable (QNested s) a) => Integer -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)

-- | Drop the first <tt>offset</tt>` results.
offset_ :: forall s a be db. (Projectible be a, ThreadRewritable (QNested s) a) => Integer -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)

-- | Convenience function that allows you to use type applications to
--   specify the result of a <a>QGenExpr</a>.
--   
--   Useful to disambiguate the types of <a>QGenExpr</a>s without having to
--   provide a complete type signature. As an example, the
--   <tt>countAll_</tt> aggregate can return a result of any
--   <a>Integral</a> type. Without further constraints, the type is
--   ambiguous. You can use <a>as_</a> to disambiguate the return type.
--   
--   For example, this is ambiguous
--   
--   <pre>
--   aggregate_ (\_ -&gt; countAll_) ..
--   </pre>
--   
--   But this is not
--   
--   <pre>
--   aggregate_ (\_ -&gt; as_ @Int32 countAll_) ..
--   </pre>
as_ :: forall a ctxt be s. QGenExpr ctxt be s a -> QGenExpr ctxt be s a

-- | Use the SQL <tt>EXISTS</tt> operator to determine if the given query
--   returns any results
exists_ :: (BeamSqlBackend be, HasQBuilder be, Projectible be a) => Q be db s a -> QExpr be s Bool

-- | Use the SQL <tt>UNIQUE</tt> operator to determine if the given query
--   produces a unique result
unique_ :: (BeamSqlBackend be, HasQBuilder be, Projectible be a) => Q be db s a -> QExpr be s Bool

-- | Use the SQL99 <tt>DISTINCT</tt> operator to determine if the given
--   query produces a distinct result
distinct_ :: (BeamSqlBackend be, BeamSql99ExpressionBackend be, HasQBuilder be, Projectible be a) => Q be db s a -> QExpr be s Bool

-- | Project the (presumably) singular result of the given query as an
--   expression
subquery_ :: (BeamSqlBackend be, HasQBuilder be, Projectible be (QExpr be s a)) => Q be db s (QExpr be s a) -> QGenExpr ctxt be s a

-- | SQL <tt>UNION</tt> operator
union_ :: forall be db s a. (BeamSqlBackend be, Projectible be a, ThreadRewritable (QNested s) a) => Q be db (QNested s) a -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)

-- | SQL <tt>UNION ALL</tt> operator
unionAll_ :: forall be db s a. (BeamSqlBackend be, Projectible be a, ThreadRewritable (QNested s) a) => Q be db (QNested s) a -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)

-- | SQL <tt>INTERSECT</tt> operator
intersect_ :: forall be db s a. (BeamSqlBackend be, Projectible be a, ThreadRewritable (QNested s) a) => Q be db (QNested s) a -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)

-- | SQL <tt>INTERSECT ALL</tt> operator
intersectAll_ :: forall be db s a. (BeamSqlBackend be, Projectible be a, ThreadRewritable (QNested s) a) => Q be db (QNested s) a -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)

-- | SQL <tt>EXCEPT</tt> operator
except_ :: forall be db s a. (BeamSqlBackend be, Projectible be a, ThreadRewritable (QNested s) a) => Q be db (QNested s) a -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)

-- | SQL <tt>EXCEPT ALL</tt> operator
exceptAll_ :: forall be db s a. (BeamSqlBackend be, Projectible be a, ThreadRewritable (QNested s) a) => Q be db (QNested s) a -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)

-- | Produce a window expression given an aggregate function and a window.
over_ :: BeamSql2003ExpressionBackend be => QAgg be s a -> QWindow be s -> QWindowExpr be s a

-- | Specify a window frame with all the options
frame_ :: forall be ordering partition s. (BeamSql2003ExpressionBackend be, SqlOrderable be ordering, Projectible be partition) => Maybe partition -> Maybe ordering -> QFrameBounds be -> QWindow be s
bounds_ :: BeamSql2003ExpressionBackend be => QFrameBound be -> Maybe (QFrameBound be) -> QFrameBounds be
unbounded_ :: BeamSql2003ExpressionBackend be => QFrameBound be
nrows_ :: BeamSql2003ExpressionBackend be => Int -> QFrameBound be
fromBound_ :: BeamSql2003ExpressionBackend be => QFrameBound be -> QFrameBounds be
noBounds_ :: QFrameBounds be
noOrder_ :: Integral a => Maybe (QOrd be s a)
noPartition_ :: Integral a => Maybe (QExpr be s a)
partitionBy_ :: partition -> Maybe partition
orderPartitionBy_ :: partition -> Maybe partition

-- | Compute a query over windows.
--   
--   The first function builds window frames using the <a>frame_</a>,
--   <a>partitionBy_</a>, etc functions. The return type can be a single
--   frame, tuples of frame, or any arbitrarily nested tuple of the above.
--   Instances up to 8-tuples are provided.
--   
--   The second function builds the resulting projection using the result
--   of the subquery as well as the window frames built in the first
--   function. In this function, window expressions can be included in the
--   output using the <a>over_</a> function.
withWindow_ :: forall window a s r be db. (ProjectibleWithPredicate WindowFrameContext be (WithExprContext (BeamSqlBackendWindowFrameSyntax' be)) window, Projectible be r, Projectible be a, ContextRewritable a, ThreadRewritable (QNested s) (WithRewrittenContext a QValueContext)) => (r -> window) -> (r -> window -> a) -> Q be db (QNested s) r -> Q be db s (WithRewrittenThread (QNested s) s (WithRewrittenContext a QValueContext))

-- | Order by the given expressions. The return type of the ordering key
--   should either be the result of <a>asc_</a> or <a>desc_</a> (or another
--   ordering <a>QOrd</a> generated by a backend-specific ordering) or an
--   (possibly nested) tuple of results of the former.
--   
--   The <a>manual section</a> has more information.
orderBy_ :: forall s a ordering be db. (Projectible be a, SqlOrderable be ordering, ThreadRewritable (QNested s) a) => (a -> ordering) -> Q be db (QNested s) a -> Q be db s (WithRewrittenThread (QNested s) s a)

-- | Produce a <a>QOrd</a> corresponding to a SQL <tt>ASC</tt> ordering
asc_ :: forall be s a. BeamSqlBackend be => QExpr be s a -> QOrd be s a

-- | Produce a <a>QOrd</a> corresponding to a SQL <tt>DESC</tt> ordering
desc_ :: forall be s a. BeamSqlBackend be => QExpr be s a -> QOrd be s a
nullsFirst_ :: IsSql2003OrderingElementaryOLAPOperationsSyntax (BeamSqlBackendOrderingSyntax be) => QOrd be s a -> QOrd be s a
nullsLast_ :: IsSql2003OrderingElementaryOLAPOperationsSyntax (BeamSqlBackendOrderingSyntax be) => QOrd be s a -> QOrd be s a
ntile_ :: (BeamSqlBackend be, BeamSqlT614Backend be, Integral n) => QExpr be s n -> QAgg be s a
lead1_ :: (BeamSqlBackend be, BeamSqlT615Backend be) => QExpr be s a -> QAgg be s a
lag1_ :: (BeamSqlBackend be, BeamSqlT615Backend be) => QExpr be s a -> QAgg be s a
lead_ :: (BeamSqlBackend be, BeamSqlT615Backend be, Integral n) => QExpr be s a -> QExpr be s n -> QAgg be s a
lag_ :: (BeamSqlBackend be, BeamSqlT615Backend be, Integral n) => QExpr be s a -> QExpr be s n -> QAgg be s a
leadWithDefault_ :: (BeamSqlBackend be, BeamSqlT615Backend be, Integral n) => QExpr be s a -> QExpr be s n -> QExpr be s a -> QAgg be s a
lagWithDefault_ :: (BeamSqlBackend be, BeamSqlT615Backend be, Integral n) => QExpr be s a -> QExpr be s n -> QExpr be s a -> QAgg be s a
firstValue_ :: (BeamSqlBackend be, BeamSqlT616Backend be) => QExpr be s a -> QAgg be s a
lastValue_ :: (BeamSqlBackend be, BeamSqlT616Backend be) => QExpr be s a -> QAgg be s a
nthValue_ :: (BeamSqlBackend be, BeamSqlT618Backend be, Integral n) => QExpr be s a -> QExpr be s n -> QAgg be s a
(**.) :: (Floating a, BeamSqlBackend be, BeamSqlT621Backend be) => QGenExpr ctxt be s a -> QGenExpr ctxt be s a -> QGenExpr ctxt be s a
infixr 8 **.
ln_ :: (Floating a, BeamSqlBackend be, BeamSqlT621Backend be) => QGenExpr ctxt be s a -> QGenExpr ctxt be s a
exp_ :: (Floating a, BeamSqlBackend be, BeamSqlT621Backend be) => QGenExpr ctxt be s a -> QGenExpr ctxt be s a
sqrt_ :: (Floating a, BeamSqlBackend be, BeamSqlT621Backend be) => QGenExpr ctxt be s a -> QGenExpr ctxt be s a
ceiling_ :: (RealFrac a, Integral b, BeamSqlBackend be, BeamSqlT621Backend be) => QGenExpr ctxt be s a -> QGenExpr ctxt be s b
floor_ :: (RealFrac a, Integral b, BeamSqlBackend be, BeamSqlT621Backend be) => QGenExpr ctxt be s a -> QGenExpr ctxt be s b
stddevPopOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QAgg be s b
stddevSampOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QAgg be s b
varPopOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QAgg be s b
varSampOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QAgg be s b
stddevPop_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QAgg be s b
stddevSamp_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QAgg be s b
varPop_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QAgg be s b
varSamp_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QAgg be s b
covarPopOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
covarSampOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
corrOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
regrSlopeOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
regrInterceptOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
regrCountOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
regrRSquaredOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
regrAvgXOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
regrAvgYOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
regrSXXOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
regrSYYOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
regrSXYOver_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QExpr be s a -> QExpr be s b
covarPop_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
covarSamp_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
corr_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
regrSlope_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
regrIntercept_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
regrCount_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
regrRSquared_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
regrAvgX_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
regrAvgY_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
regrSXX_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
regrSYY_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b
regrSXY_ :: (Num a, Floating b, BeamSqlBackend be, BeamSqlT621Backend be) => QExpr be s a -> QExpr be s a -> QExpr be s b

-- | Convenience type to declare many-to-many relationships. See the manual
--   section on <a>relationships</a> for more information
type ManyToMany be db left right = forall s. (BeamSqlBackend be, SqlEq (QExpr be s) (PrimaryKey left (QExpr be s)), SqlEq (QExpr be s) (PrimaryKey right (QExpr be s))) => Q be db s (left (QExpr be s)) -> Q be db s (right (QExpr be s)) -> Q be db s (left (QExpr be s), right (QExpr be s))

-- | Convenience type to declare many-to-many relationships with additional
--   data. See the manual section on <a>relationships</a> for more
--   information
type ManyToManyThrough be db through left right = forall s. (BeamSqlBackend be, SqlEq (QExpr be s) (PrimaryKey left (QExpr be s)), SqlEq (QExpr be s) (PrimaryKey right (QExpr be s))) => Q be db s (left (QExpr be s)) -> Q be db s (right (QExpr be s)) -> Q be db s (through (QExpr be s), left (QExpr be s), right (QExpr be s))

-- | Used to define many-to-many relationships without any additional data.
--   Takes the join table and two key extraction functions from that table
--   to the related tables. Also takes two <a>Q</a>s representing the table
--   sources to relate.
--   
--   See <a>the manual</a> for more information.
manyToMany_ :: (Database be db, Table joinThrough, Table left, Table right, BeamSqlBackend be, SqlEq (QExpr be s) (PrimaryKey left (QExpr be s)), SqlEq (QExpr be s) (PrimaryKey right (QExpr be s))) => DatabaseEntity be db (TableEntity joinThrough) -> (joinThrough (QExpr be s) -> PrimaryKey left (QExpr be s)) -> (joinThrough (QExpr be s) -> PrimaryKey right (QExpr be s)) -> Q be db s (left (QExpr be s)) -> Q be db s (right (QExpr be s)) -> Q be db s (left (QExpr be s), right (QExpr be s))

-- | Used to define many-to-many relationships with additional data. Takes
--   the join table and two key extraction functions from that table to the
--   related tables. Also takes two <a>Q</a>s representing the table
--   sources to relate.
--   
--   See <a>the manual</a> for more information.
manyToManyPassthrough_ :: (Database be db, Table joinThrough, Table left, Table right, BeamSqlBackend be, SqlEq (QExpr be s) (PrimaryKey left (QExpr be s)), SqlEq (QExpr be s) (PrimaryKey right (QExpr be s))) => DatabaseEntity be db (TableEntity joinThrough) -> (joinThrough (QExpr be s) -> PrimaryKey left (QExpr be s)) -> (joinThrough (QExpr be s) -> PrimaryKey right (QExpr be s)) -> Q be db s (left (QExpr be s)) -> Q be db s (right (QExpr be s)) -> Q be db s (joinThrough (QExpr be s), left (QExpr be s), right (QExpr be s))

-- | Convenience type to declare one-to-many relationships. See the manual
--   section on <a>relationships</a> for more information
type OneToMany be db s one many = (BeamSqlBackend be, BeamSqlBackendCanSerialize be Bool) => one (QExpr be s) -> Q be db s (many (QExpr be s))

-- | Convenience type to declare one-to-many relationships with a nullable
--   foreign key. See the manual section on <a>relationships</a> for more
--   information
type OneToManyOptional be db s tbl rel = (BeamSqlBackend be, BeamSqlBackendCanSerialize be Bool, BeamSqlBackendCanSerialize be SqlNull) => tbl (QExpr be s) -> Q be db s (rel (Nullable (QExpr be s)))

-- | Used to define one-to-many (or one-to-one) relationships. Takes the
--   table to fetch, a way to extract the foreign key from that table, and
--   the table to relate to.
oneToMany_ :: (Database be db, BeamSqlBackend be, HasTableEquality be (PrimaryKey tbl), Table tbl, Table rel) => DatabaseEntity be db (TableEntity rel) -> (rel (QExpr be s) -> PrimaryKey tbl (QExpr be s)) -> tbl (QExpr be s) -> Q be db s (rel (QExpr be s))

-- | Used to define one-to-many (or one-to-one) relationships with a
--   nullable foreign key. Takes the table to fetch, a way to extract the
--   foreign key from that table, and the table to relate to.
oneToManyOptional_ :: (BeamSqlBackend be, Database be db, Table tbl, Table rel, HasTableEqualityNullable be (PrimaryKey tbl)) => DatabaseEntity be db (TableEntity rel) -> (rel (QExpr be s) -> PrimaryKey tbl (Nullable (QExpr be s))) -> tbl (QExpr be s) -> Q be db s (rel (Nullable (QExpr be s)))

-- | Synonym of <a>OneToMany</a>. Useful for giving more meaningful types,
--   when the relationship is meant to be one-to-one.
type OneToOne be db s one many = OneToMany be db s one many

-- | Synonym of <a>OneToManyOptional</a>. Useful for giving more meaningful
--   types, when the relationship is meant to be one-to-one.
type OneToMaybe be db s tbl rel = OneToManyOptional be db s tbl rel

-- | Used to define one-to-many (or one-to-one) relationships. Takes the
--   table to fetch, a way to extract the foreign key from that table, and
--   the table to relate to.
oneToOne_ :: (Database be db, BeamSqlBackend be, HasTableEquality be (PrimaryKey tbl), Table tbl, Table rel) => DatabaseEntity be db (TableEntity rel) -> (rel (QExpr be s) -> PrimaryKey tbl (QExpr be s)) -> tbl (QExpr be s) -> Q be db s (rel (QExpr be s))

-- | Used to define one-to-many (or one-to-one) relationships with a
--   nullable foreign key. Takes the table to fetch, a way to extract the
--   foreign key from that table, and the table to relate to.
oneToMaybe_ :: (BeamSqlBackend be, Database be db, Table tbl, Table rel, HasTableEqualityNullable be (PrimaryKey tbl)) => DatabaseEntity be db (TableEntity rel) -> (rel (QExpr be s) -> PrimaryKey tbl (Nullable (QExpr be s))) -> tbl (QExpr be s) -> Q be db s (rel (Nullable (QExpr be s)))

-- | Query results that have been introduced into a common table expression
--   via <a>selecting</a> that can be used in future queries with
--   <a>reuse</a>.
data ReusableQ be db res

-- | Monad in which <tt>SELECT</tt> statements can be made (via
--   <a>selecting</a>) and bound to result names for re-use later. This has
--   the advantage of only computing each result once. In SQL, this is
--   translated to a common table expression.
--   
--   Once introduced, results can be re-used in future queries with
--   <a>reuse</a>.
--   
--   <a>With</a> is also a member of <a>MonadFix</a> for backends that
--   support recursive CTEs. In this case, you can use <tt>mdo</tt> or
--   <tt>rec</tt> notation (with <tt>RecursiveDo</tt> enabled) to bind
--   result values (again, using <a>reuse</a>) even <i>before</i> they're
--   introduced.
--   
--   See further documentation <a>here</a>.
data With be (db :: (Type -> Type) -> Type) a

-- | Introduce the result of a query as a result in a common table
--   expression. The returned value can be used in future queries by
--   applying <a>reuse</a>.
selecting :: forall res be db. (BeamSql99CommonTableExpressionBackend be, HasQBuilder be, Projectible be res, ThreadRewritable QAnyScope res) => Q be db QAnyScope res -> With be db (ReusableQ be db res)

-- | Introduces the result of a previous <a>selecting</a> (a CTE) into a
--   new query
reuse :: forall s be db res. ReusableQ be db res -> Q be db s (WithRewrittenThread QAnyScope s res)

-- | A field that can be extracted from SQL expressions of type
--   <tt>tgt</tt> that results in a type <tt>a</tt>, in backend
--   <tt>be</tt>.
newtype ExtractField be tgt a
ExtractField :: Sql92ExtractFieldSyntax (BeamSqlBackendSyntax be) -> ExtractField be tgt a

-- | Extracts the given field from the target expression
extract_ :: BeamSqlBackend be => ExtractField be tgt a -> QGenExpr ctxt be s tgt -> QGenExpr cxt be s a

-- | Extracts the hours, minutes, or seconds from any timestamp or time
--   field
hour_ :: (BeamSqlBackend be, HasSqlTime tgt) => ExtractField be tgt Double

-- | Extracts the hours, minutes, or seconds from any timestamp or time
--   field
minutes_ :: (BeamSqlBackend be, HasSqlTime tgt) => ExtractField be tgt Double

-- | Extracts the hours, minutes, or seconds from any timestamp or time
--   field
seconds_ :: (BeamSqlBackend be, HasSqlTime tgt) => ExtractField be tgt Double
year_ :: (BeamSqlBackend be, HasSqlDate tgt) => ExtractField be tgt Double
month_ :: (BeamSqlBackend be, HasSqlDate tgt) => ExtractField be tgt Double
day_ :: (BeamSqlBackend be, HasSqlDate tgt) => ExtractField be tgt Double

-- | Type-class for types that contain a time component
class HasSqlTime tgt

-- | Type-class for types that contain a date component
class HasSqlDate tgt

-- | Phantom type representing a SQL <i>Tri-state</i> boolean -- true,
--   false, and unknown
--   
--   This type has no values because it cannot be sent to or retrieved from
--   the database directly. Use <tt>isTrue_</tt>, <tt>isFalse_</tt>,
--   <tt>isNotTrue_</tt>, <tt>isNotFalse_</tt>, <tt>isUnknown_</tt>,
--   <tt>isNotUnknown_</tt>, and <tt>unknownAs_</tt> to retrieve the
--   corresponding <a>Bool</a> value.
data SqlBool

-- | SQL <tt>AND</tt> operator
(&&.) :: BeamSqlBackend be => QGenExpr context be s Bool -> QGenExpr context be s Bool -> QGenExpr context be s Bool
infixr 3 &&.

-- | SQL <tt>OR</tt> operator
(||.) :: BeamSqlBackend be => QGenExpr context be s Bool -> QGenExpr context be s Bool -> QGenExpr context be s Bool
infixr 2 ||.

-- | SQL <tt>NOT</tt> operator
not_ :: forall be context s. BeamSqlBackend be => QGenExpr context be s Bool -> QGenExpr context be s Bool

-- | SQL <tt>/</tt> operator
div_ :: (Integral a, BeamSqlBackend be) => QGenExpr context be s a -> QGenExpr context be s a -> QGenExpr context be s a
infixl 7 `div_`

-- | SQL <tt>%</tt> operator
mod_ :: (Integral a, BeamSqlBackend be) => QGenExpr context be s a -> QGenExpr context be s a -> QGenExpr context be s a
infixl 7 `mod_`

-- | SQL <tt>AND</tt> operator for <a>SqlBool</a>
(&&?.) :: BeamSqlBackend be => QGenExpr context be s SqlBool -> QGenExpr context be s SqlBool -> QGenExpr context be s SqlBool
infixr 3 &&?.

-- | SQL <tt>OR</tt> operator
(||?.) :: BeamSqlBackend be => QGenExpr context be s SqlBool -> QGenExpr context be s SqlBool -> QGenExpr context be s SqlBool
infixr 2 ||?.

-- | SQL <tt>NOT</tt> operator, but operating on <a>SqlBool</a> instead
sqlNot_ :: forall be context s. BeamSqlBackend be => QGenExpr context be s SqlBool -> QGenExpr context be s SqlBool

-- | SQL <tt>LIKE</tt> operator
like_ :: (BeamSqlBackendIsString be text, BeamSqlBackend be) => QGenExpr ctxt be s text -> QGenExpr ctxt be s text -> QGenExpr ctxt be s Bool
infix 4 `like_`

-- | SQL99 <tt>SIMILAR TO</tt> operator
similarTo_ :: (BeamSqlBackendIsString be text, BeamSql99ExpressionBackend be) => QGenExpr ctxt be s text -> QGenExpr ctxt be s text -> QGenExpr ctxt be s text
infix 4 `similarTo_`

-- | SQL <tt>LIKE</tt> operator but heterogeneous over the text type
like_' :: (BeamSqlBackendIsString be left, BeamSqlBackendIsString be right, BeamSqlBackend be) => QGenExpr ctxt be s left -> QGenExpr ctxt be s right -> QGenExpr ctxt be s Bool

-- | SQL99 <tt>SIMILAR TO</tt> operator but heterogeneous over the text
--   type
similarTo_' :: (BeamSqlBackendIsString be left, BeamSqlBackendIsString be right, BeamSql99ExpressionBackend be) => QGenExpr ctxt be s left -> QGenExpr ctxt be s right -> QGenExpr ctxt be s left

-- | SQL <tt>CONCAT</tt> function
concat_ :: BeamSql99ConcatExpressionBackend be => [QGenExpr context be s Text] -> QGenExpr context be s Text

-- | SQL <tt>IS TRUE</tt> operator
isTrue_ :: BeamSqlBackend be => QGenExpr context be s SqlBool -> QGenExpr context be s Bool

-- | SQL <tt>IS NOT TRUE</tt> operator
isNotTrue_ :: BeamSqlBackend be => QGenExpr context be s SqlBool -> QGenExpr context be s Bool

-- | SQL <tt>IS FALSE</tt> operator
isFalse_ :: BeamSqlBackend be => QGenExpr context be s SqlBool -> QGenExpr context be s Bool

-- | SQL <tt>IS NOT FALSE</tt> operator
isNotFalse_ :: BeamSqlBackend be => QGenExpr context be s SqlBool -> QGenExpr context be s Bool

-- | SQL <tt>IS UNKNOWN</tt> operator
isUnknown_ :: BeamSqlBackend be => QGenExpr context be s SqlBool -> QGenExpr context be s Bool

-- | SQL <tt>IS NOT UNKNOWN</tt> operator
isNotUnknown_ :: BeamSqlBackend be => QGenExpr context be s SqlBool -> QGenExpr context be s Bool

-- | Return the first argument if the expression has the unknown SQL value
--   See <a>sqlBool_</a> for the inverse
unknownAs_ :: BeamSqlBackend be => Bool -> QGenExpr context be s SqlBool -> QGenExpr context be s Bool

-- | Convert a <i>known not null</i> bool to a <a>SqlBool</a>. See
--   <a>unknownAs_</a> for the inverse
sqlBool_ :: QGenExpr context syntax s Bool -> QGenExpr context syntax s SqlBool

-- | Retrieve a <a>SqlBool</a> value as a potentially <tt>NULL</tt>
--   <a>Bool</a>. This is useful if you want to get the value of a SQL
--   boolean expression directly, without having to specify what to do on
--   <tt>UNKNOWN</tt>. Note that both <tt>NULL</tt> and <tt>UNKNOWN</tt>
--   will be returned as <a>Nothing</a>.
possiblyNullBool_ :: QGenExpr context be s SqlBool -> QGenExpr context be s (Maybe Bool)

-- | Convert a possibly <tt>NULL</tt> <a>Bool</a> to a <a>SqlBool</a>.
fromPossiblyNullBool_ :: QGenExpr context be s (Maybe Bool) -> QGenExpr context be s SqlBool

-- | Class for Haskell types that can be compared for equality in the given
--   backend
class BeamSqlBackend be => HasSqlEqualityCheck be a
sqlEqE :: HasSqlEqualityCheck be a => Proxy a -> Proxy be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be
sqlNeqE :: HasSqlEqualityCheck be a => Proxy a -> Proxy be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be

-- | Tri-state equality
sqlEqTriE :: HasSqlEqualityCheck be a => Proxy a -> Proxy be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be

-- | Tri-state equality
sqlNeqTriE :: HasSqlEqualityCheck be a => Proxy a -> Proxy be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be

-- | Class for Haskell types that can be compared for quantified equality
--   in the given backend
class HasSqlEqualityCheck be a => HasSqlQuantifiedEqualityCheck be a
sqlQEqE :: HasSqlQuantifiedEqualityCheck be a => Proxy a -> Proxy be -> Maybe (BeamSqlBackendExpressionQuantifierSyntax be) -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be
sqlQNeqE :: HasSqlQuantifiedEqualityCheck be a => Proxy a -> Proxy be -> Maybe (BeamSqlBackendExpressionQuantifierSyntax be) -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be -> BeamSqlBackendExpressionSyntax be

-- | Constraint synonym to check if two tables can be compared for equality
type HasTableEquality be tbl = (FieldsFulfillConstraint (HasSqlEqualityCheck be) tbl, Beamable tbl)

-- | Class for expression types or expression containers for which there is
--   a notion of equality.
--   
--   Instances are provided to check the equality of expressions of the
--   same type as well as entire <a>Beamable</a> types parameterized over
--   <a>QGenExpr</a>
class SqlEq expr a | a -> expr

-- | Given two expressions, returns whether they are equal, using Haskell
--   semantics (NULLs handled properly)
(==.) :: SqlEq expr a => a -> a -> expr Bool

-- | Given two expressions, returns whether they are not equal, using
--   Haskell semantics (NULLs handled properly)
(/=.) :: SqlEq expr a => a -> a -> expr Bool

-- | Given two expressions, returns the <i>SQL tri-state boolean</i> when
--   compared for equality
(==?.) :: SqlEq expr a => a -> a -> expr SqlBool

-- | Given two expressions, returns the <i>SQL tri-state boolean</i> when
--   compared for inequality
(/=?.) :: SqlEq expr a => a -> a -> expr SqlBool
infix 4 ==.
infix 4 /=.
infix 4 ==?.
infix 4 /=?.

-- | Class for expression types or expression containers for which there is
--   a notion of ordering.
--   
--   Instances are provided to check the ordering of expressions of the
--   same type. Since there is no universal notion of ordering for an
--   arbitrary number of expressions, no instance is provided for
--   <a>Beamable</a> types.
class SqlOrd expr e | e -> expr
(<.) :: SqlOrd expr e => e -> e -> expr Bool
(>.) :: SqlOrd expr e => e -> e -> expr Bool
(<=.) :: SqlOrd expr e => e -> e -> expr Bool
(>=.) :: SqlOrd expr e => e -> e -> expr Bool
infix 4 <.
infix 4 >.
infix 4 <=.
infix 4 >=.
class SqlIn expr a | a -> expr

-- | SQL <tt>IN</tt> predicate
in_ :: SqlIn expr a => a -> [a] -> expr Bool
infix 4 `in_`

-- | Class for backends which support SQL <tt>IN</tt> on lists of row
--   values, which is not part of ANSI SQL. This is useful for <tt>IN</tt>
--   on primary keys.
class BeamSqlBackend be => HasSqlInTable be
inRowValuesE :: HasSqlInTable be => Proxy be -> BeamSqlBackendExpressionSyntax be -> [BeamSqlBackendExpressionSyntax be] -> BeamSqlBackendExpressionSyntax be
inQuery_ :: (HasQBuilder be, BeamSqlBackend be) => QGenExpr ctx be s a -> Q be db s (QExpr be s a) -> QGenExpr ctx be s Bool
infix 4 `inQuery_`

-- | Class for expression types for which there is a notion of
--   <i>quantified</i> equality.
class SqlEq expr a => SqlEqQuantified expr quantified a | a -> expr quantified

-- | Quantified equality and inequality using <i>SQL semantics</i>
--   (tri-state boolean)
(==*.) :: SqlEqQuantified expr quantified a => a -> quantified -> expr SqlBool

-- | Quantified equality and inequality using <i>SQL semantics</i>
--   (tri-state boolean)
(/=*.) :: SqlEqQuantified expr quantified a => a -> quantified -> expr SqlBool
infix 4 ==*.
infix 4 /=*.

-- | Class for things which can be <i>quantifiably</i> compared.
class SqlOrd expr e => SqlOrdQuantified expr quantified e | e -> expr quantified
(<*.) :: SqlOrdQuantified expr quantified e => e -> quantified -> expr Bool
(>*.) :: SqlOrdQuantified expr quantified e => e -> quantified -> expr Bool
(<=*.) :: SqlOrdQuantified expr quantified e => e -> quantified -> expr Bool
(>=*.) :: SqlOrdQuantified expr quantified e => e -> quantified -> expr Bool
infix 4 <*.
infix 4 >*.
infix 4 <=*.
infix 4 >=*.

-- | A data structure representing the set to quantify a comparison
--   operator over.
data QQuantified be s r

-- | A <a>QQuantified</a> representing a SQL <tt>ANY(..)</tt> for use with
--   a <a>quantified comparison operator</a>
--   
--   Accepts a subquery. Use <a>anyIn_</a> for an explicit list
anyOf_ :: forall s a be db. (BeamSqlBackend be, HasQBuilder be) => Q be db (QNested s) (QExpr be (QNested s) a) -> QQuantified be s a

-- | A <a>QQuantified</a> representing a SQL <tt>ALL(..)</tt> for use with
--   a <a>quantified comparison operator</a>
--   
--   Accepts a subquery. Use <a>allIn_</a> for an explicit list
allOf_ :: forall s a be db. (BeamSqlBackend be, HasQBuilder be) => Q be db (QNested s) (QExpr be (QNested s) a) -> QQuantified be s a

-- | A <a>QQuantified</a> representing a SQL <tt>ANY(..)</tt> for use with
--   a <a>quantified comparison operator</a>
--   
--   Accepts an explicit list of typed expressions. Use <a>anyOf_</a> for a
--   subquery
anyIn_ :: forall s a be. BeamSqlBackend be => [QExpr be s a] -> QQuantified be s a

-- | A <a>QQuantified</a> representing a SQL <tt>ALL(..)</tt> for use with
--   a <a>quantified comparison operator</a>
--   
--   Accepts an explicit list of typed expressions. Use <a>allOf_</a> for a
--   subquery
allIn_ :: forall s a be. BeamSqlBackend be => [QExpr be s a] -> QQuantified be s a

-- | SQL <tt>BETWEEN</tt> clause
between_ :: BeamSqlBackend be => QGenExpr context be s a -> QGenExpr context be s a -> QGenExpr context be s a -> QGenExpr context be s Bool
infix 4 `between_`

-- | Compute an aggregate over a query.
--   
--   The supplied aggregate projection should return an aggregate
--   expression (an expression containing an aggregate function such as
--   <a>count_</a>, <a>sum_</a>, <a>countAll_</a>, etc), a grouping key
--   (specified with the <a>group_</a> function), or a combination of
--   tuples of the above.
--   
--   Appropriate instances are provided up to 8-tuples.
--   
--   Semantically, all grouping expressions in the projection will be added
--   to a SQL <tt>GROUP BY</tt> clause and all aggregate expressions will
--   be computed.
--   
--   The return value will be the type of the aggregate projection, but
--   transformed to be in the normal value context (i.e., everything will
--   become <a>QExpr</a>s).
--   
--   For usage examples, see <a>the manual</a>.
aggregate_ :: forall be a r db s. (BeamSqlBackend be, Aggregable be a, Projectible be r, Projectible be a, ContextRewritable a, ThreadRewritable (QNested s) (WithRewrittenContext a QValueContext)) => (r -> a) -> Q be db (QNested s) r -> Q be db s (WithRewrittenThread (QNested s) s (WithRewrittenContext a QValueContext))

-- | Support for FILTER (WHERE ...) syntax for aggregates. Part of SQL2003
--   Elementary OLAP operations feature (T611).
--   
--   See <a>filterWhere_'</a> for a version that accepts <a>SqlBool</a>.
filterWhere_ :: BeamSqlT611Backend be => QAgg be s a -> QExpr be s Bool -> QAgg be s a

-- | Like <a>filterWhere_</a> but accepting <a>SqlBool</a>.
filterWhere_' :: BeamSqlT611Backend be => QAgg be s a -> QExpr be s SqlBool -> QAgg be s a

-- | Type class for grouping keys. <tt>expr</tt> is the type of the
--   grouping key after projection. <tt>grouped</tt> is the type of the
--   grouping key in the aggregate expression (usually something that
--   contains <a>QGenExpr</a>s in the <a>QGroupingContext</a>).
class QGroupable expr grouped | expr -> grouped, grouped -> expr
group_ :: QGroupable expr grouped => expr -> grouped

-- | SQL <tt>SUM(ALL ..)</tt> function (but without the explicit ALL)
sum_ :: (BeamSqlBackend be, Num a) => QExpr be s a -> QAgg be s (Maybe a)

-- | SQL <tt>AVG(ALL ..)</tt> function (but without the explicit ALL)
avg_ :: (BeamSqlBackend be, Num a) => QExpr be s a -> QAgg be s (Maybe a)

-- | SQL <tt>MIN(ALL ..)</tt> function (but without the explicit ALL)
min_ :: BeamSqlBackend be => QExpr be s a -> QAgg be s (Maybe a)

-- | SQL <tt>MAX(ALL ..)</tt> function (but without the explicit ALL)
max_ :: BeamSqlBackend be => QExpr be s a -> QAgg be s (Maybe a)

-- | SQL <tt>COUNT(ALL ..)</tt> function (but without the explicit ALL)
count_ :: (BeamSqlBackend be, Integral b) => QExpr be s a -> QAgg be s b

-- | SQL <tt>COUNT(*)</tt> function
countAll_ :: (BeamSqlBackend be, Integral a) => QAgg be s a

-- | SQL2003 <tt>RANK</tt> function (Requires T611 Elementary OLAP
--   operations support)
rank_ :: (BeamSqlT611Backend be, Integral a) => QAgg be s a

-- | SQL2003 <tt>CUME_DIST</tt> function (Requires T612 Advanced OLAP
--   operations support)
cumeDist_ :: BeamSqlT612Backend be => QAgg be s Double

-- | SQL2003 <tt>PERCENT_RANK</tt> function (Requires T612 Advanced OLAP
--   operations support)
percentRank_ :: BeamSqlT612Backend be => QAgg be s Double

-- | SQL2003 <tt>DENSE_RANK</tt> function (Requires T612 Advanced OLAP
--   operations support)
denseRank_ :: (BeamSqlT612Backend be, Integral a) => QAgg be s a

-- | SQL2003 <tt>ROW_NUMBER</tt> function
rowNumber_ :: (BeamSql2003ExpressionBackend be, Integral a) => QAgg be s a

-- | SQL99 <tt>EVERY(ALL ..)</tt> function (but without the explicit ALL)
every_ :: BeamSql99AggregationBackend be => QExpr be s SqlBool -> QAgg be s SqlBool

-- | SQL99 <tt>ANY(ALL ..)</tt> function (but without the explicit ALL)
any_ :: BeamSql99AggregationBackend be => QExpr be s SqlBool -> QAgg be s SqlBool

-- | SQL99 <tt>SOME(ALL ..)</tt> function (but without the explicit ALL)
some_ :: BeamSql99AggregationBackend be => QExpr be s SqlBool -> QAgg be s SqlBool
sumOver_ :: (BeamSqlBackend be, Num a) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QAgg be s (Maybe a)
avgOver_ :: (BeamSqlBackend be, Num a) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QAgg be s (Maybe a)
minOver_ :: BeamSqlBackend be => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QAgg be s (Maybe a)
maxOver_ :: BeamSqlBackend be => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QAgg be s (Maybe a)
countOver_ :: (BeamSqlBackend be, Integral b) => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s a -> QAgg be s b

-- | SQL <tt>EVERY</tt>, <tt>SOME</tt>, and <tt>ANY</tt> aggregates.
--   Operates over <a>SqlBool</a> only, as the result can be <tt>NULL</tt>,
--   even if all inputs are known (no input rows).
everyOver_ :: BeamSql99AggregationBackend be => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s SqlBool -> QAgg be s SqlBool

-- | SQL <tt>EVERY</tt>, <tt>SOME</tt>, and <tt>ANY</tt> aggregates.
--   Operates over <a>SqlBool</a> only, as the result can be <tt>NULL</tt>,
--   even if all inputs are known (no input rows).
anyOver_ :: BeamSql99AggregationBackend be => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s SqlBool -> QAgg be s SqlBool

-- | SQL <tt>EVERY</tt>, <tt>SOME</tt>, and <tt>ANY</tt> aggregates.
--   Operates over <a>SqlBool</a> only, as the result can be <tt>NULL</tt>,
--   even if all inputs are known (no input rows).
someOver_ :: BeamSql99AggregationBackend be => Maybe (BeamSqlBackendAggregationQuantifierSyntax be) -> QExpr be s SqlBool -> QAgg be s SqlBool

-- | Compute an aggregate only over distinct values in a group. Corresponds
--   to the <tt>AGG(DISTINCT ..)</tt> syntax.
distinctInGroup_ :: IsSql92AggregationSetQuantifierSyntax s => Maybe s

-- | Compute an aggregate over all values in a group. Corresponds
--   semantically to the <tt>AGG(ALL ..)</tt> syntax, but doesn't produce
--   an explicit <tt>ALL</tt>. To produce <tt>ALL</tt> expicitly, see
--   <a>allInGroupExplicitly_</a>.
allInGroup_ :: IsSql92AggregationSetQuantifierSyntax s => Maybe s

-- | Compute an aggregate over all values in a group. Corresponds to the
--   <tt>AGG(ALL ..)</tt> syntax. Note that <tt>ALL</tt> is the default for
--   most aggregations, so you don't normally explicitly specify
--   <tt>ALL</tt>. However, if you need to, you can use this function. To
--   be explicit about quantification in the beam query DSL, but not
--   produce an explicit <tt>ALL</tt>, use <a>allInGroup_</a>.
--   <a>allInGroup_</a> has the same semantic meaning, but does not produce
--   an explicit <tt>ALL</tt>.
allInGroupExplicitly_ :: IsSql92AggregationSetQuantifierSyntax s => Maybe s

-- | Represents a select statement in the given backend, returning rows of
--   type <tt>a</tt>.
newtype SqlSelect be a
SqlSelect :: BeamSqlBackendSelectSyntax be -> SqlSelect be a

-- | Build a <a>SqlSelect</a> for the given <a>Q</a>.
select :: forall be db res. (BeamSqlBackend be, HasQBuilder be, Projectible be res) => Q be db QBaseScope res -> SqlSelect be (QExprToIdentity res)

-- | Create a <a>SqlSelect</a> for a query which may have common table
--   expressions. See the documentation of <a>With</a> for more details.
selectWith :: forall be db res. (BeamSqlBackend be, BeamSql99CommonTableExpressionBackend be, HasQBuilder be, Projectible be res) => With be db (Q be db QBaseScope res) -> SqlSelect be (QExprToIdentity res)

-- | Convenience function to generate a <a>SqlSelect</a> that looks up a
--   table row given a primary key.
lookup_ :: (Database be db, Table table, BeamSqlBackend be, HasQBuilder be, SqlValableTable be (PrimaryKey table), HasTableEquality be (PrimaryKey table)) => DatabaseEntity be db (TableEntity table) -> PrimaryKey table Identity -> SqlSelect be (table Identity)

-- | Run a <a>SqlSelect</a> in a <a>MonadBeam</a> and get the results as a
--   list
runSelectReturningList :: (MonadBeam be m, BeamSqlBackend be, FromBackendRow be a) => SqlSelect be a -> m [a]

-- | Run a <a>SqlSelect</a> in a <a>MonadBeam</a> and get the unique
--   result, if there is one. Both no results as well as more than one
--   result cause this to return <a>Nothing</a>.
runSelectReturningOne :: (MonadBeam be m, BeamSqlBackend be, FromBackendRow be a) => SqlSelect be a -> m (Maybe a)

-- | Run a <a>SqlSelect</a> in a <a>MonadBeam</a> and get the first result,
--   if there is one. This is not guaranteed to automatically limit the
--   query to one result.
runSelectReturningFirst :: (MonadBeam be m, BeamSqlBackend be, FromBackendRow be a) => SqlSelect be a -> m (Maybe a)

-- | Use a special debug syntax to print out an ANSI Standard
--   <tt>SELECT</tt> statement that may be generated for a given <a>Q</a>.
dumpSqlSelect :: Projectible (MockSqlBackend SqlSyntaxBuilder) res => Q (MockSqlBackend SqlSyntaxBuilder) db QBaseScope res -> IO ()

-- | Represents a SQL <tt>INSERT</tt> command that has not yet been run
data SqlInsert be (table :: (Type -> Type) -> Type)
SqlInsert :: !TableSettings table -> !BeamSqlBackendInsertSyntax be -> SqlInsert be (table :: (Type -> Type) -> Type)
SqlInsertNoRows :: SqlInsert be (table :: (Type -> Type) -> Type)

-- | Generate a <a>SqlInsert</a> given a table and a source of values.
insert :: (BeamSqlBackend be, ProjectibleWithPredicate AnyType () Text (table (QField s))) => DatabaseEntity be db (TableEntity table) -> SqlInsertValues be (table (QExpr be s)) -> SqlInsert be table

-- | Generate a <a>SqlInsert</a> over only certain fields of a table
insertOnly :: (BeamSqlBackend be, ProjectibleWithPredicate AnyType () Text (QExprToField r)) => DatabaseEntity be db (TableEntity table) -> (table (QField s) -> QExprToField r) -> SqlInsertValues be r -> SqlInsert be table

-- | Run a <a>SqlInsert</a> in a <a>MonadBeam</a>
runInsert :: (BeamSqlBackend be, MonadBeam be m) => SqlInsert be table -> m ()

-- | Represents a source of values that can be inserted into a table shaped
--   like <tt>tbl</tt>.
data SqlInsertValues be proj
SqlInsertValues :: BeamSqlBackendInsertValuesSyntax be -> SqlInsertValues be proj
SqlInsertValuesEmpty :: SqlInsertValues be proj

-- | Build a <a>SqlInsertValues</a> from series of expressions in tables
insertExpressions :: forall be table s. (BeamSqlBackend be, Beamable table) => (forall s'. [table (QExpr be s')]) -> SqlInsertValues be (table (QExpr be s))

-- | Build a <a>SqlInsertValues</a> from concrete table values
insertValues :: forall be table s. (BeamSqlBackend be, Beamable table, FieldsFulfillConstraint (BeamSqlBackendCanSerialize be) table) => [table Identity] -> SqlInsertValues be (table (QExpr be s))

-- | Build a <a>SqlInsertValues</a> from a <a>SqlSelect</a> that returns
--   the same table
insertFrom :: (BeamSqlBackend be, HasQBuilder be, Projectible be r) => Q be db QBaseScope r -> SqlInsertValues be r

-- | Build a <a>SqlInsertValues</a> from arbitrarily shaped data containing
--   expressions
insertData :: forall be r. (Projectible be r, BeamSqlBackend be) => [r] -> SqlInsertValues be r

-- | Represents a SQL <tt>UPDATE</tt> statement for the given
--   <tt>table</tt>.
data SqlUpdate be (table :: (Type -> Type) -> Type)
SqlUpdate :: !TableSettings table -> !BeamSqlBackendUpdateSyntax be -> SqlUpdate be (table :: (Type -> Type) -> Type)
SqlIdentityUpdate :: SqlUpdate be (table :: (Type -> Type) -> Type)

-- | Build a <a>SqlUpdate</a> given a table, a list of assignments, and a
--   way to build a <tt>WHERE</tt> clause.
--   
--   Use <a>update'</a> for comparisons with <a>SqlBool</a>.
--   
--   See the <a>(&lt;-.)</a> operator for ways to build assignments. The
--   argument to the second argument is a the table parameterized over
--   <a>QField</a>, which represents the left hand side of assignments.
--   Sometimes, you'd like to also get the current value of a particular
--   column. You can use the <a>current_</a> function to convert a
--   <a>QField</a> to a <a>QExpr</a>.
update :: (BeamSqlBackend be, Beamable table) => DatabaseEntity be db (TableEntity table) -> (forall s. table (QField s) -> QAssignment be s) -> (forall s. table (QExpr be s) -> QExpr be s Bool) -> SqlUpdate be table

-- | Generate a <a>SqlUpdate</a> that will update the given table row with
--   the given value.
--   
--   The SQL <tt>UPDATE</tt> that is generated will set every non-primary
--   key field for the row where each primary key field is exactly what is
--   given.
--   
--   Note: This is a pure SQL <tt>UPDATE</tt> command. This does not upsert
--   or merge values.
--   
--   Use <a>save'</a> for an internal <a>SqlBool</a> comparison.
save :: forall table be db. (Table table, BeamSqlBackend be, SqlValableTable be (PrimaryKey table), SqlValableTable be table, HasTableEquality be (PrimaryKey table)) => DatabaseEntity be db (TableEntity table) -> table Identity -> SqlUpdate be table

-- | Build a <a>SqlUpdate</a> given a table, a list of assignments, and a
--   way to build a <tt>WHERE</tt> clause.
--   
--   Uses a <a>SqlBool</a> comparison. Use <a>update</a> for comparisons
--   with <a>Bool</a>.
--   
--   See the <a>(&lt;-.)</a> operator for ways to build assignments. The
--   argument to the second argument is a the table parameterized over
--   <a>QField</a>, which represents the left hand side of assignments.
--   Sometimes, you'd like to also get the current value of a particular
--   column. You can use the <a>current_</a> function to convert a
--   <a>QField</a> to a <a>QExpr</a>.
update' :: (BeamSqlBackend be, Beamable table) => DatabaseEntity be db (TableEntity table) -> (forall s. table (QField s) -> QAssignment be s) -> (forall s. table (QExpr be s) -> QExpr be s SqlBool) -> SqlUpdate be table

-- | Generate a <a>SqlUpdate</a> that will update the given table row with
--   the given value. This is a variant using <a>update'</a> and a
--   <a>SqlBool</a> comparison.
--   
--   The SQL <tt>UPDATE</tt> that is generated will set every non-primary
--   key field for the row where each primary key field is exactly what is
--   given.
--   
--   Note: This is a pure SQL <tt>UPDATE</tt> command. This does not upsert
--   or merge values.
--   
--   Use <a>save</a> for an internal <a>Bool</a> comparison.
save' :: forall table be db. (Table table, BeamSqlBackend be, SqlValableTable be (PrimaryKey table), SqlValableTable be table, HasTableEquality be (PrimaryKey table)) => DatabaseEntity be db (TableEntity table) -> table Identity -> SqlUpdate be table

-- | A specialization of <a>update</a> that is more convenient for normal
--   tables.
--   
--   Use <a>updateTable'</a> for comparisons with <a>SqlBool</a>.
updateTable :: forall table db be. (BeamSqlBackend be, Beamable table) => DatabaseEntity be db (TableEntity table) -> table (QFieldAssignment be table) -> (forall s. table (QExpr be s) -> QExpr be s Bool) -> SqlUpdate be table

-- | A specialization of <a>update'</a> that is more convenient for normal
--   tables.
--   
--   Use <a>updateTable</a> for comparisons with <a>Bool</a>.
updateTable' :: forall table db be. (BeamSqlBackend be, Beamable table) => DatabaseEntity be db (TableEntity table) -> table (QFieldAssignment be table) -> (forall s. table (QExpr be s) -> QExpr be s SqlBool) -> SqlUpdate be table
set :: forall table be table'. Beamable table => table (QFieldAssignment be table')
setFieldsTo :: forall table be table'. Table table => (forall s. table (QExpr be s)) -> table (QFieldAssignment be table')

-- | Use with <a>set</a> to set a field to an explicit new value that does
--   not depend on any other value
toNewValue :: (forall s. QExpr be s a) -> QFieldAssignment be table a

-- | Use with <a>set</a> to not modify the field
toOldValue :: QFieldAssignment be table a

-- | Use with <a>set</a> to set a field to a new value that is calculated
--   based on one or more fields from the existing row
toUpdatedValue :: (forall s. table (QExpr be s) -> QExpr be s a) -> QFieldAssignment be table a

-- | Use with <a>set</a> to optionally set a fiield to a new value,
--   calculated based on one or more fields from the existing row
toUpdatedValueMaybe :: (forall s. table (QExpr be s) -> Maybe (QExpr be s a)) -> QFieldAssignment be table a

-- | A specialization of <a>update</a> that matches the given (already
--   existing) row.
--   
--   Use <a>updateRow'</a> for an internal <a>SqlBool</a> comparison.
updateRow :: (BeamSqlBackend be, Table table, HasTableEquality be (PrimaryKey table), SqlValableTable be (PrimaryKey table)) => DatabaseEntity be db (TableEntity table) -> table Identity -> (forall s. table (QField s) -> QAssignment be s) -> SqlUpdate be table

-- | Convenience form of <a>updateTable</a> that generates a <tt>WHERE</tt>
--   clause that matches only the already existing entity.
--   
--   Use <a>updateTableRow'</a> for an internal <a>SqlBool</a> comparison.
updateTableRow :: (BeamSqlBackend be, Table table, HasTableEquality be (PrimaryKey table), SqlValableTable be (PrimaryKey table)) => DatabaseEntity be db (TableEntity table) -> table Identity -> table (QFieldAssignment be table) -> SqlUpdate be table

-- | A specialization of <a>update'</a> that matches the given (already
--   existing) row.
--   
--   Use <a>updateRow</a> for an internal <a>Bool</a> comparison.
updateRow' :: (BeamSqlBackend be, Table table, HasTableEquality be (PrimaryKey table), SqlValableTable be (PrimaryKey table)) => DatabaseEntity be db (TableEntity table) -> table Identity -> (forall s. table (QField s) -> QAssignment be s) -> SqlUpdate be table

-- | Convenience form of <a>updateTable'</a> that generates a
--   <tt>WHERE</tt> clause that matches only the already existing entity.
--   
--   Uses <a>update'</a> with a <a>SqlBool</a> comparison. Use
--   <a>updateTableRow</a> for an internal <a>Bool</a> comparison.
updateTableRow' :: (BeamSqlBackend be, Table table, HasTableEquality be (PrimaryKey table), SqlValableTable be (PrimaryKey table)) => DatabaseEntity be db (TableEntity table) -> table Identity -> table (QFieldAssignment be table) -> SqlUpdate be table

-- | Run a <a>SqlUpdate</a> in a <a>MonadBeam</a>.
runUpdate :: (BeamSqlBackend be, MonadBeam be m) => SqlUpdate be tbl -> m ()

-- | Represents a SQL <tt>DELETE</tt> statement for the given
--   <tt>table</tt>
data SqlDelete be (table :: (Type -> Type) -> Type)
SqlDelete :: !TableSettings table -> !BeamSqlBackendDeleteSyntax be -> SqlDelete be (table :: (Type -> Type) -> Type)

-- | Build a <a>SqlDelete</a> from a table and a way to build a
--   <tt>WHERE</tt> clause
delete :: forall be db table. BeamSqlBackend be => DatabaseEntity be db (TableEntity table) -> (forall s. (forall s'. table (QExpr be s')) -> QExpr be s Bool) -> SqlDelete be table

-- | Run a <a>SqlDelete</a> in a <a>MonadBeam</a>
runDelete :: (BeamSqlBackend be, MonadBeam be m) => SqlDelete be table -> m ()


-- | Top-level Beam module. This module re-exports all the symbols
--   necessary for most common user operations.
--   
--   The most interesting modules are <a>Database.Beam.Schema</a> and
--   <a>Database.Beam.Query</a>.
--   
--   This is mainly reference documentation. Most users will want to
--   consult the <a>manual</a>.
module Database.Beam

-- | A class that ties together a monad with a particular backend
--   
--   Provided here is a low-level interface for executing commands. The
--   'run*' functions are wrapped by the appropriate functions in
--   <a>Query</a>.
--   
--   This interface is very high-level and isn't meant to expose the full
--   power of the underlying database. Namely, it only supports simple data
--   retrieval strategies. More complicated strategies (for example,
--   Postgres's <tt>COPY</tt>) are supported in individual backends. See
--   the documentation of those backends for more details.
class (BeamBackend be, Monad m) => MonadBeam be m | m -> be

-- | Run a query determined by the given syntax, providing an action that
--   will be called to consume the results from the database (if any). The
--   action will get a reader action that can be used to fetch the next
--   row. When this reader action returns <a>Nothing</a>, there are no rows
--   left to consume. When the reader action returns, the database result
--   is freed.
runReturningMany :: (MonadBeam be m, FromBackendRow be x) => BeamSqlBackendSyntax be -> (m (Maybe x) -> m a) -> m a

-- | Run the given command and don't consume any results. Useful for DML
--   statements like INSERT, UPDATE, and DELETE, or DDL statements.
runNoReturn :: MonadBeam be m => BeamSqlBackendSyntax be -> m ()

-- | Run the given command and fetch the unique result. The result is
--   <a>Nothing</a> if either no results are returned or more than one
--   result is returned.
runReturningOne :: (MonadBeam be m, FromBackendRow be x) => BeamSqlBackendSyntax be -> m (Maybe x)

-- | Run the given command and fetch the first result. The result is
--   <a>Nothing</a> if no results are returned. This is not guaranteed to
--   automatically limit the query to one result.
runReturningFirst :: (MonadBeam be m, FromBackendRow be x) => BeamSqlBackendSyntax be -> m (Maybe x)

-- | Run the given command, collect all the results, and return them as a
--   list. May be more convenient than <a>runReturningMany</a>, but reads
--   the entire result set into memory.
runReturningList :: (MonadBeam be m, FromBackendRow be x) => BeamSqlBackendSyntax be -> m [x]
class BeamBackend be => FromBackendRow be a

-- | Parses a beam row. This should not fail, except in the case of an
--   internal bug in beam deserialization code. If it does fail, this
--   should throw a <tt>BeamRowParseError</tt>.
fromBackendRow :: FromBackendRow be a => FromBackendRowM be a

-- | Parses a beam row. This should not fail, except in the case of an
--   internal bug in beam deserialization code. If it does fail, this
--   should throw a <tt>BeamRowParseError</tt>.
fromBackendRow :: (FromBackendRow be a, Typeable a, BackendFromField be a) => FromBackendRowM be a
valuesNeeded :: FromBackendRow be a => Proxy be -> Proxy a -> Int

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO (m :: Type -> Type)

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => IO a -> m a

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a>  <a>id</a>
--   <a>to</a> . <a>from</a>  <a>id</a>
--   </pre>
class Generic a

-- | Identity functor and monad. (a non-strict monad)
data Identity a


-- | Some functionality is useful enough to be provided across backends,
--   but is not standardized. For example, many RDBMS systems provide ways
--   of fetching auto-incrementing or defaulting fields on INSERT or
--   UPDATE.
--   
--   Beam provides type classes that some backends instantiate that provide
--   this support. This uses direct means on sufficiently advanced backends
--   and is emulated on others.
module Database.Beam.Backend.SQL.BeamExtensions

-- | <a>MonadBeam</a>s that support returning the newly created rows of an
--   <tt>INSERT</tt> statement. Useful for discovering the real value of a
--   defaulted value.
class MonadBeam be m => MonadBeamInsertReturning be m | m -> be
runInsertReturningList :: (MonadBeamInsertReturning be m, Beamable table, Projectible be (table (QExpr be ())), FromBackendRow be (table Identity)) => SqlInsert be table -> m [table Identity]

-- | <a>MonadBeam</a>s that support returning the updated rows of an
--   <tt>UPDATE</tt> statement. Useful for discovering the new values of
--   the updated rows.
class MonadBeam be m => MonadBeamUpdateReturning be m | m -> be
runUpdateReturningList :: (MonadBeamUpdateReturning be m, Beamable table, Projectible be (table (QExpr be ())), FromBackendRow be (table Identity)) => SqlUpdate be table -> m [table Identity]

-- | <a>MonadBeam</a>s that suppert returning rows that will be deleted by
--   the given <tt>DELETE</tt> statement. Useful for deallocating resources
--   based on the value of deleted rows.
class MonadBeam be m => MonadBeamDeleteReturning be m | m -> be
runDeleteReturningList :: (MonadBeamDeleteReturning be m, Beamable table, Projectible be (table (QExpr be ())), FromBackendRow be (table Identity)) => SqlDelete be table -> m [table Identity]
class BeamSqlBackend be => BeamHasInsertOnConflict be where {
    
    -- | Specifies the kind of constraint that must be violated for the action
    --   to occur
    data family SqlConflictTarget be (table :: (Type -> Type) -> Type) :: Type;
    
    -- | What to do when an <tt>INSERT</tt> statement inserts a row into the
    --   table <tt>tbl</tt> that violates a constraint.
    data family SqlConflictAction be (table :: (Type -> Type) -> Type) :: Type;
}
insertOnConflict :: (BeamHasInsertOnConflict be, Beamable table) => DatabaseEntity be db (TableEntity table) -> SqlInsertValues be (table (QExpr be s)) -> SqlConflictTarget be table -> SqlConflictAction be table -> SqlInsert be table
anyConflict :: BeamHasInsertOnConflict be => SqlConflictTarget be table
conflictingFields :: (BeamHasInsertOnConflict be, Projectible be proj) => (table (QExpr be QInternal) -> proj) -> SqlConflictTarget be table
conflictingFieldsWhere :: (BeamHasInsertOnConflict be, Projectible be proj) => (table (QExpr be QInternal) -> proj) -> (forall s. table (QExpr be s) -> QExpr be s Bool) -> SqlConflictTarget be table
onConflictDoNothing :: BeamHasInsertOnConflict be => SqlConflictAction be table
onConflictUpdateSet :: (BeamHasInsertOnConflict be, Beamable table) => (forall s. table (QField s) -> table (QExpr be s) -> QAssignment be s) -> SqlConflictAction be table
onConflictUpdateSetWhere :: (BeamHasInsertOnConflict be, Beamable table) => (forall s. table (QField s) -> table (QExpr be s) -> QAssignment be s) -> (forall s. table (QField s) -> table (QExpr be s) -> QExpr be s Bool) -> SqlConflictAction be table
newtype SqlSerial a
SqlSerial :: a -> SqlSerial a
[unSerial] :: SqlSerial a -> a
onConflictUpdateInstead :: forall be table proj. (BeamHasInsertOnConflict be, Beamable table, ProjectibleWithPredicate AnyType () (InaccessibleQAssignment be) proj) => (table (Const (InaccessibleQAssignment be)) -> proj) -> SqlConflictAction be table
onConflictUpdateAll :: forall be table. (BeamHasInsertOnConflict be, Beamable table) => SqlConflictAction be table
instance GHC.Base.Monoid (Database.Beam.Backend.SQL.BeamExtensions.InaccessibleQAssignment be)
instance GHC.Base.Semigroup (Database.Beam.Backend.SQL.BeamExtensions.InaccessibleQAssignment be)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be (Control.Monad.Trans.Except.ExceptT e m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be (Control.Monad.Trans.Cont.ContT r m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be (Control.Monad.Trans.Reader.ReaderT r m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be (Control.Monad.Trans.State.Lazy.StateT r m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be (Control.Monad.Trans.State.Strict.StateT r m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be m, GHC.Base.Monoid r) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be (Control.Monad.Trans.Writer.Lazy.WriterT r m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be m, GHC.Base.Monoid r) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be (Control.Monad.Trans.Writer.Strict.WriterT r m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be m, GHC.Base.Monoid w) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be m, GHC.Base.Monoid w) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamDeleteReturning be (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be (Control.Monad.Trans.Except.ExceptT e m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be (Control.Monad.Trans.Cont.ContT r m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be (Control.Monad.Trans.Reader.ReaderT r m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be (Control.Monad.Trans.State.Lazy.StateT r m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be (Control.Monad.Trans.State.Strict.StateT r m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be m, GHC.Base.Monoid r) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be (Control.Monad.Trans.Writer.Lazy.WriterT r m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be m, GHC.Base.Monoid r) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be (Control.Monad.Trans.Writer.Strict.WriterT r m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be m, GHC.Base.Monoid w) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be m, GHC.Base.Monoid w) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamUpdateReturning be (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be (Control.Monad.Trans.Except.ExceptT e m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be (Control.Monad.Trans.Cont.ContT r m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be (Control.Monad.Trans.Reader.ReaderT r m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be (Control.Monad.Trans.State.Lazy.StateT r m)
instance Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be m => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be (Control.Monad.Trans.State.Strict.StateT r m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be m, GHC.Base.Monoid r) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be (Control.Monad.Trans.Writer.Lazy.WriterT r m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be m, GHC.Base.Monoid r) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be (Control.Monad.Trans.Writer.Strict.WriterT r m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be m, GHC.Base.Monoid w) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be m, GHC.Base.Monoid w) => Database.Beam.Backend.SQL.BeamExtensions.MonadBeamInsertReturning be (Control.Monad.Trans.RWS.Strict.RWST r w s m)
