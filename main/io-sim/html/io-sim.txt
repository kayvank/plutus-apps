-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A pure simulator for monadic concurrency with STM
--   
--   A pure simulator for monadic concurrency with STM
@package io-sim
@version 0.2.0.0

module Data.List.Trace

-- | A <tt>cons</tt> list with polymorphic <tt>nil</tt>, thus an octopus.
--   
--   <ul>
--   <li><tt><a>Trace</a> Void a</tt> is an infinite stream</li>
--   <li><tt><a>Trace</a> () a</tt> is isomorphic to <tt>[a]</tt></li>
--   </ul>
--   
--   Usually used with <tt>a</tt> being a non empty sum type.
data Trace a b
Cons :: b -> Trace a b -> Trace a b
Nil :: a -> Trace a b

-- | Pretty print an <a>Trace</a>.
ppTrace :: (a -> String) -> (b -> String) -> Trace a b -> String
toList :: Trace a b -> [b]
fromList :: a -> [b] -> Trace a b
head :: Trace a b -> b
tail :: Trace a b -> Trace a b
filter :: (b -> Bool) -> Trace a b -> Trace a b
length :: Trace a b -> Int
instance GHC.Base.Functor (Data.List.Trace.Trace a)
instance (GHC.Classes.Ord b, GHC.Classes.Ord a) => GHC.Classes.Ord (Data.List.Trace.Trace a b)
instance (GHC.Classes.Eq b, GHC.Classes.Eq a) => GHC.Classes.Eq (Data.List.Trace.Trace a b)
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (Data.List.Trace.Trace a b)
instance Data.Bifunctor.Bifunctor Data.List.Trace.Trace
instance Data.Bifoldable.Bifoldable Data.List.Trace.Trace
instance Data.Bitraversable.Bitraversable Data.List.Trace.Trace
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.List.Trace.Trace a b)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.List.Trace.Trace a b)
instance GHC.Base.Monoid a => GHC.Base.Applicative (Data.List.Trace.Trace a)
instance GHC.Base.Monoid a => GHC.Base.Monad (Data.List.Trace.Trace a)
instance GHC.Base.Monoid a => Control.Monad.Fail.MonadFail (Data.List.Trace.Trace a)
instance GHC.Base.Monoid a => GHC.Base.Alternative (Data.List.Trace.Trace a)
instance GHC.Base.Monoid a => GHC.Base.MonadPlus (Data.List.Trace.Trace a)
instance GHC.Base.Monoid a => Control.Monad.Fix.MonadFix (Data.List.Trace.Trace a)
instance GHC.Classes.Eq a => Data.Functor.Classes.Eq1 (Data.List.Trace.Trace a)
instance GHC.Classes.Ord a => Data.Functor.Classes.Ord1 (Data.List.Trace.Trace a)
instance GHC.Show.Show a => Data.Functor.Classes.Show1 (Data.List.Trace.Trace a)

module Control.Monad.IOSim.Types
newtype IOSim s a
IOSim :: (forall r. (a -> SimA s r) -> SimA s r) -> IOSim s a
[unIOSim] :: IOSim s a -> forall r. (a -> SimA s r) -> SimA s r
runIOSim :: IOSim s a -> SimA s a
traceM :: Typeable a => a -> IOSim s ()
traceSTM :: Typeable a => a -> STMSim s ()
liftST :: ST s a -> IOSim s a
data SimA s a
[Return] :: a -> SimA s a
[Say] :: String -> SimA s b -> SimA s b
[Output] :: Dynamic -> SimA s b -> SimA s b
[LiftST] :: ST s a -> (a -> SimA s b) -> SimA s b
[GetMonoTime] :: (Time -> SimA s b) -> SimA s b
[GetWallTime] :: (UTCTime -> SimA s b) -> SimA s b
[SetWallTime] :: UTCTime -> SimA s b -> SimA s b
[UnshareClock] :: SimA s b -> SimA s b
[NewTimeout] :: DiffTime -> (Timeout (IOSim s) -> SimA s b) -> SimA s b
[UpdateTimeout] :: Timeout (IOSim s) -> DiffTime -> SimA s b -> SimA s b
[CancelTimeout] :: Timeout (IOSim s) -> SimA s b -> SimA s b
[Throw] :: SomeException -> SimA s a
[Catch] :: Exception e => SimA s a -> (e -> SimA s a) -> (a -> SimA s b) -> SimA s b
[Evaluate] :: a -> (a -> SimA s b) -> SimA s b
[Fork] :: IOSim s () -> (ThreadId -> SimA s b) -> SimA s b
[GetThreadId] :: (ThreadId -> SimA s b) -> SimA s b
[LabelThread] :: ThreadId -> String -> SimA s b -> SimA s b
[Atomically] :: STM s a -> (a -> SimA s b) -> SimA s b
[ThrowTo] :: SomeException -> ThreadId -> SimA s a -> SimA s a
[SetMaskState] :: MaskingState -> IOSim s a -> (a -> SimA s b) -> SimA s b
[GetMaskState] :: (MaskingState -> SimA s b) -> SimA s b
[YieldSim] :: SimA s a -> SimA s a
[ExploreRaces] :: SimA s b -> SimA s b
[Fix] :: (x -> IOSim s x) -> (x -> SimA s r) -> SimA s r
type StepId = (ThreadId, Int)
type STMSim = STM
newtype STM s a
STM :: (forall r. (a -> StmA s r) -> StmA s r) -> STM s a
[unSTM] :: STM s a -> forall r. (a -> StmA s r) -> StmA s r
runSTM :: STM s a -> StmA s a
data StmA s a
[ReturnStm] :: a -> StmA s a
[ThrowStm] :: SomeException -> StmA s a
[NewTVar] :: Maybe String -> x -> (TVar s x -> StmA s b) -> StmA s b
[LabelTVar] :: String -> TVar s a -> StmA s b -> StmA s b
[ReadTVar] :: TVar s a -> (a -> StmA s b) -> StmA s b
[WriteTVar] :: TVar s a -> a -> StmA s b -> StmA s b
[Retry] :: StmA s b
[OrElse] :: StmA s a -> StmA s a -> (a -> StmA s b) -> StmA s b
[SayStm] :: String -> StmA s b -> StmA s b
[OutputStm] :: Dynamic -> StmA s b -> StmA s b
[TraceTVar] :: forall s a b. TVar s a -> (Maybe a -> a -> ST s TraceValue) -> StmA s b -> StmA s b
data StmTxResult s a

-- | A committed transaction reports the vars that were written (in order
--   of first write) so that the scheduler can unblock other threads that
--   were blocked in STM transactions that read any of these vars.
--   
--   It reports the vars that were read, so we can update vector clocks
--   appropriately.
--   
--   The third list of vars is ones that were created during this
--   transaction. This is useful for an implementation of <a>traceTVar</a>.
--   
--   It also includes the updated TVarId name supply.
StmTxCommitted :: a -> [SomeTVar s] -> [SomeTVar s] -> [SomeTVar s] -> [Dynamic] -> [String] -> TVarId -> StmTxResult s a

-- | A blocked transaction reports the vars that were read so that the
--   scheduler can block the thread on those vars.
StmTxBlocked :: [SomeTVar s] -> StmTxResult s a

-- | An aborted transaction reports the vars that were read so that the
--   vector clock can be updated.
StmTxAborted :: [SomeTVar s] -> SomeException -> StmTxResult s a
data StmStack s b a

-- | Executing in the context of a top level <tt>atomically</tt>.
[AtomicallyFrame] :: StmStack s a a

-- | Executing in the context of the <i>left</i> hand side of an
--   <tt>orElse</tt>
[OrElseLeftFrame] :: StmA s a -> (a -> StmA s b) -> Map TVarId (SomeTVar s) -> [SomeTVar s] -> [SomeTVar s] -> StmStack s b c -> StmStack s a c

-- | Executing in the context of the <i>right</i> hand side of an
--   <tt>orElse</tt>
[OrElseRightFrame] :: (a -> StmA s b) -> Map TVarId (SomeTVar s) -> [SomeTVar s] -> [SomeTVar s] -> StmStack s b c -> StmStack s a c
data family Timeout (m :: Type -> Type)
newtype TimeoutException
TimeoutException :: TimeoutId -> TimeoutException

-- | Set the current wall clock time for the thread's clock domain.
setCurrentTime :: UTCTime -> IOSim s ()

-- | Put the thread into a new wall clock domain, not shared with the
--   parent thread. Changing the wall clock time in the new clock domain
--   will not affect the other clock of other threads. All threads forked
--   by this thread from this point onwards will share the new clock
--   domain.
unshareClock :: IOSim s ()
data ScheduleControl

-- | default scheduling mode
ControlDefault :: ScheduleControl

-- | if the current control is <a>ControlAwait</a>, the normal scheduling
--   will proceed, until the thread found in the first <a>ScheduleMod</a>
--   reaches the given step. At this point the thread is put to sleep,
--   until after all the steps are followed.
ControlAwait :: [ScheduleMod] -> ScheduleControl

-- | follow the steps then continue with schedule modifications. This
--   control is set by <tt>followControl</tt> when <tt>controlTargets</tt>
--   returns true.
ControlFollow :: [StepId] -> [ScheduleMod] -> ScheduleControl
data ScheduleMod
ScheduleMod :: StepId -> ScheduleControl -> [StepId] -> ScheduleMod

-- | Step at which the <a>ScheduleMod</a> is activated.
[scheduleModTarget] :: ScheduleMod -> StepId

-- | <a>ScheduleControl</a> at the activation step. It is needed by
--   <tt>extendScheduleControl</tt> when combining the discovered schedule
--   with the initial one.
[scheduleModControl] :: ScheduleMod -> ScheduleControl

-- | Series of steps which are executed at the target step. This *includes*
--   the target step, not necessarily as the last step.
[scheduleModInsertion] :: ScheduleMod -> [StepId]
data ExplorationOptions
ExplorationOptions :: Int -> Int -> Maybe Int -> Maybe ScheduleControl -> ExplorationOptions
[explorationScheduleBound] :: ExplorationOptions -> Int
[explorationBranching] :: ExplorationOptions -> Int
[explorationStepTimelimit] :: ExplorationOptions -> Maybe Int
[explorationReplay] :: ExplorationOptions -> Maybe ScheduleControl
type ExplorationSpec = ExplorationOptions -> ExplorationOptions
withScheduleBound :: Int -> ExplorationSpec
withBranching :: Int -> ExplorationSpec
withStepTimelimit :: Int -> ExplorationSpec
withReplay :: ScheduleControl -> ExplorationSpec
stdExplorationOptions :: ExplorationOptions

-- | Wrapper for Eventlog events so they can be retrieved from the trace
--   with <tt>selectTraceEventsDynamic</tt>.
newtype EventlogEvent
EventlogEvent :: String -> EventlogEvent

-- | Wrapper for Eventlog markers so they can be retrieved from the trace
--   with <tt>selectTraceEventsDynamic</tt>.
newtype EventlogMarker
EventlogMarker :: String -> EventlogMarker
data SimEventType
EventSimStart :: ScheduleControl -> SimEventType
EventSay :: String -> SimEventType
EventLog :: Dynamic -> SimEventType
EventMask :: MaskingState -> SimEventType
EventThrow :: SomeException -> SimEventType
EventThrowTo :: SomeException -> ThreadId -> SimEventType
EventThrowToBlocked :: SimEventType
EventThrowToWakeup :: SimEventType
EventThrowToUnmasked :: Labelled ThreadId -> SimEventType
EventThreadForked :: ThreadId -> SimEventType
EventThreadFinished :: SimEventType
EventThreadUnhandled :: SomeException -> SimEventType
EventTxCommitted :: [Labelled TVarId] -> [Labelled TVarId] -> Maybe Effect -> SimEventType
EventTxAborted :: Maybe Effect -> SimEventType
EventTxBlocked :: [Labelled TVarId] -> Maybe Effect -> SimEventType
EventTxWakeup :: [Labelled TVarId] -> SimEventType
EventTimerCreated :: TimeoutId -> TVarId -> Time -> SimEventType
EventTimerUpdated :: TimeoutId -> Time -> SimEventType
EventTimerCancelled :: TimeoutId -> SimEventType
EventTimerExpired :: TimeoutId -> SimEventType
EventThreadSleep :: SimEventType
EventThreadWake :: SimEventType
EventDeschedule :: Deschedule -> SimEventType
EventFollowControl :: ScheduleControl -> SimEventType
EventAwaitControl :: StepId -> ScheduleControl -> SimEventType
EventPerformAction :: StepId -> SimEventType
EventReschedule :: ScheduleControl -> SimEventType
EventUnblocked :: [ThreadId] -> SimEventType

-- | <a>Trace</a> is a recursive data type, it is the trace of a
--   <a>IOSim</a> computation. The trace will contain information about
--   thread sheduling, blocking on <a>TVar</a>s, and other internal state
--   changes of <a>IOSim</a>. More importantly it also supports traces
--   generated by the computation with <a>say</a> (which corresponds to
--   using <a>putStrLn</a> in <a>IO</a>), <a>traceEventM</a>, or
--   dynamically typed traces with <a>traceM</a> (which generalise the
--   <tt>base</tt> library <a>traceM</a>)
--   
--   It also contains information on races discovered.
--   
--   See also: <tt>traceEvents</tt>, <tt>traceResult</tt>,
--   <tt>selectTraceEvents</tt>, <tt>selectTraceEventsDynamic</tt> and
--   <tt>printTraceEventsSay</tt>.
data SimEvent
SimEvent :: !Time -> !ThreadId -> !Maybe ThreadLabel -> !SimEventType -> SimEvent
[seTime] :: SimEvent -> !Time
[seThreadId] :: SimEvent -> !ThreadId
[seThreadLabel] :: SimEvent -> !Maybe ThreadLabel
[seType] :: SimEvent -> !SimEventType
SimPOREvent :: !Time -> !ThreadId -> !Int -> !Maybe ThreadLabel -> !SimEventType -> SimEvent
[seTime] :: SimEvent -> !Time
[seThreadId] :: SimEvent -> !ThreadId
[seStep] :: SimEvent -> !Int
[seThreadLabel] :: SimEvent -> !Maybe ThreadLabel
[seType] :: SimEvent -> !SimEventType
SimRacesFound :: [ScheduleControl] -> SimEvent
data SimResult a
MainReturn :: !Time -> a -> ![Labelled ThreadId] -> SimResult a
MainException :: !Time -> SomeException -> ![Labelled ThreadId] -> SimResult a
Deadlock :: !Time -> ![Labelled ThreadId] -> SimResult a
Loop :: SimResult a
type SimTrace a = Trace (SimResult a) SimEvent

-- | A <tt>cons</tt> list with polymorphic <tt>nil</tt>, thus an octopus.
--   
--   <ul>
--   <li><tt><a>Trace</a> Void a</tt> is an infinite stream</li>
--   <li><tt><a>Trace</a> () a</tt> is isomorphic to <tt>[a]</tt></li>
--   </ul>
--   
--   Usually used with <tt>a</tt> being a non empty sum type.
data Trace a b

-- | <i>Deprecated: Use <a>SimTrace</a> instead.</i>
pattern Trace :: Time -> ThreadId -> Maybe ThreadLabel -> SimEventType -> SimTrace a -> SimTrace a
pattern SimTrace :: Time -> ThreadId -> Maybe ThreadLabel -> SimEventType -> SimTrace a -> SimTrace a
pattern SimPORTrace :: Time -> ThreadId -> Int -> Maybe ThreadLabel -> SimEventType -> SimTrace a -> SimTrace a
pattern TraceMainReturn :: Time -> a -> [Labelled ThreadId] -> SimTrace a
pattern TraceMainException :: Time -> SomeException -> [Labelled ThreadId] -> SimTrace a
pattern TraceDeadlock :: Time -> [Labelled ThreadId] -> SimTrace a
pattern TraceRacesFound :: [ScheduleControl] -> SimTrace a -> SimTrace a
pattern TraceLoop :: SimTrace a

-- | Pretty print simulation trace.
ppTrace :: Show a => SimTrace a -> String

-- | Like <a>ppTrace</a> but does not show the result value.
ppTrace_ :: SimTrace a -> String
ppSimEvent :: Int -> Int -> Int -> SimEvent -> String

-- | Trace each event using <a>trace</a>; this is useful when a trace ends
--   with a pure error, e.g. an assertion.
ppDebug :: SimTrace a -> x -> x

-- | <i>Deprecated: Use <a>SimEventType</a> instead.</i>
type TraceEvent = SimEventType
data Labelled a
Labelled :: !a -> !Maybe String -> Labelled a
[l_labelled] :: Labelled a -> !a
[l_label] :: Labelled a -> !Maybe String
data ThreadId
RacyThreadId :: [Int] -> ThreadId
ThreadId :: [Int] -> ThreadId
childThreadId :: ThreadId -> Int -> ThreadId
setRacyThread :: ThreadId -> ThreadId
newtype TVarId
TVarId :: Int -> TVarId
newtype TimeoutId
TimeoutId :: Int -> TimeoutId
newtype ClockId
ClockId :: [Int] -> ClockId
newtype VectorClock
VectorClock :: Map ThreadId Int -> VectorClock
[getVectorClock] :: VectorClock -> Map ThreadId Int
unTimeoutId :: TimeoutId -> Int
type ThreadLabel = String
type TVarLabel = String
data TVar s a
TVar :: !TVarId -> !STRef s (Maybe TVarLabel) -> !STRef s a -> !STRef s [a] -> !STRef s ([ThreadId], Set ThreadId) -> !STRef s VectorClock -> !STRef s (Maybe (Maybe a -> a -> ST s TraceValue)) -> TVar s a

-- | The identifier of this var.
[tvarId] :: TVar s a -> !TVarId

-- | Label.
[tvarLabel] :: TVar s a -> !STRef s (Maybe TVarLabel)

-- | The var's current value
[tvarCurrent] :: TVar s a -> !STRef s a

-- | A stack of undo values. This is only used while executing a
--   transaction.
[tvarUndo] :: TVar s a -> !STRef s [a]

-- | Thread Ids of threads blocked on a read of this var. It is represented
--   in reverse order of thread wakeup, without duplicates.
--   
--   To avoid duplicates efficiently, the operations rely on a copy of the
--   thread Ids represented as a set.
[tvarBlocked] :: TVar s a -> !STRef s ([ThreadId], Set ThreadId)

-- | The vector clock of the current value.
[tvarVClock] :: TVar s a -> !STRef s VectorClock

-- | Callback to construct a trace which will be attached to the dynamic
--   trace.
[tvarTrace] :: TVar s a -> !STRef s (Maybe (Maybe a -> a -> ST s TraceValue))
data SomeTVar s
[SomeTVar] :: !TVar s a -> SomeTVar s
data Deschedule
Yield :: Deschedule
Interruptable :: Deschedule
Blocked :: Deschedule
Terminated :: Deschedule
Sleep :: Deschedule

-- | <i>Deprecated: Use IOSim</i>
type SimM s = IOSim s

-- | <i>Deprecated: Use STMSim</i>
type SimSTM = STM
instance GHC.Classes.Eq Control.Monad.IOSim.Types.TimeoutException
instance GHC.Show.Show a => GHC.Show.Show (Control.Monad.IOSim.Types.Labelled a)
instance GHC.Generics.Generic (Control.Monad.IOSim.Types.Labelled a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.Monad.IOSim.Types.Labelled a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.Monad.IOSim.Types.Labelled a)
instance GHC.Show.Show a => GHC.Show.Show (Control.Monad.IOSim.Types.SimResult a)
instance GHC.Classes.Ord Control.Monad.IOSim.Types.ScheduleMod
instance GHC.Classes.Eq Control.Monad.IOSim.Types.ScheduleMod
instance GHC.Show.Show Control.Monad.IOSim.Types.ScheduleControl
instance GHC.Classes.Ord Control.Monad.IOSim.Types.ScheduleControl
instance GHC.Classes.Eq Control.Monad.IOSim.Types.ScheduleControl
instance GHC.Show.Show Control.Monad.IOSim.Types.SimEventType
instance GHC.Show.Show Control.Monad.IOSim.Types.SimEvent
instance GHC.Generics.Generic Control.Monad.IOSim.Types.SimEvent
instance GHC.Show.Show Control.Monad.IOSim.Types.ExplorationOptions
instance GHC.Show.Show Control.Monad.IOSim.Types.ScheduleMod
instance Control.Monad.Class.MonadEventlog.MonadEventlog (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadTimer.MonadTimer (Control.Monad.IOSim.Types.IOSim s)
instance GHC.Show.Show Control.Monad.IOSim.Types.TimeoutException
instance GHC.Exception.Type.Exception Control.Monad.IOSim.Types.TimeoutException
instance GHC.Classes.Eq (Control.Monad.IOSim.Types.Async s a)
instance GHC.Classes.Ord (Control.Monad.IOSim.Types.Async s a)
instance GHC.Base.Functor (Control.Monad.IOSim.Types.Async s)
instance Control.Monad.Class.MonadAsync.MonadAsync (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadSay.MonadSay (Control.Monad.IOSim.Types.STMSim s)
instance GHC.Base.Functor (Control.Monad.IOSim.Types.IOSim s)
instance GHC.Base.Applicative (Control.Monad.IOSim.Types.IOSim s)
instance GHC.Base.Monad (Control.Monad.IOSim.Types.IOSim s)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Control.Monad.IOSim.Types.IOSim s a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Control.Monad.IOSim.Types.IOSim s a)
instance Control.Monad.Fail.MonadFail (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Fix.MonadFix (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadSay.MonadSay (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadThrow.MonadThrow (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadThrow.MonadEvaluate (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Catch.MonadThrow (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadThrow.MonadCatch (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Catch.MonadCatch (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadThrow.MonadMask (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadThrow.MonadMaskingState (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Catch.MonadMask (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadFork.MonadThread (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadFork.MonadFork (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadTest.MonadTest (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadSTM.MonadLabelledSTM (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadSTM.MonadSTM (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadSTM.MonadInspectSTM (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadSTM.MonadTraceSTM (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadST.MonadST (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadTime.MonadMonotonicTime (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadTime.MonadTime (Control.Monad.IOSim.Types.IOSim s)
instance Control.Monad.Class.MonadTimer.MonadDelay (Control.Monad.IOSim.Types.IOSim s)
instance GHC.Base.Functor (Control.Monad.IOSim.Types.STM s)
instance GHC.Base.Applicative (Control.Monad.IOSim.Types.STM s)
instance GHC.Base.Monad (Control.Monad.IOSim.Types.STM s)
instance Control.Monad.Fail.MonadFail (Control.Monad.IOSim.Types.STM s)
instance GHC.Base.Alternative (Control.Monad.IOSim.Types.STM s)
instance GHC.Base.MonadPlus (Control.Monad.IOSim.Types.STM s)
instance Control.Monad.Class.MonadThrow.MonadThrow (Control.Monad.IOSim.Types.STM s)
instance Control.Monad.Catch.MonadThrow (Control.Monad.IOSim.Types.STM s)

module Control.Monad.IOSim
data IOSim s a
type STMSim = STM

-- | <a>IOSim</a> is a pure monad.
runSim :: forall a. (forall s. IOSim s a) -> Either Failure a

-- | For quick experiments and tests it is often appropriate and convenient
--   to simply throw failures as exceptions.
runSimOrThrow :: forall a. (forall s. IOSim s a) -> a

-- | Like <a>runSim</a> but also fail if when the main thread terminates,
--   there are other threads still running or blocked. If one is trying to
--   follow a strict thread cleanup policy then this helps testing for
--   that.
runSimStrictShutdown :: forall a. (forall s. IOSim s a) -> Either Failure a

-- | Simulation termination with failure
data Failure

-- | The main thread terminated with an exception
FailureException :: SomeException -> Failure

-- | The threads all deadlocked
FailureDeadlock :: ![Labelled ThreadId] -> Failure

-- | The main thread terminated normally but other threads were still
--   alive, and strict shutdown checking was requested. See
--   <a>runSimStrictShutdown</a>
FailureSloppyShutdown :: [Labelled ThreadId] -> Failure

-- | See <a>runSimTraceST</a> below.
runSimTrace :: forall a. (forall s. IOSim s a) -> SimTrace a
controlSimTrace :: forall a. Maybe Int -> ScheduleControl -> (forall s. IOSim s a) -> SimTrace a
exploreSimTrace :: forall a test. Testable test => (ExplorationOptions -> ExplorationOptions) -> (forall s. IOSim s a) -> (Maybe (SimTrace a) -> SimTrace a -> test) -> Property
data ScheduleMod
ScheduleMod :: StepId -> ScheduleControl -> [StepId] -> ScheduleMod

-- | Step at which the <a>ScheduleMod</a> is activated.
[scheduleModTarget] :: ScheduleMod -> StepId

-- | <a>ScheduleControl</a> at the activation step. It is needed by
--   <tt>extendScheduleControl</tt> when combining the discovered schedule
--   with the initial one.
[scheduleModControl] :: ScheduleMod -> ScheduleControl

-- | Series of steps which are executed at the target step. This *includes*
--   the target step, not necessarily as the last step.
[scheduleModInsertion] :: ScheduleMod -> [StepId]
data ScheduleControl

-- | default scheduling mode
ControlDefault :: ScheduleControl

-- | if the current control is <a>ControlAwait</a>, the normal scheduling
--   will proceed, until the thread found in the first <a>ScheduleMod</a>
--   reaches the given step. At this point the thread is put to sleep,
--   until after all the steps are followed.
ControlAwait :: [ScheduleMod] -> ScheduleControl

-- | follow the steps then continue with schedule modifications. This
--   control is set by <tt>followControl</tt> when <tt>controlTargets</tt>
--   returns true.
ControlFollow :: [StepId] -> [ScheduleMod] -> ScheduleControl

-- | The most general method of running <a>IOSim</a> is in <a>ST</a> monad.
--   One can recover failures or the result from <a>SimTrace</a> with
--   <tt>traceResult</tt>, or access <a>SimEventType</a>s generated by the
--   computation with <tt>traceEvents</tt>. A slightly more convenient way
--   is exposed by <tt>runSimTrace</tt>.
runSimTraceST :: forall s a. IOSim s a -> ST s (SimTrace a)
liftST :: ST s a -> IOSim s a
traceM :: Typeable a => a -> IOSim s ()
traceSTM :: Typeable a => a -> STMSim s ()

-- | Set the current wall clock time for the thread's clock domain.
setCurrentTime :: UTCTime -> IOSim s ()

-- | Put the thread into a new wall clock domain, not shared with the
--   parent thread. Changing the wall clock time in the new clock domain
--   will not affect the other clock of other threads. All threads forked
--   by this thread from this point onwards will share the new clock
--   domain.
unshareClock :: IOSim s ()
type SimTrace a = Trace (SimResult a) SimEvent

-- | A <tt>cons</tt> list with polymorphic <tt>nil</tt>, thus an octopus.
--   
--   <ul>
--   <li><tt><a>Trace</a> Void a</tt> is an infinite stream</li>
--   <li><tt><a>Trace</a> () a</tt> is isomorphic to <tt>[a]</tt></li>
--   </ul>
--   
--   Usually used with <tt>a</tt> being a non empty sum type.
data Trace a b
Cons :: b -> Trace a b -> Trace a b
Nil :: a -> Trace a b

-- | <i>Deprecated: Use <a>SimTrace</a> instead.</i>
pattern Trace :: Time -> ThreadId -> Maybe ThreadLabel -> SimEventType -> SimTrace a -> SimTrace a
pattern SimTrace :: Time -> ThreadId -> Maybe ThreadLabel -> SimEventType -> SimTrace a -> SimTrace a
pattern SimPORTrace :: Time -> ThreadId -> Int -> Maybe ThreadLabel -> SimEventType -> SimTrace a -> SimTrace a
pattern TraceDeadlock :: Time -> [Labelled ThreadId] -> SimTrace a
pattern TraceLoop :: SimTrace a
pattern TraceMainReturn :: Time -> a -> [Labelled ThreadId] -> SimTrace a
pattern TraceMainException :: Time -> SomeException -> [Labelled ThreadId] -> SimTrace a
pattern TraceRacesFound :: [ScheduleControl] -> SimTrace a -> SimTrace a
data SimResult a
MainReturn :: !Time -> a -> ![Labelled ThreadId] -> SimResult a
MainException :: !Time -> SomeException -> ![Labelled ThreadId] -> SimResult a
Deadlock :: !Time -> ![Labelled ThreadId] -> SimResult a
Loop :: SimResult a

-- | <a>Trace</a> is a recursive data type, it is the trace of a
--   <a>IOSim</a> computation. The trace will contain information about
--   thread sheduling, blocking on <a>TVar</a>s, and other internal state
--   changes of <a>IOSim</a>. More importantly it also supports traces
--   generated by the computation with <a>say</a> (which corresponds to
--   using <a>putStrLn</a> in <a>IO</a>), <a>traceEventM</a>, or
--   dynamically typed traces with <a>traceM</a> (which generalise the
--   <tt>base</tt> library <a>traceM</a>)
--   
--   It also contains information on races discovered.
--   
--   See also: <tt>traceEvents</tt>, <tt>traceResult</tt>,
--   <tt>selectTraceEvents</tt>, <tt>selectTraceEventsDynamic</tt> and
--   <tt>printTraceEventsSay</tt>.
data SimEvent
SimEvent :: !Time -> !ThreadId -> !Maybe ThreadLabel -> !SimEventType -> SimEvent
[seTime] :: SimEvent -> !Time
[seThreadId] :: SimEvent -> !ThreadId
[seThreadLabel] :: SimEvent -> !Maybe ThreadLabel
[seType] :: SimEvent -> !SimEventType
SimPOREvent :: !Time -> !ThreadId -> !Int -> !Maybe ThreadLabel -> !SimEventType -> SimEvent
[seTime] :: SimEvent -> !Time
[seThreadId] :: SimEvent -> !ThreadId
[seStep] :: SimEvent -> !Int
[seThreadLabel] :: SimEvent -> !Maybe ThreadLabel
[seType] :: SimEvent -> !SimEventType
SimRacesFound :: [ScheduleControl] -> SimEvent
data SimEventType
EventSimStart :: ScheduleControl -> SimEventType
EventSay :: String -> SimEventType
EventLog :: Dynamic -> SimEventType
EventMask :: MaskingState -> SimEventType
EventThrow :: SomeException -> SimEventType
EventThrowTo :: SomeException -> ThreadId -> SimEventType
EventThrowToBlocked :: SimEventType
EventThrowToWakeup :: SimEventType
EventThrowToUnmasked :: Labelled ThreadId -> SimEventType
EventThreadForked :: ThreadId -> SimEventType
EventThreadFinished :: SimEventType
EventThreadUnhandled :: SomeException -> SimEventType
EventTxCommitted :: [Labelled TVarId] -> [Labelled TVarId] -> Maybe Effect -> SimEventType
EventTxAborted :: Maybe Effect -> SimEventType
EventTxBlocked :: [Labelled TVarId] -> Maybe Effect -> SimEventType
EventTxWakeup :: [Labelled TVarId] -> SimEventType
EventTimerCreated :: TimeoutId -> TVarId -> Time -> SimEventType
EventTimerUpdated :: TimeoutId -> Time -> SimEventType
EventTimerCancelled :: TimeoutId -> SimEventType
EventTimerExpired :: TimeoutId -> SimEventType
EventThreadSleep :: SimEventType
EventThreadWake :: SimEventType
EventDeschedule :: Deschedule -> SimEventType
EventFollowControl :: ScheduleControl -> SimEventType
EventAwaitControl :: StepId -> ScheduleControl -> SimEventType
EventPerformAction :: StepId -> SimEventType
EventReschedule :: ScheduleControl -> SimEventType
EventUnblocked :: [ThreadId] -> SimEventType
type ThreadLabel = String
data Labelled a
Labelled :: !a -> !Maybe String -> Labelled a
[l_labelled] :: Labelled a -> !a
[l_label] :: Labelled a -> !Maybe String

-- | Pretty print simulation trace.
ppTrace :: Show a => SimTrace a -> String

-- | Like <a>ppTrace</a> but does not show the result value.
ppTrace_ :: SimTrace a -> String
ppEvents :: [(Time, ThreadId, Maybe ThreadLabel, SimEventType)] -> String
ppSimEvent :: Int -> Int -> Int -> SimEvent -> String

-- | Trace each event using <a>trace</a>; this is useful when a trace ends
--   with a pure error, e.g. an assertion.
ppDebug :: SimTrace a -> x -> x
traceEvents :: SimTrace a -> [(Time, ThreadId, Maybe ThreadLabel, SimEventType)]
traceResult :: Bool -> SimTrace a -> Either Failure a
selectTraceEvents :: (SimEventType -> Maybe b) -> SimTrace a -> [b]
selectTraceEvents' :: (SimEventType -> Maybe b) -> SimTrace a -> [b]

-- | Select all the traced values matching the expected type. This relies
--   on the sim's dynamic trace facility.
--   
--   For convenience, this throws exceptions for abnormal sim termination.
selectTraceEventsDynamic :: forall a b. Typeable b => SimTrace a -> [b]

-- | Like <a>selectTraceEventsDynamic</a> but returns partial trace if an
--   exception is found in it.
selectTraceEventsDynamic' :: forall a b. Typeable b => SimTrace a -> [b]

-- | Get a trace of <a>EventSay</a>.
--   
--   For convenience, this throws exceptions for abnormal sim termination.
selectTraceEventsSay :: SimTrace a -> [String]

-- | Like <a>selectTraceEventsSay</a> but return partial trace if an
--   exception is found in it.
selectTraceEventsSay' :: SimTrace a -> [String]
selectTraceRaces :: SimTrace a -> [ScheduleControl]

-- | The most general select function. It is a _total_ function.
traceSelectTraceEvents :: (SimEventType -> Maybe b) -> SimTrace a -> Trace (SimResult a) b

-- | Select dynamic events. It is a _total_ function.
traceSelectTraceEventsDynamic :: forall a b. Typeable b => SimTrace a -> Trace (SimResult a) b

-- | Select say events. It is a _total_ function.
traceSelectTraceEventsSay :: forall a. SimTrace a -> Trace (SimResult a) String

-- | Print all <a>EventSay</a> to the console.
--   
--   For convenience, this throws exceptions for abnormal sim termination.
printTraceEventsSay :: SimTrace a -> IO ()
type ExplorationSpec = ExplorationOptions -> ExplorationOptions
data ExplorationOptions
ExplorationOptions :: Int -> Int -> Maybe Int -> Maybe ScheduleControl -> ExplorationOptions
[explorationScheduleBound] :: ExplorationOptions -> Int
[explorationBranching] :: ExplorationOptions -> Int
[explorationStepTimelimit] :: ExplorationOptions -> Maybe Int
[explorationReplay] :: ExplorationOptions -> Maybe ScheduleControl
stdExplorationOptions :: ExplorationOptions
withScheduleBound :: Int -> ExplorationSpec
withBranching :: Int -> ExplorationSpec
withStepTimelimit :: Int -> ExplorationSpec
withReplay :: ScheduleControl -> ExplorationSpec

-- | Wrapper for Eventlog events so they can be retrieved from the trace
--   with <tt>selectTraceEventsDynamic</tt>.
newtype EventlogEvent
EventlogEvent :: String -> EventlogEvent

-- | Wrapper for Eventlog markers so they can be retrieved from the trace
--   with <tt>selectTraceEventsDynamic</tt>.
newtype EventlogMarker
EventlogMarker :: String -> EventlogMarker
execReadTVar :: TVar s a -> ST s a

-- | <i>Deprecated: Use IOSim</i>
type SimM s = IOSim s

-- | <i>Deprecated: Use STMSim</i>
type SimSTM = STM

-- | <i>Deprecated: Use <a>SimEventType</a> instead.</i>
type TraceEvent = SimEventType
instance GHC.Show.Show Control.Monad.IOSim.Failure
instance GHC.Exception.Type.Exception Control.Monad.IOSim.Failure
