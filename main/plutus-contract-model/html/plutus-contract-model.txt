-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/input-output-hk/plutus-apps#readme</a>
@package plutus-contract-model
@version 1.2.0.0

module Plutus.Contract.Test.ContractModel.Internal.ContractInstance

-- | Key-value map where keys and values have three indices that can vary
--   between different elements of the map. Used to store
--   <a>ContractHandle</a>s, which are indexed over observable state,
--   schema, and error type.
data IMap (key :: i -> j -> k -> l -> *) (val :: i -> j -> k -> *)
[IMNil] :: IMap key val
[IMCons] :: (Typeable i, Typeable j, Typeable k, Typeable l) => key i j k l -> val i j k -> IMap key val -> IMap key val
imAppend :: IMap key val -> IMap key val -> IMap key val

-- | Look up a value in an indexed map. First checks that the indices
--   agree, using <a>cast</a>. Once the type checker is convinced that the
--   indices match we can check the key for equality.
imLookup :: (Typeable i, Typeable j, Typeable k, Typeable l, Typeable key, Typeable val, Eq (key i j k l)) => key i j k l -> IMap key val -> Maybe (val i j k)
imMap :: (forall i j k l. key i j k l -> key' i j k l) -> (forall i j k. val i j k -> val' i j k) -> IMap key val -> IMap key' val'

-- | The constraints required on contract schemas and error types to enable
--   calling contract endpoints (<a>callEndpoint</a>).
type SchemaConstraints w schema err = (Typeable w, Monoid w, ToJSON w, Typeable schema, ContractConstraints schema, Show err, Typeable err, ToJSON err, FromJSON err, ToJSON w, FromJSON w)
data WalletContractHandle w s e
WalletContractHandle :: Wallet -> ContractHandle w s e -> WalletContractHandle w s e
type Handles state = IMap (ContractInstanceKey state) WalletContractHandle
handlesAppend :: Handles state -> Handles state -> Handles state
data StartContract state
[StartContract] :: (SchemaConstraints w s e, Typeable p) => ContractInstanceKey state w s e p -> p -> StartContract state
class (ContractModel state, (forall w s e p. Eq (ContractInstanceKey state w s e p)), (forall w s e p. Show (ContractInstanceKey state w s e p))) => ContractInstanceModel state where {
    
    -- | To be able to call a contract endpoint from a wallet a
    --   <a>ContractHandle</a> is required. These are managed by the test
    --   framework and all the user needs to do is provide this contract
    --   instance key type representing the different contract instances that a
    --   test needs to work with, and when creating a property (see
    --   <tt>propRunActions_</tt>) provide a list of contract instance keys
    --   together with their wallets and contracts. Contract instance keys are
    --   indexed by the observable state, schema, and error type of the
    --   contract and should be defined as a GADT. For example, a handle type
    --   for a contract with one seller and multiple buyers could look like
    --   this.
    --   
    --   <pre>
    --   data ContractInstanceKey MyModel w s e where
    --       Buyer  :: Wallet -&gt; ContractInstanceKey MyModel MyObsState MySchema MyError MyParams
    --       Seller :: ContractInstanceKey MyModel MyObsState MySchema MyError MyParams
    --   </pre>
    data family ContractInstanceKey state :: * -> Row * -> * -> * -> *;
}

-- | Get the wallet that the contract running at a specific
--   <a>ContractInstanceKey</a> should run in
instanceWallet :: ContractInstanceModel state => ContractInstanceKey state w s e p -> Wallet

-- | The <a>ContractInstanceTag</a> of an instance key for a wallet.
--   Defaults to <a>walletInstanceTag</a>. You must override this if you
--   have multiple instances per wallet.
instanceTag :: forall w s e p. (ContractInstanceModel state, SchemaConstraints w s e) => ContractInstanceKey state w s e p -> ContractInstanceTag

-- | The initial handles
initialInstances :: ContractInstanceModel state => [StartContract state]

-- | Start new contract instances
startInstances :: ContractInstanceModel state => ModelState state -> Action state -> [StartContract state]

-- | Map a <a>ContractInstanceKey</a> <tt>k</tt> to the <a>Contract</a>
--   that is started when we start <tt>k</tt> in a given <a>ModelState</a>
--   with a given semantics of <a>SymToken</a>s
instanceContract :: ContractInstanceModel state => (forall t. HasSymbolicRep t => Symbolic t -> t) -> ContractInstanceKey state w s e p -> p -> Contract w s e ()


-- | This module provides a framework for testing Plutus contracts built on
--   <a>Test.QuickCheck</a>. The testing is model based, so to test a
--   contract you define a type modelling the state of the contract (or set
--   of contracts) and provide an instance of the <a>ContractModel</a>
--   class. This instance specifies what operations (<a>Action</a>s) the
--   contract supports, how they interact with the model state, and how to
--   execute them in the blockchain emulator
--   (<a>Plutus.Trace.Emulator</a>). Tests are evaluated by running
--   sequences of actions (random or user-specified) in the emulator and
--   comparing the state of the blockchain to the model state at the end.
--   
--   Test cases are written in the <a>DL</a> monad, which supports mixing
--   fixed sequences of actions with random actions, making it easy to
--   write properties like <i>it is always possible to get all funds out of
--   the contract</i>.
module Plutus.Contract.Test.ContractModel.Internal
pattern UnderlyingAction :: () => Action s -> Action (WithInstances s)
pattern Unilateral :: () => Wallet -> Action (WithInstances s)

-- | Options for controlling coverage checking requirements
--   
--   <ul>
--   <li><a>checkCoverage</a> tells you whether or not to run the coverage
--   checks at all.</li>
--   <li>`endpointCoverageEq instance endpointName` tells us what
--   percentage of tests are required to include a call to the endpoint
--   <tt>endpointName</tt> in the contract at `instance`.</li>
--   <li><tt>coverIndex</tt> is the coverage index obtained from the
--   <tt>CompiledCodeIn</tt> of the validator.</li>
--   </ul>
data CoverageOptions
CoverageOptions :: Bool -> (ContractInstanceTag -> String -> Double) -> CoverageIndex -> Maybe (IORef CoverageData) -> CoverageOptions
[_checkCoverage] :: CoverageOptions -> Bool
[_endpointCoverageReq] :: CoverageOptions -> ContractInstanceTag -> String -> Double
[_coverageIndex] :: CoverageOptions -> CoverageIndex
[_coverageIORef] :: CoverageOptions -> Maybe (IORef CoverageData)
newtype WithInstances s
WithInstances :: s -> WithInstances s
[withoutInstances] :: WithInstances s -> s
type CheckableContractModel state = (RunModel state (SpecificationEmulatorTrace state), ContractInstanceModel state)
type EmulatorTraceWithInstances s = Eff (State (Handles s) : EmulatorEffects)
type SpecificationEmulatorTrace s = Eff (Reader (Handles s) : BaseEmulatorEffects)
contractHandle :: (ContractInstanceModel state, Typeable w, Typeable schema, Typeable err, Typeable params) => ContractInstanceKey state w schema err params -> RunMonad (SpecificationEmulatorTrace state) (ContractHandle w schema err)
activateWallets :: ContractInstanceModel state => (forall t. HasSymbolicRep t => Symbolic t -> t) -> [StartContract state] -> EmulatorTraceWithInstances state ()

-- | Used to freeze other wallets when checking a
--   <a>NoLockedFundsProof</a>.
instancesForOtherWallets :: Wallet -> Handles state -> [ContractInstanceId]
liftSpecificationTrace :: SpecificationEmulatorTrace s a -> EmulatorTraceWithInstances s a

-- | `delay n` delays emulator execution by <tt>n</tt> slots
delay :: Integer -> RunMonad (SpecificationEmulatorTrace state) ()

-- | A whitelist entry tells you what final log entry prefixes are
--   acceptable for a given error
data Whitelist
Whitelist :: Set Text -> Whitelist
[errorPrefixes] :: Whitelist -> Set Text
data NoLockedFundsProofLight model
NoLockedFundsProofLight :: DL (WithInstances model) () -> NoLockedFundsProofLight model
[nlfplMainStrategy] :: NoLockedFundsProofLight model -> DL (WithInstances model) ()

-- | A "proof" that you can always recover the funds locked by a contract.
--   The first component is a strategy that from any state of the contract
--   can get all the funds out. The second component is a strategy for each
--   wallet that from the same state, shows how that wallet can recover the
--   same (or bigger) amount as using the first strategy, without relying
--   on any actions being taken by the other wallets.
--   
--   For instance, in a two player game where each player bets some amount
--   of funds and the winner gets the pot, there needs to be a mechanism
--   for the players to recover their bid if the other player simply walks
--   away (perhaps after realising the game is lost). If not, it won't be
--   possible to construct a <a>NoLockedFundsProof</a> that works in a
--   state where both players need to move before any funds can be
--   collected.
data NoLockedFundsProof model
NoLockedFundsProof :: DL (WithInstances model) () -> (Wallet -> DL (WithInstances model) ()) -> (ModelState (WithInstances model) -> SymValue) -> (ModelState (WithInstances model) -> SymValue) -> NoLockedFundsProof model

-- | Strategy to recover all funds from the contract in any reachable
--   state.
[nlfpMainStrategy] :: NoLockedFundsProof model -> DL (WithInstances model) ()

-- | A strategy for each wallet to recover as much (or more) funds as the
--   main strategy would give them in a given state, without the assistance
--   of any other wallet.
[nlfpWalletStrategy] :: NoLockedFundsProof model -> Wallet -> DL (WithInstances model) ()

-- | An initial amount of overhead value that may be lost - e.g. setup fees
--   for scripts that can't be recovered.
[nlfpOverhead] :: NoLockedFundsProof model -> ModelState (WithInstances model) -> SymValue

-- | The total amount of margin for error in the value collected by the
--   WalletStrategy compared to the MainStrategy. This is useful if your
--   contract contains rounding code that makes the order of operations
--   have a small but predictable effect on the value collected by
--   different wallets.
[nlfpErrorMargin] :: NoLockedFundsProof model -> ModelState (WithInstances model) -> SymValue
checkCoverage :: Lens' CoverageOptions Bool
coverageIORef :: Lens' CoverageOptions (Maybe (IORef CoverageData))
coverageIndex :: Lens' CoverageOptions CoverageIndex
endpointCoverageReq :: Lens' CoverageOptions (ContractInstanceTag -> String -> Double)

-- | Default coverage checking options are: * not to check coverage * set
--   the requriements for every endpoint to 20% and * not to cover any
--   source locations in the validator scripts.
defaultCoverageOptions :: CoverageOptions

-- | Default check options that include a large amount of Ada in the
--   initial distributions to avoid having to write <a>ContractModel</a>s
--   that keep track of balances.
defaultCheckOptionsContractModel :: CheckOptions

-- | Run QuickCheck on a property that tracks coverage and print its
--   coverage report.
quickCheckWithCoverage :: Testable prop => Args -> CoverageOptions -> (CoverageOptions -> prop) -> IO CoverageReport
quickCheckWithCoverageAndResult :: Testable prop => Args -> CoverageOptions -> (CoverageOptions -> prop) -> IO (CoverageReport, Result)
balanceChangePredicate :: ProtocolParameters -> ContractModelResult state -> Property
threatModelPredicate :: ThreatModel a -> ProtocolParameters -> ContractModelResult state -> Property

-- | Check a threat model on all transactions produced by the given
--   actions.
checkThreatModel :: CheckableContractModel state => ThreatModel a -> Actions (WithInstances state) -> Property

-- | Check a threat model on all transactions produced by the given
--   actions.
checkThreatModelWithOptions :: CheckableContractModel state => CheckOptions -> CoverageOptions -> ThreatModel a -> Actions (WithInstances state) -> Property

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes. Equivalent to
--   
--   <pre>
--   propRunActions_ hs actions = <a>propRunActions</a> hs (<a>const</a> <a>$</a> <a>pure</a> <a>True</a>) actions
--   </pre>
propRunActions_ :: CheckableContractModel state => Actions (WithInstances state) -> Property

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes, and that the given
--   <a>TracePredicate</a> holds at the end. Equivalent to:
--   
--   <pre>
--   propRunActions = <a>propRunActionsWithOptions</a> <a>defaultCheckOptionsContractModel</a> <a>defaultCoverageOptions</a>
--   </pre>
propRunActions :: CheckableContractModel state => (ModelState (WithInstances state) -> TracePredicate) -> (ProtocolParameters -> ContractModelResult (WithInstances state) -> Property) -> Actions (WithInstances state) -> Property
propRunActionsWithOptions :: forall state. CheckableContractModel state => CheckOptions -> CoverageOptions -> (ModelState (WithInstances state) -> TracePredicate) -> (ProtocolParameters -> ContractModelResult (WithInstances state) -> Property) -> Actions (WithInstances state) -> Property

-- | The default skeleton of a NoLockedFundsProof - doesn't permit any
--   overhead or error margin.
defaultNLFP :: NoLockedFundsProof model

-- | Check a <a>NoLockedFundsProof</a>. Each test will generate an
--   arbitrary sequence of actions (<a>anyActions_</a>) and ask the
--   <a>nlfpMainStrategy</a> to recover all funds locked by the contract
--   after performing those actions. This results in some distribution of
--   the contract funds to the wallets, and the test then asks each
--   <a>nlfpWalletStrategy</a> to show how to recover their allotment of
--   funds without any assistance from the other wallets (assuming the main
--   strategy did not execute). When executing wallet strategies, the
--   off-chain instances for other wallets are killed and their private
--   keys are deleted from the emulator state.
checkNoLockedFundsProof :: CheckableContractModel model => NoLockedFundsProof model -> Property
checkNoLockedFundsProofFast :: CheckableContractModel model => NoLockedFundsProof model -> Property
checkNoLockedFundsProofWithOptions :: CheckableContractModel model => CheckOptions -> NoLockedFundsProof model -> Property
checkNoLockedFundsProofFastWithOptions :: CheckableContractModel model => CheckOptions -> NoLockedFundsProof model -> Property
checkNoLockedFundsProof' :: CheckableContractModel model => (Actions (WithInstances model) -> Property) -> NoLockedFundsProof model -> Property
actionsFromList :: [Action s] -> Actions s
walletAddress :: Wallet -> AddressInEra Era
addressToWallet :: AddressInEra Era -> Maybe Wallet
checkNoLockedFundsProofLight :: CheckableContractModel model => NoLockedFundsProofLight model -> Property

-- | Check that the last entry in a log is accepted by a whitelist entry
isAcceptedBy :: Maybe Text -> Whitelist -> Bool

-- | Check that a whitelist does not accept any partial functions
whitelistOk :: Whitelist -> Bool
mkWhitelist :: [Text] -> Whitelist
defaultWhitelist :: Whitelist

-- | Check that running a contract model does not result in validation
--   failures that are not accepted by the whitelist.
checkErrorWhitelist :: CheckableContractModel m => Whitelist -> Actions (WithInstances m) -> Property

-- | Check that running a contract model does not result in validation
--   failures that are not accepted by the whitelist.
checkErrorWhitelistWithOptions :: forall m. CheckableContractModel m => CheckOptions -> CoverageOptions -> Whitelist -> Actions (WithInstances m) -> Property
instance GHC.Base.Semigroup Plutus.Contract.Test.ContractModel.Internal.Whitelist
instance GHC.Base.Monoid Plutus.Contract.Test.ContractModel.Internal.Whitelist
instance GHC.Show.Show s => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Internal.WithInstances s)
instance GHC.Generics.Generic (Plutus.Contract.Test.ContractModel.Internal.WithInstances s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Internal.WithInstances s)
instance GHC.Generics.Generic (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Internal.WithInstances s))
instance GHC.Classes.Eq (Test.QuickCheck.ContractModel.Internal.Model.Action s) => GHC.Classes.Eq (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Internal.WithInstances s))
instance Test.QuickCheck.StateModel.Variables.HasVariables Wallet.Emulator.Wallet.Wallet
instance Plutus.Contract.Test.ContractModel.Internal.CheckableContractModel state => Test.QuickCheck.ContractModel.Internal.RunModel (Plutus.Contract.Test.ContractModel.Internal.WithInstances state) (Plutus.Contract.Test.ContractModel.Internal.EmulatorTraceWithInstances state)
instance GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Model.Action s) => GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Internal.WithInstances s))
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics (Test.QuickCheck.ContractModel.Internal.Model.Action s) => Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Internal.WithInstances s))
instance Test.QuickCheck.ContractModel.Internal.Model.ContractModel s => Test.QuickCheck.ContractModel.Internal.Model.ContractModel (Plutus.Contract.Test.ContractModel.Internal.WithInstances s)
instance Data.OpenUnion.Internal.Member Plutus.Trace.Effects.EmulatorControl.EmulatorControl effs => Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex (Control.Monad.Freer.Internal.Eff effs)
instance (Test.QuickCheck.ContractModel.Internal.ChainIndex.HasChainIndex (Control.Monad.Freer.Internal.Eff effs), Data.OpenUnion.Internal.Member Plutus.Trace.Effects.Waiting.Waiting effs) => Test.QuickCheck.ContractModel.Internal.IsRunnable (Control.Monad.Freer.Internal.Eff effs)

module Plutus.Contract.Test.ContractModel.Interface

-- | A <a>ContractModel</a> instance captures everything that is needed to
--   generate and run tests of a contract or set of contracts. It specifies
--   among other things
--   
--   <ul>
--   <li>what operations are supported by the contract
--   (<a>Action</a>),</li>
--   <li>when they are valid (<a>precondition</a>),</li>
--   <li>how to generate random actions (<a>arbitraryAction</a>),</li>
--   <li>how the operations affect the state (<a>nextState</a>), and</li>
--   <li>how to run the operations in the emulator (<a>perform</a>)</li>
--   </ul>
class (Typeable state, Show state, Show (Action state), Eq (Action state), HasSymbolics (Action state), HasVariables (Action state), HasVariables state, Generic state, (forall w s e p. Eq (ContractInstanceKey state w s e p)), (forall w s e p. Show (ContractInstanceKey state w s e p))) => ContractModel state where {
    
    -- | The type of actions that are supported by the contract. An action
    --   usually represents a single <a>callEndpoint</a> or a transfer of
    --   tokens, but it can be anything that can be interpreted in the
    --   <tt>EmulatorTrace</tt> monad.
    data family Action state;
    
    -- | To be able to call a contract endpoint from a wallet a
    --   <a>ContractHandle</a> is required. These are managed by the test
    --   framework and all the user needs to do is provide this contract
    --   instance key type representing the different contract instances that a
    --   test needs to work with, and when creating a property (see
    --   <a>propRunActions_</a>) provide a list of contract instance keys
    --   together with their wallets and contracts (a
    --   <tt>ContractInstanceSpec</tt>). Contract instance keys are indexed by
    --   the observable state, schema, and error type of the contract and
    --   should be defined as a GADT. For example, a handle type for a contract
    --   with one seller and multiple buyers could look like this.
    --   
    --   <pre>
    --   data ContractInstanceKey MyModel w s e where
    --       Buyer  :: Wallet -&gt; ContractInstanceKey MyModel MyObsState MySchema MyError MyParams
    --       Seller :: ContractInstanceKey MyModel MyObsState MySchema MyError MyParams
    --   </pre>
    data family ContractInstanceKey state :: * -> Row * -> * -> * -> *;
}

-- | Get the wallet that the contract running at a specific
--   <a>ContractInstanceKey</a> should run in
instanceWallet :: ContractModel state => ContractInstanceKey state w s e p -> Wallet

-- | The <a>ContractInstanceTag</a> of an instance key for a wallet.
--   Defaults to <a>walletInstanceTag</a>. You must override this if you
--   have multiple instances per wallet.
instanceTag :: forall w s e p. (ContractModel state, SchemaConstraints w s e) => ContractInstanceKey state w s e p -> ContractInstanceTag

-- | Given the current model state, provide a QuickCheck generator for a
--   random next action. This is used in the <a>Arbitrary</a> instance for
--   <a>Actions</a>s as well as by <tt>anyAction</tt> and
--   <tt>anyActions</tt>.
arbitraryAction :: ContractModel state => ModelState state -> Gen (Action state)

-- | The name of an Action, used to report statistics.
actionName :: ContractModel state => Action state -> String

-- | The probability that we will generate a <tt>WaitUntil</tt> in a given
--   state
waitProbability :: ContractModel state => ModelState state -> Double

-- | Control the distribution of how long <tt>WaitUntil</tt> waits
arbitraryWaitInterval :: ContractModel state => ModelState state -> Gen Slot

-- | The initial state, before any actions have been performed.
initialState :: ContractModel state => state

-- | The initial handles
initialInstances :: ContractModel state => [StartContract state]

-- | The <a>precondition</a> function decides if a given action is valid in
--   a given state. Typically actions generated by <a>arbitraryAction</a>
--   will satisfy the precondition, but if they don't they will be
--   discarded and another action will be generated. More importantly, the
--   preconditions are used when shrinking (see <a>shrinkAction</a>) to
--   ensure that shrunk test cases still make sense.
--   
--   If an explicit <a>action</a> in a <a>DL</a> scenario violates the
--   precondition an error is raised.
precondition :: ContractModel state => ModelState state -> Action state -> Bool

-- | <a>nextReactiveState</a> is run every time the model <a>wait</a>s for
--   a slot to be reached. This can be used to model reactive components of
--   off-chain code.
nextReactiveState :: ContractModel state => Slot -> Spec state ()

-- | This is where the model logic is defined. Given an action,
--   <a>nextState</a> specifies the effects running that action has on the
--   model state. It runs in the <a>Spec</a> monad, which is a state monad
--   over the <a>ModelState</a>.
nextState :: ContractModel state => Action state -> Spec state ()

-- | Start new contract instances
startInstances :: ContractModel state => ModelState state -> Action state -> [StartContract state]

-- | Map a <a>ContractInstanceKey</a> <tt>k</tt> to the <a>Contract</a>
--   that is started when we start <tt>k</tt> in a given <a>ModelState</a>
--   with a given semantics of <tt>SymToken</tt>s
instanceContract :: ContractModel state => (forall t. HasSymbolicRep t => Symbolic t -> t) -> ContractInstanceKey state w s e p -> p -> Contract w s e ()

-- | While <a>nextState</a> models the behaviour of the actions,
--   <a>perform</a> contains the code for running the actions in the
--   emulator (see <a>Plutus.Trace.Emulator</a>). It gets access to the
--   wallet contract handles, the current model state, and the action to be
--   performed.
perform :: ContractModel state => HandleFun state -> (forall t. HasSymbolicRep t => Symbolic t -> t) -> ModelState state -> Action state -> SpecificationEmulatorTrace ()

-- | When a test involving random sequences of actions fails, the framework
--   tries to find a minimal failing test case by shrinking the original
--   failure. Action sequences are shrunk by removing individual actions,
--   or by replacing an action by one of the (simpler) actions returned by
--   <a>shrinkAction</a>.
--   
--   See <a>shrink</a> for more information on shrinking.
shrinkAction :: ContractModel state => ModelState state -> Action state -> [Action state]

-- | The <a>monitoring</a> function allows you to collect statistics of
--   your testing using QuickCheck functions like <a>label</a>,
--   <a>collect</a>, <a>classify</a>, and <a>tabulate</a>. This function is
--   called by <a>propRunActions</a> (and friends) for any actions in the
--   given <a>Actions</a>.
--   
--   Statistics on which actions are executed are always collected.
monitoring :: ContractModel state => (ModelState state, ModelState state) -> Action state -> Property -> Property

-- | In some scenarios it's useful to have actions that are never generated
--   randomly, but only used explicitly in <a>DL</a> scenario
--   <a>action</a>s. To avoid these actions matching an <tt>anyAction</tt>
--   when shrinking, they can be marked <a>restricted</a>.
restricted :: ContractModel state => Action state -> Bool
type Actions state = Actions (WithInstances (WrappedState state))
data SomeContractInstanceKey state
[Key] :: (SchemaConstraints w s e, Typeable p) => ContractInstanceKey state w s e p -> SomeContractInstanceKey state
class HasSymbolics a
getAllSymbolics :: HasSymbolics a => a -> SymCollectionIndex

-- | The <a>ModelState</a> models the state of the blockchain. It contains,
--   
--   <ul>
--   <li>the contract-specific state (<a>contractState</a>)</li>
--   <li>the current slot (<a>currentSlot</a>)</li>
--   <li>the wallet balances (<tt>balances</tt>)</li>
--   <li>the amount that has been minted (<a>minted</a>)</li>
--   </ul>
data ModelState state

-- | Lens for the contract-specific part of the model state.
contractState :: Lens (ModelState state1) (ModelState state2) state1 state2
currentSlot :: Getter (ModelState state) Slot

-- | Get the current wallet balance changes. These are delta balances, so
--   they start out at zero and can be negative. The absolute balances used
--   by the emulator can be set in the <tt>CheckOptions</tt> argument to
--   <tt>propRunActionsWithOptions</tt>.
--   
--   <a>Spec</a> monad update functions: <a>withdraw</a>, <a>deposit</a>,
--   <a>transfer</a>.
balanceChanges :: Getter (ModelState state) (Map (AddressInEra Era) SymValue)
balanceChange :: Wallet -> Getter (ModelState state) SymValue

-- | Get the amount of tokens minted so far. This is used to compute
--   <a>lockedValue</a>.
--   
--   <a>Spec</a> monad update functions: <a>mint</a> and <a>burn</a>.
minted :: Getter (ModelState state) SymValue

-- | How much value is currently locked by contracts. This computed by
--   subtracting the wallet <tt>balances</tt> from the <a>minted</a> value.
lockedValue :: ModelState s -> SymValue

-- | Check if a symbolic value is zero
symIsZero :: SymValue -> Bool

-- | Monads with read access to the model state: the <a>Spec</a> monad used
--   in <a>nextState</a>, and the <tt>DL</tt> monad used to construct test
--   scenarios.
class Monad m => GetModelState (m :: Type -> Type)

-- | Get a component of the model state using a lens.
viewModelState :: GetModelState m => Getting a (ModelState (StateType m)) a -> m a

-- | Get a component of the contract state using a lens.
viewContractState :: (Coercible (StateType m) state, GetModelState m) => Getting a state a -> m a

-- | A symbolic token is a token that is only available at runtime
type SymToken = Symbolic AssetId
class SymValueLike v
toSymValue :: SymValueLike v => v -> SymValue
class TokenLike t

-- | Get the value of a specific token in a <a>SymValue</a>
symAssetIdValueOf :: TokenLike t => SymValue -> t -> Quantity

-- | Convert a token and an amount to a <a>SymValue</a>
symAssetIdValue :: TokenLike t => t -> Quantity -> SymValue
invSymValue :: SymValue -> SymValue

-- | Using a semantics function for symbolic tokens, convert a SymValue to
--   a Value
toValue :: (SymToken -> AssetId) -> SymValue -> Value

-- | The <a>Spec</a> monad is a state monad over the <a>ModelState</a> with
--   reader and writer components to keep track of newly created symbolic
--   tokens. It is used exclusively by the <a>nextState</a> function to
--   model the effects of an action on the blockchain.
newtype Spec state a
Spec :: WriterT SymCreationIndex (ReaderT (Var SymIndex) (State (ModelState state))) a -> Spec state a
[unSpec] :: Spec state a -> WriterT SymCreationIndex (ReaderT (Var SymIndex) (State (ModelState state))) a
wait :: forall state. ContractModel state => Integer -> Spec state ()
waitUntil :: forall state. ContractModel state => Slot -> Spec state ()

-- | Mint tokens. Minted tokens start out as <a>lockedValue</a> (i.e. owned
--   by the contract) and can be transferred to wallets using
--   <a>deposit</a>.
mint :: SymValueLike v => v -> Spec state ()

-- | Burn tokens. Equivalent to <tt><a>mint</a> . <a>inv</a></tt>.
burn :: SymValueLike v => v -> Spec state ()

-- | Add tokens to the <a>balanceChange</a> of a wallet. The added tokens
--   are subtracted from the <tt>lockedValue</tt> of tokens held by
--   contracts.
deposit :: SymValueLike v => Wallet -> v -> Spec state ()

-- | Withdraw tokens from a wallet. The withdrawn tokens are added to the
--   <tt>lockedValue</tt> of tokens held by contracts.
withdraw :: SymValueLike v => Wallet -> v -> Spec state ()

-- | Transfer tokens between wallets, updating their <tt>balances</tt>.
transfer :: SymValueLike v => Wallet -> Wallet -> v -> Spec state ()

-- | Create a new symbolic token in <a>nextState</a> - must have a
--   corresponding <tt>registerToken</tt> call in <a>perform</a>
createToken :: String -> Spec state SymToken

-- | Create a new symbolic TxOut in <a>nextState</a> - must have a
--   corresponding <tt>registerTxOut</tt> call in <a>perform</a>
createTxOut :: String -> Spec state SymTxOut

-- | Create a new symbolic TxIn in <a>nextState</a> - must have a
--   corresponding <tt>registerTxIn</tt> call in <a>perform</a>
createTxIn :: String -> Spec state SymTxIn
createSymbolic :: HasSymbolicRep t => String -> Spec state (Symbolic t)

-- | Assert that a particular predicate holds at a point in the
--   specification
assertSpec :: String -> Bool -> Spec state ()
type SpecificationEmulatorTrace = Eff (Writer [(String, SomethingWithSymbolicRep)] : BaseEmulatorEffects)

-- | Register the real token corresponding to a symbolic token created in
--   <tt>createToken</tt>.
registerToken :: String -> AssetId -> SpecificationEmulatorTrace ()

-- | Register the real TxOut corresponding to a symbolic TxOut created in
--   <tt>createTxOut</tt>.
registerTxOut :: String -> TxOut CtxUTxO Era -> SpecificationEmulatorTrace ()

-- | Register the real TxIn corresponding to a symbolic TxIn created in
--   <tt>createTxIn</tt>.
registerTxIn :: String -> TxIn -> SpecificationEmulatorTrace ()
registerSymbolic :: HasSymbolicRep t => String -> t -> SpecificationEmulatorTrace ()

-- | `delay n` delays emulator execution by <tt>n</tt> slots
delay :: Integer -> SpecificationEmulatorTrace ()
fromSlotNo :: SlotNo -> Slot
toSlotNo :: Slot -> SlotNo
type DL state = DL (WithInstances (WrappedState state))
action :: ContractModel state => Action state -> DL state ()
waitUntilDL :: ContractModel state => Slot -> DL state ()
observe :: ContractModel state => String -> ((forall t. HasSymbolicRep t => Symbolic t -> t) -> ChainState -> Bool) -> DL state ()

-- | Generate a random action using <a>arbitraryAction</a>. The generated
--   action is guaranteed to satisfy its <a>precondition</a>. Fails with
--   <tt>Stuck</tt> if no action satisfying the precondition can be found
--   after 100 attempts.
anyAction :: DL state ()

-- | Generate a sequence of random actions using <a>arbitraryAction</a>.
--   All actions satisfy their <a>precondition</a>s. The argument is the
--   expected number of actions in the sequence chosen from a geometric
--   distribution, unless in the <a>stopping</a> stage, in which case as
--   few actions as possible are generated.
anyActions :: Int -> DL state ()

-- | Generate a sequence of random actions using <a>arbitraryAction</a>.
--   All actions satisfy their <a>precondition</a>s. Actions may be
--   generated until the <a>stopping</a> stage is reached; the expected
--   length is size/2.
anyActions_ :: DL state ()

-- | Generate a random value using the given <a>Quantification</a> (or
--   list/tuple of quantifications). Generated values will only shrink to
--   smaller values that could also have been generated.
forAllQ :: Quantifiable q => q -> DL s (Quantifies q)

-- | Pick a random value from a list. Treated as an empty choice if the
--   list is empty:
--   
--   <pre>
--   <a>forAllQ</a> (<a>elementsQ</a> []) == <a>empty</a>
--   </pre>
elementsQ :: Eq a => [a] -> Quantification a

-- | Generate a random value in a given range (inclusive).
chooseQ :: (Arbitrary a, Random a, Ord a) => (a, a) -> Quantification a

-- | Fail if the boolean is <tt>False</tt>.
--   
--   Equivalent to
--   
--   <pre>
--   assert msg b = unless b (fail msg)
--   </pre>
assert :: String -> Bool -> DL s ()
assertModel :: String -> (ModelState state -> Bool) -> DL state ()

-- | Test case generation from <a>DL</a> scenarios have a target length of
--   the action sequence to be generated that is based on the QuickCheck
--   size parameter (see <a>sized</a>). However, given that scenarios can
--   contain explicit <a>action</a>s it might not be possible to stop the
--   scenario once the target length has been reached.
--   
--   Instead, once the target number of actions have been reached,
--   generation goes into the <i>stopping</i> phase. In this phase branches
--   starting with <a>stopping</a> are preferred, if possible. Conversely,
--   before the stopping phase, branches starting with <a>stopping</a> are
--   avoided unless there are no other possible choices.
--   
--   For example, here is the definition of <a>anyActions</a>:
--   
--   <pre>
--   <a>anyActions</a> n = <a>stopping</a> <a>&lt;|&gt;</a> pure ()
--                          <a>&lt;|&gt;</a> (<a>weight</a> (fromIntegral n) &gt;&gt; <a>anyAction</a> &gt;&gt; <a>anyActions</a> n)
--   </pre>
--   
--   The effect of this definition is that the second or third branch will
--   be taken until the desired number of actions have been generated, at
--   which point the <a>stopping</a> branch will be taken and generation
--   stops (or continues with whatever comes after the <a>anyActions</a>
--   call).
--   
--   Now, it might not be possible, or too hard, to find a way to terminate
--   a scenario. For instance, this scenario has no finite test cases:
--   
--   <pre>
--   looping = <a>anyAction</a> &gt;&gt; looping
--   </pre>
--   
--   To prevent test case generation from looping, if a scenario has not
--   terminated after generating <tt>2 * n + 20</tt> actions, where
--   <tt>n</tt> is when the stopping phase kicks in, generation fails with
--   a <tt>Looping</tt> error.
stopping :: DL state ()

-- | By default, <a>Alternative</a> choice (<a>&lt;|&gt;</a>) picks among
--   the next actions with equal probability. So, for instance, this code
--   chooses between the actions <tt>a</tt>, <tt>b</tt> and <tt>c</tt>,
--   with a probability <tt>1/3</tt> of choosing each:
--   
--   <pre>
--   unbiasedChoice a b c = <a>action</a> a <a>&lt;|&gt;</a> <a>action</a> b <a>&lt;|&gt;</a> <a>action</a> c
--   </pre>
--   
--   To change this you can use <a>weight</a>, which multiplies the
--   relative probability of picking a branch by the given number.
--   
--   For instance, the following scenario picks the action <tt>a</tt> with
--   probability <tt>2/3</tt> and the action <tt>b</tt> with probability
--   <tt>1/3</tt>:
--   
--   <pre>
--   biasedChoice a b = <a>weight</a> 2 (<a>action</a> a) <a>&lt;|&gt;</a> <a>weight</a> (<a>action</a> b)
--   </pre>
--   
--   Calls to <a>weight</a> need to appear at the top-level after a choice,
--   preceding any actions (<a>action</a>/<a>anyAction</a>) or random
--   generation (<tt>forAllQ</tt>), or they will have no effect.
weight :: Double -> DL state ()

-- | Sometimes test case generation should depend on QuickCheck's size
--   parameter. This can be accessed using <tt>getSize</tt>. For example,
--   <tt>anyActions_</tt> is defined by
--   
--   <pre>
--   anyActions_ = do n &lt;- getSize
--                    anyActions (n <a>div</a> 2 + 1)
--   </pre>
--   
--   so that we generate a random number of actions, but on average half
--   the size (which is about the same as the average random positive
--   integer, or length of a list).
getSize :: DL state Int

-- | The <a>monitor</a> function allows you to collect statistics of your
--   testing using QuickCheck functions like <a>label</a>, <a>collect</a>,
--   <a>classify</a>, and <a>tabulate</a>. See also the <tt>monitoring</tt>
--   method of <a>ContractModel</a> which is called for all actions in a
--   test case (regardless of whether they are generated by an explicit
--   <a>action</a> or an <a>anyAction</a>).
monitor :: (Property -> Property) -> DL state ()

-- | The constraints required on contract schemas and error types to enable
--   calling contract endpoints (<a>callEndpoint</a>).
type SchemaConstraints w schema err = (Typeable w, Monoid w, ToJSON w, Typeable schema, ContractConstraints schema, Show err, Typeable err, ToJSON err, FromJSON err, ToJSON w, FromJSON w)
data StartContract state
[StartContract] :: (SchemaConstraints w s e, Typeable p) => ContractInstanceKey state w s e p -> p -> StartContract state

-- | A function returning the <a>ContractHandle</a> corresponding to a
--   <a>ContractInstanceKey</a>. A <a>HandleFun</a> is provided to the
--   <a>perform</a> function to enable calling contract endpoints with
--   <a>callEndpoint</a>.
type HandleFun state = forall w schema err params. (Typeable w, Typeable schema, Typeable err, Typeable params) => ContractInstanceKey state w schema err params -> ContractHandle w schema err

-- | Sanity check a <a>ContractModel</a>. Ensures that wallet balances are
--   not always unchanged.
propSanityCheckModel :: forall state. ContractModel state => Property

-- | Sanity check a <a>ContractModel</a>. Ensures that all assertions in
--   the property generation succeed.
propSanityCheckAssertions :: forall state. ContractModel state => Actions state -> Property

-- | Sanity check a <a>ContractModel</a>. Ensures that
--   <a>nextReactiveState</a> is idempotent.
propSanityCheckReactive :: forall state. (ContractModel state, Eq state) => Actions state -> Positive Integer -> Positive Integer -> Property

-- | Options for controlling coverage checking requirements
--   
--   <ul>
--   <li><a>checkCoverage</a> tells you whether or not to run the coverage
--   checks at all.</li>
--   <li>`endpointCoverageEq instance endpointName` tells us what
--   percentage of tests are required to include a call to the endpoint
--   <tt>endpointName</tt> in the contract at `instance`.</li>
--   <li><tt>coverIndex</tt> is the coverage index obtained from the
--   <tt>CompiledCodeIn</tt> of the validator.</li>
--   </ul>
data CoverageOptions

-- | Default coverage checking options are: * not to check coverage * set
--   the requriements for every endpoint to 20% and * not to cover any
--   source locations in the validator scripts.
defaultCoverageOptions :: CoverageOptions
endpointCoverageReq :: Lens' CoverageOptions (ContractInstanceTag -> String -> Double)
checkCoverage :: Lens' CoverageOptions Bool
coverageIndex :: Lens' CoverageOptions CoverageIndex

-- | Run QuickCheck on a property that tracks coverage and print its
--   coverage report.
quickCheckWithCoverage :: Testable prop => Args -> CoverageOptions -> (CoverageOptions -> prop) -> IO CoverageReport
quickCheckWithCoverageAndResult :: Testable prop => Args -> CoverageOptions -> (CoverageOptions -> prop) -> IO (CoverageReport, Result)

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes. Equivalent to
--   
--   <pre>
--   propRunActions_ hs actions = <a>propRunActions</a> hs (<a>const</a> <a>$</a> <a>pure</a> <a>True</a>) actions
--   </pre>
propRunActions_ :: ContractModel state => Actions state -> Property

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes, and that the given
--   <a>TracePredicate</a> holds at the end. Equivalent to:
--   
--   <pre>
--   propRunActions = <a>propRunActionsWithOptions</a> <tt>defaultCheckOptionsContractModel</tt> <tt>defaultCoverageOptions</tt>
--   </pre>
propRunActions :: ContractModel state => (ModelState state -> TracePredicate) -> Actions state -> Property

-- | Run a <a>Actions</a> in the emulator and check that the model and the
--   emulator agree on the final wallet balance changes, that no off-chain
--   contract instance crashed, and that the given <a>TracePredicate</a>
--   holds at the end. The predicate has access to the final model state.
--   
--   The <a>Actions</a> argument can be generated by a <tt>forAllDL</tt>
--   from a <a>DL</a> scenario, or using the <a>Arbitrary</a> instance for
--   actions which generates random actions using <a>arbitraryAction</a>:
--   
--   <pre>
--   &gt;&gt;&gt; quickCheck $ propRunActions_ handles
--   +++ OK, passed 100 tests
--   
--   &gt;&gt;&gt; quickCheck $ forAllDL dl $ propRunActions_ handles
--   +++ OK, passed 100 tests
--   </pre>
--   
--   The options argument can be used to configure the emulator--setting
--   initial wallet balances, the maximum number of slots to run for, and
--   the log level for the emulator trace printed on failing tests:
--   
--   <pre>
--   options :: <tt>Map</tt> <a>Wallet</a> <a>Value</a> -&gt; <a>Slot</a> -&gt; <a>LogLevel</a> -&gt; <a>CheckOptions</a>
--   options dist slot logLevel =
--       <a>defaultCheckOptions</a> <a>&amp;</a> <a>emulatorConfig</a> . <a>initialChainState</a> <a>.~</a> <a>Left</a> dist
--                             <a>&amp;</a> <a>minLogLevel</a>                        <a>.~</a> logLevel
--   </pre>
propRunActionsWithOptions :: ContractModel state => CheckOptions -> CoverageOptions -> (ModelState state -> TracePredicate) -> Actions state -> Property

-- | Default check options that include a large amount of Ada in the
--   initial distributions to avoid having to write <a>ContractModel</a>s
--   that keep track of balances.
defaultCheckOptionsContractModel :: CheckOptions

-- | Check a threat model on all transactions produced by the given
--   actions.
checkThreatModel :: CheckableContractModel state => ThreatModel a -> Actions (WithInstances state) -> Property

-- | Check a threat model on all transactions produced by the given
--   actions.
checkThreatModelWithOptions :: CheckableContractModel state => CheckOptions -> CoverageOptions -> ThreatModel a -> Actions (WithInstances state) -> Property

-- | Turn a <a>DL</a> scenario into a QuickCheck property. Generates a
--   random <a>Actions</a> matching the scenario and feeds it to the given
--   property. The property can be a full property running the emulator and
--   checking the results, defined using <tt>propRunActions_</tt>,
--   <tt>propRunActions</tt>, or <tt>propRunActionsWithOptions</tt>.
--   Assuming a model for an auction contract and <a>DL</a> scenario that
--   checks that you can always complete the auction, you can write:
--   
--   <pre>
--   finishAuction :: <a>DL</a> AuctionState ()
--   prop_Auction  = <tt>propRunActions_</tt> handles
--     where handles = ...
--   prop_Finish = <a>forAllDL</a> finishAuction prop_Auction
--   </pre>
--   
--   However, there is also value in a property that does not run the
--   emulator at all:
--   
--   <pre>
--   prop_FinishModel = <a>forAllDL</a> finishAuction $ const True
--   </pre>
--   
--   This will check all the assertions and other failure conditions of the
--   <a>DL</a> scenario very quickly. Once this property passes a large
--   number of tests, you can run the full property checking that the model
--   agrees with reality.
forAllDL :: (ContractModel state, Testable p) => DL state () -> (Actions state -> p) -> Property
type NoLockedFundsProof state = NoLockedFundsProof (WrappedState state)
pattern NoLockedFundsProof :: () => DL (WithInstances model) () -> (Wallet -> DL (WithInstances model) ()) -> (ModelState (WithInstances model) -> SymValue) -> (ModelState (WithInstances model) -> SymValue) -> NoLockedFundsProof model

-- | Strategy to recover all funds from the contract in any reachable
--   state.
nlfpMainStrategy :: NoLockedFundsProof model -> DL (WithInstances model) ()

-- | A strategy for each wallet to recover as much (or more) funds as the
--   main strategy would give them in a given state, without the assistance
--   of any other wallet.
nlfpWalletStrategy :: NoLockedFundsProof model -> Wallet -> DL (WithInstances model) ()

-- | An initial amount of overhead value that may be lost - e.g. setup fees
--   for scripts that can't be recovered.
nlfpOverhead :: NoLockedFundsProof model -> ModelState (WithInstances model) -> SymValue

-- | The total amount of margin for error in the value collected by the
--   WalletStrategy compared to the MainStrategy. This is useful if your
--   contract contains rounding code that makes the order of operations
--   have a small but predictable effect on the value collected by
--   different wallets.
nlfpErrorMargin :: NoLockedFundsProof model -> ModelState (WithInstances model) -> SymValue

-- | The default skeleton of a NoLockedFundsProof - doesn't permit any
--   overhead or error margin.
defaultNLFP :: NoLockedFundsProof model

-- | Check a <a>NoLockedFundsProof</a>. Each test will generate an
--   arbitrary sequence of actions (<a>anyActions_</a>) and ask the
--   <a>nlfpMainStrategy</a> to recover all funds locked by the contract
--   after performing those actions. This results in some distribution of
--   the contract funds to the wallets, and the test then asks each
--   <a>nlfpWalletStrategy</a> to show how to recover their allotment of
--   funds without any assistance from the other wallets (assuming the main
--   strategy did not execute). When executing wallet strategies, the
--   off-chain instances for other wallets are killed and their private
--   keys are deleted from the emulator state.
checkNoLockedFundsProof :: CheckableContractModel model => NoLockedFundsProof model -> Property
checkNoLockedFundsProofFast :: CheckableContractModel model => NoLockedFundsProof model -> Property
type NoLockedFundsProofLight state = NoLockedFundsProofLight (WrappedState state)
pattern NoLockedFundsProofLight :: () => DL (WithInstances model) () -> NoLockedFundsProofLight model
nlfplMainStrategy :: NoLockedFundsProofLight model -> DL (WithInstances model) ()
checkNoLockedFundsProofLight :: CheckableContractModel model => NoLockedFundsProofLight model -> Property
checkNoLockedFundsProofWithOptions :: CheckableContractModel model => CheckOptions -> NoLockedFundsProof model -> Property
checkNoLockedFundsProofFastWithOptions :: CheckableContractModel model => CheckOptions -> NoLockedFundsProof model -> Property

-- | A whitelist entry tells you what final log entry prefixes are
--   acceptable for a given error
data Whitelist

-- | Check that a whitelist does not accept any partial functions
whitelistOk :: Whitelist -> Bool
mkWhitelist :: [Text] -> Whitelist
errorPrefixes :: Whitelist -> Set Text
defaultWhitelist :: Whitelist

-- | Check that running a contract model does not result in validation
--   failures that are not accepted by the whitelist.
checkErrorWhitelist :: ContractModel m => Whitelist -> Actions m -> Property

-- | Check that running a contract model does not result in validation
--   failures that are not accepted by the whitelist.
checkErrorWhitelistWithOptions :: forall m. ContractModel m => CheckOptions -> CoverageOptions -> Whitelist -> Actions m -> Property
newtype WithInstances s
WithInstances :: s -> WithInstances s
[withoutInstances] :: WithInstances s -> s
newtype WrappedState state
WrapState :: state -> WrappedState state
[unwrapState] :: WrappedState state -> state

-- | Perform a light-weight check to find egregious double satisfaction
--   vulnerabilities in contracts.
--   
--   A counterexample to this property consists of three transactions. *
--   The first transaction is a valid transaction from the trace generated
--   by the contract model. * The second transaction, generated by
--   redirecting a non-datum pubkey output from a non-signer to a signer in
--   the first transaction, fails to validate. This demonstrates that funds
--   can't simply be stolen. * The third transaction goes through and
--   manages to steal funds by altering the first transaction. It is
--   generated by adding another script input (with the same value as the
--   non-signer non-stealable pubkey output) and adding a datum to the
--   non-signer non-stealable pubkey output, and giving the extra value
--   from the new script input to a signer.
checkDoubleSatisfaction :: forall m. ContractModel m => Actions m -> Property

-- | Perform a light-weight check to find egregious double satisfaction
--   vulnerabilities in contracts, with options.
checkDoubleSatisfactionWithOptions :: forall m. ContractModel m => CheckOptions -> CoverageOptions -> Actions m -> Property

-- | Representable types of kind <tt>*</tt>. This class is derivable in GHC
--   with the <tt>DeriveGeneric</tt> flag on.
--   
--   A <a>Generic</a> instance must satisfy the following laws:
--   
--   <pre>
--   <a>from</a> . <a>to</a> ≡ <a>id</a>
--   <a>to</a> . <a>from</a> ≡ <a>id</a>
--   </pre>
class Generic a
fromAssetId :: AssetId -> AssetClass
toAssetId :: AssetClass -> AssetId
instance GHC.Show.Show state => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance GHC.Generics.Generic (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance GHC.Classes.Eq state => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance GHC.Classes.Ord state => GHC.Classes.Ord (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey state w s e p) => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Internal.ContractInstance.ContractInstanceKey (Plutus.Contract.Test.ContractModel.Interface.WrappedState state) w s e p)
instance GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey state w s e p) => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Internal.ContractInstance.ContractInstanceKey (Plutus.Contract.Test.ContractModel.Interface.WrappedState state) w s e p)
instance GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.Action state) => GHC.Classes.Eq (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Interface.WrappedState state))
instance GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.Action state) => GHC.Show.Show (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Interface.WrappedState state))
instance GHC.Generics.Generic (Test.QuickCheck.ContractModel.Internal.Model.Action (Plutus.Contract.Test.ContractModel.Interface.WrappedState state))
instance Test.QuickCheck.StateModel.Variables.HasVariables PlutusTx.Builtins.Internal.BuiltinByteString
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.SomeContractInstanceKey state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.SomeContractInstanceKey state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => Plutus.Contract.Test.ContractModel.Internal.ContractInstance.ContractInstanceModel (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => Test.QuickCheck.ContractModel.Internal.Model.ContractModel (Plutus.Contract.Test.ContractModel.Interface.WrappedState state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => Test.QuickCheck.ContractModel.Internal.RunModel (Plutus.Contract.Test.ContractModel.Interface.WrappedState state) (Plutus.Contract.Test.ContractModel.Internal.SpecificationEmulatorTrace (Plutus.Contract.Test.ContractModel.Interface.WrappedState state))
instance Test.QuickCheck.ContractModel.Internal.Symbolics.SymValueLike Plutus.V1.Ledger.Value.Value
instance Test.QuickCheck.ContractModel.Internal.Symbolics.TokenLike Plutus.V1.Ledger.Value.AssetClass
instance Test.QuickCheck.ContractModel.Internal.Symbolics.SymValueLike Plutus.Script.Utils.Ada.Ada
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics Wallet.Emulator.Wallet.Wallet
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics Plutus.V1.Ledger.Value.Value
instance Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics PlutusTx.Builtins.Internal.BuiltinByteString


-- | This module provides a framework for testing Plutus contracts built on
--   <a>Test.QuickCheck</a>. The testing is model based, so to test a
--   contract you define a type modelling the state of the contract (or set
--   of contracts) and provide an instance of the <a>ContractModel</a>
--   class. This instance specifies what operations (<a>Action</a>s) the
--   contract supports, how they interact with the model state, and how to
--   execute them in the blockchain emulator
--   (<a>Plutus.Trace.Emulator</a>). Tests are evaluated by running
--   sequences of actions (random or user-specified) in the emulator and
--   comparing the state of the blockchain to the model state at the end.
--   
--   Test cases are written in the <a>DL</a> monad, which supports mixing
--   fixed sequences of actions with random actions, making it easy to
--   write properties like <i>it is always possible to get all funds out of
--   the contract</i>.
module Plutus.Contract.Test.ContractModel

module Plutus.Contract.Test.ContractModel.CrashTolerance

-- | This derived state is used to derive a new <a>ContractModel</a> on top
--   of the <a>state</a> contract model that also specifies how the
--   contract(s) behave when contract instances crash and restart.
data WithCrashTolerance state
class ContractModel state => CrashTolerance state

-- | Specifiy what happens when a contract instance crashes
crash :: CrashTolerance state => SomeContractInstanceKey state -> Spec state ()

-- | Specify what happens when a contract instance is restarted
restart :: CrashTolerance state => SomeContractInstanceKey state -> Spec state ()

-- | Specify the arguments to give to a restarted contract
restartArguments :: CrashTolerance state => ModelState state -> ContractInstanceKey state w s e p -> p

-- | Check if an action is available given a list of alive contract
--   instances.
available :: CrashTolerance state => Action state -> [SomeContractInstanceKey state] -> Bool

-- | If your <a>ContractInstanceKey</a>s contain symbolic tokens or
--   symbolic variables you **MUST** implement this function.
contractInstanceVariables :: CrashTolerance state => ContractInstanceKey state w s e p -> Set (Any Var)
instance GHC.Generics.Generic (Plutus.Contract.Test.ContractModel.Interface.Action (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state))
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => GHC.Show.Show (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state)
instance (GHC.Classes.Eq state, Plutus.Contract.Test.ContractModel.Interface.ContractModel state) => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.Action (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state))
instance GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey state w s e p) => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state) w s e p)
instance GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey state w s e p) => GHC.Classes.Eq (Plutus.Contract.Test.ContractModel.Interface.ContractInstanceKey (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state) w s e p)
instance Plutus.Contract.Test.ContractModel.CrashTolerance.CrashTolerance state => Test.QuickCheck.StateModel.Variables.HasVariables (Plutus.Contract.Test.ContractModel.Interface.SomeContractInstanceKey state)
instance (Data.Typeable.Internal.Typeable state, Plutus.Contract.Test.ContractModel.CrashTolerance.CrashTolerance state) => Plutus.Contract.Test.ContractModel.Interface.ContractModel (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state)
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => GHC.Show.Show (Plutus.Contract.Test.ContractModel.Interface.Action (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state))
instance Plutus.Contract.Test.ContractModel.Interface.ContractModel state => Test.QuickCheck.ContractModel.Internal.Model.HasSymbolics (Plutus.Contract.Test.ContractModel.Interface.Action (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state))
instance GHC.Generics.Generic (Plutus.Contract.Test.ContractModel.CrashTolerance.WithCrashTolerance state)
