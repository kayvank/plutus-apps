<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">System.IO.Streams.Tutorial</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-2"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Introduction</span></span><span>
</span><span id="line-3"></span><span>    </span><span class="annot"><span class="hs-comment">-- $introduction</span></span><span>
</span><span id="line-4"></span><span>
</span><span id="line-5"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Build Input Streams</span></span><span>
</span><span id="line-6"></span><span>    </span><span class="annot"><span class="hs-comment">-- $createinput</span></span><span>
</span><span id="line-7"></span><span>
</span><span id="line-8"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Build Output Streams</span></span><span>
</span><span id="line-9"></span><span>    </span><span class="annot"><span class="hs-comment">-- $createoutput</span></span><span>
</span><span id="line-10"></span><span>
</span><span id="line-11"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Connect Streams</span></span><span>
</span><span id="line-12"></span><span>    </span><span class="annot"><span class="hs-comment">-- $connect</span></span><span>
</span><span id="line-13"></span><span>
</span><span id="line-14"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Transform Streams</span></span><span>
</span><span id="line-15"></span><span>    </span><span class="annot"><span class="hs-comment">-- $transform</span></span><span>
</span><span id="line-16"></span><span>
</span><span id="line-17"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Resource and Exception Safety</span></span><span>
</span><span id="line-18"></span><span>    </span><span class="annot"><span class="hs-comment">-- $safety</span></span><span>
</span><span id="line-19"></span><span>
</span><span id="line-20"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Pushback</span></span><span>
</span><span id="line-21"></span><span>    </span><span class="annot"><span class="hs-comment">-- $pushback</span></span><span>
</span><span id="line-22"></span><span>
</span><span id="line-23"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Thread Safety</span></span><span>
</span><span id="line-24"></span><span>    </span><span class="annot"><span class="hs-comment">-- $threadsafety</span></span><span>
</span><span id="line-25"></span><span>
</span><span id="line-26"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Examples</span></span><span>
</span><span id="line-27"></span><span>    </span><span class="annot"><span class="hs-comment">-- $examples</span></span><span>
</span><span id="line-28"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-29"></span><span>
</span><span id="line-30"></span><span class="hs-comment">{- $introduction

The @io-streams@ package defines two \&quot;smart handles\&quot; for stream processing:

  * 'System.IO.Streams.InputStream': a read-only smart handle

  * 'System.IO.Streams.OutputStream': a write-only smart handle

The 'System.IO.Streams.InputStream' type implements all the core operations we
expect for a read-only handle. We consume values using 'read', which returns a
'Nothing' when the resource is done:

@
'System.IO.Streams.read' :: 'System.IO.Streams.InputStream' c -&gt; 'IO' ('Maybe' c)
@

... and we can push back values using 'System.IO.Streams.unRead':

@
'System.IO.Streams.unRead' :: c -&gt; 'System.IO.Streams.InputStream' c -&gt; 'IO' ()
@

The 'System.IO.Streams.OutputStream' type implements the
'System.IO.Streams.write' operation which feeds it output, supplying 'Nothing'
to signal resource exhaustion:

@
'System.IO.Streams.write' :: 'Maybe' c -&gt; 'System.IO.Streams.OutputStream' c -&gt; 'IO' ()
@

These streams slightly resemble Haskell 'System.IO.Handle's, but support a
wider range of sources and sinks. For example, you can convert an ordinary list
to an 'System.IO.Streams.InputStream' source and interact with it using the
handle-based API:

@
ghci&gt; import qualified System.IO.Streams as S
ghci&gt; listHandle \&lt;- S.'System.IO.Streams.fromList' [1, 2]
ghci&gt; S.'System.IO.Streams.read' listHandle
Just 1
ghci&gt; S.'System.IO.Streams.read' listHandle
Just 2
ghci&gt; S.'System.IO.Streams.read' listHandle
Nothing
@

Additionally, IO streams come with a library of stream transformations that
preserve their handle-like API. For example, you can map a function over an
'System.IO.Streams.InputStream', which generates a new handle to the same
stream that returns transformed values:

@
ghci&gt; oldHandle \&lt;- S.'System.IO.Streams.List.fromList' [1, 2, 3]
ghci&gt; newHandle \&lt;- S.'System.IO.Streams.Combinators.mapM' (\\x -\&gt; 'return' (x * 10)) oldHandle
ghci&gt; S.'System.IO.Streams.read' newHandle
10
ghci&gt; -- We can still view the stream through the old handle
ghci&gt; S.'System.IO.Streams.read' oldHandle
2
ghci&gt; -- ... and switch back again
ghci&gt; S.'System.IO.Streams.read' newHandle
30
@

IO streams focus on preserving the convention of traditional handles while
offering a wider library of stream-processing utilities.

-}</span><span>
</span><span id="line-98"></span><span>
</span><span id="line-99"></span><span class="hs-comment">{- $createinput


The @io-streams@ library provides a simple interface for creating your own
'System.IO.Streams.InputStream's and 'System.IO.Streams.OutputStream's.

You can build an 'System.IO.Streams.InputStream' from any 'IO' action that
generates output, as long as it wraps results in 'Just' and uses 'Nothing' to
signal EOF:

@
'System.IO.Streams.makeInputStream' :: 'IO' ('Maybe' a) -&gt; 'IO' ('System.IO.Streams.InputStream' a)
@

As an example, let's wrap an ordinary read-only 'System.IO.Handle' in an
'System.IO.Streams.InputStream':

@
import &quot;Data.ByteString&quot; ('Data.ByteString.ByteString')
import qualified &quot;Data.ByteString&quot; as S
import &quot;System.IO.Streams&quot; ('System.IO.Streams.InputStream')
import qualified &quot;System.IO.Streams&quot; as Streams
import &quot;System.IO&quot; ('System.IO.Handle', 'System.IO.hFlush')

bUFSIZ = 32752

upgradeReadOnlyHandle :: 'System.IO.Handle' -&gt; 'IO' ('System.IO.Streams.InputStream' 'Data.ByteString.ByteString')
upgradeReadOnlyHandle h = Streams.'System.IO.Streams.makeInputStream' f
  where
    f = do
        x &lt;- S.'Data.ByteString.hGetSome' h bUFSIZ
        'return' $! if S.'Data.ByteString.null' x then 'Nothing' else 'Just' x
@

We didn't even really need to write the @upgradeReadOnlyHandle@ function,
because &quot;System.IO.Streams.Handle&quot; already provides one that uses the exact
same implementation given above:

@
'System.IO.Streams.handleToInputStream' :: 'System.IO.Handle' -&gt; 'IO' ('System.IO.Streams.InputStream' 'Data.ByteString.ByteString')
@

-}</span><span>
</span><span id="line-142"></span><span>
</span><span id="line-143"></span><span class="hs-comment">{- $createoutput

Similarly, you can build any 'System.IO.Streams.OutputStream' from an 'IO'
action that accepts input, as long as it interprets 'Just' as more input and
'Nothing' as EOF:

@
'System.IO.Streams.makeOutputStream' :: ('Maybe' a -&gt; 'IO' ()) -&gt; 'IO' ('System.IO.Streams.OutputStream' a)
@

A simple 'System.IO.Streams.OutputStream' might wrap 'putStrLn' for 'Data.ByteString.ByteString's:

@
import &quot;Data.ByteString&quot; ('Data.ByteString.ByteString')
import qualified &quot;Data.ByteString&quot; as S
import &quot;System.IO.Streams&quot; ('System.IO.Streams.OutputStream')
import qualified &quot;System.IO.Streams&quot; as Streams
\
writeConsole :: 'IO' ('System.IO.Streams.OutputStream' 'Data.ByteString.ByteString')
writeConsole = Streams.'System.IO.Streams.makeOutputStream' $ \\m -&gt; case m of
    'Just' bs -&gt; S.'Data.ByteString.putStrLn' bs
    'Nothing' -&gt; 'return' ()
@

The 'Just' wraps more incoming data, whereas 'Nothing' indicates the data is
exhausted. In principle, you can feed 'System.IO.Streams.OutputStream's more
input after writing a 'Nothing' to them, but IO streams only guarantee a
well-defined behavior up to the first 'Nothing'. After receiving the first
'Nothing', an 'System.IO.Streams.OutputStream' could respond to additional
input by:

  * Using the input

  * Ignoring the input

  * Throwing an exception

Ideally, you should adhere to well-defined behavior and ensure that after you
write a 'Nothing' to an 'System.IO.Streams.OutputStream', you don't write
anything else.

-}</span><span>
</span><span id="line-185"></span><span>
</span><span id="line-186"></span><span class="hs-comment">{- $connect

@io-streams@ provides two ways to connect an 'System.IO.Streams.InputStream'
and 'System.IO.Streams.OutputStream':

@
'System.IO.Streams.connect' :: 'System.IO.Streams.InputStream' a -&gt; 'System.IO.Streams.OutputStream' a -&gt; 'IO' ()
'System.IO.Streams.supply'  :: 'System.IO.Streams.InputStream' a -&gt; 'System.IO.Streams.OutputStream' a -&gt; 'IO' ()
@

'System.IO.Streams.connect' feeds the 'System.IO.Streams.OutputStream'
exclusively with the given 'System.IO.Streams.InputStream' and passes along the
end-of-stream notification to the 'System.IO.Streams.OutputStream'.

'System.IO.Streams.supply' feeds the 'System.IO.Streams.OutputStream'
non-exclusively with the given 'System.IO.Streams.InputStream' and does not
pass along the end-of-stream notification to the
'System.IO.Streams.OutputStream'.

You can combine both 'System.IO.Streams.supply' and 'System.IO.Streams.connect'
to feed multiple 'System.IO.Streams.InputStream's into a single
'System.IO.Streams.OutputStream':

@
import qualified &quot;System.IO.Streams&quot; as Streams
import &quot;System.IO&quot; ('System.IO.IOMode'('System.IO.WriteMode'))

main = do
   Streams.'System.IO.Streams.withFileAsOutput' \&quot;out.txt\&quot; 'System.IO.WriteMode' $ \\outStream -&gt;
   Streams.'System.IO.Streams.withFileAsInput'  \&quot;in1.txt\&quot; $ \\inStream1 -&gt;
   Streams.'System.IO.Streams.withFileAsInput'  \&quot;in2.txt\&quot; $ \\inStream2 -&gt;
   Streams.'System.IO.Streams.withFileAsInput'  \&quot;in3.txt\&quot; $ \\inStream3 -&gt;
   Streams.'System.IO.Streams.supply'  inStream1 outStream
   Streams.'System.IO.Streams.supply'  inStream2 outStream
   Streams.'System.IO.Streams.connect' inStream3 outStream
@

The final 'System.IO.Streams.connect' seals the
'System.IO.Streams.OutputStream' when the final 'System.IO.Streams.InputStream'
terminates.

Keep in mind that you do not need to use 'System.IO.Streams.connect' or
'System.IO.Streams.supply' at all: @io-streams@ mainly provides them for user
convenience. You can always build your own abstractions on top of the
'System.IO.Streams.read' and 'System.IO.Streams.write' operations.

-}</span><span>
</span><span id="line-233"></span><span>
</span><span id="line-234"></span><span class="hs-comment">{- $transform

When we build or use 'IO' streams we can tap into all the stream-processing
features the @io-streams@ library provides. For example, we can decompress any
'System.IO.Streams.InputStream' of 'Data.ByteString.ByteString's:

@
import &quot;Control.Monad&quot; ((&gt;=&gt;))
import &quot;Data.ByteString&quot; ('Data.ByteString.ByteString')
import &quot;System.IO&quot; ('System.IO.Handle')
import &quot;System.IO.Streams&quot; ('System.IO.Streams.InputStream', 'System.IO.Streams.OutputStream')
import qualified &quot;System.IO.Streams&quot; as Streams
import qualified &quot;System.IO.Streams.File&quot; as Streams

unzipHandle :: 'System.IO.Handle' -&gt; 'IO' ('System.IO.Streams.InputStream' 'Data.ByteString.ByteString')
unzipHandle = Streams.'System.IO.Streams.handleToInputStream' &gt;=&gt; Streams.'System.IO.Streams.decompress'
@

... or we can guard it against a denial-of-service attack:

@
protectHandle :: 'System.IO.Handle' -&gt; 'IO' ('System.IO.Streams.InputStream' 'Data.ByteString.ByteString')
protectHandle =
    Streams.'System.IO.Streams.handleToInputStream' &gt;=&gt; Streams.'System.IO.Streams.throwIfProducesMoreThan' 1000000
@

@io-streams@ provides many useful functions such as these in its standard
library and you take advantage of them by defining IO streams that wrap your
resources.

-}</span><span>
</span><span id="line-265"></span><span>
</span><span id="line-266"></span><span class="hs-comment">{- $safety

IO streams use standard Haskell idioms for resource safety. Since all
operations occur in the IO monad, you can use 'Control.Exception.catch',
'Control.Exception.bracket', or various \&quot;@with...@\&quot; functions to guard any
'System.IO.Streams.read' or 'System.IO.Streams.write' without any special
considerations:

@
import qualified &quot;Data.ByteString&quot; as S
import &quot;System.IO&quot;
import &quot;System.IO.Streams&quot; ('System.IO.Streams.InputStream', 'System.IO.Streams.OutputStream')
import qualified &quot;System.IO.Streams&quot; as Streams
import qualified &quot;System.IO.Streams.File&quot; as Streams

main =
    'System.IO.withFile' \&quot;test.txt\&quot; 'System.IO.ReadMode' $ \\handle -&gt; do
        stream &lt;- Streams.'System.IO.Streams.handleToInputStream' handle
        mBytes &lt;- Streams.'System.IO.Streams.read' stream
        case mBytes of
            'Just' bytes -&gt; S.'Data.ByteString.putStrLn' bytes
            'Nothing'    -&gt; 'System.IO.putStrLn' \&quot;EOF\&quot;
@

However, you can also simplify the above example by using the convenience
function 'System.IO.Streams.File.withFileAsInput' from
&quot;System.IO.Streams.File&quot;:

@
'System.IO.Streams.withFileAsInput'
 :: 'System.IO.FilePath' -&gt; ('System.IO.Streams.InputStream' 'Data.ByteString.ByteString' -&gt; 'IO' a) -&gt; 'IO' a
@

-}</span><span>
</span><span id="line-300"></span><span>
</span><span id="line-301"></span><span class="hs-comment">{- $pushback

All 'System.IO.Streams.InputStream's support pushback, which simplifies many
types of operations. For example, we can 'System.IO.Streams.peek' at an
'System.IO.Streams.InputStream' by combining 'System.IO.Streams.read' and
'System.IO.Streams.unRead':

@
'System.IO.Streams.peek' :: 'System.IO.Streams.InputStream' c -&gt; 'IO' ('Maybe' c)
'System.IO.Streams.peek' s = do
    x &lt;- Streams.'System.IO.Streams.read' s
    case x of
        'Nothing' -&gt; 'return' ()
        'Just' c  -&gt; Streams.'System.IO.Streams.unRead' c s
    'return' x
@

... although &quot;System.IO.Streams&quot; already exports the above function.

'System.IO.Streams.InputStream's can customize pushback behavior to support
more sophisticated support for pushback. For example, if you protect a stream
using 'System.IO.Streams.throwIfProducesMoreThan' and
'System.IO.Streams.unRead' input, it will subtract the unread input from the
total byte count. However, these extra features will not interfere with the
basic pushback contract, given by the following law:

@
'System.IO.Streams.unRead' c stream &gt;&gt; 'System.IO.Streams.read' stream == 'return' ('Just' c)
@

When you build an 'System.IO.Streams.InputStream' using
'System.IO.Streams.makeInputStream', it supplies the default pushback behavior
which just saves the input for the next 'System.IO.Streams.read' call. More
advanced users can use &quot;System.IO.Streams.Internal&quot; to customize their own
pushback routines.

{- NOTE: The library only exports pushback API for Sources, which are a
         completely internal type, so should we teach the user how to define
         custom pushback or not?  Maybe that belongs in some sort of separate
         &quot;advanced&quot; tutorial for System.IO.Streams.Internal. -}
-}</span><span>
</span><span id="line-342"></span><span>
</span><span id="line-343"></span><span class="hs-comment">{- $threadsafety

IO stream operations are not thread-safe by default for performance reasons.
However, you can transform an existing IO stream into a thread-safe one using
the provided locking functions:

@
'System.IO.Streams.lockingInputStream'  :: 'System.IO.Streams.InputStream'  a -&gt; 'IO' ('System.IO.Streams.InputStream'  a)
'System.IO.Streams.lockingOutputStream' :: 'System.IO.Streams.OutputStream' a -&gt; 'IO' ('System.IO.Streams.OutputStream' a)
@

These functions do not prevent access to the previous IO stream, so you must
take care to not save the reference to the previous stream.

    {- NOTE: Should I give specific performance numbers or just say something
             like &quot;a slight cost to performance&quot; for locking? -}
    {- NOTE: This could use a concrete example of a race condition that a user
             might encounter without this protection. -}
-}</span><span>
</span><span id="line-362"></span><span>
</span><span id="line-363"></span><span class="hs-comment">-- $examples</span><span>
</span><span id="line-364"></span><span class="hs-comment">-- The following examples show how to use the standard library to implement</span><span>
</span><span id="line-365"></span><span class="hs-comment">-- traditional command-line utilities:</span><span>
</span><span id="line-366"></span><span class="hs-comment">--</span><span>
</span><span id="line-367"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-368"></span><span class="hs-comment">--{-\# LANGUAGE OverloadedStrings #-}</span><span>
</span><span id="line-369"></span><span class="hs-comment">--</span><span>
</span><span id="line-370"></span><span class="hs-comment">--import Control.Monad ((&gt;=&gt;), join)</span><span>
</span><span id="line-371"></span><span class="hs-comment">--import qualified Data.ByteString.Char8 as S</span><span>
</span><span id="line-372"></span><span class="hs-comment">--import Data.Int (Int64)</span><span>
</span><span id="line-373"></span><span class="hs-comment">--import Data.Monoid ((\&lt;&gt;))</span><span>
</span><span id="line-374"></span><span class="hs-comment">--import &quot;System.IO.Streams&quot; ('System.IO.Streams.InputStream')</span><span>
</span><span id="line-375"></span><span class="hs-comment">--import qualified &quot;System.IO.Streams&quot; as Streams</span><span>
</span><span id="line-376"></span><span class="hs-comment">--import System.IO</span><span>
</span><span id="line-377"></span><span class="hs-comment">--import Prelude hiding (head)</span><span>
</span><span id="line-378"></span><span class="hs-comment">--</span><span>
</span><span id="line-379"></span><span class="hs-comment">--cat :: 'FilePath' -&gt; IO ()</span><span>
</span><span id="line-380"></span><span class="hs-comment">--cat file = 'System.IO.withFile' file ReadMode $ \\h -&gt; do</span><span>
</span><span id="line-381"></span><span class="hs-comment">--    is &lt;- Streams.'System.IO.Streams.handleToInputStream' h</span><span>
</span><span id="line-382"></span><span class="hs-comment">--    Streams.'System.IO.Streams.connect' is Streams.'System.IO.Streams.stdout'</span><span>
</span><span id="line-383"></span><span class="hs-comment">--</span><span>
</span><span id="line-384"></span><span class="hs-comment">--grep :: S.'Data.ByteString.ByteString' -&gt; 'FilePath' -&gt; IO ()</span><span>
</span><span id="line-385"></span><span class="hs-comment">--grep pattern file = 'System.IO.withFile' file ReadMode $ \\h -&gt; do</span><span>
</span><span id="line-386"></span><span class="hs-comment">--    is \&lt;- Streams.'System.IO.Streams.handleToInputStream' h &gt;&gt;=</span><span>
</span><span id="line-387"></span><span class="hs-comment">--          Streams.'System.IO.Streams.lines'                 &gt;&gt;=</span><span>
</span><span id="line-388"></span><span class="hs-comment">--          Streams.'System.IO.Streams.filter' (S.isInfixOf pattern)</span><span>
</span><span id="line-389"></span><span class="hs-comment">--    os &lt;- Streams.'System.IO.Streams.unlines' Streams.'System.IO.Streams.stdout'</span><span>
</span><span id="line-390"></span><span class="hs-comment">--    Streams.'System.IO.Streams.connect' is os</span><span>
</span><span id="line-391"></span><span class="hs-comment">--</span><span>
</span><span id="line-392"></span><span class="hs-comment">--data Option = Bytes | Words | Lines</span><span>
</span><span id="line-393"></span><span class="hs-comment">--</span><span>
</span><span id="line-394"></span><span class="hs-comment">--len :: 'System.IO.Streams.InputStream' a -&gt; IO Int64</span><span>
</span><span id="line-395"></span><span class="hs-comment">--len = Streams.'System.IO.Streams.fold' (\\n _ -&gt; n + 1) 0</span><span>
</span><span id="line-396"></span><span class="hs-comment">--</span><span>
</span><span id="line-397"></span><span class="hs-comment">--wc :: Option -&gt; 'FilePath' -&gt; IO ()</span><span>
</span><span id="line-398"></span><span class="hs-comment">--wc opt file = 'System.IO.withFile' file ReadMode $</span><span>
</span><span id="line-399"></span><span class="hs-comment">--    Streams.'System.IO.Streams.handleToInputStream' &gt;=&gt; count &gt;=&gt; print</span><span>
</span><span id="line-400"></span><span class="hs-comment">--  where</span><span>
</span><span id="line-401"></span><span class="hs-comment">--    count = case opt of</span><span>
</span><span id="line-402"></span><span class="hs-comment">--        Bytes -&gt; \\is -&gt; do</span><span>
</span><span id="line-403"></span><span class="hs-comment">--            (is', cnt) &lt;- Streams.'System.IO.Streams.countInput' is</span><span>
</span><span id="line-404"></span><span class="hs-comment">--            Streams.'System.IO.Streams.skipToEof' is'</span><span>
</span><span id="line-405"></span><span class="hs-comment">--            cnt</span><span>
</span><span id="line-406"></span><span class="hs-comment">--        Words -&gt; Streams.'System.IO.Streams.words' &gt;=&gt; len</span><span>
</span><span id="line-407"></span><span class="hs-comment">--        Lines -&gt; Streams.'System.IO.STreams.lines' &gt;=&gt; len</span><span>
</span><span id="line-408"></span><span class="hs-comment">--</span><span>
</span><span id="line-409"></span><span class="hs-comment">--nl :: 'FilePath' -&gt; IO ()</span><span>
</span><span id="line-410"></span><span class="hs-comment">--nl file = 'System.IO.withFile' file ReadMode $ \\h -&gt; do</span><span>
</span><span id="line-411"></span><span class="hs-comment">--    nats &lt;- Streams.'System.IO.Streams.fromList' [1..]</span><span>
</span><span id="line-412"></span><span class="hs-comment">--    ls   \&lt;- Streams.'System.IO.Streams.handleToInputStream' h &gt;&gt;= Streams.'System.IO.Streams.lines'</span><span>
</span><span id="line-413"></span><span class="hs-comment">--    is   &lt;- Streams.'System.IO.Streams.zipWith'</span><span>
</span><span id="line-414"></span><span class="hs-comment">--                (\\n bs -&gt; S.pack (show n) \&lt;&gt; \&quot; \&quot; \&lt;&gt; bs)</span><span>
</span><span id="line-415"></span><span class="hs-comment">--                nats</span><span>
</span><span id="line-416"></span><span class="hs-comment">--                ls</span><span>
</span><span id="line-417"></span><span class="hs-comment">--    os   &lt;- Streams.'System.IO.Streams.unlines' Streams.'System.IO.Streams.stdout'</span><span>
</span><span id="line-418"></span><span class="hs-comment">--    Streams.'System.IO.Streams.connect' is os</span><span>
</span><span id="line-419"></span><span class="hs-comment">--</span><span>
</span><span id="line-420"></span><span class="hs-comment">--head :: Int64 -&gt; 'FilePath' -&gt; IO ()</span><span>
</span><span id="line-421"></span><span class="hs-comment">--head n file = 'System.IO.withFile' file ReadMode $ \\h -&gt; do</span><span>
</span><span id="line-422"></span><span class="hs-comment">--    is \&lt;- Streams.'System.IO.Streams.handleToInputStream' h &gt;&gt;= Streams.'System.IO.Streams.lines' &gt;&gt;= Streams.'System.IO.Streams.take' n</span><span>
</span><span id="line-423"></span><span class="hs-comment">--    os &lt;- Streams.'System.IO.Streams.unlines' Streams.'System.IO.Streams.stdout'</span><span>
</span><span id="line-424"></span><span class="hs-comment">--    Streams.'System.IO.Streams.connect' is os</span><span>
</span><span id="line-425"></span><span class="hs-comment">--</span><span>
</span><span id="line-426"></span><span class="hs-comment">--paste :: 'FilePath' -&gt; 'FilePath' -&gt; IO ()</span><span>
</span><span id="line-427"></span><span class="hs-comment">--paste file1 file2 =</span><span>
</span><span id="line-428"></span><span class="hs-comment">--    'System.IO.withFile' file1 ReadMode $ \\h1 -&gt;</span><span>
</span><span id="line-429"></span><span class="hs-comment">--    'System.IO.withFile' file2 ReadMode $ \\h2 -&gt; do</span><span>
</span><span id="line-430"></span><span class="hs-comment">--    is1 \&lt;- Streams.'System.IO.Streams.handleToInputStream' h1 &gt;&gt;= Streams.'System.IO.Streams.lines'</span><span>
</span><span id="line-431"></span><span class="hs-comment">--    is2 \&lt;- Streams.'System.IO.Streams.handleToInputStream' h2 &gt;&gt;= Streams.'System.IO.Streams.lines'</span><span>
</span><span id="line-432"></span><span class="hs-comment">--    isT \&lt;- Streams.'System.IO.Streams.zipWith' (\\l1 l2 -&gt; l1 \&lt;&gt; \&quot;\\t\&quot; \&lt;&gt; l2) is1 is2</span><span>
</span><span id="line-433"></span><span class="hs-comment">--    os  &lt;- Streams.'System.IO.Streams.unlines' Streams.'System.IO.Streams.stdout'</span><span>
</span><span id="line-434"></span><span class="hs-comment">--    Streams.connect isT os</span><span>
</span><span id="line-435"></span><span class="hs-comment">--</span><span>
</span><span id="line-436"></span><span class="hs-comment">--yes :: IO ()</span><span>
</span><span id="line-437"></span><span class="hs-comment">--yes = do</span><span>
</span><span id="line-438"></span><span class="hs-comment">--    is &lt;- Streams.fromList (repeat \&quot;y\&quot;)</span><span>
</span><span id="line-439"></span><span class="hs-comment">--    os &lt;- Streams.unlines Streams.stdout</span><span>
</span><span id="line-440"></span><span class="hs-comment">--    Streams.connect is os</span><span>
</span><span id="line-441"></span><span class="hs-comment">-- @</span><span>
</span><span id="line-442"></span></pre></body></html>