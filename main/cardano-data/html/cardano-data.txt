-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Specialized data for Cardano project
--   
--   Specialized data for Cardano project
@package cardano-data
@version 0.1.0.0


-- | An approach to computing the abstract size of data using
--   <a>TypeRep</a>.
module Data.AbstractSize

-- | The <a>typeReps</a> function retrieves all the type representations
--   found while traversing the data given as parameter.
--   
--   CAUTION: for newtypes, do not use 'deriving newtype (HasTypeReps)' to
--   derive instances, rather use 'deriving anyclass (HasTypeReps)'. This
--   is because we use these instances in <a>abstractSize</a>, and for that
--   we prefer to have the newtype wrapper type available for "costing".
--   The difference between 'newtype' and <tt>anyclass</tt> instances is as
--   follows:
--   
--   newtype Hash = Hash { unHash :: Int } deriving newtype (...,
--   HasTypeReps) &gt; typeReps someHash = Seq.fromList [Int] vs newtype
--   Hash = Hash { unHash :: Int } deriving stock (...,Generics); deriving
--   anyclass (HasTypeReps) &gt; typeReps someHash = Seq.fromList [Hash,
--   Int]
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; typeReps "a"
--   fromList [[Char],Char]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeReps "ab"
--   fromList [[Char],Char,Char]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; typeReps ([] :: [Int])
--   fromList [[Int]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric
--   
--   &gt;&gt;&gt; import GHC.Generics (Generic)
--   
--   &gt;&gt;&gt; data Foo = Foo [Int] (Char, Char) deriving (Generic)
--   
--   &gt;&gt;&gt; instance HasTypeReps Foo
--   
--   &gt;&gt;&gt; typeReps $ Foo [1, 2] ('a', 'b')
--   fromList [Foo,[Int],Int,Int,(Char,Char),Char,Char]
--   </pre>
class HasTypeReps a
typeReps :: HasTypeReps a => a -> Seq TypeRep

-- | <tt>abstractSize m a</tt> computes the abstract size of <tt>a</tt>,
--   using the accounting map <tt>m</tt>. The map <tt>m</tt> determines the
--   abstract size of each <a>TypeRep</a> contained in <tt>a</tt>, and this
--   function simply adds all the individual abstract sizes. To be able to
--   extract the type representations (<a>TypeRep</a>s) inside <tt>a</tt>,
--   we require it to be an instance of <a>HasTypeReps</a>.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedLists
--   
--   &gt;&gt;&gt; import Data.Typeable (typeOf)
--   
--   &gt;&gt;&gt; abstractSize [(typeOf (undefined:: Char), 10)] 'a'
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; abstractSize [(typeOf 'x', 10)] "hello"
--   50
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; abstractSize [(typeOf 'x', 10), (typeOf True, 100)] ("hello", False)
--   150
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; abstractSize [(typeOf (undefined :: [Int]), 6), (typeOf (1 :: Int), 1)] ([0, 1, 2, 3] :: [Int])
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; abstractSize [(typeOf (undefined :: [Int]), 3), (typeOf (1 :: Int), -1)] ([0, 1, 2] :: [Int])
--   0
--   </pre>
abstractSize :: HasTypeReps a => AccountingMap -> a -> Size
type AccountingMap = Map TypeRep Size
type Size = Int
instance Data.AbstractSize.HasTypeReps a => Data.AbstractSize.GHasTypeReps (GHC.Generics.K1 i a)
instance (Data.Typeable.Internal.Typeable a, Data.AbstractSize.HasTypeReps a) => Data.AbstractSize.HasTypeReps (GHC.Maybe.Maybe a)
instance (Data.Typeable.Internal.Typeable a, Data.AbstractSize.HasTypeReps a) => Data.AbstractSize.HasTypeReps [a]
instance (Data.Typeable.Internal.Typeable a, Data.AbstractSize.HasTypeReps a) => Data.AbstractSize.HasTypeReps (Data.Set.Internal.Set a)
instance (Data.Typeable.Internal.Typeable a, Data.Typeable.Internal.Typeable b, Data.AbstractSize.HasTypeReps a, Data.AbstractSize.HasTypeReps b) => Data.AbstractSize.HasTypeReps (a, b)
instance Data.AbstractSize.HasTypeReps GHC.Types.Bool
instance Data.AbstractSize.HasTypeReps GHC.Types.Char
instance Data.AbstractSize.HasTypeReps GHC.Types.Int
instance Data.AbstractSize.HasTypeReps GHC.Integer.Type.Integer
instance Data.AbstractSize.HasTypeReps GHC.Types.Double
instance Data.AbstractSize.HasTypeReps GHC.Natural.Natural
instance Data.AbstractSize.HasTypeReps GHC.Types.Word
instance Data.AbstractSize.HasTypeReps GHC.Word.Word8
instance Data.AbstractSize.HasTypeReps GHC.Word.Word16
instance Data.AbstractSize.HasTypeReps GHC.Word.Word32
instance Data.AbstractSize.HasTypeReps GHC.Word.Word64
instance Data.AbstractSize.HasTypeReps (Crypto.Hash.Types.Digest Crypto.Hash.SHA256.SHA256)
instance Data.AbstractSize.HasTypeReps Cardano.Crypto.Hash.Short.ShortHash
instance Data.Typeable.Internal.Typeable a => Data.AbstractSize.HasTypeReps (Cardano.Crypto.Hash.Class.Hash Cardano.Crypto.Hash.Short.ShortHash a)
instance Data.AbstractSize.HasTypeReps (Cardano.Crypto.DSIGN.Class.SignedDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN a)
instance Data.AbstractSize.HasTypeReps (Cardano.Crypto.DSIGN.Class.VerKeyDSIGN Cardano.Crypto.DSIGN.Mock.MockDSIGN)
instance Data.AbstractSize.GHasTypeReps GHC.Generics.U1
instance (Data.AbstractSize.GHasTypeReps a, Data.AbstractSize.GHasTypeReps b) => Data.AbstractSize.GHasTypeReps (a GHC.Generics.:*: b)
instance (Data.AbstractSize.GHasTypeReps a, Data.AbstractSize.GHasTypeReps b) => Data.AbstractSize.GHasTypeReps (a GHC.Generics.:+: b)
instance Data.AbstractSize.GHasTypeReps a => Data.AbstractSize.GHasTypeReps (GHC.Generics.M1 i c a)

module Data.CanonicalMaps
class Eq t => CanonicalZero t
zeroC :: CanonicalZero t => t
joinC :: CanonicalZero t => t -> t -> t
canonicalInsert :: (Ord k, CanonicalZero a) => (a -> a -> a) -> k -> a -> Map k a -> Map k a
canonicalMapUnion :: (Ord k, CanonicalZero a) => (a -> a -> a) -> Map k a -> Map k a -> Map k a
canonicalMap :: (Ord k, CanonicalZero a) => (a -> a) -> Map k a -> Map k a
pointWise :: (Ord k, CanonicalZero v) => (v -> v -> Bool) -> Map k v -> Map k v -> Bool

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
--   
--   The <a>Semigroup</a> operation for <a>Map</a> is <a>union</a>, which
--   prefers values from the left operand. If <tt>m1</tt> maps a key
--   <tt>k</tt> to a value <tt>a1</tt>, and <tt>m2</tt> maps the same key
--   to a different value <tt>a2</tt>, then their union <tt>m1 &lt;&gt;
--   m2</tt> maps <tt>k</tt> to <tt>a1</tt>.
data Map k a
instance Data.CanonicalMaps.CanonicalZero GHC.Integer.Type.Integer
instance (GHC.Classes.Eq k, GHC.Classes.Eq v, GHC.Classes.Ord k, Data.CanonicalMaps.CanonicalZero v) => Data.CanonicalMaps.CanonicalZero (Data.Map.Internal.Map k v)


-- | MemoBytes is an abstration for a datetype that encodes its own
--   seriialization. The idea is to use a newtype around a MemoBytes
--   non-memoizing version. For example: newtype Foo = Foo(MemoBytes
--   NonMemoizingFoo) This way all the instances for Foo
--   (Eq,Show,Ord,ToCBOR,FromCBOR,NoThunks,Generic) can be derived for
--   free.
module Data.Coders
data Encode (w :: Wrapped) t
[Rec] :: t -> Encode ('Closed 'Dense) t
[Sum] :: t -> Word -> Encode 'Open t
[Keyed] :: t -> Encode ('Closed 'Sparse) t
[To] :: ToCBOR a => a -> Encode ('Closed 'Dense) a
[E] :: (t -> Encoding) -> t -> Encode ('Closed 'Dense) t
[MapE] :: (a -> b) -> Encode w a -> Encode w b
[ED] :: Dual t -> t -> Encode ('Closed 'Dense) t
[OmitC] :: t -> Encode w t
[Tag] :: Word -> Encode ('Closed x) t -> Encode ('Closed x) t
[Omit] :: (t -> Bool) -> Encode ('Closed 'Sparse) t -> Encode ('Closed 'Sparse) t
[Key] :: Word -> Encode ('Closed 'Dense) t -> Encode ('Closed 'Sparse) t
[ApplyE] :: Encode w (a -> t) -> Encode ('Closed r) a -> Encode w t
data Decode (w :: Wrapped) t
[Summands] :: String -> (Word -> Decode 'Open t) -> Decode ('Closed 'Dense) t
[SparseKeyed] :: Typeable t => String -> t -> (Word -> Field t) -> [(Word, String)] -> Decode ('Closed 'Dense) t
[SumD] :: t -> Decode 'Open t
[RecD] :: t -> Decode ('Closed 'Dense) t
[KeyedD] :: t -> Decode ('Closed 'Sparse) t
[From] :: FromCBOR t => Decode w t
[D] :: (forall s. Decoder s t) -> Decode ('Closed 'Dense) t
[ApplyD] :: Decode w1 (a -> t) -> Decode ('Closed d) a -> Decode w1 t
[Invalid] :: Word -> Decode w t
[Map] :: (a -> b) -> Decode w a -> Decode w b
[DD] :: Dual t -> Decode ('Closed 'Dense) t
[TagD] :: Word -> Decode ('Closed x) t -> Decode ('Closed x) t
[Emit] :: t -> Decode w t
[Ann] :: Decode w t -> Decode w (Annotator t)
[ApplyAnn] :: Decode w1 (Annotator (a -> t)) -> Decode ('Closed d) (Annotator a) -> Decode w1 (Annotator t)
[ApplyErr] :: Decode w1 (a -> Either String t) -> Decode ('Closed d) a -> Decode w1 t
(!>) :: Encode w (a -> t) -> Encode ('Closed r) a -> Encode w t
infixl 4 !>
(<!) :: Decode w1 (a -> t) -> Decode ('Closed w) a -> Decode w1 t
infixl 4 <!
(<*!) :: Decode w1 (Annotator (a -> t)) -> Decode ('Closed d) (Annotator a) -> Decode w1 (Annotator t)
infixl 4 <*!
(<?) :: Decode w1 (a -> Either String t) -> Decode ('Closed d) a -> Decode w1 t
infixl 4 <?

-- | Some CBOR instances wrap encoding sequences with prefixes and
--   suffixes. I.e. prefix , encode, encode, encode , ... , suffix. There
--   are two kinds of wrapping coders: Nary sums, and Sparsely encoded
--   products. Coders in these classes can only be decoded when they are
--   wrapped by their closing forms Summand and SparseKeyed. In another
--   dimension records can be encoded densely (all their fields serialised)
--   or sparsely (only some of their fields). We use indexes to types to
--   try and mark (and enforce) these distinctions.
--   
--   Record density (all the fields) vs (some of the fields)
data Density
Dense :: Density
Sparse :: Density
data Wrapped
[Open] :: Wrapped
[Closed] :: Density -> Wrapped

-- | A value of type `Annotator a` is one that needs access to the entire |
--   bytestring used during decoding to finish construction.
newtype Annotator a
Annotator :: (FullByteString -> a) -> Annotator a
[runAnnotator] :: Annotator a -> FullByteString -> a

-- | Analogous to paired ToCBOR and FromCBOR instances with out freezing
--   out alternate ways to code. Unlike ToCBOR and FromCBOR where there is
--   only one instance per type. There can be multiple Duals with the same
--   type.
data Dual t
Dual :: (t -> Encoding) -> (forall s. Decoder s t) -> Dual t

-- | A Field pairs an update function and a decoder for one field of a
--   Sparse record.
data Field t
[Field] :: (x -> t -> t) -> (forall s. Decoder s x) -> Field t
ofield :: (StrictMaybe x -> t -> t) -> Decode ('Closed d) x -> Field t
invalidField :: forall t. Word -> Field t
field :: (x -> t -> t) -> Decode ('Closed d) x -> Field t
fieldA :: Applicative ann => (x -> t -> t) -> Decode ('Closed d) x -> Field (ann t)
fieldAA :: Applicative ann => (x -> t -> t) -> Decode ('Closed d) (ann x) -> Field (ann t)
encode :: Encode w t -> Encoding
decode :: Decode w t -> Decoder s t
runE :: Encode w t -> t
decodeList :: Decoder s a -> Decoder s [a]
decodePair :: Decoder s a -> Decoder s b -> Decoder s (a, b)
decodeSeq :: Decoder s a -> Decoder s (Seq a)
decodeStrictSeq :: Decoder s a -> Decoder s (StrictSeq a)
decodeSet :: Ord a => Decoder s a -> Decoder s (Set a)
decodeAnnSet :: Ord t => Decoder s (Annotator t) -> Decoder s (Annotator (Set t))
decodeRecordNamed :: Text -> (a -> Int) -> Decoder s a -> Decoder s a
decodeRecordNamedT :: (MonadTrans m, Monad (m (Decoder s))) => Text -> (a -> Int) -> m (Decoder s) a -> m (Decoder s) a
decodeRecordSum :: String -> (Word -> Decoder s (Int, a)) -> Decoder s a
invalidKey :: Word -> Decoder s a
unusedRequiredKeys :: Set Word -> [(Word, String)] -> String -> Decoder s a
duplicateKey :: String -> Word -> Decoder s a
wrapCBORArray :: Word -> Encoding -> Encoding
encodePair :: (a -> Encoding) -> (b -> Encoding) -> (a, b) -> Encoding
encodeFoldable :: (ToCBOR a, Foldable f) => f a -> Encoding
encodeFoldableAsDefinite :: (ToCBOR a, Foldable f) => f a -> Encoding
encodeFoldableAsIndefinite :: (ToCBOR a, Foldable f) => f a -> Encoding
encodeFoldableMapPairs :: (ToCBOR a, ToCBOR b, Foldable f) => f (a, b) -> Encoding
decodeCollectionWithLen :: Decoder s (Maybe Int) -> Decoder s a -> Decoder s (Int, [a])
decodeCollection :: Decoder s (Maybe Int) -> Decoder s a -> Decoder s [a]
encodeFoldableEncoder :: Foldable f => (a -> Encoding) -> f a -> Encoding
encodeMap :: (a -> Encoding) -> (b -> Encoding) -> Map a b -> Encoding
encodeVMap :: (Vector vk k, Vector vv v) => (k -> Encoding) -> (v -> Encoding) -> VMap vk vv k v -> Encoding
wrapCBORMap :: Word -> Encoding -> Encoding
decodeMap :: Ord a => Decoder s a -> Decoder s b -> Decoder s (Map a b)
decodeVMap :: (Vector kv k, Vector vv v, Ord k) => Decoder s k -> Decoder s v -> Decoder s (VMap kv vv k v)

-- | Just like <a>decodeMap</a>, but assumes there are no duplicate keys
decodeMapNoDuplicates :: Ord a => Decoder s a -> Decoder s b -> Decoder s (Map a b)
decodeMapByKey :: (IsList t, Item t ~ (k, v)) => Decoder s k -> (k -> Decoder s v) -> Decoder s t
decodeMapContents :: Decoder s a -> Decoder s [a]
decodeMapTraverse :: (Ord a, Applicative t) => Decoder s (t a) -> Decoder s (t b) -> Decoder s (t (Map a b))
decodeMapContentsTraverse :: Applicative t => Decoder s (t a) -> Decoder s (t b) -> Decoder s (t [(a, b)])
dualList :: (ToCBOR a, FromCBOR a) => Dual [a]
dualSeq :: (ToCBOR a, FromCBOR a) => Dual (Seq a)
dualSet :: (Ord a, ToCBOR a, FromCBOR a) => Dual (Set a)

-- | Good for encoding (Maybe t) if is another Maybe. Uses more space than
--   dualMaybeAsNull
dualMaybeAsList :: (ToCBOR a, FromCBOR a) => Dual (Maybe a)

-- | Good for encoding (Maybe T) as long as T isn't another Maybe
dualMaybeAsNull :: (ToCBOR a, FromCBOR a) => Dual (Maybe a)
dualText :: Dual Text
dualStrictSeq :: (ToCBOR a, FromCBOR a) => Dual (StrictSeq a)
dualCBOR :: (ToCBOR a, FromCBOR a) => Dual a
to :: (ToCBOR t, FromCBOR t) => t -> Encode ('Closed 'Dense) t
from :: (ToCBOR t, FromCBOR t) => Decode ('Closed 'Dense) t

-- | A continuation-based decoder, used for decoding values that were
--   previously encoded using the <a>Codec.CBOR.Encoding</a> module. As
--   <a>Decoder</a> has a <a>Monad</a> instance, you can easily write
--   <a>Decoder</a>s monadically for building your deserialisation logic.
data Decoder s a

-- | An intermediate form used during serialisation, specified as a
--   <a>Monoid</a>. It supports efficient concatenation, and is equivalent
--   to a specialised <a>Endo</a> <a>Tokens</a> type.
--   
--   It is used for the stage in serialisation where we flatten out the
--   Haskell data structure but it is independent of any specific external
--   binary or text format.
--   
--   Traditionally, to build any arbitrary <a>Encoding</a> value, you
--   specify larger structures from smaller ones and append the small ones
--   together using <a>mconcat</a>.
data Encoding
encodeNullMaybe :: (a -> Encoding) -> Maybe a -> Encoding
encodeKeyedStrictMaybeWith :: Word -> (a -> Encoding) -> StrictMaybe a -> Encode ('Closed 'Sparse) (StrictMaybe a)
encodeKeyedStrictMaybe :: ToCBOR a => Word -> StrictMaybe a -> Encode ('Closed 'Sparse) (StrictMaybe a)
decodeNullMaybe :: Decoder s a -> Decoder s (Maybe a)
decodeSparse :: Typeable a => String -> a -> (Word -> Field a) -> [(Word, String)] -> Decoder s a

-- | (mapEncode x) is self-documenting, correct way to encode Map. use
--   mapDecode as its dual
mapEncode :: (ToCBOR k, ToCBOR v) => Map k v -> Encode ('Closed 'Dense) (Map k v)

-- | (mapDecode) is the Dual for (mapEncode x)
mapDecode :: (Ord k, FromCBOR k, FromCBOR v) => Decode ('Closed 'Dense) (Map k v)
mapDecodeA :: Ord k => Decode ('Closed 'Dense) (Annotator k) -> Decode ('Closed 'Dense) (Annotator v) -> Decode ('Closed 'Dense) (Annotator (Map k v))

-- | (vMapEncode x) is self-documenting, correct way to encode VMap. use
--   vMapDecode as its dual
vMapEncode :: (Vector kv k, Vector vv v, ToCBOR k, ToCBOR v) => VMap kv vv k v -> Encode ('Closed 'Dense) (VMap kv vv k v)

-- | (vMapDecode) is the Dual for (vMapEncode x)
vMapDecode :: (Vector kv k, Vector vv v, Ord k, FromCBOR k, FromCBOR v) => Decode ('Closed 'Dense) (VMap kv vv k v)

-- | (setEncode x) is self-documenting (E encodeFoldable x), use setDecode
--   as its dual
setEncode :: ToCBOR v => Set v -> Encode ('Closed 'Dense) (Set v)

-- | (setDecode) is the Dual for (setEncode x)
setDecode :: (Ord v, FromCBOR v) => Decode ('Closed 'Dense) (Set v)
setDecodeA :: Ord x => Decode ('Closed 'Dense) (Annotator x) -> Decode ('Closed 'Dense) (Annotator (Set x))

-- | (listEncode x) is self-documenting (E encodeFoldable x), use
--   listDecode as its dual
listEncode :: ToCBOR v => [v] -> Encode ('Closed 'Dense) [v]

-- | (listDecode) is the Dual for (listEncode x)
listDecode :: FromCBOR v => Decode ('Closed 'Dense) [v]
listDecodeA :: Decode ('Closed 'Dense) (Annotator x) -> Decode ('Closed 'Dense) (Annotator [x])
pairDecodeA :: Decode ('Closed 'Dense) (Annotator x) -> Decode ('Closed 'Dense) (Annotator y) -> Decode ('Closed 'Dense) (Annotator (x, y))

-- | Convert a <tt>Buildable</tt> error into a <tt>cborg</tt> decoder error
cborError :: Buildable e => e -> Decoder s a
instance GHC.Base.Functor (Data.Coders.Decode w)
instance GHC.Base.Applicative (Data.Coders.Decode ('Data.Coders.Closed d))

module Data.BiMap
data BiMap v a b
[MkBiMap] :: v ~ b => !Map a b -> !Map b (Set a) -> BiMap v a b
biMapToMap :: BiMap v a b -> Map a b
biMapFromMap :: (Ord k, Ord v) => Map k v -> BiMap v k v

-- | Decode a serialised CBOR Map as a Bimap
decodeMapAsBimap :: (FromCBOR a, FromCBOR b, Ord a, Ord b) => Decoder s (BiMap b a b)
addBack :: (Ord v, Ord k) => v -> k -> Map v (Set k) -> Map v (Set k)
retract :: (Ord v, Ord k) => v -> k -> Map v (Set k) -> Map v (Set k)
insertBackwards :: (Ord k, Ord v) => v -> v -> k -> Map v (Set k) -> Map v (Set k)
insertWithBiMap :: (Ord k, Ord v) => (v -> v -> v) -> k -> v -> BiMap v k v -> BiMap v k v
biMapEmpty :: BiMap v k v
biMapFromList :: (Ord k, Ord v) => (v -> v -> v) -> [(k, v)] -> BiMap v k v
mapflip :: (v -> v -> v) -> v -> v -> v

-- | <i>Warning</i> - invariant that keys are distinct and in ascending
--   order is not checked. Make sure it is not violated, otherwise crazy
--   things will happen.
biMapFromAscDistinctList :: (Ord k, Ord v) => [(k, v)] -> BiMap v k v
type Bimap k v = BiMap v k v
removeval :: (Ord k, Ord v) => v -> BiMap v k v -> BiMap v k v
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, Cardano.Binary.ToCBOR.ToCBOR a, Cardano.Binary.ToCBOR.ToCBOR b) => Cardano.Binary.ToCBOR.ToCBOR (Data.BiMap.BiMap b a b)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, Cardano.Binary.FromCBOR.FromCBOR a, Cardano.Binary.FromCBOR.FromCBOR b) => Cardano.Binary.FromCBOR.FromCBOR (Data.BiMap.BiMap b a b)
instance (NoThunks.Class.NoThunks a, NoThunks.Class.NoThunks b) => NoThunks.Class.NoThunks (Data.BiMap.BiMap v a b)
instance Control.DeepSeq.NFData (Data.BiMap.BiMap v a b)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.BiMap.BiMap u k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Data.BiMap.BiMap u k v)


-- | Sometimes we need to write our own version of functions over
--   <a>Map</a> that do not appear in the "containers" library. This module
--   is for such functions.
--   
--   For example:
--   
--   <ol>
--   <li>Version of <a>withoutKeys</a> where both arguments are
--   <a>Map</a></li>
--   <li>Comparing that two maps have exactly the same set of keys</li>
--   <li>The intersection of two maps guarded by a predicate.</li>
--   </ol>
--   
--   <pre>
--   ((dom stkcred) ◁ deleg) ▷ (dom stpool)) ==&gt;
--   intersectDomP (\ k v -&gt; Map.member v stpool) stkcred deleg
--   </pre>
module Data.MapExtras
data StrictTriple a b c
StrictTriple :: !a -> !b -> !c -> StrictTriple a b c

-- | Just like <a>delete</a>, but also returns the value if it was indeed
--   deleted from the map.
extract :: Ord k => k -> Map k b -> (Maybe b, Map k b)
noKeys :: Ord k => Map k a -> Map k b -> Map k a
keysEqual :: Ord k => Map k v1 -> Map k v2 -> Bool

-- | A variant of <tt>splitLookup</tt> that indicates only whether the key
--   was present, rather than producing its value. This is used to
--   implement <a>keysEqual</a> to avoid allocating unnecessary <a>Just</a>
--   constructors.
--   
--   <i>Note</i> - this is a copy pasted internal function from
--   "containers" package adjusted to return <a>StrictTriple</a>
splitMemberMap :: Ord k => k -> Map k a -> StrictTriple (Map k a) Bool (Map k a)

-- | <i>O(log n)</i>. Performs a <tt>split</tt> but also returns whether
--   the pivot element was found in the original set.
--   
--   This is a modified version of <a>splitMember</a>, where
--   <a>StrictTriple</a> is used instead of a lazy one for minor
--   performance gain.
splitMemberSet :: Ord a => a -> Set a -> StrictTriple (Set a) Bool (Set a)

-- | intersetDomP p m1 m2 == Keep the key and value from m2, iff (the key
--   is in the dom of m1) &amp;&amp; ((p key value) is true)
intersectDomP :: Ord k => (k -> v2 -> Bool) -> Map k v1 -> Map k v2 -> Map k v2

-- | <ul>
--   <li>Similar to intersectDomP, except the Map returned has the same key
--   as the first input map, rather than the second input map.</li>
--   </ul>
intersectDomPLeft :: Ord k => (k -> v2 -> Bool) -> Map k v1 -> Map k v2 -> Map k v1

-- | <ul>
--   <li>fold over the intersection of a Map and a Set</li>
--   </ul>
intersectMapSetFold :: Ord k => (k -> v -> ans -> ans) -> Map k v -> Set k -> ans -> ans

-- | Fold with <tt>accum</tt> all those pairs in the map, not appearing in
--   the set.
disjointMapSetFold :: Ord k => (k -> v -> ans -> ans) -> Map k v -> Set k -> ans -> ans

-- | Partition the <a>Map</a> according to keys in the <a>Set</a>. This is
--   equivalent to:
--   
--   <pre>
--   extractKeys m s === (withoutKeys m s, restrictKeys m s)
--   </pre>
extractKeys :: Ord k => Map k a -> Set k -> (Map k a, Map k a)

-- | It has been discovered expirementally through benchmarks that for
--   small Set size of under around 6 elements this function performs
--   faster than <a>extractKeys#</a>
extractKeysSmallSet :: Ord k => Map k a -> Set k -> (Map k a, Map k a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (Data.MapExtras.StrictTriple a b c)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => GHC.Show.Show (Data.MapExtras.StrictTriple a b c)


-- | MemoBytes is an abstraction for a data type that encodes its own
--   serialization. The idea is to use a newtype around a MemoBytes
--   non-memoizing version. For example: newtype Foo = Foo (MemoBytes
--   NonMemoizingFoo) This way all the instances for Foo
--   (Eq,Show,Ord,ToCBOR,FromCBOR,NoThunks,Generic) can be derived for
--   free.
module Data.MemoBytes
data MemoBytes t
Memo :: !t -> ShortByteString -> MemoBytes t
[memotype] :: MemoBytes t -> !t
[memobytes] :: MemoBytes t -> ShortByteString
memoBytes :: Encode w t -> MemoBytes t

-- | Useful when deriving FromCBOR(Annotator T) deriving via (Mem T)
--   instance (Era era) =&gt; FromCBOR (Annotator T)
type Mem t = Annotator (MemoBytes t)
shorten :: ByteString -> ShortByteString
showMemo :: Show t => MemoBytes t -> String
printMemo :: Show t => MemoBytes t -> IO ()
roundTripMemo :: FromCBOR t => MemoBytes t -> Either DeserialiseFailure (ByteString, MemoBytes t)
instance (Data.Typeable.Internal.Typeable t, NoThunks.Class.NoThunks t) => NoThunks.Class.NoThunks (Data.MemoBytes.MemoBytes t)
instance Control.DeepSeq.NFData t => Control.DeepSeq.NFData (Data.MemoBytes.MemoBytes t)
instance GHC.Generics.Generic (Data.MemoBytes.MemoBytes t)
instance Data.Typeable.Internal.Typeable t => Cardano.Binary.ToCBOR.ToCBOR (Data.MemoBytes.MemoBytes t)
instance (Data.Typeable.Internal.Typeable t, Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator t)) => Cardano.Binary.FromCBOR.FromCBOR (Cardano.Binary.Annotated.Annotator (Data.MemoBytes.MemoBytes t))
instance GHC.Classes.Eq (Data.MemoBytes.MemoBytes t)
instance GHC.Show.Show t => GHC.Show.Show (Data.MemoBytes.MemoBytes t)
instance GHC.Classes.Ord t => GHC.Classes.Ord (Data.MemoBytes.MemoBytes t)

module Data.Pulse

-- | let T be a Pulse structure. A Pulse struture is abstracted over a
--   monad: m, and an answer type: t, so the concrete type of a pulse
--   structure is written: (T m a). The Pulsable class supplies operations
--   on the structure that allow its computation to be split into many
--   discrete steps. One does this by running: "pulse p" or "pulseM p",
--   depending upon whether the computation is monadic or not, to run a
--   discrete step. The scheduling infrastructure needs to know nothing
--   about what is going on inside the pulse structure.
class Pulsable (pulse :: (Type -> Type) -> Type -> Type)
done :: Pulsable pulse => pulse m ans -> Bool
current :: Pulsable pulse => pulse m ans -> ans
pulseM :: (Pulsable pulse, Monad m) => pulse m ans -> m (pulse m ans)
completeM :: (Pulsable pulse, Monad m) => pulse m ans -> m ans

-- | A Map based pulser.
data PulseMapM m ans
[PulseMap] :: !Int -> !ans -> k -> v -> m ans -> !Map k v -> !ans -> PulseMapM m ans

-- | A List based pulser
data PulseListM m ans
[PulseList] :: !Int -> !ans -> a -> m ans -> ![a] -> !ans -> PulseListM m ans

-- | Type of a Map based pulser in the Identity monad.
type PulseMap ans = PulseListM Identity ans

-- | Type of a List based pulser in the Identity monad.
type PulseList ans = PulseListM Identity ans

-- | Create List pulser structure in the Identity monad, a pure accumulator
--   is lifted to a monadic one.
pulseList :: Int -> (t1 -> t2 -> t1) -> [t2] -> t1 -> PulseListM Identity t1

-- | Create Map pulser structure in the Identity monad, a pure accumulator
--   is lifted to a monadic one.
pulseMap :: Int -> (a -> k -> v -> a) -> Map k v -> a -> PulseMapM Identity a

-- | Pulse a structure in the Identity monad
pulse :: Pulsable p => p Identity ans -> p Identity ans

-- | Complete a structure in the Identity monad
complete :: Pulsable p => p Identity ans -> ans

-- | A strict, monadic, version of <a>foldl</a>. It associates to the left.
foldlM' :: (Foldable t, Monad m) => (ans -> k -> m ans) -> ans -> t k -> m ans

-- | <i>O(n)</i>. A strict, monadic, version of <tt>foldlWithKey</tt>. Each
--   application of the operator is evaluated before using the result in
--   the next application. This function is strict in the starting value.
--   Associates to the left.
foldlWithKeyM' :: Monad m => (a -> k -> b -> m a) -> a -> Map k b -> m a
instance GHC.Show.Show ans => GHC.Show.Show (Data.Pulse.PulseMapM m ans)
instance Data.Pulse.Pulsable Data.Pulse.PulseMapM
instance GHC.Show.Show ans => GHC.Show.Show (Data.Pulse.PulseListM m ans)
instance Data.Pulse.Pulsable Data.Pulse.PulseListM


-- | Defines reusable abstractions for testing Roundtrip properties of CBOR
--   instances
module Data.Roundtrip
roundTrip :: (ToCBOR t, FromCBOR t) => t -> RoundTripResult t
roundTrip' :: (t -> Encoding) -> (forall s. Decoder s t) -> t -> RoundTripResult t

-- | Can we serialise a type, and then deserialise it as something else?
embedTrip :: (ToCBOR t, FromCBOR s) => t -> RoundTripResult s
embedTrip' :: (s -> Encoding) -> (forall x. Decoder x t) -> s -> RoundTripResult t
roundTripAnn :: (ToCBOR t, FromCBOR (Annotator t)) => t -> RoundTripResult t
embedTripAnn :: forall s t. (ToCBOR t, FromCBOR (Annotator s)) => t -> RoundTripResult s
type RoundTripResult t = Either DeserialiseFailure (ByteString, t)

module Data.Sharing
class Monoid (Share a) => FromSharedCBOR a where {
    type family Share a :: Type;
    type Share a = ();
}

-- | Whenever <tt>fromShareCBOR</tt> is being used for defining the
--   instance this function should return the state that can be added
--   whenever user invokes <a>fromSharedPlusCBOR</a>. <a>mempty</a> is
--   returned by default.
getShare :: FromSharedCBOR a => a -> Share a

-- | Utilize sharing when decoding, but do not add anything to the state
--   for future sharing.
fromSharedCBOR :: FromSharedCBOR a => Share a -> Decoder s a

-- | Deserialize with sharing and add to the state that is used for
--   sharing. Default implementation will add value returned by
--   <a>getShare</a> for adding to the state.
fromSharedPlusCBOR :: FromSharedCBOR a => StateT (Share a) (Decoder s) a
newtype Interns a
Interns :: [Intern a] -> Interns a

-- | This is an abstract interface that does the interning. In other words
--   it does the actual sharing by looking up the supplied value in some
--   existing data structure and uses that value instead. Relying on this
--   interface gives us the benefit of ignoring the type of underlying data
--   structure and allows us to compose many <a>Intern</a>s with the
--   monoidal interface provided by <a>Interns</a> wrapper. In order to
--   create an <a>Intern</a> see the <a>internsFromMap</a> or
--   <a>internsFromVMap</a> functions.
data Intern a
Intern :: (a -> Maybe a) -> !Int -> Intern a

-- | Function that will do the interning. If value is not available then
--   <a>Nothing</a> is returned.
[internMaybe] :: Intern a -> a -> Maybe a

-- | Used for sorting. Normally set to the size of the underlying data
--   structure. Keeping interns sorted with respect to how many elements is
--   in the underlying data structure in theory gives a better chance of
--   successful intern hit sooner rather than later.
[internWeight] :: Intern a -> !Int
fromSharedLensCBOR :: FromSharedCBOR b => SimpleGetter bs (Share b) -> StateT bs (Decoder s) b

-- | Just like <a>fromSharedPlusCBOR</a>, except allows to transform the
--   shared state with a lens.
fromSharedPlusLensCBOR :: FromSharedCBOR b => Lens' bs (Share b) -> StateT bs (Decoder s) b

-- | Use <a>FromSharedCBOR</a> class while ignoring sharing
fromNotSharedCBOR :: FromSharedCBOR a => Decoder s a
interns :: Interns k -> k -> k
internsFromMap :: Ord k => Map k a -> Interns k
internsFromVMap :: Ord k => VMap VB kv k a -> Interns k

-- | Using this function it is possible to compose two lenses. One will
--   extract a value and another will used it for placing it into a empty
--   monoid. Here is an example of how a second element of a tuple can be
--   projected on the third element of a 3-tuple.
--   
--   <pre>
--   toMemptyLens _3 _2 == lens (\(_, b) -&gt; (mempty, mempty, b)) (\(a, _) (_, _, b) -&gt; (a, b))
--   </pre>
--   
--   Here is an example where we extract a second element of a tuple and
--   insert it at third position of a three tuple while all other elements
--   are set to <a>mempty</a>:
--   
--   <pre>
--   &gt;&gt;&gt; import Lens.Micro
--   
--   &gt;&gt;&gt; ("foo","bar") ^. toMemptyLens _3 _2 :: (Maybe String, (), String)
--   (Nothing,(),"bar")
--   </pre>
--   
--   In the opposite direction of extracting the third element of a 3-tuple
--   and replacing the second element of the tuple the setter is being
--   applied to
--   
--   <pre>
--   &gt;&gt;&gt; ("foo","bar") &amp; toMemptyLens _3 _2 .~ (Just "baz", (), "booyah") :: (String, String)
--   ("foo","booyah")
--   </pre>
toMemptyLens :: Monoid a => Lens' a b -> Lens' c b -> Lens' c a

-- | Share every item in a functor, have deserializing it
fromShareCBORfunctor :: (FromCBOR (f b), Monad f) => Interns b -> Decoder s (f b)
instance GHC.Base.Monoid (Data.Sharing.Interns a)
instance (GHC.Classes.Ord k, Cardano.Binary.FromCBOR.FromCBOR k, Cardano.Binary.FromCBOR.FromCBOR v) => Data.Sharing.FromSharedCBOR (Data.Map.Internal.Map k v)
instance (GHC.Classes.Ord k, Cardano.Binary.FromCBOR.FromCBOR k, Cardano.Binary.FromCBOR.FromCBOR v) => Data.Sharing.FromSharedCBOR (Data.VMap.VMap Data.VMap.VB Data.VMap.VB k v)
instance (GHC.Classes.Ord k, Cardano.Binary.FromCBOR.FromCBOR k, Cardano.Binary.FromCBOR.FromCBOR v, Data.Primitive.Types.Prim v) => Data.Sharing.FromSharedCBOR (Data.VMap.VMap Data.VMap.VB Data.VMap.VP k v)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b, Cardano.Binary.FromCBOR.FromCBOR a, Cardano.Binary.FromCBOR.FromCBOR b) => Data.Sharing.FromSharedCBOR (Data.BiMap.BiMap b a b)
instance GHC.Base.Semigroup (Data.Sharing.Interns a)

module Data.UMap
data Trip coin ptr pool
pattern Triple :: StrictMaybe coin -> Set ptr -> StrictMaybe pool -> Trip coin ptr pool
tripReward :: Trip coin ptr pool -> Maybe coin
tripRewardActiveDelegation :: Trip coin ptr pool -> Maybe coin
tripDelegation :: Trip coin ptr pool -> Maybe pool
data UMap coin cred pool ptr
UnifiedMap :: !Map cred (Trip coin ptr pool) -> !Map ptr cred -> UMap coin cred pool ptr
class UnifiedView coin cred pool ptr k v
tag :: UnifiedView coin cred pool ptr k v => Tag coin cred pool ptr k v

-- | It is worthwhie stating the invariant that holds on a Unified Map The
--   <tt>ptrmap</tt> and the <tt>ptrT</tt> field of the <tt>tripmap</tt>
--   are inverses.
umInvariant :: (Ord cred, Ord ptr) => cred -> ptr -> UMap coin cred pool ptr -> Bool
unView :: View coin cr pl ptr k v -> UMap coin cr pl ptr

-- | This is expensive, use it wisely (like maybe once per epoch boundary
--   to make a SnapShot) See also domRestrictedView, which domain restricts
--   before computing a view.
unUnify :: View coin cred pool ptr k v -> Map k v

-- | This is expensive, use it wisely (like maybe once per epoch boundary
--   to make a SnapShot)
viewToVMap :: Ord cred => View coin cred pool ptr k v -> VMap VB VB k v
rewView :: UMap coin cred pool ptr -> Map cred coin
delView :: UMap coin cred pool ptr -> Map cred pool
ptrView :: UMap coin cred pool ptr -> Map ptr cred

-- | Return the appropriate View of a domain restricted Umap. f
--   <tt>setk</tt> is small this should be efficient.
domRestrictedView :: (Ord ptr, Ord cred) => Set k -> View coin cred pl ptr k v -> Map k v

-- | Is there no information in a Triple? If so then we can delete it from
--   the UnifedMap
zero :: Trip coin ptr pool -> Bool
zeroMaybe :: Trip coin ptr pool -> Maybe (Trip coin ptr pool)
mapNext :: Map k v -> Maybe (k, v, Map k v)
mapLub :: Ord k => k -> Map k v -> Maybe (k, v, Map k v)
next :: View coin cr pl ptr k v -> Maybe (k, v, View coin cr pl ptr k v)
leastUpperBound :: (Ord ptr, Ord cr) => k -> View coin cr pool ptr k v -> Maybe (k, v, View coin cr pool ptr k v)
empty :: UMap coin cr pool ptr
delete :: (Ord cr, Ord ptr) => k -> View coin cr pool ptr k v -> UMap coin cr pool ptr
delete' :: (Ord cr, Ord ptr) => k -> View coin cr pool ptr k v -> View coin cr pool ptr k v
insertWith :: (Ord cr, Monoid coin, Ord ptr) => (v -> v -> v) -> k -> v -> View coin cr pool ptr k v -> UMap coin cr pool ptr

-- | Special insertion:
--   
--   Keeps the value already in the ViewMap if the key <tt>k</tt> is
--   already there:
--   
--   <pre>
--   insertWith' (\ old new -&gt; old) k v xs
--   </pre>
--   
--   Replaces the value already in the ViewMap with <tt>v</tt>, if key
--   <tt>k</tt> is already there:
--   
--   <pre>
--   insertWith' (\ old new -&gt; new) k v xs
--   </pre>
--   
--   Replaces the value already in the ViewMap with the sum, if key
--   <tt>k</tt> is already there:
--   
--   <pre>
--   insertWith' (\ old new -&gt; old+new) k v xs
--   </pre>
--   
--   Ignores <tt>combine</tt> if the key <tt>k</tt> is NOT already in the
--   ViewMap, and inserts <tt>v</tt>:
--   
--   <pre>
--   insertWith' combine k v xs
--   </pre>
insertWith' :: (Ord cr, Monoid coin, Ord ptr) => (v -> v -> v) -> k -> v -> View coin cr pool ptr k v -> View coin cr pool ptr k v
insert :: (Ord cr, Monoid coin, Ord ptr) => k -> v -> View coin cr pool ptr k v -> UMap coin cr pool ptr
insert' :: (Ord cr, Monoid coin, Ord ptr) => k -> v -> View coin cr pool ptr k v -> View coin cr pool ptr k v
lookup :: (Ord cr, Ord ptr) => k -> View coin cr pool ptr k v -> Maybe v
isNull :: View coin cr pool ptr k v -> Bool
domain :: Ord cr => View coin cr pool ptr k v -> Set k
range :: (Ord coin, Ord pool, Ord cr) => View coin cr pool ptr k v -> Set v

-- | Union with left preference, so if k, already exists, do nothing, if it
--   doesn't exist insert it.
(∪) :: (Ord cr, Monoid coin, Ord ptr) => View coin cr pool ptr k v -> (k, v) -> UMap coin cr pool ptr

-- | Union with right preference, so if <tt>k</tt>, already exists, then
--   its value is overwritten with <tt>v</tt>
(⨃) :: (Ord cr, Monoid coin, Ord ptr) => View coin cr pool ptr k v -> Map k v -> UMap coin cr pool ptr
(∪+) :: (Ord cred, Monoid coin) => View coin cred pool ptr k coin -> Map k coin -> UMap coin cred pool ptr
(⋪) :: (Ord cred, Ord ptr) => Set k -> View coin cred pool ptr k v -> UMap coin cred pool ptr

-- | This is slow for Delegations and Rewards Views, better hope they are
--   small
(⋫) :: (Ord cred, Ord ptr, Ord coin, Ord pool) => View coin cred pool ptr k v -> Set v -> UMap coin cred pool ptr
member :: (Ord cr, Ord ptr) => k -> View coin cr pool ptr k v -> Bool
notMember :: (Ord cr, Ord ptr) => k -> View coin cr pool ptr k v -> Bool
domRestrict :: (Ord cr, Ord ptr) => View coin cr pool ptr k v -> Map k u -> Map k u
data Tag coin cred pool ptr k v
[Rew] :: Tag coin cred pool ptr cred coin
[Del] :: Tag coin cred pool ptr cred pool
[Ptr] :: Tag coin cred pool ptr ptr cred
data View coin cr pl ptr k v
[Rewards] :: !UMap coin cr pl ptr -> View coin cr pl ptr cr coin
[Delegations] :: !UMap coin cr pl ptr -> View coin cr pl ptr cr pl
[Ptrs] :: !UMap coin cr pl ptr -> View coin cr pl ptr ptr cr
findWithDefault :: (Ord cred, Ord ptr) => a -> k -> View coin cred pool ptr k a -> a

-- | A View is a view, so the size of the view is NOT the same as the size
--   of the underlying triple map.
size :: View coin cred pool ptr k a -> Int

-- | Create a UMap from 3 separate maps. For use in tests only.
unify :: (Monoid coin, Ord cred, Ord ptr) => Map cred coin -> Map cred pool -> Map ptr cred -> UMap coin cred pool ptr
instance (Control.DeepSeq.NFData pool, Control.DeepSeq.NFData ptr, Control.DeepSeq.NFData coin) => Control.DeepSeq.NFData (Data.UMap.Trip coin ptr pool)
instance (NoThunks.Class.NoThunks pool, NoThunks.Class.NoThunks ptr, NoThunks.Class.NoThunks coin) => NoThunks.Class.NoThunks (Data.UMap.Trip coin ptr pool)
instance GHC.Generics.Generic (Data.UMap.Trip coin ptr pool)
instance (GHC.Classes.Ord pool, GHC.Classes.Ord ptr, GHC.Classes.Ord coin) => GHC.Classes.Ord (Data.UMap.Trip coin ptr pool)
instance (GHC.Classes.Eq pool, GHC.Classes.Eq ptr, GHC.Classes.Eq coin) => GHC.Classes.Eq (Data.UMap.Trip coin ptr pool)
instance (Control.DeepSeq.NFData cred, Control.DeepSeq.NFData pool, Control.DeepSeq.NFData ptr, Control.DeepSeq.NFData coin) => Control.DeepSeq.NFData (Data.UMap.UMap coin cred pool ptr)
instance (NoThunks.Class.NoThunks cred, NoThunks.Class.NoThunks pool, NoThunks.Class.NoThunks ptr, NoThunks.Class.NoThunks coin) => NoThunks.Class.NoThunks (Data.UMap.UMap coin cred pool ptr)
instance GHC.Generics.Generic (Data.UMap.UMap coin cred pool ptr)
instance (GHC.Classes.Eq cred, GHC.Classes.Eq pool, GHC.Classes.Eq ptr, GHC.Classes.Eq coin) => GHC.Classes.Eq (Data.UMap.UMap coin cred pool ptr)
instance (GHC.Show.Show cred, GHC.Show.Show coin, GHC.Show.Show pool, GHC.Show.Show ptr) => GHC.Show.Show (Data.UMap.UMap coin cred pool ptr)
instance (Data.UMap.Tbor coin, Data.UMap.Tbor ptr, GHC.Classes.Ord ptr, Cardano.Binary.ToCBOR.ToCBOR pool) => Cardano.Binary.ToCBOR.ToCBOR (Data.UMap.Trip coin ptr pool)
instance (Data.UMap.Tbor coin, Data.UMap.Tbor ptr, Data.UMap.Tbor cred, Cardano.Binary.ToCBOR.ToCBOR pool, GHC.Classes.Ord ptr) => Cardano.Binary.ToCBOR.ToCBOR (Data.UMap.UMap coin cred pool ptr)
instance Data.Foldable.Foldable (Data.UMap.View coin cred pool ptr k)
instance (GHC.Classes.Ord cred, Cardano.Binary.FromCBOR.FromCBOR cred, GHC.Classes.Ord ptr, Cardano.Binary.FromCBOR.FromCBOR ptr, Cardano.Binary.FromCBOR.FromCBOR coin, Cardano.Binary.FromCBOR.FromCBOR pool) => Data.Sharing.FromSharedCBOR (Data.UMap.UMap coin cred pool ptr)
instance (GHC.Show.Show coin, GHC.Show.Show pool, GHC.Show.Show ptr) => GHC.Show.Show (Data.UMap.Trip coin ptr pool)
instance (GHC.Classes.Ord ptr, GHC.Base.Monoid coin) => GHC.Base.Semigroup (Data.UMap.Trip coin ptr pool)
instance (GHC.Classes.Ord ptr, GHC.Base.Monoid coin) => GHC.Base.Monoid (Data.UMap.Trip coin ptr pool)
instance (Cardano.Binary.FromCBOR.FromCBOR coin, GHC.Classes.Ord ptr, Cardano.Binary.FromCBOR.FromCBOR ptr, Cardano.Binary.FromCBOR.FromCBOR pool) => Data.Sharing.FromSharedCBOR (Data.UMap.Trip coin ptr pool)
