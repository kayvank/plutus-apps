-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A newtype around ByteString, for base64 encoding
--   
--   A newtype around ByteString, for base64 encoding. Strict and lazy,
--   normal and url alphabet variants.
@package base64-bytestring-type
@version 1.0.1


-- | Lazy <a>ByteString</a> standard base64 encoding.
--   
--   See <a>https://tools.ietf.org/html/rfc4648</a>.
module Data.ByteString.Base64.Lazy.Type

-- | Aeson serialisable bytestring. Uses base64 encoding.
--   
--   The inner <a>ByteString</a> is in raw format.
--   
--   <pre>
--   &gt;&gt;&gt; let bs64 = makeByteString64 "foobar"
--   
--   &gt;&gt;&gt; bs64
--   mkBS64 "foobar"
--   </pre>
--   
--   <a>Binary</a> instance doesn't use base64 encoding:
--   
--   <pre>
--   &gt;&gt;&gt; Binary.encode bs64
--   "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ACKfoobar"
--   </pre>
--   
--   <tt>Aeson</tt> instance does:
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode bs64
--   "\"Zm9vYmFy\""
--   </pre>
--   
--   This module uses standard alphabet
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode (makeByteString64 "aa\191")
--   "\"YWG/\""
--   </pre>
data ByteString64

-- | Wrap <a>ByteString</a> into <a>ByteString64</a>. Essentially
--   <tt>coerce</tt>.
makeByteString64 :: ByteString -> ByteString64

-- | Unwrap <a>ByteString</a> from <a>ByteString64</a>. Essentially
--   <tt>coerce</tt>.
getByteString64 :: ByteString64 -> ByteString

-- | Shorter variant of <a>makeByteString64</a>
mkBS64 :: ByteString -> ByteString64
getBS64 :: ByteString64 -> ByteString

-- | Get base64 encode bytestring
--   
--   <pre>
--   &gt;&gt;&gt; getEncodedByteString64 "foobar"
--   "Zm9vYmFy"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getEncodedByteString64 "aa\191"
--   "YWG/"
--   </pre>
getEncodedByteString64 :: ByteString64 -> ByteString
instance GHC.Generics.Generic Data.ByteString.Base64.Lazy.Type.ByteString64
instance Data.Data.Data Data.ByteString.Base64.Lazy.Type.ByteString64
instance GHC.Classes.Ord Data.ByteString.Base64.Lazy.Type.ByteString64
instance GHC.Classes.Eq Data.ByteString.Base64.Lazy.Type.ByteString64
instance GHC.Show.Show Data.ByteString.Base64.Lazy.Type.ByteString64
instance Data.String.IsString Data.ByteString.Base64.Lazy.Type.ByteString64
instance GHC.Base.Semigroup Data.ByteString.Base64.Lazy.Type.ByteString64
instance GHC.Base.Monoid Data.ByteString.Base64.Lazy.Type.ByteString64
instance Control.DeepSeq.NFData Data.ByteString.Base64.Lazy.Type.ByteString64
instance Data.Hashable.Class.Hashable Data.ByteString.Base64.Lazy.Type.ByteString64
instance Data.Aeson.Types.ToJSON.ToJSON Data.ByteString.Base64.Lazy.Type.ByteString64
instance Data.Aeson.Types.FromJSON.FromJSON Data.ByteString.Base64.Lazy.Type.ByteString64
instance Data.Aeson.Types.ToJSON.ToJSONKey Data.ByteString.Base64.Lazy.Type.ByteString64
instance Data.Aeson.Types.FromJSON.FromJSONKey Data.ByteString.Base64.Lazy.Type.ByteString64
instance Data.Serialize.Serialize Data.ByteString.Base64.Lazy.Type.ByteString64
instance Data.Binary.Class.Binary Data.ByteString.Base64.Lazy.Type.ByteString64
instance Codec.Serialise.Class.Serialise Data.ByteString.Base64.Lazy.Type.ByteString64
instance Test.QuickCheck.Arbitrary.Arbitrary Data.ByteString.Base64.Lazy.Type.ByteString64
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.ByteString.Base64.Lazy.Type.ByteString64
instance Test.QuickCheck.Function.Function Data.ByteString.Base64.Lazy.Type.ByteString64


-- | Strict <a>ByteString</a> standard base64 encoding.
--   
--   See <a>https://tools.ietf.org/html/rfc4648</a>.
module Data.ByteString.Base64.Type

-- | Aeson serialisable bytestring. Uses base64 encoding.
--   
--   The inner <a>ByteString</a> is in raw format.
--   
--   <pre>
--   &gt;&gt;&gt; let bs64 = makeByteString64 "foobar"
--   
--   &gt;&gt;&gt; bs64
--   mkBS64 "foobar"
--   </pre>
--   
--   <a>Binary</a> instance doesn't use base64 encoding:
--   
--   <pre>
--   &gt;&gt;&gt; Binary.encode bs64
--   "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ACKfoobar"
--   </pre>
--   
--   <tt>Aeson</tt> instance does:
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode bs64
--   "\"Zm9vYmFy\""
--   </pre>
--   
--   This module uses standard alphabet
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode (makeByteString64 "aa\191")
--   "\"YWG/\""
--   </pre>
data ByteString64

-- | Wrap <a>ByteString</a> into <a>ByteString64</a>. Essentially
--   <tt>coerce</tt>.
--   
--   Wrap <a>ByteString</a> into <a>ByteString64</a>. Essentially
--   <tt>coerce</tt>.
makeByteString64 :: ByteString -> ByteString64

-- | Unwrap <a>ByteString</a> from <a>ByteString64</a>. Essentially
--   <tt>coerce</tt>.
getByteString64 :: ByteString64 -> ByteString

-- | Shorter variant of <a>makeByteString64</a>
mkBS64 :: ByteString -> ByteString64
getBS64 :: ByteString64 -> ByteString

-- | Get base64 encode bytestring
--   
--   <pre>
--   &gt;&gt;&gt; getEncodedByteString64 "foobar"
--   "Zm9vYmFy"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getEncodedByteString64 "aa\191"
--   "YWG/"
--   </pre>
getEncodedByteString64 :: ByteString64 -> ByteString
instance GHC.Generics.Generic Data.ByteString.Base64.Type.ByteString64
instance Data.Data.Data Data.ByteString.Base64.Type.ByteString64
instance GHC.Classes.Ord Data.ByteString.Base64.Type.ByteString64
instance GHC.Classes.Eq Data.ByteString.Base64.Type.ByteString64
instance GHC.Show.Show Data.ByteString.Base64.Type.ByteString64
instance Data.String.IsString Data.ByteString.Base64.Type.ByteString64
instance GHC.Base.Semigroup Data.ByteString.Base64.Type.ByteString64
instance GHC.Base.Monoid Data.ByteString.Base64.Type.ByteString64
instance Control.DeepSeq.NFData Data.ByteString.Base64.Type.ByteString64
instance Data.Hashable.Class.Hashable Data.ByteString.Base64.Type.ByteString64
instance Data.Aeson.Types.ToJSON.ToJSON Data.ByteString.Base64.Type.ByteString64
instance Data.Aeson.Types.FromJSON.FromJSON Data.ByteString.Base64.Type.ByteString64
instance Data.Aeson.Types.ToJSON.ToJSONKey Data.ByteString.Base64.Type.ByteString64
instance Data.Aeson.Types.FromJSON.FromJSONKey Data.ByteString.Base64.Type.ByteString64
instance Data.Serialize.Serialize Data.ByteString.Base64.Type.ByteString64
instance Data.Binary.Class.Binary Data.ByteString.Base64.Type.ByteString64
instance Codec.Serialise.Class.Serialise Data.ByteString.Base64.Type.ByteString64
instance Web.Internal.HttpApiData.ToHttpApiData Data.ByteString.Base64.Type.ByteString64
instance Web.Internal.HttpApiData.FromHttpApiData Data.ByteString.Base64.Type.ByteString64
instance Test.QuickCheck.Arbitrary.Arbitrary Data.ByteString.Base64.Type.ByteString64
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.ByteString.Base64.Type.ByteString64
instance Test.QuickCheck.Function.Function Data.ByteString.Base64.Type.ByteString64


-- | Lazy <a>ByteString</a> base64 encoding with URL and filename safe
--   alphabet.
--   
--   See <a>https://tools.ietf.org/html/rfc4648</a>.
module Data.ByteString.Base64.URL.Lazy.Type

-- | Aeson serialisable bytestring. Uses base64 encoding.
--   
--   The inner <a>ByteString</a> is in raw format.
--   
--   <pre>
--   &gt;&gt;&gt; let bs64 = makeByteString64 "foobar"
--   
--   &gt;&gt;&gt; bs64
--   mkBS64 "foobar"
--   </pre>
--   
--   <a>Binary</a> instance doesn't use base64 encoding:
--   
--   <pre>
--   &gt;&gt;&gt; Binary.encode bs64
--   "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ACKfoobar"
--   </pre>
--   
--   <tt>Aeson</tt> instance does:
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode bs64
--   "\"Zm9vYmFy\""
--   </pre>
--   
--   This module uses standard alphabet
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode (makeByteString64 "aa\191")
--   "\"YWG_\""
--   </pre>
data ByteString64

-- | Wrap <a>ByteString</a> into <a>ByteString64</a>. Essentially
--   <tt>coerce</tt>.
makeByteString64 :: ByteString -> ByteString64

-- | Unwrap <a>ByteString</a> from <a>ByteString64</a>. Essentially
--   <tt>coerce</tt>.
getByteString64 :: ByteString64 -> ByteString

-- | Shorter variant of <a>makeByteString64</a>
mkBS64 :: ByteString -> ByteString64
getBS64 :: ByteString64 -> ByteString

-- | Get base64 encode bytestring
--   
--   <pre>
--   &gt;&gt;&gt; getEncodedByteString64 "foobar"
--   "Zm9vYmFy"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getEncodedByteString64 "aa\191"
--   "YWG_"
--   </pre>
getEncodedByteString64 :: ByteString64 -> ByteString
instance GHC.Generics.Generic Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Data.Data.Data Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance GHC.Classes.Ord Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance GHC.Classes.Eq Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance GHC.Show.Show Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Data.String.IsString Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance GHC.Base.Semigroup Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance GHC.Base.Monoid Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Control.DeepSeq.NFData Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Data.Hashable.Class.Hashable Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Data.Aeson.Types.ToJSON.ToJSON Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Data.Aeson.Types.FromJSON.FromJSON Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Data.Aeson.Types.ToJSON.ToJSONKey Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Data.Aeson.Types.FromJSON.FromJSONKey Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Data.Serialize.Serialize Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Data.Binary.Class.Binary Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Codec.Serialise.Class.Serialise Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Test.QuickCheck.Arbitrary.Arbitrary Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.ByteString.Base64.URL.Lazy.Type.ByteString64
instance Test.QuickCheck.Function.Function Data.ByteString.Base64.URL.Lazy.Type.ByteString64


-- | Strict <a>ByteString</a> base64 encoding with URL and filename safe
--   alphabet.
--   
--   See <a>https://tools.ietf.org/html/rfc4648</a>.
module Data.ByteString.Base64.URL.Type

-- | Aeson serialisable bytestring. Uses base64 encoding.
--   
--   The inner <a>ByteString</a> is in raw format.
--   
--   <pre>
--   &gt;&gt;&gt; let bs64 = makeByteString64 "foobar"
--   
--   &gt;&gt;&gt; bs64
--   mkBS64 "foobar"
--   </pre>
--   
--   <a>Binary</a> instance doesn't use base64 encoding:
--   
--   <pre>
--   &gt;&gt;&gt; Binary.encode bs64
--   "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\ACKfoobar"
--   </pre>
--   
--   <tt>Aeson</tt> instance does:
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode bs64
--   "\"Zm9vYmFy\""
--   </pre>
--   
--   This module uses standard alphabet
--   
--   <pre>
--   &gt;&gt;&gt; Aeson.encode (makeByteString64 "aa\191")
--   "\"YWG_\""
--   </pre>
data ByteString64

-- | Wrap <a>ByteString</a> into <a>ByteString64</a>. Essentially
--   <tt>coerce</tt>.
makeByteString64 :: ByteString -> ByteString64

-- | Unwrap <a>ByteString</a> from <a>ByteString64</a>. Essentially
--   <tt>coerce</tt>.
getByteString64 :: ByteString64 -> ByteString

-- | Shorter variant of <a>makeByteString64</a>
mkBS64 :: ByteString -> ByteString64
getBS64 :: ByteString64 -> ByteString

-- | Get base64 encode bytestring
--   
--   <pre>
--   &gt;&gt;&gt; getEncodedByteString64 "foobar"
--   "Zm9vYmFy"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; getEncodedByteString64 "aa\191"
--   "YWG_"
--   </pre>
getEncodedByteString64 :: ByteString64 -> ByteString
instance GHC.Generics.Generic Data.ByteString.Base64.URL.Type.ByteString64
instance Data.Data.Data Data.ByteString.Base64.URL.Type.ByteString64
instance GHC.Classes.Ord Data.ByteString.Base64.URL.Type.ByteString64
instance GHC.Classes.Eq Data.ByteString.Base64.URL.Type.ByteString64
instance GHC.Show.Show Data.ByteString.Base64.URL.Type.ByteString64
instance Data.String.IsString Data.ByteString.Base64.URL.Type.ByteString64
instance GHC.Base.Semigroup Data.ByteString.Base64.URL.Type.ByteString64
instance GHC.Base.Monoid Data.ByteString.Base64.URL.Type.ByteString64
instance Control.DeepSeq.NFData Data.ByteString.Base64.URL.Type.ByteString64
instance Data.Hashable.Class.Hashable Data.ByteString.Base64.URL.Type.ByteString64
instance Data.Aeson.Types.ToJSON.ToJSON Data.ByteString.Base64.URL.Type.ByteString64
instance Data.Aeson.Types.FromJSON.FromJSON Data.ByteString.Base64.URL.Type.ByteString64
instance Data.Aeson.Types.ToJSON.ToJSONKey Data.ByteString.Base64.URL.Type.ByteString64
instance Data.Aeson.Types.FromJSON.FromJSONKey Data.ByteString.Base64.URL.Type.ByteString64
instance Data.Serialize.Serialize Data.ByteString.Base64.URL.Type.ByteString64
instance Data.Binary.Class.Binary Data.ByteString.Base64.URL.Type.ByteString64
instance Codec.Serialise.Class.Serialise Data.ByteString.Base64.URL.Type.ByteString64
instance Web.Internal.HttpApiData.ToHttpApiData Data.ByteString.Base64.URL.Type.ByteString64
instance Web.Internal.HttpApiData.FromHttpApiData Data.ByteString.Base64.URL.Type.ByteString64
instance Test.QuickCheck.Arbitrary.Arbitrary Data.ByteString.Base64.URL.Type.ByteString64
instance Test.QuickCheck.Arbitrary.CoArbitrary Data.ByteString.Base64.URL.Type.ByteString64
instance Test.QuickCheck.Function.Function Data.ByteString.Base64.URL.Type.ByteString64
