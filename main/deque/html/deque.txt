-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Double-ended queues
--   
--   Strict and lazy implementations of Double-Ended Queue (aka Dequeue or
--   Deque) based on head-tail linked list.
@package deque
@version 0.4.4


-- | Definitions of strict Deque.
--   
--   The typical <a>toList</a> and <a>fromList</a> conversions are provided
--   by means of the <a>Foldable</a> and <a>IsList</a> instances.
module Deque.Strict

-- | Strict double-ended queue (aka Dequeue or Deque) based on head-tail
--   linked list.
data Deque a

-- | Convert lazy deque to strict deque.
fromLazy :: Deque a -> Deque a

-- | Convert strict deque to lazy deque.
toLazy :: Deque a -> Deque a

-- | &lt;math&gt;. Construct from cons and snoc lists.
fromConsAndSnocLists :: [a] -> [a] -> Deque a

-- | &lt;math&gt;. Add element in the beginning.
cons :: a -> Deque a -> Deque a

-- | &lt;math&gt;. Add element in the ending.
snoc :: a -> Deque a -> Deque a

-- | &lt;math&gt;. Reverse the deque.
reverse :: Deque a -> Deque a

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the first element to the
--   end.
--   
--   <pre>
--   位 toList . shiftLeft $ fromList [1,2,3]
--   [2,3,1]
--   </pre>
shiftLeft :: Deque a -> Deque a

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the last element to the
--   beginning.
--   
--   <pre>
--   位 toList . shiftRight $ fromList [1,2,3]
--   [3,1,2]
--   </pre>
shiftRight :: Deque a -> Deque a

-- | &lt;math&gt;. Leave only the elements satisfying the predicate.
filter :: (a -> Bool) -> Deque a -> Deque a

-- | &lt;math&gt;. Leave only the specified amount of first elements.
take :: Int -> Deque a -> Deque a

-- | &lt;math&gt;. Drop the specified amount of first elements.
drop :: Int -> Deque a -> Deque a

-- | &lt;math&gt;. Leave only the first elements satisfying the predicate.
takeWhile :: (a -> Bool) -> Deque a -> Deque a

-- | &lt;math&gt;. Drop the first elements satisfying the predicate.
dropWhile :: (a -> Bool) -> Deque a -> Deque a

-- | &lt;math&gt;. Perform <a>takeWhile</a> and <a>dropWhile</a> in a
--   single operation.
span :: (a -> Bool) -> Deque a -> (Deque a, Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element and
--   deque without it if it's not empty.
uncons :: Deque a -> Maybe (a, Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element and
--   deque without it if it's not empty.
unsnoc :: Deque a -> Maybe (a, Deque a)

-- | &lt;math&gt;. Check whether deque is empty.
null :: Deque a -> Bool

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element if
--   deque is not empty.
head :: Deque a -> Maybe a

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element if deque
--   is not empty.
last :: Deque a -> Maybe a

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   first one.
--   
--   In case of empty deque returns an empty deque.
tail :: Deque a -> Deque a

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   last one.
--   
--   In case of empty deque returns an empty deque.
init :: Deque a -> Deque a


-- | Definitions of lazy Deque.
--   
--   The typical <a>toList</a> and <a>fromList</a> conversions are provided
--   by means of the <a>Foldable</a> and <a>IsList</a> instances.
module Deque.Lazy

-- | Lazy double-ended queue (aka Dequeue or Deque) based on head-tail
--   linked list.
data Deque a

-- | Convert strict deque to lazy deque.
fromStrict :: Deque a -> Deque a

-- | Convert lazy deque to strict deque.
toStrict :: Deque a -> Deque a

-- | &lt;math&gt;. Construct from cons and snoc lists.
fromConsAndSnocLists :: [a] -> [a] -> Deque a

-- | &lt;math&gt;. Add element in the beginning.
cons :: a -> Deque a -> Deque a

-- | &lt;math&gt;. Add element in the ending.
snoc :: a -> Deque a -> Deque a

-- | &lt;math&gt;. Reverse the deque.
reverse :: Deque a -> Deque a

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the first element to the
--   end.
--   
--   <pre>
--   位 toList . shiftLeft $ fromList [1,2,3]
--   [2,3,1]
--   </pre>
shiftLeft :: Deque a -> Deque a

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the last element to the
--   beginning.
--   
--   <pre>
--   位 toList . shiftRight $ fromList [1,2,3]
--   [3,1,2]
--   </pre>
shiftRight :: Deque a -> Deque a

-- | &lt;math&gt;. Leave only the elements satisfying the predicate.
filter :: (a -> Bool) -> Deque a -> Deque a

-- | &lt;math&gt;. Leave only the specified amount of first elements.
take :: Int -> Deque a -> Deque a

-- | &lt;math&gt;. Drop the specified amount of first elements.
drop :: Int -> Deque a -> Deque a

-- | &lt;math&gt;. Leave only the first elements satisfying the predicate.
takeWhile :: (a -> Bool) -> Deque a -> Deque a

-- | &lt;math&gt;. Drop the first elements satisfying the predicate.
dropWhile :: (a -> Bool) -> Deque a -> Deque a

-- | &lt;math&gt;. Perform <a>takeWhile</a> and <a>dropWhile</a> in a
--   single operation.
span :: (a -> Bool) -> Deque a -> (Deque a, Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element and
--   deque without it if it's not empty.
uncons :: Deque a -> Maybe (a, Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element and
--   deque without it if it's not empty.
unsnoc :: Deque a -> Maybe (a, Deque a)

-- | &lt;math&gt;. Check whether deque is empty.
null :: Deque a -> Bool

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element if
--   deque is not empty.
head :: Deque a -> Maybe a

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element if deque
--   is not empty.
last :: Deque a -> Maybe a

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   first one.
--   
--   In case of empty deque returns an empty deque.
tail :: Deque a -> Deque a

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   last one.
--   
--   In case of empty deque returns an empty deque.
init :: Deque a -> Deque a


-- | Lazy Deque API lifted to a State monad, "mtl"-style.
module Deque.Lazy.State

-- | &lt;math&gt;. Modify each element of the queue.
map :: MonadState (Deque a) m => (a -> a) -> m ()

-- | &lt;math&gt;. Add elements to the begginning.
prepend :: MonadState (Deque a) m => Deque a -> m ()

-- | &lt;math&gt;. Add elements to the ending.
append :: MonadState (Deque a) m => Deque a -> m ()

-- | &lt;math&gt;. Add element in the beginning.
cons :: MonadState (Deque a) m => a -> m ()

-- | &lt;math&gt;. Add element in the ending.
snoc :: MonadState (Deque a) m => a -> m ()

-- | &lt;math&gt;. Reverse the deque.
reverse :: MonadState (Deque a) m => m ()

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the first element to the
--   end.
shiftLeft :: MonadState (Deque a) m => m ()

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the last element to the
--   beginning.
shiftRight :: MonadState (Deque a) m => m ()

-- | &lt;math&gt;. Leave only the elements satisfying the predicate.
filter :: MonadState (Deque a) m => (a -> Bool) -> m ()

-- | &lt;math&gt;. Leave only the specified amount of first elements.
take :: MonadState (Deque a) m => Int -> m ()

-- | &lt;math&gt;. Drop the specified amount of first elements.
drop :: MonadState (Deque a) m => Int -> m ()

-- | &lt;math&gt;. Leave only the first elements satisfying the predicate.
takeWhile :: MonadState (Deque a) m => (a -> Bool) -> m ()

-- | &lt;math&gt;. Drop the first elements satisfying the predicate.
dropWhile :: MonadState (Deque a) m => (a -> Bool) -> m ()

-- | &lt;math&gt;. Return the first elements satisfying the predicate,
--   removing them from the state.
span :: MonadState (Deque a) m => (a -> Bool) -> m (Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element if
--   deque is not empty, removing the element.
uncons :: MonadState (Deque a) m => m (Maybe a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element if deque
--   is not empty, removing the element.
unsnoc :: MonadState (Deque a) m => m (Maybe a)

-- | &lt;math&gt;. Check whether deque is empty.
null :: MonadState (Deque a) m => m Bool

-- | &lt;math&gt;. Check whether deque is empty.
length :: MonadState (Deque a) m => m Int

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element if
--   deque is not empty.
head :: MonadState (Deque a) m => m (Maybe a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element if deque
--   is not empty.
last :: MonadState (Deque a) m => m (Maybe a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   first one.
tail :: MonadState (Deque a) m => m ()

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   last one.
init :: MonadState (Deque a) m => m ()


-- | Lazy Deque API lifted to a Reader monad, "mtl"-style.
module Deque.Lazy.Reader

-- | &lt;math&gt;. Modify each element of the queue.
map :: MonadReader (Deque a) m => (a -> b) -> m (Deque b)

-- | &lt;math&gt;. Add elements to the begginning.
prepend :: MonadReader (Deque a) m => Deque a -> m (Deque a)

-- | &lt;math&gt;. Add elements to the ending.
append :: MonadReader (Deque a) m => Deque a -> m (Deque a)

-- | &lt;math&gt;. Add element in the beginning.
cons :: MonadReader (Deque a) m => a -> m (Deque a)

-- | &lt;math&gt;. Add element in the ending.
snoc :: MonadReader (Deque a) m => a -> m (Deque a)

-- | &lt;math&gt;. Reverse the deque.
reverse :: MonadReader (Deque a) m => m (Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the first element to the
--   end.
shiftLeft :: MonadReader (Deque a) m => m (Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the last element to the
--   beginning.
shiftRight :: MonadReader (Deque a) m => m (Deque a)

-- | &lt;math&gt;. Leave only the elements satisfying the predicate.
filter :: MonadReader (Deque a) m => (a -> Bool) -> m (Deque a)

-- | &lt;math&gt;. Leave only the specified amount of first elements.
take :: MonadReader (Deque a) m => Int -> m (Deque a)

-- | &lt;math&gt;. Drop the specified amount of first elements.
drop :: MonadReader (Deque a) m => Int -> m (Deque a)

-- | &lt;math&gt;. Leave only the first elements satisfying the predicate.
takeWhile :: MonadReader (Deque a) m => (a -> Bool) -> m (Deque a)

-- | &lt;math&gt;. Drop the first elements satisfying the predicate.
dropWhile :: MonadReader (Deque a) m => (a -> Bool) -> m (Deque a)

-- | &lt;math&gt;. Same as <tt>(,) <a>&lt;$&gt;</a> <a>takeWhile</a>
--   predicate <a>&lt;*&gt;</a> <a>dropWhile</a> predicate</tt>.
span :: MonadReader (Deque a) m => (a -> Bool) -> m (Deque a, Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element and
--   deque without it if it's not empty.
uncons :: MonadReader (Deque a) m => m (Maybe a, Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element and
--   deque without it if it's not empty.
unsnoc :: MonadReader (Deque a) m => m (Maybe a, Deque a)

-- | &lt;math&gt;. Check whether deque is empty.
null :: MonadReader (Deque a) m => m Bool

-- | &lt;math&gt;. Check whether deque is empty.
length :: MonadReader (Deque a) m => m Int

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element if
--   deque is not empty.
head :: MonadReader (Deque a) m => m (Maybe a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element if deque
--   is not empty.
last :: MonadReader (Deque a) m => m (Maybe a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   first one.
tail :: MonadReader (Deque a) m => m (Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   last one.
init :: MonadReader (Deque a) m => m (Deque a)


-- | Strict Deque API lifted to a Reader monad, "mtl"-style.
module Deque.Strict.Reader

-- | &lt;math&gt;. Modify each element of the queue.
map :: MonadReader (Deque a) m => (a -> b) -> m (Deque b)

-- | &lt;math&gt;. Add elements to the begginning.
prepend :: MonadReader (Deque a) m => Deque a -> m (Deque a)

-- | &lt;math&gt;. Add elements to the ending.
append :: MonadReader (Deque a) m => Deque a -> m (Deque a)

-- | &lt;math&gt;. Add element in the beginning.
cons :: MonadReader (Deque a) m => a -> m (Deque a)

-- | &lt;math&gt;. Add element in the ending.
snoc :: MonadReader (Deque a) m => a -> m (Deque a)

-- | &lt;math&gt;. Reverse the deque.
reverse :: MonadReader (Deque a) m => m (Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the first element to the
--   end.
shiftLeft :: MonadReader (Deque a) m => m (Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the last element to the
--   beginning.
shiftRight :: MonadReader (Deque a) m => m (Deque a)

-- | &lt;math&gt;. Leave only the elements satisfying the predicate.
filter :: MonadReader (Deque a) m => (a -> Bool) -> m (Deque a)

-- | &lt;math&gt;. Leave only the specified amount of first elements.
take :: MonadReader (Deque a) m => Int -> m (Deque a)

-- | &lt;math&gt;. Drop the specified amount of first elements.
drop :: MonadReader (Deque a) m => Int -> m (Deque a)

-- | &lt;math&gt;. Leave only the first elements satisfying the predicate.
takeWhile :: MonadReader (Deque a) m => (a -> Bool) -> m (Deque a)

-- | &lt;math&gt;. Drop the first elements satisfying the predicate.
dropWhile :: MonadReader (Deque a) m => (a -> Bool) -> m (Deque a)

-- | &lt;math&gt;. Same as <tt>(,) <a>&lt;$&gt;</a> <a>takeWhile</a>
--   predicate <a>&lt;*&gt;</a> <a>dropWhile</a> predicate</tt>.
span :: MonadReader (Deque a) m => (a -> Bool) -> m (Deque a, Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element and
--   deque without it if it's not empty.
uncons :: MonadReader (Deque a) m => m (Maybe a, Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element and
--   deque without it if it's not empty.
unsnoc :: MonadReader (Deque a) m => m (Maybe a, Deque a)

-- | &lt;math&gt;. Check whether deque is empty.
null :: MonadReader (Deque a) m => m Bool

-- | &lt;math&gt;. Check whether deque is empty.
length :: MonadReader (Deque a) m => m Int

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element if
--   deque is not empty.
head :: MonadReader (Deque a) m => m (Maybe a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element if deque
--   is not empty.
last :: MonadReader (Deque a) m => m (Maybe a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   first one.
tail :: MonadReader (Deque a) m => m (Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   last one.
init :: MonadReader (Deque a) m => m (Deque a)


-- | Strict Deque API lifted to a State monad, "mtl"-style.
module Deque.Strict.State

-- | &lt;math&gt;. Modify each element of the queue.
map :: MonadState (Deque a) m => (a -> a) -> m ()

-- | &lt;math&gt;. Add elements to the begginning.
prepend :: MonadState (Deque a) m => Deque a -> m ()

-- | &lt;math&gt;. Add elements to the ending.
append :: MonadState (Deque a) m => Deque a -> m ()

-- | &lt;math&gt;. Add element in the beginning.
cons :: MonadState (Deque a) m => a -> m ()

-- | &lt;math&gt;. Add element in the ending.
snoc :: MonadState (Deque a) m => a -> m ()

-- | &lt;math&gt;. Reverse the deque.
reverse :: MonadState (Deque a) m => m ()

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the first element to the
--   end.
shiftLeft :: MonadState (Deque a) m => m ()

-- | &lt;math&gt;, occasionally &lt;math&gt;. Move the last element to the
--   beginning.
shiftRight :: MonadState (Deque a) m => m ()

-- | &lt;math&gt;. Leave only the elements satisfying the predicate.
filter :: MonadState (Deque a) m => (a -> Bool) -> m ()

-- | &lt;math&gt;. Leave only the specified amount of first elements.
take :: MonadState (Deque a) m => Int -> m ()

-- | &lt;math&gt;. Drop the specified amount of first elements.
drop :: MonadState (Deque a) m => Int -> m ()

-- | &lt;math&gt;. Leave only the first elements satisfying the predicate.
takeWhile :: MonadState (Deque a) m => (a -> Bool) -> m ()

-- | &lt;math&gt;. Drop the first elements satisfying the predicate.
dropWhile :: MonadState (Deque a) m => (a -> Bool) -> m ()

-- | &lt;math&gt;. Return the first elements satisfying the predicate,
--   removing them from the state.
span :: MonadState (Deque a) m => (a -> Bool) -> m (Deque a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element if
--   deque is not empty, removing the element.
uncons :: MonadState (Deque a) m => m (Maybe a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element if deque
--   is not empty, removing the element.
unsnoc :: MonadState (Deque a) m => m (Maybe a)

-- | &lt;math&gt;. Check whether deque is empty.
null :: MonadState (Deque a) m => m Bool

-- | &lt;math&gt;. Check whether deque is empty.
length :: MonadState (Deque a) m => m Int

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the first element if
--   deque is not empty.
head :: MonadState (Deque a) m => m (Maybe a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Get the last element if deque
--   is not empty.
last :: MonadState (Deque a) m => m (Maybe a)

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   first one.
tail :: MonadState (Deque a) m => m ()

-- | &lt;math&gt;, occasionally &lt;math&gt;. Keep all elements but the
--   last one.
init :: MonadState (Deque a) m => m ()
