-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package ouroboros-network-framework
@version 0.1.0.1

module Data.Cache

-- | Cache newtype wrapper allows to perform an action only if the cache is
--   not up-to-date, i.e. different than another value dimmed more recent.
newtype Cache a
Cache :: a -> Cache a
[getCache] :: Cache a -> a

-- | Run a computation that depends on a certain cached value, only if the
--   the most recent one is different.
withCacheA :: (Applicative m, Eq a) => Cache a -> a -> (a -> m ()) -> m ()

-- | Trace with cache only performs the tracing when the cached value is
--   different than the most recent one.
traceWithCache :: (Applicative m, Eq a) => Tracer m a -> Cache a -> a -> m ()

-- | Trace with cache only performs the tracing when the cached value is
--   different than the most recent one. And applies a function to the
--   cache value before tracing.
mapTraceWithCache :: (Applicative m, Eq a) => (a -> b) -> Tracer m b -> Cache a -> a -> m ()
instance GHC.Base.Functor Data.Cache.Cache
instance GHC.Base.Monoid a => GHC.Base.Monoid (Data.Cache.Cache a)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Data.Cache.Cache a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Cache.Cache a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Cache.Cache a)


-- | This module is a simplified version of
--   <a>https://hackage.haskell.org/package/smash/docs/Data-Wedge.html#t:Wedge</a>,
--   which is copyrighted by Emily Pillmore and originally pulished using
--   BSD-3-Clause license.
--   
--   copyright: Emily Pillmore 2020-2021, iohk 2021
module Data.Wedge

-- | A wedge product
--   <a>https://hackage.haskell.org/package/smash/docs/Data-Wedge.html#t:Wedge</a>
data Wedge a b
Nowhere :: Wedge a b
Here :: a -> Wedge a b
There :: b -> Wedge a b
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Data.Wedge.Wedge a b)
instance GHC.Base.Functor (Data.Wedge.Wedge a)
instance Data.Foldable.Foldable (Data.Wedge.Wedge a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord b) => GHC.Classes.Ord (Data.Wedge.Wedge a b)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b) => GHC.Classes.Eq (Data.Wedge.Wedge a b)
instance Data.Bifunctor.Bifunctor Data.Wedge.Wedge
instance Data.Bifoldable.Bifoldable Data.Wedge.Wedge
instance Data.Bitraversable.Bitraversable Data.Wedge.Wedge
instance GHC.Base.Applicative (Data.Wedge.Wedge a)
instance GHC.Base.Monad (Data.Wedge.Wedge a)

module Ouroboros.Network.Channel

-- | One end of a duplex channel. It is a reliable, ordered channel of some
--   medium. The medium does not imply message boundaries, it can be just
--   bytes.
data Channel m a
Channel :: (a -> m ()) -> m (Maybe a) -> Channel m a

-- | Write output to the channel.
--   
--   It may raise exceptions (as appropriate for the monad and kind of
--   channel).
[send] :: Channel m a -> a -> m ()

-- | Read some input from the channel, or <tt>Nothing</tt> to indicate EOF.
--   
--   Note that having received EOF it is still possible to send. The EOF
--   condition is however monotonic.
--   
--   It may raise exceptions (as appropriate for the monad and kind of
--   channel).
[recv] :: Channel m a -> m (Maybe a)
toChannel :: Channel m ByteString -> Channel m
fromChannel :: Channel m -> Channel m ByteString

-- | Create a local pipe, with both ends in this process, and expose that
--   as a pair of <a>Channel</a>s, one for each end.
--   
--   This is primarily for testing purposes since it does not allow actual
--   IPC.
createPipeConnectedChannels :: IO (Channel IO ByteString, Channel IO ByteString)
hoistChannel :: (forall x. m x -> n x) -> Channel m a -> Channel n a

-- | Given an isomorphism between <tt>a</tt> and <tt>b</tt> (in Kleisli
--   category), transform a <tt><a>Channel</a> m a</tt> into
--   <tt><a>Channel</a> m b</tt>.
isoKleisliChannel :: forall a b m. Monad m => (a -> m b) -> (b -> m a) -> Channel m a -> Channel m b

-- | A <a>Channel</a> with a fixed input, and where all output is
--   discarded.
--   
--   The input is guaranteed to be supplied via <a>read</a> with the given
--   chunk boundaries.
--   
--   This is only useful for testing. In particular the fixed chunk
--   boundaries can be used to test that framing and other codecs work with
--   any possible chunking.
fixedInputChannel :: MonadSTM m => [a] -> m (Channel m a)

-- | Make a <a>Channel</a> from a pair of <a>TMVar</a>s, one for reading
--   and one for writing.
mvarsAsChannel :: MonadSTM m => TMVar m a -> TMVar m a -> Channel m a

-- | Make a <a>Channel</a> from a pair of IO <tt>Handle</tt>s, one for
--   reading and one for writing.
--   
--   The Handles should be open in the appropriate read or write mode, and
--   in binary mode. Writes are flushed after each write, so it is safe to
--   use a buffering mode.
--   
--   For bidirectional handles it is safe to pass the same handle for both.
handlesAsChannel :: Handle -> Handle -> Channel IO ByteString

-- | Create a pair of channels that are connected via one-place buffers.
--   
--   This is primarily useful for testing protocols.
createConnectedChannels :: MonadSTM m => m (Channel m a, Channel m a)

-- | Create a pair of channels that are connected via N-place buffers.
--   
--   This variant <i>blocks</i> when <a>send</a> would exceed the maximum
--   buffer size. Use this variant when you want the environment rather
--   than the <tt>Peer</tt> to limit the pipelining.
--   
--   This is primarily useful for testing protocols.
createConnectedBufferedChannels :: forall m a. MonadSTM m => Natural -> m (Channel m a, Channel m a)

-- | As <a>createConnectedBufferedChannels</a>, but in <a>STM</a>.
--   
--   TODO: it should return a pair of `Channel m a`.
createConnectedBufferedChannelsSTM :: MonadSTM m => Natural -> STM m (Channel (STM m) a, Channel (STM m) a)

-- | Create a pair of channels that are connected via N-place buffers.
--   
--   This variant <i>fails</i> when <a>send</a> would exceed the maximum
--   buffer size. Use this variant when you want the <tt>PeerPipelined</tt>
--   to limit the pipelining itself, and you want to check that it does not
--   exceed the expected level of pipelining.
--   
--   This is primarily useful for testing protocols.
createPipelineTestChannels :: MonadSTM m => Natural -> m (Channel m a, Channel m a)

-- | Transform a channel to add an extra action before <i>every</i> send
--   and after <i>every</i> receive.
channelEffect :: forall m a. Monad m => (a -> m ()) -> (Maybe a -> m ()) -> Channel m a -> Channel m a

-- | Delay a channel on the receiver end.
--   
--   This is intended for testing, as a crude approximation of network
--   delays. More accurate models along these lines are of course possible.
delayChannel :: (MonadSTM m, MonadTimer m) => DiffTime -> Channel m a -> Channel m a

-- | Channel which logs sent and received messages.
loggingChannel :: (MonadSay m, Show id, Show a) => id -> Channel m a -> Channel m a

module Ouroboros.Network.CodecCBORTerm

-- | A pure codec which encodes to / decodes from <a>Term</a>. This is
--   useful if one expects a valid <tt>cbor</tt> encoding, which one might
--   not know how to decode like in the <tt>Handshake</tt> protocol.
data CodecCBORTerm fail a
CodecCBORTerm :: (a -> Term) -> (Term -> Either fail a) -> CodecCBORTerm fail a
[encodeTerm] :: CodecCBORTerm fail a -> a -> Term
[decodeTerm] :: CodecCBORTerm fail a -> Term -> Either fail a

module Ouroboros.Network.ConnectionId

-- | Connection is identified by local and remote address.
--   
--   TODO: the type variable which this data type fills in is called
--   <tt>peerid</tt>. We should renamed to <tt>connectionId</tt>.
data ConnectionId addr
ConnectionId :: !addr -> !addr -> ConnectionId addr
[localAddress] :: ConnectionId addr -> !addr
[remoteAddress] :: ConnectionId addr -> !addr
instance Data.Typeable.Internal.Typeable addr => NoThunks.Class.NoThunks (Ouroboros.Network.ConnectionId.ConnectionId addr)
instance GHC.Generics.Generic (Ouroboros.Network.ConnectionId.ConnectionId addr)
instance GHC.Show.Show addr => GHC.Show.Show (Ouroboros.Network.ConnectionId.ConnectionId addr)
instance GHC.Classes.Ord addr => GHC.Classes.Ord (Ouroboros.Network.ConnectionId.ConnectionId addr)
instance GHC.Classes.Eq addr => GHC.Classes.Eq (Ouroboros.Network.ConnectionId.ConnectionId addr)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Ouroboros.Network.ConnectionId.ConnectionId a)


-- | A shim layer for `Win32-network`'s <a>IOManager</a>
module Ouroboros.Network.IOManager


-- | Singletons to work with <a>MuxMode</a> kind.
module Ouroboros.Network.MuxMode

-- | Singletons for matching the <a>MuxMode</a> at term level.
data SingMuxMode (mode :: MuxMode)
[SingInitiatorMode] :: SingMuxMode InitiatorMode
[SingResponderMode] :: SingMuxMode ResponderMode
[SingInitiatorResponderMode] :: SingMuxMode InitiatorResponderMode

-- | Singleton for to match the <tt><a>HasInitiator</a> mode ~ True</tt>
--   constraint.
data SingHasInitiator (mode :: MuxMode)
[SingHasInitiator] :: HasInitiator mode ~ True => SingHasInitiator mode
[SingNoInitiator] :: HasInitiator mode ~ False => SingHasInitiator mode
hasInitiatorMode :: SingMuxMode mode -> SingHasInitiator mode
data WithMuxMode (mode :: MuxMode) a b
[WithInitiatorMode] :: a -> WithMuxMode InitiatorMode a b
[WithResponderMode] :: b -> WithMuxMode ResponderMode a b
[WithInitiatorResponderMode] :: a -> b -> WithMuxMode InitiatorResponderMode a b
type WithMuxTuple mode a = WithMuxMode mode a a
withInitiatorMode :: HasInitiator mode ~ True => WithMuxMode mode a b -> a
withResponderMode :: HasResponder mode ~ True => WithMuxMode mode a b -> b
data InResponderMode (mode :: MuxMode) a
[InResponderMode] :: HasResponder mode ~ True => a -> InResponderMode mode a
[NotInResponderMode] :: InResponderMode mode a


-- | Connection manager core types.
--   
--   Connection manager is responsible for managing uni- and bi-directional
--   connections and threads which are running network applications using
--   'network-mux'. In particular it is responsible for:
--   
--   <ul>
--   <li>opening new connection / reusing connections (for bidirectional
--   connections) and exposes a method to register inbound
--   connections;</li>
--   <li>run connection handler, i.e. <a>ConnectionHandler</a>, which runs
--   handshake negotiation, notifies connection manager on the results and
--   starts the multiplexer;</li>
--   <li>error handling for connection threads;</li>
--   <li>keeping track of handshake negotiation: whether a unidirectional
--   or duplex connection was negotiated;</li>
--   <li>tracking state of each connection;</li>
--   <li>keep inbound connections under limits.</li>
--   </ul>
--   
--   Connection manager is designed to work for any <a>MuxMode</a>, though
--   the most useful ones are <a>ResponderMode</a> and
--   <a>InitiatorResponderMode</a>:
--   
--   <ul>
--   <li><a>InitiatorResponderMode</a> - useful for node-to-node
--   applications, which needs to create outbound connections as well as
--   accept inbound ones;</li>
--   <li><a>ResponderMode</a> - useful for server side of node-to-client;
--   it allows us to share the same server between node-to-client and
--   node-to-node;</li>
--   <li><a>InitiatorMode</a> - could be used on client side of
--   node-to-client applications.</li>
--   </ul>
--   
--   The calls <a>requestOutboundConnection</a> and
--   <a>includeInboundConnection</a> return once a connection has been
--   negotiated. The returned <a>handle</a> contains all the information
--   that is need to start and monitor mini-protocols through the mux
--   interface.
--   
--   For inbound connections, the connection manager will pass handle (also
--   after negotiation).
--   
--   <pre>
--   ┌────────────────────────┐
--   │                        │        ┏━━━━━━━━━━━━━━━━┓     ┌──────────────────┐
--   │   ConnectionHandler    │        ┃                ┃     │                  │
--   │                        ┝━━━━━━━▶┃     handle     ┣━━━━▶│ PeerStateActions ├───▶ P2P Governor
--   │  inbound / outbound    │        ┃                ┃     │                  │
--   │         ┃              │        ┗━━┳━━━━━━━━━━━━━┛     └──────────────────┘
--   └─────────╂──────────────┘           ┃
--             ┃                          ┃
--             ▼                          ┃
--      ┏━━━━━━━━━━━━━━━━━┓               ┃
--      ┃ Control Channel ┃               ┃
--      ┗━━━━━━┳━━━━━━━━━━┛               ┃
--             ┃                          ┃
--             ┃                          ┃
--             ▼                          ┃
--   ┌────────────────────────┐           ┃
--   │                        │           ┃
--   │         Server         │◀━━━━━━━━━━┛
--   │                        │
--   └────────────────────────┘
--   </pre>
--   
--   Termination procedure as well as connection state machine is not
--   described in this haddock, see associated specification.
module Ouroboros.Network.ConnectionManager.Types

-- | Connection manager supports <tt>IPv4</tt> and <tt>IPv6</tt> addresses.
data AddressType
IPv4Address :: AddressType
IPv6Address :: AddressType

-- | Each connection is is either initiated locally (outbound) or by a
--   remote peer (inbound).
data Provenance

-- | An inbound connection: one that was initiated by a remote peer.
Inbound :: Provenance

-- | An outbound connection: one that was initiated by us.
Outbound :: Provenance

-- | Each connection negotiates if it is uni- or bi-directional.
--   <a>DataFlow</a> is a life time property of a connection, once
--   negotiated it never changes.
data DataFlow
Unidirectional :: DataFlow
Duplex :: DataFlow

-- | Boolean like type which indicates if the timeout on
--   <tt>OutboundStateDuplex</tt> has expired.
data TimeoutExpired
Expired :: TimeoutExpired
Ticking :: TimeoutExpired

-- | Either unnegotiated or negotiated unidirectional or duplex
--   connections. This is not a static property of a connection. It is used
--   by <a>PrunePolicy</a>.
--   
--   Note: the order matters, it can be used by a <tt>PickPolicy</tt>, e.g.
--   <tt>simplePickPolicy</tt>.
data ConnectionType

-- | An unnegotiated connection.
UnnegotiatedConn :: !Provenance -> ConnectionType

-- | An inbound idle connection.
InboundIdleConn :: !DataFlow -> ConnectionType

-- | An outbound idle connection.
OutboundIdleConn :: !DataFlow -> ConnectionType

-- | A negotiated connection, which is used in only one direction indicated
--   by <a>Provenance</a>. The connection could itself negotiated either
--   <a>Duplex</a> or <a>Unidirectional</a> data flow.
NegotiatedConn :: !Provenance -> !DataFlow -> ConnectionType

-- | A connection which is running in full duplex mode.
DuplexConn :: ConnectionType

-- | Handler action is started with asynchronous exceptions masked; this
--   allows to install exception handlers in an async-safe way.
newtype MaskedAction m a
MaskedAction :: ((forall x. m x -> m x) -> m a) -> MaskedAction m a
[runWithUnmask] :: MaskedAction m a -> (forall x. m x -> m x) -> m a

-- | MaskedAction which is executed by thread designated for a given
--   connection.
--   
--   <a>PromiseWriter</a> allows to notify the <a>ConnectionManager</a>
--   about the result of handshake negotiation.
--   
--   Note: <a>PromiseWriter</a> could be replaced with an stm action which
--   is accessing the <tt>TVar</tt> which holds state of the connection.
type ConnectionHandlerFn handlerTrace socket peerAddr handle handleError version m = socket -> PromiseWriter m (Either handleError (handle, version)) -> Tracer m handlerTrace -> ConnectionId peerAddr -> (DiffTime -> socket -> m (MuxBearer m)) -> MaskedAction m ()

-- | Connection handler action. It is index by <tt>muxMode ::
--   <a>MuxMode</a></tt>. There's one <a>ConnectionHandlerFn</a> per
--   provenance, possibly limited by <tt>muxMode</tt>.
data ConnectionHandler muxMode handlerTrace socket peerAddr handle handleError version m
ConnectionHandler :: WithMuxTuple muxMode (ConnectionHandlerFn handlerTrace socket peerAddr handle handleError version m) -> ConnectionHandler muxMode handlerTrace socket peerAddr handle handleError version m

-- | Connection handler.
[connectionHandler] :: ConnectionHandler muxMode handlerTrace socket peerAddr handle handleError version m -> WithMuxTuple muxMode (ConnectionHandlerFn handlerTrace socket peerAddr handle handleError version m)

-- | Boolean like type
data Inactive
Active :: MiniProtocolDir -> Inactive
Inactive :: Inactive

-- | Exception which where caught in the connection thread and were
--   re-thrown in the main thread by the <tt>rethrowPolicy</tt>.
data ExceptionInHandler peerAddr
[ExceptionInHandler] :: !peerAddr -> !SomeException -> ExceptionInHandler peerAddr

-- | Data type used to classify <tt>handleErrors</tt>.
data HandleErrorType

-- | Handshake negotiation failed. This is not a protocol error.
HandshakeFailure :: HandleErrorType

-- | Handshake protocol error. This should include timeout errors or any IO
--   errors.
HandshakeProtocolViolation :: HandleErrorType

-- | <a>PrunePolicy</a> allows to pick a select peers from which we will
--   disconnect (we use <tt>TCP</tt> reset). The chosen connections will be
--   terminated by the connection manger once it detects that there are too
--   many inbound connections.
type PrunePolicy peerAddr stm = Map peerAddr ConnectionType -> Int -> stm (Set peerAddr)

-- | The simplest <a>PrunePolicy</a>, it should only be used for tests.
simplePrunePolicy :: (Applicative stm, Ord peerAddr) => PrunePolicy peerAddr stm

-- | <a>ConnectionManager</a>.
--   
--   We identify resources (e.g. <a>Socket</a> or <a>HANDLE</a>) by their
--   address. It is enough for us to use just the remote address rather
--   than connection identifier, since we need one connection towards that
--   peer, even if we are connected through multiple local addresses. It is
--   safe to share a connection manager with multiple listening sockets.
data ConnectionManager (muxMode :: MuxMode) socket peerAddr handle handleError m
ConnectionManager :: WithMuxMode muxMode (OutboundConnectionManager muxMode socket peerAddr handle handleError m) (InboundConnectionManager muxMode socket peerAddr handle handleError m) -> m (Map peerAddr AbstractState) -> ConnectionManager (muxMode :: MuxMode) socket peerAddr handle handleError m
[getConnectionManager] :: ConnectionManager (muxMode :: MuxMode) socket peerAddr handle handleError m -> WithMuxMode muxMode (OutboundConnectionManager muxMode socket peerAddr handle handleError m) (InboundConnectionManager muxMode socket peerAddr handle handleError m)
[readState] :: ConnectionManager (muxMode :: MuxMode) socket peerAddr handle handleError m -> m (Map peerAddr AbstractState)

-- | Result of <a>requestOutboundConnection</a> or
--   <a>includeInboundConnection</a>.
data Connected peerAddr handle handleError

-- | We are connected and mux is running.
Connected :: !ConnectionId peerAddr -> !DataFlow -> !handle -> Connected peerAddr handle handleError

-- | There was an error during handshake negotiation.
--   
--   <i>Implementation detail:</i> we return <tt><a>Maybe</a>
--   handleError</tt>, rather than <tt>handleError</tt>. In case of an
--   existing inbound connection, the implementation of
--   <a>requestOutboundConnection</a> is awaiting on handshake through the
--   connection state. The <tt>TerminatingState</tt> or
--   <tt>TerminatedState</tt> are not only used for handshake errors, but
--   also for normal termination, hence the <tt><a>Maybe</a></tt>. We could
--   await on update from the handshake instead, but this would introduce a
--   race between inbound / outbound threads.
Disconnected :: !ConnectionId peerAddr -> !Maybe handleError -> Connected peerAddr handle handleError

-- | Custom either type for result of various methods.
data OperationResult a
UnsupportedState :: !AbstractState -> OperationResult a
OperationSuccess :: !a -> OperationResult a
TerminatedConnection :: !AbstractState -> OperationResult a
resultInState :: OperationResult AbstractState -> AbstractState

-- | Return value of <a>unregisterInboundConnection</a> to inform the
--   caller about the transition.
data DemotedToColdRemoteTr

-- | <tt>Commit^{dataFlow}</tt> transition from
--   <tt><tt>InboundIdleState</tt> dataFlow</tt>.
CommitTr :: DemotedToColdRemoteTr

-- | Either <tt>DemotedToCold^{Remote}</tt> transition from
--   <tt><tt>DuplexState</tt></tt>, or a level triggered
--   <tt>Awake^{Duplex}_{Local}</tt> transition. In both cases the server
--   must keep the responder side of all protocols ready.
KeepTr :: DemotedToColdRemoteTr
type RequestOutboundConnection peerAddr handle handleError m = peerAddr -> m (Connected peerAddr handle handleError)
type IncludeInboundConnection socket peerAddr handle handleError m = Word32 " inbound connections hard limit. NOTE: Check TODO over at includeInboundConnectionImpl definition." -> socket -> peerAddr -> m (Connected peerAddr handle handleError)

-- | Include outbound connection into <a>ConnectionManager</a>.
--   
--   This executes:
--   
--   <ul>
--   <li>&lt;math&gt; to &lt;math&gt; transitions</li>
--   <li>&lt;math&gt; transition</li>
--   <li>&lt;math&gt; transition</li>
--   </ul>
requestOutboundConnection :: HasInitiator muxMode ~ True => ConnectionManager muxMode socket peerAddr handle handleError m -> RequestOutboundConnection peerAddr handle handleError m

-- | Notify the <a>ConnectionManager</a> that a remote end promoted us to a
--   <i>warm peer</i>.
--   
--   This executes either:
--   
--   <ul>
--   <li>&lt;math&gt; transition,</li>
--   <li>&lt;math&gt; transition</li>
--   </ul>
--   
--   from the specification.
promotedToWarmRemote :: HasResponder muxMode ~ True => ConnectionManager muxMode socket peerAddr handle handleError m -> peerAddr -> m (OperationResult AbstractState)

-- | Notify the <a>ConnectionManager</a> that a remote end demoted us to a
--   /cold peer/.
--   
--   This executes:
--   
--   <ul>
--   <li>&lt;math&gt; transition.</li>
--   </ul>
--   
--   This method is idempotent.
demotedToColdRemote :: HasResponder muxMode ~ True => ConnectionManager muxMode socket peerAddr handle handleError m -> peerAddr -> m (OperationResult AbstractState)

-- | Unregister outbound connection.
--   
--   This executes:
--   
--   <ul>
--   <li>&lt;math&gt; transitions</li>
--   </ul>
unregisterOutboundConnection :: HasInitiator muxMode ~ True => ConnectionManager muxMode socket peerAddr handle handleError m -> peerAddr -> m (OperationResult AbstractState)

-- | Include an inbound connection into <a>ConnectionManager</a>. This
--   executes:
--   
--   <ul>
--   <li>&lt;math&gt; to &lt;math&gt; transitions</li>
--   <li>&lt;math&gt; transition</li>
--   <li>&lt;math&gt; transition</li>
--   </ul>
includeInboundConnection :: HasResponder muxMode ~ True => ConnectionManager muxMode socket peerAddr handle handleError m -> IncludeInboundConnection socket peerAddr handle handleError m

-- | Unregister outbound connection. Returns if the operation was
--   successul.
--   
--   This executes:
--   
--   <ul>
--   <li>&lt;math&gt; transition</li>
--   <li>&lt;math&gt; transition</li>
--   </ul>
unregisterInboundConnection :: HasResponder muxMode ~ True => ConnectionManager muxMode socket peerAddr handle handleError m -> peerAddr -> m (OperationResult DemotedToColdRemoteTr)

-- | Number of connections tracked by the server.
numberOfConnections :: HasResponder muxMode ~ True => ConnectionManager muxMode socket peerAddr handle handleError m -> STM m Int

-- | Outbound connection manager API.
data OutboundConnectionManager (muxMode :: MuxMode) socket peerAddr handle handleError m
[OutboundConnectionManager] :: HasInitiator muxMode ~ True => {ocmRequestConnection :: RequestOutboundConnection peerAddr handle handleError m, ocmUnregisterConnection :: peerAddr -> m (OperationResult AbstractState)} -> OutboundConnectionManager muxMode socket peerAddr handle handleError m

-- | Inbound connection manager API. For a server implementation we also
--   need to know how many connections are now managed by the connection
--   manager.
--   
--   This type is an internal detail of <a>ConnectionManager</a>
data InboundConnectionManager (muxMode :: MuxMode) socket peerAddr handle handleError m
[InboundConnectionManager] :: HasResponder muxMode ~ True => {icmIncludeConnection :: IncludeInboundConnection socket peerAddr handle handleError m, icmUnregisterConnection :: peerAddr -> m (OperationResult DemotedToColdRemoteTr), icmPromotedToWarmRemote :: peerAddr -> m (OperationResult AbstractState), icmDemotedToColdRemote :: peerAddr -> m (OperationResult AbstractState), icmNumberOfConnections :: STM m Int} -> InboundConnectionManager muxMode socket peerAddr handle handleError m

-- | Exceptions used by <a>ConnectionManager</a>.
data ConnectionManagerError peerAddr

-- | A connection manager was asked for an outbound connection and there
--   either exists a connection used in outbound direction or a reservation
--   for an outbound connection.
ConnectionExists :: !Provenance -> !peerAddr -> !CallStack -> ConnectionManagerError peerAddr

-- | Connection manager was asked for an outbound connection which turned
--   out to be unidirectional inbound, and thus it cannot be re-used..
ForbiddenConnection :: !ConnectionId peerAddr -> !CallStack -> ConnectionManagerError peerAddr

-- | Connections that would be forbidden by the kernel (<tt>TCP</tt>
--   semantics).
ImpossibleConnection :: !ConnectionId peerAddr -> !CallStack -> ConnectionManagerError peerAddr

-- | Connection is now terminating.
ConnectionTerminating :: !ConnectionId peerAddr -> !CallStack -> ConnectionManagerError peerAddr

-- | Connection has terminated.
ConnectionTerminated :: !peerAddr -> !CallStack -> ConnectionManagerError peerAddr

-- | Connection manager in impossible state.
ImpossibleState :: !peerAddr -> !CallStack -> ConnectionManagerError peerAddr

-- | A forbidden operation in the given connection state.
ForbiddenOperation :: !peerAddr -> !AbstractState -> !CallStack -> ConnectionManagerError peerAddr

-- | A connection does not exists. Only thrown when an existing connection
--   was expected.
UnknownPeer :: !peerAddr -> !CallStack -> ConnectionManagerError peerAddr

-- | Existential wrapper for <tt><a>ConnectionManagerError</a>
--   peerAddr</tt>. It allows to use <a>fromException</a>, without being
--   bothered about the address type.
data SomeConnectionManagerError
SomeConnectionManagerError :: !ConnectionManagerError addr -> SomeConnectionManagerError

-- | Useful for tracing and error messages.
data AbstractState
UnknownConnectionSt :: AbstractState
ReservedOutboundSt :: AbstractState
UnnegotiatedSt :: !Provenance -> AbstractState
InboundIdleSt :: !DataFlow -> AbstractState
InboundSt :: !DataFlow -> AbstractState
OutboundUniSt :: AbstractState
OutboundDupSt :: !TimeoutExpired -> AbstractState
OutboundIdleSt :: !DataFlow -> AbstractState
DuplexSt :: AbstractState
WaitRemoteIdleSt :: AbstractState
TerminatingSt :: AbstractState
TerminatedSt :: AbstractState

-- | Counters for tracing and analysis purposes
data ConnectionManagerCounters
ConnectionManagerCounters :: !Int -> !Int -> !Int -> !Int -> !Int -> ConnectionManagerCounters

-- | number of full duplex connections
[fullDuplexConns] :: ConnectionManagerCounters -> !Int

-- | number of negotiated duplex connections (including DuplexState
--   connections)
[duplexConns] :: ConnectionManagerCounters -> !Int

-- | number of negotiated unidirectional connections
[unidirectionalConns] :: ConnectionManagerCounters -> !Int

-- | number of inbound connections
[inboundConns] :: ConnectionManagerCounters -> !Int

-- | number of outbound connections
[outboundConns] :: ConnectionManagerCounters -> !Int
data WithMuxMode (mode :: MuxMode) a b
[WithInitiatorMode] :: a -> WithMuxMode InitiatorMode a b
[WithResponderMode] :: b -> WithMuxMode ResponderMode a b
[WithInitiatorResponderMode] :: a -> b -> WithMuxMode InitiatorResponderMode a b
withInitiatorMode :: HasInitiator mode ~ True => WithMuxMode mode a b -> a
withResponderMode :: HasResponder mode ~ True => WithMuxMode mode a b -> b
newEmptyPromiseIO :: (MonadSTM m, MonadThrow (STM m)) => m (PromiseReader m a, PromiseWriter m a)
newtype PromiseReader m a
PromiseReader :: STM m a -> PromiseReader m a

-- | A blocking read operation.
[readPromise] :: PromiseReader m a -> STM m a
readPromiseIO :: MonadSTM m => PromiseReader m a -> m a
data PromiseWriter m a
PromiseWriter :: (a -> STM m ()) -> (a -> STM m ()) -> PromiseWriter m a

-- | <tt>putPromise</tt>, is a non-blocking operation, it throws
--   <a>PromiseWriterException</a> if it would block.
[writePromise] :: PromiseWriter m a -> a -> STM m ()

-- | If the promise is empty it fills it, if it is non-empty it replaces
--   the current value.
[forcePromise] :: PromiseWriter m a -> a -> STM m ()
data PromiseWriterException
PromiseWriterBlocked :: PromiseWriterException

-- | <a>AssertionLocation</a> contains constructors that situate the
--   location of the tracing so one can be sure where the assertion came
--   from as well as the all relevant information.
data AssertionLocation peerAddr
UnregisterInboundConnection :: !Maybe (ConnectionId peerAddr) -> !AbstractState -> AssertionLocation peerAddr
RequestOutboundConnection :: !Maybe (ConnectionId peerAddr) -> !AbstractState -> AssertionLocation peerAddr
UnregisterOutboundConnection :: !Maybe (ConnectionId peerAddr) -> !AbstractState -> AssertionLocation peerAddr
PromotedToWarmRemote :: !Maybe (ConnectionId peerAddr) -> !AbstractState -> AssertionLocation peerAddr
DemotedToColdRemote :: !Maybe (ConnectionId peerAddr) -> !AbstractState -> AssertionLocation peerAddr

-- | <a>ConnectionManagerTrace</a> contains a hole for a trace of single
--   connection which is filled with <tt>ConnectionHandlerTrace</tt>.
data ConnectionManagerTrace peerAddr handlerTrace
TrIncludeConnection :: Provenance -> peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrUnregisterConnection :: Provenance -> peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrConnect :: Maybe peerAddr -> peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrConnectError :: Maybe peerAddr -> peerAddr -> SomeException -> ConnectionManagerTrace peerAddr handlerTrace
TrTerminatingConnection :: Provenance -> ConnectionId peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrTerminatedConnection :: Provenance -> peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrConnectionHandler :: ConnectionId peerAddr -> handlerTrace -> ConnectionManagerTrace peerAddr handlerTrace
TrShutdown :: ConnectionManagerTrace peerAddr handlerTrace
TrConnectionExists :: Provenance -> peerAddr -> AbstractState -> ConnectionManagerTrace peerAddr handlerTrace
TrForbiddenConnection :: ConnectionId peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrImpossibleConnection :: ConnectionId peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrConnectionFailure :: ConnectionId peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrConnectionNotFound :: Provenance -> peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrForbiddenOperation :: peerAddr -> AbstractState -> ConnectionManagerTrace peerAddr handlerTrace
TrPruneConnections :: Set peerAddr -> Int -> Set peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrConnectionCleanup :: ConnectionId peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrConnectionTimeWait :: ConnectionId peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrConnectionTimeWaitDone :: ConnectionId peerAddr -> ConnectionManagerTrace peerAddr handlerTrace
TrConnectionManagerCounters :: ConnectionManagerCounters -> ConnectionManagerTrace peerAddr handlerTrace

-- | traced on SIGUSR1 signal, installed in <tt>runDataDiffusion</tt>
TrState :: Map peerAddr AbstractState -> ConnectionManagerTrace peerAddr handlerTrace
TrUnknownConnection :: ConnectionId peerAddr -> ConnectionManagerTrace peerAddr handlerTrace

-- | This case is unexpected at call site.
TrUnexpectedlyFalseAssertion :: AssertionLocation peerAddr -> ConnectionManagerTrace peerAddr handlerTrace

-- | A custom version of <a>Maybe</a> type, which allows to explicitly
--   represent connections which are not registered by the connection
--   manager.
data MaybeUnknown state

-- | Known connection in <tt>state</tt>
Known :: !state -> MaybeUnknown state

-- | There is a possible race condition between connection finalizer and
--   either inbound or outbound connection registration. If that happens we
--   use <a>Race</a> constructor.
Race :: !state -> MaybeUnknown state

-- | Connection is is not known to the connection manager.
Unknown :: MaybeUnknown state
data Transition' state
Transition :: !state -> !state -> Transition' state
[fromState] :: Transition' state -> !state
[toState] :: Transition' state -> !state
type Transition state = Transition' (MaybeUnknown state)
type AbstractTransition = Transition' AbstractState
mkTransition :: state -> state -> Transition state
type TransitionTrace peerAddr state = TransitionTrace' peerAddr (MaybeUnknown state)
data TransitionTrace' peerAddr state
TransitionTrace :: peerAddr -> Transition' state -> TransitionTrace' peerAddr state
[ttPeerAddr] :: TransitionTrace' peerAddr state -> peerAddr
[ttTransition] :: TransitionTrace' peerAddr state -> Transition' state
type AbstractTransitionTrace peerAddr = TransitionTrace' peerAddr AbstractState
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.AddressType
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.Provenance
instance GHC.Classes.Ord Ouroboros.Network.ConnectionManager.Types.Provenance
instance GHC.Classes.Eq Ouroboros.Network.ConnectionManager.Types.Provenance
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.DataFlow
instance GHC.Classes.Ord Ouroboros.Network.ConnectionManager.Types.DataFlow
instance GHC.Classes.Eq Ouroboros.Network.ConnectionManager.Types.DataFlow
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.TimeoutExpired
instance GHC.Classes.Ord Ouroboros.Network.ConnectionManager.Types.TimeoutExpired
instance GHC.Classes.Eq Ouroboros.Network.ConnectionManager.Types.TimeoutExpired
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.ConnectionType
instance GHC.Classes.Ord Ouroboros.Network.ConnectionManager.Types.ConnectionType
instance GHC.Classes.Eq Ouroboros.Network.ConnectionManager.Types.ConnectionType
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.PromiseWriterException
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.Inactive
instance GHC.Classes.Eq Ouroboros.Network.ConnectionManager.Types.Inactive
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.DemotedToColdRemoteTr
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.AbstractState
instance GHC.Classes.Ord Ouroboros.Network.ConnectionManager.Types.AbstractState
instance GHC.Classes.Eq Ouroboros.Network.ConnectionManager.Types.AbstractState
instance GHC.Base.Functor Ouroboros.Network.ConnectionManager.Types.OperationResult
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.ConnectionManager.Types.OperationResult a)
instance GHC.Classes.Ord Ouroboros.Network.ConnectionManager.Types.ConnectionManagerCounters
instance GHC.Classes.Eq Ouroboros.Network.ConnectionManager.Types.ConnectionManagerCounters
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.ConnectionManagerCounters
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.ConnectionManager.Types.ConnectionManagerError peerAddr)
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.ConnectionManager.Types.AssertionLocation peerAddr)
instance (GHC.Show.Show peerAddr, GHC.Show.Show handlerTrace) => GHC.Show.Show (Ouroboros.Network.ConnectionManager.Types.ConnectionManagerTrace peerAddr handlerTrace)
instance GHC.Base.Functor Ouroboros.Network.ConnectionManager.Types.MaybeUnknown
instance GHC.Show.Show state => GHC.Show.Show (Ouroboros.Network.ConnectionManager.Types.MaybeUnknown state)
instance GHC.Base.Functor Ouroboros.Network.ConnectionManager.Types.Transition'
instance GHC.Classes.Eq state => GHC.Classes.Eq (Ouroboros.Network.ConnectionManager.Types.Transition' state)
instance GHC.Base.Functor (Ouroboros.Network.ConnectionManager.Types.TransitionTrace' peerAddr)
instance (GHC.Show.Show peerAddr, GHC.Show.Show state) => GHC.Show.Show (Ouroboros.Network.ConnectionManager.Types.TransitionTrace' peerAddr state)
instance GHC.Show.Show state => GHC.Show.Show (Ouroboros.Network.ConnectionManager.Types.Transition' state)
instance GHC.Show.Show Ouroboros.Network.ConnectionManager.Types.SomeConnectionManagerError
instance GHC.Exception.Type.Exception Ouroboros.Network.ConnectionManager.Types.SomeConnectionManagerError
instance (GHC.Show.Show peerAddr, Data.Typeable.Internal.Typeable peerAddr) => GHC.Exception.Type.Exception (Ouroboros.Network.ConnectionManager.Types.ConnectionManagerError peerAddr)
instance GHC.Base.Semigroup Ouroboros.Network.ConnectionManager.Types.ConnectionManagerCounters
instance GHC.Base.Monoid Ouroboros.Network.ConnectionManager.Types.ConnectionManagerCounters
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.ConnectionManager.Types.ExceptionInHandler peerAddr)
instance (GHC.Show.Show peerAddr, Data.Typeable.Internal.Typeable peerAddr) => GHC.Exception.Type.Exception (Ouroboros.Network.ConnectionManager.Types.ExceptionInHandler peerAddr)
instance GHC.Exception.Type.Exception Ouroboros.Network.ConnectionManager.Types.PromiseWriterException

module Ouroboros.Network.Protocol.Handshake.Version

-- | The version map supported by the local agent keyed on the version
--   identifier.
--   
--   Each <a>Version</a> contains a function which takes negotiated version
--   data and returns negotiated application (the <tt>r</tt> type
--   variable).
--   
--   If one needs to combine multiple versions the simplest way is to use
--   one of the combinators: <a>foldMapVersions</a>, <a>combineVersions</a>
--   or the <a>Semigroup</a> instance directly:
--   
--   <pre>
--   fold $ (simpleSingletonVersions ...)
--         :| [ (simpleSingletonVersions ...)
--            , (simpleSingletonVersions ...)
--            , ...
--            ]
--   </pre>
newtype Versions vNum vData r
Versions :: Map vNum (Version vData r) -> Versions vNum vData r
[getVersions] :: Versions vNum vData r -> Map vNum (Version vData r)
data Version vData r
Version :: (vData -> r) -> vData -> Version vData r
[versionApplication] :: Version vData r -> vData -> r
[versionData] :: Version vData r -> vData

-- | A <tt><a>Maybe</a></tt> like type which better explains its purpose.
data Accept vData
Accept :: vData -> Accept vData
Refuse :: !Text -> Accept vData
class Acceptable v
acceptableVersion :: Acceptable v => v -> v -> Accept v
data VersionMismatch vNum
[NoCommonVersion] :: VersionMismatch vNum
[InconsistentVersion] :: vNum -> VersionMismatch vNum

-- | Singleton smart constructor for <a>Versions</a>.
simpleSingletonVersions :: vNum -> vData -> r -> Versions vNum vData r

-- | Useful for folding multiple <a>Versions</a>.
--   
--   A <a>foldMap</a> restricted to the <a>Versions</a> <a>Semigroup</a>.
--   
--   PRECONDITION: <tt>f x</tt> is non-empty.
foldMapVersions :: (Ord vNum, Foldable f, HasCallStack) => (x -> Versions vNum extra r) -> f x -> Versions vNum extra r
combineVersions :: (Ord vNum, Foldable f, HasCallStack) => f (Versions vNum extra r) -> Versions vNum extra r
instance GHC.Show.Show vData => GHC.Show.Show (Ouroboros.Network.Protocol.Handshake.Version.Accept vData)
instance GHC.Classes.Eq vData => GHC.Classes.Eq (Ouroboros.Network.Protocol.Handshake.Version.Accept vData)
instance GHC.Base.Functor (Ouroboros.Network.Protocol.Handshake.Version.Version vData)
instance GHC.Classes.Ord vNum => GHC.Base.Semigroup (Ouroboros.Network.Protocol.Handshake.Version.Versions vNum vData r)
instance GHC.Base.Functor (Ouroboros.Network.Protocol.Handshake.Version.Versions vNum extra)


-- | Common values for size and time limits used by ourobors-network.
module Ouroboros.Network.Protocol.Limits
largeByteLimit :: Word
smallByteLimit :: Word
shortWait :: Maybe DiffTime
longWait :: Maybe DiffTime
waitForever :: Maybe DiffTime


-- | Rethrow policy for <tt>MuxConnectionHandler</tt>.
--   
--   Connection manager has a centralised way of handling exceptions.
--   <a>RethrowPolicy</a> is a way to decided wheather it is enough to
--   shutdown connection or the node should shut down itself. Theis
--   mechanism is affected by the design choices in the mutliplexer.
--   
--   Whenever a mini-protocol throws an exception, the bearer is closed.
--   There is no way to recover a bidirectional connection if one side
--   failed, in such way that the other end could still re-use it, e.g. if
--   the initiator throws, we cannot just restart it on the same bearer,
--   since there might be unconsumed bytes on the other end.
--   
--   <a>RethrowPolicy</a> is supplied to <tt>makeMuxConnectionHandler</tt>
--   which creates both the action that runs on each connection and error
--   handler. Error handler is attached by the connection manager (see
--   <a>Core</a>). This error handler is using <a>RethrowPolicy</a>.
--   
--   This mechanism is enough for both:
--   
--   <ul>
--   <li>the server implemented in <a>Server</a>,</li>
--   <li><tt>PeerStateActions</tt> used by peer-to-peer governor.</li>
--   </ul>
--   
--   Since both start mini-protocols with <tt>runMiniProtocol</tt> they can
--   also have access to the result / exception thrown of a mini-protocol.
--   <tt>PeerStateActions</tt> are only using this to inform the governor
--   that the peer transitioned to <tt>PeerCold</tt> or to deactivate the
--   peer.
module Ouroboros.Network.RethrowPolicy
newtype RethrowPolicy
RethrowPolicy :: RethrowPolicy_ -> RethrowPolicy
[runRethrowPolicy] :: RethrowPolicy -> RethrowPolicy_

-- | Smart constructor for <a>RethrowPolicy</a>.
mkRethrowPolicy :: forall e. Exception e => (ErrorContext -> e -> ErrorCommand) -> RethrowPolicy
data ErrorCommand

-- | Shutdown node.
ShutdownNode :: ErrorCommand

-- | Shutdown connection with the peer.
ShutdownPeer :: ErrorCommand

-- | Weather an exception happend on outbound or inbound connection.
--   
--   TODO: It would be more useful to have access weather the exception
--   happend on initiator or responder. The easiest way to fix this is make
--   mux throw the exception together with context. This allows to keep
--   error handling be done only by the connection manager (rather than by
--   server and <tt>PeerStateActions</tt>).
data ErrorContext
OutboundError :: ErrorContext
InboundError :: ErrorContext
muxErrorRethrowPolicy :: RethrowPolicy
ioErrorRethrowPolicy :: RethrowPolicy
instance GHC.Show.Show Ouroboros.Network.RethrowPolicy.ErrorCommand
instance GHC.Show.Show Ouroboros.Network.RethrowPolicy.ErrorContext
instance GHC.Base.Monoid Ouroboros.Network.RethrowPolicy.RethrowPolicy
instance GHC.Base.Semigroup Ouroboros.Network.RethrowPolicy.RethrowPolicy
instance GHC.Base.Semigroup Ouroboros.Network.RethrowPolicy.ErrorCommand
instance GHC.Base.Monoid Ouroboros.Network.RethrowPolicy.ErrorCommand

module Ouroboros.Network.Server.ConnectionTable
data ConnectionTable m addr
data ConnectionTableRef

-- | No connection to peer exists, attempt to create one.
ConnectionTableCreate :: ConnectionTableRef

-- | A connection to the peer existed, either from another subscriber or
--   the peer opened one towards us.
ConnectionTableExist :: ConnectionTableRef

-- | This subscriber already has counted a connection to this peer. It must
--   try another target.
ConnectionTableDuplicate :: ConnectionTableRef

-- | ValencyCounter represents how many active connections we have towards
--   a given peer. It starts out with a positive value representing a
--   desired number of connections for a specific subscription worker. It
--   can become negative, for example if a peer opens multiple connections
--   to us. The vcId is unique per ConnectionTable and ensures that we
--   won't count the same connection twice.
data ValencyCounter m

-- | Create a new ConnectionTable.
newConnectionTableSTM :: MonadSTM m => STM m (ConnectionTable m addr)
newConnectionTable :: MonadSTM m => m (ConnectionTable m addr)

-- | Try to see if it is possible to reference an existing connection
--   rather than creating a new one to the provied peer.
refConnectionSTM :: (MonadSTM m, Ord addr) => ConnectionTable m addr -> addr -> ValencyCounter m -> STM m ConnectionTableRef
refConnection :: (MonadSTM m, Ord addr) => ConnectionTable m addr -> addr -> ValencyCounter m -> m ConnectionTableRef

-- | Insert a new connection into the ConnectionTable.
addConnection :: forall m addr. (MonadSTM m, Ord addr) => ConnectionTable m addr -> addr -> addr -> Maybe (ValencyCounter m) -> STM m ()

-- | Remove a Connection.
removeConnectionSTM :: forall m addr. (MonadSTM m, Ord addr) => ConnectionTable m addr -> addr -> addr -> STM m ()
removeConnection :: forall m addr. (MonadSTM m, Ord addr) => ConnectionTable m addr -> addr -> addr -> m ()

-- | Create a new ValencyCounter
newValencyCounter :: MonadSTM m => ConnectionTable m addr -> Int -> STM m (ValencyCounter m)

-- | Add a connection.
addValencyCounter :: MonadSTM m => ValencyCounter m -> STM m ()

-- | Remove a connection.
remValencyCounter :: MonadSTM m => ValencyCounter m -> STM m ()

-- | Wait until ValencyCounter becomes positive, used for detecting when we
--   can create new connections.
waitValencyCounter :: MonadSTM m => ValencyCounter m -> STM m ()

-- | Returns current ValencyCounter value, represent the number of
--   additional connections that can be created. May be negative.
readValencyCounter :: MonadSTM m => ValencyCounter m -> STM m Int
instance GHC.Show.Show Ouroboros.Network.Server.ConnectionTable.ConnectionTableRef
instance GHC.Classes.Ord (Ouroboros.Network.Server.ConnectionTable.ValencyCounter m)
instance GHC.Classes.Eq (Ouroboros.Network.Server.ConnectionTable.ValencyCounter m)


-- | Rage limiting of accepted connections
module Ouroboros.Network.Server.RateLimiting

-- | Policy which governs how to limit the number of accepted connections.
data AcceptedConnectionsLimit
AcceptedConnectionsLimit :: !Word32 -> !Word32 -> !DiffTime -> AcceptedConnectionsLimit

-- | Hard limit of accepted connections.
[acceptedConnectionsHardLimit] :: AcceptedConnectionsLimit -> !Word32

-- | Soft limit of accepted connections. If we are above this threshold, we
--   will start rate limiting.
[acceptedConnectionsSoftLimit] :: AcceptedConnectionsLimit -> !Word32

-- | Max delay for limiting accepted connections. We use linear regression
--   starting from 0 at the soft limit up to
--   <tt>acceptedConnectionDelay</tt> at the hard limit.
[acceptedConnectionsDelay] :: AcceptedConnectionsLimit -> !DiffTime

-- | Get the number of current connections, make decision based on
--   <a>AcceptedConnectionsLimit</a> and execute it.
runConnectionRateLimits :: (MonadSTM m, MonadDelay m, MonadTime m) => Tracer m AcceptConnectionsPolicyTrace -> STM m Int -> AcceptedConnectionsLimit -> m ()

-- | Trace for the <tt>AcceptConnectionsLimit</tt> policy.
data AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionRateLimiting :: DiffTime -> Int -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionHardLimit :: Word32 -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionResume :: Int -> AcceptConnectionsPolicyTrace
instance GHC.Show.Show Ouroboros.Network.Server.RateLimiting.AcceptedConnectionsLimit
instance GHC.Classes.Ord Ouroboros.Network.Server.RateLimiting.AcceptedConnectionsLimit
instance GHC.Classes.Eq Ouroboros.Network.Server.RateLimiting.AcceptedConnectionsLimit
instance GHC.Classes.Ord Ouroboros.Network.Server.RateLimiting.AcceptConnectionsPolicyTrace
instance GHC.Classes.Eq Ouroboros.Network.Server.RateLimiting.AcceptConnectionsPolicyTrace
instance GHC.Show.Show Ouroboros.Network.Server.RateLimiting.AcceptConnectionsPolicyTrace

module Ouroboros.Network.Snocket

-- | Named pipes and Berkeley sockets have different API when accepting a
--   connection. For named pipes the file descriptor created by
--   <tt>createNamedPipe</tt> is supposed to be used for the first
--   connected client. Named pipe accept loop looks this way:
--   
--   <pre>
--   acceptLoop k = do
--     h &lt;- createNamedPipe name
--     connectNamedPipe h
--     -- h is now in connected state
--     forkIO (k h)
--     acceptLoop k
--   </pre>
--   
--   For Berkeley sockets equivalent loop starts by creating a socket which
--   accepts connections and accept returns a new socket in connected state
--   
--   <pre>
--   acceptLoop k = do
--       s &lt;- socket ...
--       bind s address
--       listen s
--       loop s
--     where
--       loop s = do
--         (s' , _addr') &lt;- accept s
--         -- s' is in connected state
--         forkIO (k s')
--         loop s
--   </pre>
--   
--   To make common API for both we use a recursive type <a>Accept</a>, see
--   <a>berkeleyAccept</a> below. Creation of a socket / named pipe is part
--   of <a>Snocket</a>, but this means we need to have different recursion
--   step for named pipe &amp; sockets. For sockets its recursion step will
--   always return <a>accept</a> syscall; for named pipes the first
--   callback will reuse the file descriptor created by <a>open</a> and
--   only subsequent calls will create a new file descriptor by
--   <tt>createNamedPipe</tt>, see <tt>namedPipeSnocket</tt>.
newtype Accept m fd addr
Accept :: m (Accepted fd addr, Accept m fd addr) -> Accept m fd addr
[runAccept] :: Accept m fd addr -> m (Accepted fd addr, Accept m fd addr)
data Accepted fd addr
[AcceptFailure] :: !SomeException -> Accepted fd addr
[Accepted] :: !fd -> !addr -> Accepted fd addr

-- | We support either sockets or named pipes.
--   
--   There are three families of addresses: <a>SocketFamily</a> usef for
--   Berkeley sockets, <a>LocalFamily</a> used for <a>LocalAddress</a>es
--   (either Unix sockets or Windows named pipe addresses), and
--   <a>TestFamily</a> for testing purposes.
--   
--   <a>LocalFamily</a> requires <a>LocalAddress</a>, this is needed to
--   provide path of the opened Win32 <tt>HANDLE</tt>.
data AddressFamily addr
[SocketFamily] :: !Family -> AddressFamily SockAddr
[LocalFamily] :: !LocalAddress -> AddressFamily LocalAddress

-- | Using a newtype wrapper <a>TestAddress</a> makes pattern matches on
--   <tt>AddressFamily</tt> complete, e.g. it makes <a>AddressFamily</a>
--   injective: <tt>AddressFamily addr == AddressFamily addr'</tt> then
--   <tt>addr == addr'</tt>. .
[TestFamily] :: AddressFamily (TestAddress addr)

-- | Abstract communication interface that can be used by more than
--   <a>Socket</a>. Snockets are polymorphic over monad which is used, this
--   feature is useful for testing and/or simulations.
data Snocket m fd addr
Snocket :: (fd -> m addr) -> (fd -> m addr) -> (addr -> AddressFamily addr) -> (AddressFamily addr -> m fd) -> (addr -> m fd) -> (fd -> addr -> m ()) -> (fd -> addr -> m ()) -> (fd -> m ()) -> (fd -> m (Accept m fd addr)) -> (fd -> m ()) -> (DiffTime -> Tracer m MuxTrace -> fd -> m (MuxBearer m)) -> Snocket m fd addr
[getLocalAddr] :: Snocket m fd addr -> fd -> m addr
[getRemoteAddr] :: Snocket m fd addr -> fd -> m addr
[addrFamily] :: Snocket m fd addr -> addr -> AddressFamily addr

-- | Open a file descriptor (socket / namedPipe). For named pipes this is
--   using <tt>CreateNamedPipe</tt> syscall, for Berkeley sockets
--   <tt>socket</tt> is used.
[open] :: Snocket m fd addr -> AddressFamily addr -> m fd

-- | A way to create <tt>fd</tt> to pass to <a>connect</a>. For named pipes
--   it will use <tt>CreateFile</tt> syscall. For Berkeley sockets this the
--   same as <a>open</a>.
--   
--   For named pipes we need full <tt>addr</tt> rather than just address
--   family as it is for sockets.
[openToConnect] :: Snocket m fd addr -> addr -> m fd

-- | <a>connect</a> is only needed for Berkeley sockets, for named pipes
--   this is no-op.
[connect] :: Snocket m fd addr -> fd -> addr -> m ()
[bind] :: Snocket m fd addr -> fd -> addr -> m ()
[listen] :: Snocket m fd addr -> fd -> m ()
[accept] :: Snocket m fd addr -> fd -> m (Accept m fd addr)
[close] :: Snocket m fd addr -> fd -> m ()
[toBearer] :: Snocket m fd addr -> DiffTime -> Tracer m MuxTrace -> fd -> m (MuxBearer m)
type SocketSnocket = Snocket IO Socket SockAddr

-- | Create a <a>Snocket</a> for the given <a>Family</a>. In the
--   <a>bind</a> method set <a>ReuseAddr</a> and <a>ReusePort</a>.
socketSnocket :: IOManager -> SocketSnocket

-- | System dependent LocalSnocket
type LocalSnocket = Snocket IO LocalSocket LocalAddress

-- | Create a <a>LocalSnocket</a>.
--   
--   On <i>Windows</i>, there is no way to get path associated to a named
--   pipe. To go around this, the address passed to <a>open</a> via
--   <a>LocalFamily</a> will be referenced by <a>LocalSocket</a>.
localSnocket :: IOManager -> LocalSnocket

-- | System dependent LocalSnocket type
newtype LocalSocket
LocalSocket :: LocalHandle -> LocalSocket
[getLocalHandle] :: LocalSocket -> LocalHandle

-- | Local address, on Unix is associated with <a>AF_UNIX</a> family, on
--   
--   Windows with `named-pipes`.
newtype LocalAddress
LocalAddress :: FilePath -> LocalAddress
[getFilePath] :: LocalAddress -> FilePath
localAddressFromPath :: FilePath -> LocalAddress
newtype TestAddress addr
TestAddress :: addr -> TestAddress addr
[getTestAddress] :: TestAddress addr -> addr

-- | Socket file descriptor.
newtype FileDescriptor
FileDescriptor :: Int -> FileDescriptor
[getFileDescriptor] :: FileDescriptor -> Int

-- | We use <tt>unsafeFdSocket</tt> but <a>FileDescriptor</a> constructor
--   is not exposed. This forbids any usage of <a>FileDescriptor</a> (at
--   least in a straightforward way) using any low level functions which
--   operate on file descriptors.
socketFileDescriptor :: Socket -> IO FileDescriptor
localSocketFileDescriptor :: LocalSocket -> IO FileDescriptor
instance GHC.Show.Show Ouroboros.Network.Snocket.LocalAddress
instance GHC.Generics.Generic Ouroboros.Network.Snocket.LocalAddress
instance GHC.Classes.Ord Ouroboros.Network.Snocket.LocalAddress
instance GHC.Classes.Eq Ouroboros.Network.Snocket.LocalAddress
instance GHC.Show.Show addr => GHC.Show.Show (Ouroboros.Network.Snocket.TestAddress addr)
instance GHC.Generics.Generic (Ouroboros.Network.Snocket.TestAddress addr)
instance GHC.Classes.Ord addr => GHC.Classes.Ord (Ouroboros.Network.Snocket.TestAddress addr)
instance GHC.Classes.Eq addr => GHC.Classes.Eq (Ouroboros.Network.Snocket.TestAddress addr)
instance GHC.Show.Show Ouroboros.Network.Snocket.LocalSocket
instance GHC.Generics.Generic Ouroboros.Network.Snocket.LocalSocket
instance GHC.Classes.Eq Ouroboros.Network.Snocket.LocalSocket
instance GHC.Show.Show Ouroboros.Network.Snocket.FileDescriptor
instance GHC.Generics.Generic Ouroboros.Network.Snocket.FileDescriptor
instance GHC.Classes.Eq addr => GHC.Classes.Eq (Ouroboros.Network.Snocket.AddressFamily addr)
instance GHC.Show.Show addr => GHC.Show.Show (Ouroboros.Network.Snocket.AddressFamily addr)
instance Data.Hashable.Class.Hashable Ouroboros.Network.Snocket.LocalAddress
instance GHC.Base.Functor m => Data.Bifunctor.Bifunctor (Ouroboros.Network.Snocket.Accept m)
instance Data.Bifunctor.Bifunctor Ouroboros.Network.Snocket.Accepted
instance Data.Bifoldable.Bifoldable Ouroboros.Network.Snocket.Accepted


-- | This module contains peer state management and error policies.
module Ouroboros.Network.Subscription.PeerState

-- | Semigroup of commands which acts on <a>PeerState</a>. The <tt>t</tt>
--   variable might be initiated to <a>DiffTime</a> or <tt>Time m</tt>.
--   
--   This semigroup allows to either suspend both consumer and producer or
--   just the consumer part.
data SuspendDecision t

-- | peer is suspend; The first <tt>t</tt> is the time until which a local
--   producer is suspended, the second one is the time until which a local
--   consumer is suspended.
SuspendPeer :: !t -> !t -> SuspendDecision t

-- | suspend local consumer / initiator side until <tt>t</tt> (this mean we
--   are not allowing to communicate with the producer / responder of a
--   remote peer).
SuspendConsumer :: !t -> SuspendDecision t

-- | throw an error from the main thread.
Throw :: SuspendDecision t

-- | Action of <a>SuspendDecision</a> on <tt>Maybe <a>PeerState</a></tt>.
--   Action laws are only satisfied for the submonoid form by
--   <a>SuspendPeer</a> and <a>SuspendConsumer</a>.
suspend :: Ord (Async m ()) => Maybe (PeerState m) -> SuspendDecision Time -> (Set (Async m ()), Maybe (PeerState m))
data PeerState m

-- | active peer with its producers and consumer threads
HotPeer :: !Set (Async m ()) -> !Set (Async m ()) -> PeerState m

-- | suspended consumer: with producer threads and time until the consumer
--   is suspended
SuspendedConsumer :: !Set (Async m ()) -> !Time -> PeerState m

-- | suspended peer: producer &amp; consumer suspend time
SuspendedPeer :: !Time -> !Time -> PeerState m

-- | peer with no opened connections in either direction
ColdPeer :: PeerState m

-- | Threads which needs to be cancelled when updating the <a>PeerState</a>
--   with <a>SuspendDecision</a>.
threadsToCancel :: Ord (Async m ()) => PeerState m -> SuspendDecision diffTime -> Set (Async m ())

-- | Map from addresses to <a>PeerState</a>s; it will be be shared in a
--   <a>StrictTVar</a>.
--   
--   Abstracting <tt>t</tt> is useful for tests, the <tt>IO</tt> version
--   will use <tt>Time IO</tt>.
data PeerStates m addr

-- | Map of peer states
[PeerStates] :: !Map addr (PeerState m) -> PeerStates m addr

-- | Or an exception to throw
[ThrowException] :: Exception e => e -> PeerStates m addr
newPeerStatesVar :: MonadSTM m => m (StrictTVar m (PeerStates m addr))
newPeerStatesVarSTM :: MonadSTM m => STM m (StrictTVar m (PeerStates m addr))

-- | Periodically clean <a>PeerState</a>. It will stop when
--   <a>PeerState</a> becomes <a>ThrowException</a>.
cleanPeerStates :: (MonadSTM m, MonadAsync m, MonadTime m, MonadTimer m) => DiffTime -> StrictTVar m (PeerStates m addr) -> m ()

-- | Update <a>PeerStates</a> for a given <tt>addr</tt>, using
--   <a>suspend</a>, and return threads which must be cancelled.
--   
--   This is more efficient that using the action of <a>SuspendDecision</a>
--   on <a>PeerStates</a>, since it only uses a single dictionary lookup to
--   update the state and return the set of threads to be cancelled.
runSuspendDecision :: forall m addr e. (Ord addr, Ord (Async m ()), Exception e) => Time -> addr -> e -> SuspendDecision DiffTime -> PeerStates m addr -> (PeerStates m addr, Set (Async m ()))

-- | Register consumer in <a>PeerState</a>. This is a partial function
--   which assumes that the <a>PeerState</a> is <a>HotPeer</a>.
registerConsumer :: forall m addr. (Ord addr, Ord (Async m ())) => addr -> Async m () -> PeerStates m addr -> PeerStates m addr

-- | Unregister consumer from a <a>PeerState</a>.
unregisterConsumer :: forall m addr. (Ord addr, Ord (Async m ())) => addr -> Async m () -> PeerStates m addr -> PeerStates m addr

-- | Register producer in PeerStates. This is a partial function which
--   assumes that the <a>PeerState</a> is either <a>HotPeer</a> or
--   <a>SuspendedConsumer</a>.
registerProducer :: forall m addr. (Ord addr, Ord (Async m ())) => addr -> Async m () -> PeerStates m addr -> PeerStates m addr
unregisterProducer :: forall m addr. (Ord addr, Ord (Async m ())) => addr -> Async m () -> PeerStates m addr -> PeerStates m addr

-- | Check state before connecting to a remote peer. We will connect only
--   if it retuns <a>True</a>.
type BeforeConnect m s addr = Time -> addr -> s -> STM m (ConnectDecision s)

-- | Before connectin with a peer we make a decision to either connect to
--   it or not.
data ConnectDecision s
AllowConnection :: !s -> ConnectDecision s
DisallowConnection :: !s -> ConnectDecision s

-- | Run <a>BeforeConnect</a> callback in a <a>MonadTime</a> monad.
runBeforeConnect :: (MonadSTM m, MonadTime m) => StrictTVar m s -> BeforeConnect m s addr -> addr -> m Bool

-- | <a>BeforeConnect</a> callback: it updates peer state and return
--   boolean value wheather to connect to it or not. If a peer hasn't been
--   recorded in <a>PeerStates</a>, we add it and try to connect to it.
beforeConnectTx :: forall m addr. (MonadSTM m, Ord addr) => BeforeConnect m (PeerStates m addr) addr

-- | This is a length of time, as measured by a clock. Conversion functions
--   will treat it as seconds. It has a precision of 10^-12 s.
data DiffTime
alterAndLookup :: forall k s a. Ord k => (Maybe a -> (s, Maybe a)) -> k -> Map k a -> (Map k a, Maybe s)
instance GHC.Base.Functor Ouroboros.Network.Subscription.PeerState.SuspendDecision
instance GHC.Show.Show t => GHC.Show.Show (Ouroboros.Network.Subscription.PeerState.SuspendDecision t)
instance GHC.Classes.Ord t => GHC.Classes.Ord (Ouroboros.Network.Subscription.PeerState.SuspendDecision t)
instance GHC.Classes.Eq t => GHC.Classes.Eq (Ouroboros.Network.Subscription.PeerState.SuspendDecision t)
instance GHC.Base.Functor Ouroboros.Network.Subscription.PeerState.ConnectDecision
instance GHC.Classes.Eq (Control.Monad.Class.MonadAsync.Async m ()) => GHC.Classes.Eq (Ouroboros.Network.Subscription.PeerState.PeerState m)
instance GHC.Classes.Ord (Control.Monad.Class.MonadAsync.Async m ()) => GHC.Classes.Ord (Ouroboros.Network.Subscription.PeerState.PeerState m)
instance GHC.Show.Show addr => GHC.Show.Show (Ouroboros.Network.Subscription.PeerState.PeerStates GHC.Types.IO addr)
instance GHC.Classes.Eq addr => GHC.Classes.Eq (Ouroboros.Network.Subscription.PeerState.PeerStates GHC.Types.IO addr)
instance (Control.Monad.Class.MonadAsync.MonadAsync m, GHC.Show.Show (Control.Monad.Class.MonadFork.ThreadId m), GHC.Classes.Ord (Control.Monad.Class.MonadFork.ThreadId m)) => GHC.Show.Show (Ouroboros.Network.Subscription.PeerState.PeerState m)
instance Data.Semigroup.Action.SAct (Ouroboros.Network.Subscription.PeerState.SuspendDecision Control.Monad.Class.MonadTime.Time) (GHC.Maybe.Maybe (Ouroboros.Network.Subscription.PeerState.PeerState m))
instance GHC.Classes.Ord t => GHC.Base.Semigroup (Ouroboros.Network.Subscription.PeerState.SuspendDecision t)


-- | Error policies, and integration with <a>SuspendDecision</a>-semigroup
--   action on <a>PeerState</a>.
module Ouroboros.Network.ErrorPolicy

-- | List of error policies for exception handling and a policy for handing
--   application return values.
data ErrorPolicies
ErrorPolicies :: [ErrorPolicy] -> [ErrorPolicy] -> ErrorPolicies

-- | Application Error Policies
[epAppErrorPolicies] :: ErrorPolicies -> [ErrorPolicy]

-- | <tt>connect</tt> Error Policies
[epConErrorPolicies] :: ErrorPolicies -> [ErrorPolicy]
nullErrorPolicies :: ErrorPolicies
data ErrorPolicy
[ErrorPolicy] :: forall e. Exception e => (e -> Maybe (SuspendDecision DiffTime)) -> ErrorPolicy
evalErrorPolicy :: forall e. Exception e => e -> ErrorPolicy -> Maybe (SuspendDecision DiffTime)

-- | Evaluate a list of <a>ErrorPolicy</a>s; If none of them applies this
--   function returns <a>Nothing</a>, in this case the exception will be
--   traced and not thrown.
evalErrorPolicies :: forall e. Exception e => e -> [ErrorPolicy] -> Maybe (SuspendDecision DiffTime)

-- | Complete a connection, which receive application result (or
--   exception).
type CompleteApplication m s addr r = Result addr r -> s -> STM m (CompleteApplicationResult m addr s)
data CompleteApplicationResult m addr s
CompleteApplicationResult :: !s -> Set (Async m ()) -> Maybe (WithAddr addr ErrorPolicyTrace) -> CompleteApplicationResult m addr s

-- | new state
[carState] :: CompleteApplicationResult m addr s -> !s

-- | threads to kill
[carThreads] :: CompleteApplicationResult m addr s -> Set (Async m ())

-- | trace points
[carTrace] :: CompleteApplicationResult m addr s -> Maybe (WithAddr addr ErrorPolicyTrace)

-- | Result of the connection thread. It's either result of an application,
--   or an exception thrown by it.
data Result addr r
[ApplicationResult] :: !Time -> !addr -> !r -> Result addr r
[Connected] :: !Time -> !addr -> Result addr r
[ConnectionError] :: Exception e => !Time -> !addr -> !e -> Result addr r
[ApplicationError] :: Exception e => !Time -> !addr -> !e -> Result addr r

-- | <a>CompleteApplication</a> callback
completeApplicationTx :: forall m addr a. (MonadAsync m, Ord addr, Ord (Async m ())) => ErrorPolicies -> CompleteApplication m (PeerStates m addr) addr a

-- | Trace data for error policies
data ErrorPolicyTrace

-- | suspending peer with a given exception until
ErrorPolicySuspendPeer :: Maybe (ConnectionOrApplicationExceptionTrace SomeException) -> DiffTime -> DiffTime -> ErrorPolicyTrace

-- | suspending consumer until
ErrorPolicySuspendConsumer :: Maybe (ConnectionOrApplicationExceptionTrace SomeException) -> DiffTime -> ErrorPolicyTrace

-- | caught a local exception
ErrorPolicyLocalNodeError :: ConnectionOrApplicationExceptionTrace SomeException -> ErrorPolicyTrace

-- | resume a peer (both consumer and producer)
ErrorPolicyResumePeer :: ErrorPolicyTrace

-- | consumer was suspended until producer will resume
ErrorPolicyKeepSuspended :: ErrorPolicyTrace

-- | resume consumer
ErrorPolicyResumeConsumer :: ErrorPolicyTrace

-- | resume producer
ErrorPolicyResumeProducer :: ErrorPolicyTrace

-- | an application throwed an exception, which was not handled by any
--   <a>ErrorPolicy</a>.
ErrorPolicyUnhandledApplicationException :: SomeException -> ErrorPolicyTrace

-- | <tt>connect</tt> throwed an exception, which was not handled by any
--   <a>ErrorPolicy</a>.
ErrorPolicyUnhandledConnectionException :: SomeException -> ErrorPolicyTrace

-- | <tt>accept</tt> throwed an exception
ErrorPolicyAcceptException :: IOException -> ErrorPolicyTrace
traceErrorPolicy :: Either (ConnectionOrApplicationExceptionTrace SomeException) r -> SuspendDecision DiffTime -> Maybe ErrorPolicyTrace
data WithAddr addr a
WithAddr :: addr -> a -> WithAddr addr a
[wiaAddr] :: WithAddr addr a -> addr
[wiaEvent] :: WithAddr addr a -> a

-- | Map from addresses to <a>PeerState</a>s; it will be be shared in a
--   <a>StrictTVar</a>.
--   
--   Abstracting <tt>t</tt> is useful for tests, the <tt>IO</tt> version
--   will use <tt>Time IO</tt>.
data PeerStates m addr

-- | Semigroup of commands which acts on <a>PeerState</a>. The <tt>t</tt>
--   variable might be initiated to <a>DiffTime</a> or <tt>Time m</tt>.
--   
--   This semigroup allows to either suspend both consumer and producer or
--   just the consumer part.
data SuspendDecision t

-- | peer is suspend; The first <tt>t</tt> is the time until which a local
--   producer is suspended, the second one is the time until which a local
--   consumer is suspended.
SuspendPeer :: !t -> !t -> SuspendDecision t

-- | suspend local consumer / initiator side until <tt>t</tt> (this mean we
--   are not allowing to communicate with the producer / responder of a
--   remote peer).
SuspendConsumer :: !t -> SuspendDecision t

-- | throw an error from the main thread.
Throw :: SuspendDecision t
instance GHC.Base.Functor Ouroboros.Network.ErrorPolicy.ConnectionOrApplicationExceptionTrace
instance GHC.Show.Show err => GHC.Show.Show (Ouroboros.Network.ErrorPolicy.ConnectionOrApplicationExceptionTrace err)
instance GHC.Show.Show Ouroboros.Network.ErrorPolicy.ErrorPolicyTrace
instance GHC.Base.Functor (Ouroboros.Network.ErrorPolicy.CompleteApplicationResult m addr)
instance (GHC.Show.Show addr, GHC.Show.Show a) => GHC.Show.Show (Ouroboros.Network.ErrorPolicy.WithAddr addr a)
instance GHC.Base.Semigroup Ouroboros.Network.ErrorPolicy.ErrorPolicies
instance GHC.Show.Show Ouroboros.Network.ErrorPolicy.ErrorPolicy

module Ouroboros.Network.Server.Socket

-- | Policy which governs how to limit the number of accepted connections.
data AcceptedConnectionsLimit
AcceptedConnectionsLimit :: !Word32 -> !Word32 -> !DiffTime -> AcceptedConnectionsLimit

-- | Hard limit of accepted connections.
[acceptedConnectionsHardLimit] :: AcceptedConnectionsLimit -> !Word32

-- | Soft limit of accepted connections. If we are above this threshold, we
--   will start rate limiting.
[acceptedConnectionsSoftLimit] :: AcceptedConnectionsLimit -> !Word32

-- | Max delay for limiting accepted connections. We use linear regression
--   starting from 0 at the soft limit up to
--   <tt>acceptedConnectionDelay</tt> at the hard limit.
[acceptedConnectionsDelay] :: AcceptedConnectionsLimit -> !DiffTime

-- | Trace for the <tt>AcceptConnectionsLimit</tt> policy.
data AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionRateLimiting :: DiffTime -> Int -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionHardLimit :: Word32 -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionResume :: Int -> AcceptConnectionsPolicyTrace

-- | What to do on a new connection: accept and run this <a>IO</a>, or
--   reject.
type BeginConnection addr channel st r = Time -> addr -> st -> STM (HandleConnection channel st r)

-- | What to do with a new connection: reject it and give a new state, or
--   accept it and give a new state with a continuation to run against the
--   resulting channel. See also <a>CompleteConnection</a>, which is run
--   for every connection when it finishes, and can also update the state.
data HandleConnection channel st r
[Reject] :: !st -> HandleConnection channel st r
[Accept] :: !st -> !channel -> IO r -> HandleConnection channel st r

-- | A call back which runs when application starts;
--   
--   It is needed only because <a>BeginConnection</a> does not have access
--   to the thread which runs the application.
type ApplicationStart addr st = addr -> Async () -> st -> STM st

-- | How to update state when a connection finishes. Can use
--   <tt>throwSTM</tt> to terminate the server.
--   
--   TODO: remove <tt>async</tt>, use `Async m ()` from
--   <tt>MonadAsync</tt>.
type CompleteConnection addr st tr r = Result addr r -> st -> STM (CompleteApplicationResult IO addr st)
data CompleteApplicationResult m addr s
CompleteApplicationResult :: !s -> Set (Async m ()) -> Maybe (WithAddr addr ErrorPolicyTrace) -> CompleteApplicationResult m addr s

-- | new state
[carState] :: CompleteApplicationResult m addr s -> !s

-- | threads to kill
[carThreads] :: CompleteApplicationResult m addr s -> Set (Async m ())

-- | trace points
[carTrace] :: CompleteApplicationResult m addr s -> Maybe (WithAddr addr ErrorPolicyTrace)

-- | The product of a spawned thread. We catch all (even async) exceptions.
data Result addr r
Result :: !Async () -> !addr -> !Time -> !Either SomeException r -> Result addr r
[resultThread] :: Result addr r -> !Async ()
[resultAddr] :: Result addr r -> !addr
[resultTime] :: Result addr r -> !Time
[resultValue] :: Result addr r -> !Either SomeException r

-- | Given a current state, <tt>retry</tt> unless you want to stop the
--   server. When this transaction returns, any running threads spawned by
--   the server will be killed.
--   
--   It's possible that a connection is accepted after the main thread
--   returns, but before the server stops. In that case, it will be killed,
--   and the <a>CompleteConnection</a> will not run against it.
type Main st t = st -> STM t

-- | Run a server.
run :: Tracer IO (WithAddr addr ErrorPolicyTrace) -> Tracer IO AcceptConnectionsPolicyTrace -> Socket addr channel -> AcceptedConnectionsLimit -> (IOException -> IO ()) -> BeginConnection addr channel st r -> ApplicationStart addr st -> CompleteConnection addr st tr r -> Main st t -> TVar st -> IO t

-- | Abstraction of something that can provide connections. A <a>Socket</a>
--   can be used to get a `Socket SockAddr (Channel IO Lazy.ByteString)`
--   It's not defined in here, though, because we don't want the dependency
--   on typed-protocols or even on network.
data Socket addr channel
Socket :: IO (addr, channel, IO (), Socket addr channel) -> Socket addr channel

-- | The address, a channel, IO to close the channel.
[acceptConnection] :: Socket addr channel -> IO (addr, channel, IO (), Socket addr channel)

-- | Expected to be useful for testing.
ioSocket :: IO (addr, channel) -> Socket addr channel

module Ouroboros.Network.Subscription.Subscriber

-- | Generate subscription targets in some monad. Examples include
--   obtaining targets from a fixed list, or from a DNS lookup.
newtype SubscriptionTarget m target
SubscriptionTarget :: m (Maybe (target, SubscriptionTarget m target)) -> SubscriptionTarget m target

-- | This should be used with the exception that implementations can block
--   on the order of seconds.
[getSubscriptionTarget] :: SubscriptionTarget m target -> m (Maybe (target, SubscriptionTarget m target))
listSubscriptionTarget :: Applicative m => [target] -> SubscriptionTarget m target

module Ouroboros.Network.Subscription.Worker

-- | Callback which fires: when we create or close a socket.
type SocketStateChange m s addr = SocketState m addr -> s -> STM m s
data SocketState m addr
CreatedSocket :: !addr -> !Async m () -> SocketState m addr
ClosedSocket :: !addr -> !Async m () -> SocketState m addr

-- | Complete a connection, which receive application result (or
--   exception).
type CompleteApplication m s addr r = Result addr r -> s -> STM m (CompleteApplicationResult m addr s)

-- | GADT which classifies connection result.
data ConnectResult

-- | Successful connection.
ConnectSuccess :: ConnectResult

-- | Successfully connection, reached the valency target. Other ongoing
--   connection attempts will be killed.
ConnectSuccessLast :: ConnectResult

-- | Someone else manged to create the final connection to a target before
--   us.
ConnectValencyExceeded :: ConnectResult

-- | Result of the connection thread. It's either result of an application,
--   or an exception thrown by it.
data Result addr r
[ApplicationResult] :: !Time -> !addr -> !r -> Result addr r
[Connected] :: !Time -> !addr -> Result addr r
[ConnectionError] :: Exception e => !Time -> !addr -> !e -> Result addr r
[ApplicationError] :: Exception e => !Time -> !addr -> !e -> Result addr r

-- | Given current state <a>retry</a> too keep the subscription worker
--   going. When this transaction returns, all the threads spawned by the
--   worker will be killed.
type Main m s t = s -> STM m t

-- | Mutable state kept by the worker. All the workers in this module are
--   polymorphic over the state type. The state is updated with two
--   callbacks:
--   
--   <ul>
--   <li><tt>CompleteConnect</tt> - STM transaction which runs when the
--   connect call returned, if it thrown an exception it will be passed to
--   the callback.</li>
--   <li><a>CompleteApplication</a> - STM transaction which runs when
--   application returned. It will receive the result of the application or
--   an exception raised by it.</li>
--   </ul>
type StateVar m s = StrictTVar m s
data LocalAddresses addr
LocalAddresses :: Maybe addr -> Maybe addr -> Maybe addr -> LocalAddresses addr

-- | Local IPv4 address to use, Nothing indicates don't use IPv4
[laIpv4] :: LocalAddresses addr -> Maybe addr

-- | Local IPv6 address to use, Nothing indicates don't use IPv6
[laIpv6] :: LocalAddresses addr -> Maybe addr

-- | Local Unix address to use, Nothing indicates don't use Unix sockets
[laUnix] :: LocalAddresses addr -> Maybe addr

-- | Worker STM callbacks
data WorkerCallbacks m s addr a t
WorkerCallbacks :: SocketStateChange m s addr -> CompleteApplication m s addr a -> Main m s t -> WorkerCallbacks m s addr a t
[wcSocketStateChangeTx] :: WorkerCallbacks m s addr a t -> SocketStateChange m s addr
[wcCompleteApplicationTx] :: WorkerCallbacks m s addr a t -> CompleteApplication m s addr a
[wcMainTx] :: WorkerCallbacks m s addr a t -> Main m s t

-- | Worker parameters
data WorkerParams m localAddrs addr
WorkerParams :: localAddrs addr -> (addr -> localAddrs addr -> Maybe addr) -> (addr -> Maybe DiffTime) -> m (SubscriptionTarget m addr) -> Int -> WorkerParams m localAddrs addr

-- | local addresses of the server
[wpLocalAddresses] :: WorkerParams m localAddrs addr -> localAddrs addr

-- | given remote addr pick the local address
[wpSelectAddress] :: WorkerParams m localAddrs addr -> addr -> localAddrs addr -> Maybe addr

-- | delay after a connection attempt to <tt>addr</tt>
[wpConnectionAttemptDelay] :: WorkerParams m localAddrs addr -> addr -> Maybe DiffTime
[wpSubscriptionTarget] :: WorkerParams m localAddrs addr -> m (SubscriptionTarget m addr)
[wpValency] :: WorkerParams m localAddrs addr -> Int

-- | This is the most abstract worker, which puts all the pieces together.
--   It will execute until <tt>main :: Main m s t</tt> returns. It runs
--   <a>subscriptionLoop</a> in a new threads and will exit when it dies.
--   Spawn threads are cancelled in a <a>finally</a> callback by throwing
--   <a>SubscriberError</a>.
--   
--   Note: This function runs in <a>IO</a> only because <a>MonadSTM</a>
--   does not yet support <a>orElse</a>, PR #432.
worker :: forall s sock localAddrs addr a x. Ord addr => Tracer IO (SubscriptionTrace addr) -> Tracer IO (WithAddr addr ErrorPolicyTrace) -> ConnectionTable IO addr -> StateVar IO s -> Snocket IO sock addr -> WorkerCallbacks IO s addr a x -> WorkerParams IO localAddrs addr -> (sock -> IO a) -> IO x

-- | Allocate a socket and connect to a peer, execute the continuation with
--   async exceptions masked. The continuation receives the <tt>unmask</tt>
--   callback.
safeConnect :: (MonadThrow m, MonadMask m) => Snocket m sock addr -> addr -> addr -> m () -> m () -> ((forall x. m x -> m x) -> sock -> Either SomeException () -> m t) -> m t

-- | Time to wait between connection attempts when we don't have any DeltaQ
--   info.
defaultConnectionAttemptDelay :: DiffTime

-- | Minimum time to wait between connection attempts.
minConnectionAttemptDelay :: DiffTime

-- | Maximum time to wait between connection attempts.
maxConnectionAttemptDelay :: DiffTime

-- | Minimum time to wait between ip reconnects
ipRetryDelay :: DiffTime
data SubscriberError
SubscriberError :: !SubscriberErrorType -> !String -> !CallStack -> SubscriberError
[seType] :: SubscriberError -> !SubscriberErrorType
[seMessage] :: SubscriberError -> !String
[seStack] :: SubscriberError -> !CallStack
data SubscriptionTrace addr
SubscriptionTraceConnectStart :: addr -> SubscriptionTrace addr
SubscriptionTraceConnectEnd :: addr -> ConnectResult -> SubscriptionTrace addr
SubscriptionTraceSocketAllocationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceConnectException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceApplicationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceTryConnectToPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSkippingPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSubscriptionRunning :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaiting :: Int -> SubscriptionTrace addr
SubscriptionTraceSubscriptionFailed :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaitingNewConnection :: DiffTime -> SubscriptionTrace addr
SubscriptionTraceStart :: Int -> SubscriptionTrace addr
SubscriptionTraceRestart :: DiffTime -> Int -> Int -> SubscriptionTrace addr
SubscriptionTraceConnectionExist :: addr -> SubscriptionTrace addr
SubscriptionTraceUnsupportedRemoteAddr :: addr -> SubscriptionTrace addr
SubscriptionTraceMissingLocalAddress :: SubscriptionTrace addr
SubscriptionTraceAllocateSocket :: addr -> SubscriptionTrace addr
SubscriptionTraceCloseSocket :: addr -> SubscriptionTrace addr
instance GHC.Show.Show addr => GHC.Show.Show (Ouroboros.Network.Subscription.Worker.LocalAddresses addr)
instance GHC.Classes.Eq addr => GHC.Classes.Eq (Ouroboros.Network.Subscription.Worker.LocalAddresses addr)
instance GHC.Show.Show Ouroboros.Network.Subscription.Worker.ConnectResult
instance GHC.Classes.Ord Ouroboros.Network.Subscription.Worker.ConnectResult
instance GHC.Classes.Eq Ouroboros.Network.Subscription.Worker.ConnectResult
instance GHC.Show.Show Ouroboros.Network.Subscription.Worker.SubscriberErrorType
instance GHC.Classes.Eq Ouroboros.Network.Subscription.Worker.SubscriberErrorType
instance GHC.Show.Show Ouroboros.Network.Subscription.Worker.SubscriberError
instance GHC.Show.Show addr => GHC.Show.Show (Ouroboros.Network.Subscription.Worker.SubscriptionTrace addr)
instance GHC.Exception.Type.Exception Ouroboros.Network.Subscription.Worker.SubscriberError
instance GHC.Base.Semigroup (Ouroboros.Network.Subscription.Worker.LocalAddresses addr)

module Ouroboros.Network.Util.ShowProxy
class ShowProxy p
showProxy :: ShowProxy p => Proxy p -> String
showProxy :: (ShowProxy p, Typeable p) => Proxy p -> String

-- | <a>Proxy</a> is a type that holds no data, but has a phantom parameter
--   of arbitrary type (or even kind). Its use is to provide type
--   information, even though there is no value available of that type (or
--   it may be too costly to create one).
--   
--   Historically, <tt><a>Proxy</a> :: <a>Proxy</a> a</tt> is a safer
--   alternative to the <tt><a>undefined</a> :: a</tt> idiom.
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy (Void, Int -&gt; Int)
--   Proxy
--   </pre>
--   
--   Proxy can even hold types of higher kinds,
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Either
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy Functor
--   Proxy
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Proxy :: Proxy complicatedStructure
--   Proxy
--   </pre>
data Proxy (t :: k)
Proxy :: Proxy (t :: k)
instance Ouroboros.Network.Util.ShowProxy.ShowProxy GHC.Types.Int

module Ouroboros.Network.Protocol.Handshake.Type

-- | The handshake mini-protocol is used initially to agree the version and
--   associated parameters of the protocol to use for all subsequent
--   communication.
data Handshake vNumber vParams
[StPropose] :: Handshake vNumber vParams
[StConfirm] :: Handshake vNumber vParams
[StDone] :: Handshake vNumber vParams

-- | The messages for this protocol. It is expected to be a GADT that is
--   indexed by the <tt>from</tt> and <tt>to</tt> protocol states. That is
--   the protocol state the message transitions from, and the protocol
--   state it transitions into. These are the edges of the protocol state
--   transition system.
data family Message ps (st :: ps) (st' :: ps)

-- | Tokens for those protocol states in which the client has agency.
data family ClientHasAgency (st :: ps)

-- | Tokens for those protocol states in which the server has agency.
data family ServerHasAgency (st :: ps)

-- | Tokens for terminal protocol states in which neither the client nor
--   server has agency.
data family NobodyHasAgency (st :: ps)

-- | Reasons by which a server can refuse proposed version.
data RefuseReason vNumber

-- | All of the prosed versions where not known to the server. Since the
--   server sends all versions that it can knows about, some of them we
--   might not be able to decode, so we include raw tags <tt>[Int]</tt>.
VersionMismatch :: [vNumber] -> [Int] -> RefuseReason vNumber

-- | The server failed to decode version parameters.
HandshakeDecodeError :: vNumber -> Text -> RefuseReason vNumber

-- | The server refused to run the proposed version parameters
Refused :: vNumber -> Text -> RefuseReason vNumber

-- | Extends handshake error <tt><a>RefuseReason</a></tt> type, by client
--   specific errors.
data HandshakeProtocolError vNumber
HandshakeError :: RefuseReason vNumber -> HandshakeProtocolError vNumber
NotRecognisedVersion :: vNumber -> HandshakeProtocolError vNumber
InvalidServerSelection :: vNumber -> Text -> HandshakeProtocolError vNumber
instance GHC.Show.Show vNumber => GHC.Show.Show (Ouroboros.Network.Protocol.Handshake.Type.RefuseReason vNumber)
instance GHC.Classes.Eq vNumber => GHC.Classes.Eq (Ouroboros.Network.Protocol.Handshake.Type.RefuseReason vNumber)
instance GHC.Show.Show vNumber => GHC.Show.Show (Ouroboros.Network.Protocol.Handshake.Type.HandshakeProtocolError vNumber)
instance GHC.Classes.Eq vNumber => GHC.Classes.Eq (Ouroboros.Network.Protocol.Handshake.Type.HandshakeProtocolError vNumber)
instance forall vNumber vParams (from :: Ouroboros.Network.Protocol.Handshake.Type.Handshake vNumber vParams) (to :: Ouroboros.Network.Protocol.Handshake.Type.Handshake vNumber vParams). (GHC.Show.Show vNumber, GHC.Show.Show vParams) => GHC.Show.Show (Network.TypedProtocol.Core.Message (Ouroboros.Network.Protocol.Handshake.Type.Handshake vNumber vParams) from to)
instance (Data.Typeable.Internal.Typeable vNumber, GHC.Show.Show vNumber) => GHC.Exception.Type.Exception (Ouroboros.Network.Protocol.Handshake.Type.HandshakeProtocolError vNumber)
instance (Data.Typeable.Internal.Typeable vNumber, GHC.Show.Show vNumber) => GHC.Exception.Type.Exception (Ouroboros.Network.Protocol.Handshake.Type.RefuseReason vNumber)
instance forall k1 k2 (vNumber :: k1) (vParams :: k2). Network.TypedProtocol.Core.Protocol (Ouroboros.Network.Protocol.Handshake.Type.Handshake vNumber vParams)
instance forall k1 k2 (vNumber :: k1) (vParams :: k2). Ouroboros.Network.Util.ShowProxy.ShowProxy (Ouroboros.Network.Protocol.Handshake.Type.Handshake vNumber vParams)
instance forall k1 k2 (vNumber :: k1) (vParams :: k2) (st :: Ouroboros.Network.Protocol.Handshake.Type.Handshake vNumber vParams). GHC.Show.Show (Network.TypedProtocol.Core.ClientHasAgency st)
instance forall k1 k2 (vNumber :: k1) (vParams :: k2) (st :: Ouroboros.Network.Protocol.Handshake.Type.Handshake vNumber vParams). GHC.Show.Show (Network.TypedProtocol.Core.ServerHasAgency st)


-- | Drivers for running <a>Peer</a>s with a <a>Codec</a> and a
--   <a>Channel</a>.
module Ouroboros.Network.Driver.Simple

-- | Run a peer with the given channel via the given codec.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
runPeer :: forall ps (st :: ps) pr failure bytes m a. (MonadThrow m, Show failure, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => Tracer m (TraceSendRecv ps) -> Codec ps failure m bytes -> Channel m bytes -> Peer ps pr st m a -> m (a, Maybe bytes)

-- | Structured <a>Tracer</a> output for <a>runPeer</a> and derivitives.
data TraceSendRecv ps
[TraceSendMsg] :: AnyMessageAndAgency ps -> TraceSendRecv ps
[TraceRecvMsg] :: AnyMessageAndAgency ps -> TraceSendRecv ps
data DecoderFailure
[DecoderFailure] :: forall (pr :: PeerRole) ps (st :: ps) failure. (forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps, Show failure) => PeerHasAgency pr st -> failure -> DecoderFailure

-- | Run a pipelined peer with the given channel via the given codec.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
--   
--   Unlike normal peers, running pipelined peers rely on concurrency,
--   hence the <a>MonadSTM</a> constraint.
runPipelinedPeer :: forall ps (st :: ps) pr failure bytes m a. (MonadAsync m, MonadThrow m, Show failure, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => Tracer m (TraceSendRecv ps) -> Codec ps failure m bytes -> Channel m bytes -> PeerPipelined ps pr st m a -> m (a, Maybe bytes)
data Role
Client :: Role
Server :: Role

-- | Run two <a>Peer</a>s via a pair of connected <a>Channel</a>s and a
--   common <a>Codec</a>.
--   
--   This is useful for tests and quick experiments.
--   
--   The first argument is expected to create two channels that are
--   connected, for example <a>createConnectedChannels</a>.
runConnectedPeers :: (MonadSTM m, MonadAsync m, MonadCatch m, Show failure, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => m (Channel m bytes, Channel m bytes) -> Tracer m (Role, TraceSendRecv ps) -> Codec ps failure m bytes -> Peer ps pr st m a -> Peer ps (FlipAgency pr) st m b -> m (a, b)
runConnectedPeersAsymmetric :: (MonadSTM m, MonadAsync m, MonadCatch m, Show failure, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => m (Channel m bytes, Channel m bytes) -> Tracer m (Role, TraceSendRecv ps) -> Codec ps failure m bytes -> Codec ps failure m bytes -> Peer ps pr st m a -> Peer ps (FlipAgency pr) st m b -> m (a, b)
runConnectedPeersPipelined :: (MonadSTM m, MonadAsync m, MonadCatch m, Show failure, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => m (Channel m bytes, Channel m bytes) -> Tracer m (Role, TraceSendRecv ps) -> Codec ps failure m bytes -> PeerPipelined ps pr st m a -> Peer ps (FlipAgency pr) st m b -> m (a, b)
instance GHC.Show.Show Ouroboros.Network.Driver.Simple.DecoderFailure
instance GHC.Exception.Type.Exception Ouroboros.Network.Driver.Simple.DecoderFailure
instance GHC.Show.Show (Network.TypedProtocol.Codec.AnyMessageAndAgency ps) => GHC.Show.Show (Ouroboros.Network.Driver.Simple.TraceSendRecv ps)


-- | Drivers for running <a>Peer</a>s.
module Ouroboros.Network.Driver.Limits
data ProtocolSizeLimits ps bytes
ProtocolSizeLimits :: (forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> Word) -> (bytes -> Word) -> ProtocolSizeLimits ps bytes
[sizeLimitForState] :: ProtocolSizeLimits ps bytes -> forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> Word
[dataSize] :: ProtocolSizeLimits ps bytes -> bytes -> Word
data ProtocolTimeLimits ps
ProtocolTimeLimits :: (forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> Maybe DiffTime) -> ProtocolTimeLimits ps
[timeLimitForState] :: ProtocolTimeLimits ps -> forall (pr :: PeerRole) (st :: ps). PeerHasAgency pr st -> Maybe DiffTime
data ProtocolLimitFailure
[ExceededSizeLimit] :: forall (pr :: PeerRole) ps (st :: ps). (forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => PeerHasAgency pr st -> ProtocolLimitFailure
[ExceededTimeLimit] :: forall (pr :: PeerRole) ps (st :: ps). (forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => PeerHasAgency pr st -> ProtocolLimitFailure
runPeerWithLimits :: forall ps (st :: ps) pr failure bytes m a. (MonadAsync m, MonadFork m, MonadMask m, MonadThrow (STM m), MonadMonotonicTime m, MonadTimer m, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps, Show failure) => Tracer m (TraceSendRecv ps) -> Codec ps failure m bytes -> ProtocolSizeLimits ps bytes -> ProtocolTimeLimits ps -> Channel m bytes -> Peer ps pr st m a -> m (a, Maybe bytes)

-- | Structured <a>Tracer</a> output for <a>runPeer</a> and derivitives.
data TraceSendRecv ps
[TraceSendMsg] :: AnyMessageAndAgency ps -> TraceSendRecv ps
[TraceRecvMsg] :: AnyMessageAndAgency ps -> TraceSendRecv ps

-- | Run a pipelined peer with the given channel via the given codec.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
--   
--   Unlike normal peers, running pipelined peers rely on concurrency,
--   hence the <a>MonadSTM</a> constraint.
runPipelinedPeerWithLimits :: forall ps (st :: ps) pr failure bytes m a. (MonadAsync m, MonadFork m, MonadMask m, MonadThrow (STM m), MonadMonotonicTime m, MonadTimer m, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps, Show failure) => Tracer m (TraceSendRecv ps) -> Codec ps failure m bytes -> ProtocolSizeLimits ps bytes -> ProtocolTimeLimits ps -> Channel m bytes -> PeerPipelined ps pr st m a -> m (a, Maybe bytes)
driverWithLimits :: forall ps failure bytes m. (MonadThrow m, Show failure, ShowProxy ps, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st')) => Tracer m (TraceSendRecv ps) -> TimeoutFn m -> Codec ps failure m bytes -> ProtocolSizeLimits ps bytes -> ProtocolTimeLimits ps -> Channel m bytes -> Driver ps (Maybe bytes) m
instance GHC.Show.Show Ouroboros.Network.Driver.Limits.ProtocolLimitFailure
instance GHC.Exception.Type.Exception Ouroboros.Network.Driver.Limits.ProtocolLimitFailure

module Ouroboros.Network.Protocol.Handshake.Codec

-- | <tt><a>Handshake</a></tt> codec. The
--   <tt><a>MsgProposeVersions</a></tt> encodes proposed map in ascending
--   order and it expects to receive them in this order. This allows to
--   construct the map in linear time. There is also another limiting
--   factor to the number of versions on can present: the whole message
--   must fit into a single TCP segment.
codecHandshake :: forall vNumber m failure. (MonadST m, Ord vNumber, Show failure) => CodecCBORTerm (failure, Maybe Int) vNumber -> Codec (Handshake vNumber Term) DeserialiseFailure m ByteString

-- | Byte limits
byteLimitsHandshake :: forall vNumber. ProtocolSizeLimits (Handshake vNumber Term) ByteString

-- | Time limits.
timeLimitsHandshake :: forall vNumber. ProtocolTimeLimits (Handshake vNumber Term)
noTimeLimitsHandshake :: forall vNumber. ProtocolTimeLimits (Handshake vNumber Term)
encodeRefuseReason :: CodecCBORTerm fail vNumber -> RefuseReason vNumber -> Encoding
decodeRefuseReason :: Show failure => CodecCBORTerm (failure, Maybe Int) vNumber -> Decoder s (RefuseReason vNumber)

-- | Codec for version data (<tt>vData</tt> in code) exchanged by the
--   handshake protocol.
--   
--   Note: <tt>extra</tt> type param is instantiated to
--   <tt>DictVersion</tt>; <tt>agreedOptions</tt> is instantiated to
--   <tt>NodeToNodeVersionData</tt> in <a>Ouroboros.Network.NodeToNode</a>
--   or to <tt>()</tt> in <a>Ouroboros.Network.NodeToClient</a>.
data VersionDataCodec bytes vNumber vData
VersionDataCodec :: (vNumber -> vData -> bytes) -> (vNumber -> bytes -> Either Text vData) -> VersionDataCodec bytes vNumber vData

-- | encoder of <tt>vData</tt> which has access to 'extra vData' which can
--   bring extra instances into the scope (by means of pattern matching on
--   a GADT).
[encodeData] :: VersionDataCodec bytes vNumber vData -> vNumber -> vData -> bytes

-- | decoder of <tt>vData</tt>.
[decodeData] :: VersionDataCodec bytes vNumber vData -> vNumber -> bytes -> Either Text vData
cborTermVersionDataCodec :: (vNumber -> CodecCBORTerm Text vData) -> VersionDataCodec Term vNumber vData


-- | Unversioned protocol, used in tests and demo applications.
module Ouroboros.Network.Protocol.Handshake.Unversioned

-- | Version negotiation for an unversioned protocol. We only use this for
--   tests and demos where proper versioning is excessive.
data UnversionedProtocol
UnversionedProtocol :: UnversionedProtocol
data UnversionedProtocolData
UnversionedProtocolData :: UnversionedProtocolData

-- | <a>Handshake</a> codec used in various tests.
unversionedHandshakeCodec :: MonadST m => Codec (Handshake UnversionedProtocol Term) DeserialiseFailure m ByteString
unversionedProtocolDataCodec :: VersionDataCodec Term UnversionedProtocol UnversionedProtocolData

-- | Make a <a>Versions</a> for an unversioned protocol. Only use this for
--   tests and demos where proper versioning is excessive.
unversionedProtocol :: app -> Versions UnversionedProtocol UnversionedProtocolData app

-- | Alternative for <a>UnversionedProtocolData</a> which contains
--   <a>DataFlow</a>.
newtype DataFlowProtocolData
DataFlowProtocolData :: DataFlow -> DataFlowProtocolData
[getProtocolDataFlow] :: DataFlowProtocolData -> DataFlow
dataFlowProtocolDataCodec :: UnversionedProtocol -> CodecCBORTerm Text DataFlowProtocolData
dataFlowProtocol :: DataFlow -> app -> Versions UnversionedProtocol DataFlowProtocolData app
instance GHC.Show.Show Ouroboros.Network.Protocol.Handshake.Unversioned.UnversionedProtocol
instance GHC.Classes.Ord Ouroboros.Network.Protocol.Handshake.Unversioned.UnversionedProtocol
instance GHC.Classes.Eq Ouroboros.Network.Protocol.Handshake.Unversioned.UnversionedProtocol
instance GHC.Show.Show Ouroboros.Network.Protocol.Handshake.Unversioned.UnversionedProtocolData
instance GHC.Classes.Eq Ouroboros.Network.Protocol.Handshake.Unversioned.UnversionedProtocolData
instance GHC.Show.Show Ouroboros.Network.Protocol.Handshake.Unversioned.DataFlowProtocolData
instance GHC.Classes.Eq Ouroboros.Network.Protocol.Handshake.Unversioned.DataFlowProtocolData
instance Ouroboros.Network.Protocol.Handshake.Version.Acceptable Ouroboros.Network.Protocol.Handshake.Unversioned.DataFlowProtocolData
instance Ouroboros.Network.Protocol.Handshake.Version.Acceptable Ouroboros.Network.Protocol.Handshake.Unversioned.UnversionedProtocolData

module Ouroboros.Network.Protocol.Handshake.Client

-- | Handshake client which offers <tt><a>Versions</a> vNumber vData</tt>
--   to the remote peer.
--   
--   TODO: GADT encoding of the client (<tt>Handshake.Client</tt> module).
handshakeClientPeer :: Ord vNumber => VersionDataCodec Term vNumber vData -> (vData -> vData -> Accept vData) -> Versions vNumber vData r -> Peer (Handshake vNumber Term) AsClient StPropose m (Either (HandshakeProtocolError vNumber) (r, vNumber, vData))
acceptOrRefuse :: forall vParams vNumber vData r. Ord vNumber => VersionDataCodec vParams vNumber vData -> (vData -> vData -> Accept vData) -> Versions vNumber vData r -> Map vNumber vParams -> Either (RefuseReason vNumber) (r, vNumber, vData)

module Ouroboros.Network.Protocol.Handshake.Server

-- | Server following the handshake protocol; it accepts highest version
--   offered by the peer that also belongs to the server <tt>versions</tt>.
handshakeServerPeer :: Ord vNumber => VersionDataCodec Term vNumber vData -> (vData -> vData -> Accept vData) -> Versions vNumber vData r -> Peer (Handshake vNumber Term) AsServer StPropose m (Either (HandshakeProtocolError vNumber) (r, vNumber, vData))


-- | API for running <a>Handshake</a> protocol.
module Ouroboros.Network.Protocol.Handshake

-- | Run client side of the <a>Handshake</a> protocol
runHandshakeClient :: (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m), Ord vNumber) => MuxBearer m -> connectionId -> HandshakeArguments connectionId vNumber vData m -> Versions vNumber vData application -> m (Either (HandshakeException vNumber) (application, vNumber, vData))

-- | Run server side of the <a>Handshake</a> protocol.
runHandshakeServer :: (MonadAsync m, MonadFork m, MonadMonotonicTime m, MonadTimer m, MonadMask m, MonadThrow (STM m), Ord vNumber) => MuxBearer m -> connectionId -> HandshakeArguments connectionId vNumber vData m -> Versions vNumber vData application -> m (Either (HandshakeException vNumber) (application, vNumber, vData))

-- | Common arguments for both <a>Handshake</a> client &amp; server.
data HandshakeArguments connectionId vNumber vData m
HandshakeArguments :: Tracer m (WithMuxBearer connectionId (TraceSendRecv (Handshake vNumber Term))) -> Codec (Handshake vNumber Term) DeserialiseFailure m ByteString -> VersionDataCodec Term vNumber vData -> (vData -> vData -> Accept vData) -> ProtocolTimeLimits (Handshake vNumber Term) -> HandshakeArguments connectionId vNumber vData m

-- | <a>Handshake</a> tracer
[haHandshakeTracer] :: HandshakeArguments connectionId vNumber vData m -> Tracer m (WithMuxBearer connectionId (TraceSendRecv (Handshake vNumber Term)))

-- | Codec for protocol messages.
[haHandshakeCodec] :: HandshakeArguments connectionId vNumber vData m -> Codec (Handshake vNumber Term) DeserialiseFailure m ByteString

-- | A codec for protocol parameters.
[haVersionDataCodec] :: HandshakeArguments connectionId vNumber vData m -> VersionDataCodec Term vNumber vData

-- | accept version, first argument is our version data the second argument
--   is the remote version data.
[haAcceptVersion] :: HandshakeArguments connectionId vNumber vData m -> vData -> vData -> Accept vData

-- | <tt>Driver</tt> timeouts for <a>Handshake</a> protocol.
[haTimeLimits] :: HandshakeArguments connectionId vNumber vData m -> ProtocolTimeLimits (Handshake vNumber Term)

-- | The version map supported by the local agent keyed on the version
--   identifier.
--   
--   Each <a>Version</a> contains a function which takes negotiated version
--   data and returns negotiated application (the <tt>r</tt> type
--   variable).
--   
--   If one needs to combine multiple versions the simplest way is to use
--   one of the combinators: <a>foldMapVersions</a>, <a>combineVersions</a>
--   or the <a>Semigroup</a> instance directly:
--   
--   <pre>
--   fold $ (simpleSingletonVersions ...)
--         :| [ (simpleSingletonVersions ...)
--            , (simpleSingletonVersions ...)
--            , ...
--            ]
--   </pre>
newtype Versions vNum vData r
Versions :: Map vNum (Version vData r) -> Versions vNum vData r
[getVersions] :: Versions vNum vData r -> Map vNum (Version vData r)

-- | Wrapper around initiator and responder errors experienced by
--   tryHandshake.
data HandshakeException vNumber
HandshakeProtocolLimit :: ProtocolLimitFailure -> HandshakeException vNumber
HandshakeProtocolError :: HandshakeProtocolError vNumber -> HandshakeException vNumber

-- | Extends handshake error <tt><a>RefuseReason</a></tt> type, by client
--   specific errors.
data HandshakeProtocolError vNumber
HandshakeError :: RefuseReason vNumber -> HandshakeProtocolError vNumber
NotRecognisedVersion :: vNumber -> HandshakeProtocolError vNumber
InvalidServerSelection :: vNumber -> Text -> HandshakeProtocolError vNumber

-- | Reasons by which a server can refuse proposed version.
data RefuseReason vNumber

-- | All of the prosed versions where not known to the server. Since the
--   server sends all versions that it can knows about, some of them we
--   might not be able to decode, so we include raw tags <tt>[Int]</tt>.
VersionMismatch :: [vNumber] -> [Int] -> RefuseReason vNumber

-- | The server failed to decode version parameters.
HandshakeDecodeError :: vNumber -> Text -> RefuseReason vNumber

-- | The server refused to run the proposed version parameters
Refused :: vNumber -> Text -> RefuseReason vNumber

-- | A <tt><a>Maybe</a></tt> like type which better explains its purpose.
data Accept vData
Accept :: vData -> Accept vData
Refuse :: !Text -> Accept vData
instance GHC.Show.Show vNumber => GHC.Show.Show (Ouroboros.Network.Protocol.Handshake.HandshakeException vNumber)


-- | Drivers for running <tt>Peer</tt>s with a <tt>Codec</tt> and a
--   <tt>Channel</tt>.
module Ouroboros.Network.Driver

-- | Run a peer with the given channel via the given codec.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
runPeer :: forall ps (st :: ps) pr failure bytes m a. (MonadThrow m, Show failure, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => Tracer m (TraceSendRecv ps) -> Codec ps failure m bytes -> Channel m bytes -> Peer ps pr st m a -> m (a, Maybe bytes)
runPeerWithLimits :: forall ps (st :: ps) pr failure bytes m a. (MonadAsync m, MonadFork m, MonadMask m, MonadThrow (STM m), MonadMonotonicTime m, MonadTimer m, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps, Show failure) => Tracer m (TraceSendRecv ps) -> Codec ps failure m bytes -> ProtocolSizeLimits ps bytes -> ProtocolTimeLimits ps -> Channel m bytes -> Peer ps pr st m a -> m (a, Maybe bytes)

-- | Structured <a>Tracer</a> output for <a>runPeer</a> and derivitives.
data TraceSendRecv ps
[TraceSendMsg] :: AnyMessageAndAgency ps -> TraceSendRecv ps
[TraceRecvMsg] :: AnyMessageAndAgency ps -> TraceSendRecv ps

-- | Run a pipelined peer with the given channel via the given codec.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
--   
--   Unlike normal peers, running pipelined peers rely on concurrency,
--   hence the <a>MonadSTM</a> constraint.
runPipelinedPeer :: forall ps (st :: ps) pr failure bytes m a. (MonadAsync m, MonadThrow m, Show failure, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => Tracer m (TraceSendRecv ps) -> Codec ps failure m bytes -> Channel m bytes -> PeerPipelined ps pr st m a -> m (a, Maybe bytes)

-- | Run a pipelined peer with the given channel via the given codec.
--   
--   This runs the peer to completion (if the protocol allows for
--   termination).
--   
--   Unlike normal peers, running pipelined peers rely on concurrency,
--   hence the <a>MonadSTM</a> constraint.
runPipelinedPeerWithLimits :: forall ps (st :: ps) pr failure bytes m a. (MonadAsync m, MonadFork m, MonadMask m, MonadThrow (STM m), MonadMonotonicTime m, MonadTimer m, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps, Show failure) => Tracer m (TraceSendRecv ps) -> Codec ps failure m bytes -> ProtocolSizeLimits ps bytes -> ProtocolTimeLimits ps -> Channel m bytes -> PeerPipelined ps pr st m a -> m (a, Maybe bytes)

module Ouroboros.Network.Mux
data MuxMode
[InitiatorMode] :: MuxMode
[ResponderMode] :: MuxMode
[InitiatorResponderMode] :: MuxMode

-- | Like <tt>MuxApplication</tt> but using a <a>MuxPeer</a> rather than a
--   raw <tt>Channel -&gt; m a</tt> action.
newtype OuroborosApplication (mode :: MuxMode) addr bytes m a b
OuroborosApplication :: (ConnectionId addr -> ControlMessageSTM m -> [MiniProtocol mode bytes m a b]) -> OuroborosApplication (mode :: MuxMode) addr bytes m a b
type MuxProtocolBundle (mode :: MuxMode) addr bytes m a b = ConnectionId addr -> ControlMessageSTM m -> [MiniProtocol mode bytes m a b]

-- | There are three kinds of applications: warm, hot and established (ones
--   that run in for both warm and hot peers).
data ProtocolTemperature
Established :: ProtocolTemperature
Warm :: ProtocolTemperature
Hot :: ProtocolTemperature

-- | Singletons for <tt>AppKind</tt>
data TokProtocolTemperature (pt :: ProtocolTemperature)
[TokHot] :: TokProtocolTemperature Hot
[TokWarm] :: TokProtocolTemperature Warm
[TokEstablished] :: TokProtocolTemperature Established
data SomeTokProtocolTemperature
[SomeTokProtocolTemperature] :: TokProtocolTemperature pt -> SomeTokProtocolTemperature

-- | We keep hot, warm and established application (or their context)
--   distinct. It's only needed for a handly <a>projectBundle</a> map.
data WithProtocolTemperature (pt :: ProtocolTemperature) a
[WithHot] :: !a -> WithProtocolTemperature Hot a
[WithWarm] :: !a -> WithProtocolTemperature Warm a
[WithEstablished] :: !a -> WithProtocolTemperature Established a
withoutProtocolTemperature :: WithProtocolTemperature pt a -> a
data WithSomeProtocolTemperature a
[WithSomeProtocolTemperature] :: WithProtocolTemperature pt a -> WithSomeProtocolTemperature a
withoutSomeProtocolTemperature :: WithSomeProtocolTemperature a -> a

-- | A bundle of <tt>HotApp</tt>, <tt>WarmApp</tt> and
--   <tt>EstablishedApp</tt>.
data Bundle a
Bundle :: !WithProtocolTemperature Hot a -> !WithProtocolTemperature Warm a -> !WithProtocolTemperature Established a -> Bundle a

-- | hot mini-protocols
[withHot] :: Bundle a -> !WithProtocolTemperature Hot a

-- | warm mini-protocols
[withWarm] :: Bundle a -> !WithProtocolTemperature Warm a

-- | established mini-protocols
[withEstablished] :: Bundle a -> !WithProtocolTemperature Established a
projectBundle :: TokProtocolTemperature pt -> Bundle a -> a
type OuroborosBundle (mode :: MuxMode) addr bytes m a b = Bundle (MuxProtocolBundle mode addr bytes m a b)
type MuxBundle (mode :: MuxMode) bytes m a b = Bundle [MiniProtocol mode bytes m a b]
data MiniProtocol (mode :: MuxMode) bytes m a b
MiniProtocol :: !MiniProtocolNum -> !MiniProtocolLimits -> !RunMiniProtocol mode bytes m a b -> MiniProtocol (mode :: MuxMode) bytes m a b
[miniProtocolNum] :: MiniProtocol (mode :: MuxMode) bytes m a b -> !MiniProtocolNum
[miniProtocolLimits] :: MiniProtocol (mode :: MuxMode) bytes m a b -> !MiniProtocolLimits
[miniProtocolRun] :: MiniProtocol (mode :: MuxMode) bytes m a b -> !RunMiniProtocol mode bytes m a b

-- | The wire format includes the protocol numbers, and it's vital that
--   these are stable. They are not necessarily dense however, as new ones
--   are added and some old ones retired. So we use a dedicated class for
--   this rather than reusing <a>Enum</a>. This also covers unrecognised
--   protocol numbers on the decoding side.
newtype MiniProtocolNum
MiniProtocolNum :: Word16 -> MiniProtocolNum

-- | Per Miniprotocol limits
data MiniProtocolLimits
MiniProtocolLimits :: !Int -> MiniProtocolLimits

-- | Limit on the maximum number of bytes that can be queued in the
--   miniprotocol's ingress queue.
[maximumIngressQueue] :: MiniProtocolLimits -> !Int
data RunMiniProtocol (mode :: MuxMode) bytes m a b
[InitiatorProtocolOnly] :: MuxPeer bytes m a -> RunMiniProtocol InitiatorMode bytes m a Void
[ResponderProtocolOnly] :: MuxPeer bytes m b -> RunMiniProtocol ResponderMode bytes m Void b
[InitiatorAndResponderProtocol] :: MuxPeer bytes m a -> MuxPeer bytes m b -> RunMiniProtocol InitiatorResponderMode bytes m a b
data MuxPeer bytes m a
[MuxPeer] :: forall (pr :: PeerRole) ps (st :: ps) failure bytes m a. (Show failure, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => Tracer m (TraceSendRecv ps) -> Codec ps failure m bytes -> Peer ps pr st m a -> MuxPeer bytes m a
[MuxPeerPipelined] :: forall (pr :: PeerRole) ps (st :: ps) failure bytes m a. (Show failure, forall (st' :: ps). Show (ClientHasAgency st'), forall (st' :: ps). Show (ServerHasAgency st'), ShowProxy ps) => Tracer m (TraceSendRecv ps) -> Codec ps failure m bytes -> PeerPipelined ps pr st m a -> MuxPeer bytes m a
[MuxPeerRaw] :: (Channel m bytes -> m (a, Maybe bytes)) -> MuxPeer bytes m a

-- | Run a <tt><a>MuxPeer</a></tt> using either <tt><a>runPeer</a></tt> or
--   <tt><a>runPipelinedPeer</a></tt>.
runMuxPeer :: (MonadCatch m, MonadAsync m) => MuxPeer bytes m a -> Channel m bytes -> m (a, Maybe bytes)
toApplication :: (MonadCatch m, MonadAsync m) => ConnectionId addr -> ControlMessageSTM m -> OuroborosApplication mode addr ByteString m a b -> MuxApplication mode m a b
mkMuxApplicationBundle :: forall mode addr bytes m a b. ConnectionId addr -> Bundle (ControlMessageSTM m) -> OuroborosBundle mode addr bytes m a b -> MuxBundle mode bytes m a b

-- | Make <a>MiniProtocolBundle</a>, which is used to create a mux
--   interface with <tt>newMux</tt>. The output of
--   <a>mkMuxApplicationBundle</a> can be used as input.
mkMiniProtocolBundle :: MuxBundle mode bytes m a b -> MiniProtocolBundle mode

-- | Control signal sent to a mini-protocol. expected to exit, on
--   <a>Continue</a> it should continue its operation
data ControlMessage

-- | Continue operation.
Continue :: ControlMessage

-- | Hold on, e.g. do not sent messages until resumed. This is not used for
--   any hot protocol.
Quiesce :: ControlMessage

-- | The client is expected to terminate as soon as possible.
Terminate :: ControlMessage

-- | <a>ControlMessageSTM</a> should depend on <tt>muxMode</tt> (we only
--   need to shedule stop for intiator side). This is not done only because
--   this would break tests, but once the old api is removed it should be
--   possible.
type ControlMessageSTM m = STM m ControlMessage
continueForever :: Applicative (STM m) => proxy m -> ControlMessageSTM m

-- | First to finish synchronisation between <a>Terminate</a> state of
--   <a>ControlMessage</a> and an stm action.
--   
--   This should return <tt>STM m (Maybe a)</tt> but <a>STM</a> is a
--   non-injective type family, and we would need to pass <tt>Proxy m</tt>
--   to fix an ambiuous type (or use <tt>AllowAmbiguousTypes</tt>
--   extension).
timeoutWithControlMessage :: MonadSTM m => ControlMessageSTM m -> STM m a -> m (Maybe a)

-- | Error type used in across the mux layer.
data MuxError
MuxError :: !MuxErrorType -> !String -> MuxError
[errorType] :: MuxError -> !MuxErrorType
[errorMsg] :: MuxError -> !String

-- | Enumeration of error conditions.
data MuxErrorType

-- | returned by <tt>decodeMuxSDUHeader</tt>, thrown by <a>MuxBearer</a>.
MuxUnknownMiniProtocol :: MuxErrorType

-- | return by <tt>decodeMuxSDUHeader</tt>, thrown by <a>MuxBearer</a>.
MuxDecodeError :: MuxErrorType

-- | thrown by <a>MuxBearer</a> when received a null byte.
MuxBearerClosed :: MuxErrorType

-- | thrown by <tt>demux</tt> when violating <a>maximumIngressQueue</a>
--   byte limit.
MuxIngressQueueOverRun :: MuxErrorType

-- | thrown when data arrives on a responder channel when the mux was set
--   up as an <tt>InitiatorApp</tt>.
MuxInitiatorOnly :: MuxErrorType

-- | <a>IOException</a> thrown by
MuxIOException :: IOException -> MuxErrorType

-- | thrown when reading of a single SDU takes too long
MuxSDUReadTimeout :: MuxErrorType

-- | thrown when writing a single SDU takes too long
MuxSDUWriteTimeout :: MuxErrorType

-- | Result of runMiniProtocol's completionAction in case of an error or
--   mux being closed while a mini-protocol was still running, this is not
--   a clean exit.
MuxShutdown :: !Maybe MuxErrorType -> MuxErrorType

-- | Mux stopped by <tt>stopMux</tt>
MuxCleanShutdown :: MuxErrorType
type family HasInitiator (mode :: MuxMode) :: Bool
type family HasResponder (mode :: MuxMode) :: Bool
instance GHC.Show.Show Ouroboros.Network.Mux.ControlMessage
instance GHC.Classes.Eq Ouroboros.Network.Mux.ControlMessage
instance GHC.Show.Show Ouroboros.Network.Mux.ProtocolTemperature
instance GHC.Classes.Ord Ouroboros.Network.Mux.ProtocolTemperature
instance GHC.Classes.Eq Ouroboros.Network.Mux.ProtocolTemperature
instance Data.Traversable.Traversable Ouroboros.Network.Mux.Bundle
instance Data.Foldable.Foldable Ouroboros.Network.Mux.Bundle
instance GHC.Base.Functor Ouroboros.Network.Mux.Bundle
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Mux.Bundle a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Ouroboros.Network.Mux.Bundle a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Ouroboros.Network.Mux.WithProtocolTemperature pt a)
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Mux.WithProtocolTemperature pt a)
instance GHC.Base.Functor (Ouroboros.Network.Mux.WithProtocolTemperature pt)
instance Data.Foldable.Foldable (Ouroboros.Network.Mux.WithProtocolTemperature pt)
instance Data.Traversable.Traversable (Ouroboros.Network.Mux.WithProtocolTemperature pt)
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Mux.WithSomeProtocolTemperature a)
instance GHC.Base.Functor Ouroboros.Network.Mux.WithSomeProtocolTemperature
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Ouroboros.Network.Mux.Bundle a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Ouroboros.Network.Mux.Bundle a)
instance GHC.Base.Applicative Ouroboros.Network.Mux.Bundle
instance GHC.Base.Applicative (Ouroboros.Network.Mux.WithProtocolTemperature 'Ouroboros.Network.Mux.Hot)
instance GHC.Base.Applicative (Ouroboros.Network.Mux.WithProtocolTemperature 'Ouroboros.Network.Mux.Warm)
instance GHC.Base.Applicative (Ouroboros.Network.Mux.WithProtocolTemperature 'Ouroboros.Network.Mux.Established)
instance GHC.Base.Semigroup a => GHC.Base.Semigroup (Ouroboros.Network.Mux.WithProtocolTemperature pt a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Ouroboros.Network.Mux.WithProtocolTemperature 'Ouroboros.Network.Mux.Hot a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Ouroboros.Network.Mux.WithProtocolTemperature 'Ouroboros.Network.Mux.Warm a)
instance GHC.Base.Monoid a => GHC.Base.Monoid (Ouroboros.Network.Mux.WithProtocolTemperature 'Ouroboros.Network.Mux.Established a)


-- | Module exports interface for running a node over a socket over TCP /
--   IP.
module Ouroboros.Network.Socket
data ConnectionTable m addr
data ConnectionTableRef

-- | No connection to peer exists, attempt to create one.
ConnectionTableCreate :: ConnectionTableRef

-- | A connection to the peer existed, either from another subscriber or
--   the peer opened one towards us.
ConnectionTableExist :: ConnectionTableRef

-- | This subscriber already has counted a connection to this peer. It must
--   try another target.
ConnectionTableDuplicate :: ConnectionTableRef

-- | ValencyCounter represents how many active connections we have towards
--   a given peer. It starts out with a positive value representing a
--   desired number of connections for a specific subscription worker. It
--   can become negative, for example if a peer opens multiple connections
--   to us. The vcId is unique per ConnectionTable and ensures that we
--   won't count the same connection twice.
data ValencyCounter m

-- | Mutable state maintained by the network component.
data NetworkMutableState addr
NetworkMutableState :: ConnectionTable IO addr -> StrictTVar IO (PeerStates IO addr) -> NetworkMutableState addr

-- | <a>ConnectionTable</a> which maintains information about current
--   upstream and downstream connections.
[nmsConnectionTable] :: NetworkMutableState addr -> ConnectionTable IO addr

-- | <a>PeerStates</a> which maintains state of each downstream / upstream
--   peer that errored, misbehaved or was not interesting to us.
[nmsPeerStates] :: NetworkMutableState addr -> StrictTVar IO (PeerStates IO addr)

-- | Wrapper for OuroborosResponderApplication and
--   OuroborosInitiatorAndResponderApplication.
data SomeResponderApplication addr bytes m b
[SomeResponderApplication] :: forall appType addr bytes m a b. HasResponder appType ~ True => OuroborosApplication appType addr bytes m a b -> SomeResponderApplication addr bytes m b
newNetworkMutableState :: IO (NetworkMutableState addr)
newNetworkMutableStateSTM :: STM (NetworkMutableState addr)

-- | Clean <a>PeerStates</a> within <a>NetworkMutableState</a> every 200s
cleanNetworkMutableState :: NetworkMutableState addr -> IO ()

-- | Policy which governs how to limit the number of accepted connections.
data AcceptedConnectionsLimit
AcceptedConnectionsLimit :: !Word32 -> !Word32 -> !DiffTime -> AcceptedConnectionsLimit

-- | Hard limit of accepted connections.
[acceptedConnectionsHardLimit] :: AcceptedConnectionsLimit -> !Word32

-- | Soft limit of accepted connections. If we are above this threshold, we
--   will start rate limiting.
[acceptedConnectionsSoftLimit] :: AcceptedConnectionsLimit -> !Word32

-- | Max delay for limiting accepted connections. We use linear regression
--   starting from 0 at the soft limit up to
--   <tt>acceptedConnectionDelay</tt> at the hard limit.
[acceptedConnectionsDelay] :: AcceptedConnectionsLimit -> !DiffTime

-- | Connection is identified by local and remote address.
--   
--   TODO: the type variable which this data type fills in is called
--   <tt>peerid</tt>. We should renamed to <tt>connectionId</tt>.
data ConnectionId addr
ConnectionId :: !addr -> !addr -> ConnectionId addr
[localAddress] :: ConnectionId addr -> !addr
[remoteAddress] :: ConnectionId addr -> !addr

-- | Run a server application. It will listen on the given address for
--   incoming connection, otherwise like withServerNode'.
withServerNode :: forall vNumber vData t fd addr b. (Ord vNumber, Typeable vNumber, Show vNumber, Ord addr) => Snocket IO fd addr -> NetworkServerTracers addr vNumber -> NetworkMutableState addr -> AcceptedConnectionsLimit -> addr -> Codec (Handshake vNumber Term) DeserialiseFailure IO ByteString -> ProtocolTimeLimits (Handshake vNumber Term) -> VersionDataCodec Term vNumber vData -> (vData -> vData -> Accept vData) -> Versions vNumber vData (SomeResponderApplication addr ByteString IO b) -> ErrorPolicies -> (addr -> Async Void -> IO t) -> IO t

-- | Run a server application on the provided socket. The socket must be
--   ready to accept connections. The server thread runs using
--   <tt>withAsync</tt> function, which means that it will terminate when
--   the callback terminates or throws an exception.
--   
--   TODO: we should track connections in the state and refuse connections
--   from peers we are already connected to. This is also the right place
--   to ban connection from peers which missbehaved.
--   
--   The server will run handshake protocol on each incoming connection. We
--   assume that each versin negotiation message should fit into
--   <tt><tt>maxTransmissionUnit</tt></tt> (~5k bytes).
--   
--   Note: it will open a socket in the current thread and pass it to the
--   spawned thread which runs the server. This makes it useful for
--   testing, where we need to guarantee that a socket is open before we
--   try to connect to it.
withServerNode' :: forall vNumber vData t fd addr b. (Ord vNumber, Typeable vNumber, Show vNumber, Ord addr) => Snocket IO fd addr -> NetworkServerTracers addr vNumber -> NetworkMutableState addr -> AcceptedConnectionsLimit -> fd -> Codec (Handshake vNumber Term) DeserialiseFailure IO ByteString -> ProtocolTimeLimits (Handshake vNumber Term) -> VersionDataCodec Term vNumber vData -> (vData -> vData -> Accept vData) -> Versions vNumber vData (SomeResponderApplication addr ByteString IO b) -> ErrorPolicies -> (addr -> Async Void -> IO t) -> IO t

-- | Connect to a remote node. It is using bracket to enclose the
--   underlying socket acquisition. This implies that when the continuation
--   exits the underlying bearer will get closed.
--   
--   The connection will start with handshake protocol sending
--   <tt>Versions</tt> to the remote peer. It must fit into
--   <tt><tt>maxTransmissionUnit</tt></tt> (~5k bytes).
--   
--   Exceptions thrown by <tt><tt>MuxApplication</tt></tt> are rethrown by
--   <tt><tt>connectTo</tt></tt>.
connectToNode :: forall appType vNumber vData fd addr a b. (Ord vNumber, Typeable vNumber, Show vNumber, HasInitiator appType ~ True) => Snocket IO fd addr -> Codec (Handshake vNumber Term) DeserialiseFailure IO ByteString -> ProtocolTimeLimits (Handshake vNumber Term) -> VersionDataCodec Term vNumber vData -> NetworkConnectTracers addr vNumber -> (vData -> vData -> Accept vData) -> Versions vNumber vData (OuroborosApplication appType addr ByteString IO a b) -> Maybe addr -> addr -> IO ()
connectToNodeSocket :: forall appType vNumber vData a b. (Ord vNumber, Typeable vNumber, Show vNumber, HasInitiator appType ~ True) => IOManager -> Codec (Handshake vNumber Term) DeserialiseFailure IO ByteString -> ProtocolTimeLimits (Handshake vNumber Term) -> VersionDataCodec Term vNumber vData -> NetworkConnectTracers SockAddr vNumber -> (vData -> vData -> Accept vData) -> Versions vNumber vData (OuroborosApplication appType SockAddr ByteString IO a b) -> Socket -> IO ()

-- | Connect to a remote node using an existing socket. It is up to to
--   caller to ensure that the socket is closed in case of an exception.
--   
--   The connection will start with handshake protocol sending
--   <tt>Versions</tt> to the remote peer. It must fit into
--   <tt><tt>maxTransmissionUnit</tt></tt> (~5k bytes).
--   
--   Exceptions thrown by <tt><tt>MuxApplication</tt></tt> are rethrown by
--   <tt><tt>connectTo</tt></tt>.
connectToNode' :: forall appType vNumber vData fd addr a b. (Ord vNumber, Typeable vNumber, Show vNumber, HasInitiator appType ~ True) => Snocket IO fd addr -> Codec (Handshake vNumber Term) DeserialiseFailure IO ByteString -> ProtocolTimeLimits (Handshake vNumber Term) -> VersionDataCodec Term vNumber vData -> NetworkConnectTracers addr vNumber -> (vData -> vData -> Accept vData) -> Versions vNumber vData (OuroborosApplication appType addr ByteString IO a b) -> fd -> IO ()

-- | Tracer used by <a>connectToNode</a> (and derivatives, like
--   <a>connectTo</a> or 'Ouroboros.Network.NodeToClient.connectTo).
data NetworkConnectTracers addr vNumber
NetworkConnectTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> NetworkConnectTracers addr vNumber

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[nctMuxTracer] :: NetworkConnectTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[nctHandshakeTracer] :: NetworkConnectTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))
nullNetworkConnectTracers :: NetworkConnectTracers addr vNumber
debuggingNetworkConnectTracers :: (Show addr, Show vNumber) => NetworkConnectTracers addr vNumber

-- | Tracers required by a server which handles inbound connections.
data NetworkServerTracers addr vNumber
NetworkServerTracers :: Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> Tracer IO (WithAddr addr ErrorPolicyTrace) -> Tracer IO AcceptConnectionsPolicyTrace -> NetworkServerTracers addr vNumber

-- | low level mux-network tracer, which logs mux sdu (send and received)
--   and other low level multiplexing events.
[nstMuxTracer] :: NetworkServerTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace)

-- | handshake protocol tracer; it is important for analysing version
--   negotation mismatches.
[nstHandshakeTracer] :: NetworkServerTracers addr vNumber -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term)))

-- | error policy tracer; must not be <a>nullTracer</a>, otherwise all the
--   exceptions which are not matched by any error policy will be caught
--   and not logged or rethrown.
[nstErrorPolicyTracer] :: NetworkServerTracers addr vNumber -> Tracer IO (WithAddr addr ErrorPolicyTrace)

-- | tracing rate limiting of accepting connections.
[nstAcceptPolicyTracer] :: NetworkServerTracers addr vNumber -> Tracer IO AcceptConnectionsPolicyTrace
nullNetworkServerTracers :: NetworkServerTracers addr vNumber
debuggingNetworkServerTracers :: (Show addr, Show vNumber) => NetworkServerTracers addr vNumber

-- | Trace for the <tt>AcceptConnectionsLimit</tt> policy.
data AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionRateLimiting :: DiffTime -> Int -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionHardLimit :: Word32 -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionResume :: Int -> AcceptConnectionsPolicyTrace

-- | Make a server-compatible socket from a network socket.
fromSnocket :: forall fd addr. Ord addr => ConnectionTable IO addr -> Snocket IO fd addr -> fd -> IO (Socket addr fd)

-- | Accept or reject incoming connection based on the current state and
--   address of the incoming connection.
beginConnection :: forall vNumber vData addr st fd. (Ord vNumber, Typeable vNumber, Show vNumber) => Snocket IO fd addr -> Tracer IO (WithMuxBearer (ConnectionId addr) MuxTrace) -> Tracer IO (WithMuxBearer (ConnectionId addr) (TraceSendRecv (Handshake vNumber Term))) -> Codec (Handshake vNumber Term) DeserialiseFailure IO ByteString -> ProtocolTimeLimits (Handshake vNumber Term) -> VersionDataCodec Term vNumber vData -> (vData -> vData -> Accept vData) -> (Time -> addr -> st -> STM (AcceptConnection st vNumber vData addr IO ByteString)) -> BeginConnection addr fd st ()

-- | Map from addresses to <a>PeerState</a>s; it will be be shared in a
--   <a>StrictTVar</a>.
--   
--   Abstracting <tt>t</tt> is useful for tests, the <tt>IO</tt> version
--   will use <tt>Time IO</tt>.
data PeerStates m addr
newConnectionTable :: MonadSTM m => m (ConnectionTable m addr)
refConnection :: (MonadSTM m, Ord addr) => ConnectionTable m addr -> addr -> ValencyCounter m -> m ConnectionTableRef

-- | Insert a new connection into the ConnectionTable.
addConnection :: forall m addr. (MonadSTM m, Ord addr) => ConnectionTable m addr -> addr -> addr -> Maybe (ValencyCounter m) -> STM m ()
removeConnection :: forall m addr. (MonadSTM m, Ord addr) => ConnectionTable m addr -> addr -> addr -> m ()

-- | Create a new ValencyCounter
newValencyCounter :: MonadSTM m => ConnectionTable m addr -> Int -> STM m (ValencyCounter m)

-- | Add a connection.
addValencyCounter :: MonadSTM m => ValencyCounter m -> STM m ()

-- | Remove a connection.
remValencyCounter :: MonadSTM m => ValencyCounter m -> STM m ()

-- | Wait until ValencyCounter becomes positive, used for detecting when we
--   can create new connections.
waitValencyCounter :: MonadSTM m => ValencyCounter m -> STM m ()

-- | Returns current ValencyCounter value, represent the number of
--   additional connections that can be created. May be negative.
readValencyCounter :: MonadSTM m => ValencyCounter m -> STM m Int
sockAddrFamily :: SockAddr -> Family
instance Data.Hashable.Class.Hashable Network.Socket.Types.SockAddr


-- | IP subscription worker implentation.
module Ouroboros.Network.Subscription.Ip

-- | <a>ipSubscriptionWorker</a> and <tt>dnsSubscriptionWorker</tt>
--   parameters
data SubscriptionParams a target
SubscriptionParams :: LocalAddresses SockAddr -> (SockAddr -> Maybe DiffTime) -> ErrorPolicies -> target -> SubscriptionParams a target
[spLocalAddresses] :: SubscriptionParams a target -> LocalAddresses SockAddr

-- | should return expected delay for the given address
[spConnectionAttemptDelay] :: SubscriptionParams a target -> SockAddr -> Maybe DiffTime
[spErrorPolicies] :: SubscriptionParams a target -> ErrorPolicies
[spSubscriptionTarget] :: SubscriptionParams a target -> target
type IPSubscriptionParams a = SubscriptionParams a IPSubscriptionTarget

-- | Spawns a subscription worker which will attempt to keep the specified
--   number of connections (Valency) active towards the list of IP
--   addresses given in IPSubscriptionTarget.
ipSubscriptionWorker :: forall a. Snocket IO Socket SockAddr -> Tracer IO (WithIPList (SubscriptionTrace SockAddr)) -> Tracer IO (WithAddr SockAddr ErrorPolicyTrace) -> NetworkMutableState SockAddr -> IPSubscriptionParams a -> (Socket -> IO a) -> IO Void

-- | Like <a>worker</a> but in <a>IO</a>; It provides address selection
--   function, <a>SocketStateChange</a> and <a>CompleteApplication</a>
--   callbacks. The <a>Main</a> callback is left as it's useful for testing
--   purposes.
subscriptionWorker :: Snocket IO Socket SockAddr -> Tracer IO (SubscriptionTrace SockAddr) -> Tracer IO (WithAddr SockAddr ErrorPolicyTrace) -> NetworkMutableState SockAddr -> WorkerParams IO LocalAddresses SockAddr -> ErrorPolicies -> Main IO (PeerStates IO SockAddr) x -> (Socket -> IO a) -> IO x
data IPSubscriptionTarget
IPSubscriptionTarget :: ![SockAddr] -> !Int -> IPSubscriptionTarget

-- | List of destinations to possibly connect to
[ispIps] :: IPSubscriptionTarget -> ![SockAddr]

-- | Number of parallel connections to keep actice.
[ispValency] :: IPSubscriptionTarget -> !Int
ipSubscriptionTarget :: forall m addr. (MonadSTM m, MonadTime m, Ord addr) => Tracer m (SubscriptionTrace addr) -> StrictTVar m (PeerStates m addr) -> [addr] -> SubscriptionTarget m addr
data SubscriptionTrace addr
SubscriptionTraceConnectStart :: addr -> SubscriptionTrace addr
SubscriptionTraceConnectEnd :: addr -> ConnectResult -> SubscriptionTrace addr
SubscriptionTraceSocketAllocationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceConnectException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceApplicationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceTryConnectToPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSkippingPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSubscriptionRunning :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaiting :: Int -> SubscriptionTrace addr
SubscriptionTraceSubscriptionFailed :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaitingNewConnection :: DiffTime -> SubscriptionTrace addr
SubscriptionTraceStart :: Int -> SubscriptionTrace addr
SubscriptionTraceRestart :: DiffTime -> Int -> Int -> SubscriptionTrace addr
SubscriptionTraceConnectionExist :: addr -> SubscriptionTrace addr
SubscriptionTraceUnsupportedRemoteAddr :: addr -> SubscriptionTrace addr
SubscriptionTraceMissingLocalAddress :: SubscriptionTrace addr
SubscriptionTraceAllocateSocket :: addr -> SubscriptionTrace addr
SubscriptionTraceCloseSocket :: addr -> SubscriptionTrace addr

-- | Trace data for error policies
data ErrorPolicyTrace

-- | suspending peer with a given exception until
ErrorPolicySuspendPeer :: Maybe (ConnectionOrApplicationExceptionTrace SomeException) -> DiffTime -> DiffTime -> ErrorPolicyTrace

-- | suspending consumer until
ErrorPolicySuspendConsumer :: Maybe (ConnectionOrApplicationExceptionTrace SomeException) -> DiffTime -> ErrorPolicyTrace

-- | caught a local exception
ErrorPolicyLocalNodeError :: ConnectionOrApplicationExceptionTrace SomeException -> ErrorPolicyTrace

-- | resume a peer (both consumer and producer)
ErrorPolicyResumePeer :: ErrorPolicyTrace

-- | consumer was suspended until producer will resume
ErrorPolicyKeepSuspended :: ErrorPolicyTrace

-- | resume consumer
ErrorPolicyResumeConsumer :: ErrorPolicyTrace

-- | resume producer
ErrorPolicyResumeProducer :: ErrorPolicyTrace

-- | an application throwed an exception, which was not handled by any
--   <a>ErrorPolicy</a>.
ErrorPolicyUnhandledApplicationException :: SomeException -> ErrorPolicyTrace

-- | <tt>connect</tt> throwed an exception, which was not handled by any
--   <a>ErrorPolicy</a>.
ErrorPolicyUnhandledConnectionException :: SomeException -> ErrorPolicyTrace

-- | <tt>accept</tt> throwed an exception
ErrorPolicyAcceptException :: IOException -> ErrorPolicyTrace
data WithIPList a
WithIPList :: LocalAddresses SockAddr -> [SockAddr] -> a -> WithIPList a
[wilSrc] :: WithIPList a -> LocalAddresses SockAddr
[wilDsts] :: WithIPList a -> [SockAddr]
[wilEvent] :: WithIPList a -> a

-- | Check state before connecting to a remote peer. We will connect only
--   if it retuns <a>True</a>.
type BeforeConnect m s addr = Time -> addr -> s -> STM m (ConnectDecision s)

-- | Run <a>BeforeConnect</a> callback in a <a>MonadTime</a> monad.
runBeforeConnect :: (MonadSTM m, MonadTime m) => StrictTVar m s -> BeforeConnect m s addr -> addr -> m Bool

-- | <a>BeforeConnect</a> callback: it updates peer state and return
--   boolean value wheather to connect to it or not. If a peer hasn't been
--   recorded in <a>PeerStates</a>, we add it and try to connect to it.
beforeConnectTx :: forall m addr. (MonadSTM m, Ord addr) => BeforeConnect m (PeerStates m addr) addr

-- | <a>CompleteApplication</a> callback
completeApplicationTx :: forall m addr a. (MonadAsync m, Ord addr, Ord (Async m ())) => ErrorPolicies -> CompleteApplication m (PeerStates m addr) addr a
socketStateChangeTx :: Ord addr => SocketStateChange IO (PeerStates IO addr) addr

-- | Main callback. It throws an exception when the state becomes
--   <a>ThrowException</a>. This exception is thrown from the main thread.
mainTx :: (MonadThrow (STM m), MonadSTM m) => Main m (PeerStates m addr) Void
selectSockAddr :: SockAddr -> LocalAddresses SockAddr -> Maybe SockAddr
instance GHC.Show.Show Ouroboros.Network.Subscription.Ip.IPSubscriptionTarget
instance GHC.Classes.Eq Ouroboros.Network.Subscription.Ip.IPSubscriptionTarget
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Subscription.Ip.WithIPList a)

module Ouroboros.Network.Subscription.Dns
data DnsSubscriptionTarget
DnsSubscriptionTarget :: !Domain -> !PortNumber -> !Int -> DnsSubscriptionTarget
[dstDomain] :: DnsSubscriptionTarget -> !Domain
[dstPort] :: DnsSubscriptionTarget -> !PortNumber
[dstValency] :: DnsSubscriptionTarget -> !Int
data Resolver m
Resolver :: (Domain -> m (Either DNSError [SockAddr])) -> (Domain -> m (Either DNSError [SockAddr])) -> Resolver m
[lookupA] :: Resolver m -> Domain -> m (Either DNSError [SockAddr])
[lookupAAAA] :: Resolver m -> Domain -> m (Either DNSError [SockAddr])
type DnsSubscriptionParams a = SubscriptionParams a DnsSubscriptionTarget
dnsSubscriptionWorker' :: Snocket IO Socket SockAddr -> Tracer IO (WithDomainName (SubscriptionTrace SockAddr)) -> Tracer IO (WithDomainName DnsTrace) -> Tracer IO (WithAddr SockAddr ErrorPolicyTrace) -> NetworkMutableState SockAddr -> IO b -> (b -> (Resolver IO -> IO (SubscriptionTarget IO SockAddr)) -> IO (SubscriptionTarget IO SockAddr)) -> DnsSubscriptionParams a -> Main IO (PeerStates IO SockAddr) x -> (Socket -> IO a) -> IO x
dnsSubscriptionWorker :: Snocket IO Socket SockAddr -> Tracer IO (WithDomainName (SubscriptionTrace SockAddr)) -> Tracer IO (WithDomainName DnsTrace) -> Tracer IO (WithAddr SockAddr ErrorPolicyTrace) -> NetworkMutableState SockAddr -> DnsSubscriptionParams a -> (Socket -> IO a) -> IO Void
dnsResolve :: forall a m s. (MonadAsync m, MonadCatch m, MonadTime m, MonadTimer m) => Tracer m DnsTrace -> m a -> (a -> (Resolver m -> m (SubscriptionTarget m SockAddr)) -> m (SubscriptionTarget m SockAddr)) -> StrictTVar m s -> BeforeConnect m s SockAddr -> DnsSubscriptionTarget -> m (SubscriptionTarget m SockAddr)

-- | Time to wait for an AAAA response after receiving an A response.
resolutionDelay :: DiffTime
data SubscriptionTrace addr
SubscriptionTraceConnectStart :: addr -> SubscriptionTrace addr
SubscriptionTraceConnectEnd :: addr -> ConnectResult -> SubscriptionTrace addr
SubscriptionTraceSocketAllocationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceConnectException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceApplicationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceTryConnectToPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSkippingPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSubscriptionRunning :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaiting :: Int -> SubscriptionTrace addr
SubscriptionTraceSubscriptionFailed :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaitingNewConnection :: DiffTime -> SubscriptionTrace addr
SubscriptionTraceStart :: Int -> SubscriptionTrace addr
SubscriptionTraceRestart :: DiffTime -> Int -> Int -> SubscriptionTrace addr
SubscriptionTraceConnectionExist :: addr -> SubscriptionTrace addr
SubscriptionTraceUnsupportedRemoteAddr :: addr -> SubscriptionTrace addr
SubscriptionTraceMissingLocalAddress :: SubscriptionTrace addr
SubscriptionTraceAllocateSocket :: addr -> SubscriptionTrace addr
SubscriptionTraceCloseSocket :: addr -> SubscriptionTrace addr
data DnsTrace
DnsTraceLookupException :: SomeException -> DnsTrace
DnsTraceLookupAError :: DNSError -> DnsTrace
DnsTraceLookupAAAAError :: DNSError -> DnsTrace
DnsTraceLookupIPv6First :: DnsTrace
DnsTraceLookupIPv4First :: DnsTrace
DnsTraceLookupAResult :: [SockAddr] -> DnsTrace
DnsTraceLookupAAAAResult :: [SockAddr] -> DnsTrace

-- | Trace data for error policies
data ErrorPolicyTrace

-- | suspending peer with a given exception until
ErrorPolicySuspendPeer :: Maybe (ConnectionOrApplicationExceptionTrace SomeException) -> DiffTime -> DiffTime -> ErrorPolicyTrace

-- | suspending consumer until
ErrorPolicySuspendConsumer :: Maybe (ConnectionOrApplicationExceptionTrace SomeException) -> DiffTime -> ErrorPolicyTrace

-- | caught a local exception
ErrorPolicyLocalNodeError :: ConnectionOrApplicationExceptionTrace SomeException -> ErrorPolicyTrace

-- | resume a peer (both consumer and producer)
ErrorPolicyResumePeer :: ErrorPolicyTrace

-- | consumer was suspended until producer will resume
ErrorPolicyKeepSuspended :: ErrorPolicyTrace

-- | resume consumer
ErrorPolicyResumeConsumer :: ErrorPolicyTrace

-- | resume producer
ErrorPolicyResumeProducer :: ErrorPolicyTrace

-- | an application throwed an exception, which was not handled by any
--   <a>ErrorPolicy</a>.
ErrorPolicyUnhandledApplicationException :: SomeException -> ErrorPolicyTrace

-- | <tt>connect</tt> throwed an exception, which was not handled by any
--   <a>ErrorPolicy</a>.
ErrorPolicyUnhandledConnectionException :: SomeException -> ErrorPolicyTrace

-- | <tt>accept</tt> throwed an exception
ErrorPolicyAcceptException :: IOException -> ErrorPolicyTrace
data WithDomainName a
WithDomainName :: Domain -> a -> WithDomainName a
[wdnDomain] :: WithDomainName a -> Domain
[wdnEvent] :: WithDomainName a -> a
data WithAddr addr a
WithAddr :: addr -> a -> WithAddr addr a
[wiaAddr] :: WithAddr addr a -> addr
[wiaEvent] :: WithAddr addr a -> a
instance GHC.Show.Show Ouroboros.Network.Subscription.Dns.DnsSubscriptionTarget
instance GHC.Classes.Eq Ouroboros.Network.Subscription.Dns.DnsSubscriptionTarget
instance GHC.Show.Show Ouroboros.Network.Subscription.Dns.DnsTrace
instance GHC.Show.Show a => GHC.Show.Show (Ouroboros.Network.Subscription.Dns.WithDomainName a)


-- | Public interface of <a>Subscription</a> workers.
module Ouroboros.Network.Subscription

-- | Spawns a subscription worker which will attempt to keep the specified
--   number of connections (Valency) active towards the list of IP
--   addresses given in IPSubscriptionTarget.
ipSubscriptionWorker :: forall a. Snocket IO Socket SockAddr -> Tracer IO (WithIPList (SubscriptionTrace SockAddr)) -> Tracer IO (WithAddr SockAddr ErrorPolicyTrace) -> NetworkMutableState SockAddr -> IPSubscriptionParams a -> (Socket -> IO a) -> IO Void
data IPSubscriptionTarget
IPSubscriptionTarget :: ![SockAddr] -> !Int -> IPSubscriptionTarget

-- | List of destinations to possibly connect to
[ispIps] :: IPSubscriptionTarget -> ![SockAddr]

-- | Number of parallel connections to keep actice.
[ispValency] :: IPSubscriptionTarget -> !Int
dnsSubscriptionWorker :: Snocket IO Socket SockAddr -> Tracer IO (WithDomainName (SubscriptionTrace SockAddr)) -> Tracer IO (WithDomainName DnsTrace) -> Tracer IO (WithAddr SockAddr ErrorPolicyTrace) -> NetworkMutableState SockAddr -> DnsSubscriptionParams a -> (Socket -> IO a) -> IO Void
data DnsSubscriptionTarget
DnsSubscriptionTarget :: !Domain -> !PortNumber -> !Int -> DnsSubscriptionTarget
[dstDomain] :: DnsSubscriptionTarget -> !Domain
[dstPort] :: DnsSubscriptionTarget -> !PortNumber
[dstValency] :: DnsSubscriptionTarget -> !Int

-- | GADT which classifies connection result.
data ConnectResult

-- | Successful connection.
ConnectSuccess :: ConnectResult

-- | Successfully connection, reached the valency target. Other ongoing
--   connection attempts will be killed.
ConnectSuccessLast :: ConnectResult

-- | Someone else manged to create the final connection to a target before
--   us.
ConnectValencyExceeded :: ConnectResult

-- | Time to wait between connection attempts when we don't have any DeltaQ
--   info.
defaultConnectionAttemptDelay :: DiffTime

-- | Minimum time to wait between connection attempts.
minConnectionAttemptDelay :: DiffTime

-- | Maximum time to wait between connection attempts.
maxConnectionAttemptDelay :: DiffTime

-- | Minimum time to wait between ip reconnects
ipRetryDelay :: DiffTime

-- | Time to wait for an AAAA response after receiving an A response.
resolutionDelay :: DiffTime
data SubscriberError
SubscriberError :: !SubscriberErrorType -> !String -> !CallStack -> SubscriberError
[seType] :: SubscriberError -> !SubscriberErrorType
[seMessage] :: SubscriberError -> !String
[seStack] :: SubscriberError -> !CallStack
data SubscriptionTrace addr
SubscriptionTraceConnectStart :: addr -> SubscriptionTrace addr
SubscriptionTraceConnectEnd :: addr -> ConnectResult -> SubscriptionTrace addr
SubscriptionTraceSocketAllocationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceConnectException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceApplicationException :: addr -> e -> SubscriptionTrace addr
SubscriptionTraceTryConnectToPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSkippingPeer :: addr -> SubscriptionTrace addr
SubscriptionTraceSubscriptionRunning :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaiting :: Int -> SubscriptionTrace addr
SubscriptionTraceSubscriptionFailed :: SubscriptionTrace addr
SubscriptionTraceSubscriptionWaitingNewConnection :: DiffTime -> SubscriptionTrace addr
SubscriptionTraceStart :: Int -> SubscriptionTrace addr
SubscriptionTraceRestart :: DiffTime -> Int -> Int -> SubscriptionTrace addr
SubscriptionTraceConnectionExist :: addr -> SubscriptionTrace addr
SubscriptionTraceUnsupportedRemoteAddr :: addr -> SubscriptionTrace addr
SubscriptionTraceMissingLocalAddress :: SubscriptionTrace addr
SubscriptionTraceAllocateSocket :: addr -> SubscriptionTrace addr
SubscriptionTraceCloseSocket :: addr -> SubscriptionTrace addr
data WithIPList a
WithIPList :: LocalAddresses SockAddr -> [SockAddr] -> a -> WithIPList a
[wilSrc] :: WithIPList a -> LocalAddresses SockAddr
[wilDsts] :: WithIPList a -> [SockAddr]
[wilEvent] :: WithIPList a -> a
data DnsTrace
DnsTraceLookupException :: SomeException -> DnsTrace
DnsTraceLookupAError :: DNSError -> DnsTrace
DnsTraceLookupAAAAError :: DNSError -> DnsTrace
DnsTraceLookupIPv6First :: DnsTrace
DnsTraceLookupIPv4First :: DnsTrace
DnsTraceLookupAResult :: [SockAddr] -> DnsTrace
DnsTraceLookupAAAAResult :: [SockAddr] -> DnsTrace
data WithDomainName a
WithDomainName :: Domain -> a -> WithDomainName a
[wdnDomain] :: WithDomainName a -> Domain
[wdnEvent] :: WithDomainName a -> a

module Ouroboros.Network.Subscription.Client
data ClientSubscriptionParams a
ClientSubscriptionParams :: !LocalAddress -> !Maybe DiffTime -> !ErrorPolicies -> ClientSubscriptionParams a

-- | unix socket or named pipe address
[cspAddress] :: ClientSubscriptionParams a -> !LocalAddress

-- | delay between connection attempts
[cspConnectionAttemptDelay] :: ClientSubscriptionParams a -> !Maybe DiffTime

-- | error policies for subscription worker
[cspErrorPolicies] :: ClientSubscriptionParams a -> !ErrorPolicies

-- | Client subscription worker keeps subsribing to the <a>LocalAddress</a>
--   using either unix socket or named pipe.
clientSubscriptionWorker :: LocalSnocket -> Tracer IO (SubscriptionTrace LocalAddress) -> Tracer IO (WithAddr LocalAddress ErrorPolicyTrace) -> NetworkMutableState LocalAddress -> ClientSubscriptionParams a -> (LocalSocket -> IO a) -> IO Void

module Ouroboros.Network.InboundGovernor.State

-- | Currently only <a>StdGen</a>, but in the future this will be extended
--   to a record which contains some useful statistics about peers to
--   support more advances prune strategies (see. <tt>PruneStrategy</tt>).
newtype InboundGovernorObservableState
InboundGovernorObservableState :: StdGen -> InboundGovernorObservableState
[igosPrng] :: InboundGovernorObservableState -> StdGen

-- | Create new observable state <a>StrictTVar</a>.
newObservableStateVar :: MonadLabelledSTM m => StdGen -> m (StrictTVar m InboundGovernorObservableState)

-- | Using the global <a>StdGen</a>.
newObservableStateVarIO :: IO (StrictTVar IO InboundGovernorObservableState)

-- | Useful for testing, it is using <a>mkStdGen</a>.
newObservableStateVarFromSeed :: MonadLabelledSTM m => Int -> m (StrictTVar m InboundGovernorObservableState)

-- | <a>InboundGovernorState</a>, which consist of pure part, and a mutable
--   part. The mutable part can be observable from outside. Future version
--   could contain additional statistics on the peers.
data InboundGovernorState muxMode peerAddr m a b
InboundGovernorState :: !Map (ConnectionId peerAddr) (ConnectionState muxMode peerAddr m a b) -> !StrictTVar m InboundGovernorObservableState -> !Cache InboundGovernorCounters -> InboundGovernorState muxMode peerAddr m a b

-- | Map of connections state. Modifying <a>igsConnections</a> outside of
--   <tt>inboundGovernorLoop</tt> is not safe.
[igsConnections] :: InboundGovernorState muxMode peerAddr m a b -> !Map (ConnectionId peerAddr) (ConnectionState muxMode peerAddr m a b)

-- | PRNG available to <a>PrunePolicy</a>.
[igsObservableVar] :: InboundGovernorState muxMode peerAddr m a b -> !StrictTVar m InboundGovernorObservableState

-- | <a>InboundGovernorCounters</a> counters cache. Allows to only trace
--   values when necessary.
[igsCountersCache] :: InboundGovernorState muxMode peerAddr m a b -> !Cache InboundGovernorCounters

-- | Per connection state tracked by <i>inbound protocol governor</i>.
data ConnectionState muxMode peerAddr m a b
ConnectionState :: !Mux muxMode m -> !DataFlow -> !Map MiniProtocolNum (MiniProtocolData muxMode m a b) -> !Map MiniProtocolNum (STM m (Either SomeException b)) -> !RemoteState m -> ConnectionState muxMode peerAddr m a b

-- | Mux interface.
[csMux] :: ConnectionState muxMode peerAddr m a b -> !Mux muxMode m

-- | Connection data flow.
[csDataFlow] :: ConnectionState muxMode peerAddr m a b -> !DataFlow

-- | All supported mini-protocols and respective <a>ProtocolTemperature</a>
[csMiniProtocolMap] :: ConnectionState muxMode peerAddr m a b -> !Map MiniProtocolNum (MiniProtocolData muxMode m a b)

-- | Map of all running mini-protocol completion STM actions.
[csCompletionMap] :: ConnectionState muxMode peerAddr m a b -> !Map MiniProtocolNum (STM m (Either SomeException b))

-- | State of the connection.
[csRemoteState] :: ConnectionState muxMode peerAddr m a b -> !RemoteState m

-- | Counters for tracing and analysis purposes
data InboundGovernorCounters
InboundGovernorCounters :: !Int -> !Int -> !Int -> !Int -> InboundGovernorCounters

-- | the number of remote peers which are in <a>RemoteCold</a> state
[coldPeersRemote] :: InboundGovernorCounters -> !Int

-- | the number of remote peers which are in <a>RemoteIdle</a> state
[idlePeersRemote] :: InboundGovernorCounters -> !Int

-- | the number of remote peers which are in <a>RemoteWarm</a> state (a
--   close approximation of peers that have the node as a warm peer)
[warmPeersRemote] :: InboundGovernorCounters -> !Int

-- | the number of remote peers which are in <a>RemoteHot</a> state (a
--   close approximation of peers that have the node as a hot peer)
[hotPeersRemote] :: InboundGovernorCounters -> !Int
inboundGovernorCounters :: InboundGovernorState muxMode peerAddr m a b -> InboundGovernorCounters

-- | Remove connection from <a>InboundGovernorState</a>.
unregisterConnection :: Ord peerAddr => ConnectionId peerAddr -> InboundGovernorState muxMode peerAddr m a b -> InboundGovernorState muxMode peerAddr m a b

-- | Update a mini-protocol in <a>ConnectionState</a>. Once a mini-protocol
--   was restarted we put the new completion action into
--   <a>csCompletionMap</a>.
updateMiniProtocol :: Ord peerAddr => ConnectionId peerAddr -> MiniProtocolNum -> STM m (Either SomeException b) -> InboundGovernorState muxMode peerAddr m a b -> InboundGovernorState muxMode peerAddr m a b

-- | Each inbound connection is either in <a>RemoteIdle</a>,
--   <a>RemoteCold</a> or <a>RemoteEstablished</a> state. We only need to
--   support <tt>PromotedToWarm^{Duplex}_{Remote}</tt>,
--   <tt>DemotedToCold^{Duplex}_{Remote}</tt> and
--   <tt>DemotedToCold^{Unidirectional}_{Remote}</tt> transitions.
data RemoteState m

-- | After <tt>PromotedToWarm^{dataFlow}_{Remote}</tt> a connection is in
--   <a>RemoteWarm</a> state.
RemoteWarm :: RemoteState m

-- | In this state all established and hot mini-protocols are running and
--   none of the warm mini-protocols is running.
RemoteHot :: RemoteState m

-- | After <tt>DemotedToCold^{dataFlow}_{Remote}</tt> is detected. This
--   state corresponds to <tt>InboundIdleState</tt>. In this state we are
--   checking if the responder protocols are idle during protocol idle
--   timeout (represented by an <a>STM</a> action)
--   
--   <a>RemoteIdle</a> is the initial state of an accepted a connection.
RemoteIdle :: !STM m () -> RemoteState m

-- | The <a>RemoteCold</a> state for <a>Duplex</a> connections allows us to
--   have responders started using the on-demand strategy. This assures
--   that once the remote peer start using the connection the local side
--   will be ready to serve it.
--   
--   For a <a>Duplex</a> connection: a <a>RemoteIdle</a> connection
--   transitions to <a>RemoteCold</a> state after all responders being idle
--   for <tt>protocolIdleTimeout</tt>. This triggers
--   <a>unregisterInboundConnection</a>.
--   
--   For a <tt>Unidreictional</tt> connection: after all responders
--   terminated.
RemoteCold :: RemoteState m
pattern RemoteEstablished :: RemoteState m

-- | Set <a>csRemoteState</a> for a given connection.
updateRemoteState :: Ord peerAddr => ConnectionId peerAddr -> RemoteState m -> InboundGovernorState muxMode peerAddr m a b -> InboundGovernorState muxMode peerAddr m a b
mapRemoteState :: Ord peerAddr => ConnectionId peerAddr -> (RemoteState m -> RemoteState m) -> InboundGovernorState muxMode peerAddr m a b -> InboundGovernorState muxMode peerAddr m a b
data MiniProtocolData muxMode m a b
MiniProtocolData :: !MiniProtocol muxMode ByteString m a b -> !ProtocolTemperature -> MiniProtocolData muxMode m a b

-- | Static <a>MiniProtocol</a> description.
[mpdMiniProtocol] :: MiniProtocolData muxMode m a b -> !MiniProtocol muxMode ByteString m a b

-- | Static mini-protocol temperature.
[mpdMiniProtocolTemp] :: MiniProtocolData muxMode m a b -> !ProtocolTemperature
instance GHC.Show.Show Ouroboros.Network.InboundGovernor.State.InboundGovernorCounters
instance GHC.Classes.Ord Ouroboros.Network.InboundGovernor.State.InboundGovernorCounters
instance GHC.Classes.Eq Ouroboros.Network.InboundGovernor.State.InboundGovernorCounters
instance GHC.Base.Semigroup Ouroboros.Network.InboundGovernor.State.InboundGovernorCounters
instance GHC.Base.Monoid Ouroboros.Network.InboundGovernor.State.InboundGovernorCounters


-- | Implementation of <a>ConnectionHandler</a>
--   
--   While connection manager responsibility is to keep track of resources:
--   sockets and threads running connection and their state changes
--   (including changes imposed by <a>ConnectionHandler</a>, e.g. weather a
--   uni- or duplex- data flow was negotiated), the responsibility of
--   <a>ConnectionHandler</a> is to:
--   
--   <ul>
--   <li>run handshake protocol on the underlying bearer</li>
--   <li>start mux</li>
--   </ul>
--   
--   <a>ConnectionHandler</a> is run on each inbound or outbound connection
--   and returns <a>Handle</a>. Upon successful handshake negotiation it
--   returns all the necessary information to run mini-protocols. Note that
--   it is not responsible for running them: that's what a server does or
--   p2p-governor by means of <tt>PeerStateActions</tt>.
module Ouroboros.Network.ConnectionHandler

-- | States of the connection handler thread.
--   
--   <ul>
--   <li><tt>MuxRunning</tt> - successful Handshake, mux started</li>
--   <li><a>HandleHandshakeClientError</a></li>
--   <li>the connection handler thread was running client side of the
--   handshake negotiation, which failed with a
--   <a>HandshakeException</a></li>
--   <li><a>HandleHandshakeServerError</a></li>
--   <li>the connection handler thread was running server side of the
--   handshake protocol, which fail with <a>HandshakeException</a></li>
--   <li><a>HandleError</a></li>
--   <li>the multiplexer thrown <a>MuxError</a>.</li>
--   </ul>
data Handle (muxMode :: MuxMode) peerAddr bytes m a b
Handle :: !Mux muxMode m -> !MuxBundle muxMode bytes m a b -> !Bundle (StrictTVar m ControlMessage) -> Handle (muxMode :: MuxMode) peerAddr bytes m a b
[hMux] :: Handle (muxMode :: MuxMode) peerAddr bytes m a b -> !Mux muxMode m
[hMuxBundle] :: Handle (muxMode :: MuxMode) peerAddr bytes m a b -> !MuxBundle muxMode bytes m a b
[hControlMessage] :: Handle (muxMode :: MuxMode) peerAddr bytes m a b -> !Bundle (StrictTVar m ControlMessage)
data HandleError (muxMode :: MuxMode) versionNumber
[HandleHandshakeClientError] :: HasInitiator muxMode ~ True => !HandshakeException versionNumber -> HandleError muxMode versionNumber
[HandleHandshakeServerError] :: HasResponder muxMode ~ True => !HandshakeException versionNumber -> HandleError muxMode versionNumber
[HandleError] :: !SomeException -> HandleError muxMode versionNumber
classifyHandleError :: HandleError muxMode versionNumber -> HandleErrorType

-- | Type of <a>ConnectionHandler</a> implemented in this module.
type MuxConnectionHandler muxMode socket peerAddr versionNumber versionData bytes m a b = ConnectionHandler muxMode (ConnectionHandlerTrace versionNumber versionData) socket peerAddr (Handle muxMode peerAddr bytes m a b) (HandleError muxMode versionNumber) (versionNumber, versionData) m

-- | To be used as <a>makeConnectionHandler</a> field of
--   <tt>ConnectionManagerArguments</tt>.
--   
--   Note: We need to pass <a>MiniProtocolBundle</a> what forces us to have
--   two different <a>ConnectionManager</a>s: one for `node-to-client` and
--   another for `node-to-node` connections. But this is ok, as these
--   resources are independent.
makeConnectionHandler :: forall peerAddr muxMode socket versionNumber versionData m a b. (MonadAsync m, MonadCatch m, MonadFork m, MonadLabelledSTM m, MonadThrow (STM m), MonadTime m, MonadTimer m, MonadMask m, Ord versionNumber, Show peerAddr, Typeable peerAddr) => Tracer m (WithMuxBearer (ConnectionId peerAddr) MuxTrace) -> SingMuxMode muxMode -> HandshakeArguments (ConnectionId peerAddr) versionNumber versionData m -> Versions versionNumber versionData (OuroborosBundle muxMode peerAddr ByteString m a b) -> (ThreadId m, RethrowPolicy) -> MuxConnectionHandler muxMode socket peerAddr versionNumber versionData ByteString m a b

-- | Type alias for <a>ConnectionManager</a> using <a>Handle</a>.
type MuxConnectionManager muxMode socket peerAddr versionNumber bytes m a b = ConnectionManager muxMode socket peerAddr (Handle muxMode peerAddr bytes m a b) (HandleError muxMode versionNumber) m

-- | <a>ConnectionHandlerTrace</a> is embedded into
--   <a>ConnectionManagerTrace</a> with <a>ConnectionHandlerTrace</a>
--   constructor. It already includes <a>ConnectionId</a> so we don't need
--   to take care of it here.
--   
--   TODO: when <tt>Handshake</tt> will get its own tracer, independent of
--   <a>Mux</a>, it should be embedded into <a>ConnectionHandlerTrace</a>.
data ConnectionHandlerTrace versionNumber versionData
TrHandshakeSuccess :: versionNumber -> versionData -> ConnectionHandlerTrace versionNumber versionData
TrHandshakeClientError :: HandshakeException versionNumber -> ConnectionHandlerTrace versionNumber versionData
TrHandshakeServerError :: HandshakeException versionNumber -> ConnectionHandlerTrace versionNumber versionData
TrError :: ErrorContext -> SomeException -> ErrorCommand -> ConnectionHandlerTrace versionNumber versionData
instance (GHC.Show.Show versionNumber, GHC.Show.Show versionData) => GHC.Show.Show (Ouroboros.Network.ConnectionHandler.ConnectionHandlerTrace versionNumber versionData)
instance GHC.Show.Show versionNumber => GHC.Show.Show (Ouroboros.Network.ConnectionHandler.HandleError muxMode versionNumber)


-- | Intended to be imported qualified.
module Ouroboros.Network.InboundGovernor.ControlChannel

-- | Announcment message for a new connection.
data NewConnection peerAddr handle

-- | Announce a new connection. <i>Inbound protocol governor</i> will start
--   responder protocols using <tt>StartOnDemand</tt> strategy and monitor
--   remote transitions: <tt>PromotedToWarm^{Duplex}_{Remote}</tt> and
--   <tt>DemotedToCold^{dataFlow}_{Remote}</tt>.
NewConnection :: !Provenance -> !ConnectionId peerAddr -> !DataFlow -> !handle -> NewConnection peerAddr handle

-- | Server control channel. It allows to pass <a>STM</a> transactions
--   which will resolve to <a>NewConnection</a>. Server's monitoring thread
--   is the consumer of this messages; there are two produceres: accept
--   loop and connection handler for outbound connections.
data ControlChannel m msg
ControlChannel :: STM m msg -> (msg -> STM m ()) -> ControlChannel m msg

-- | Read a single <a>NewConnection</a> instructrion from the channel.
[readMessage] :: ControlChannel m msg -> STM m msg

-- | Write a <a>NewConnection</a> to the channel.
[writeMessage] :: ControlChannel m msg -> msg -> STM m ()
type ServerControlChannel (muxMode :: MuxMode) peerAddr bytes m a b = ControlChannel m (NewConnection peerAddr (Handle muxMode peerAddr bytes m a b))
newControlChannel :: forall m srvCntrlMsg. MonadLabelledSTM m => m (ControlChannel m srvCntrlMsg)
newOutboundConnection :: ControlChannel m (NewConnection peerAddr handle) -> ConnectionId peerAddr -> DataFlow -> handle -> STM m ()
newInboundConnection :: ControlChannel m (NewConnection peerAddr handle) -> ConnectionId peerAddr -> DataFlow -> handle -> STM m ()
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.InboundGovernor.ControlChannel.NewConnection peerAddr handle)

module Ouroboros.Network.InboundGovernor.Event

-- | Edge triggered events to which the <i>inbound protocol governor</i>
--   reacts.
data Event (muxMode :: MuxMode) peerAddr m a b

-- | A request to start mini-protocol bundle, either from the server or
--   from connection manager after a duplex connection was negotiated.
NewConnection :: !NewConnection peerAddr (Handle muxMode peerAddr ByteString m a b) -> Event (muxMode :: MuxMode) peerAddr m a b

-- | A multiplexer exited.
MuxFinished :: !ConnectionId peerAddr -> !Maybe SomeException -> Event (muxMode :: MuxMode) peerAddr m a b

-- | A mini-protocol terminated either cleanly or abruptly.
MiniProtocolTerminated :: !Terminated muxMode peerAddr m a b -> Event (muxMode :: MuxMode) peerAddr m a b

-- | Transition from <a>RemoteEstablished</a> to <a>RemoteIdle</a>.
WaitIdleRemote :: !ConnectionId peerAddr -> Event (muxMode :: MuxMode) peerAddr m a b

-- | A remote <tt>warm → hot</tt> transition. It is scheduled as soon as
--   all hot mini-protocols are running.
RemotePromotedToHot :: !ConnectionId peerAddr -> Event (muxMode :: MuxMode) peerAddr m a b

-- | A <tt>hot → warm</tt> transition. It is scheduled as soon as any hot
--   mini-protocol terminates.
RemoteDemotedToWarm :: !ConnectionId peerAddr -> Event (muxMode :: MuxMode) peerAddr m a b

-- | Transition from <a>RemoteIdle</a> to <a>RemoteCold</a>.
CommitRemote :: !ConnectionId peerAddr -> Event (muxMode :: MuxMode) peerAddr m a b

-- | Transition from <a>RemoteIdle</a> or <a>RemoteCold</a> to
--   <a>RemoteEstablished</a>.
AwakeRemote :: !ConnectionId peerAddr -> Event (muxMode :: MuxMode) peerAddr m a b

-- | A signal which returns an <a>Event</a>. Signals are combined together
--   and passed used to fold the current state map.
type EventSignal (muxMode :: MuxMode) peerAddr m a b = ConnectionId peerAddr -> ConnectionState muxMode peerAddr m a b -> FirstToFinish (STM m) (Event muxMode peerAddr m a b)

-- | A mux stopped. If mux exited cleanly no error is attached.
firstMuxToFinish :: MonadSTM m => EventSignal muxMode peerAddr m a b

-- | When a mini-protocol terminates we take <a>Terminated</a> out of
--   'ConnectionState and pass it to the main loop. This is just enough to
--   decide if we need to restart a mini-protocol and to do the restart.
data Terminated muxMode peerAddr m a b
Terminated :: !ConnectionId peerAddr -> !Mux muxMode m -> !MiniProtocolData muxMode m a b -> !DataFlow -> !Either SomeException b -> Terminated muxMode peerAddr m a b
[tConnId] :: Terminated muxMode peerAddr m a b -> !ConnectionId peerAddr
[tMux] :: Terminated muxMode peerAddr m a b -> !Mux muxMode m
[tMiniProtocolData] :: Terminated muxMode peerAddr m a b -> !MiniProtocolData muxMode m a b
[tDataFlow] :: Terminated muxMode peerAddr m a b -> !DataFlow
[tResult] :: Terminated muxMode peerAddr m a b -> !Either SomeException b

-- | Detect when one of the mini-protocols terminated.
--   
--   <i>triggers:</i> <a>MiniProtocolTerminated</a>.
firstMiniProtocolToFinish :: MonadSTM m => EventSignal muxMode peerAddr m a b

-- | Detect when one of the peers was promoted to warm, e.g.
--   <tt>PromotedToWarm^{Duplex}_{Remote}</tt> or
--   <tt>PromotedToWarm^{Unidirectional}_{Remote}</tt>.
--   
--   <i>triggers:</i> <tt>PromotedToWarm</tt>
--   
--   Note: The specification only describes
--   <tt>PromotedToWarm^{Duplex}_{Remote}</tt> transition, but here we
--   don't make a distinction on <tt>Duplex</tt> and
--   <tt>Unidirectional</tt> connections.
firstPeerPromotedToWarm :: forall muxMode peerAddr m a b. MonadSTM m => EventSignal muxMode peerAddr m a b

-- | Detect when a first warm peer is promoted to hot (all hot
--   mini-protocols run running).
firstPeerPromotedToHot :: forall muxMode peerAddr m a b. MonadSTM m => EventSignal muxMode peerAddr m a b

-- | Detect when a first hot mini-protocols terminates, which triggers the
--   `RemoteHot → RemoteWarm` transition.
firstPeerDemotedToWarm :: forall muxMode peerAddr m a b. MonadSTM m => EventSignal muxMode peerAddr m a b

-- | Await for first peer demoted to cold, i.e. detect the
--   <tt>DemotedToCold^{Duplex}_{Remote}</tt>.
--   
--   <i>triggers:</i> <a>DemotedToColdRemote</a>
firstPeerDemotedToCold :: MonadSTM m => EventSignal muxMode peerAddr m a b

-- | First peer for which the <a>RemoteIdle</a> timeout expires.
firstPeerCommitRemote :: MonadSTM m => EventSignal muxMode peerAddr m a b


-- | The implementation of connection manager.
module Ouroboros.Network.ConnectionManager.Core

-- | Arguments for a <a>ConnectionManager</a> which are independent of
--   <a>MuxMode</a>.
data ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m
ConnectionManagerArguments :: Tracer m (ConnectionManagerTrace peerAddr handlerTrace) -> Tracer m (TransitionTrace peerAddr (ConnectionState peerAddr handle handleError version m)) -> Tracer m (WithMuxBearer (ConnectionId peerAddr) MuxTrace) -> Maybe peerAddr -> Maybe peerAddr -> (peerAddr -> Maybe AddressType) -> Snocket m socket peerAddr -> DiffTime -> DiffTime -> (version -> DataFlow) -> PrunePolicy peerAddr (STM m) -> AcceptedConnectionsLimit -> ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m

-- | Connection manager tracer.
[cmTracer] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> Tracer m (ConnectionManagerTrace peerAddr handlerTrace)

-- | Trace state transitions.
[cmTrTracer] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> Tracer m (TransitionTrace peerAddr (ConnectionState peerAddr handle handleError version m))

-- | Mux trace.
[cmMuxTracer] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> Tracer m (WithMuxBearer (ConnectionId peerAddr) MuxTrace)

-- | <tt>IPv4</tt> address of the connection manager. If given, outbound
--   connections to an <tt>IPv4</tt> address will bound to it. To use
--   bidirectional <tt>TCP</tt> connections, it must be the same as the
--   server listening <tt>IPv4</tt> address.
[cmIPv4Address] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> Maybe peerAddr

-- | <tt>IPv6</tt> address of the connection manager. If given, outbound
--   connections to an <tt>IPv6</tt> address will bound to it. To use
--   bidirectional <tt>TCP</tt> connections, it must be the same as the
--   server listening <tt>IPv6</tt> address.
[cmIPv6Address] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> Maybe peerAddr
[cmAddressType] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> peerAddr -> Maybe AddressType

-- | Snocket for the <tt>socket</tt> type.
[cmSnocket] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> Snocket m socket peerAddr

-- | <tt>TCP</tt> will held connections in <tt>TIME_WAIT</tt> state for up
--   to two MSL (maximum segment time). On Linux this is set to '60'
--   seconds on other system this might be up to four minutes.
--   
--   This is configurable, so we can set different value in tests.
--   
--   When this timeout expires a connection will transition from
--   <a>TerminatingState</a> to <a>TerminatedState</a>.
[cmTimeWaitTimeout] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> DiffTime

-- | Inactivity timeout before the connection will be reset. It is the
--   timeout attached to the <a>OutboundIdleState</a>.
[cmOutboundIdleTimeout] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> DiffTime

-- | <tt>version</tt> represents the tuple of <tt>versionNumber</tt> and
--   <tt>agreedOptions</tt>.
[connectionDataFlow] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> version -> DataFlow

-- | Prune policy
[cmPrunePolicy] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> PrunePolicy peerAddr (STM m)
[cmConnectionsLimits] :: ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> AcceptedConnectionsLimit

-- | Entry point for using the connection manager. This is a classic
--   <tt>with</tt> style combinator, which cleans resources on exit of the
--   callback (whether cleanly or through an exception).
--   
--   Including a connection (either inbound or outbound) is an idempotent
--   operation on connection manager state. The connection manager will
--   always return the handle that was first to be included in its state.
--   
--   Once an inbound connection is passed to the <a>ConnectionManager</a>,
--   the manager is responsible for the resource.
withConnectionManager :: forall (muxMode :: MuxMode) peerAddr socket handlerTrace handle handleError version m a. (Monad m, MonadLabelledSTM m, MonadTraceSTM m, MonadFork m, MonadAsync m, MonadEvaluate m, MonadFix m, MonadMask m, MonadMonotonicTime m, MonadThrow (STM m), MonadTimer m, Ord peerAddr, Show peerAddr, Typeable peerAddr) => ConnectionManagerArguments handlerTrace socket peerAddr handle handleError version m -> ConnectionHandler muxMode handlerTrace socket peerAddr handle handleError version m -> (handleError -> HandleErrorType) -> InResponderMode muxMode (ControlChannel m (NewConnection peerAddr handle)) -> (ConnectionManager muxMode socket peerAddr handle handleError m -> m a) -> m a

-- | The default value for <a>cmTimeWaitTimeout</a>.
defaultTimeWaitTimeout :: DiffTime

-- | Inactivity timeout. It configures how long to wait since the local
--   side demoted remote peer to <i>cold</i>, before closing the
--   connection.
defaultProtocolIdleTimeout :: DiffTime
defaultResetTimeout :: DiffTime

-- | State of a connection.
data ConnectionState peerAddr handle handleError version m

-- | Each outbound connections starts in this state.
ReservedOutboundState :: ConnectionState peerAddr handle handleError version m

-- | Each inbound connection starts in this state, outbound connection
--   reach this state once <a>connect</a> call returns.
--   
--   note: the async handle is lazy, because it's passed with <a>mfix</a>.
UnnegotiatedState :: !Provenance -> !ConnectionId peerAddr -> Async m () -> ConnectionState peerAddr handle handleError version m

-- | <tt>OutboundState Unidirectional</tt> state.
OutboundUniState :: !ConnectionId peerAddr -> !Async m () -> !handle -> ConnectionState peerAddr handle handleError version m

-- | Either <tt>OutboundState Duplex</tt> or <tt>OutobundState^tau
--   Duplex</tt>.
OutboundDupState :: !ConnectionId peerAddr -> !Async m () -> !handle -> !TimeoutExpired -> ConnectionState peerAddr handle handleError version m

-- | Before connection is reset it is put in <a>OutboundIdleState</a> for
--   the duration of <a>cmOutboundIdleTimeout</a>.
OutboundIdleState :: !ConnectionId peerAddr -> !Async m () -> !handle -> !DataFlow -> ConnectionState peerAddr handle handleError version m
InboundIdleState :: !ConnectionId peerAddr -> !Async m () -> !handle -> !DataFlow -> ConnectionState peerAddr handle handleError version m
InboundState :: !ConnectionId peerAddr -> !Async m () -> !handle -> !DataFlow -> ConnectionState peerAddr handle handleError version m
DuplexState :: !ConnectionId peerAddr -> !Async m () -> !handle -> ConnectionState peerAddr handle handleError version m
TerminatingState :: !ConnectionId peerAddr -> !Async m () -> !Maybe handleError -> ConnectionState peerAddr handle handleError version m
TerminatedState :: !Maybe handleError -> ConnectionState peerAddr handle handleError version m
abstractState :: MaybeUnknown (ConnectionState muxMode peerAddr m a b) -> AbstractState
instance GHC.Classes.Eq (Ouroboros.Network.ConnectionManager.Core.MutableConnState peerAddr handle handleError version m)
instance (GHC.Show.Show peerAddr, GHC.Show.Show handleError, GHC.Show.Show (Control.Monad.Class.MonadFork.ThreadId m), Control.Monad.Class.MonadAsync.MonadAsync m) => GHC.Show.Show (Ouroboros.Network.ConnectionManager.Core.ConnectionState peerAddr handle handleError version m)


-- | Server implementation based on <a>ConnectionManager</a>
module Ouroboros.Network.InboundGovernor

-- | Currently only <a>StdGen</a>, but in the future this will be extended
--   to a record which contains some useful statistics about peers to
--   support more advances prune strategies (see. <tt>PruneStrategy</tt>).
newtype InboundGovernorObservableState
InboundGovernorObservableState :: StdGen -> InboundGovernorObservableState
[igosPrng] :: InboundGovernorObservableState -> StdGen

-- | Create new observable state <a>StrictTVar</a>.
newObservableStateVar :: MonadLabelledSTM m => StdGen -> m (StrictTVar m InboundGovernorObservableState)

-- | Using the global <a>StdGen</a>.
newObservableStateVarIO :: IO (StrictTVar IO InboundGovernorObservableState)

-- | Useful for testing, it is using <a>mkStdGen</a>.
newObservableStateVarFromSeed :: MonadLabelledSTM m => Int -> m (StrictTVar m InboundGovernorObservableState)

-- | Run the server, which consists of the following components:
--   
--   <ul>
--   <li><i>inbound governor</i>, it corresponds to p2p-governor on
--   outbound side</li>
--   <li><i>accept loop(s)</i>, one per given ip address. We support up to
--   one ipv4 address and up to one ipv6 address, i.e. an ipv6 enabled node
--   will run two accept loops on listening on different addresses with
--   shared <i>inbound governor</i>.</li>
--   </ul>
--   
--   The server can be run in either of two <a>MuxMode</a>-es:
--   
--   <ul>
--   <li><a>InitiatorResponderMode</a></li>
--   <li><a>ResponderMode</a></li>
--   </ul>
--   
--   The first one is used in data diffusion for <i>Node-To-Node
--   protocol</i>, while the other is useful for running a server for the
--   <i>Node-To-Client protocol</i>.
inboundGovernor :: forall (muxMode :: MuxMode) socket peerAddr versionNumber m a b. (MonadAsync m, MonadCatch m, MonadEvaluate m, MonadThrow m, MonadThrow (STM m), MonadTime m, MonadTimer m, MonadMask m, Ord peerAddr, HasResponder muxMode ~ True) => Tracer m (RemoteTransitionTrace peerAddr) -> Tracer m (InboundGovernorTrace peerAddr) -> ServerControlChannel muxMode peerAddr ByteString m a b -> DiffTime -> MuxConnectionManager muxMode socket peerAddr versionNumber ByteString m a b -> StrictTVar m InboundGovernorObservableState -> m Void
data InboundGovernorTrace peerAddr
TrNewConnection :: !Provenance -> !ConnectionId peerAddr -> InboundGovernorTrace peerAddr
TrResponderRestarted :: !ConnectionId peerAddr -> !MiniProtocolNum -> InboundGovernorTrace peerAddr
TrResponderStartFailure :: !ConnectionId peerAddr -> !MiniProtocolNum -> !SomeException -> InboundGovernorTrace peerAddr
TrResponderErrored :: !ConnectionId peerAddr -> !MiniProtocolNum -> !SomeException -> InboundGovernorTrace peerAddr
TrResponderStarted :: !ConnectionId peerAddr -> !MiniProtocolNum -> InboundGovernorTrace peerAddr
TrResponderTerminated :: !ConnectionId peerAddr -> !MiniProtocolNum -> InboundGovernorTrace peerAddr
TrPromotedToWarmRemote :: !ConnectionId peerAddr -> !OperationResult AbstractState -> InboundGovernorTrace peerAddr
TrPromotedToHotRemote :: !ConnectionId peerAddr -> InboundGovernorTrace peerAddr
TrDemotedToWarmRemote :: !ConnectionId peerAddr -> InboundGovernorTrace peerAddr

-- | All mini-protocols terminated. The boolean is true if this connection
--   was not used by p2p-governor, and thus the connection will be
--   terminated.
TrDemotedToColdRemote :: !ConnectionId peerAddr -> !OperationResult DemotedToColdRemoteTr -> InboundGovernorTrace peerAddr
TrWaitIdleRemote :: !ConnectionId peerAddr -> !OperationResult AbstractState -> InboundGovernorTrace peerAddr
TrMuxCleanExit :: !ConnectionId peerAddr -> InboundGovernorTrace peerAddr
TrMuxErrored :: !ConnectionId peerAddr -> SomeException -> InboundGovernorTrace peerAddr
TrInboundGovernorCounters :: !InboundGovernorCounters -> InboundGovernorTrace peerAddr
TrRemoteState :: !Map (ConnectionId peerAddr) RemoteSt -> InboundGovernorTrace peerAddr

-- | This case is unexpected at call site.
TrUnexpectedlyFalseAssertion :: !IGAssertionLocation peerAddr -> InboundGovernorTrace peerAddr
TrInboundGovernorError :: !SomeException -> InboundGovernorTrace peerAddr

-- | Remote connection state tracked by inbound protocol governor.
data RemoteSt
RemoteWarmSt :: RemoteSt
RemoteHotSt :: RemoteSt
RemoteIdleSt :: RemoteSt
RemoteColdSt :: RemoteSt

-- | <a>Nothing</a> represents unitialised state.
type RemoteTransition = Transition' (Maybe RemoteSt)
type RemoteTransitionTrace peerAddr = TransitionTrace' peerAddr (Maybe RemoteSt)

-- | Trace for the <tt>AcceptConnectionsLimit</tt> policy.
data AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionRateLimiting :: DiffTime -> Int -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionHardLimit :: Word32 -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionResume :: Int -> AcceptConnectionsPolicyTrace
data Transition' state
Transition :: !state -> !state -> Transition' state
[fromState] :: Transition' state -> !state
[toState] :: Transition' state -> !state
data TransitionTrace' peerAddr state
TransitionTrace :: peerAddr -> Transition' state -> TransitionTrace' peerAddr state
[ttPeerAddr] :: TransitionTrace' peerAddr state -> peerAddr
[ttTransition] :: TransitionTrace' peerAddr state -> Transition' state
instance GHC.Show.Show Ouroboros.Network.InboundGovernor.RemoteSt
instance GHC.Classes.Eq Ouroboros.Network.InboundGovernor.RemoteSt
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.InboundGovernor.IGAssertionLocation peerAddr)
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.InboundGovernor.InboundGovernorTrace peerAddr)


-- | Server implementation based on <a>ConnectionManager</a>
module Ouroboros.Network.Server2

-- | Server static configuration.
data ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b
ServerArguments :: NonEmpty socket -> Snocket m socket peerAddr -> Tracer m (ServerTrace peerAddr) -> Tracer m (RemoteTransitionTrace peerAddr) -> Tracer m (InboundGovernorTrace peerAddr) -> AcceptedConnectionsLimit -> MuxConnectionManager muxMode socket peerAddr versionNumber bytes m a b -> DiffTime -> ServerControlChannel muxMode peerAddr bytes m a b -> StrictTVar m InboundGovernorObservableState -> ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b
[serverSockets] :: ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b -> NonEmpty socket
[serverSnocket] :: ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b -> Snocket m socket peerAddr
[serverTracer] :: ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b -> Tracer m (ServerTrace peerAddr)
[serverTrTracer] :: ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b -> Tracer m (RemoteTransitionTrace peerAddr)
[serverInboundGovernorTracer] :: ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b -> Tracer m (InboundGovernorTrace peerAddr)
[serverConnectionLimits] :: ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b -> AcceptedConnectionsLimit
[serverConnectionManager] :: ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b -> MuxConnectionManager muxMode socket peerAddr versionNumber bytes m a b

-- | Time for which all protocols need to be idle to trigger
--   <tt>DemotedToCold</tt> transition.
[serverInboundIdleTimeout] :: ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b -> DiffTime

-- | Server control var is passed as an argument; this allows to use the
--   server to run and manage responders which needs to be started on
--   inbound connections.
[serverControlChannel] :: ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b -> ServerControlChannel muxMode peerAddr bytes m a b

-- | Observable mutable state.
[serverObservableStateVar] :: ServerArguments (muxMode :: MuxMode) socket peerAddr versionNumber bytes m a b -> StrictTVar m InboundGovernorObservableState

-- | Currently only <a>StdGen</a>, but in the future this will be extended
--   to a record which contains some useful statistics about peers to
--   support more advances prune strategies (see. <tt>PruneStrategy</tt>).
newtype InboundGovernorObservableState
InboundGovernorObservableState :: StdGen -> InboundGovernorObservableState
[igosPrng] :: InboundGovernorObservableState -> StdGen

-- | Create new observable state <a>StrictTVar</a>.
newObservableStateVar :: MonadLabelledSTM m => StdGen -> m (StrictTVar m InboundGovernorObservableState)

-- | Using the global <a>StdGen</a>.
newObservableStateVarIO :: IO (StrictTVar IO InboundGovernorObservableState)

-- | Useful for testing, it is using <a>mkStdGen</a>.
newObservableStateVarFromSeed :: MonadLabelledSTM m => Int -> m (StrictTVar m InboundGovernorObservableState)

-- | Run the server, which consists of the following components:
--   
--   <ul>
--   <li><i>inbound governor</i>, it corresponds to p2p-governor on
--   outbound side</li>
--   <li><i>accept loop(s)</i>, one per given ip address. We support up to
--   one ipv4 address and up to one ipv6 address, i.e. an ipv6 enabled node
--   will run two accept loops on listening on different addresses with
--   shared <i>inbound governor</i>.</li>
--   </ul>
--   
--   The server can be run in either of two <a>MuxMode</a>-es:
--   
--   <ul>
--   <li><a>InitiatorResponderMode</a></li>
--   <li><a>ResponderMode</a></li>
--   </ul>
--   
--   The first one is used in data diffusion for <i>Node-To-Node
--   protocol</i>, while the other is useful for running a server for the
--   <i>Node-To-Client protocol</i>.
run :: forall muxMode socket peerAddr versionNumber m a b. (MonadAsync m, MonadCatch m, MonadEvaluate m, MonadLabelledSTM m, MonadMask m, MonadThrow (STM m), MonadTime m, MonadTimer m, HasResponder muxMode ~ True, Ord peerAddr, Show peerAddr) => ServerArguments muxMode socket peerAddr versionNumber ByteString m a b -> m Void
data ServerTrace peerAddr
TrAcceptConnection :: peerAddr -> ServerTrace peerAddr
TrAcceptError :: SomeException -> ServerTrace peerAddr
TrAcceptPolicyTrace :: AcceptConnectionsPolicyTrace -> ServerTrace peerAddr
TrServerStarted :: [peerAddr] -> ServerTrace peerAddr
TrServerStopped :: ServerTrace peerAddr

-- | similar to <a>TrAcceptConnection</a> but it is logged once the
--   connection is handed to inbound connection manager, e.g. after
--   handshake negotiation.
TrServerError :: SomeException -> ServerTrace peerAddr

-- | Trace for the <tt>AcceptConnectionsLimit</tt> policy.
data AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionRateLimiting :: DiffTime -> Int -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionHardLimit :: Word32 -> AcceptConnectionsPolicyTrace
ServerTraceAcceptConnectionResume :: Int -> AcceptConnectionsPolicyTrace

-- | Remote connection state tracked by inbound protocol governor.
data RemoteSt
RemoteWarmSt :: RemoteSt
RemoteHotSt :: RemoteSt
RemoteIdleSt :: RemoteSt
RemoteColdSt :: RemoteSt

-- | <a>Nothing</a> represents unitialised state.
type RemoteTransition = Transition' (Maybe RemoteSt)
type RemoteTransitionTrace peerAddr = TransitionTrace' peerAddr (Maybe RemoteSt)
instance GHC.Show.Show peerAddr => GHC.Show.Show (Ouroboros.Network.Server2.ServerTrace peerAddr)


-- | This module provides simulation environment and a snocket
--   implementation suitable for <tt>IOSim</tt>.
--   
--   Though this module is designed for simulation / testing, it lives in
--   the library, since it is needed in `ouroboros-network-framework:test`
--   and `ouroboros-network:test' components.
--   
--   TODO: Create a <tt>snocket</tt> package, in order to avoid having to
--   have ouroboros-network-testing as a dependency for this cabal library.
module Simulation.Network.Snocket

-- | A bracket which runs a network simulation. When the simulation
--   terminates it verifies that all listening sockets and all connections
--   are closed. It might throw <a>ResourceException</a>.
withSnocket :: forall m peerAddr a. (MonadCatch m, MonadLabelledSTM m, MonadMask m, MonadTime m, MonadTimer m, MonadThrow (STM m), GlobalAddressScheme peerAddr, Ord peerAddr, Typeable peerAddr, Show peerAddr) => Tracer m (WithAddr (TestAddress peerAddr) (SnocketTrace m (TestAddress peerAddr))) -> BearerInfo -> Map (NormalisedId (TestAddress peerAddr)) (Script BearerInfo) -> (Snocket m (FD m (TestAddress peerAddr)) (TestAddress peerAddr) -> m (ObservableNetworkState (TestAddress peerAddr)) -> m a) -> m a

-- | Simulation accessible network environment consumed by
--   <tt>simSnocket</tt>.
newtype ObservableNetworkState addr
ObservableNetworkState :: Map (NormalisedId addr) addr -> ObservableNetworkState addr

-- | Registry of active connections and respective provider
[onsConnections] :: ObservableNetworkState addr -> Map (NormalisedId addr) addr
data ResourceException addr
NotReleasedListeningSockets :: [addr] -> Maybe SomeException -> ResourceException addr
NotReleasedConnections :: Map (NormalisedId addr) ConnectionState -> Maybe SomeException -> ResourceException addr
data SDUSize
newtype Script a
Script :: NonEmpty a -> Script a
type Size = Int64
data SnocketTrace m addr
STConnecting :: FD_ m addr -> addr -> SnocketTrace m addr
STConnected :: FD_ m addr -> OpenType -> SnocketTrace m addr
STBearerInfo :: BearerInfo -> SnocketTrace m addr
STConnectError :: FD_ m addr -> addr -> IOError -> SnocketTrace m addr
STConnectTimeout :: TimeoutDetail -> SnocketTrace m addr
STBindError :: FD_ m addr -> addr -> IOError -> SnocketTrace m addr
STClosing :: SockType -> Wedge (ConnectionId addr) [addr] -> SnocketTrace m addr

-- | TODO: Document meaning of 'Maybe (Maybe OpenState)'
STClosed :: SockType -> Maybe (Maybe ConnectionState) -> SnocketTrace m addr
STClosingQueue :: Bool -> SnocketTrace m addr
STClosedQueue :: Bool -> SnocketTrace m addr
STAcceptFailure :: SockType -> SomeException -> SnocketTrace m addr
STAccepting :: SnocketTrace m addr
STAccepted :: addr -> SnocketTrace m addr
STBearer :: FD_ m addr -> SnocketTrace m addr
STAttenuatedChannelTrace :: ConnectionId addr -> AttenuatedChannelTrace -> SnocketTrace m addr
data SockType
ListeningSock :: SockType
ConnectionSock :: SockType
UnknownType :: SockType

-- | Either simultaneous open or normal open. Unlike in TCP, only one side
--   will will know that it is doing simultaneous open.
data OpenType

-- | Simultaneous open
SimOpen :: OpenType

-- | Normal open
NormalOpen :: OpenType

-- | Safe constructor of <a>NormalisedId</a>
normaliseId :: Ord addr => ConnectionId addr -> NormalisedId addr

-- | Each bearer info describes outbound and inbound side of a point to
--   point bearer.
data BearerInfo
BearerInfo :: !DiffTime -> (Time -> Size -> (DiffTime, SuccessOrFailure)) -> (Time -> Size -> (DiffTime, SuccessOrFailure)) -> !Maybe Int -> !Maybe Int -> !Maybe (DiffTime, IOErrType) -> !SDUSize -> BearerInfo

-- | How long it take to create a connection
[biConnectionDelay] :: BearerInfo -> !DiffTime

-- | attenuation of inbound side of the bearer, i.e. attenuation used by
--   bearers that were <a>accept</a>ed.
[biInboundAttenuation] :: BearerInfo -> Time -> Size -> (DiffTime, SuccessOrFailure)

-- | attenuation of outbound side of the bearer, i.e. the attenuation used
--   by bearers that were created with <a>connect</a> call.
[biOutboundAttenuation] :: BearerInfo -> Time -> Size -> (DiffTime, SuccessOrFailure)

-- | Maximum number of successful writes for an inbound bearer.
[biInboundWriteFailure] :: BearerInfo -> !Maybe Int

-- | Maximum number of successful writes for an outbound bearer.
[biOutboundWriteFailure] :: BearerInfo -> !Maybe Int

-- | Time after which accept will throw an exception.
--   
--   Currently it only supports two kinds of exceptions, ones that are
--   caught and rethrown by the server (ECONNABORTED), and an exception
--   which would be caught, and delivered to the application via
--   <a>AcceptFailure</a>.
[biAcceptFailures] :: BearerInfo -> !Maybe (DiffTime, IOErrType)

-- | SDU size of the bearer; it will be shared between outbound and inbound
--   sides.
--   
--   Note: shrinking <a>SDUSize</a> means make it larger, as this allows to
--   send fewer chunks through the bearer.
[biSDUSize] :: BearerInfo -> !SDUSize

-- | Error types.
data IOErrType
IOErrConnectionAborted :: IOErrType
IOErrResourceExhausted :: IOErrType
data SuccessOrFailure
Success :: SuccessOrFailure
Failure :: SuccessOrFailure
data TimeoutDetail
WaitingToConnect :: TimeoutDetail
WaitingToBeAccepted :: TimeoutDetail

-- | <a>BearerInfo</a> without attenuation and instantaneous connect delay.
--   It also using the production value of <a>SDUSize</a>.
noAttenuation :: BearerInfo

-- | File descriptor type.
data FD m peerAddr

-- | A type class for global IP address scheme. Every node in the
--   simulation has an ephemeral address. Every node in the simulation has
--   an implicit ipv4 and ipv6 address (if one is not bound by explicitly).
class GlobalAddressScheme addr
getAddressType :: GlobalAddressScheme addr => TestAddress addr -> AddressType
ephemeralAddress :: GlobalAddressScheme addr => AddressType -> Natural -> TestAddress addr

-- | Connection manager supports <tt>IPv4</tt> and <tt>IPv6</tt> addresses.
data AddressType
IPv4Address :: AddressType
IPv6Address :: AddressType
instance GHC.Show.Show Simulation.Network.Snocket.ConnectionState
instance GHC.Classes.Eq Simulation.Network.Snocket.ConnectionState
instance GHC.Show.Show addr => GHC.Show.Show (Simulation.Network.Snocket.NormalisedId addr)
instance GHC.Classes.Ord addr => GHC.Classes.Ord (Simulation.Network.Snocket.NormalisedId addr)
instance GHC.Classes.Eq addr => GHC.Classes.Eq (Simulation.Network.Snocket.NormalisedId addr)
instance GHC.Show.Show addr => GHC.Show.Show (Simulation.Network.Snocket.ObservableNetworkState addr)
instance GHC.Show.Show Simulation.Network.Snocket.IOErrType
instance GHC.Classes.Eq Simulation.Network.Snocket.IOErrType
instance GHC.Show.Show addr => GHC.Show.Show (Simulation.Network.Snocket.ResourceException addr)
instance (GHC.Show.Show addr, GHC.Show.Show event) => GHC.Show.Show (Simulation.Network.Snocket.WithAddr addr event)
instance GHC.Show.Show Simulation.Network.Snocket.SockType
instance GHC.Show.Show Simulation.Network.Snocket.TimeoutDetail
instance GHC.Show.Show Simulation.Network.Snocket.OpenType
instance GHC.Show.Show addr => GHC.Show.Show (Simulation.Network.Snocket.SnocketTrace m addr)
instance GHC.Show.Show addr => GHC.Show.Show (Simulation.Network.Snocket.FD_ m addr)
instance Simulation.Network.Snocket.GlobalAddressScheme GHC.Types.Int
instance (Data.Typeable.Internal.Typeable addr, GHC.Show.Show addr) => GHC.Exception.Type.Exception (Simulation.Network.Snocket.ResourceException addr)
instance GHC.Show.Show Simulation.Network.Snocket.BearerInfo
