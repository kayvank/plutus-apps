-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Small step semantics
--   
--   Small step semantics
@package small-steps
@version 0.1.0.0

module Control.Provenance

-- | The Provenance Monad is just the StateT transformer wrapped in a
--   newtype, where the state is (StrictMaybe t). By running the state
--   transformer with an initial state of SNothing we indicate we are not
--   collecting provenance. With an initial state of (SJust t), we are
--   collecting provenance. If we start off as SNothing, then actions on
--   the state are no-ops and are ignored. We maintain several invariants.
--   If we start with SNothing, we get SNothing, and if we start with
--   (SJust s) we end up with (SJust t)
--   
--   invariant1 (ProvM m) = do (_,SNothing) &lt;- runStateT m SNothing
--   invariant2 (ProvM m) = do (_,SJust t) &lt;- runStateT m (SJust 1)
--   
--   The second invariant is that regardless of whether we compute
--   provenance or not, the non-provenance part is the same. Currently this
--   is enforced by the BlackBox type and its API.
--   
--   invariant3 (ProvM m) = do (ans1,SNothing) &lt;- runStateT m SNothing
--   (ans2,SJust p) &lt;- runStateT m (SJust s) pure(ans1 == ans2)
--   
--   All operations that read the provenance (i.e the state) return a
--   (BlackBox t). BlackBoxes can only be used to modify provenance.
newtype ProvM t m a
ProvM :: StateT (StrictMaybe t) m a -> ProvM t m a

-- | Provenance Object
data PObject

-- | Since PObjects are dynamically typed, What operations are required on
--   a type to act as Provenance? We might want to add or subtract some
--   properties from this list.
type Provenance t = (Typeable t, ToJSON t, Show t, NoThunks t)

-- | A special case of the ProvM Monad, where the state type is Store a
--   (Map Text PObject), where PObject is a dynamically typed value. This
--   allows the collection of a Set of provenance values, indexed by keys
--   of type Text. As in the ProvM monad, if run with <a>runProv</a>
--   operations on the Store are ignored.
type Prov m a = ProvM Store m a

-- | BlackBox is an abstraction barrier. Reading the provenance is always
--   returned in a BlackBox. The only way to open the BlackBox is to use
--   one of the BlackBlox eliminator operations: modifyWithBlackBox or
--   runOtherProv, that merge the contents of the BlackBox into the current
--   provenance. This ensures that there is no easy way for the provenance
--   computation to have an effect on the result of the underlying
--   computation.
data BlackBox t

-- | Lift a computation from the argument monad to the constructed monad.
lift :: (MonadTrans t, Monad m) => m a -> t m a

-- | Overwrite the current provenance with something new.
putM :: Monad m => s -> ProvM s m ()

-- | Extract the current provenance. The result is wrapped in a BlackBox.
--   This ensures that provenance cannot be used in the non-provenance part
--   of the computation.
getM :: Monad m => ProvM s m (BlackBox s)

-- | Modify the provenance if collecting provenance, otherwise do nothing.
modifyM :: Monad m => (t -> t) -> ProvM t m ()
modifyWithBlackBox :: Monad m => BlackBox p -> (p -> t -> t) -> ProvM t m ()

-- | Run the (Prov m a) computation and ignore the provenance part
runProv :: Monad m => Prov m t -> m t

-- | Run the (Prov m a) computation, compute and return the provenance as
--   well as the result.
runWithProv :: Monad m => Prov m t -> m (t, Store)

-- | Run a provenance computation, with provenance s1, and lift the result
--   to a provenance computation with provenance s2. Use the active state
--   of the s2 computation to decide if we actually compute the provenance
--   s1. The s1 result is returned in a BlackBox. This ensures that
--   provenance cannot be used in the non-provenance part of the
--   computation.
runOtherProv :: Monad m => s1 -> ProvM s1 m a -> ProvM s2 m (a, BlackBox s1)

-- | lift a provenenace computation from one provenance type (s1) to
--   another (s2)
liftProv :: Monad m => ProvM s1 m a -> s1 -> (a -> s1 -> s2 -> s2) -> ProvM s2 m a

-- | Return a String representation of the current provenance store.
dump :: Monad m => Prov m String

-- | Run a computation in the underlying monad (m), return that value in
--   the (Prov m) monad. As a side effect store that value under the given
--   key equivalent to: store key m = do { a &lt;- lift m; push key a; pure
--   a}
store :: forall t m. (Provenance t, Monad m) => Text -> m t -> Prov m t

-- | Push a key value pair into the provenance store. Overwrites any
--   existing POjects stored under that key.
push :: (Provenance t, Monad m) => Text -> t -> Prov m ()

-- | Reads the provenance value at a key. The value is returned in a
--   BlackBox. There are 3 reasons the BlackBox may be empty. 1) The
--   computation is not collecting provenance. 2) The map does not contain
--   the key 3) The value at the key has the wrong type.
pull :: forall t m. (Monad m, Typeable t) => Text -> Prov m (BlackBox t)

-- | Modify the value stored at the given key. If the key isn't found or
--   the PObject at that key has the wrong type, do nothing.
update :: forall t m. (Provenance t, Monad m) => Text -> (t -> t) -> Prov m ()

-- | Modify the value stored at the given key using a value in a BlackBox.
--   if the key isn't found, or the PObject at that key has the wrong type,
--   do nothing.
updateWithBlackBox :: forall t m s. (Provenance t, Monad m) => Text -> BlackBox s -> (s -> t -> t) -> Prov m ()

-- | Push the provenance of a computation, under the given key. The
--   computation has provenance s1, and lift the result to a provenance
--   computation with provenance Store. Use the active state of the Store
--   computation to decide if we actually want to compute the provenance
--   s1, and push it, or simply ignore it.
pushOtherProv :: (Provenance s1, Monad m) => Text -> s1 -> ProvM s1 m a -> ProvM Store m a

-- | Run and compute the result as well as the provenance. Supply an
--   initial value for the provenance.
runWithProvM :: Monad m => s -> ProvM s m a -> m (a, s)

-- | Run the computation with SNothing. Expend no resources to compute
--   provenance.
runProvM :: Monad m => ProvM s m b -> m b

-- | Find a value for a given key from a Store (Map Text PObject). If the
--   Store does not have that key, or the PObject at that key does not have
--   the right type, returns SNothing. If the type context of the call does
--   not fix the type, one can use a type application like: find @Bool key
--   map
find :: forall t k. (Ord k, Typeable t) => k -> Map k PObject -> StrictMaybe t

-- | Turn a Map of PObjects into a String, indicating its contents.
observe :: Store -> String
preservesNothing :: Monad m => ProvM t m a -> m Bool
preservesJust :: Monad m => t -> ProvM t m a -> m Bool
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Provenance.ProvM t m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Provenance.ProvM t m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Provenance.ProvM t m)
instance GHC.Base.Functor Control.Provenance.BlackBox
instance GHC.Show.Show t => GHC.Show.Show (Control.Provenance.BlackBox t)
instance NoThunks.Class.NoThunks Control.Provenance.PObject
instance GHC.Show.Show Control.Provenance.PObject
instance Control.Monad.Trans.Class.MonadTrans (Control.Provenance.ProvM t)


-- | Small step state transition systems.
module Control.State.Transition.Extended
data RuleType
Initial :: RuleType
Transition :: RuleType
class RuleTypeRep t
type family RuleContext (t :: RuleType) = (ctx :: Type -> Type) | ctx -> t

-- | Context available to initial rules.
newtype IRC sts
IRC :: Environment sts -> IRC sts

-- | Context available to transition rules.
newtype TRC sts
TRC :: (Environment sts, State sts, Signal sts) -> TRC sts
type Rule sts rtype = F (Clause sts rtype)
type TransitionRule sts = Rule sts 'Transition (State sts)
type InitialRule sts = Rule sts 'Initial (State sts)

-- | An assertion is a validation condition for the STS system in question.
--   It should be used to define properties of the system as a whole that
--   cannot be violated under normal circumstances - e.g. a violation
--   implies a failing in the rule logic.
--   
--   Assertions should not check for conditions that may differ between
--   different rules in a system, since the interpreter may stop the system
--   upon presence of a failed assertion.
--   
--   Whether assertions are checked is a matter for the STS interpreter.
data Assertion sts

-- | Pre-condition. Checked before the rule fires.
PreCondition :: String -> (TRC sts -> Bool) -> Assertion sts

-- | Post-condition. Checked after the rule fires, and given access to the
--   resultant state as well as the initial context.
PostCondition :: String -> (TRC sts -> State sts -> Bool) -> Assertion sts
data AssertionViolation sts
AssertionViolation :: String -> String -> TRC sts -> Maybe (State sts) -> AssertionViolation sts
[avSTS] :: AssertionViolation sts -> String
[avMsg] :: AssertionViolation sts -> String
[avCtx] :: AssertionViolation sts -> TRC sts
[avState] :: AssertionViolation sts -> Maybe (State sts)
data AssertionException
[AssertionException] :: forall sts. STS sts => AssertionViolation sts -> AssertionException

-- | State transition system.
class (Eq (PredicateFailure a), Show (PredicateFailure a), Monad (BaseM a), Typeable a) => STS a where {
    
    -- | Type of the state which the system transitions between.
    type family State a :: Type;
    
    -- | Signal triggering a state change.
    type family Signal a :: Type;
    
    -- | Environment type.
    type family Environment a :: Type;
    
    -- | Monad into which to interpret the rules.
    type family BaseM a :: Type -> Type;
    
    -- | Event type.
    type family Event a :: Type;
    
    -- | Descriptive type for the possible failures which might cause a
    --   transition to fail.
    --   
    --   As a convention, <a>PredicateFailure</a>s which are "structural"
    --   (meaning that they are not "throwable" in practice, and are used to
    --   pass control from one transition rule to another) are prefixed with
    --   <tt>S_</tt>.
    --   
    --   Structural <a>PredicateFailure</a>s represent conditions between rules
    --   where the disjunction of all rules' preconditions is equal to
    --   <a>True</a>. That is, either one rule will throw a structural
    --   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
    type family PredicateFailure a :: Type;
    type BaseM a = Identity;
    type Event a = Void;
}

-- | Rules governing transition under this system.
initialRules :: STS a => [InitialRule a]

-- | Rules governing transition under this system.
initialRules :: (STS a, Default (State a)) => [InitialRule a]
transitionRules :: STS a => [TransitionRule a]

-- | Assertions about the transition system.
assertions :: STS a => [Assertion a]

-- | Render an assertion violation.
--   
--   Defaults to using <a>show</a>, but note that this does not know how to
--   render the context. So for more information you should define your own
--   renderer here.
renderAssertionViolation :: STS a => AssertionViolation a -> String

-- | A stub rule with no transitions to use as a placeholder
data STUB (e :: Type) (st :: Type) (si :: Type) (f :: Type) (m :: Type -> Type)

-- | Embed one STS within another.
class (STS sub, BaseM sub ~ BaseM super) => Embed sub super

-- | Wrap a predicate failure of the subsystem in a failure of the
--   super-system.
wrapFailed :: Embed sub super => PredicateFailure sub -> PredicateFailure super
wrapEvent :: Embed sub super => Event sub -> Event super
wrapEvent :: (Embed sub super, Coercible (Event sub) (Event super)) => Event sub -> Event super

-- | Oh noes!
--   
--   This takes a condition (a boolean expression) and a failure and
--   results in a clause which will throw that failure if the condition
--   fails.
(?!) :: Bool -> PredicateFailure sts -> Rule sts ctx ()
infix 1 ?!

-- | Oh noes with an explanation
--   
--   We interpret this as "What?" "No!" "Because:"
(?!:) :: Either e () -> (e -> PredicateFailure sts) -> Rule sts ctx ()

-- | Fail with <a>PredicateFailure</a>'s in STS if <a>Validation</a> was
--   unsuccessful.
validate :: Validation (NonEmpty (PredicateFailure sts)) () -> Rule sts ctx ()

-- | Same as <tt>validation</tt>, except with ability to transform opaque
--   failures into <a>PredicateFailure</a>s with a help of supplied
--   function.
validateTrans :: (e -> PredicateFailure sts) -> Validation (NonEmpty e) () -> Rule sts ctx ()

-- | Same as <tt>validation</tt>, except with ability to translate opaque
--   failures into <a>PredicateFailure</a>s with a help of supplied
--   function.
validateTransLabeled :: (e -> PredicateFailure sts) -> NonEmpty Label -> Validation (NonEmpty e) () -> Rule sts ctx ()

-- | Label for a predicate. This can be used to control which predicates
--   get run.
type Label = String
data SingEP ep
[EPReturn] :: SingEP 'EventPolicyReturn
[EPDiscard] :: SingEP 'EventPolicyDiscard
data EventPolicy
EventPolicyReturn :: EventPolicy
EventPolicyDiscard :: EventPolicy
type family EventReturnType ep sts a :: Type

-- | Labeled clause. This will only be executed if the interpreter is set
--   to execute clauses with this label.
labeled :: NonEmpty Label -> Rule sts ctx () -> Rule sts ctx ()

-- | Labeled predicate. This may be used to control which predicates are
--   run using <a>ValidateSuchThat</a>.
labeledPred :: NonEmpty Label -> Bool -> PredicateFailure sts -> Rule sts ctx ()

-- | Labeled predicate with an explanation
labeledPredE :: NonEmpty Label -> Either e () -> (e -> PredicateFailure sts) -> Rule sts ctx ()
ifFailureFree :: Rule sts rtype a -> Rule sts rtype a -> Rule sts rtype a
whenFailureFree :: Rule sts rtype () -> Rule sts rtype ()
failBecause :: PredicateFailure sts -> Rule sts ctx ()

-- | Get the judgment context
judgmentContext :: Rule sts rtype (RuleContext rtype sts)
trans :: Embed sub super => RuleContext rtype sub -> Rule super rtype (State sub)
liftSTS :: STS sts => BaseM sts a -> Rule sts ctx a
tellEvent :: Event sts -> Rule sts ctx ()
tellEvents :: [Event sts] -> Rule sts ctx ()
class EventReturnTypeRep ert

-- | Map over an arbitrary <a>EventReturnType</a>.
mapEventReturn :: forall ep sts a b. EventReturnTypeRep ep => (a -> b) -> EventReturnType ep sts a -> EventReturnType ep sts b

-- | Control which assertions are enabled.
data AssertionPolicy
AssertionsAll :: AssertionPolicy

-- | Only run preconditions
AssertionsPre :: AssertionPolicy

-- | Only run postconditions
AssertionsPost :: AssertionPolicy
AssertionsOff :: AssertionPolicy

-- | Control which predicates are evaluated during rule processing.
data ValidationPolicy
ValidateAll :: ValidationPolicy
ValidateNone :: ValidationPolicy
ValidateSuchThat :: ([Label] -> Bool) -> ValidationPolicy
data ApplySTSOpts ep
ApplySTSOpts :: AssertionPolicy -> ValidationPolicy -> SingEP ep -> ApplySTSOpts ep

-- | Enable assertions during STS processing. If this option is enabled,
--   STS processing will terminate on violation of an assertion.
[asoAssertions] :: ApplySTSOpts ep -> AssertionPolicy

-- | Validation policy
[asoValidation] :: ApplySTSOpts ep -> ValidationPolicy

-- | Event policy
[asoEvents] :: ApplySTSOpts ep -> SingEP ep

-- | Apply an STS with options. Note that this returns both the final state
--   and the list of predicate failures.
applySTSOpts :: forall s m rtype ep. (STS s, RuleTypeRep rtype, m ~ BaseM s) => ApplySTSOpts ep -> RuleContext rtype s -> m (EventReturnType ep s (State s, [PredicateFailure s]))
applySTSOptsEither :: forall s m rtype ep. (STS s, RuleTypeRep rtype, m ~ BaseM s) => ApplySTSOpts ep -> RuleContext rtype s -> m (Either [PredicateFailure s] (EventReturnType ep s (State s)))
applySTS :: forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> m (Either [PredicateFailure s] (State s))
applySTSIndifferently :: forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> m (State s, [PredicateFailure s])

-- | Re-apply an STS.
--   
--   It is assumed that the caller of this function has previously applied
--   this STS, and can guarantee that it completed successfully. No
--   predicates or assertions will be checked when calling this function.
reapplySTS :: forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> m (State s)
globalAssertionPolicy :: AssertionPolicy
applySTSInternal :: forall s m rtype ep. (STS s, RuleTypeRep rtype, m ~ BaseM s) => SingEP ep -> AssertionPolicy -> RuleInterpreter ep -> RuleContext rtype s -> ExceptT (AssertionViolation s) m (EventReturnType ep s (State s, [PredicateFailure s]))

-- | Apply a rule even if its predicates fail.
--   
--   If the rule successfully applied, the list of predicate failures will
--   be empty.
applyRuleInternal :: forall (ep :: EventPolicy) s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => IsFailing -> SingEP ep -> ValidationPolicy -> (IsFailing -> STSInterpreter ep) -> RuleContext rtype s -> Rule s rtype (State s) -> m (EventReturnType ep s (State s, [PredicateFailure s]))
type RuleInterpreter ep = forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> Rule s rtype (State s) -> m (EventReturnType ep s (State s, [PredicateFailure s]))
type STSInterpreter ep = forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> m (EventReturnType ep s (State s, [PredicateFailure s]))

-- | This can be used to specify predicate failures in STS rules where a
--   value is beyond a certain threshold.
--   
--   TODO move this somewhere more sensible
newtype Threshold a
Threshold :: a -> Threshold a

-- | <a>sfor_</a> is <a>straverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sfor_ ([1..4] :: [Int]) print
--   1
--   2
--   3
--   4
--   </pre>
sfor_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
instance GHC.Show.Show Control.State.Transition.Extended.IsFailing
instance GHC.Classes.Eq Control.State.Transition.Extended.IsFailing
instance GHC.Show.Show Control.State.Transition.Extended.AssertionPolicy
instance GHC.Classes.Eq Control.State.Transition.Extended.AssertionPolicy
instance NoThunks.Class.NoThunks a => NoThunks.Class.NoThunks (Control.State.Transition.Extended.Threshold a)
instance Data.Data.Data a => Data.Data.Data (Control.State.Transition.Extended.Threshold a)
instance GHC.Show.Show a => GHC.Show.Show (Control.State.Transition.Extended.Threshold a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Control.State.Transition.Extended.Threshold a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Control.State.Transition.Extended.Threshold a)
instance (GHC.Show.Show (Control.State.Transition.Extended.Environment sts), GHC.Show.Show (Control.State.Transition.Extended.State sts), GHC.Show.Show (Control.State.Transition.Extended.Signal sts)) => GHC.Show.Show (Control.State.Transition.Extended.TRC sts)
instance GHC.Base.Functor (Control.State.Transition.Extended.Clause sts rtype)
instance (GHC.Classes.Eq f, GHC.Base.Monad m, GHC.Show.Show f, Data.Typeable.Internal.Typeable e, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable si, Data.Typeable.Internal.Typeable st, Data.Typeable.Internal.Typeable m) => Control.State.Transition.Extended.STS (Control.State.Transition.Extended.STUB e st si f m)
instance GHC.Show.Show Control.State.Transition.Extended.AssertionException
instance GHC.Exception.Type.Exception Control.State.Transition.Extended.AssertionException
instance Control.State.Transition.Extended.STS sts => GHC.Show.Show (Control.State.Transition.Extended.AssertionViolation sts)
instance Control.State.Transition.Extended.STS sts => Control.State.Transition.Extended.Embed sts sts
instance Control.State.Transition.Extended.EventReturnTypeRep 'Control.State.Transition.Extended.EventPolicyReturn
instance Control.State.Transition.Extended.EventReturnTypeRep 'Control.State.Transition.Extended.EventPolicyDiscard
instance Control.State.Transition.Extended.RuleTypeRep 'Control.State.Transition.Extended.Initial
instance Control.State.Transition.Extended.RuleTypeRep 'Control.State.Transition.Extended.Transition


-- | Simple state transition system over the Identity monad.
module Control.State.Transition.Simple
applySTSIndifferently :: forall s rtype. (STS s, RuleTypeRep rtype, Identity ~ BaseM s) => RuleContext rtype s -> (State s, [PredicateFailure s])
applySTS :: forall s rtype. (STS s, RuleTypeRep rtype, BaseM s ~ Identity) => RuleContext rtype s -> Either [PredicateFailure s] (State s)

-- | A stub rule with no transitions to use as a placeholder
data STUB (e :: Type) (st :: Type) (si :: Type) (f :: Type) (m :: Type -> Type)

-- | This can be used to specify predicate failures in STS rules where a
--   value is beyond a certain threshold.
--   
--   TODO move this somewhere more sensible
newtype Threshold a
Threshold :: a -> Threshold a
type RuleInterpreter ep = forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> Rule s rtype (State s) -> m (EventReturnType ep s (State s, [PredicateFailure s]))
type STSInterpreter ep = forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> m (EventReturnType ep s (State s, [PredicateFailure s]))
data ApplySTSOpts ep
ApplySTSOpts :: AssertionPolicy -> ValidationPolicy -> SingEP ep -> ApplySTSOpts ep

-- | Enable assertions during STS processing. If this option is enabled,
--   STS processing will terminate on violation of an assertion.
[asoAssertions] :: ApplySTSOpts ep -> AssertionPolicy

-- | Validation policy
[asoValidation] :: ApplySTSOpts ep -> ValidationPolicy

-- | Event policy
[asoEvents] :: ApplySTSOpts ep -> SingEP ep

-- | Control which predicates are evaluated during rule processing.
data ValidationPolicy
ValidateAll :: ValidationPolicy
ValidateNone :: ValidationPolicy
ValidateSuchThat :: ([Label] -> Bool) -> ValidationPolicy

-- | Control which assertions are enabled.
data AssertionPolicy
AssertionsAll :: AssertionPolicy

-- | Only run preconditions
AssertionsPre :: AssertionPolicy

-- | Only run postconditions
AssertionsPost :: AssertionPolicy
AssertionsOff :: AssertionPolicy

-- | Label for a predicate. This can be used to control which predicates
--   get run.
type Label = String
type Rule sts rtype = F (Clause sts rtype)
class EventReturnTypeRep ert
type family EventReturnType ep sts a :: Type
data SingEP ep
[EPReturn] :: SingEP 'EventPolicyReturn
[EPDiscard] :: SingEP 'EventPolicyDiscard
data EventPolicy
EventPolicyReturn :: EventPolicy
EventPolicyDiscard :: EventPolicy

-- | Embed one STS within another.
class (STS sub, BaseM sub ~ BaseM super) => Embed sub super

-- | Wrap a predicate failure of the subsystem in a failure of the
--   super-system.
wrapFailed :: Embed sub super => PredicateFailure sub -> PredicateFailure super
wrapEvent :: Embed sub super => Event sub -> Event super
wrapEvent :: (Embed sub super, Coercible (Event sub) (Event super)) => Event sub -> Event super

-- | State transition system.
class (Eq (PredicateFailure a), Show (PredicateFailure a), Monad (BaseM a), Typeable a) => STS a where {
    
    -- | Type of the state which the system transitions between.
    type family State a :: Type;
    
    -- | Signal triggering a state change.
    type family Signal a :: Type;
    
    -- | Environment type.
    type family Environment a :: Type;
    
    -- | Monad into which to interpret the rules.
    type family BaseM a :: Type -> Type;
    
    -- | Event type.
    type family Event a :: Type;
    
    -- | Descriptive type for the possible failures which might cause a
    --   transition to fail.
    --   
    --   As a convention, <a>PredicateFailure</a>s which are "structural"
    --   (meaning that they are not "throwable" in practice, and are used to
    --   pass control from one transition rule to another) are prefixed with
    --   <tt>S_</tt>.
    --   
    --   Structural <a>PredicateFailure</a>s represent conditions between rules
    --   where the disjunction of all rules' preconditions is equal to
    --   <a>True</a>. That is, either one rule will throw a structural
    --   <a>PredicateFailure</a> and the other will succeed, or vice-versa.
    type family PredicateFailure a :: Type;
    type BaseM a = Identity;
    type Event a = Void;
}

-- | Rules governing transition under this system.
initialRules :: STS a => [InitialRule a]

-- | Rules governing transition under this system.
initialRules :: (STS a, Default (State a)) => [InitialRule a]
transitionRules :: STS a => [TransitionRule a]

-- | Assertions about the transition system.
assertions :: STS a => [Assertion a]

-- | Render an assertion violation.
--   
--   Defaults to using <a>show</a>, but note that this does not know how to
--   render the context. So for more information you should define your own
--   renderer here.
renderAssertionViolation :: STS a => AssertionViolation a -> String
data AssertionException
[AssertionException] :: forall sts. STS sts => AssertionViolation sts -> AssertionException
data AssertionViolation sts
AssertionViolation :: String -> String -> TRC sts -> Maybe (State sts) -> AssertionViolation sts
[avSTS] :: AssertionViolation sts -> String
[avMsg] :: AssertionViolation sts -> String
[avCtx] :: AssertionViolation sts -> TRC sts
[avState] :: AssertionViolation sts -> Maybe (State sts)

-- | An assertion is a validation condition for the STS system in question.
--   It should be used to define properties of the system as a whole that
--   cannot be violated under normal circumstances - e.g. a violation
--   implies a failing in the rule logic.
--   
--   Assertions should not check for conditions that may differ between
--   different rules in a system, since the interpreter may stop the system
--   upon presence of a failed assertion.
--   
--   Whether assertions are checked is a matter for the STS interpreter.
data Assertion sts

-- | Pre-condition. Checked before the rule fires.
PreCondition :: String -> (TRC sts -> Bool) -> Assertion sts

-- | Post-condition. Checked after the rule fires, and given access to the
--   resultant state as well as the initial context.
PostCondition :: String -> (TRC sts -> State sts -> Bool) -> Assertion sts
type TransitionRule sts = Rule sts 'Transition (State sts)
type InitialRule sts = Rule sts 'Initial (State sts)
type family RuleContext (t :: RuleType) = (ctx :: Type -> Type) | ctx -> t

-- | Context available to transition rules.
newtype TRC sts
TRC :: (Environment sts, State sts, Signal sts) -> TRC sts

-- | Context available to initial rules.
newtype IRC sts
IRC :: Environment sts -> IRC sts
class RuleTypeRep t
data RuleType
Initial :: RuleType
Transition :: RuleType

-- | Map over an arbitrary <a>EventReturnType</a>.
mapEventReturn :: forall ep sts a b. EventReturnTypeRep ep => (a -> b) -> EventReturnType ep sts a -> EventReturnType ep sts b

-- | Fail with <a>PredicateFailure</a>'s in STS if <a>Validation</a> was
--   unsuccessful.
validate :: Validation (NonEmpty (PredicateFailure sts)) () -> Rule sts ctx ()

-- | Same as <tt>validation</tt>, except with ability to transform opaque
--   failures into <a>PredicateFailure</a>s with a help of supplied
--   function.
validateTrans :: (e -> PredicateFailure sts) -> Validation (NonEmpty e) () -> Rule sts ctx ()

-- | Same as <tt>validation</tt>, except with ability to translate opaque
--   failures into <a>PredicateFailure</a>s with a help of supplied
--   function.
validateTransLabeled :: (e -> PredicateFailure sts) -> NonEmpty Label -> Validation (NonEmpty e) () -> Rule sts ctx ()

-- | Oh noes!
--   
--   This takes a condition (a boolean expression) and a failure and
--   results in a clause which will throw that failure if the condition
--   fails.
(?!) :: Bool -> PredicateFailure sts -> Rule sts ctx ()
infix 1 ?!
failBecause :: PredicateFailure sts -> Rule sts ctx ()

-- | Oh noes with an explanation
--   
--   We interpret this as "What?" "No!" "Because:"
(?!:) :: Either e () -> (e -> PredicateFailure sts) -> Rule sts ctx ()

-- | Labeled predicate. This may be used to control which predicates are
--   run using <a>ValidateSuchThat</a>.
labeledPred :: NonEmpty Label -> Bool -> PredicateFailure sts -> Rule sts ctx ()

-- | Labeled predicate with an explanation
labeledPredE :: NonEmpty Label -> Either e () -> (e -> PredicateFailure sts) -> Rule sts ctx ()

-- | Labeled clause. This will only be executed if the interpreter is set
--   to execute clauses with this label.
labeled :: NonEmpty Label -> Rule sts ctx () -> Rule sts ctx ()
trans :: Embed sub super => RuleContext rtype sub -> Rule super rtype (State sub)
ifFailureFree :: Rule sts rtype a -> Rule sts rtype a -> Rule sts rtype a
whenFailureFree :: Rule sts rtype () -> Rule sts rtype ()
liftSTS :: STS sts => BaseM sts a -> Rule sts ctx a

-- | Get the judgment context
judgmentContext :: Rule sts rtype (RuleContext rtype sts)

-- | Apply an STS with options. Note that this returns both the final state
--   and the list of predicate failures.
applySTSOpts :: forall s m rtype ep. (STS s, RuleTypeRep rtype, m ~ BaseM s) => ApplySTSOpts ep -> RuleContext rtype s -> m (EventReturnType ep s (State s, [PredicateFailure s]))
applySTSOptsEither :: forall s m rtype ep. (STS s, RuleTypeRep rtype, m ~ BaseM s) => ApplySTSOpts ep -> RuleContext rtype s -> m (Either [PredicateFailure s] (EventReturnType ep s (State s)))
globalAssertionPolicy :: AssertionPolicy

-- | Re-apply an STS.
--   
--   It is assumed that the caller of this function has previously applied
--   this STS, and can guarantee that it completed successfully. No
--   predicates or assertions will be checked when calling this function.
reapplySTS :: forall s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => RuleContext rtype s -> m (State s)

-- | Apply a rule even if its predicates fail.
--   
--   If the rule successfully applied, the list of predicate failures will
--   be empty.
applyRuleInternal :: forall (ep :: EventPolicy) s m rtype. (STS s, RuleTypeRep rtype, m ~ BaseM s) => IsFailing -> SingEP ep -> ValidationPolicy -> (IsFailing -> STSInterpreter ep) -> RuleContext rtype s -> Rule s rtype (State s) -> m (EventReturnType ep s (State s, [PredicateFailure s]))
applySTSInternal :: forall s m rtype ep. (STS s, RuleTypeRep rtype, m ~ BaseM s) => SingEP ep -> AssertionPolicy -> RuleInterpreter ep -> RuleContext rtype s -> ExceptT (AssertionViolation s) m (EventReturnType ep s (State s, [PredicateFailure s]))

-- | <a>sfor_</a> is <a>straverse_</a> with its arguments flipped. For a
--   version that doesn't ignore the results see <a>for</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sfor_ ([1..4] :: [Int]) print
--   1
--   2
--   3
--   4
--   </pre>
sfor_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
tellEvent :: Event sts -> Rule sts ctx ()
tellEvents :: [Event sts] -> Rule sts ctx ()


-- | Small step state transition systems.
module Control.State.Transition
